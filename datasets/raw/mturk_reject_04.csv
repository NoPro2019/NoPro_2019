HITId,HITTypeId,Title,Description,Keywords,Reward,CreationTime,MaxAssignments,RequesterAnnotation,AssignmentDurationInSeconds,AutoApprovalDelayInSeconds,Expiration,NumberOfSimilarHITs,LifetimeInSeconds,AssignmentId,WorkerId,AssignmentStatus,AcceptTime,SubmitTime,AutoApprovalTime,ApprovalTime,RejectionTime,RequesterFeedback,WorkTimeInSeconds,LifetimeApprovalRate,Last30DaysApprovalRate,Last7DaysApprovalRate,Input.fid_1,Input.file_name_1,Input.function_body_1,Input.comment_body_1,Input.fid_2,Input.file_name_2,Input.function_body_2,Input.comment_body_2,Input.fid_3,Input.file_name_3,Input.function_body_3,Input.comment_body_3,Input.fid_4,Input.file_name_4,Input.function_body_4,Input.comment_body_4,Input.fid_5,Input.file_name_5,Input.function_body_5,Input.comment_body_5,Input.fid_6,Input.file_name_6,Input.function_body_6,Input.comment_body_6,Input.fid_7,Input.file_name_7,Input.function_body_7,Input.comment_body_7,Input.fid_8,Input.file_name_8,Input.function_body_8,Input.comment_body_8,Input.fid_9,Input.file_name_9,Input.function_body_9,Input.comment_body_9,Input.fid_10,Input.file_name_10,Input.function_body_10,Input.comment_body_10,Input.fid_11,Input.file_name_11,Input.function_body_11,Input.comment_body_11,Input.fid_12,Input.file_name_12,Input.function_body_12,Input.comment_body_12,Input.fid_13,Input.file_name_13,Input.function_body_13,Input.comment_body_13,Input.fid_14,Input.file_name_14,Input.function_body_14,Input.comment_body_14,Input.fid_15,Input.file_name_15,Input.function_body_15,Input.comment_body_15,Input.fid_16,Input.file_name_16,Input.function_body_16,Input.comment_body_16,Input.fid_17,Input.file_name_17,Input.function_body_17,Input.comment_body_17,Input.fid_18,Input.file_name_18,Input.function_body_18,Input.comment_body_18,Input.fid_19,Input.file_name_19,Input.function_body_19,Input.comment_body_19,Input.fid_20,Input.file_name_20,Input.function_body_20,Input.comment_body_20,Input.fid_21,Input.file_name_21,Input.function_body_21,Input.comment_body_21,Answer.empty_1,Answer.empty_10,Answer.empty_11,Answer.empty_12,Answer.empty_13,Answer.empty_14,Answer.empty_15,Answer.empty_16,Answer.empty_17,Answer.empty_18,Answer.empty_19,Answer.empty_2,Answer.empty_20,Answer.empty_21,Answer.empty_3,Answer.empty_4,Answer.empty_5,Answer.empty_6,Answer.empty_7,Answer.empty_8,Answer.empty_9,Answer.multiple_1,Answer.multiple_10,Answer.multiple_11,Answer.multiple_12,Answer.multiple_13,Answer.multiple_14,Answer.multiple_15,Answer.multiple_16,Answer.multiple_17,Answer.multiple_18,Answer.multiple_19,Answer.multiple_2,Answer.multiple_20,Answer.multiple_21,Answer.multiple_3,Answer.multiple_4,Answer.multiple_5,Answer.multiple_6,Answer.multiple_7,Answer.multiple_8,Answer.multiple_9,Answer.tag_1,Answer.tag_10,Answer.tag_11,Answer.tag_12,Answer.tag_13,Answer.tag_14,Answer.tag_15,Answer.tag_16,Answer.tag_17,Answer.tag_18,Answer.tag_19,Answer.tag_2,Answer.tag_20,Answer.tag_21,Answer.tag_3,Answer.tag_4,Answer.tag_5,Answer.tag_6,Answer.tag_7,Answer.tag_8,Answer.tag_9,Approve,Reject
371QPA24C2O8COMVIJI1OFC0B6X1TB,37V5OWJ68WQJ5E26AG5FTR2POI1LVJ,Highlight the phrase that best summarizes a source code comment (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Thu May 02 10:10:41 PDT 2019,2,BatchId:3628794;OriginalHitTemplateId:920937336;,3600,172800,Thu May 09 10:10:41 PDT 2019,,,3H8DHMCCW9B5OK9DU5T5D9M20KNKDB,A2CX71WKI4VHVC,Submitted,Fri May 03 08:25:56 PDT 2019,Fri May 03 08:34:02 PDT 2019,Sun May 05 08:34:02 PDT 2019,,,,486,100% (1/1),100% (1/1),0% (0/0),1799853,target.c,"retvalue package_remove_by_cursor(struct package_cursor *tc, struct logger *logger, struct trackingdata *trackingdata) {\newline	struct target * const target = tc-&gttarget;\newline	struct package *old = &amptc-&gtcurrent;\newline	struct strlist files;\newline	retvalue result, r;\newline\newline	assert (target != NULL &amp&amp target-&gtpackages != NULL);\newline	assert (target == old-&gttarget);\newline\newline	if (logger != NULL) {\newline		(void)package_getversion(old);\newline	}\newline	r = old-&gttarget-&gtgetfilekeys(old-&gtcontrol, &ampfiles);\newline	if (RET_WAS_ERROR(r)) {\newline		return r;\newline	}\newline	if (trackingdata != NULL) {\newline		(void)package_getsource(old);\newline	}\newline	if (verbose &gt 0)\newline		printf(&quotremoving &#039%s&#039 from &#039%s&#039...\\n&quot,\newline				old-&gtname, old-&gttarget-&gtidentifier);\newline	result = cursor_delete(target-&gtpackages, tc-&gtcursor, old-&gtname, NULL);\newline	if (RET_IS_OK(result)) {\newline		old-&gttarget-&gtwasmodified = true;\newline		if (trackingdata != NULL &amp&amp old-&gtsource != NULL\newline				&amp&amp old-&gtsourceversion != NULL) {\newline			r = trackingdata_remove(trackingdata,\newline					old-&gtsource, old-&gtsourceversion, &ampfiles);\newline			RET_UPDATE(result, r);\newline		}\newline		if (trackingdata == NULL)\newline			old-&gttarget-&gtstaletracking = true;\newline		if (logger != NULL)\newline			logger_log(logger, old-&gttarget, old-&gtname,\newline					NULL, old-&gtversion,\newline					NULL, old-&gtcontrol,\newline					NULL, &ampfiles,\newline					NULL, NULL);\newline		r = references_delete(old-&gttarget-&gtidentifier, &ampfiles, NULL);\newline		RET_UPDATE(result, r);\newline	}\newline	strlist_done(&ampfiles);\newline	return result;\newline}\newline","Like target_removepackage, but delete the package record by cursor \newline",406922,mapm5sin.c,"void	M_4x_do_it(M_APM rr, int places, M_APM xx)\newline{\newlineM_APM   tmp0, tmp1, t2, t4;\newline\newlinetmp0 = M_get_stack_var();\newlinetmp1 = M_get_stack_var();\newlinet2   = M_get_stack_var();\newlinet4   = M_get_stack_var();\newline\newlinem_apm_multiply(tmp1, xx, xx);\newlinem_apm_round(t2, (places + 4), tmp1);     /* x ^ 2 */\newlinem_apm_multiply(t4, t2, t2);              /* x ^ 4 */\newline\newlinem_apm_subtract(tmp0, t4, t2);\newlinem_apm_multiply(tmp1, tmp0, MM_5x_Eight);\newlinem_apm_add(tmp0, MM_One, tmp1);\newlinem_apm_round(rr, places, tmp0);\newlineM_restore_stack(4);\newline}\newline",\newline calculate the multiple angle identity for cos (4x)\newline \newline cos (4x) == 8 [ cos^4 (x) - cos^2 (x) ] + 1\newline \newline,1225567,goal2sat.cpp,bool goal2sat::has_unsupported_bool(goal const &amp g) {\newline    return test&ltunsupported_bool_proc&gt(g);\newline}\newline,\newline\\brief Return true if s contains an unsupported Boolean operator.\newlinegoal_rewriter (with the following configuration) can be used to\newlineeliminate unsupported operators.\newline:elim-and true\newline:blast-distinct true\newline \newline,4475611,xml_parser.c,"PARSED* parse_xml(char* xml){\newline	char* result = &quotresult&quot;\newline	char* esgwri = &quotesgwri&quot;\newline	char* esqk = &quotesqk&quot;\newline	char* lro = &quotlro&quot;\newline	char* callid = &quotcallId&quot;\newline	char* datetimestamp = &quotdatetimestamp&quot;\newline	char* vpc = &quotvpc&quot;\newline	char* destination = &quotdestination&quot;\newline	char* organizationname = &quotorganizationName&quot;\newline	char* hostname = &quothostId&quot;\newline	char* nenaid = &quotnenaId&quot;\newline	char* contact = &quotcontact&quot;\newline	char* certuri = &quotcertUri&quot;\newline	char* ert = &quotert&quot;\newline	char* selectiveRoutingID = &quotselectiveRoutingID&quot;\newline	char* routingESN = &quotroutingESN&quot;\newline	char* npa = &quotnpa&quot;\newline\newline	char *new_vpc, *new_destination, *new_ert;\newline\newline	PARSED *parsed = pkg_malloc(sizeof(PARSED));\newline	parsed-&gtvpc =pkg_malloc(sizeof(NENA));\newline	parsed-&gtdestination =pkg_malloc(sizeof(NENA));\newline	parsed-&gtert =pkg_malloc(sizeof(ERT));\newline\newline	if (check_str_between_init_tags(xml))\newline		return NULL;\newline\newline	if(parsed == NULL || parsed-&gtvpc == NULL || parsed-&gtdestination == NULL || parsed-&gtert == NULL)\newline		return NULL;\newline\newline	parsed-&gtresult = copy_str_between_two_tags(result,xml);\newline	parsed-&gtesgwri = copy_str_between_two_tags(esgwri,xml);\newline	parsed-&gtesqk = copy_str_between_two_tags(esqk,xml);\newline	parsed-&gtlro = copy_str_between_two_tags(lro,xml);\newline	parsed-&gtcallid = copy_str_between_two_tags(callid,xml);\newline	parsed-&gtdatetimestamp = copy_str_between_two_tags(datetimestamp,xml);\newline\newline	new_vpc = copy_str_between_two_tags(vpc,xml);\newline	if(new_vpc != empty){\newline		parsed-&gtvpc-&gtorganizationname = copy_str_between_two_tags(organizationname,new_vpc);\newline		parsed-&gtvpc-&gthostname = copy_str_between_two_tags(hostname,new_vpc);\newline		parsed-&gtvpc-&gtnenaid = copy_str_between_two_tags(nenaid,new_vpc);\newline		parsed-&gtvpc-&gtcontact = copy_str_between_two_tags(contact,new_vpc);\newline		parsed-&gtvpc-&gtcerturi = copy_str_between_two_tags(certuri,new_vpc);\newline\newline		pkg_free(new_vpc);\newline	}else{\newline		parsed-&gtvpc-&gtorganizationname = empty;\newline		parsed-&gtvpc-&gthostname = empty;\newline		parsed-&gtvpc-&gtnenaid = empty;\newline		parsed-&gtvpc-&gtcontact = empty;\newline		parsed-&gtvpc-&gtcerturi = empty;\newline	}\newline\newline	new_destination = copy_str_between_two_tags(destination,xml);\newline	if(new_destination!= empty){\newline		parsed-&gtdestination-&gtorganizationname = copy_str_between_two_tags(organizationname,new_destination);\newline		parsed-&gtdestination-&gthostname = copy_str_between_two_tags(hostname,new_destination);\newline		parsed-&gtdestination-&gtnenaid = copy_str_between_two_tags(nenaid,new_destination);\newline		parsed-&gtdestination-&gtcontact = copy_str_between_two_tags(contact,new_destination);\newline		parsed-&gtdestination-&gtcerturi = copy_str_between_two_tags(certuri,new_destination);\newline\newline		pkg_free(new_destination);\newline	}else{\newline		parsed-&gtdestination-&gtorganizationname = empty;\newline		parsed-&gtdestination-&gthostname = empty;\newline		parsed-&gtdestination-&gtnenaid = empty;\newline		parsed-&gtdestination-&gtcontact = empty;\newline		parsed-&gtdestination-&gtcerturi = empty;\newline	}\newline\newline	new_ert = copy_str_between_two_tags(ert,xml);\newline	if(new_ert != empty){\newline		parsed-&gtert-&gtselectiveRoutingID = copy_str_between_two_tags(selectiveRoutingID,new_ert);\newline		parsed-&gtert-&gtroutingESN = copy_str_between_two_tags(routingESN,new_ert);\newline		parsed-&gtert-&gtnpa = copy_str_between_two_tags(npa,new_ert);\newline\newline		pkg_free(new_ert);\newline	}else{\newline		parsed-&gtert-&gtselectiveRoutingID = empty;\newline		parsed-&gtert-&gtroutingESN = empty;\newline		parsed-&gtert-&gtnpa = empty;\newline	}\newline\newline	return parsed;\newline}\newline",treats the esrResponse xml from VPC\newline - extract data between tags and put in parsed struct:\newline - result\newline - esgwri\newline - esqk\newline - lro\newline - callid\newline - datetimestamp\newline - vpc\newline .organizationname\newline .hostname\newline .nenaid\newline .contact\newline .certuri\newline - destination\newline .organizationname\newline .hostname\newline .nenaid\newline .contact\newline .certuri\newline - ert\newline .selectiveRoutingID\newline .routingESN\newline .npa\newline \newline,6588697,malloc.c,"static int has_segment_link(mstate m, msegmentptr ss) {\newline  msegmentptr sp = &ampm-&gtseg;\newline  for (;;) {\newline    if ((char*)sp &gt= ss-&gtbase &amp&amp (char*)sp &lt ss-&gtbase + ss-&gtsize)\newline      return 1;\newline    if ((sp = sp-&gtnext) == 0)\newline      return 0;\newline  }\newline}\newline",Return true if segment contains a segment link \newline,5246267,ow_1820.c,"static GOOD_OR_BAD OW_10temp(_FLOAT * temp, enum temperature_problem_flag accept_85C, int simul_good, const struct parsedname *pn)\newline{\newline	struct tempresolution * Resolution = &ampResolutionS ;\newline\newline	RETURN_BAD_IF_BAD( OW_temperature_ready( accept_85C, simul_good, Resolution, pn ) ) ;\newline\newline	return OW_10latesttemp(temp, accept_85C, pn);\newline}\newline",get the temp from the scratchpad buffer after starting a conversion and waiting \newline,3466037,gram.c,"static SEXP install_and_save(char * text)\newline{\newline    strcpy(yytext, text);\newline    return install(text);\newline}\newline","Get the R symbol, and set yytext at the same time \newline",5964400,service.c,"faim_export int aim_clientready(aim_session_t *sess, aim_conn_t *conn)\newline{\newline	aim_conn_inside_t *ins = (aim_conn_inside_t *)conn-&gtinside;\newline	struct snacgroup *sg;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline\newline	if (!ins)\newline		return -EINVAL;\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 1152)))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0001, 0x0002, 0x0000, NULL, 0);\newline	aim_putsnac(&ampfr-&gtdata, 0x0001, 0x0002, 0x0000, snacid);\newline\newline	/*\newline	 * Send only the tool versions that the server cares about (that it\newline	 * marked as supporting in the server ready SNAC).  \newline	 */\newline	for (sg = ins-&gtgroups; sg; sg = sg-&gtnext) {\newline		aim_module_t *mod;\newline\newline		if ((mod = aim__findmodulebygroup(sess, sg-&gtgroup))) {\newline			aimbs_put16(&ampfr-&gtdata, mod-&gtfamily);\newline			aimbs_put16(&ampfr-&gtdata, mod-&gtversion);\newline			aimbs_put16(&ampfr-&gtdata, mod-&gttoolid);\newline			aimbs_put16(&ampfr-&gtdata, mod-&gttoolversion);\newline		} else\newline			faimdprintf(sess, 1, &quotaim_clientready: server supports group 0x%04x but we don&#039t!\\n&quot, sg-&gtgroup);\newline	}\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline",Subtype 0x0002 - Client Online \newline,1040663,pwck.c,"static void fail_exit (int code)\newline{\newline	if (spw_locked) {\newline		if (spw_unlock () == 0) {\newline			fprintf (stderr, _(&quot%s: failed to unlock %s\\n&quot), Prog, spw_dbname ());\newline			if (use_system_spw_file) {\newline				SYSLOG ((LOG_ERR, &quotfailed to unlock %s&quot,\newline				         spw_dbname ()));\newline			}\newline			/* continue */\newline		}\newline	}\newline\newline	if (pw_locked) {\newline		if (pw_unlock () == 0) {\newline			fprintf (stderr, _(&quot%s: failed to unlock %s\\n&quot), Prog, pw_dbname ());\newline			if (use_system_pw_file) {\newline				SYSLOG ((LOG_ERR, &quotfailed to unlock %s&quot,\newline				         pw_dbname ()));\newline			}\newline			/* continue */\newline		}\newline	}\newline\newline	closelog ();\newline\newline	exit (code);\newline}\newline",\newline fail_exit - do some cleanup and exit with the given error code\newline \newline,2968117,interface.c,"void ruby_libvirt_interface_init(void)\newline{\newline#if HAVE_TYPE_VIRINTERFACEPTR\newline    c_interface = rb_define_class_under(m_libvirt, &quotInterface&quot, rb_cObject);\newline#if HAVE_CONST_VIR_INTERFACE_XML_INACTIVE\newline    rb_define_const(c_interface, &quotXML_INACTIVE&quot,\newline                    INT2NUM(VIR_INTERFACE_XML_INACTIVE));\newline#endif\newline    rb_define_attr(c_interface, &quotconnection&quot, 1, 0);\newline\newline    /* Interface object methods */\newline    rb_define_method(c_interface, &quotname&quot, libvirt_interface_name, 0);\newline    rb_define_method(c_interface, &quotmac&quot, libvirt_interface_mac, 0);\newline    rb_define_method(c_interface, &quotxml_desc&quot, libvirt_interface_xml_desc, -1);\newline    rb_define_method(c_interface, &quotundefine&quot, libvirt_interface_undefine, 0);\newline    rb_define_method(c_interface, &quotcreate&quot, libvirt_interface_create, -1);\newline    rb_define_method(c_interface, &quotdestroy&quot, libvirt_interface_destroy, -1);\newline    rb_define_method(c_interface, &quotfree&quot, libvirt_interface_free, 0);\newline#if HAVE_VIRINTERFACEISACTIVE\newline    rb_define_method(c_interface, &quotactive?&quot, libvirt_interface_active_p, 0);\newline#endif\newline#endif\newline}\newline",\newline Class Libvirt::Interface\newline \newline,4143065,gif2rgb.c,"static void RGB2GIF(bool OneFileFlag, int NumFiles, char *FileName,\newline		    int ExpNumOfColors, int Width, int Height)\newline{\newline    int ColorMapSize;\newline\newline    GifByteType *RedBuffer = NULL, *GreenBuffer = NULL, *BlueBuffer = NULL,\newline	*OutputBuffer = NULL;\newline    ColorMapObject *OutputColorMap = NULL;\newline\newline    ColorMapSize = 1 &lt&lt ExpNumOfColors;\newline\newline    if (NumFiles == 1) {\newline	LoadRGB(FileName, OneFileFlag,\newline		&ampRedBuffer, &ampGreenBuffer, &ampBlueBuffer, Width, Height);\newline    }\newline    else {\newline	LoadRGB(NULL, OneFileFlag,\newline		&ampRedBuffer, &ampGreenBuffer, &ampBlueBuffer, Width, Height);\newline    }\newline\newline    if ((OutputColorMap = GifMakeMapObject(ColorMapSize, NULL)) == NULL ||\newline	(OutputBuffer = (GifByteType *) malloc(Width * Height *\newline					    sizeof(GifByteType))) == NULL)\newline	GIF_EXIT(&quotFailed to allocate memory required, aborted.&quot);\newline\newline    if (GifQuantizeBuffer(Width, Height, &ampColorMapSize,\newline		       RedBuffer, GreenBuffer, BlueBuffer,\newline		       OutputBuffer, OutputColorMap-&gtColors) == GIF_ERROR)\newline	exit(EXIT_FAILURE);\newline    free((char *) RedBuffer);\newline    free((char *) GreenBuffer);\newline    free((char *) BlueBuffer);\newline\newline    SaveGif(OutputBuffer, Width, Height, ExpNumOfColors, OutputColorMap);\newline}\newline","\newlineClose output file (if open), and exit.\newline \newline",514245,bluetooth_rxtx.c,"static void cs_threshold_set(int8_t level, u8 samples)\newline{\newline	level = MIN(MAX(level,-120),(-20));\newline	cc2400_set(RSSI, (uint8_t)((level + 56) &amp (0x3f &lt&lt 2)) | (samples&amp3));\newline	cs_threshold_cur = level;\newline	cs_no_squelch = (level &lt= -120);\newline}\newline","Set CC2400 carrier sense threshold and store value to\newline global. CC2400 RSSI is determined by 54dBm + level. CS threshold is\newline in 4dBm steps, so the provided level is rounded to the nearest\newline multiple of 4 by adding 56. Useful range is -100 to -20. \newline",4909412,ldif2ldbm.c,"int ldbm_back_fetch_incl_excl(Slapi_PBlock *pb, char ***include,\newline                              char ***exclude)\newline{\newline    char **pb_incl, **pb_excl;\newline\newline    slapi_pblock_get(pb, SLAPI_LDIF2DB_INCLUDE, &amppb_incl);\newline    slapi_pblock_get(pb, SLAPI_LDIF2DB_EXCLUDE, &amppb_excl);\newline    if ((NULL == include) || (NULL == exclude)) {\newline        return 0;\newline    }\newline    *include = *exclude = NULL;\newline\newline    /* pb_incl/excl are both normalized */\newline    *exclude = slapi_ch_array_dup(pb_excl);\newline    *include = slapi_ch_array_dup(pb_incl);\newline\newline    return (pb_incl || pb_excl);\newline}\newline",fetch include/exclude DNs from the pblock and normalize them --\newline returns true if there are any include/exclude DNs\newline [used by both ldif2db and db2ldif]\newline \newline,6110085,comp.c,"int ifp_rename_file(struct ifp_device * dev, const char * old_file, const char * new_file)\newline{\newline	int i;\newline	char * b = dev-&gtb3;\newline\newline	i = ifp_copy_parent_string(b, new_file, strlen(new_file));\newline	ifp_err_jump(i, out, &quotgetting parent directory of %s failed.&quot,new_file);\newline	i = touch(dev, b, new_file);\newline	ifp_err_expect(i, i==-ENOENT || i==-EEXIST || i==IFP_ERR_BAD_FILENAME, out, &quotTouch failed.&quot);\newline	b = NULL; //release b3\newline\newline	i = swap_filenames(dev, old_file, new_file);\newline	ifp_err_jump(i, out, &quotfilename swap failed.&quot);\newline\newline	i = ifp_delete(dev, old_file);\newline	ifp_err_jump(i, out, &quotdelete failed.&quot);\newline\newlineout:\newline	return i;\newline}\newline","returns -ENOENT, -EEXIST, IFP_ERR_BAD_FILENAME \newline",528946,gl_menu.c,"char Sdlgl_yn_function(const char *query, const char *resp, CHAR_P def)\newline{\newline  struct TextWindow *win;\newline  \newline  int ch = &#039n&#039;  /* value to keep compiler sweet */\newline  int allow_num;\newline\newline  char prompt[BUFSZ]; \newline  char respbuf[BUFSIZ];\newline  char *rb;\newline  \newline  if (WIN_MESSAGE == WIN_ERR)\newline    return &#039n&#039;\newline\newline  win = text_wins[WIN_MESSAGE];\newline  assert(win);\newline  assert(win-&gtbase);\newline\newline  if (sdlgl_alt_prev)\newline    sdlgl_remove_scrollback();\newline\newline  if (win-&gtfresh_lines &gt 0)\newline    sdlgl_more(win);\newline\newline  Sdlgl_clear_nhwindow(WIN_MESSAGE);\newline  \newline  /* disable scrollback while we control the message win */\newline  win-&gtscrollback_enable = 0;\newline\newline  sdlgl_gotoxy(win, 0, 0);\newline\newline  allow_num = (resp &amp&amp strchr(resp, &#039#&#039) != NULL);\newline  \newline  /* make up the prompt */\newline  if (resp)\newline  {\newline    strcpy(respbuf, resp);\newline    rb = strchr(respbuf, &#039\\033&#039);\newline    if (rb)\newline      *rb = 0;\newline    sprintf(prompt, &quot%s [%s] &quot, query, respbuf);\newline    if (def) \newline      sprintf(prompt+strlen(prompt), &quot(%c) &quot, def);\newline  }\newline  else\newline    strcpy(prompt, query);\newline\newline  sdlgl_puts(win, prompt);\newline  \newline  for (;;)\newline  {\newline    sdlgl_flush();\newline    ch = sdlgl_get_key(0);\newline\newline    if (!resp)\newline      break;\newline\newline    if (ch == C(&#039p&#039))\newline    {\newline      Sdlgl_doprev_message();\newline      continue;\newline    }\newline\newline    if (sdlgl_alt_prev)\newline      sdlgl_remove_scrollback();\newline\newline    /* handle escape (yes, it&#039s weird) */\newline    if (ch == &#039\\033&#039) \newline    {\newline      ch = strchr(resp, &#039q&#039) ? &#039q&#039 : (strchr(resp, &#039n&#039) ? &#039n&#039 : def);\newline      break;\newline    }\newline\newline    /* Note: quitchars[] is defined in the main nethack code */\newline    if (strchr(quitchars, ch))\newline    {\newline      ch = def;\newline      break;\newline    }\newline\newline    if (allow_num &amp&amp (ch == &#039#&#039 || digit(ch)))\newline    {\newline      /* --- handle numbers --- */\newline\newline      int n_len = 0;\newline      int value = 0;\newline      int nc;\newline\newline      sdlgl_putc(win, &#039#&#039); n_len++;\newline\newline      if (digit(ch))\newline      {\newline        sdlgl_putc(win, ch); n_len++;\newline        value = ch - &#0390&#039;\newline      }\newline\newline      for (;;)\newline      {\newline        sdlgl_flush();\newline        nc = sdlgl_get_key(0);\newline\newline        if (nc == C(&#039p&#039))\newline        {\newline          Sdlgl_doprev_message();\newline          continue;\newline        }\newline\newline        if (sdlgl_alt_prev)\newline          sdlgl_remove_scrollback();\newline\newline        if (digit(nc) &amp&amp value &lt= 99999)\newline        {\newline          sdlgl_putc(win, nc); n_len++;\newline          value = value * 10 + (nc - &#0390&#039);\newline          continue;\newline        }\newline\newline        /* handle escape */\newline        if (nc == &#039\\033&#039 || (nc == &#039\\b&#039 &amp&amp n_len &lt= 1))\newline        {\newline          value = -1;\newline          break;\newline        }\newline        \newline        /* backspace */\newline        if (nc == &#039\\b&#039)\newline        {\newline          assert(n_len &gt 1);\newline          sdlgl_puts(win, &quot\\b \\b&quot); n_len--;\newline\newline          value /= 10;\newline          continue;\newline        }\newline\newline        /* enter */\newline        if ((nc == &#039\\n&#039 || nc == &#039\\r&#039) &amp&amp n_len &gt 1)\newline          break;\newline\newline        /* beep ? */\newline      }\newline\newline      if (value &gt 0)\newline      {\newline        yn_number = value;\newline        ch = &#039#&#039;\newline        break;\newline      }\newline      else if (value == 0)\newline      {\newline        ch = &#039n&#039;\newline        break;\newline      }\newline\newline      /* user escaped, clear number */\newline      for (; n_len &gt 0; n_len--)\newline        sdlgl_puts(win, &quot\\b \\b&quot);\newline\newline      continue;\newline      \newline      /* --- end of handle numbers --- */\newline    }\newline\newline    if (strchr(resp, ch))\newline      break;\newline\newline    /* beep ? */\newline  }\newline\newline  Sdlgl_clear_nhwindow(WIN_MESSAGE);\newline\newline  win-&gtscrollback_enable = 1;\newline\newline  return (char) ch;\newline}\newline","\newline Generic yes/no function. &#039def&#039 is the default (returned by space or\newline return; &#039esc&#039 returns &#039q&#039, or &#039n&#039, or the default, depending on\newline what&#039s in the string. The &#039query&#039 string is printed before the\newline user is asked about the string.\newline \newline If resp is NULL, any single character is accepted and returned.\newline If not-NULL, only characters in it are allowed (exceptions: the\newline quitchars are always allowed, and if it contains &#039#&#039 then digits\newline are allowed); if it includes an &ltesc&gt, anything beyond that won&#039t\newline be shown in the prompt to the user but will be acceptable as input.\newline \newline",2806406,player.c,"void player_add( Player *player )\newline{\newline    if ( players == 0 ) \newline        players = list_create( LIST_AUTO_DELETE, player_delete );\newline    list_add( players, player );\newline}\newline",\newline====================================================================\newlineAdd player to player list.\newline====================================================================\newline \newline,6007296,genrcbin.c,"static void BsaveRestrictionExpressions(\newline  void *theEnv,\newline  struct constructHeader *theDefgeneric,\newline  void *userBuffer)\newline  {\newline   DEFGENERIC *gfunc = (DEFGENERIC *) theDefgeneric;\newline   register unsigned i,j;\newline   DEFMETHOD *meth;\newline\newline   for (i = 0 ; i &lt gfunc-&gtmcnt ; i++)\newline     {\newline      meth = &ampgfunc-&gtmethods[i];\newline      for (j = 0 ; j &lt (unsigned) meth-&gtrestrictionCount ; j++)\newline        BsaveExpression(theEnv,meth-&gtrestrictions[j].query,(FILE *) userBuffer);\newline     }\newline  }\newline",\newlineNAME : BsaveRestrictionExpressions\newlineDESCRIPTION : Saves the needed expressions for\newlinea defgeneric method restriction\newlinequeries bsave\newlineINPUTS : 1) The defgeneric\newline2) Output data file pointer\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Method restriction query\newlineexpressions saved\newlineNOTES : None\newline \newline,1207013,mesh.c,"static int _my_nla_put_u8(struct nl_msg *n, int mesh_param_num, _any *value)\newline{\newline	return nla_put(n, mesh_param_num, sizeof(uint8_t), &ampvalue-&gtu.as_8);\newline}\newline",utility functions for manipulating and printing u8/u16/u32 values and\newline timesouts. \newline,2187379,capi.c,"int a_Capi_dpi_verify_request(BrowserWindow *bw, DilloUrl *url)\newline{\newline   const DilloUrl *referer;\newline   int allow = FALSE;\newline\newline   if (dStrAsciiCasecmp(URL_SCHEME(url), &quotdpi&quot) == 0) {\newline      if (!(URL_FLAGS(url) &amp (URL_Post + URL_Get))) {\newline         allow = TRUE;\newline      } else if (!(URL_FLAGS(url) &amp URL_Post) &amp&amp\newline                 strncmp(URL_PATH(url), &quot/vsource/&quot, 9) == 0) {\newline         allow = TRUE;\newline      } else {\newline         /* only allow GET&ampPOST dpi-requests from dpi-generated urls */\newline         if (a_Nav_stack_size(bw)) {\newline            referer = a_History_get_url(NAV_TOP_UIDX(bw));\newline            if (dStrAsciiCasecmp(URL_SCHEME(referer), &quotdpi&quot) == 0) {\newline               allow = TRUE;\newline            }\newline         }\newline      }\newline   } else {\newline      allow = TRUE;\newline   }\newline\newline   if (!allow) {\newline      MSG(&quota_Capi_dpi_verify_request: Permission Denied!\\n&quot);\newline      MSG(&quot  URL_STR : %s\\n&quot, URL_STR(url));\newline      if (URL_FLAGS(url) &amp URL_Post) {\newline         MSG(&quot  URL_DATA: %s\\n&quot, dStr_printable(URL_DATA(url), 1024));\newline      }\newline   }\newline   return allow;\newline}\newline",\newline Safety test: only allow GET|POST dpi-urls from dpi-generated pages.\newline \newline,2174659,cph-iface-mechanism.c,"void cph_iface_object_skeleton_set_mechanism (CphIfaceObjectSkeleton *object, CphIfaceMechanism *interface_)\newline{\newline  g_object_set (G_OBJECT (object), &quotmechanism&quot, interface_, NULL);\newline}\newline",\newline cph_iface_object_skeleton_set_mechanism:\newline @object: A #CphIfaceObjectSkeleton.\newline @interface_: (allow-none): A #CphIfaceMechanism or %NULL to clear the interface.\newline \newline Sets the #CphIfaceMechanism instance for the D-Bus interface &ltlink linkend=&quotgdbus-interface-org-opensuse-CupsPkHelper-Mechanism.top_of_page&quot&gtorg.opensuse.CupsPkHelper.Mechanism&lt/link&gt on @object.\newline \newline,922175,pagesel.c,"int	mdvi_page_selected(DviPageSpec *spec, PageNum page, int dvipage)\newline{\newline	int	i;\newline	int	not_found;\newline	\newline	if(spec == NULL)\newline		return 1;\newline	if(spec[0]) {\newline		not_found = mdvi_in_range(spec[0]-&gtranges, \newline			spec[0]-&gtnranges, dvipage);\newline		if(not_found &lt 0)\newline			return 0;\newline	}\newline	for(i = 1; i &lt= 10; i++) {\newline		if(spec[i] == NULL)\newline			continue;\newline		not_found = mdvi_in_range(spec[i]-&gtranges, \newline			spec[i]-&gtnranges, (int)page[i]);\newline		if(not_found &lt 0)\newline			return 0;\newline	}\newline	return 1;\newline}\newline",returns non-zero if the given page is included by `spec&#039 \newline,,,,,,,,,,,,,,,,,,,,,,,on,,,,,on,,on,,on,,,,on,on,on,on,on,,on,"Like target_removepackage, but delete the package record by cursor",Class Libvirt::Interface,"Close output file (if open), and exit.",Set CC2400 carrier,include/exclude DNs from the pblock and normalize them --,"returns -ENOENT, -EEXIST,",Generic yes/no function.,Add player to player,DESCRIPTION : Saves the needed,utility functions for manipulating,Safety test: only allow,calculate the multiple angle identity for cos (4x),cph_iface_object_skeleton_set_mechanism:,returns non-zero,\brief Return,extract data between tags and put in parsed struct:,Return true if segment contains a segment link,get the temp from the scratchpad,"Get the R symbol,",Subtype 0x0002 - Client Online,fail_exit - do,,"Due to a large influx of spam, we are automatically rejecting some HITs that are flagged as inappropriate.                 These include HITs by users who never use the 'No tag?' box, users who submit responses                 at an improbably fast rate, and users who, after completing several HITs, show very poor agreement with our gold set.                 If you believe your HIT was unfairly rejected, please contact the requester. Thank you for your understanding."
