"HITId","HITTypeId","Title","Description","Keywords","Reward","CreationTime","MaxAssignments","RequesterAnnotation","AssignmentDurationInSeconds","AutoApprovalDelayInSeconds","Expiration","NumberOfSimilarHITs","LifetimeInSeconds","AssignmentId","WorkerId","AssignmentStatus","AcceptTime","SubmitTime","AutoApprovalTime","ApprovalTime","RejectionTime","RequesterFeedback","WorkTimeInSeconds","LifetimeApprovalRate","Last30DaysApprovalRate","Last7DaysApprovalRate","Input.fid_1","Input.file_name_1","Input.function_body_1","Input.comment_body_1","Input.fid_2","Input.file_name_2","Input.function_body_2","Input.comment_body_2","Input.fid_3","Input.file_name_3","Input.function_body_3","Input.comment_body_3","Input.fid_4","Input.file_name_4","Input.function_body_4","Input.comment_body_4","Input.fid_5","Input.file_name_5","Input.function_body_5","Input.comment_body_5","Input.fid_6","Input.file_name_6","Input.function_body_6","Input.comment_body_6","Input.fid_7","Input.file_name_7","Input.function_body_7","Input.comment_body_7","Input.fid_8","Input.file_name_8","Input.function_body_8","Input.comment_body_8","Input.fid_9","Input.file_name_9","Input.function_body_9","Input.comment_body_9","Input.fid_10","Input.file_name_10","Input.function_body_10","Input.comment_body_10","Input.fid_11","Input.file_name_11","Input.function_body_11","Input.comment_body_11","Input.fid_12","Input.file_name_12","Input.function_body_12","Input.comment_body_12","Input.fid_13","Input.file_name_13","Input.function_body_13","Input.comment_body_13","Input.fid_14","Input.file_name_14","Input.function_body_14","Input.comment_body_14","Input.fid_15","Input.file_name_15","Input.function_body_15","Input.comment_body_15","Input.fid_16","Input.file_name_16","Input.function_body_16","Input.comment_body_16","Input.fid_17","Input.file_name_17","Input.function_body_17","Input.comment_body_17","Input.fid_18","Input.file_name_18","Input.function_body_18","Input.comment_body_18","Input.fid_19","Input.file_name_19","Input.function_body_19","Input.comment_body_19","Input.fid_20","Input.file_name_20","Input.function_body_20","Input.comment_body_20","Input.fid_21","Input.file_name_21","Input.function_body_21","Input.comment_body_21","Answer.empty_1","Answer.empty_10","Answer.empty_11","Answer.empty_12","Answer.empty_13","Answer.empty_14","Answer.empty_15","Answer.empty_16","Answer.empty_17","Answer.empty_18","Answer.empty_19","Answer.empty_2","Answer.empty_20","Answer.empty_21","Answer.empty_3","Answer.empty_4","Answer.empty_5","Answer.empty_6","Answer.empty_7","Answer.empty_8","Answer.empty_9","Answer.multiple_1","Answer.multiple_10","Answer.multiple_11","Answer.multiple_12","Answer.multiple_13","Answer.multiple_14","Answer.multiple_15","Answer.multiple_16","Answer.multiple_17","Answer.multiple_18","Answer.multiple_19","Answer.multiple_2","Answer.multiple_20","Answer.multiple_21","Answer.multiple_3","Answer.multiple_4","Answer.multiple_5","Answer.multiple_6","Answer.multiple_7","Answer.multiple_8","Answer.multiple_9","Answer.tag_1","Answer.tag_10","Answer.tag_11","Answer.tag_12","Answer.tag_13","Answer.tag_14","Answer.tag_15","Answer.tag_16","Answer.tag_17","Answer.tag_18","Answer.tag_19","Answer.tag_2","Answer.tag_20","Answer.tag_21","Answer.tag_3","Answer.tag_4","Answer.tag_5","Answer.tag_6","Answer.tag_7","Answer.tag_8","Answer.tag_9","Approve","Reject"
"33Q5P9PUSPMOL35S48W3RZW80KRZC2","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","35GCEFQ6I5O2VN621HQ3NFO3AVHZ3B","A3H595NF3V9INA","Approved","Wed Apr 17 13:34:02 PDT 2019","Wed Apr 17 13:39:49 PDT 2019","Fri Apr 19 13:39:49 PDT 2019","2019-04-19 20:40:21 UTC","","","347","100% (1/1)","100% (1/1)","100% (1/1)","1328629","ms_task.c","static void ms_single_getset_task_sch(ms_conn_t *c)\newline{\newline  ms_task_t *task;\newline  ms_task_item_t *item;\newline\newline  /* the last time don&#039t run a task */\newline  if (c-&gtremain_exec_num-- &gt 0)\newline  {\newline    task= ms_get_task(c, false);\newline    item= task-&gtitem;\newline    if (task-&gtcmd == CMD_SET)\newline    {\newline      ms_mcd_set(c, item);\newline    }\newline    else if (task-&gtcmd == CMD_GET)\newline    {\newline      assert(task-&gtcmd == CMD_GET);\newline      ms_mcd_get(c, item);\newline    }\newline  }\newline} /* ms_single_getset_task_sch */\newline","\newline dispatch single get and set task\newline \newline @param c, pointer of the concurrency\newline \newline","263800","disasmview.c","static gboolean move_up_lines(TilemDisasmView *dv, int count)\newline{\newline	TilemCalc *calc;\newline	dword pos;\newline	int linenum;\newline\newline	if (!get_cursor_line(dv, NULL, &amplinenum))\newline		linenum = 0;\newline\newline	if (linenum &gt= count)\newline		return FALSE;\newline\newline	tilem_calc_emulator_lock(dv-&gtdbg-&gtemu);\newline	calc = dv-&gtdbg-&gtemu-&gtcalc;\newline\newline	pos = dv-&gtstartpos;\newline	count -= linenum;\newline	while (count &gt 0) {\newline		pos = get_prev_pos(dv, calc, pos);\newline		count--;\newline	}\newline\newline	tilem_calc_emulator_unlock(dv-&gtdbg-&gtemu);\newline\newline	refresh_disassembly(dv, pos, dv-&gtnlines, pos);\newline\newline	return TRUE;\newline}\newline","Move up by COUNT lines \newline","2129121","stream.c","void test_filter_stream__smallfile(void)\newline{\newline	test_stream(5);\newline}\newline","write a 50KB file through the &quotcompression&quot stream \newline","4539621","srp_sync.c","struct target_details *pop_from_retry_list(struct sync_resources *res)\newline{\newline	struct target_details *ret = res-&gtretry_tasks_head;\newline\newline	if (ret)\newline		res-&gtretry_tasks_head = ret-&gtnext;\newline	else\newline		res-&gtretry_tasks_tail = NULL;\newline\newline	return ret;\newline}\newline","assumes that res-&gtretry_mutex is locked !!! \newline","6448631","qwt_plot_axis.cpp","void QwtPlot::setAxisTitle( QwtAxisId axisId, const QString &amptitle )\newline{\newline    if ( isAxisValid( axisId ) )\newline        axisWidget( axisId )-&gtsetTitle( title );\newline}\newline","!\newline\\brief Change the title of a specified axis\newline\\param axisPos Axis position\newline\\param title axis title\newline \newline","287086","ust-app.c","int ust_app_add_ctx_channel_glb(struct ltt_ust_session *usess,\newline		struct ltt_ust_channel *uchan, struct ltt_ust_context *uctx)\newline{\newline	int ret = 0;\newline	struct lttng_ht_node_str *ua_chan_node;\newline	struct lttng_ht_iter iter, uiter;\newline	struct ust_app_channel *ua_chan = NULL;\newline	struct ust_app_session *ua_sess;\newline	struct ust_app *app;\newline\newline	rcu_read_lock();\newline\newline	cds_lfht_for_each_entry(ust_app_ht-&gtht, &ampiter.iter, app, pid_n.node) {\newline		if (!app-&gtcompatible) {\newline			/*\newline			 * TODO: In time, we should notice the caller of this error by\newline			 * telling him that this is a version error.\newline			 */\newline			continue;\newline		}\newline		ua_sess = lookup_session_by_app(usess, app);\newline		if (ua_sess == NULL) {\newline			continue;\newline		}\newline\newline		pthread_mutex_lock(&ampua_sess-&gtlock);\newline\newline		if (ua_sess-&gtdeleted) {\newline			pthread_mutex_unlock(&ampua_sess-&gtlock);\newline			continue;\newline		}\newline\newline		/* Lookup channel in the ust app session */\newline		lttng_ht_lookup(ua_sess-&gtchannels, (void *)uchan-&gtname, &ampuiter);\newline		ua_chan_node = lttng_ht_iter_get_node_str(&ampuiter);\newline		if (ua_chan_node == NULL) {\newline			goto next_app;\newline		}\newline		ua_chan = caa_container_of(ua_chan_node, struct ust_app_channel,\newline				node);\newline		ret = create_ust_app_channel_context(ua_sess, ua_chan, &ampuctx-&gtctx, app);\newline		if (ret &lt 0) {\newline			goto next_app;\newline		}\newline	next_app:\newline		pthread_mutex_unlock(&ampua_sess-&gtlock);\newline	}\newline\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Add context to a specific channel for global UST domain.\newline \newline","636433","chat-shared.cpp","void ChatShared::load()\newline{\newline	if (!isValidStorage())\newline		return;\newline\newline	Shared::load();\newline\newline	ConfigurationApi *configurationStorage = storage()-&gtstorage();\newline	QDomElement parent = storage()-&gtpoint();\newline\newline	Groups.clear();\newline\newline	QDomElement groupsNode = configurationStorage-&gtgetNode(parent, &quotChatGroups&quot, ConfigurationApi::ModeFind);\newline	if (!groupsNode.isNull())\newline	{\newline		QDomNodeList groupsList = groupsNode.elementsByTagName(&quotGroup&quot);\newline\newline		int count = groupsList.count();\newline		for (int i = 0; i &lt count; i++)\newline		{\newline			QDomElement groupElement = groupsList.at(i).toElement();\newline			if (groupElement.isNull())\newline				continue;\newline			doAddToGroup(m_groupManager-&gtbyUuid(groupElement.text()));\newline		}\newline	}\newline\newline	*ChatAccount = m_accountManager-&gtbyUuid(QUuid(loadValue&ltQString&gt(&quotAccount&quot)));\newline	Display = loadValue&ltQString&gt(&quotDisplay&quot);\newline	auto type = loadValue&ltQString&gt(&quotType&quot);\newline\newline	// import from alias to new name of chat type\newline	ChatType *chatType = m_chatTypeManager-&gtchatType(type);\newline	if (chatType)\newline		type = chatType-&gtname();\newline\newline	// we should not have display names for Contact chats\newline	if (type == &quotContact&quot)\newline		Display.clear();\newline\newline	setType(type);\newline}\newline","\newline @author Rafal &#039Vogel&#039 Malinowski\newline @short Loads chat data from storage.\newline \newline This method is called when object is used at first time. It loads data from object&#039s\newline storage point. After loading data chat type is known (&#039Type&#039) so this method check\newline if the type is any of known chat types. If so, details class is created, assigned and\newline loaded - chat has full data available. If no, loading details class is deffered to\newline moment after good chat type is loaded. This mechanism is provided by\newline @link ChatTypeAvareObject @endlink class.\newline \newline","311642","checks.c","static void extract_check_result(FILE *fp, dbuf *checkresult_dbuf) {\newline	char output_buffer[MAX_INPUT_BUFFER] = &quot&quot;\newline	char *temp_buffer;\newline\newline	/* initialize buffer */\newline	strcpy(output_buffer, &quot&quot);\newline\newline	/* get all lines of plugin output - escape newlines */\newline	while (fgets(output_buffer, sizeof(output_buffer) - 1, fp)) {\newline		temp_buffer = escape_newlines(output_buffer);\newline		dbuf_strcat(checkresult_dbuf, temp_buffer);\newline		my_free(temp_buffer);\newline	}\newline}\newline","extract check result \newline","5899901","http.c","static void range_fetch_getmore(struct range_fetch *rf) {\newline    char request[2048];\newline    int l;\newline    int max_range_per_request = 20;\newline\newline    /* Only if there&#039s stuff queued to get */\newline    if (rf-&gtrangessent == rf-&gtnranges)\newline        return;\newline\newline    /* Build the base request, everything up to the Range: bytes= */\newline    snprintf(request, sizeof(request),\newline             &quotGET %s HTTP/1.1\\r\\n&quot\newline             &quotUser-Agent: zsync/&quot VERSION &quot\\r\\n&quot\newline             &quotHost: %s&quot\newline             &quot%s%s\\r\\n&quot\newline             &quot%s&quot\newline             &quotRange: bytes=&quot,\newline             rf-&gturl, rf-&gthosth,\newline             referer ? &quot\\r\\nReferer: &quot : &quot&quot, referer ? referer : &quot&quot,\newline             rf-&gtauthh ? rf-&gtauthh : &quot&quot);\newline\newline    /* The for loop here is just a sanity check, lastrange is the real loop control */\newline    for (; rf-&gtrangessent &lt rf-&gtnranges;) {\newline        int i = rf-&gtrangessent;\newline        int lastrange = 0;\newline\newline        /* Add at least one byterange to the request; but is this the last one? \newline         * That&#039s decided based on whether there are any more to add, whether\newline         * we&#039ve reached our self-imposed limit per request, and whether\newline         * there&#039s buffer space to add more.\newline         */\newline        l = strlen(request);\newline        if (l &gt 1200 || !(--max_range_per_request) || i == rf-&gtnranges - 1)\newline            lastrange = 1;\newline\newline        /* Append to the request */\newline        snprintf(request + l, sizeof(request) - l, OFF_T_PF &quot-&quot OFF_T_PF &quot%s&quot,\newline                 rf-&gtranges_todo[2 * i], rf-&gtranges_todo[2 * i + 1],\newline                 lastrange ? &quot&quot : &quot,&quot);\newline\newline        /* And record that we have sent this one */\newline        rf-&gtrangessent++;\newline\newline        /* Exit loop if that is the last to add */\newline        if (lastrange)\newline            break;\newline    }\newline    l = strlen(request);\newline\newline    /* Possibly close the connection (and record the fact, so we definitely\newline     * don&#039t send more stuff) if this is the last */\newline    snprintf(request + l, sizeof(request) - l, &quot\\r\\n%s\\r\\n&quot,\newline             rf-&gtrangessent == rf-&gtnranges ? (rf-&gtserver_close =\newline                                              1, &quotConnection: close\\r\\n&quot) : &quot&quot);\newline\newline    {   /* Send the request */\newline        size_t len = strlen(request);\newline        char *p = request;\newline        int r = 0;\newline\newline        while (len &gt 0\newline               &amp&amp ((r = send(rf-&gtsd, p, len, 0)) != -1 || errno == EINTR)) {\newline            if (r &gt= 0) {\newline                p += r;\newline                len -= r;\newline            }\newline        }\newline        if (r == -1) {\newline            perror(&quotsend&quot);\newline        }\newline    }\newline}\newline","range_fetch_getmore\newline On a connected range fetch, send another request to the remote \newline","2332588","qemuarch.c","const char *qemu_arch_qemumachine(const char *arch) {\newline	if (!strcmp(arch, &quotarm&quot) || !strcmp(arch, &quotarmel&quot)) {\newline		return &quotversatilepb&quot;\newline	} else if (!strcmp(arch, &quotarmhf&quot) || !strcmp(arch, &quotarm64&quot)) {\newline		return &quotvirt&quot;\newline	} else if (!strcmp(arch, &quoti386&quot) || !strcmp(arch, &quothurd-i386&quot) ||\newline			   !strcmp(arch, &quotamd64&quot) || !strcmp(arch, &quotx32&quot)) {\newline		return &quotpc&quot;\newline	} else if (!strcmp(arch, &quotmips&quot) || !strcmp(arch, &quotmipsel&quot)) {\newline		return &quotmalta&quot;\newline	} else if (!strcmp(arch, &quotpowerpc&quot)) {\newline		return &quotprep&quot;\newline	} else if (!strcmp(arch, &quotsparc&quot)) {\newline		return &quotSS-5&quot;\newline	}\newline	return NULL;\newline}\newline","\newline arch-specific routine; the machine spec for this arch\newline \newline","6629324","ibv.c","int finalizeIB(ArgStruct *p)\newline{\newline  int ret;\newline\newline  LOGPRINTF((&quotFinalizing IB stuff&quot));\newline    /* NOTE: This implementation only has created one of each type of queue.\newline     * In other implementations it may be necessary to create arrays of \newline     * these queues.  If this is the case, you need to loop and get them all */\newline  if(qp_hndl) {	    \newline    LOGPRINTF((&quotDestroying QP&quot));\newline    ret = ibv_destroy_qp(qp_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying Queue Pair\\n&quot);\newline    }\newline  }\newline\newline  if(r_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Recv CQ&quot));\newline    ret = ibv_destroy_cq(r_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying recv CQ\\n&quot);\newline    }\newline  }\newline\newline  if(s_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Send CQ&quot));\newline    ret = ibv_destroy_cq(s_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying send CQ\\n&quot);\newline    }\newline  }\newline\newline  /* Check memory registrations just in case user bailed out */\newline  if(s_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering send buffer&quot));\newline    ret = ibv_dereg_mr(s_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering send mr\\n&quot);\newline    }\newline  }\newline\newline  if(r_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering recv buffer&quot));\newline    ret = ibv_dereg_mr(r_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering recv mr\\n&quot);\newline    }\newline  }\newline\newline  if(pd_hndl) {\newline    LOGPRINTF((&quotDeallocating PD&quot));\newline    ret = ibv_dealloc_pd(pd_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deallocating PD\\n&quot);\newline    }\newline  }\newline\newline  /* Application code should not close HCA, just release handle */\newline\newline  if(ctx) {\newline    LOGPRINTF((&quotReleasing HCA&quot));\newline    ret = ibv_close_device(ctx);\newline    if(ret) {\newline      fprintf(stderr, &quotError releasing HCA\\n&quot);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","Deallocate everything properly \newline","3008347","drms.c","static int GetSystemKey( uint32_t *p_sys_key, uint32_t b_ipod )\newline{\newline    static char const p_secret1[ 8 ] = &quotYuaFlafu&quot;\newline    static char const p_secret2[ 8 ] = &quotzPif98ga&quot;\newline    struct md5_s md5;\newline    int64_t i_ipod_id;\newline    uint32_t p_system_hash[ 4 ];\newline\newline    /* Compute the MD5 hash of our system info */\newline    if( ( !b_ipod &amp&amp HashSystemInfo( p_system_hash ) ) ||\newline        (  b_ipod &amp&amp GetiPodID( &ampi_ipod_id ) ) )\newline    {\newline        return -1;\newline    }\newline\newline    /* Combine our system info hash with additional secret data. The resulting\newline     * MD5 hash will be our system key. */\newline    InitMD5( &ampmd5 );\newline    AddMD5( &ampmd5, (uint8_t *)p_secret1, 8 );\newline\newline    if( !b_ipod )\newline    {\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_secret2, 8 );\newline    }\newline    else\newline    {\newline        i_ipod_id = U64_AT(&ampi_ipod_id);\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline    }\newline\newline    EndMD5( &ampmd5 );\newline\newline    memcpy( p_sys_key, md5.p_digest, 16 );\newline\newline    return 0;\newline}\newline","\newline GetSystemKey: get the system key\newline \newline Compute the system key from various system information, see HashSystemInfo.\newline \newline","5861021","main.c","unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)\newline{\newline	struct syscallentry *entry;\newline	unsigned int fd;\newline\newline	entry = get_syscall_entry(rec-&gtnr, rec-&gtdo32bit);\newline\newline	if ((entry-&gtarg1type != ARG_FD) &amp&amp\newline	    (entry-&gtarg1type != ARG_SOCKETINFO))\newline	    return FALSE;\newline\newline	/* in the SOCKETINFO case, post syscall, a1 is actually the fd,\newline	 * not the socketinfo.  In ARG_FD a1=fd.\newline	 */\newline	fd = rec-&gta1;\newline\newline	/* if it&#039s out of range, it&#039s not going to be valid. */\newline	if (fd &gt 1024)\newline		return FALSE;\newline\newline	if (logging == LOGGING_FILES) {\newline		if (child-&gtlogfile == NULL)\newline			return FALSE;\newline\newline		if (fd &lt= (unsigned int) fileno(child-&gtlogfile))\newline			return FALSE;\newline	}\newline	return TRUE;\newline}\newline","if the first arg was an fd, find out which one it was.\newline Call with syscallrecord lock held. \newline","1392224","swfshape.c","static SHAPELINE* swf_ParseShapeData(U8*data, int bits, int fillbits, int linebits, int version, SHAPE2*shape2)\newline{\newline    SHAPELINE _lines;\newline    SHAPELINE*lines = &amp_lines;\newline\newline    TAG _tag;\newline    TAG* tag = &amp_tag;\newline    int fill0 = 0;\newline    int fill1 = 0;\newline    int line = 0;\newline    int x=0,y=0;\newline    int linestyleadd=0;\newline    int fillstyleadd=0;\newline    \newline    memset(tag, 0, sizeof(TAG));\newline    tag-&gtdata = data;\newline    tag-&gtlen = tag-&gtmemsize = (bits+7)/8;\newline    tag-&gtpos = 0;\newline    tag-&gtid = version==1?ST_DEFINESHAPE:(version==2?ST_DEFINESHAPE2:(version==3?ST_DEFINESHAPE3:ST_DEFINESHAPE4));\newline\newline    lines-&gtnext = 0;\newline    while(1) {\newline	int flags;\newline	flags = swf_GetBits(tag, 1);\newline	if(!flags) { //style change\newline	    flags = swf_GetBits(tag, 5);\newline	    if(!flags)\newline		break;\newline	    if(flags&amp1) { //move\newline		int n = swf_GetBits(tag, 5); \newline		x = swf_GetSBits(tag, n); //x\newline		y = swf_GetSBits(tag, n); //y\newline	    }\newline	    if(flags&amp2)\newline		fill0 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp4)\newline		fill1 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp8)\newline		line = swf_GetBits(tag, linebits) + linestyleadd; \newline	    if(flags&amp16) {\newline		if(!shape2) {\newline		    fprintf(stderr, &quotrfxswf: Error: Additional fillstyles not supported\\n&quot);fflush(stderr);\newline		    enumerateUsedIDs_styles(tag, dummycallback1, 0, version, 0);\newline		} else {\newline		    linestyleadd = shape2-&gtnumlinestyles;\newline		    fillstyleadd = shape2-&gtnumfillstyles;\newline		    if(!parseFillStyleArray(tag, shape2))\newline			return 0;\newline		}\newline		fillbits = swf_GetBits(tag, 4);\newline		linebits = swf_GetBits(tag, 4);\newline	    }\newline	    if(flags&amp1) { //move\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = moveTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	} else {\newline	    flags = swf_GetBits(tag, 1);\newline	    if(flags) { //straight edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		if(swf_GetBits(tag, 1)) { //line flag\newline		    x += swf_GetSBits(tag, n); //delta x\newline		    y += swf_GetSBits(tag, n); //delta y\newline		} else {\newline		    int v=swf_GetBits(tag, 1);\newline		    int d;\newline		    d = swf_GetSBits(tag, n); //vert/horz\newline		    if(v) y += d;\newline		    else  x += d;\newline		}\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = lineTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    } else { //curved edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		int x1,y1;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline		x1 = x;\newline		y1 = y;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = splineTo;\newline		lines-&gtsx = x1; \newline		lines-&gtsy = y1; \newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	}\newline    }\newline    return _lines.next;\newline}\newline","todo: merge this with swf_GetSimpleShape \newline","1003861","lp_report.c","MYBOOL REPORT_tableau(lprec *lp)\newline{\newline  int  j, row_nr, *coltarget;\newline  REAL *prow = NULL;\newline  FILE *stream = lp-&gtoutstream;\newline\newline  if(lp-&gtoutstream == NULL)\newline    return(FALSE);\newline\newline  if(!lp-&gtmodel_is_valid || !has_BFP(lp) ||\newline     (get_total_iter(lp) == 0) || (lp-&gtspx_status == NOTRUN)) {\newline    lp-&gtspx_status = NOTRUN;\newline    return(FALSE);\newline  }\newline  if(!allocREAL(lp, &ampprow,lp-&gtsum + 1, TRUE)) {\newline    lp-&gtspx_status = NOMEMORY;\newline    return(FALSE);\newline  }\newline\newline  fprintf(stream, &quot\\n&quot);\newline  fprintf(stream, &quotTableau at iter %.0f:\\n&quot, (double) get_total_iter(lp));\newline\newline  for(j = 1; j &lt= lp-&gtsum; j++)\newline    if (!lp-&gtis_basic[j])\newline      fprintf(stream, &quot%15d&quot, (j &lt= lp-&gtrows ?\newline                               (j + lp-&gtcolumns) * ((lp-&gtorig_upbo[j] == 0) ||\newline                                                    (is_chsign(lp, j)) ? 1 : -1) : j - lp-&gtrows) *\newline                              (lp-&gtis_lower[j] ? 1 : -1));\newline  fprintf(stream, &quot\\n&quot);\newline\newline  coltarget = (int *) mempool_obtainVector(lp-&gtworkarrays, lp-&gtcolumns+1, sizeof(*coltarget));\newline  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\newline    mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline    return(FALSE);\newline  }\newline  for(row_nr = 1; (row_nr &lt= lp-&gtrows + 1); row_nr++) {\newline    if (row_nr &lt= lp-&gtrows)\newline      fprintf(stream, &quot%3d&quot, (lp-&gtvar_basic[row_nr] &lt= lp-&gtrows ?\newline                              (lp-&gtvar_basic[row_nr] + lp-&gtcolumns) * ((lp-&gtorig_upbo[lp-&gtvar_basic [row_nr]] == 0) ||\newline                                                                       (is_chsign(lp, lp-&gtvar_basic[row_nr])) ? 1 : -1) : lp-&gtvar_basic[row_nr] - lp-&gtrows) *\newline                             (lp-&gtis_lower[lp-&gtvar_basic [row_nr]] ? 1 : -1));\newline    else\newline      fprintf(stream, &quot   &quot);\newline    bsolve(lp, row_nr &lt= lp-&gtrows ? row_nr : 0, prow, NULL, lp-&gtepsmachine*DOUBLEROUND, 1.0);\newline    prod_xA(lp, coltarget, prow, NULL, lp-&gtepsmachine, 1.0,\newline                                       prow, NULL, MAT_ROUNDDEFAULT);\newline\newline    for(j = 1; j &lt= lp-&gtrows + lp-&gtcolumns; j++)\newline      if (!lp-&gtis_basic[j])\newline        fprintf(stream, &quot%15.7f&quot, prow[j] * (lp-&gtis_lower[j] ? 1 : -1) *\newline                                            (row_nr &lt= lp-&gtrows ? 1 : -1));\newline    fprintf(stream, &quot%15.7f&quot, lp-&gtrhs[row_nr &lt= lp-&gtrows ? row_nr : 0] *\newline                              (double) ((row_nr &lt= lp-&gtrows) || (is_maxim(lp)) ? 1 : -1));\newline    fprintf(stream, &quot\\n&quot);\newline  }\newline  fflush(stream);\newline\newline  mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline  FREE(prow);\newline  return(TRUE);\newline}\newline","Report the traditional tableau corresponding to the current basis \newline","2806773","gui.c","void gui_remove_deploy_unit( Unit *unit )\newline{\newline    List_Entry *entry;\newline    Unit *next_unit;\newline    entry = list_entry( left_deploy_units, unit );\newline    if ( entry-&gtnext-&gtitem )\newline        next_unit = entry-&gtnext-&gtitem;\newline    else\newline        if ( entry-&gtprev-&gtitem )\newline            next_unit = entry-&gtprev-&gtitem;\newline        else\newline            next_unit = 0;\newline    list_delete_item( left_deploy_units, unit );\newline    deploy_unit = next_unit;\newline    gui_add_deploy_units( gui-&gtdeploy_window-&gtframe-&gtcontents );\newline    frame_apply( gui-&gtdeploy_window-&gtframe );\newline}\newline","\newline====================================================================\newlineUpdate deploy list. Unit is either removed or added to \newlineleft_deploy_units and the deploy window is updated.\newline====================================================================\newline \newline","2150485","citadel_ipc.c","int CtdlIPCKnownRooms(CtdlIPC *ipc, enum RoomList which, int floor, struct march **listing, char *cret)\newline{\newline	register int ret;\newline	struct march *march = NULL;\newline	static char *proto[] =\newline		{&quotLKRA&quot, &quotLKRN&quot, &quotLKRO&quot, &quotLZRM&quot, &quotLRMS&quot, &quotLPRM&quot };\newline	char aaa[SIZ];\newline	char *bbb = NULL;\newline	size_t bbb_len;\newline\newline	if (!listing) return -2;\newline	if (*listing) return -2;	/* Free the listing first */\newline	if (!cret) return -2;\newline	/* if (which &lt 0 || which &gt 4) return -2; */\newline	if (floor &lt -1) return -2;	/* Can&#039t validate upper bound, sorry */\newline\newline	sprintf(aaa, &quot%s %d&quot, proto[which], floor);\newline	ret = CtdlIPCGenericCommand(ipc, aaa, NULL, 0, &ampbbb, &ampbbb_len, cret);\newline	if (ret / 100 == 1) {\newline		struct march *mptr;\newline\newline		while (bbb &amp&amp strlen(bbb)) {\newline			int a;\newline\newline			extract_token(aaa, bbb, 0, &#039\\n&#039, sizeof aaa);\newline			a = strlen(aaa);\newline			memmove(bbb, bbb + a + 1, strlen(bbb) - a);\newline			mptr = (struct march *) malloc(sizeof (struct march));\newline			if (mptr) {\newline				mptr-&gtnext = NULL;\newline				extract_token(mptr-&gtmarch_name, aaa, 0, &#039|&#039, sizeof mptr-&gtmarch_name);\newline				mptr-&gtmarch_flags = (unsigned int) extract_int(aaa, 1);\newline				mptr-&gtmarch_floor = (char) extract_int(aaa, 2);\newline				mptr-&gtmarch_order = (char) extract_int(aaa, 3);\newline				mptr-&gtmarch_flags2 = (unsigned int) extract_int(aaa, 4);\newline				mptr-&gtmarch_access = (char) extract_int(aaa, 5);\newline				if (march == NULL)\newline					march = mptr;\newline				else {\newline					struct march *mptr2;\newline\newline					mptr2 = march;\newline					while (mptr2-&gtnext != NULL)\newline						mptr2 = mptr2-&gtnext;\newline					mptr2-&gtnext = mptr;\newline				}\newline			}\newline		}\newline	}\newline	*listing = march;\newline	if (bbb) free(bbb);\newline	return ret;\newline}\newline","floor is -1 for all, or floornum \newline","4489701","lcc.c","static void error(char *fmt, char *msg) {\newline	fprintf(stderr, &quot%s: &quot, progname);\newline	fprintf(stderr, fmt, msg);\newline	fprintf(stderr, &quot\\n&quot);\newline	errcnt++;\newline}\newline","error - issue error msg according to fmt, bump error count \newline","4065816","getopt.c","static int parse_tcp_opt(int ac, char *av[], struct opts *optsp)\newline{\newline\newline	/* memorize protocol */\newline	optsp-&gtns_proto = NS_PROTO_TCP;\newline\newline	/* tcp has some default values too, set them here */\newline	optsp-&gtperform_rtt_probe = 1;\newline	optsp-&gtprotocol = IPPROTO_TCP;\newline	optsp-&gtsocktype = SOCK_STREAM;\newline\newline	while (av[0] &amp&amp av[0][0] == &#039-&#039) {\newline		if (av[0][1] == &#039C&#039)\newline			optsp-&gttcp_use_md5sig = true;\newline\newline		if (optsp-&gtworkmode == MODE_RECEIVE) {\newline			/* need peer ip address */\newline			if (!av[1] || av[1][0] == &#039-&#039)\newline				err_msg_die(EXIT_FAILOPT, &quotOption -C needs an argument (Peer IP Address)&quot);\newline			optsp-&gttcp_md5sig_peeraddr = av[1];\newline			ac--;\newline			av++;\newline		}\newline		ac--;\newline		av++;\newline	}\newline\newline	if (optsp-&gttcp_use_md5sig)\newline		msg(GENTLE, &quotEnabled TCP_MD5SIG option&quot);\newline	/* Now parse all transmit | receive specific code, plus the most\newline	 * important options: the file- and hostname\newline	 */\newline	switch (optsp-&gtworkmode) {\newline		case MODE_TRANSMIT:\newline			/* sanity check first */\newline			if (ac &lt= 1)\newline				print_usage(&quottcp transmit mode required file and destination address\\n&quot,\newline						HELP_STR_GLOBAL, 1);\newline\newline			optsp-&gtinfile = xstrdup(av[0]);\newline			optsp-&gthostname = xstrdup(av[1]);\newline\newline			break;\newline		case MODE_RECEIVE:\newline			switch (ac) {\newline				case 0: /* nothing to do */\newline					break;\newline\newline				case 2:\newline					opts.hostname = xstrdup(av[1]);\newline					/* fallthrough */\newline				case 1:\newline					opts.outfile = xstrdup(av[0]);\newline					break;\newline				default:\newline					err_msg(&quotYou specify to many arguments!&quot);\newline					print_usage(NULL, HELP_STR_GLOBAL, 1);\newline					break;\newline			};\newline\newline			break;\newline		default:\newline			err_msg_die(EXIT_FAILINT,\newline					&quotInternal, programmed error - unknown tranmit mode: %d\\n&quot,\newline					optsp-&gtworkmode);\newline	}\newline\newline	return SUCCESS;\newline}\newline","parse_tcp_opt set all tcp default values\newline within optsp and parse all tcp related options\newline ac is the number of arguments from MODE and av is\newline the correspond pointer into the array vector. We parse all tcp\newline related options first and within the switch/case statement we handle\newline transmit | receive specific options.\newline \newline","6007439","objrtmch.c","static void QueueObjectMatchAction(\newline  void *theEnv,\newline  int type,\newline  INSTANCE_TYPE *ins,\newline  int slotNameID)\newline  {\newline   OBJECT_MATCH_ACTION *prv,*cur,*newMatch;\newline\newline   prv = NULL;\newline   cur = ObjectReteData(theEnv)-&gtObjectMatchActionQueue;\newline   while (cur != NULL)\newline     {\newline      /* ===========================================================\newline         Here are the possibilities for the first Rete event already\newline         on the queue as compared with the new event for an object:\newline\newline         Assert/Retract  --&gt  Delete assert event\newline                              Ignore retract event\newline         Assert/Modify   --&gt  Ignore modify event\newline         Modify/Modify   --&gt  Merge new modify event\newline         Modify/Retract  --&gt  Delete modify event\newline                              Queue the retract event\newline         =========================================================== */\newline      if (cur-&gtins == ins)\newline        {\newline         /* ===================================================\newline            An action for initially asserting the newly created\newline            object to all applicable patterns\newline            =================================================== */\newline         if (cur-&gttype == OBJECT_ASSERT)\newline           {\newline            if (type == OBJECT_RETRACT)\newline              {\newline               /* ===================================================\newline                  If we are retracting the entire object, then we can\newline                  remove the assert action (and all modifies as well)\newline                  and ignore the retract action\newline                  (basically the object came and went before the Rete\newline                  network had a chance to see it)\newline                  =================================================== */\newline               if (prv == NULL)\newline                 ObjectReteData(theEnv)-&gtObjectMatchActionQueue = cur-&gtnxt;\newline               else\newline                 prv-&gtnxt = cur-&gtnxt;\newline               cur-&gtins-&gtbusy--;\newline               ReturnObjectMatchAction(theEnv,cur);\newline              }\newline\newline            /* =================================================\newline               If this is a modify action, then we can ignore it\newline               since the assert action will encompass it\newline               ================================================= */\newline           }\newline\newline         /* ===================================================\newline            If the object is being deleted after a slot modify,\newline            drop the modify event and replace with the retract\newline            =================================================== */\newline         else if (type == OBJECT_RETRACT)\newline           {\newline            cur-&gttype = OBJECT_RETRACT;\newline            if (cur-&gtslotNameIDs != NULL)\newline              {\newline               rm(theEnv,(void *) cur-&gtslotNameIDs,SlotBitMapSize(cur-&gtslotNameIDs));\newline               cur-&gtslotNameIDs = NULL;\newline              }\newline           }\newline\newline         /* ====================================================\newline            If a modify event for this slot is already on the\newline            queue, ignore this one. Otherwise, merge the slot id\newline            ==================================================== */\newline         else\newline            cur-&gtslotNameIDs = QueueModifySlotMap(theEnv,cur-&gtslotNameIDs,slotNameID);\newline\newline         return;\newline        }\newline      prv = cur;\newline      cur = cur-&gtnxt;\newline     }\newline\newline   /* ================================================\newline      If there are no actions for the instance already\newline      on the queue, the new action is simply appended.\newline      ================================================ */\newline   newMatch = get_struct(theEnv,objectMatchAction);\newline   newMatch-&gttype = type;\newline   newMatch-&gtnxt = cur;\newline   newMatch-&gtslotNameIDs = (type != OBJECT_MODIFY) ? NULL :\newline                       QueueModifySlotMap(theEnv,NULL,slotNameID);\newline   newMatch-&gtins = ins;\newline   newMatch-&gtins-&gtbusy++;\newline   if (prv == NULL)\newline     ObjectReteData(theEnv)-&gtObjectMatchActionQueue = newMatch;\newline   else\newline     prv-&gtnxt = newMatch;\newline  }\newline","\newlineNAME : QueueObjectMatchAction\newlineDESCRIPTION : Posts a Rete network match event\newlinefor later processing\newlineINPUTS : 1) The match action type\newlineOBJECT_ASSERT (1)\newlineOBJECT_RETRACT (2)\newlineOBJECT_MODIFY (3)\newline2) The instance to be matched\newline3) The name id of the slot being\newlineupdated (can be -1)\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Queue updated\newlineNOTES : None\newline \newline","1886672","libtcc.c","static void tcc_cleanup(void)\newline{\newline    int i, n;\newline    if (NULL == tcc_state)\newline        return;\newline    tcc_state = NULL;\newline\newline    /* free -D defines */\newline    free_defines(NULL);\newline\newline    /* free tokens */\newline    n = tok_ident - TOK_IDENT;\newline    for(i = 0; i &lt n; i++)\newline        free(table_ident[i]);\newline    free(table_ident);\newline\newline    /* free sym_pools */\newline    dynarray_reset(&ampsym_pools, &ampnb_sym_pools);\newline    /* string buffer */\newline    cstr_free(&amptokcstr);\newline    /* reset symbol stack */\newline    sym_free_first = NULL;\newline    /* cleanup from error/setjmp */\newline    macro_ptr = NULL;\newline}\newline","cleanup all static data used during compilation \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","pointer of the concurrency","arch-specific routine; the","Deallocate everything","Compute the system key from various system information,","find out which one it was.","merge this with swf_GetSimpleShape","Report the traditional tableau corresponding to the current basis","Update deploy list.","floor is -1 for all,","issue error msg according to fmt,","set all tcp default values","Move up","Posts a Rete network match eventfor later processing","cleanup all static data used during compilation","write a 50KB file","locked","Change the title of a specified axis","Add context to a specific channel for global UST domain.","loads data from object'sstorage point.","extract check result","On a connected range fetch, send another request to the remote"
"33Q5P9PUSPMOL35S48W3RZW80KRZC2","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3AQF3RZ558IVNP2KJ7UURQK58F6F6M","AQ3KPKZ6UIYPF","Approved","Wed Apr 17 09:50:41 PDT 2019","Wed Apr 17 10:15:41 PDT 2019","Fri Apr 19 10:15:41 PDT 2019","2019-04-19 17:16:21 UTC","","","1500","100% (1/1)","100% (1/1)","100% (1/1)","1328629","ms_task.c","static void ms_single_getset_task_sch(ms_conn_t *c)\newline{\newline  ms_task_t *task;\newline  ms_task_item_t *item;\newline\newline  /* the last time don&#039t run a task */\newline  if (c-&gtremain_exec_num-- &gt 0)\newline  {\newline    task= ms_get_task(c, false);\newline    item= task-&gtitem;\newline    if (task-&gtcmd == CMD_SET)\newline    {\newline      ms_mcd_set(c, item);\newline    }\newline    else if (task-&gtcmd == CMD_GET)\newline    {\newline      assert(task-&gtcmd == CMD_GET);\newline      ms_mcd_get(c, item);\newline    }\newline  }\newline} /* ms_single_getset_task_sch */\newline","\newline dispatch single get and set task\newline \newline @param c, pointer of the concurrency\newline \newline","263800","disasmview.c","static gboolean move_up_lines(TilemDisasmView *dv, int count)\newline{\newline	TilemCalc *calc;\newline	dword pos;\newline	int linenum;\newline\newline	if (!get_cursor_line(dv, NULL, &amplinenum))\newline		linenum = 0;\newline\newline	if (linenum &gt= count)\newline		return FALSE;\newline\newline	tilem_calc_emulator_lock(dv-&gtdbg-&gtemu);\newline	calc = dv-&gtdbg-&gtemu-&gtcalc;\newline\newline	pos = dv-&gtstartpos;\newline	count -= linenum;\newline	while (count &gt 0) {\newline		pos = get_prev_pos(dv, calc, pos);\newline		count--;\newline	}\newline\newline	tilem_calc_emulator_unlock(dv-&gtdbg-&gtemu);\newline\newline	refresh_disassembly(dv, pos, dv-&gtnlines, pos);\newline\newline	return TRUE;\newline}\newline","Move up by COUNT lines \newline","2129121","stream.c","void test_filter_stream__smallfile(void)\newline{\newline	test_stream(5);\newline}\newline","write a 50KB file through the &quotcompression&quot stream \newline","4539621","srp_sync.c","struct target_details *pop_from_retry_list(struct sync_resources *res)\newline{\newline	struct target_details *ret = res-&gtretry_tasks_head;\newline\newline	if (ret)\newline		res-&gtretry_tasks_head = ret-&gtnext;\newline	else\newline		res-&gtretry_tasks_tail = NULL;\newline\newline	return ret;\newline}\newline","assumes that res-&gtretry_mutex is locked !!! \newline","6448631","qwt_plot_axis.cpp","void QwtPlot::setAxisTitle( QwtAxisId axisId, const QString &amptitle )\newline{\newline    if ( isAxisValid( axisId ) )\newline        axisWidget( axisId )-&gtsetTitle( title );\newline}\newline","!\newline\\brief Change the title of a specified axis\newline\\param axisPos Axis position\newline\\param title axis title\newline \newline","287086","ust-app.c","int ust_app_add_ctx_channel_glb(struct ltt_ust_session *usess,\newline		struct ltt_ust_channel *uchan, struct ltt_ust_context *uctx)\newline{\newline	int ret = 0;\newline	struct lttng_ht_node_str *ua_chan_node;\newline	struct lttng_ht_iter iter, uiter;\newline	struct ust_app_channel *ua_chan = NULL;\newline	struct ust_app_session *ua_sess;\newline	struct ust_app *app;\newline\newline	rcu_read_lock();\newline\newline	cds_lfht_for_each_entry(ust_app_ht-&gtht, &ampiter.iter, app, pid_n.node) {\newline		if (!app-&gtcompatible) {\newline			/*\newline			 * TODO: In time, we should notice the caller of this error by\newline			 * telling him that this is a version error.\newline			 */\newline			continue;\newline		}\newline		ua_sess = lookup_session_by_app(usess, app);\newline		if (ua_sess == NULL) {\newline			continue;\newline		}\newline\newline		pthread_mutex_lock(&ampua_sess-&gtlock);\newline\newline		if (ua_sess-&gtdeleted) {\newline			pthread_mutex_unlock(&ampua_sess-&gtlock);\newline			continue;\newline		}\newline\newline		/* Lookup channel in the ust app session */\newline		lttng_ht_lookup(ua_sess-&gtchannels, (void *)uchan-&gtname, &ampuiter);\newline		ua_chan_node = lttng_ht_iter_get_node_str(&ampuiter);\newline		if (ua_chan_node == NULL) {\newline			goto next_app;\newline		}\newline		ua_chan = caa_container_of(ua_chan_node, struct ust_app_channel,\newline				node);\newline		ret = create_ust_app_channel_context(ua_sess, ua_chan, &ampuctx-&gtctx, app);\newline		if (ret &lt 0) {\newline			goto next_app;\newline		}\newline	next_app:\newline		pthread_mutex_unlock(&ampua_sess-&gtlock);\newline	}\newline\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Add context to a specific channel for global UST domain.\newline \newline","636433","chat-shared.cpp","void ChatShared::load()\newline{\newline	if (!isValidStorage())\newline		return;\newline\newline	Shared::load();\newline\newline	ConfigurationApi *configurationStorage = storage()-&gtstorage();\newline	QDomElement parent = storage()-&gtpoint();\newline\newline	Groups.clear();\newline\newline	QDomElement groupsNode = configurationStorage-&gtgetNode(parent, &quotChatGroups&quot, ConfigurationApi::ModeFind);\newline	if (!groupsNode.isNull())\newline	{\newline		QDomNodeList groupsList = groupsNode.elementsByTagName(&quotGroup&quot);\newline\newline		int count = groupsList.count();\newline		for (int i = 0; i &lt count; i++)\newline		{\newline			QDomElement groupElement = groupsList.at(i).toElement();\newline			if (groupElement.isNull())\newline				continue;\newline			doAddToGroup(m_groupManager-&gtbyUuid(groupElement.text()));\newline		}\newline	}\newline\newline	*ChatAccount = m_accountManager-&gtbyUuid(QUuid(loadValue&ltQString&gt(&quotAccount&quot)));\newline	Display = loadValue&ltQString&gt(&quotDisplay&quot);\newline	auto type = loadValue&ltQString&gt(&quotType&quot);\newline\newline	// import from alias to new name of chat type\newline	ChatType *chatType = m_chatTypeManager-&gtchatType(type);\newline	if (chatType)\newline		type = chatType-&gtname();\newline\newline	// we should not have display names for Contact chats\newline	if (type == &quotContact&quot)\newline		Display.clear();\newline\newline	setType(type);\newline}\newline","\newline @author Rafal &#039Vogel&#039 Malinowski\newline @short Loads chat data from storage.\newline \newline This method is called when object is used at first time. It loads data from object&#039s\newline storage point. After loading data chat type is known (&#039Type&#039) so this method check\newline if the type is any of known chat types. If so, details class is created, assigned and\newline loaded - chat has full data available. If no, loading details class is deffered to\newline moment after good chat type is loaded. This mechanism is provided by\newline @link ChatTypeAvareObject @endlink class.\newline \newline","311642","checks.c","static void extract_check_result(FILE *fp, dbuf *checkresult_dbuf) {\newline	char output_buffer[MAX_INPUT_BUFFER] = &quot&quot;\newline	char *temp_buffer;\newline\newline	/* initialize buffer */\newline	strcpy(output_buffer, &quot&quot);\newline\newline	/* get all lines of plugin output - escape newlines */\newline	while (fgets(output_buffer, sizeof(output_buffer) - 1, fp)) {\newline		temp_buffer = escape_newlines(output_buffer);\newline		dbuf_strcat(checkresult_dbuf, temp_buffer);\newline		my_free(temp_buffer);\newline	}\newline}\newline","extract check result \newline","5899901","http.c","static void range_fetch_getmore(struct range_fetch *rf) {\newline    char request[2048];\newline    int l;\newline    int max_range_per_request = 20;\newline\newline    /* Only if there&#039s stuff queued to get */\newline    if (rf-&gtrangessent == rf-&gtnranges)\newline        return;\newline\newline    /* Build the base request, everything up to the Range: bytes= */\newline    snprintf(request, sizeof(request),\newline             &quotGET %s HTTP/1.1\\r\\n&quot\newline             &quotUser-Agent: zsync/&quot VERSION &quot\\r\\n&quot\newline             &quotHost: %s&quot\newline             &quot%s%s\\r\\n&quot\newline             &quot%s&quot\newline             &quotRange: bytes=&quot,\newline             rf-&gturl, rf-&gthosth,\newline             referer ? &quot\\r\\nReferer: &quot : &quot&quot, referer ? referer : &quot&quot,\newline             rf-&gtauthh ? rf-&gtauthh : &quot&quot);\newline\newline    /* The for loop here is just a sanity check, lastrange is the real loop control */\newline    for (; rf-&gtrangessent &lt rf-&gtnranges;) {\newline        int i = rf-&gtrangessent;\newline        int lastrange = 0;\newline\newline        /* Add at least one byterange to the request; but is this the last one? \newline         * That&#039s decided based on whether there are any more to add, whether\newline         * we&#039ve reached our self-imposed limit per request, and whether\newline         * there&#039s buffer space to add more.\newline         */\newline        l = strlen(request);\newline        if (l &gt 1200 || !(--max_range_per_request) || i == rf-&gtnranges - 1)\newline            lastrange = 1;\newline\newline        /* Append to the request */\newline        snprintf(request + l, sizeof(request) - l, OFF_T_PF &quot-&quot OFF_T_PF &quot%s&quot,\newline                 rf-&gtranges_todo[2 * i], rf-&gtranges_todo[2 * i + 1],\newline                 lastrange ? &quot&quot : &quot,&quot);\newline\newline        /* And record that we have sent this one */\newline        rf-&gtrangessent++;\newline\newline        /* Exit loop if that is the last to add */\newline        if (lastrange)\newline            break;\newline    }\newline    l = strlen(request);\newline\newline    /* Possibly close the connection (and record the fact, so we definitely\newline     * don&#039t send more stuff) if this is the last */\newline    snprintf(request + l, sizeof(request) - l, &quot\\r\\n%s\\r\\n&quot,\newline             rf-&gtrangessent == rf-&gtnranges ? (rf-&gtserver_close =\newline                                              1, &quotConnection: close\\r\\n&quot) : &quot&quot);\newline\newline    {   /* Send the request */\newline        size_t len = strlen(request);\newline        char *p = request;\newline        int r = 0;\newline\newline        while (len &gt 0\newline               &amp&amp ((r = send(rf-&gtsd, p, len, 0)) != -1 || errno == EINTR)) {\newline            if (r &gt= 0) {\newline                p += r;\newline                len -= r;\newline            }\newline        }\newline        if (r == -1) {\newline            perror(&quotsend&quot);\newline        }\newline    }\newline}\newline","range_fetch_getmore\newline On a connected range fetch, send another request to the remote \newline","2332588","qemuarch.c","const char *qemu_arch_qemumachine(const char *arch) {\newline	if (!strcmp(arch, &quotarm&quot) || !strcmp(arch, &quotarmel&quot)) {\newline		return &quotversatilepb&quot;\newline	} else if (!strcmp(arch, &quotarmhf&quot) || !strcmp(arch, &quotarm64&quot)) {\newline		return &quotvirt&quot;\newline	} else if (!strcmp(arch, &quoti386&quot) || !strcmp(arch, &quothurd-i386&quot) ||\newline			   !strcmp(arch, &quotamd64&quot) || !strcmp(arch, &quotx32&quot)) {\newline		return &quotpc&quot;\newline	} else if (!strcmp(arch, &quotmips&quot) || !strcmp(arch, &quotmipsel&quot)) {\newline		return &quotmalta&quot;\newline	} else if (!strcmp(arch, &quotpowerpc&quot)) {\newline		return &quotprep&quot;\newline	} else if (!strcmp(arch, &quotsparc&quot)) {\newline		return &quotSS-5&quot;\newline	}\newline	return NULL;\newline}\newline","\newline arch-specific routine; the machine spec for this arch\newline \newline","6629324","ibv.c","int finalizeIB(ArgStruct *p)\newline{\newline  int ret;\newline\newline  LOGPRINTF((&quotFinalizing IB stuff&quot));\newline    /* NOTE: This implementation only has created one of each type of queue.\newline     * In other implementations it may be necessary to create arrays of \newline     * these queues.  If this is the case, you need to loop and get them all */\newline  if(qp_hndl) {	    \newline    LOGPRINTF((&quotDestroying QP&quot));\newline    ret = ibv_destroy_qp(qp_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying Queue Pair\\n&quot);\newline    }\newline  }\newline\newline  if(r_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Recv CQ&quot));\newline    ret = ibv_destroy_cq(r_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying recv CQ\\n&quot);\newline    }\newline  }\newline\newline  if(s_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Send CQ&quot));\newline    ret = ibv_destroy_cq(s_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying send CQ\\n&quot);\newline    }\newline  }\newline\newline  /* Check memory registrations just in case user bailed out */\newline  if(s_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering send buffer&quot));\newline    ret = ibv_dereg_mr(s_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering send mr\\n&quot);\newline    }\newline  }\newline\newline  if(r_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering recv buffer&quot));\newline    ret = ibv_dereg_mr(r_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering recv mr\\n&quot);\newline    }\newline  }\newline\newline  if(pd_hndl) {\newline    LOGPRINTF((&quotDeallocating PD&quot));\newline    ret = ibv_dealloc_pd(pd_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deallocating PD\\n&quot);\newline    }\newline  }\newline\newline  /* Application code should not close HCA, just release handle */\newline\newline  if(ctx) {\newline    LOGPRINTF((&quotReleasing HCA&quot));\newline    ret = ibv_close_device(ctx);\newline    if(ret) {\newline      fprintf(stderr, &quotError releasing HCA\\n&quot);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","Deallocate everything properly \newline","3008347","drms.c","static int GetSystemKey( uint32_t *p_sys_key, uint32_t b_ipod )\newline{\newline    static char const p_secret1[ 8 ] = &quotYuaFlafu&quot;\newline    static char const p_secret2[ 8 ] = &quotzPif98ga&quot;\newline    struct md5_s md5;\newline    int64_t i_ipod_id;\newline    uint32_t p_system_hash[ 4 ];\newline\newline    /* Compute the MD5 hash of our system info */\newline    if( ( !b_ipod &amp&amp HashSystemInfo( p_system_hash ) ) ||\newline        (  b_ipod &amp&amp GetiPodID( &ampi_ipod_id ) ) )\newline    {\newline        return -1;\newline    }\newline\newline    /* Combine our system info hash with additional secret data. The resulting\newline     * MD5 hash will be our system key. */\newline    InitMD5( &ampmd5 );\newline    AddMD5( &ampmd5, (uint8_t *)p_secret1, 8 );\newline\newline    if( !b_ipod )\newline    {\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_secret2, 8 );\newline    }\newline    else\newline    {\newline        i_ipod_id = U64_AT(&ampi_ipod_id);\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline    }\newline\newline    EndMD5( &ampmd5 );\newline\newline    memcpy( p_sys_key, md5.p_digest, 16 );\newline\newline    return 0;\newline}\newline","\newline GetSystemKey: get the system key\newline \newline Compute the system key from various system information, see HashSystemInfo.\newline \newline","5861021","main.c","unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)\newline{\newline	struct syscallentry *entry;\newline	unsigned int fd;\newline\newline	entry = get_syscall_entry(rec-&gtnr, rec-&gtdo32bit);\newline\newline	if ((entry-&gtarg1type != ARG_FD) &amp&amp\newline	    (entry-&gtarg1type != ARG_SOCKETINFO))\newline	    return FALSE;\newline\newline	/* in the SOCKETINFO case, post syscall, a1 is actually the fd,\newline	 * not the socketinfo.  In ARG_FD a1=fd.\newline	 */\newline	fd = rec-&gta1;\newline\newline	/* if it&#039s out of range, it&#039s not going to be valid. */\newline	if (fd &gt 1024)\newline		return FALSE;\newline\newline	if (logging == LOGGING_FILES) {\newline		if (child-&gtlogfile == NULL)\newline			return FALSE;\newline\newline		if (fd &lt= (unsigned int) fileno(child-&gtlogfile))\newline			return FALSE;\newline	}\newline	return TRUE;\newline}\newline","if the first arg was an fd, find out which one it was.\newline Call with syscallrecord lock held. \newline","1392224","swfshape.c","static SHAPELINE* swf_ParseShapeData(U8*data, int bits, int fillbits, int linebits, int version, SHAPE2*shape2)\newline{\newline    SHAPELINE _lines;\newline    SHAPELINE*lines = &amp_lines;\newline\newline    TAG _tag;\newline    TAG* tag = &amp_tag;\newline    int fill0 = 0;\newline    int fill1 = 0;\newline    int line = 0;\newline    int x=0,y=0;\newline    int linestyleadd=0;\newline    int fillstyleadd=0;\newline    \newline    memset(tag, 0, sizeof(TAG));\newline    tag-&gtdata = data;\newline    tag-&gtlen = tag-&gtmemsize = (bits+7)/8;\newline    tag-&gtpos = 0;\newline    tag-&gtid = version==1?ST_DEFINESHAPE:(version==2?ST_DEFINESHAPE2:(version==3?ST_DEFINESHAPE3:ST_DEFINESHAPE4));\newline\newline    lines-&gtnext = 0;\newline    while(1) {\newline	int flags;\newline	flags = swf_GetBits(tag, 1);\newline	if(!flags) { //style change\newline	    flags = swf_GetBits(tag, 5);\newline	    if(!flags)\newline		break;\newline	    if(flags&amp1) { //move\newline		int n = swf_GetBits(tag, 5); \newline		x = swf_GetSBits(tag, n); //x\newline		y = swf_GetSBits(tag, n); //y\newline	    }\newline	    if(flags&amp2)\newline		fill0 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp4)\newline		fill1 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp8)\newline		line = swf_GetBits(tag, linebits) + linestyleadd; \newline	    if(flags&amp16) {\newline		if(!shape2) {\newline		    fprintf(stderr, &quotrfxswf: Error: Additional fillstyles not supported\\n&quot);fflush(stderr);\newline		    enumerateUsedIDs_styles(tag, dummycallback1, 0, version, 0);\newline		} else {\newline		    linestyleadd = shape2-&gtnumlinestyles;\newline		    fillstyleadd = shape2-&gtnumfillstyles;\newline		    if(!parseFillStyleArray(tag, shape2))\newline			return 0;\newline		}\newline		fillbits = swf_GetBits(tag, 4);\newline		linebits = swf_GetBits(tag, 4);\newline	    }\newline	    if(flags&amp1) { //move\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = moveTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	} else {\newline	    flags = swf_GetBits(tag, 1);\newline	    if(flags) { //straight edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		if(swf_GetBits(tag, 1)) { //line flag\newline		    x += swf_GetSBits(tag, n); //delta x\newline		    y += swf_GetSBits(tag, n); //delta y\newline		} else {\newline		    int v=swf_GetBits(tag, 1);\newline		    int d;\newline		    d = swf_GetSBits(tag, n); //vert/horz\newline		    if(v) y += d;\newline		    else  x += d;\newline		}\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = lineTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    } else { //curved edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		int x1,y1;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline		x1 = x;\newline		y1 = y;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = splineTo;\newline		lines-&gtsx = x1; \newline		lines-&gtsy = y1; \newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	}\newline    }\newline    return _lines.next;\newline}\newline","todo: merge this with swf_GetSimpleShape \newline","1003861","lp_report.c","MYBOOL REPORT_tableau(lprec *lp)\newline{\newline  int  j, row_nr, *coltarget;\newline  REAL *prow = NULL;\newline  FILE *stream = lp-&gtoutstream;\newline\newline  if(lp-&gtoutstream == NULL)\newline    return(FALSE);\newline\newline  if(!lp-&gtmodel_is_valid || !has_BFP(lp) ||\newline     (get_total_iter(lp) == 0) || (lp-&gtspx_status == NOTRUN)) {\newline    lp-&gtspx_status = NOTRUN;\newline    return(FALSE);\newline  }\newline  if(!allocREAL(lp, &ampprow,lp-&gtsum + 1, TRUE)) {\newline    lp-&gtspx_status = NOMEMORY;\newline    return(FALSE);\newline  }\newline\newline  fprintf(stream, &quot\\n&quot);\newline  fprintf(stream, &quotTableau at iter %.0f:\\n&quot, (double) get_total_iter(lp));\newline\newline  for(j = 1; j &lt= lp-&gtsum; j++)\newline    if (!lp-&gtis_basic[j])\newline      fprintf(stream, &quot%15d&quot, (j &lt= lp-&gtrows ?\newline                               (j + lp-&gtcolumns) * ((lp-&gtorig_upbo[j] == 0) ||\newline                                                    (is_chsign(lp, j)) ? 1 : -1) : j - lp-&gtrows) *\newline                              (lp-&gtis_lower[j] ? 1 : -1));\newline  fprintf(stream, &quot\\n&quot);\newline\newline  coltarget = (int *) mempool_obtainVector(lp-&gtworkarrays, lp-&gtcolumns+1, sizeof(*coltarget));\newline  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\newline    mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline    return(FALSE);\newline  }\newline  for(row_nr = 1; (row_nr &lt= lp-&gtrows + 1); row_nr++) {\newline    if (row_nr &lt= lp-&gtrows)\newline      fprintf(stream, &quot%3d&quot, (lp-&gtvar_basic[row_nr] &lt= lp-&gtrows ?\newline                              (lp-&gtvar_basic[row_nr] + lp-&gtcolumns) * ((lp-&gtorig_upbo[lp-&gtvar_basic [row_nr]] == 0) ||\newline                                                                       (is_chsign(lp, lp-&gtvar_basic[row_nr])) ? 1 : -1) : lp-&gtvar_basic[row_nr] - lp-&gtrows) *\newline                             (lp-&gtis_lower[lp-&gtvar_basic [row_nr]] ? 1 : -1));\newline    else\newline      fprintf(stream, &quot   &quot);\newline    bsolve(lp, row_nr &lt= lp-&gtrows ? row_nr : 0, prow, NULL, lp-&gtepsmachine*DOUBLEROUND, 1.0);\newline    prod_xA(lp, coltarget, prow, NULL, lp-&gtepsmachine, 1.0,\newline                                       prow, NULL, MAT_ROUNDDEFAULT);\newline\newline    for(j = 1; j &lt= lp-&gtrows + lp-&gtcolumns; j++)\newline      if (!lp-&gtis_basic[j])\newline        fprintf(stream, &quot%15.7f&quot, prow[j] * (lp-&gtis_lower[j] ? 1 : -1) *\newline                                            (row_nr &lt= lp-&gtrows ? 1 : -1));\newline    fprintf(stream, &quot%15.7f&quot, lp-&gtrhs[row_nr &lt= lp-&gtrows ? row_nr : 0] *\newline                              (double) ((row_nr &lt= lp-&gtrows) || (is_maxim(lp)) ? 1 : -1));\newline    fprintf(stream, &quot\\n&quot);\newline  }\newline  fflush(stream);\newline\newline  mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline  FREE(prow);\newline  return(TRUE);\newline}\newline","Report the traditional tableau corresponding to the current basis \newline","2806773","gui.c","void gui_remove_deploy_unit( Unit *unit )\newline{\newline    List_Entry *entry;\newline    Unit *next_unit;\newline    entry = list_entry( left_deploy_units, unit );\newline    if ( entry-&gtnext-&gtitem )\newline        next_unit = entry-&gtnext-&gtitem;\newline    else\newline        if ( entry-&gtprev-&gtitem )\newline            next_unit = entry-&gtprev-&gtitem;\newline        else\newline            next_unit = 0;\newline    list_delete_item( left_deploy_units, unit );\newline    deploy_unit = next_unit;\newline    gui_add_deploy_units( gui-&gtdeploy_window-&gtframe-&gtcontents );\newline    frame_apply( gui-&gtdeploy_window-&gtframe );\newline}\newline","\newline====================================================================\newlineUpdate deploy list. Unit is either removed or added to \newlineleft_deploy_units and the deploy window is updated.\newline====================================================================\newline \newline","2150485","citadel_ipc.c","int CtdlIPCKnownRooms(CtdlIPC *ipc, enum RoomList which, int floor, struct march **listing, char *cret)\newline{\newline	register int ret;\newline	struct march *march = NULL;\newline	static char *proto[] =\newline		{&quotLKRA&quot, &quotLKRN&quot, &quotLKRO&quot, &quotLZRM&quot, &quotLRMS&quot, &quotLPRM&quot };\newline	char aaa[SIZ];\newline	char *bbb = NULL;\newline	size_t bbb_len;\newline\newline	if (!listing) return -2;\newline	if (*listing) return -2;	/* Free the listing first */\newline	if (!cret) return -2;\newline	/* if (which &lt 0 || which &gt 4) return -2; */\newline	if (floor &lt -1) return -2;	/* Can&#039t validate upper bound, sorry */\newline\newline	sprintf(aaa, &quot%s %d&quot, proto[which], floor);\newline	ret = CtdlIPCGenericCommand(ipc, aaa, NULL, 0, &ampbbb, &ampbbb_len, cret);\newline	if (ret / 100 == 1) {\newline		struct march *mptr;\newline\newline		while (bbb &amp&amp strlen(bbb)) {\newline			int a;\newline\newline			extract_token(aaa, bbb, 0, &#039\\n&#039, sizeof aaa);\newline			a = strlen(aaa);\newline			memmove(bbb, bbb + a + 1, strlen(bbb) - a);\newline			mptr = (struct march *) malloc(sizeof (struct march));\newline			if (mptr) {\newline				mptr-&gtnext = NULL;\newline				extract_token(mptr-&gtmarch_name, aaa, 0, &#039|&#039, sizeof mptr-&gtmarch_name);\newline				mptr-&gtmarch_flags = (unsigned int) extract_int(aaa, 1);\newline				mptr-&gtmarch_floor = (char) extract_int(aaa, 2);\newline				mptr-&gtmarch_order = (char) extract_int(aaa, 3);\newline				mptr-&gtmarch_flags2 = (unsigned int) extract_int(aaa, 4);\newline				mptr-&gtmarch_access = (char) extract_int(aaa, 5);\newline				if (march == NULL)\newline					march = mptr;\newline				else {\newline					struct march *mptr2;\newline\newline					mptr2 = march;\newline					while (mptr2-&gtnext != NULL)\newline						mptr2 = mptr2-&gtnext;\newline					mptr2-&gtnext = mptr;\newline				}\newline			}\newline		}\newline	}\newline	*listing = march;\newline	if (bbb) free(bbb);\newline	return ret;\newline}\newline","floor is -1 for all, or floornum \newline","4489701","lcc.c","static void error(char *fmt, char *msg) {\newline	fprintf(stderr, &quot%s: &quot, progname);\newline	fprintf(stderr, fmt, msg);\newline	fprintf(stderr, &quot\\n&quot);\newline	errcnt++;\newline}\newline","error - issue error msg according to fmt, bump error count \newline","4065816","getopt.c","static int parse_tcp_opt(int ac, char *av[], struct opts *optsp)\newline{\newline\newline	/* memorize protocol */\newline	optsp-&gtns_proto = NS_PROTO_TCP;\newline\newline	/* tcp has some default values too, set them here */\newline	optsp-&gtperform_rtt_probe = 1;\newline	optsp-&gtprotocol = IPPROTO_TCP;\newline	optsp-&gtsocktype = SOCK_STREAM;\newline\newline	while (av[0] &amp&amp av[0][0] == &#039-&#039) {\newline		if (av[0][1] == &#039C&#039)\newline			optsp-&gttcp_use_md5sig = true;\newline\newline		if (optsp-&gtworkmode == MODE_RECEIVE) {\newline			/* need peer ip address */\newline			if (!av[1] || av[1][0] == &#039-&#039)\newline				err_msg_die(EXIT_FAILOPT, &quotOption -C needs an argument (Peer IP Address)&quot);\newline			optsp-&gttcp_md5sig_peeraddr = av[1];\newline			ac--;\newline			av++;\newline		}\newline		ac--;\newline		av++;\newline	}\newline\newline	if (optsp-&gttcp_use_md5sig)\newline		msg(GENTLE, &quotEnabled TCP_MD5SIG option&quot);\newline	/* Now parse all transmit | receive specific code, plus the most\newline	 * important options: the file- and hostname\newline	 */\newline	switch (optsp-&gtworkmode) {\newline		case MODE_TRANSMIT:\newline			/* sanity check first */\newline			if (ac &lt= 1)\newline				print_usage(&quottcp transmit mode required file and destination address\\n&quot,\newline						HELP_STR_GLOBAL, 1);\newline\newline			optsp-&gtinfile = xstrdup(av[0]);\newline			optsp-&gthostname = xstrdup(av[1]);\newline\newline			break;\newline		case MODE_RECEIVE:\newline			switch (ac) {\newline				case 0: /* nothing to do */\newline					break;\newline\newline				case 2:\newline					opts.hostname = xstrdup(av[1]);\newline					/* fallthrough */\newline				case 1:\newline					opts.outfile = xstrdup(av[0]);\newline					break;\newline				default:\newline					err_msg(&quotYou specify to many arguments!&quot);\newline					print_usage(NULL, HELP_STR_GLOBAL, 1);\newline					break;\newline			};\newline\newline			break;\newline		default:\newline			err_msg_die(EXIT_FAILINT,\newline					&quotInternal, programmed error - unknown tranmit mode: %d\\n&quot,\newline					optsp-&gtworkmode);\newline	}\newline\newline	return SUCCESS;\newline}\newline","parse_tcp_opt set all tcp default values\newline within optsp and parse all tcp related options\newline ac is the number of arguments from MODE and av is\newline the correspond pointer into the array vector. We parse all tcp\newline related options first and within the switch/case statement we handle\newline transmit | receive specific options.\newline \newline","6007439","objrtmch.c","static void QueueObjectMatchAction(\newline  void *theEnv,\newline  int type,\newline  INSTANCE_TYPE *ins,\newline  int slotNameID)\newline  {\newline   OBJECT_MATCH_ACTION *prv,*cur,*newMatch;\newline\newline   prv = NULL;\newline   cur = ObjectReteData(theEnv)-&gtObjectMatchActionQueue;\newline   while (cur != NULL)\newline     {\newline      /* ===========================================================\newline         Here are the possibilities for the first Rete event already\newline         on the queue as compared with the new event for an object:\newline\newline         Assert/Retract  --&gt  Delete assert event\newline                              Ignore retract event\newline         Assert/Modify   --&gt  Ignore modify event\newline         Modify/Modify   --&gt  Merge new modify event\newline         Modify/Retract  --&gt  Delete modify event\newline                              Queue the retract event\newline         =========================================================== */\newline      if (cur-&gtins == ins)\newline        {\newline         /* ===================================================\newline            An action for initially asserting the newly created\newline            object to all applicable patterns\newline            =================================================== */\newline         if (cur-&gttype == OBJECT_ASSERT)\newline           {\newline            if (type == OBJECT_RETRACT)\newline              {\newline               /* ===================================================\newline                  If we are retracting the entire object, then we can\newline                  remove the assert action (and all modifies as well)\newline                  and ignore the retract action\newline                  (basically the object came and went before the Rete\newline                  network had a chance to see it)\newline                  =================================================== */\newline               if (prv == NULL)\newline                 ObjectReteData(theEnv)-&gtObjectMatchActionQueue = cur-&gtnxt;\newline               else\newline                 prv-&gtnxt = cur-&gtnxt;\newline               cur-&gtins-&gtbusy--;\newline               ReturnObjectMatchAction(theEnv,cur);\newline              }\newline\newline            /* =================================================\newline               If this is a modify action, then we can ignore it\newline               since the assert action will encompass it\newline               ================================================= */\newline           }\newline\newline         /* ===================================================\newline            If the object is being deleted after a slot modify,\newline            drop the modify event and replace with the retract\newline            =================================================== */\newline         else if (type == OBJECT_RETRACT)\newline           {\newline            cur-&gttype = OBJECT_RETRACT;\newline            if (cur-&gtslotNameIDs != NULL)\newline              {\newline               rm(theEnv,(void *) cur-&gtslotNameIDs,SlotBitMapSize(cur-&gtslotNameIDs));\newline               cur-&gtslotNameIDs = NULL;\newline              }\newline           }\newline\newline         /* ====================================================\newline            If a modify event for this slot is already on the\newline            queue, ignore this one. Otherwise, merge the slot id\newline            ==================================================== */\newline         else\newline            cur-&gtslotNameIDs = QueueModifySlotMap(theEnv,cur-&gtslotNameIDs,slotNameID);\newline\newline         return;\newline        }\newline      prv = cur;\newline      cur = cur-&gtnxt;\newline     }\newline\newline   /* ================================================\newline      If there are no actions for the instance already\newline      on the queue, the new action is simply appended.\newline      ================================================ */\newline   newMatch = get_struct(theEnv,objectMatchAction);\newline   newMatch-&gttype = type;\newline   newMatch-&gtnxt = cur;\newline   newMatch-&gtslotNameIDs = (type != OBJECT_MODIFY) ? NULL :\newline                       QueueModifySlotMap(theEnv,NULL,slotNameID);\newline   newMatch-&gtins = ins;\newline   newMatch-&gtins-&gtbusy++;\newline   if (prv == NULL)\newline     ObjectReteData(theEnv)-&gtObjectMatchActionQueue = newMatch;\newline   else\newline     prv-&gtnxt = newMatch;\newline  }\newline","\newlineNAME : QueueObjectMatchAction\newlineDESCRIPTION : Posts a Rete network match event\newlinefor later processing\newlineINPUTS : 1) The match action type\newlineOBJECT_ASSERT (1)\newlineOBJECT_RETRACT (2)\newlineOBJECT_MODIFY (3)\newline2) The instance to be matched\newline3) The name id of the slot being\newlineupdated (can be -1)\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Queue updated\newlineNOTES : None\newline \newline","1886672","libtcc.c","static void tcc_cleanup(void)\newline{\newline    int i, n;\newline    if (NULL == tcc_state)\newline        return;\newline    tcc_state = NULL;\newline\newline    /* free -D defines */\newline    free_defines(NULL);\newline\newline    /* free tokens */\newline    n = tok_ident - TOK_IDENT;\newline    for(i = 0; i &lt n; i++)\newline        free(table_ident[i]);\newline    free(table_ident);\newline\newline    /* free sym_pools */\newline    dynarray_reset(&ampsym_pools, &ampnb_sym_pools);\newline    /* string buffer */\newline    cstr_free(&amptokcstr);\newline    /* reset symbol stack */\newline    sym_free_first = NULL;\newline    /* cleanup from error/setjmp */\newline    macro_ptr = NULL;\newline}\newline","cleanup all static data used during compilation \newline","on","on","","","","","on","","on","","","","","","on","on","on","","","","","","","","","","","","","","","","","","","","","","","","","","{}","{}","Deallocate everything properly","Compute the system key from various system information,","Call with syscallrecord lock held.","todo: merge","{}","Update deploy list. Unit is either removed or added to","{}","error - issue error msg according to fmt, bump error count","switch/case statement we handletransmit | receive specific options.","Move up by COUNT lines","Posts a Rete network match eventfor later processing","cleanup all static data used during compilation","{}","{}","{}","Add context to a specific channel","loading data chat type is known ('Type') so this method check","extract check result","connected range fetch, send another request to the remote"
"33Q5P9PUSPMOL35S48W3RZW80KRZC2","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3CTOC39K37QUWR2LL7Q7C2CTWZJJ78","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:54:06 PDT 2019","Wed Apr 17 13:00:09 PDT 2019","Fri Apr 19 13:00:09 PDT 2019","2019-04-19 20:00:21 UTC","","","363","100% (27/27)","100% (27/27)","100% (27/27)","1328629","ms_task.c","static void ms_single_getset_task_sch(ms_conn_t *c)\newline{\newline  ms_task_t *task;\newline  ms_task_item_t *item;\newline\newline  /* the last time don&#039t run a task */\newline  if (c-&gtremain_exec_num-- &gt 0)\newline  {\newline    task= ms_get_task(c, false);\newline    item= task-&gtitem;\newline    if (task-&gtcmd == CMD_SET)\newline    {\newline      ms_mcd_set(c, item);\newline    }\newline    else if (task-&gtcmd == CMD_GET)\newline    {\newline      assert(task-&gtcmd == CMD_GET);\newline      ms_mcd_get(c, item);\newline    }\newline  }\newline} /* ms_single_getset_task_sch */\newline","\newline dispatch single get and set task\newline \newline @param c, pointer of the concurrency\newline \newline","263800","disasmview.c","static gboolean move_up_lines(TilemDisasmView *dv, int count)\newline{\newline	TilemCalc *calc;\newline	dword pos;\newline	int linenum;\newline\newline	if (!get_cursor_line(dv, NULL, &amplinenum))\newline		linenum = 0;\newline\newline	if (linenum &gt= count)\newline		return FALSE;\newline\newline	tilem_calc_emulator_lock(dv-&gtdbg-&gtemu);\newline	calc = dv-&gtdbg-&gtemu-&gtcalc;\newline\newline	pos = dv-&gtstartpos;\newline	count -= linenum;\newline	while (count &gt 0) {\newline		pos = get_prev_pos(dv, calc, pos);\newline		count--;\newline	}\newline\newline	tilem_calc_emulator_unlock(dv-&gtdbg-&gtemu);\newline\newline	refresh_disassembly(dv, pos, dv-&gtnlines, pos);\newline\newline	return TRUE;\newline}\newline","Move up by COUNT lines \newline","2129121","stream.c","void test_filter_stream__smallfile(void)\newline{\newline	test_stream(5);\newline}\newline","write a 50KB file through the &quotcompression&quot stream \newline","4539621","srp_sync.c","struct target_details *pop_from_retry_list(struct sync_resources *res)\newline{\newline	struct target_details *ret = res-&gtretry_tasks_head;\newline\newline	if (ret)\newline		res-&gtretry_tasks_head = ret-&gtnext;\newline	else\newline		res-&gtretry_tasks_tail = NULL;\newline\newline	return ret;\newline}\newline","assumes that res-&gtretry_mutex is locked !!! \newline","6448631","qwt_plot_axis.cpp","void QwtPlot::setAxisTitle( QwtAxisId axisId, const QString &amptitle )\newline{\newline    if ( isAxisValid( axisId ) )\newline        axisWidget( axisId )-&gtsetTitle( title );\newline}\newline","!\newline\\brief Change the title of a specified axis\newline\\param axisPos Axis position\newline\\param title axis title\newline \newline","287086","ust-app.c","int ust_app_add_ctx_channel_glb(struct ltt_ust_session *usess,\newline		struct ltt_ust_channel *uchan, struct ltt_ust_context *uctx)\newline{\newline	int ret = 0;\newline	struct lttng_ht_node_str *ua_chan_node;\newline	struct lttng_ht_iter iter, uiter;\newline	struct ust_app_channel *ua_chan = NULL;\newline	struct ust_app_session *ua_sess;\newline	struct ust_app *app;\newline\newline	rcu_read_lock();\newline\newline	cds_lfht_for_each_entry(ust_app_ht-&gtht, &ampiter.iter, app, pid_n.node) {\newline		if (!app-&gtcompatible) {\newline			/*\newline			 * TODO: In time, we should notice the caller of this error by\newline			 * telling him that this is a version error.\newline			 */\newline			continue;\newline		}\newline		ua_sess = lookup_session_by_app(usess, app);\newline		if (ua_sess == NULL) {\newline			continue;\newline		}\newline\newline		pthread_mutex_lock(&ampua_sess-&gtlock);\newline\newline		if (ua_sess-&gtdeleted) {\newline			pthread_mutex_unlock(&ampua_sess-&gtlock);\newline			continue;\newline		}\newline\newline		/* Lookup channel in the ust app session */\newline		lttng_ht_lookup(ua_sess-&gtchannels, (void *)uchan-&gtname, &ampuiter);\newline		ua_chan_node = lttng_ht_iter_get_node_str(&ampuiter);\newline		if (ua_chan_node == NULL) {\newline			goto next_app;\newline		}\newline		ua_chan = caa_container_of(ua_chan_node, struct ust_app_channel,\newline				node);\newline		ret = create_ust_app_channel_context(ua_sess, ua_chan, &ampuctx-&gtctx, app);\newline		if (ret &lt 0) {\newline			goto next_app;\newline		}\newline	next_app:\newline		pthread_mutex_unlock(&ampua_sess-&gtlock);\newline	}\newline\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Add context to a specific channel for global UST domain.\newline \newline","636433","chat-shared.cpp","void ChatShared::load()\newline{\newline	if (!isValidStorage())\newline		return;\newline\newline	Shared::load();\newline\newline	ConfigurationApi *configurationStorage = storage()-&gtstorage();\newline	QDomElement parent = storage()-&gtpoint();\newline\newline	Groups.clear();\newline\newline	QDomElement groupsNode = configurationStorage-&gtgetNode(parent, &quotChatGroups&quot, ConfigurationApi::ModeFind);\newline	if (!groupsNode.isNull())\newline	{\newline		QDomNodeList groupsList = groupsNode.elementsByTagName(&quotGroup&quot);\newline\newline		int count = groupsList.count();\newline		for (int i = 0; i &lt count; i++)\newline		{\newline			QDomElement groupElement = groupsList.at(i).toElement();\newline			if (groupElement.isNull())\newline				continue;\newline			doAddToGroup(m_groupManager-&gtbyUuid(groupElement.text()));\newline		}\newline	}\newline\newline	*ChatAccount = m_accountManager-&gtbyUuid(QUuid(loadValue&ltQString&gt(&quotAccount&quot)));\newline	Display = loadValue&ltQString&gt(&quotDisplay&quot);\newline	auto type = loadValue&ltQString&gt(&quotType&quot);\newline\newline	// import from alias to new name of chat type\newline	ChatType *chatType = m_chatTypeManager-&gtchatType(type);\newline	if (chatType)\newline		type = chatType-&gtname();\newline\newline	// we should not have display names for Contact chats\newline	if (type == &quotContact&quot)\newline		Display.clear();\newline\newline	setType(type);\newline}\newline","\newline @author Rafal &#039Vogel&#039 Malinowski\newline @short Loads chat data from storage.\newline \newline This method is called when object is used at first time. It loads data from object&#039s\newline storage point. After loading data chat type is known (&#039Type&#039) so this method check\newline if the type is any of known chat types. If so, details class is created, assigned and\newline loaded - chat has full data available. If no, loading details class is deffered to\newline moment after good chat type is loaded. This mechanism is provided by\newline @link ChatTypeAvareObject @endlink class.\newline \newline","311642","checks.c","static void extract_check_result(FILE *fp, dbuf *checkresult_dbuf) {\newline	char output_buffer[MAX_INPUT_BUFFER] = &quot&quot;\newline	char *temp_buffer;\newline\newline	/* initialize buffer */\newline	strcpy(output_buffer, &quot&quot);\newline\newline	/* get all lines of plugin output - escape newlines */\newline	while (fgets(output_buffer, sizeof(output_buffer) - 1, fp)) {\newline		temp_buffer = escape_newlines(output_buffer);\newline		dbuf_strcat(checkresult_dbuf, temp_buffer);\newline		my_free(temp_buffer);\newline	}\newline}\newline","extract check result \newline","5899901","http.c","static void range_fetch_getmore(struct range_fetch *rf) {\newline    char request[2048];\newline    int l;\newline    int max_range_per_request = 20;\newline\newline    /* Only if there&#039s stuff queued to get */\newline    if (rf-&gtrangessent == rf-&gtnranges)\newline        return;\newline\newline    /* Build the base request, everything up to the Range: bytes= */\newline    snprintf(request, sizeof(request),\newline             &quotGET %s HTTP/1.1\\r\\n&quot\newline             &quotUser-Agent: zsync/&quot VERSION &quot\\r\\n&quot\newline             &quotHost: %s&quot\newline             &quot%s%s\\r\\n&quot\newline             &quot%s&quot\newline             &quotRange: bytes=&quot,\newline             rf-&gturl, rf-&gthosth,\newline             referer ? &quot\\r\\nReferer: &quot : &quot&quot, referer ? referer : &quot&quot,\newline             rf-&gtauthh ? rf-&gtauthh : &quot&quot);\newline\newline    /* The for loop here is just a sanity check, lastrange is the real loop control */\newline    for (; rf-&gtrangessent &lt rf-&gtnranges;) {\newline        int i = rf-&gtrangessent;\newline        int lastrange = 0;\newline\newline        /* Add at least one byterange to the request; but is this the last one? \newline         * That&#039s decided based on whether there are any more to add, whether\newline         * we&#039ve reached our self-imposed limit per request, and whether\newline         * there&#039s buffer space to add more.\newline         */\newline        l = strlen(request);\newline        if (l &gt 1200 || !(--max_range_per_request) || i == rf-&gtnranges - 1)\newline            lastrange = 1;\newline\newline        /* Append to the request */\newline        snprintf(request + l, sizeof(request) - l, OFF_T_PF &quot-&quot OFF_T_PF &quot%s&quot,\newline                 rf-&gtranges_todo[2 * i], rf-&gtranges_todo[2 * i + 1],\newline                 lastrange ? &quot&quot : &quot,&quot);\newline\newline        /* And record that we have sent this one */\newline        rf-&gtrangessent++;\newline\newline        /* Exit loop if that is the last to add */\newline        if (lastrange)\newline            break;\newline    }\newline    l = strlen(request);\newline\newline    /* Possibly close the connection (and record the fact, so we definitely\newline     * don&#039t send more stuff) if this is the last */\newline    snprintf(request + l, sizeof(request) - l, &quot\\r\\n%s\\r\\n&quot,\newline             rf-&gtrangessent == rf-&gtnranges ? (rf-&gtserver_close =\newline                                              1, &quotConnection: close\\r\\n&quot) : &quot&quot);\newline\newline    {   /* Send the request */\newline        size_t len = strlen(request);\newline        char *p = request;\newline        int r = 0;\newline\newline        while (len &gt 0\newline               &amp&amp ((r = send(rf-&gtsd, p, len, 0)) != -1 || errno == EINTR)) {\newline            if (r &gt= 0) {\newline                p += r;\newline                len -= r;\newline            }\newline        }\newline        if (r == -1) {\newline            perror(&quotsend&quot);\newline        }\newline    }\newline}\newline","range_fetch_getmore\newline On a connected range fetch, send another request to the remote \newline","2332588","qemuarch.c","const char *qemu_arch_qemumachine(const char *arch) {\newline	if (!strcmp(arch, &quotarm&quot) || !strcmp(arch, &quotarmel&quot)) {\newline		return &quotversatilepb&quot;\newline	} else if (!strcmp(arch, &quotarmhf&quot) || !strcmp(arch, &quotarm64&quot)) {\newline		return &quotvirt&quot;\newline	} else if (!strcmp(arch, &quoti386&quot) || !strcmp(arch, &quothurd-i386&quot) ||\newline			   !strcmp(arch, &quotamd64&quot) || !strcmp(arch, &quotx32&quot)) {\newline		return &quotpc&quot;\newline	} else if (!strcmp(arch, &quotmips&quot) || !strcmp(arch, &quotmipsel&quot)) {\newline		return &quotmalta&quot;\newline	} else if (!strcmp(arch, &quotpowerpc&quot)) {\newline		return &quotprep&quot;\newline	} else if (!strcmp(arch, &quotsparc&quot)) {\newline		return &quotSS-5&quot;\newline	}\newline	return NULL;\newline}\newline","\newline arch-specific routine; the machine spec for this arch\newline \newline","6629324","ibv.c","int finalizeIB(ArgStruct *p)\newline{\newline  int ret;\newline\newline  LOGPRINTF((&quotFinalizing IB stuff&quot));\newline    /* NOTE: This implementation only has created one of each type of queue.\newline     * In other implementations it may be necessary to create arrays of \newline     * these queues.  If this is the case, you need to loop and get them all */\newline  if(qp_hndl) {	    \newline    LOGPRINTF((&quotDestroying QP&quot));\newline    ret = ibv_destroy_qp(qp_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying Queue Pair\\n&quot);\newline    }\newline  }\newline\newline  if(r_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Recv CQ&quot));\newline    ret = ibv_destroy_cq(r_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying recv CQ\\n&quot);\newline    }\newline  }\newline\newline  if(s_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Send CQ&quot));\newline    ret = ibv_destroy_cq(s_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying send CQ\\n&quot);\newline    }\newline  }\newline\newline  /* Check memory registrations just in case user bailed out */\newline  if(s_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering send buffer&quot));\newline    ret = ibv_dereg_mr(s_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering send mr\\n&quot);\newline    }\newline  }\newline\newline  if(r_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering recv buffer&quot));\newline    ret = ibv_dereg_mr(r_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering recv mr\\n&quot);\newline    }\newline  }\newline\newline  if(pd_hndl) {\newline    LOGPRINTF((&quotDeallocating PD&quot));\newline    ret = ibv_dealloc_pd(pd_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deallocating PD\\n&quot);\newline    }\newline  }\newline\newline  /* Application code should not close HCA, just release handle */\newline\newline  if(ctx) {\newline    LOGPRINTF((&quotReleasing HCA&quot));\newline    ret = ibv_close_device(ctx);\newline    if(ret) {\newline      fprintf(stderr, &quotError releasing HCA\\n&quot);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","Deallocate everything properly \newline","3008347","drms.c","static int GetSystemKey( uint32_t *p_sys_key, uint32_t b_ipod )\newline{\newline    static char const p_secret1[ 8 ] = &quotYuaFlafu&quot;\newline    static char const p_secret2[ 8 ] = &quotzPif98ga&quot;\newline    struct md5_s md5;\newline    int64_t i_ipod_id;\newline    uint32_t p_system_hash[ 4 ];\newline\newline    /* Compute the MD5 hash of our system info */\newline    if( ( !b_ipod &amp&amp HashSystemInfo( p_system_hash ) ) ||\newline        (  b_ipod &amp&amp GetiPodID( &ampi_ipod_id ) ) )\newline    {\newline        return -1;\newline    }\newline\newline    /* Combine our system info hash with additional secret data. The resulting\newline     * MD5 hash will be our system key. */\newline    InitMD5( &ampmd5 );\newline    AddMD5( &ampmd5, (uint8_t *)p_secret1, 8 );\newline\newline    if( !b_ipod )\newline    {\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_secret2, 8 );\newline    }\newline    else\newline    {\newline        i_ipod_id = U64_AT(&ampi_ipod_id);\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline    }\newline\newline    EndMD5( &ampmd5 );\newline\newline    memcpy( p_sys_key, md5.p_digest, 16 );\newline\newline    return 0;\newline}\newline","\newline GetSystemKey: get the system key\newline \newline Compute the system key from various system information, see HashSystemInfo.\newline \newline","5861021","main.c","unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)\newline{\newline	struct syscallentry *entry;\newline	unsigned int fd;\newline\newline	entry = get_syscall_entry(rec-&gtnr, rec-&gtdo32bit);\newline\newline	if ((entry-&gtarg1type != ARG_FD) &amp&amp\newline	    (entry-&gtarg1type != ARG_SOCKETINFO))\newline	    return FALSE;\newline\newline	/* in the SOCKETINFO case, post syscall, a1 is actually the fd,\newline	 * not the socketinfo.  In ARG_FD a1=fd.\newline	 */\newline	fd = rec-&gta1;\newline\newline	/* if it&#039s out of range, it&#039s not going to be valid. */\newline	if (fd &gt 1024)\newline		return FALSE;\newline\newline	if (logging == LOGGING_FILES) {\newline		if (child-&gtlogfile == NULL)\newline			return FALSE;\newline\newline		if (fd &lt= (unsigned int) fileno(child-&gtlogfile))\newline			return FALSE;\newline	}\newline	return TRUE;\newline}\newline","if the first arg was an fd, find out which one it was.\newline Call with syscallrecord lock held. \newline","1392224","swfshape.c","static SHAPELINE* swf_ParseShapeData(U8*data, int bits, int fillbits, int linebits, int version, SHAPE2*shape2)\newline{\newline    SHAPELINE _lines;\newline    SHAPELINE*lines = &amp_lines;\newline\newline    TAG _tag;\newline    TAG* tag = &amp_tag;\newline    int fill0 = 0;\newline    int fill1 = 0;\newline    int line = 0;\newline    int x=0,y=0;\newline    int linestyleadd=0;\newline    int fillstyleadd=0;\newline    \newline    memset(tag, 0, sizeof(TAG));\newline    tag-&gtdata = data;\newline    tag-&gtlen = tag-&gtmemsize = (bits+7)/8;\newline    tag-&gtpos = 0;\newline    tag-&gtid = version==1?ST_DEFINESHAPE:(version==2?ST_DEFINESHAPE2:(version==3?ST_DEFINESHAPE3:ST_DEFINESHAPE4));\newline\newline    lines-&gtnext = 0;\newline    while(1) {\newline	int flags;\newline	flags = swf_GetBits(tag, 1);\newline	if(!flags) { //style change\newline	    flags = swf_GetBits(tag, 5);\newline	    if(!flags)\newline		break;\newline	    if(flags&amp1) { //move\newline		int n = swf_GetBits(tag, 5); \newline		x = swf_GetSBits(tag, n); //x\newline		y = swf_GetSBits(tag, n); //y\newline	    }\newline	    if(flags&amp2)\newline		fill0 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp4)\newline		fill1 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp8)\newline		line = swf_GetBits(tag, linebits) + linestyleadd; \newline	    if(flags&amp16) {\newline		if(!shape2) {\newline		    fprintf(stderr, &quotrfxswf: Error: Additional fillstyles not supported\\n&quot);fflush(stderr);\newline		    enumerateUsedIDs_styles(tag, dummycallback1, 0, version, 0);\newline		} else {\newline		    linestyleadd = shape2-&gtnumlinestyles;\newline		    fillstyleadd = shape2-&gtnumfillstyles;\newline		    if(!parseFillStyleArray(tag, shape2))\newline			return 0;\newline		}\newline		fillbits = swf_GetBits(tag, 4);\newline		linebits = swf_GetBits(tag, 4);\newline	    }\newline	    if(flags&amp1) { //move\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = moveTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	} else {\newline	    flags = swf_GetBits(tag, 1);\newline	    if(flags) { //straight edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		if(swf_GetBits(tag, 1)) { //line flag\newline		    x += swf_GetSBits(tag, n); //delta x\newline		    y += swf_GetSBits(tag, n); //delta y\newline		} else {\newline		    int v=swf_GetBits(tag, 1);\newline		    int d;\newline		    d = swf_GetSBits(tag, n); //vert/horz\newline		    if(v) y += d;\newline		    else  x += d;\newline		}\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = lineTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    } else { //curved edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		int x1,y1;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline		x1 = x;\newline		y1 = y;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = splineTo;\newline		lines-&gtsx = x1; \newline		lines-&gtsy = y1; \newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	}\newline    }\newline    return _lines.next;\newline}\newline","todo: merge this with swf_GetSimpleShape \newline","1003861","lp_report.c","MYBOOL REPORT_tableau(lprec *lp)\newline{\newline  int  j, row_nr, *coltarget;\newline  REAL *prow = NULL;\newline  FILE *stream = lp-&gtoutstream;\newline\newline  if(lp-&gtoutstream == NULL)\newline    return(FALSE);\newline\newline  if(!lp-&gtmodel_is_valid || !has_BFP(lp) ||\newline     (get_total_iter(lp) == 0) || (lp-&gtspx_status == NOTRUN)) {\newline    lp-&gtspx_status = NOTRUN;\newline    return(FALSE);\newline  }\newline  if(!allocREAL(lp, &ampprow,lp-&gtsum + 1, TRUE)) {\newline    lp-&gtspx_status = NOMEMORY;\newline    return(FALSE);\newline  }\newline\newline  fprintf(stream, &quot\\n&quot);\newline  fprintf(stream, &quotTableau at iter %.0f:\\n&quot, (double) get_total_iter(lp));\newline\newline  for(j = 1; j &lt= lp-&gtsum; j++)\newline    if (!lp-&gtis_basic[j])\newline      fprintf(stream, &quot%15d&quot, (j &lt= lp-&gtrows ?\newline                               (j + lp-&gtcolumns) * ((lp-&gtorig_upbo[j] == 0) ||\newline                                                    (is_chsign(lp, j)) ? 1 : -1) : j - lp-&gtrows) *\newline                              (lp-&gtis_lower[j] ? 1 : -1));\newline  fprintf(stream, &quot\\n&quot);\newline\newline  coltarget = (int *) mempool_obtainVector(lp-&gtworkarrays, lp-&gtcolumns+1, sizeof(*coltarget));\newline  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\newline    mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline    return(FALSE);\newline  }\newline  for(row_nr = 1; (row_nr &lt= lp-&gtrows + 1); row_nr++) {\newline    if (row_nr &lt= lp-&gtrows)\newline      fprintf(stream, &quot%3d&quot, (lp-&gtvar_basic[row_nr] &lt= lp-&gtrows ?\newline                              (lp-&gtvar_basic[row_nr] + lp-&gtcolumns) * ((lp-&gtorig_upbo[lp-&gtvar_basic [row_nr]] == 0) ||\newline                                                                       (is_chsign(lp, lp-&gtvar_basic[row_nr])) ? 1 : -1) : lp-&gtvar_basic[row_nr] - lp-&gtrows) *\newline                             (lp-&gtis_lower[lp-&gtvar_basic [row_nr]] ? 1 : -1));\newline    else\newline      fprintf(stream, &quot   &quot);\newline    bsolve(lp, row_nr &lt= lp-&gtrows ? row_nr : 0, prow, NULL, lp-&gtepsmachine*DOUBLEROUND, 1.0);\newline    prod_xA(lp, coltarget, prow, NULL, lp-&gtepsmachine, 1.0,\newline                                       prow, NULL, MAT_ROUNDDEFAULT);\newline\newline    for(j = 1; j &lt= lp-&gtrows + lp-&gtcolumns; j++)\newline      if (!lp-&gtis_basic[j])\newline        fprintf(stream, &quot%15.7f&quot, prow[j] * (lp-&gtis_lower[j] ? 1 : -1) *\newline                                            (row_nr &lt= lp-&gtrows ? 1 : -1));\newline    fprintf(stream, &quot%15.7f&quot, lp-&gtrhs[row_nr &lt= lp-&gtrows ? row_nr : 0] *\newline                              (double) ((row_nr &lt= lp-&gtrows) || (is_maxim(lp)) ? 1 : -1));\newline    fprintf(stream, &quot\\n&quot);\newline  }\newline  fflush(stream);\newline\newline  mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline  FREE(prow);\newline  return(TRUE);\newline}\newline","Report the traditional tableau corresponding to the current basis \newline","2806773","gui.c","void gui_remove_deploy_unit( Unit *unit )\newline{\newline    List_Entry *entry;\newline    Unit *next_unit;\newline    entry = list_entry( left_deploy_units, unit );\newline    if ( entry-&gtnext-&gtitem )\newline        next_unit = entry-&gtnext-&gtitem;\newline    else\newline        if ( entry-&gtprev-&gtitem )\newline            next_unit = entry-&gtprev-&gtitem;\newline        else\newline            next_unit = 0;\newline    list_delete_item( left_deploy_units, unit );\newline    deploy_unit = next_unit;\newline    gui_add_deploy_units( gui-&gtdeploy_window-&gtframe-&gtcontents );\newline    frame_apply( gui-&gtdeploy_window-&gtframe );\newline}\newline","\newline====================================================================\newlineUpdate deploy list. Unit is either removed or added to \newlineleft_deploy_units and the deploy window is updated.\newline====================================================================\newline \newline","2150485","citadel_ipc.c","int CtdlIPCKnownRooms(CtdlIPC *ipc, enum RoomList which, int floor, struct march **listing, char *cret)\newline{\newline	register int ret;\newline	struct march *march = NULL;\newline	static char *proto[] =\newline		{&quotLKRA&quot, &quotLKRN&quot, &quotLKRO&quot, &quotLZRM&quot, &quotLRMS&quot, &quotLPRM&quot };\newline	char aaa[SIZ];\newline	char *bbb = NULL;\newline	size_t bbb_len;\newline\newline	if (!listing) return -2;\newline	if (*listing) return -2;	/* Free the listing first */\newline	if (!cret) return -2;\newline	/* if (which &lt 0 || which &gt 4) return -2; */\newline	if (floor &lt -1) return -2;	/* Can&#039t validate upper bound, sorry */\newline\newline	sprintf(aaa, &quot%s %d&quot, proto[which], floor);\newline	ret = CtdlIPCGenericCommand(ipc, aaa, NULL, 0, &ampbbb, &ampbbb_len, cret);\newline	if (ret / 100 == 1) {\newline		struct march *mptr;\newline\newline		while (bbb &amp&amp strlen(bbb)) {\newline			int a;\newline\newline			extract_token(aaa, bbb, 0, &#039\\n&#039, sizeof aaa);\newline			a = strlen(aaa);\newline			memmove(bbb, bbb + a + 1, strlen(bbb) - a);\newline			mptr = (struct march *) malloc(sizeof (struct march));\newline			if (mptr) {\newline				mptr-&gtnext = NULL;\newline				extract_token(mptr-&gtmarch_name, aaa, 0, &#039|&#039, sizeof mptr-&gtmarch_name);\newline				mptr-&gtmarch_flags = (unsigned int) extract_int(aaa, 1);\newline				mptr-&gtmarch_floor = (char) extract_int(aaa, 2);\newline				mptr-&gtmarch_order = (char) extract_int(aaa, 3);\newline				mptr-&gtmarch_flags2 = (unsigned int) extract_int(aaa, 4);\newline				mptr-&gtmarch_access = (char) extract_int(aaa, 5);\newline				if (march == NULL)\newline					march = mptr;\newline				else {\newline					struct march *mptr2;\newline\newline					mptr2 = march;\newline					while (mptr2-&gtnext != NULL)\newline						mptr2 = mptr2-&gtnext;\newline					mptr2-&gtnext = mptr;\newline				}\newline			}\newline		}\newline	}\newline	*listing = march;\newline	if (bbb) free(bbb);\newline	return ret;\newline}\newline","floor is -1 for all, or floornum \newline","4489701","lcc.c","static void error(char *fmt, char *msg) {\newline	fprintf(stderr, &quot%s: &quot, progname);\newline	fprintf(stderr, fmt, msg);\newline	fprintf(stderr, &quot\\n&quot);\newline	errcnt++;\newline}\newline","error - issue error msg according to fmt, bump error count \newline","4065816","getopt.c","static int parse_tcp_opt(int ac, char *av[], struct opts *optsp)\newline{\newline\newline	/* memorize protocol */\newline	optsp-&gtns_proto = NS_PROTO_TCP;\newline\newline	/* tcp has some default values too, set them here */\newline	optsp-&gtperform_rtt_probe = 1;\newline	optsp-&gtprotocol = IPPROTO_TCP;\newline	optsp-&gtsocktype = SOCK_STREAM;\newline\newline	while (av[0] &amp&amp av[0][0] == &#039-&#039) {\newline		if (av[0][1] == &#039C&#039)\newline			optsp-&gttcp_use_md5sig = true;\newline\newline		if (optsp-&gtworkmode == MODE_RECEIVE) {\newline			/* need peer ip address */\newline			if (!av[1] || av[1][0] == &#039-&#039)\newline				err_msg_die(EXIT_FAILOPT, &quotOption -C needs an argument (Peer IP Address)&quot);\newline			optsp-&gttcp_md5sig_peeraddr = av[1];\newline			ac--;\newline			av++;\newline		}\newline		ac--;\newline		av++;\newline	}\newline\newline	if (optsp-&gttcp_use_md5sig)\newline		msg(GENTLE, &quotEnabled TCP_MD5SIG option&quot);\newline	/* Now parse all transmit | receive specific code, plus the most\newline	 * important options: the file- and hostname\newline	 */\newline	switch (optsp-&gtworkmode) {\newline		case MODE_TRANSMIT:\newline			/* sanity check first */\newline			if (ac &lt= 1)\newline				print_usage(&quottcp transmit mode required file and destination address\\n&quot,\newline						HELP_STR_GLOBAL, 1);\newline\newline			optsp-&gtinfile = xstrdup(av[0]);\newline			optsp-&gthostname = xstrdup(av[1]);\newline\newline			break;\newline		case MODE_RECEIVE:\newline			switch (ac) {\newline				case 0: /* nothing to do */\newline					break;\newline\newline				case 2:\newline					opts.hostname = xstrdup(av[1]);\newline					/* fallthrough */\newline				case 1:\newline					opts.outfile = xstrdup(av[0]);\newline					break;\newline				default:\newline					err_msg(&quotYou specify to many arguments!&quot);\newline					print_usage(NULL, HELP_STR_GLOBAL, 1);\newline					break;\newline			};\newline\newline			break;\newline		default:\newline			err_msg_die(EXIT_FAILINT,\newline					&quotInternal, programmed error - unknown tranmit mode: %d\\n&quot,\newline					optsp-&gtworkmode);\newline	}\newline\newline	return SUCCESS;\newline}\newline","parse_tcp_opt set all tcp default values\newline within optsp and parse all tcp related options\newline ac is the number of arguments from MODE and av is\newline the correspond pointer into the array vector. We parse all tcp\newline related options first and within the switch/case statement we handle\newline transmit | receive specific options.\newline \newline","6007439","objrtmch.c","static void QueueObjectMatchAction(\newline  void *theEnv,\newline  int type,\newline  INSTANCE_TYPE *ins,\newline  int slotNameID)\newline  {\newline   OBJECT_MATCH_ACTION *prv,*cur,*newMatch;\newline\newline   prv = NULL;\newline   cur = ObjectReteData(theEnv)-&gtObjectMatchActionQueue;\newline   while (cur != NULL)\newline     {\newline      /* ===========================================================\newline         Here are the possibilities for the first Rete event already\newline         on the queue as compared with the new event for an object:\newline\newline         Assert/Retract  --&gt  Delete assert event\newline                              Ignore retract event\newline         Assert/Modify   --&gt  Ignore modify event\newline         Modify/Modify   --&gt  Merge new modify event\newline         Modify/Retract  --&gt  Delete modify event\newline                              Queue the retract event\newline         =========================================================== */\newline      if (cur-&gtins == ins)\newline        {\newline         /* ===================================================\newline            An action for initially asserting the newly created\newline            object to all applicable patterns\newline            =================================================== */\newline         if (cur-&gttype == OBJECT_ASSERT)\newline           {\newline            if (type == OBJECT_RETRACT)\newline              {\newline               /* ===================================================\newline                  If we are retracting the entire object, then we can\newline                  remove the assert action (and all modifies as well)\newline                  and ignore the retract action\newline                  (basically the object came and went before the Rete\newline                  network had a chance to see it)\newline                  =================================================== */\newline               if (prv == NULL)\newline                 ObjectReteData(theEnv)-&gtObjectMatchActionQueue = cur-&gtnxt;\newline               else\newline                 prv-&gtnxt = cur-&gtnxt;\newline               cur-&gtins-&gtbusy--;\newline               ReturnObjectMatchAction(theEnv,cur);\newline              }\newline\newline            /* =================================================\newline               If this is a modify action, then we can ignore it\newline               since the assert action will encompass it\newline               ================================================= */\newline           }\newline\newline         /* ===================================================\newline            If the object is being deleted after a slot modify,\newline            drop the modify event and replace with the retract\newline            =================================================== */\newline         else if (type == OBJECT_RETRACT)\newline           {\newline            cur-&gttype = OBJECT_RETRACT;\newline            if (cur-&gtslotNameIDs != NULL)\newline              {\newline               rm(theEnv,(void *) cur-&gtslotNameIDs,SlotBitMapSize(cur-&gtslotNameIDs));\newline               cur-&gtslotNameIDs = NULL;\newline              }\newline           }\newline\newline         /* ====================================================\newline            If a modify event for this slot is already on the\newline            queue, ignore this one. Otherwise, merge the slot id\newline            ==================================================== */\newline         else\newline            cur-&gtslotNameIDs = QueueModifySlotMap(theEnv,cur-&gtslotNameIDs,slotNameID);\newline\newline         return;\newline        }\newline      prv = cur;\newline      cur = cur-&gtnxt;\newline     }\newline\newline   /* ================================================\newline      If there are no actions for the instance already\newline      on the queue, the new action is simply appended.\newline      ================================================ */\newline   newMatch = get_struct(theEnv,objectMatchAction);\newline   newMatch-&gttype = type;\newline   newMatch-&gtnxt = cur;\newline   newMatch-&gtslotNameIDs = (type != OBJECT_MODIFY) ? NULL :\newline                       QueueModifySlotMap(theEnv,NULL,slotNameID);\newline   newMatch-&gtins = ins;\newline   newMatch-&gtins-&gtbusy++;\newline   if (prv == NULL)\newline     ObjectReteData(theEnv)-&gtObjectMatchActionQueue = newMatch;\newline   else\newline     prv-&gtnxt = newMatch;\newline  }\newline","\newlineNAME : QueueObjectMatchAction\newlineDESCRIPTION : Posts a Rete network match event\newlinefor later processing\newlineINPUTS : 1) The match action type\newlineOBJECT_ASSERT (1)\newlineOBJECT_RETRACT (2)\newlineOBJECT_MODIFY (3)\newline2) The instance to be matched\newline3) The name id of the slot being\newlineupdated (can be -1)\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Queue updated\newlineNOTES : None\newline \newline","1886672","libtcc.c","static void tcc_cleanup(void)\newline{\newline    int i, n;\newline    if (NULL == tcc_state)\newline        return;\newline    tcc_state = NULL;\newline\newline    /* free -D defines */\newline    free_defines(NULL);\newline\newline    /* free tokens */\newline    n = tok_ident - TOK_IDENT;\newline    for(i = 0; i &lt n; i++)\newline        free(table_ident[i]);\newline    free(table_ident);\newline\newline    /* free sym_pools */\newline    dynarray_reset(&ampsym_pools, &ampnb_sym_pools);\newline    /* string buffer */\newline    cstr_free(&amptokcstr);\newline    /* reset symbol stack */\newline    sym_free_first = NULL;\newline    /* cleanup from error/setjmp */\newline    macro_ptr = NULL;\newline}\newline","cleanup all static data used during compilation \newline","","on","","","","on","","","on","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","on","","","dispatch single get and set task","{}","Deallocate everything properly","Compute the system key from various system information,","if the first arg was an fd, find out which one","{}","Report the traditional tableau","Update deploy list.","{}","issue error msg","set all tcp default values","Move up by COUNT lines","Posts a Rete network match eventfor later processing","cleanup all static data used during compilation","write a 50KB file through the ""compression"" stream","{}","Change the title of a specified axis","Add context to a specific channel for global UST domain.","checkif the type is any of known chat types.","extract check result","On a connected range fetch, send another request to the remote"
"33Q5P9PUSPMOL35S48W3RZW80KRZC2","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3YHH42UU5BFM96Q13THBD2FYS920L9","A469WIPCE72UL","Approved","Wed Apr 17 11:44:35 PDT 2019","Wed Apr 17 11:51:34 PDT 2019","Fri Apr 19 11:51:34 PDT 2019","2019-04-19 18:52:21 UTC","","","419","100% (2/2)","100% (2/2)","100% (2/2)","1328629","ms_task.c","static void ms_single_getset_task_sch(ms_conn_t *c)\newline{\newline  ms_task_t *task;\newline  ms_task_item_t *item;\newline\newline  /* the last time don&#039t run a task */\newline  if (c-&gtremain_exec_num-- &gt 0)\newline  {\newline    task= ms_get_task(c, false);\newline    item= task-&gtitem;\newline    if (task-&gtcmd == CMD_SET)\newline    {\newline      ms_mcd_set(c, item);\newline    }\newline    else if (task-&gtcmd == CMD_GET)\newline    {\newline      assert(task-&gtcmd == CMD_GET);\newline      ms_mcd_get(c, item);\newline    }\newline  }\newline} /* ms_single_getset_task_sch */\newline","\newline dispatch single get and set task\newline \newline @param c, pointer of the concurrency\newline \newline","263800","disasmview.c","static gboolean move_up_lines(TilemDisasmView *dv, int count)\newline{\newline	TilemCalc *calc;\newline	dword pos;\newline	int linenum;\newline\newline	if (!get_cursor_line(dv, NULL, &amplinenum))\newline		linenum = 0;\newline\newline	if (linenum &gt= count)\newline		return FALSE;\newline\newline	tilem_calc_emulator_lock(dv-&gtdbg-&gtemu);\newline	calc = dv-&gtdbg-&gtemu-&gtcalc;\newline\newline	pos = dv-&gtstartpos;\newline	count -= linenum;\newline	while (count &gt 0) {\newline		pos = get_prev_pos(dv, calc, pos);\newline		count--;\newline	}\newline\newline	tilem_calc_emulator_unlock(dv-&gtdbg-&gtemu);\newline\newline	refresh_disassembly(dv, pos, dv-&gtnlines, pos);\newline\newline	return TRUE;\newline}\newline","Move up by COUNT lines \newline","2129121","stream.c","void test_filter_stream__smallfile(void)\newline{\newline	test_stream(5);\newline}\newline","write a 50KB file through the &quotcompression&quot stream \newline","4539621","srp_sync.c","struct target_details *pop_from_retry_list(struct sync_resources *res)\newline{\newline	struct target_details *ret = res-&gtretry_tasks_head;\newline\newline	if (ret)\newline		res-&gtretry_tasks_head = ret-&gtnext;\newline	else\newline		res-&gtretry_tasks_tail = NULL;\newline\newline	return ret;\newline}\newline","assumes that res-&gtretry_mutex is locked !!! \newline","6448631","qwt_plot_axis.cpp","void QwtPlot::setAxisTitle( QwtAxisId axisId, const QString &amptitle )\newline{\newline    if ( isAxisValid( axisId ) )\newline        axisWidget( axisId )-&gtsetTitle( title );\newline}\newline","!\newline\\brief Change the title of a specified axis\newline\\param axisPos Axis position\newline\\param title axis title\newline \newline","287086","ust-app.c","int ust_app_add_ctx_channel_glb(struct ltt_ust_session *usess,\newline		struct ltt_ust_channel *uchan, struct ltt_ust_context *uctx)\newline{\newline	int ret = 0;\newline	struct lttng_ht_node_str *ua_chan_node;\newline	struct lttng_ht_iter iter, uiter;\newline	struct ust_app_channel *ua_chan = NULL;\newline	struct ust_app_session *ua_sess;\newline	struct ust_app *app;\newline\newline	rcu_read_lock();\newline\newline	cds_lfht_for_each_entry(ust_app_ht-&gtht, &ampiter.iter, app, pid_n.node) {\newline		if (!app-&gtcompatible) {\newline			/*\newline			 * TODO: In time, we should notice the caller of this error by\newline			 * telling him that this is a version error.\newline			 */\newline			continue;\newline		}\newline		ua_sess = lookup_session_by_app(usess, app);\newline		if (ua_sess == NULL) {\newline			continue;\newline		}\newline\newline		pthread_mutex_lock(&ampua_sess-&gtlock);\newline\newline		if (ua_sess-&gtdeleted) {\newline			pthread_mutex_unlock(&ampua_sess-&gtlock);\newline			continue;\newline		}\newline\newline		/* Lookup channel in the ust app session */\newline		lttng_ht_lookup(ua_sess-&gtchannels, (void *)uchan-&gtname, &ampuiter);\newline		ua_chan_node = lttng_ht_iter_get_node_str(&ampuiter);\newline		if (ua_chan_node == NULL) {\newline			goto next_app;\newline		}\newline		ua_chan = caa_container_of(ua_chan_node, struct ust_app_channel,\newline				node);\newline		ret = create_ust_app_channel_context(ua_sess, ua_chan, &ampuctx-&gtctx, app);\newline		if (ret &lt 0) {\newline			goto next_app;\newline		}\newline	next_app:\newline		pthread_mutex_unlock(&ampua_sess-&gtlock);\newline	}\newline\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Add context to a specific channel for global UST domain.\newline \newline","636433","chat-shared.cpp","void ChatShared::load()\newline{\newline	if (!isValidStorage())\newline		return;\newline\newline	Shared::load();\newline\newline	ConfigurationApi *configurationStorage = storage()-&gtstorage();\newline	QDomElement parent = storage()-&gtpoint();\newline\newline	Groups.clear();\newline\newline	QDomElement groupsNode = configurationStorage-&gtgetNode(parent, &quotChatGroups&quot, ConfigurationApi::ModeFind);\newline	if (!groupsNode.isNull())\newline	{\newline		QDomNodeList groupsList = groupsNode.elementsByTagName(&quotGroup&quot);\newline\newline		int count = groupsList.count();\newline		for (int i = 0; i &lt count; i++)\newline		{\newline			QDomElement groupElement = groupsList.at(i).toElement();\newline			if (groupElement.isNull())\newline				continue;\newline			doAddToGroup(m_groupManager-&gtbyUuid(groupElement.text()));\newline		}\newline	}\newline\newline	*ChatAccount = m_accountManager-&gtbyUuid(QUuid(loadValue&ltQString&gt(&quotAccount&quot)));\newline	Display = loadValue&ltQString&gt(&quotDisplay&quot);\newline	auto type = loadValue&ltQString&gt(&quotType&quot);\newline\newline	// import from alias to new name of chat type\newline	ChatType *chatType = m_chatTypeManager-&gtchatType(type);\newline	if (chatType)\newline		type = chatType-&gtname();\newline\newline	// we should not have display names for Contact chats\newline	if (type == &quotContact&quot)\newline		Display.clear();\newline\newline	setType(type);\newline}\newline","\newline @author Rafal &#039Vogel&#039 Malinowski\newline @short Loads chat data from storage.\newline \newline This method is called when object is used at first time. It loads data from object&#039s\newline storage point. After loading data chat type is known (&#039Type&#039) so this method check\newline if the type is any of known chat types. If so, details class is created, assigned and\newline loaded - chat has full data available. If no, loading details class is deffered to\newline moment after good chat type is loaded. This mechanism is provided by\newline @link ChatTypeAvareObject @endlink class.\newline \newline","311642","checks.c","static void extract_check_result(FILE *fp, dbuf *checkresult_dbuf) {\newline	char output_buffer[MAX_INPUT_BUFFER] = &quot&quot;\newline	char *temp_buffer;\newline\newline	/* initialize buffer */\newline	strcpy(output_buffer, &quot&quot);\newline\newline	/* get all lines of plugin output - escape newlines */\newline	while (fgets(output_buffer, sizeof(output_buffer) - 1, fp)) {\newline		temp_buffer = escape_newlines(output_buffer);\newline		dbuf_strcat(checkresult_dbuf, temp_buffer);\newline		my_free(temp_buffer);\newline	}\newline}\newline","extract check result \newline","5899901","http.c","static void range_fetch_getmore(struct range_fetch *rf) {\newline    char request[2048];\newline    int l;\newline    int max_range_per_request = 20;\newline\newline    /* Only if there&#039s stuff queued to get */\newline    if (rf-&gtrangessent == rf-&gtnranges)\newline        return;\newline\newline    /* Build the base request, everything up to the Range: bytes= */\newline    snprintf(request, sizeof(request),\newline             &quotGET %s HTTP/1.1\\r\\n&quot\newline             &quotUser-Agent: zsync/&quot VERSION &quot\\r\\n&quot\newline             &quotHost: %s&quot\newline             &quot%s%s\\r\\n&quot\newline             &quot%s&quot\newline             &quotRange: bytes=&quot,\newline             rf-&gturl, rf-&gthosth,\newline             referer ? &quot\\r\\nReferer: &quot : &quot&quot, referer ? referer : &quot&quot,\newline             rf-&gtauthh ? rf-&gtauthh : &quot&quot);\newline\newline    /* The for loop here is just a sanity check, lastrange is the real loop control */\newline    for (; rf-&gtrangessent &lt rf-&gtnranges;) {\newline        int i = rf-&gtrangessent;\newline        int lastrange = 0;\newline\newline        /* Add at least one byterange to the request; but is this the last one? \newline         * That&#039s decided based on whether there are any more to add, whether\newline         * we&#039ve reached our self-imposed limit per request, and whether\newline         * there&#039s buffer space to add more.\newline         */\newline        l = strlen(request);\newline        if (l &gt 1200 || !(--max_range_per_request) || i == rf-&gtnranges - 1)\newline            lastrange = 1;\newline\newline        /* Append to the request */\newline        snprintf(request + l, sizeof(request) - l, OFF_T_PF &quot-&quot OFF_T_PF &quot%s&quot,\newline                 rf-&gtranges_todo[2 * i], rf-&gtranges_todo[2 * i + 1],\newline                 lastrange ? &quot&quot : &quot,&quot);\newline\newline        /* And record that we have sent this one */\newline        rf-&gtrangessent++;\newline\newline        /* Exit loop if that is the last to add */\newline        if (lastrange)\newline            break;\newline    }\newline    l = strlen(request);\newline\newline    /* Possibly close the connection (and record the fact, so we definitely\newline     * don&#039t send more stuff) if this is the last */\newline    snprintf(request + l, sizeof(request) - l, &quot\\r\\n%s\\r\\n&quot,\newline             rf-&gtrangessent == rf-&gtnranges ? (rf-&gtserver_close =\newline                                              1, &quotConnection: close\\r\\n&quot) : &quot&quot);\newline\newline    {   /* Send the request */\newline        size_t len = strlen(request);\newline        char *p = request;\newline        int r = 0;\newline\newline        while (len &gt 0\newline               &amp&amp ((r = send(rf-&gtsd, p, len, 0)) != -1 || errno == EINTR)) {\newline            if (r &gt= 0) {\newline                p += r;\newline                len -= r;\newline            }\newline        }\newline        if (r == -1) {\newline            perror(&quotsend&quot);\newline        }\newline    }\newline}\newline","range_fetch_getmore\newline On a connected range fetch, send another request to the remote \newline","2332588","qemuarch.c","const char *qemu_arch_qemumachine(const char *arch) {\newline	if (!strcmp(arch, &quotarm&quot) || !strcmp(arch, &quotarmel&quot)) {\newline		return &quotversatilepb&quot;\newline	} else if (!strcmp(arch, &quotarmhf&quot) || !strcmp(arch, &quotarm64&quot)) {\newline		return &quotvirt&quot;\newline	} else if (!strcmp(arch, &quoti386&quot) || !strcmp(arch, &quothurd-i386&quot) ||\newline			   !strcmp(arch, &quotamd64&quot) || !strcmp(arch, &quotx32&quot)) {\newline		return &quotpc&quot;\newline	} else if (!strcmp(arch, &quotmips&quot) || !strcmp(arch, &quotmipsel&quot)) {\newline		return &quotmalta&quot;\newline	} else if (!strcmp(arch, &quotpowerpc&quot)) {\newline		return &quotprep&quot;\newline	} else if (!strcmp(arch, &quotsparc&quot)) {\newline		return &quotSS-5&quot;\newline	}\newline	return NULL;\newline}\newline","\newline arch-specific routine; the machine spec for this arch\newline \newline","6629324","ibv.c","int finalizeIB(ArgStruct *p)\newline{\newline  int ret;\newline\newline  LOGPRINTF((&quotFinalizing IB stuff&quot));\newline    /* NOTE: This implementation only has created one of each type of queue.\newline     * In other implementations it may be necessary to create arrays of \newline     * these queues.  If this is the case, you need to loop and get them all */\newline  if(qp_hndl) {	    \newline    LOGPRINTF((&quotDestroying QP&quot));\newline    ret = ibv_destroy_qp(qp_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying Queue Pair\\n&quot);\newline    }\newline  }\newline\newline  if(r_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Recv CQ&quot));\newline    ret = ibv_destroy_cq(r_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying recv CQ\\n&quot);\newline    }\newline  }\newline\newline  if(s_cq_hndl) {\newline    LOGPRINTF((&quotDestroying Send CQ&quot));\newline    ret = ibv_destroy_cq(s_cq_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError destroying send CQ\\n&quot);\newline    }\newline  }\newline\newline  /* Check memory registrations just in case user bailed out */\newline  if(s_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering send buffer&quot));\newline    ret = ibv_dereg_mr(s_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering send mr\\n&quot);\newline    }\newline  }\newline\newline  if(r_mr_hndl) {\newline    LOGPRINTF((&quotDeregistering recv buffer&quot));\newline    ret = ibv_dereg_mr(r_mr_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deregistering recv mr\\n&quot);\newline    }\newline  }\newline\newline  if(pd_hndl) {\newline    LOGPRINTF((&quotDeallocating PD&quot));\newline    ret = ibv_dealloc_pd(pd_hndl);\newline    if(ret) {\newline      fprintf(stderr, &quotError deallocating PD\\n&quot);\newline    }\newline  }\newline\newline  /* Application code should not close HCA, just release handle */\newline\newline  if(ctx) {\newline    LOGPRINTF((&quotReleasing HCA&quot));\newline    ret = ibv_close_device(ctx);\newline    if(ret) {\newline      fprintf(stderr, &quotError releasing HCA\\n&quot);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","Deallocate everything properly \newline","3008347","drms.c","static int GetSystemKey( uint32_t *p_sys_key, uint32_t b_ipod )\newline{\newline    static char const p_secret1[ 8 ] = &quotYuaFlafu&quot;\newline    static char const p_secret2[ 8 ] = &quotzPif98ga&quot;\newline    struct md5_s md5;\newline    int64_t i_ipod_id;\newline    uint32_t p_system_hash[ 4 ];\newline\newline    /* Compute the MD5 hash of our system info */\newline    if( ( !b_ipod &amp&amp HashSystemInfo( p_system_hash ) ) ||\newline        (  b_ipod &amp&amp GetiPodID( &ampi_ipod_id ) ) )\newline    {\newline        return -1;\newline    }\newline\newline    /* Combine our system info hash with additional secret data. The resulting\newline     * MD5 hash will be our system key. */\newline    InitMD5( &ampmd5 );\newline    AddMD5( &ampmd5, (uint8_t *)p_secret1, 8 );\newline\newline    if( !b_ipod )\newline    {\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_system_hash, 6 );\newline        AddMD5( &ampmd5, (uint8_t *)p_secret2, 8 );\newline    }\newline    else\newline    {\newline        i_ipod_id = U64_AT(&ampi_ipod_id);\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline        AddMD5( &ampmd5, (uint8_t *)&ampi_ipod_id, sizeof(i_ipod_id) );\newline    }\newline\newline    EndMD5( &ampmd5 );\newline\newline    memcpy( p_sys_key, md5.p_digest, 16 );\newline\newline    return 0;\newline}\newline","\newline GetSystemKey: get the system key\newline \newline Compute the system key from various system information, see HashSystemInfo.\newline \newline","5861021","main.c","unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)\newline{\newline	struct syscallentry *entry;\newline	unsigned int fd;\newline\newline	entry = get_syscall_entry(rec-&gtnr, rec-&gtdo32bit);\newline\newline	if ((entry-&gtarg1type != ARG_FD) &amp&amp\newline	    (entry-&gtarg1type != ARG_SOCKETINFO))\newline	    return FALSE;\newline\newline	/* in the SOCKETINFO case, post syscall, a1 is actually the fd,\newline	 * not the socketinfo.  In ARG_FD a1=fd.\newline	 */\newline	fd = rec-&gta1;\newline\newline	/* if it&#039s out of range, it&#039s not going to be valid. */\newline	if (fd &gt 1024)\newline		return FALSE;\newline\newline	if (logging == LOGGING_FILES) {\newline		if (child-&gtlogfile == NULL)\newline			return FALSE;\newline\newline		if (fd &lt= (unsigned int) fileno(child-&gtlogfile))\newline			return FALSE;\newline	}\newline	return TRUE;\newline}\newline","if the first arg was an fd, find out which one it was.\newline Call with syscallrecord lock held. \newline","1392224","swfshape.c","static SHAPELINE* swf_ParseShapeData(U8*data, int bits, int fillbits, int linebits, int version, SHAPE2*shape2)\newline{\newline    SHAPELINE _lines;\newline    SHAPELINE*lines = &amp_lines;\newline\newline    TAG _tag;\newline    TAG* tag = &amp_tag;\newline    int fill0 = 0;\newline    int fill1 = 0;\newline    int line = 0;\newline    int x=0,y=0;\newline    int linestyleadd=0;\newline    int fillstyleadd=0;\newline    \newline    memset(tag, 0, sizeof(TAG));\newline    tag-&gtdata = data;\newline    tag-&gtlen = tag-&gtmemsize = (bits+7)/8;\newline    tag-&gtpos = 0;\newline    tag-&gtid = version==1?ST_DEFINESHAPE:(version==2?ST_DEFINESHAPE2:(version==3?ST_DEFINESHAPE3:ST_DEFINESHAPE4));\newline\newline    lines-&gtnext = 0;\newline    while(1) {\newline	int flags;\newline	flags = swf_GetBits(tag, 1);\newline	if(!flags) { //style change\newline	    flags = swf_GetBits(tag, 5);\newline	    if(!flags)\newline		break;\newline	    if(flags&amp1) { //move\newline		int n = swf_GetBits(tag, 5); \newline		x = swf_GetSBits(tag, n); //x\newline		y = swf_GetSBits(tag, n); //y\newline	    }\newline	    if(flags&amp2)\newline		fill0 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp4)\newline		fill1 = swf_GetBits(tag, fillbits) + fillstyleadd; \newline	    if(flags&amp8)\newline		line = swf_GetBits(tag, linebits) + linestyleadd; \newline	    if(flags&amp16) {\newline		if(!shape2) {\newline		    fprintf(stderr, &quotrfxswf: Error: Additional fillstyles not supported\\n&quot);fflush(stderr);\newline		    enumerateUsedIDs_styles(tag, dummycallback1, 0, version, 0);\newline		} else {\newline		    linestyleadd = shape2-&gtnumlinestyles;\newline		    fillstyleadd = shape2-&gtnumfillstyles;\newline		    if(!parseFillStyleArray(tag, shape2))\newline			return 0;\newline		}\newline		fillbits = swf_GetBits(tag, 4);\newline		linebits = swf_GetBits(tag, 4);\newline	    }\newline	    if(flags&amp1) { //move\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = moveTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	} else {\newline	    flags = swf_GetBits(tag, 1);\newline	    if(flags) { //straight edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		if(swf_GetBits(tag, 1)) { //line flag\newline		    x += swf_GetSBits(tag, n); //delta x\newline		    y += swf_GetSBits(tag, n); //delta y\newline		} else {\newline		    int v=swf_GetBits(tag, 1);\newline		    int d;\newline		    d = swf_GetSBits(tag, n); //vert/horz\newline		    if(v) y += d;\newline		    else  x += d;\newline		}\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = lineTo;\newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtsx = lines-&gtsy = 0;\newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    } else { //curved edge\newline		int n = swf_GetBits(tag, 4) + 2;\newline		int x1,y1;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline		x1 = x;\newline		y1 = y;\newline		x += swf_GetSBits(tag, n);\newline		y += swf_GetSBits(tag, n);\newline\newline		lines-&gtnext = (SHAPELINE*)rfx_alloc(sizeof(SHAPELINE));\newline		lines = lines-&gtnext;\newline		lines-&gttype = splineTo;\newline		lines-&gtsx = x1; \newline		lines-&gtsy = y1; \newline		lines-&gtx = x; \newline		lines-&gty = y; \newline		lines-&gtfillstyle0 = fill0;\newline		lines-&gtfillstyle1 = fill1;\newline		lines-&gtlinestyle = line;\newline		lines-&gtnext = 0;\newline	    }\newline	}\newline    }\newline    return _lines.next;\newline}\newline","todo: merge this with swf_GetSimpleShape \newline","1003861","lp_report.c","MYBOOL REPORT_tableau(lprec *lp)\newline{\newline  int  j, row_nr, *coltarget;\newline  REAL *prow = NULL;\newline  FILE *stream = lp-&gtoutstream;\newline\newline  if(lp-&gtoutstream == NULL)\newline    return(FALSE);\newline\newline  if(!lp-&gtmodel_is_valid || !has_BFP(lp) ||\newline     (get_total_iter(lp) == 0) || (lp-&gtspx_status == NOTRUN)) {\newline    lp-&gtspx_status = NOTRUN;\newline    return(FALSE);\newline  }\newline  if(!allocREAL(lp, &ampprow,lp-&gtsum + 1, TRUE)) {\newline    lp-&gtspx_status = NOMEMORY;\newline    return(FALSE);\newline  }\newline\newline  fprintf(stream, &quot\\n&quot);\newline  fprintf(stream, &quotTableau at iter %.0f:\\n&quot, (double) get_total_iter(lp));\newline\newline  for(j = 1; j &lt= lp-&gtsum; j++)\newline    if (!lp-&gtis_basic[j])\newline      fprintf(stream, &quot%15d&quot, (j &lt= lp-&gtrows ?\newline                               (j + lp-&gtcolumns) * ((lp-&gtorig_upbo[j] == 0) ||\newline                                                    (is_chsign(lp, j)) ? 1 : -1) : j - lp-&gtrows) *\newline                              (lp-&gtis_lower[j] ? 1 : -1));\newline  fprintf(stream, &quot\\n&quot);\newline\newline  coltarget = (int *) mempool_obtainVector(lp-&gtworkarrays, lp-&gtcolumns+1, sizeof(*coltarget));\newline  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\newline    mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline    return(FALSE);\newline  }\newline  for(row_nr = 1; (row_nr &lt= lp-&gtrows + 1); row_nr++) {\newline    if (row_nr &lt= lp-&gtrows)\newline      fprintf(stream, &quot%3d&quot, (lp-&gtvar_basic[row_nr] &lt= lp-&gtrows ?\newline                              (lp-&gtvar_basic[row_nr] + lp-&gtcolumns) * ((lp-&gtorig_upbo[lp-&gtvar_basic [row_nr]] == 0) ||\newline                                                                       (is_chsign(lp, lp-&gtvar_basic[row_nr])) ? 1 : -1) : lp-&gtvar_basic[row_nr] - lp-&gtrows) *\newline                             (lp-&gtis_lower[lp-&gtvar_basic [row_nr]] ? 1 : -1));\newline    else\newline      fprintf(stream, &quot   &quot);\newline    bsolve(lp, row_nr &lt= lp-&gtrows ? row_nr : 0, prow, NULL, lp-&gtepsmachine*DOUBLEROUND, 1.0);\newline    prod_xA(lp, coltarget, prow, NULL, lp-&gtepsmachine, 1.0,\newline                                       prow, NULL, MAT_ROUNDDEFAULT);\newline\newline    for(j = 1; j &lt= lp-&gtrows + lp-&gtcolumns; j++)\newline      if (!lp-&gtis_basic[j])\newline        fprintf(stream, &quot%15.7f&quot, prow[j] * (lp-&gtis_lower[j] ? 1 : -1) *\newline                                            (row_nr &lt= lp-&gtrows ? 1 : -1));\newline    fprintf(stream, &quot%15.7f&quot, lp-&gtrhs[row_nr &lt= lp-&gtrows ? row_nr : 0] *\newline                              (double) ((row_nr &lt= lp-&gtrows) || (is_maxim(lp)) ? 1 : -1));\newline    fprintf(stream, &quot\\n&quot);\newline  }\newline  fflush(stream);\newline\newline  mempool_releaseVector(lp-&gtworkarrays, (char *) coltarget, FALSE);\newline  FREE(prow);\newline  return(TRUE);\newline}\newline","Report the traditional tableau corresponding to the current basis \newline","2806773","gui.c","void gui_remove_deploy_unit( Unit *unit )\newline{\newline    List_Entry *entry;\newline    Unit *next_unit;\newline    entry = list_entry( left_deploy_units, unit );\newline    if ( entry-&gtnext-&gtitem )\newline        next_unit = entry-&gtnext-&gtitem;\newline    else\newline        if ( entry-&gtprev-&gtitem )\newline            next_unit = entry-&gtprev-&gtitem;\newline        else\newline            next_unit = 0;\newline    list_delete_item( left_deploy_units, unit );\newline    deploy_unit = next_unit;\newline    gui_add_deploy_units( gui-&gtdeploy_window-&gtframe-&gtcontents );\newline    frame_apply( gui-&gtdeploy_window-&gtframe );\newline}\newline","\newline====================================================================\newlineUpdate deploy list. Unit is either removed or added to \newlineleft_deploy_units and the deploy window is updated.\newline====================================================================\newline \newline","2150485","citadel_ipc.c","int CtdlIPCKnownRooms(CtdlIPC *ipc, enum RoomList which, int floor, struct march **listing, char *cret)\newline{\newline	register int ret;\newline	struct march *march = NULL;\newline	static char *proto[] =\newline		{&quotLKRA&quot, &quotLKRN&quot, &quotLKRO&quot, &quotLZRM&quot, &quotLRMS&quot, &quotLPRM&quot };\newline	char aaa[SIZ];\newline	char *bbb = NULL;\newline	size_t bbb_len;\newline\newline	if (!listing) return -2;\newline	if (*listing) return -2;	/* Free the listing first */\newline	if (!cret) return -2;\newline	/* if (which &lt 0 || which &gt 4) return -2; */\newline	if (floor &lt -1) return -2;	/* Can&#039t validate upper bound, sorry */\newline\newline	sprintf(aaa, &quot%s %d&quot, proto[which], floor);\newline	ret = CtdlIPCGenericCommand(ipc, aaa, NULL, 0, &ampbbb, &ampbbb_len, cret);\newline	if (ret / 100 == 1) {\newline		struct march *mptr;\newline\newline		while (bbb &amp&amp strlen(bbb)) {\newline			int a;\newline\newline			extract_token(aaa, bbb, 0, &#039\\n&#039, sizeof aaa);\newline			a = strlen(aaa);\newline			memmove(bbb, bbb + a + 1, strlen(bbb) - a);\newline			mptr = (struct march *) malloc(sizeof (struct march));\newline			if (mptr) {\newline				mptr-&gtnext = NULL;\newline				extract_token(mptr-&gtmarch_name, aaa, 0, &#039|&#039, sizeof mptr-&gtmarch_name);\newline				mptr-&gtmarch_flags = (unsigned int) extract_int(aaa, 1);\newline				mptr-&gtmarch_floor = (char) extract_int(aaa, 2);\newline				mptr-&gtmarch_order = (char) extract_int(aaa, 3);\newline				mptr-&gtmarch_flags2 = (unsigned int) extract_int(aaa, 4);\newline				mptr-&gtmarch_access = (char) extract_int(aaa, 5);\newline				if (march == NULL)\newline					march = mptr;\newline				else {\newline					struct march *mptr2;\newline\newline					mptr2 = march;\newline					while (mptr2-&gtnext != NULL)\newline						mptr2 = mptr2-&gtnext;\newline					mptr2-&gtnext = mptr;\newline				}\newline			}\newline		}\newline	}\newline	*listing = march;\newline	if (bbb) free(bbb);\newline	return ret;\newline}\newline","floor is -1 for all, or floornum \newline","4489701","lcc.c","static void error(char *fmt, char *msg) {\newline	fprintf(stderr, &quot%s: &quot, progname);\newline	fprintf(stderr, fmt, msg);\newline	fprintf(stderr, &quot\\n&quot);\newline	errcnt++;\newline}\newline","error - issue error msg according to fmt, bump error count \newline","4065816","getopt.c","static int parse_tcp_opt(int ac, char *av[], struct opts *optsp)\newline{\newline\newline	/* memorize protocol */\newline	optsp-&gtns_proto = NS_PROTO_TCP;\newline\newline	/* tcp has some default values too, set them here */\newline	optsp-&gtperform_rtt_probe = 1;\newline	optsp-&gtprotocol = IPPROTO_TCP;\newline	optsp-&gtsocktype = SOCK_STREAM;\newline\newline	while (av[0] &amp&amp av[0][0] == &#039-&#039) {\newline		if (av[0][1] == &#039C&#039)\newline			optsp-&gttcp_use_md5sig = true;\newline\newline		if (optsp-&gtworkmode == MODE_RECEIVE) {\newline			/* need peer ip address */\newline			if (!av[1] || av[1][0] == &#039-&#039)\newline				err_msg_die(EXIT_FAILOPT, &quotOption -C needs an argument (Peer IP Address)&quot);\newline			optsp-&gttcp_md5sig_peeraddr = av[1];\newline			ac--;\newline			av++;\newline		}\newline		ac--;\newline		av++;\newline	}\newline\newline	if (optsp-&gttcp_use_md5sig)\newline		msg(GENTLE, &quotEnabled TCP_MD5SIG option&quot);\newline	/* Now parse all transmit | receive specific code, plus the most\newline	 * important options: the file- and hostname\newline	 */\newline	switch (optsp-&gtworkmode) {\newline		case MODE_TRANSMIT:\newline			/* sanity check first */\newline			if (ac &lt= 1)\newline				print_usage(&quottcp transmit mode required file and destination address\\n&quot,\newline						HELP_STR_GLOBAL, 1);\newline\newline			optsp-&gtinfile = xstrdup(av[0]);\newline			optsp-&gthostname = xstrdup(av[1]);\newline\newline			break;\newline		case MODE_RECEIVE:\newline			switch (ac) {\newline				case 0: /* nothing to do */\newline					break;\newline\newline				case 2:\newline					opts.hostname = xstrdup(av[1]);\newline					/* fallthrough */\newline				case 1:\newline					opts.outfile = xstrdup(av[0]);\newline					break;\newline				default:\newline					err_msg(&quotYou specify to many arguments!&quot);\newline					print_usage(NULL, HELP_STR_GLOBAL, 1);\newline					break;\newline			};\newline\newline			break;\newline		default:\newline			err_msg_die(EXIT_FAILINT,\newline					&quotInternal, programmed error - unknown tranmit mode: %d\\n&quot,\newline					optsp-&gtworkmode);\newline	}\newline\newline	return SUCCESS;\newline}\newline","parse_tcp_opt set all tcp default values\newline within optsp and parse all tcp related options\newline ac is the number of arguments from MODE and av is\newline the correspond pointer into the array vector. We parse all tcp\newline related options first and within the switch/case statement we handle\newline transmit | receive specific options.\newline \newline","6007439","objrtmch.c","static void QueueObjectMatchAction(\newline  void *theEnv,\newline  int type,\newline  INSTANCE_TYPE *ins,\newline  int slotNameID)\newline  {\newline   OBJECT_MATCH_ACTION *prv,*cur,*newMatch;\newline\newline   prv = NULL;\newline   cur = ObjectReteData(theEnv)-&gtObjectMatchActionQueue;\newline   while (cur != NULL)\newline     {\newline      /* ===========================================================\newline         Here are the possibilities for the first Rete event already\newline         on the queue as compared with the new event for an object:\newline\newline         Assert/Retract  --&gt  Delete assert event\newline                              Ignore retract event\newline         Assert/Modify   --&gt  Ignore modify event\newline         Modify/Modify   --&gt  Merge new modify event\newline         Modify/Retract  --&gt  Delete modify event\newline                              Queue the retract event\newline         =========================================================== */\newline      if (cur-&gtins == ins)\newline        {\newline         /* ===================================================\newline            An action for initially asserting the newly created\newline            object to all applicable patterns\newline            =================================================== */\newline         if (cur-&gttype == OBJECT_ASSERT)\newline           {\newline            if (type == OBJECT_RETRACT)\newline              {\newline               /* ===================================================\newline                  If we are retracting the entire object, then we can\newline                  remove the assert action (and all modifies as well)\newline                  and ignore the retract action\newline                  (basically the object came and went before the Rete\newline                  network had a chance to see it)\newline                  =================================================== */\newline               if (prv == NULL)\newline                 ObjectReteData(theEnv)-&gtObjectMatchActionQueue = cur-&gtnxt;\newline               else\newline                 prv-&gtnxt = cur-&gtnxt;\newline               cur-&gtins-&gtbusy--;\newline               ReturnObjectMatchAction(theEnv,cur);\newline              }\newline\newline            /* =================================================\newline               If this is a modify action, then we can ignore it\newline               since the assert action will encompass it\newline               ================================================= */\newline           }\newline\newline         /* ===================================================\newline            If the object is being deleted after a slot modify,\newline            drop the modify event and replace with the retract\newline            =================================================== */\newline         else if (type == OBJECT_RETRACT)\newline           {\newline            cur-&gttype = OBJECT_RETRACT;\newline            if (cur-&gtslotNameIDs != NULL)\newline              {\newline               rm(theEnv,(void *) cur-&gtslotNameIDs,SlotBitMapSize(cur-&gtslotNameIDs));\newline               cur-&gtslotNameIDs = NULL;\newline              }\newline           }\newline\newline         /* ====================================================\newline            If a modify event for this slot is already on the\newline            queue, ignore this one. Otherwise, merge the slot id\newline            ==================================================== */\newline         else\newline            cur-&gtslotNameIDs = QueueModifySlotMap(theEnv,cur-&gtslotNameIDs,slotNameID);\newline\newline         return;\newline        }\newline      prv = cur;\newline      cur = cur-&gtnxt;\newline     }\newline\newline   /* ================================================\newline      If there are no actions for the instance already\newline      on the queue, the new action is simply appended.\newline      ================================================ */\newline   newMatch = get_struct(theEnv,objectMatchAction);\newline   newMatch-&gttype = type;\newline   newMatch-&gtnxt = cur;\newline   newMatch-&gtslotNameIDs = (type != OBJECT_MODIFY) ? NULL :\newline                       QueueModifySlotMap(theEnv,NULL,slotNameID);\newline   newMatch-&gtins = ins;\newline   newMatch-&gtins-&gtbusy++;\newline   if (prv == NULL)\newline     ObjectReteData(theEnv)-&gtObjectMatchActionQueue = newMatch;\newline   else\newline     prv-&gtnxt = newMatch;\newline  }\newline","\newlineNAME : QueueObjectMatchAction\newlineDESCRIPTION : Posts a Rete network match event\newlinefor later processing\newlineINPUTS : 1) The match action type\newlineOBJECT_ASSERT (1)\newlineOBJECT_RETRACT (2)\newlineOBJECT_MODIFY (3)\newline2) The instance to be matched\newline3) The name id of the slot being\newlineupdated (can be -1)\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Queue updated\newlineNOTES : None\newline \newline","1886672","libtcc.c","static void tcc_cleanup(void)\newline{\newline    int i, n;\newline    if (NULL == tcc_state)\newline        return;\newline    tcc_state = NULL;\newline\newline    /* free -D defines */\newline    free_defines(NULL);\newline\newline    /* free tokens */\newline    n = tok_ident - TOK_IDENT;\newline    for(i = 0; i &lt n; i++)\newline        free(table_ident[i]);\newline    free(table_ident);\newline\newline    /* free sym_pools */\newline    dynarray_reset(&ampsym_pools, &ampnb_sym_pools);\newline    /* string buffer */\newline    cstr_free(&amptokcstr);\newline    /* reset symbol stack */\newline    sym_free_first = NULL;\newline    /* cleanup from error/setjmp */\newline    macro_ptr = NULL;\newline}\newline","cleanup all static data used during compilation \newline","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","dispatch single get and set task","arch-specific routine; the machine spec for this arch","Deallocate everything properly","Compute the system key from various system information, see HashSystemInfo.","Call with syscallrecord lock held.","{}","Report the traditional tableau corresponding to the current basis","Update deploy list.","floor is -1 for all, or floornum","issue error msg according to fmt, bump error count","parse_tcp_opt set all tcp default values","Move up by COUNT lines","Posts a Rete network match eventfor later processing","cleanup all static data used during compilation","write a 50KB file through the ""compression"" stream","assumes that res->retry_mutex is locked","Change the title of a specified axis","Add context to a specific channel for global UST domain.","Loads chat data from storage.","extract check result","On a connected range fetch, send another request to the remote"
"372AGES0I453MAUWLNYDJ9FJSLWRX3","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","35DR22AR5DKDQS6N0Z2IQU8S2UCX33","A2JN7TV4U2FROT","Rejected","Wed Apr 17 10:43:31 PDT 2019","Wed Apr 17 10:56:36 PDT 2019","Fri Apr 19 10:56:36 PDT 2019","","Wed Apr 17 13:10:14 PDT 2019","These results appear to be spam, or represent a misunderstanding of the task","785","0% (0/1)","0% (0/1)","0% (0/1)","4913405","http_client.c","static void _http_init(Slapi_ComponentId *plugin_id)\newline{\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot--&gt _http_init -- BEGIN\\n&quot,0,0,0);\newline	\newline	http_impl_init(plugin_id);\newline\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot&lt-- _http_init -- END\\n&quot,0,0,0);\newline}\newline","\newline perform http initialization here \newline \newline","1807476","regress.c","RegressTestFundamentalObject *\newlineregress_test_value_get_fundamental_object (const GValue * value)\newline{\newline  g_return_val_if_fail (REGRESS_TEST_VALUE_HOLDS_FUNDAMENTAL_OBJECT (value), NULL);\newline\newline  return value-&gtdata[0].v_pointer;\newline}\newline","\newline regress_test_value_get_fundamental_object: (skip)\newline @value:\newline \newline","1003211","lp_price.c","STATIC int coldual(lprec *lp, int row_nr, REAL *prow, int *nzprow,\newline                                          REAL *drow, int *nzdrow,\newline                                          MYBOOL dualphase1, MYBOOL skipupdate,\newline                                          int *candidatecount, REAL *xviol)\newline{\newline  int      i, iy, iz, ix, k, nbound;\newline  LREAL    w, g, quot;\newline  REAL     viol, p, epspivot = lp-&gtepspivot;\newline#ifdef MachinePrecRoundRHS\newline  REAL     epsvalue = lp-&gtepsmachine;\newline#else\newline  REAL     epsvalue = lp-&gtepsvalue;\newline#endif\newline  pricerec current, candidate;\newline  MYBOOL   isbatch = FALSE, /* Requires that lp-&gtlongsteps-&gtsize &gt lp-&gtsum */\newline           dolongsteps = (MYBOOL) (lp-&gtlongsteps != NULL);\newline\newline  /* Initialize */\newline  if(dolongsteps &amp&amp !dualphase1)\newline    dolongsteps = AUTOMATIC;  /* Sets Phase1 = TRUE, Phase2 = AUTOMATIC */\newline  current.theta    = lp-&gtinfinite;\newline  current.pivot    = 0;\newline  current.varno    = 0;\newline  current.epspivot = epspivot;\newline  current.isdual   = TRUE;\newline  current.lp       = lp;\newline  candidate.epspivot = epspivot;\newline  candidate.isdual = TRUE;\newline  candidate.lp     = lp;\newline  *candidatecount  = 0;\newline\newline  /* Compute reduced costs */\newline  if(!skipupdate) {\newline#ifdef UseDualReducedCostUpdate\newline    /* Recompute from scratch only at the beginning, otherwise update */\newline    if((lp-&gtcurrent_iter &gt 0) &amp&amp (refactRecent(lp) &lt AUTOMATIC))\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               NULL, NULL,\newline                               MAT_ROUNDDEFAULT);\newline    else\newline#endif\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               drow, nzdrow,\newline                               MAT_ROUNDDEFAULT);\newline  }\newline\newline#if 0\newline  /* Override all above to do in-line testing with fixed test set */\newline  if(lp-&gtrows &gt 1 &amp&amp lp-&gtcolumns &gt 10)\newline    longdual_testset(lp, 10, row_nr, prow, nzprow, drow, nzdrow);\newline#endif\newline\newline  /* Compute the current violation of the bounds of the outgoing variable,\newline     negative for violation of lower bound, positive for upper bound violation.\newline     (Basic variables are always lower-bounded, by lp_solve convention) */\newline  g = 1;\newline  viol = lp-&gtrhs[row_nr];\newline  if(viol &gt 0) {   /* Check if the leaving variable is &gt= its upper bound */\newline    p = lp-&gtupbo[lp-&gtvar_basic[row_nr]];\newline    if(p &lt lp-&gtinfinite) {\newline      viol -= p;\newline      my_roundzero(viol, epsvalue);\newline      if(viol &gt 0)\newline        g = -1;\newline    }\newline    /* Do validation of numerics */\newline    if(g == 1) {\newline      if(viol &gt= lp-&gtinfinite) {\newline        report(lp, IMPORTANT, &quotcoldual: Large basic solution value %g at iter %.0f indicates numerical instability\\n&quot,\newline                               lp-&gtrhs[row_nr], (double) get_total_iter(lp));\newline        lp-&gtspx_status = NUMFAILURE;\newline        return( 0 );\newline\newline      }\newline      if(skipupdate)\newline        report(lp, DETAILED, &quotcoldual: Inaccurate bound-flip accuracy at iter %.0f\\n&quot,\newline                              (double) get_total_iter(lp));\newline      else\newline        report(lp, SEVERE,   &quotcoldual: Leaving variable %d does not violate bounds at iter %.0f\\n&quot,\newline                              row_nr, (double) get_total_iter(lp));\newline      return( -1 );\newline    }\newline  }\newline\newline  /* Update local value of pivot setting */\newline  lp-&gt_piv_rule_ = get_piv_rule(lp);\newline\newline  /* Condense list of relevant targets */\newline  p = 0;\newline  k = 0;\newline  nbound = 0;\newline  ix = 1;\newline  iy = nzprow[0];\newline  for(ix = 1; ix &lt= iy; ix++) {\newline    i = nzprow[ix];\newline    w = prow[i] * g;            /* Change sign if upper bound of the leaving variable is violated   */\newline    w *= 2*lp-&gtis_lower[i] - 1; /* Change sign if the non-basic variable is currently upper-bounded */\newline\newline    /* Check if the candidate is worth using for anything */\newline    if(w &lt -epsvalue) {\newline      /* Tally bounded variables */\newline      if(lp-&gtupbo[i] &lt lp-&gtinfinite)\newline        nbound++;\newline\newline      /* Update the nz-index */\newline      k++;\newline      nzprow[k] = i;\newline      SETMAX(p, -w);\newline    }\newline#ifdef Paranoia\newline    else {\newline      if(lp-&gtspx_trace) {\newline        report(lp, FULL, &quotcoldual: Candidate variable prow[%d] rejected with %g too small\\n&quot,\newline                         i, w);\newline      }\newline    }\newline#endif\newline\newline  }\newline  nzprow[0] = k;\newline  if(xviol != NULL)\newline    *xviol = p;\newline\newline#ifdef UseRelativePivot_Dual\newline/*  epspivot *= sqrt(lp-&gtmatA-&gtdynrange) / lp-&gtmatA-&gtinfnorm; */\newline  epspivot /= MAX(1, sqrt(lp-&gtmatA-&gtrowmax[row_nr]));\newline#endif\newline  current.epspivot   = epspivot;\newline  candidate.epspivot = epspivot;\newline\newline  /* Initialize the long-step structures if indicated */\newline  if(dolongsteps) {\newline    if((nzprow[0] &lt= 1) || (nbound == 0)) {  /* Don&#039t bother */\newline      dolongsteps = FALSE;\newline      lp-&gtlongsteps-&gtindexSet[0] = 0;\newline    }\newline    else {\newline      multi_restart(lp-&gtlongsteps);\newline      multi_valueInit(lp-&gtlongsteps, g*viol, lp-&gtrhs[0]);\newline    }\newline  }\newline\newline  /* Loop over all entering column candidates */\newline  ix = 1;\newline  iy = nzprow[0];\newline  makePriceLoop(lp, &ampix, &ampiy, &ampiz);\newline  iy *= iz;\newline  for(; ix*iz &lt= iy; ix += iz) {\newline    i = nzprow[ix];\newline\newline    /* Compute the dual ratio (prow = w and drow = cbar in Chvatal&#039s &quotnomenclatura&quot) */\newline    w    = prow[i] * g;         /* Change sign if upper bound of the leaving variable is violated   */\newline    quot = -drow[i] / w;        /* Remember this sign-reversal in multi_recompute!                  */\newline\newline    /* Apply the selected pivot strategy (smallest theta) */\newline    candidate.theta = quot;  /* Note that abs() is applied in findSubstitutionVar */\newline    candidate.pivot = w;\newline    candidate.varno = i;\newline\newline    /* Collect candidates for minor iterations/bound flips */\newline    if(dolongsteps) {\newline      if(isbatch &amp&amp (ix == iy))\newline        isbatch = AUTOMATIC;\newline      if(collectMinorVar(&ampcandidate, lp-&gtlongsteps, (MYBOOL) (dolongsteps == AUTOMATIC), isbatch) &amp&amp\newline         lp-&gtspx_trace)\newline        report(lp, DETAILED, &quotcoldual: Long-dual break point with %d bound-flip variables\\n&quot,\newline                             lp-&gtlongsteps-&gtused);\newline      if(lp-&gtspx_status == FATHOMED)\newline        return( 0 );\newline    }\newline\newline    /* We have a candidate for entering the basis; check if it is better than the incumbent */\newline    else if(findSubstitutionVar(&ampcurrent, &ampcandidate, candidatecount))\newline      break;\newline  }\newline\newline  /* Set entering variable and long-step bound swap variables */\newline  if(dolongsteps) {\newline    *candidatecount = lp-&gtlongsteps-&gtused;\newline    i = multi_enteringvar(lp-&gtlongsteps, NULL, 3);\newline  }\newline  else\newline    i = current.varno;\newline\newline  if(lp-&gtspx_trace)\newline    report(lp, NORMAL, &quotcoldual: Entering column %d, reduced cost %g, pivot value %g, bound swaps %d\\n&quot,\newline                       i, drow[i], prow[i], multi_used(lp-&gtlongsteps));\newline\newline  return( i );\newline} /* coldual */\newline","Find the dual simplex entering non-basic variable \newline","4713257","ximasel.cpp","bool CxImage::SelectionClear()\newline{\newline	if (pSelection){\newline		memset(pSelection,0,head.biWidth * head.biHeight);\newline		info.rSelectionBox.left = head.biWidth;\newline		info.rSelectionBox.bottom = head.biHeight;\newline		info.rSelectionBox.right = info.rSelectionBox.top = 0;\newline		return true;\newline	}\newline	return false;\newline}\newline","\newline Empties the selection.\newline \newline","1213526","cdirect.c","static nlopt_result divide_rect(double *rdiv, params *p)\newline{\newline     int i;\newline     const int n = p-&gtn;\newline     const int L = p-&gtL;\newline     double *c = rdiv + 3; /* center of rect to divide */\newline     double *w = c + n; /* widths of rect to divide */\newline     double wmax = w[0];\newline     int imax = 0, nlongest = 0;\newline     rb_node *node;\newline\newline     for (i = 1; i &lt n; ++i)\newline	  if (w[i] &gt wmax)\newline	       wmax = w[imax = i];\newline     for (i = 0; i &lt n; ++i)\newline	  if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL)\newline	       ++nlongest;\newline     if (p-&gtwhich_div == 1 || (p-&gtwhich_div == 0 &amp&amp nlongest == n)) {\newline	  /* trisect all longest sides, in increasing order of the average\newline	     function value along that direction */\newline	  double *fv = p-&gtwork;\newline	  int *isort = p-&gtiwork;\newline	  for (i = 0; i &lt n; ++i) {\newline	       if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL) {\newline		    double csave = c[i];\newline		    c[i] = csave - w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i], c, p, 0);\newline		    c[i] = csave + w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i+1], c, p, 0);\newline		    c[i] = csave;\newline	       }\newline	       else {\newline		    fv[2*i] = fv[2*i+1] = HUGE_VAL;\newline	       }\newline	  }\newline	  sort_fv(n, fv, isort);\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  for (i = 0; i &lt nlongest; ++i) {\newline	       int k;\newline	       w[isort[i]] *= THIRD;\newline	       rdiv[0] = rect_diameter(n, w, p);\newline	       rdiv[2] = p-&gtage++;\newline	       node = rb_tree_resort(&ampp-&gtrtree, node);\newline	       for (k = 0; k &lt= 1; ++k) {\newline		    double *rnew;\newline		    ALLOC_RECT(rnew, L);\newline		    memcpy(rnew, rdiv, sizeof(double) * L);\newline		    rnew[3 + isort[i]] += w[isort[i]] * (2*k-1);\newline		    rnew[1] = fv[2*isort[i]+k];\newline		    rnew[2] = p-&gtage++;\newline		    if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline			 free(rnew);\newline			 return NLOPT_OUT_OF_MEMORY;\newline		    }\newline	       }\newline	  }\newline     }\newline     else {\newline	  int k;\newline	  if (nlongest &gt 1 &amp&amp p-&gtwhich_div == 2) { \newline               /* randomly choose longest side */\newline	       i = nlopt_iurand(nlongest);\newline	       for (k = 0; k &lt n; ++k)\newline		    if (wmax - w[k] &lt= wmax * EQUAL_SIDE_TOL) {\newline			 if (!i) { i = k; break; }\newline			 --i;\newline		    }\newline	  }\newline	  else\newline	       i = imax; /* trisect longest side */\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  w[i] *= THIRD;\newline	  rdiv[0] = rect_diameter(n, w, p);\newline	  rdiv[2] = p-&gtage++;\newline	  node = rb_tree_resort(&ampp-&gtrtree, node);\newline	  for (k = 0; k &lt= 1; ++k) {\newline	       double *rnew;\newline	       ALLOC_RECT(rnew, L);\newline	       memcpy(rnew, rdiv, sizeof(double) * L);\newline	       rnew[3 + i] += w[i] * (2*k-1);\newline	       FUNCTION_EVAL(rnew[1], rnew + 3, p, rnew);\newline	       rnew[2] = p-&gtage++;\newline	       if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline		    free(rnew);\newline		    return NLOPT_OUT_OF_MEMORY;\newline	       }\newline	  }\newline     }\newline     return NLOPT_SUCCESS;\newline}\newline","divide rectangle idiv in the list p-&gtrects \newline","1118681","libfwnt_security_identifier.c","int libfwnt_security_identifier_initialize(\newline     libfwnt_security_identifier_t **security_identifier,\newline     libcerror_error_t **error )\newline{\newline	libfwnt_internal_security_identifier_t *internal_security_identifier = NULL;\newline	static char *function                                                = &quotlibfwnt_security_identifier_initialize&quot;\newline\newline	if( security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid security identifier.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *security_identifier != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid security identifier value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_security_identifier = memory_allocate_structure(\newline	                                libfwnt_internal_security_identifier_t );\newline\newline	if( internal_security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     internal_security_identifier,\newline	     0,\newline	     sizeof( libfwnt_internal_security_identifier_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	*security_identifier = (libfwnt_security_identifier_t *) internal_security_identifier;\newline\newline	return( 1 );\newline\newlineon_error:\newline	if( internal_security_identifier != NULL )\newline	{\newline		memory_free(\newline		 internal_security_identifier );\newline	}\newline	return( -1 );\newline}\newline","Creates a security identifier\newline Make sure the value security_identifier is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","3908740","jsprf.cpp","JS_PUBLIC_API(JSUint32) JS_snprintf(char *out, JSUint32 outlen, const char *fmt, ...)\newline{\newline    va_list ap;\newline    int rv;\newline\newline    JS_ASSERT((JSInt32)outlen &gt 0);\newline    if ((JSInt32)outlen &lt= 0) {\newline        return 0;\newline    }\newline\newline    va_start(ap, fmt);\newline    rv = JS_vsnprintf(out, outlen, fmt, ap);\newline    va_end(ap);\newline    return rv;\newline}\newline","\newline sprintf into a fixed size buffer. Make sure there is a NUL at the end\newline when finished.\newline \newline","3687433","cdrfifo.c","int Cdrfifo_attach_follow_up_fds(struct CdrfifO *o, int source_fd, int dest_fd,\newline                                 int flag)\newline{\newline if(o-&gtfollow_up_fd_counter&gt=Cdrfifo_ffd_maX)\newline   return(0);\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][0]= source_fd;\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][1]= dest_fd;\newline  o-&gtfollow_up_fd_counter++;\newline  return(o-&gtfollow_up_fd_counter);\newline}\newline","Attach a further pair of input and output fd which will use the same\newlinefifo buffer when its predecessors are exhausted. Reading will start as\newlinesoon as reading of the predecessor encounters EOF. Writing will start\newlineas soon as all pending predecessor data are written.\newline@return index number of new item + 1, &lt=0 indicates error\newline \newline","1781824","ocean.c","static void gfs_free_surface_pressure (GfsDomain * toplayer,\newline				       GfsMultilevelParams * par,\newline				       GfsAdvectionParams * apar,\newline				       GfsVariable * p,\newline				       GfsVariable * div,\newline				       GfsVariable * divn,\newline				       GfsVariable * res,\newline				       gdouble G)\newline{\newline  FreeSurfaceParams fp;\newline  GfsVariable * res1;\newline\newline  g_return_if_fail (toplayer != NULL);\newline  g_return_if_fail (par != NULL);\newline  g_return_if_fail (apar != NULL);\newline  g_return_if_fail (p != NULL);\newline  g_return_if_fail (div != NULL);\newline  g_return_if_fail (divn != NULL);\newline  g_return_if_fail (G &gt 0.);\newline\newline  fp.pn = p;\newline  fp.div = div;\newline  fp.dia = gfs_temporary_variable (toplayer);\newline  res1 = res ? res : gfs_temporary_variable (toplayer);\newline  fp.divn = divn;\newline  fp.dt = apar-&gtdt;\newline  fp.G = G;\newline\newline  /* compute MAC divergence */\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,\newline			    (FttCellTraverseFunc) normal_divergence, &ampfp);\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,\newline  			    (FttCellTraverseFunc) scale_divergence_helmoltz, &ampfp);\newline  \newline  /* solve for pressure */\newline  par-&gtdimension = 2;\newline  par-&gtpoisson_solve (toplayer, par, p, fp.div, res1, fp.dia, apar-&gtdt);\newline#if !FTT_2D\newline  gfs_domain_traverse_merged (toplayer, (GfsMergedTraverseFunc) merge_pressures, p);\newline#endif\newline\newline  if (!res)\newline    gts_object_destroy (GTS_OBJECT (res1));\newline  gts_object_destroy (GTS_OBJECT (fp.dia));\newline}\newline","\newline gfs_free_surface_pressure:\newline @toplayer: a #GfsDomain.\newline @par: the multigrid paramaters.\newline @apar: the advection parameters.\newline \newline \newline","888223","tcl_class.c","t_class * tclpd_class_new(const char *name, int flags) {\newline    t_class *c = class_new(gensym(name), (t_newmethod)tclpd_new,\newline        (t_method)tclpd_free, sizeof(t_tcl), flags, A_GIMME, A_NULL);\newline\newline    if(!class_table)\newline        class_table = hashtable_new(1 &lt&lt 7);\newline    if(!class_table_get(name))\newline        class_table_add(name, c);\newline\newline    class_addanything(c, tclpd_anything);\newline\newline    // is this really necessary given that there is already a &#039anything&#039 handler?\newline    class_addmethod(c, (t_method)tclpd_loadbang, gensym(&quotloadbang&quot), A_NULL);\newline    \newline    class_addmethod(c, (t_method)tclpd_open, gensym(&quotmenu-open&quot), A_NULL);\newline\newline    char buf[80];\newline    Tcl_Obj *res;\newline    int res_i;\newline\newline    // use properties function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::properties]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setpropertiesfn(c, tclpd_properties);\newline        }\newline    }\newline\newline    // use save function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::save]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setsavefn(c, tclpd_save);\newline        }\newline    }\newline\newline    return c;\newline}\newline","set up the class that handles loading of tcl classes \newline","3676136","libics_binary.c","Ics_Error IcsSetIdsBlock (Ics_Header* IcsStruct, long offset, int whence)\newline{\newline   ICSINIT;\newline   Ics_BlockRead* br = (Ics_BlockRead*)IcsStruct-&gtBlockRead;\newline\newline   switch (IcsStruct-&gtCompression) {\newline      case IcsCompr_uncompressed:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               if (fseek(br-&gtDataFilePtr, (long)offset, whence) != 0) {\newline                  error = ferror(br-&gtDataFilePtr) ? IcsErr_FReadIds : IcsErr_EndOfStream;\newline               }\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#ifdef ICS_ZLIB\newline      case IcsCompr_gzip:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               error = IcsSetZipBlock (IcsStruct, offset, whence);\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#endif\newline      case IcsCompr_compress:\newline         error = IcsErr_BlockNotAllowed;\newline         break;\newline      default:\newline         error = IcsErr_UnknownCompression;\newline   }\newline\newline   return error;\newline}\newline","\newline Sets the file pointer into the IDS file.\newline \newline","5198035","apc_pool.c","PHP_APCU_API apc_pool* apc_pool_create(apc_pool_type pool_type,\newline                                       apc_malloc_t allocate, \newline                                       apc_free_t deallocate,\newline                                       apc_protect_t protect,\newline                                       apc_unprotect_t unprotect) \newline{\newline    if(pool_type == APC_UNPOOL) {\newline        return apc_unpool_create(pool_type, allocate, deallocate, protect, unprotect);\newline    }\newline\newline    return apc_realpool_create(pool_type, allocate, deallocate, protect,  unprotect);\newline}\newline","{{{ apc_pool_create \newline","2796020","libuna_base64_stream.c","LIBUNA_INLINE \\\newlineint libuna_base64_triplet_copy_from_base64_stream(\newline     uint32_t *base64_triplet,\newline     const uint8_t *base64_stream,\newline     size_t base64_stream_size,\newline     size_t *base64_stream_index,\newline     uint8_t *padding_size,\newline     uint32_t base64_variant,\newline     libcerror_error_t **error )\newline{\newline	static char *function        = &quotlibuna_base64_triplet_copy_from_base64_stream&quot;\newline	size_t base64_character_size = 0;\newline	size_t stream_index          = 0;\newline	uint32_t base64_character    = 0;\newline	uint8_t padding_character    = 0;\newline	uint8_t sixtet1              = 0;\newline	uint8_t sixtet2              = 0;\newline	uint8_t sixtet3              = 0;\newline	uint8_t sixtet4              = 0;\newline\newline	if( base64_triplet == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 triplet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid base64 stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *base64_stream_index &gt= base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: base64 stream string too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( padding_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid padding size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0x0f000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_PADDING_NONE:\newline			padding_character = 0;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_OPTIONAL:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_REQUIRED:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character_size = 1;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			base64_character_size = 2;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			base64_character_size = 4;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	stream_index = *base64_stream_index;\newline\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet1,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 1st sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet2,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 2nd sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*padding_size = 2;\newline\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 3rd base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet3 = 0;\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet3,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 3rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 3rd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 4th base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet4 = 0;\newline		}\newline		else if( *padding_size &gt 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4th base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet4,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 4th base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*base64_triplet   = sixtet1;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet2;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet3;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet4;\newline\newline	*base64_stream_index = stream_index;\newline\newline	return( 1 );\newline}\newline","Copies a base64 triplet from a base64 stream\newline \newline The padding size will still be set to indicate the number of\newline sixtets in the triplet\newline \newline Returns 1 if successful or -1 on error\newline \newline","1851940","concat-deps.c","static void emit_single_boost_header(void)\newline{\newline#define BOOST_TARGET &quot/UnpackedTarball/boost.done&quot\newline    fprintf(stdout, &quot%s&quot BOOST_TARGET &quot &quot, work_dir);\newline}\newline","\newline We collapse tens of internal boost headers to the unpacked target, such\newline that you can re-compile / install boost and all is well.\newline \newline","4938294","xmu.c","int XmuPrintDefaultErrorMessage (Display *dpy, XErrorEvent *event, FILE *fp)\newline{\newline    char buffer[BUFSIZ];\newline    char mesg[BUFSIZ];\newline    char number[32];\newline    char *mtype = &quotXlibMessage&quot;\newline    _XExtension *ext = (_XExtension *)NULL;\newline    XGetErrorText(dpy, event-&gterror_code, buffer, BUFSIZ);\newline    XGetErrorDatabaseText(dpy, mtype, &quotXError&quot, &quotX Error&quot, mesg, BUFSIZ);\newline    fprintf(fp, &quot%s:  %s\\n  &quot, mesg, buffer);\newline    XGetErrorDatabaseText(dpy, mtype, &quotMajorCode&quot, &quotRequest Major code %d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtrequest_code);\newline    if (event-&gtrequest_code &lt 128) {\newline	sprintf(number, &quot%d&quot, event-&gtrequest_code);\newline	XGetErrorDatabaseText(dpy, &quotXRequest&quot, number, &quot&quot, buffer, BUFSIZ);\newline    } else {\newline	/* XXX this is non-portable */\newline	for (ext = dpy-&gtext_procs;\newline	     ext &amp&amp (ext-&gtcodes.major_opcode != event-&gtrequest_code);\newline	     ext = ext-&gtnext)\newline	  ;\newline	if (ext)\newline	    strcpy(buffer, ext-&gtname);\newline	else\newline	    buffer[0] = &#039\\0&#039;\newline    }\newline    fprintf(fp, &quot (%s)&quot, buffer);\newline    fputs(&quot\\n  &quot, fp);\newline#if (XtSpecificationRelease &gt= 5)\newline    if (event-&gtrequest_code &gt= 128) {\newline	XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			      mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtminor_code);\newline	if (ext) {\newline	    sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline	    XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline	    fprintf(fp, &quot (%s)&quot, buffer);\newline	}\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline    if (event-&gterror_code &gt= 128) {\newline	/* let extensions try to print the values */\newline	/* XXX this is non-portable code */\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_values)\newline		(*ext-&gterror_values)(dpy, event, fp);\newline	}\newline	/* the rest is a fallback, providing a simple default */\newline	/* kludge, try to find the extension that caused it */\newline	buffer[0] = &#039\\0&#039;\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_string)\newline		(*ext-&gterror_string)(dpy, event-&gterror_code, &ampext-&gtcodes,\newline				     buffer, BUFSIZ);\newline	    if (buffer[0])\newline		break;\newline	}\newline	if (buffer[0])\newline	    sprintf(buffer, &quot%s.%d&quot, ext-&gtname,\newline		    event-&gterror_code - ext-&gtcodes.first_error);\newline	else\newline	    strcpy(buffer, &quotValue&quot);\newline	XGetErrorDatabaseText(dpy, mtype, buffer, &quot&quot, mesg, BUFSIZ);\newline	if (*mesg) {\newline	    fprintf(fp, mesg, event-&gtresourceid);\newline	    fputs(&quot\\n  &quot, fp);\newline	}\newline    } else if ((event-&gterror_code == BadWindow) ||\newline	       (event-&gterror_code == BadPixmap) ||\newline	       (event-&gterror_code == BadCursor) ||\newline	       (event-&gterror_code == BadFont) ||\newline	       (event-&gterror_code == BadDrawable) ||\newline	       (event-&gterror_code == BadColor) ||\newline	       (event-&gterror_code == BadGC) ||\newline	       (event-&gterror_code == BadIDChoice) ||\newline	       (event-&gterror_code == BadValue) ||\newline	       (event-&gterror_code == BadAtom)) {\newline	if (event-&gterror_code == BadValue)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotValue&quot, &quotValue 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else if (event-&gterror_code == BadAtom)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotAtomID&quot, &quotAtomID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else\newline	    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtresourceid);\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline#elif (XtSpecificationRelease == 4)\newline    XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtminor_code);\newline    fputs(&quot\\n  &quot, fp);\newline    if (ext) {\newline      sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline      XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline      fprintf(fp, &quot (%s)&quot, buffer);\newline    }\newline    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtresourceid);\newline    fputs(&quot\\n  &quot, fp);\newline#else\newlineERROR! Unsupported release of X11\newline#endif\newline    XGetErrorDatabaseText(dpy, mtype, &quotErrorSerial&quot, &quotError Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtserial);\newline    fputs(&quot\\n  &quot, fp);\newline    XGetErrorDatabaseText(dpy, mtype, &quotCurrentSerial&quot, &quotCurrent Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, NextRequest(dpy)-1);\newline    fputs(&quot\\n&quot, fp);\newline    if (event-&gterror_code == BadImplementation) return 0;\newline    return 1;\newline}\newline","\newline XmuPrintDefaultErrorMessage - print a nice error that looks like the usual\newline message. Return 1 if the caller should consider exiting, else 0.\newline \newline","772479","coverity_model.c","void *memccpy(void *dest, const void *src, int c, size_t n)\newline{\newline	const char *s = src;\newline	char *d = dest;\newline\newline	while (n-- &gt 0)\newline		if ((*d++ = *s++) == (char) c)\newline			return d;\newline\newline	return 0;\newline}\newline","simple_memccpy() from glibc \newline","1305953","filter_chain.c","int fc_register_match(const char *name, match_proc_t proc) /* {{{ */\newline{\newline  fc_match_t *m;\newline\newline  DEBUG(&quotfc_register_match (%s);&quot, name);\newline\newline  m = calloc(1, sizeof(*m));\newline  if (m == NULL)\newline    return (-ENOMEM);\newline\newline  sstrncpy(m-&gtname, name, sizeof(m-&gtname));\newline  memcpy(&ampm-&gtproc, &ampproc, sizeof(m-&gtproc));\newline\newline  if (match_list_head == NULL) {\newline    match_list_head = m;\newline  } else {\newline    fc_match_t *ptr;\newline\newline    ptr = match_list_head;\newline    while (ptr-&gtnext != NULL)\newline      ptr = ptr-&gtnext;\newline\newline    ptr-&gtnext = m;\newline  }\newline\newline  return (0);\newline} /* }}} int fc_register_match */\newline","Add a match to list of available matches. \newline","12245","rxstack.c","Client *get_new_client( )\newline{\newline   Client *retval = (Client *)malloc( sizeof( Client ) ) ;\newline\newline   if ( retval == NULL )\newline      return NULL ;\newline   memset( retval, 0, sizeof( Client ) ) ;\newline   retval-&gtsocket = -1 ;\newline   retval-&gtdeadline.milli = -1 ; /* deadline not used --&gt infinite timeout */\newline\newline   retval-&gtnext = clients ;\newline   if ( clients != NULL )\newline      clients-&gtprev = retval ;\newline   clients = retval ;\newline   return retval ;\newline}\newline","Creates a new client and appends it in front of the current clients.\newline Don&#039t forget to set a default_queue and the socket at once.\newline \newline","6007706","dfinscmp.c","static void CloseDefinstancesFiles(\newline  void *theEnv,\newline  FILE *moduleFile,\newline  FILE *definstancesFile,\newline  int maxIndices)\newline  {\newline   int count = maxIndices;\newline   int arrayVersion = 0;\newline\newline   if (definstancesFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,definstancesFile,&ampcount,&amparrayVersion,\newline                                         maxIndices,NULL,NULL);\newline     }\newline\newline   if (moduleFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,moduleFile,&ampcount,&amparrayVersion,maxIndices,NULL,NULL);\newline     }\newline  }\newline","\newlineNAME : CloseDefinstancesFiles\newlineDESCRIPTION : Closes construct compiler files\newlinefor definstances structures\newlineINPUTS : 1) The definstances module file\newline2) The definstances structure file\newline3) The maximum number of indices\newlineallowed in an array\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Files closed\newlineNOTES : None\newline \newline","1085640","pns.c","static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\newline                                   uint8_t sub,\newline                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\newline{\newline#ifndef FIXED_POINT\newline    uint16_t i;\newline    real_t energy = 0.0;\newline\newline    real_t scale = (real_t)1.0/(real_t)size;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\newline        spec[i] = tmp;\newline        energy += tmp*tmp;\newline    }\newline\newline    scale = (real_t)1.0/(real_t)sqrt(energy);\newline    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\newline    for (i = 0; i &lt size; i++)\newline    {\newline        spec[i] *= scale;\newline    }\newline#else\newline    uint16_t i;\newline    real_t energy = 0, scale;\newline    int32_t exp, frac;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        /* this can be replaced by a 16 bit random generator!!!! */\newline        real_t tmp = (int32_t)ne_rng(__r1, __r2);\newline        if (tmp &lt 0)\newline            tmp = -(tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline        else\newline            tmp = (tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline\newline        energy += MUL_R(tmp,tmp);\newline\newline        spec[i] = tmp;\newline    }\newline\newline    energy = fp_sqrt(energy);\newline    if (energy &gt 0)\newline    {\newline        scale = DIV(REAL_CONST(1),energy);\newline\newline        exp = scale_factor &gt&gt 2;\newline        frac = scale_factor &amp 3;\newline\newline        /* IMDCT pre-scaling */\newline        exp -= sub;\newline\newline        if (exp &lt 0)\newline            scale &gt&gt= -exp;\newline        else\newline            scale &lt&lt= exp;\newline\newline        if (frac)\newline            scale = MUL_C(scale, pow2_table[frac]);\newline\newline        for (i = 0; i &lt size; i++)\newline        {\newline            spec[i] = MUL_R(spec[i], scale);\newline        }\newline    }\newline#endif\newline}\newline","The function gen_rand_vector(addr, size) generates a vector of length\newline&ltsize&gt with signed random values of average energy MEAN_NRG per random\newlinevalue. A suitable random number generator can be realized using one\newlinemultiplication/accumulation per random value.\newline \newline","12911","files.c","void find_shared_library(const tsd_t *TSD, const char *inname, const char *inenv, char *retname)\newline{\newline   char *paths;\newline   char outname[REXX_PATH_MAX+1];\newline   char *env_path;\newline\newline   strcpy( retname, inname );\newline   env_path = mygetenv( TSD, inenv, NULL, 0 ); /* fixes bug 595293 */\newline   if ( !env_path )\newline      return;\newline   paths = env_path;\newline   while ( paths &amp&amp *paths )\newline   {\newline      int pathlen;\newline      char *sep;\newline\newline      sep = strchr( paths, PATH_SEPARATOR );\newline      pathlen = sep ? sep-paths : strlen( paths );\newline      strncpy( outname, paths, pathlen );\newline      outname[pathlen] = 0;\newline\newline      if ( ( pathlen &gt 0 ) &amp&amp ( outname[pathlen-1] != FILE_SEPARATOR ) )\newline         strcat( outname, FILE_SEPARATOR_STR );\newline      strcat( outname, inname );\newline      paths = sep ? sep+1 : 0; /* set up for next pass */\newline      if ( access( outname,F_OK ) == 0)\newline      {\newline         strcpy( retname,outname );\newline         break;\newline      }\newline   }\newline   FreeTSD( env_path );\newline   return;\newline}\newline","\newline find_shared_library is used for HP/UX purpose only.\newline It looks for the file inname in the content of the environment variable\newline inenv and puts the result into retname. retname has to have a size of\newline at least REXX_PATH_MAX+1.\newline retname becomes inname if no other file is found.\newline \newline","","on","on","","","","","","on","","","","","","","on","","","on","","","","","","on","on","on","on","on","on","on","on","on","on","on","on","","on","on","","on","on","http initialization","{}","{}","{{{ apc_pool_create","1 if successful or -1","re-compile / install boost and all is well.","XmuPrintDefaultErrorMessage - print","simple_memccpy() from glibc","{}","default_queue","SIDE EFFECTS : Files closed","regress_test_value_get_fundamental_object:","<size> with signed random values of average energy","REXX_PATH_MAX+1.","non-basic","{}","p->rects","1 if successful or -1 on error","{}","item + 1, <=0 indicates error","@toplayer: a #GfsDomain."
"372AGES0I453MAUWLNYDJ9FJSLWRX3","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3J2UYBXQQLC4QLNUGPB9OJX12FT60P","A3IP361MQUN3AA","Approved","Wed Apr 17 12:52:55 PDT 2019","Wed Apr 17 13:05:28 PDT 2019","Fri Apr 19 13:05:28 PDT 2019","2019-04-19 20:06:21 UTC","","","753","100% (1/1)","100% (1/1)","100% (1/1)","4913405","http_client.c","static void _http_init(Slapi_ComponentId *plugin_id)\newline{\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot--&gt _http_init -- BEGIN\\n&quot,0,0,0);\newline	\newline	http_impl_init(plugin_id);\newline\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot&lt-- _http_init -- END\\n&quot,0,0,0);\newline}\newline","\newline perform http initialization here \newline \newline","1807476","regress.c","RegressTestFundamentalObject *\newlineregress_test_value_get_fundamental_object (const GValue * value)\newline{\newline  g_return_val_if_fail (REGRESS_TEST_VALUE_HOLDS_FUNDAMENTAL_OBJECT (value), NULL);\newline\newline  return value-&gtdata[0].v_pointer;\newline}\newline","\newline regress_test_value_get_fundamental_object: (skip)\newline @value:\newline \newline","1003211","lp_price.c","STATIC int coldual(lprec *lp, int row_nr, REAL *prow, int *nzprow,\newline                                          REAL *drow, int *nzdrow,\newline                                          MYBOOL dualphase1, MYBOOL skipupdate,\newline                                          int *candidatecount, REAL *xviol)\newline{\newline  int      i, iy, iz, ix, k, nbound;\newline  LREAL    w, g, quot;\newline  REAL     viol, p, epspivot = lp-&gtepspivot;\newline#ifdef MachinePrecRoundRHS\newline  REAL     epsvalue = lp-&gtepsmachine;\newline#else\newline  REAL     epsvalue = lp-&gtepsvalue;\newline#endif\newline  pricerec current, candidate;\newline  MYBOOL   isbatch = FALSE, /* Requires that lp-&gtlongsteps-&gtsize &gt lp-&gtsum */\newline           dolongsteps = (MYBOOL) (lp-&gtlongsteps != NULL);\newline\newline  /* Initialize */\newline  if(dolongsteps &amp&amp !dualphase1)\newline    dolongsteps = AUTOMATIC;  /* Sets Phase1 = TRUE, Phase2 = AUTOMATIC */\newline  current.theta    = lp-&gtinfinite;\newline  current.pivot    = 0;\newline  current.varno    = 0;\newline  current.epspivot = epspivot;\newline  current.isdual   = TRUE;\newline  current.lp       = lp;\newline  candidate.epspivot = epspivot;\newline  candidate.isdual = TRUE;\newline  candidate.lp     = lp;\newline  *candidatecount  = 0;\newline\newline  /* Compute reduced costs */\newline  if(!skipupdate) {\newline#ifdef UseDualReducedCostUpdate\newline    /* Recompute from scratch only at the beginning, otherwise update */\newline    if((lp-&gtcurrent_iter &gt 0) &amp&amp (refactRecent(lp) &lt AUTOMATIC))\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               NULL, NULL,\newline                               MAT_ROUNDDEFAULT);\newline    else\newline#endif\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               drow, nzdrow,\newline                               MAT_ROUNDDEFAULT);\newline  }\newline\newline#if 0\newline  /* Override all above to do in-line testing with fixed test set */\newline  if(lp-&gtrows &gt 1 &amp&amp lp-&gtcolumns &gt 10)\newline    longdual_testset(lp, 10, row_nr, prow, nzprow, drow, nzdrow);\newline#endif\newline\newline  /* Compute the current violation of the bounds of the outgoing variable,\newline     negative for violation of lower bound, positive for upper bound violation.\newline     (Basic variables are always lower-bounded, by lp_solve convention) */\newline  g = 1;\newline  viol = lp-&gtrhs[row_nr];\newline  if(viol &gt 0) {   /* Check if the leaving variable is &gt= its upper bound */\newline    p = lp-&gtupbo[lp-&gtvar_basic[row_nr]];\newline    if(p &lt lp-&gtinfinite) {\newline      viol -= p;\newline      my_roundzero(viol, epsvalue);\newline      if(viol &gt 0)\newline        g = -1;\newline    }\newline    /* Do validation of numerics */\newline    if(g == 1) {\newline      if(viol &gt= lp-&gtinfinite) {\newline        report(lp, IMPORTANT, &quotcoldual: Large basic solution value %g at iter %.0f indicates numerical instability\\n&quot,\newline                               lp-&gtrhs[row_nr], (double) get_total_iter(lp));\newline        lp-&gtspx_status = NUMFAILURE;\newline        return( 0 );\newline\newline      }\newline      if(skipupdate)\newline        report(lp, DETAILED, &quotcoldual: Inaccurate bound-flip accuracy at iter %.0f\\n&quot,\newline                              (double) get_total_iter(lp));\newline      else\newline        report(lp, SEVERE,   &quotcoldual: Leaving variable %d does not violate bounds at iter %.0f\\n&quot,\newline                              row_nr, (double) get_total_iter(lp));\newline      return( -1 );\newline    }\newline  }\newline\newline  /* Update local value of pivot setting */\newline  lp-&gt_piv_rule_ = get_piv_rule(lp);\newline\newline  /* Condense list of relevant targets */\newline  p = 0;\newline  k = 0;\newline  nbound = 0;\newline  ix = 1;\newline  iy = nzprow[0];\newline  for(ix = 1; ix &lt= iy; ix++) {\newline    i = nzprow[ix];\newline    w = prow[i] * g;            /* Change sign if upper bound of the leaving variable is violated   */\newline    w *= 2*lp-&gtis_lower[i] - 1; /* Change sign if the non-basic variable is currently upper-bounded */\newline\newline    /* Check if the candidate is worth using for anything */\newline    if(w &lt -epsvalue) {\newline      /* Tally bounded variables */\newline      if(lp-&gtupbo[i] &lt lp-&gtinfinite)\newline        nbound++;\newline\newline      /* Update the nz-index */\newline      k++;\newline      nzprow[k] = i;\newline      SETMAX(p, -w);\newline    }\newline#ifdef Paranoia\newline    else {\newline      if(lp-&gtspx_trace) {\newline        report(lp, FULL, &quotcoldual: Candidate variable prow[%d] rejected with %g too small\\n&quot,\newline                         i, w);\newline      }\newline    }\newline#endif\newline\newline  }\newline  nzprow[0] = k;\newline  if(xviol != NULL)\newline    *xviol = p;\newline\newline#ifdef UseRelativePivot_Dual\newline/*  epspivot *= sqrt(lp-&gtmatA-&gtdynrange) / lp-&gtmatA-&gtinfnorm; */\newline  epspivot /= MAX(1, sqrt(lp-&gtmatA-&gtrowmax[row_nr]));\newline#endif\newline  current.epspivot   = epspivot;\newline  candidate.epspivot = epspivot;\newline\newline  /* Initialize the long-step structures if indicated */\newline  if(dolongsteps) {\newline    if((nzprow[0] &lt= 1) || (nbound == 0)) {  /* Don&#039t bother */\newline      dolongsteps = FALSE;\newline      lp-&gtlongsteps-&gtindexSet[0] = 0;\newline    }\newline    else {\newline      multi_restart(lp-&gtlongsteps);\newline      multi_valueInit(lp-&gtlongsteps, g*viol, lp-&gtrhs[0]);\newline    }\newline  }\newline\newline  /* Loop over all entering column candidates */\newline  ix = 1;\newline  iy = nzprow[0];\newline  makePriceLoop(lp, &ampix, &ampiy, &ampiz);\newline  iy *= iz;\newline  for(; ix*iz &lt= iy; ix += iz) {\newline    i = nzprow[ix];\newline\newline    /* Compute the dual ratio (prow = w and drow = cbar in Chvatal&#039s &quotnomenclatura&quot) */\newline    w    = prow[i] * g;         /* Change sign if upper bound of the leaving variable is violated   */\newline    quot = -drow[i] / w;        /* Remember this sign-reversal in multi_recompute!                  */\newline\newline    /* Apply the selected pivot strategy (smallest theta) */\newline    candidate.theta = quot;  /* Note that abs() is applied in findSubstitutionVar */\newline    candidate.pivot = w;\newline    candidate.varno = i;\newline\newline    /* Collect candidates for minor iterations/bound flips */\newline    if(dolongsteps) {\newline      if(isbatch &amp&amp (ix == iy))\newline        isbatch = AUTOMATIC;\newline      if(collectMinorVar(&ampcandidate, lp-&gtlongsteps, (MYBOOL) (dolongsteps == AUTOMATIC), isbatch) &amp&amp\newline         lp-&gtspx_trace)\newline        report(lp, DETAILED, &quotcoldual: Long-dual break point with %d bound-flip variables\\n&quot,\newline                             lp-&gtlongsteps-&gtused);\newline      if(lp-&gtspx_status == FATHOMED)\newline        return( 0 );\newline    }\newline\newline    /* We have a candidate for entering the basis; check if it is better than the incumbent */\newline    else if(findSubstitutionVar(&ampcurrent, &ampcandidate, candidatecount))\newline      break;\newline  }\newline\newline  /* Set entering variable and long-step bound swap variables */\newline  if(dolongsteps) {\newline    *candidatecount = lp-&gtlongsteps-&gtused;\newline    i = multi_enteringvar(lp-&gtlongsteps, NULL, 3);\newline  }\newline  else\newline    i = current.varno;\newline\newline  if(lp-&gtspx_trace)\newline    report(lp, NORMAL, &quotcoldual: Entering column %d, reduced cost %g, pivot value %g, bound swaps %d\\n&quot,\newline                       i, drow[i], prow[i], multi_used(lp-&gtlongsteps));\newline\newline  return( i );\newline} /* coldual */\newline","Find the dual simplex entering non-basic variable \newline","4713257","ximasel.cpp","bool CxImage::SelectionClear()\newline{\newline	if (pSelection){\newline		memset(pSelection,0,head.biWidth * head.biHeight);\newline		info.rSelectionBox.left = head.biWidth;\newline		info.rSelectionBox.bottom = head.biHeight;\newline		info.rSelectionBox.right = info.rSelectionBox.top = 0;\newline		return true;\newline	}\newline	return false;\newline}\newline","\newline Empties the selection.\newline \newline","1213526","cdirect.c","static nlopt_result divide_rect(double *rdiv, params *p)\newline{\newline     int i;\newline     const int n = p-&gtn;\newline     const int L = p-&gtL;\newline     double *c = rdiv + 3; /* center of rect to divide */\newline     double *w = c + n; /* widths of rect to divide */\newline     double wmax = w[0];\newline     int imax = 0, nlongest = 0;\newline     rb_node *node;\newline\newline     for (i = 1; i &lt n; ++i)\newline	  if (w[i] &gt wmax)\newline	       wmax = w[imax = i];\newline     for (i = 0; i &lt n; ++i)\newline	  if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL)\newline	       ++nlongest;\newline     if (p-&gtwhich_div == 1 || (p-&gtwhich_div == 0 &amp&amp nlongest == n)) {\newline	  /* trisect all longest sides, in increasing order of the average\newline	     function value along that direction */\newline	  double *fv = p-&gtwork;\newline	  int *isort = p-&gtiwork;\newline	  for (i = 0; i &lt n; ++i) {\newline	       if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL) {\newline		    double csave = c[i];\newline		    c[i] = csave - w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i], c, p, 0);\newline		    c[i] = csave + w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i+1], c, p, 0);\newline		    c[i] = csave;\newline	       }\newline	       else {\newline		    fv[2*i] = fv[2*i+1] = HUGE_VAL;\newline	       }\newline	  }\newline	  sort_fv(n, fv, isort);\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  for (i = 0; i &lt nlongest; ++i) {\newline	       int k;\newline	       w[isort[i]] *= THIRD;\newline	       rdiv[0] = rect_diameter(n, w, p);\newline	       rdiv[2] = p-&gtage++;\newline	       node = rb_tree_resort(&ampp-&gtrtree, node);\newline	       for (k = 0; k &lt= 1; ++k) {\newline		    double *rnew;\newline		    ALLOC_RECT(rnew, L);\newline		    memcpy(rnew, rdiv, sizeof(double) * L);\newline		    rnew[3 + isort[i]] += w[isort[i]] * (2*k-1);\newline		    rnew[1] = fv[2*isort[i]+k];\newline		    rnew[2] = p-&gtage++;\newline		    if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline			 free(rnew);\newline			 return NLOPT_OUT_OF_MEMORY;\newline		    }\newline	       }\newline	  }\newline     }\newline     else {\newline	  int k;\newline	  if (nlongest &gt 1 &amp&amp p-&gtwhich_div == 2) { \newline               /* randomly choose longest side */\newline	       i = nlopt_iurand(nlongest);\newline	       for (k = 0; k &lt n; ++k)\newline		    if (wmax - w[k] &lt= wmax * EQUAL_SIDE_TOL) {\newline			 if (!i) { i = k; break; }\newline			 --i;\newline		    }\newline	  }\newline	  else\newline	       i = imax; /* trisect longest side */\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  w[i] *= THIRD;\newline	  rdiv[0] = rect_diameter(n, w, p);\newline	  rdiv[2] = p-&gtage++;\newline	  node = rb_tree_resort(&ampp-&gtrtree, node);\newline	  for (k = 0; k &lt= 1; ++k) {\newline	       double *rnew;\newline	       ALLOC_RECT(rnew, L);\newline	       memcpy(rnew, rdiv, sizeof(double) * L);\newline	       rnew[3 + i] += w[i] * (2*k-1);\newline	       FUNCTION_EVAL(rnew[1], rnew + 3, p, rnew);\newline	       rnew[2] = p-&gtage++;\newline	       if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline		    free(rnew);\newline		    return NLOPT_OUT_OF_MEMORY;\newline	       }\newline	  }\newline     }\newline     return NLOPT_SUCCESS;\newline}\newline","divide rectangle idiv in the list p-&gtrects \newline","1118681","libfwnt_security_identifier.c","int libfwnt_security_identifier_initialize(\newline     libfwnt_security_identifier_t **security_identifier,\newline     libcerror_error_t **error )\newline{\newline	libfwnt_internal_security_identifier_t *internal_security_identifier = NULL;\newline	static char *function                                                = &quotlibfwnt_security_identifier_initialize&quot;\newline\newline	if( security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid security identifier.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *security_identifier != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid security identifier value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_security_identifier = memory_allocate_structure(\newline	                                libfwnt_internal_security_identifier_t );\newline\newline	if( internal_security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     internal_security_identifier,\newline	     0,\newline	     sizeof( libfwnt_internal_security_identifier_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	*security_identifier = (libfwnt_security_identifier_t *) internal_security_identifier;\newline\newline	return( 1 );\newline\newlineon_error:\newline	if( internal_security_identifier != NULL )\newline	{\newline		memory_free(\newline		 internal_security_identifier );\newline	}\newline	return( -1 );\newline}\newline","Creates a security identifier\newline Make sure the value security_identifier is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","3908740","jsprf.cpp","JS_PUBLIC_API(JSUint32) JS_snprintf(char *out, JSUint32 outlen, const char *fmt, ...)\newline{\newline    va_list ap;\newline    int rv;\newline\newline    JS_ASSERT((JSInt32)outlen &gt 0);\newline    if ((JSInt32)outlen &lt= 0) {\newline        return 0;\newline    }\newline\newline    va_start(ap, fmt);\newline    rv = JS_vsnprintf(out, outlen, fmt, ap);\newline    va_end(ap);\newline    return rv;\newline}\newline","\newline sprintf into a fixed size buffer. Make sure there is a NUL at the end\newline when finished.\newline \newline","3687433","cdrfifo.c","int Cdrfifo_attach_follow_up_fds(struct CdrfifO *o, int source_fd, int dest_fd,\newline                                 int flag)\newline{\newline if(o-&gtfollow_up_fd_counter&gt=Cdrfifo_ffd_maX)\newline   return(0);\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][0]= source_fd;\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][1]= dest_fd;\newline  o-&gtfollow_up_fd_counter++;\newline  return(o-&gtfollow_up_fd_counter);\newline}\newline","Attach a further pair of input and output fd which will use the same\newlinefifo buffer when its predecessors are exhausted. Reading will start as\newlinesoon as reading of the predecessor encounters EOF. Writing will start\newlineas soon as all pending predecessor data are written.\newline@return index number of new item + 1, &lt=0 indicates error\newline \newline","1781824","ocean.c","static void gfs_free_surface_pressure (GfsDomain * toplayer,\newline				       GfsMultilevelParams * par,\newline				       GfsAdvectionParams * apar,\newline				       GfsVariable * p,\newline				       GfsVariable * div,\newline				       GfsVariable * divn,\newline				       GfsVariable * res,\newline				       gdouble G)\newline{\newline  FreeSurfaceParams fp;\newline  GfsVariable * res1;\newline\newline  g_return_if_fail (toplayer != NULL);\newline  g_return_if_fail (par != NULL);\newline  g_return_if_fail (apar != NULL);\newline  g_return_if_fail (p != NULL);\newline  g_return_if_fail (div != NULL);\newline  g_return_if_fail (divn != NULL);\newline  g_return_if_fail (G &gt 0.);\newline\newline  fp.pn = p;\newline  fp.div = div;\newline  fp.dia = gfs_temporary_variable (toplayer);\newline  res1 = res ? res : gfs_temporary_variable (toplayer);\newline  fp.divn = divn;\newline  fp.dt = apar-&gtdt;\newline  fp.G = G;\newline\newline  /* compute MAC divergence */\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,\newline			    (FttCellTraverseFunc) normal_divergence, &ampfp);\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,\newline  			    (FttCellTraverseFunc) scale_divergence_helmoltz, &ampfp);\newline  \newline  /* solve for pressure */\newline  par-&gtdimension = 2;\newline  par-&gtpoisson_solve (toplayer, par, p, fp.div, res1, fp.dia, apar-&gtdt);\newline#if !FTT_2D\newline  gfs_domain_traverse_merged (toplayer, (GfsMergedTraverseFunc) merge_pressures, p);\newline#endif\newline\newline  if (!res)\newline    gts_object_destroy (GTS_OBJECT (res1));\newline  gts_object_destroy (GTS_OBJECT (fp.dia));\newline}\newline","\newline gfs_free_surface_pressure:\newline @toplayer: a #GfsDomain.\newline @par: the multigrid paramaters.\newline @apar: the advection parameters.\newline \newline \newline","888223","tcl_class.c","t_class * tclpd_class_new(const char *name, int flags) {\newline    t_class *c = class_new(gensym(name), (t_newmethod)tclpd_new,\newline        (t_method)tclpd_free, sizeof(t_tcl), flags, A_GIMME, A_NULL);\newline\newline    if(!class_table)\newline        class_table = hashtable_new(1 &lt&lt 7);\newline    if(!class_table_get(name))\newline        class_table_add(name, c);\newline\newline    class_addanything(c, tclpd_anything);\newline\newline    // is this really necessary given that there is already a &#039anything&#039 handler?\newline    class_addmethod(c, (t_method)tclpd_loadbang, gensym(&quotloadbang&quot), A_NULL);\newline    \newline    class_addmethod(c, (t_method)tclpd_open, gensym(&quotmenu-open&quot), A_NULL);\newline\newline    char buf[80];\newline    Tcl_Obj *res;\newline    int res_i;\newline\newline    // use properties function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::properties]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setpropertiesfn(c, tclpd_properties);\newline        }\newline    }\newline\newline    // use save function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::save]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setsavefn(c, tclpd_save);\newline        }\newline    }\newline\newline    return c;\newline}\newline","set up the class that handles loading of tcl classes \newline","3676136","libics_binary.c","Ics_Error IcsSetIdsBlock (Ics_Header* IcsStruct, long offset, int whence)\newline{\newline   ICSINIT;\newline   Ics_BlockRead* br = (Ics_BlockRead*)IcsStruct-&gtBlockRead;\newline\newline   switch (IcsStruct-&gtCompression) {\newline      case IcsCompr_uncompressed:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               if (fseek(br-&gtDataFilePtr, (long)offset, whence) != 0) {\newline                  error = ferror(br-&gtDataFilePtr) ? IcsErr_FReadIds : IcsErr_EndOfStream;\newline               }\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#ifdef ICS_ZLIB\newline      case IcsCompr_gzip:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               error = IcsSetZipBlock (IcsStruct, offset, whence);\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#endif\newline      case IcsCompr_compress:\newline         error = IcsErr_BlockNotAllowed;\newline         break;\newline      default:\newline         error = IcsErr_UnknownCompression;\newline   }\newline\newline   return error;\newline}\newline","\newline Sets the file pointer into the IDS file.\newline \newline","5198035","apc_pool.c","PHP_APCU_API apc_pool* apc_pool_create(apc_pool_type pool_type,\newline                                       apc_malloc_t allocate, \newline                                       apc_free_t deallocate,\newline                                       apc_protect_t protect,\newline                                       apc_unprotect_t unprotect) \newline{\newline    if(pool_type == APC_UNPOOL) {\newline        return apc_unpool_create(pool_type, allocate, deallocate, protect, unprotect);\newline    }\newline\newline    return apc_realpool_create(pool_type, allocate, deallocate, protect,  unprotect);\newline}\newline","{{{ apc_pool_create \newline","2796020","libuna_base64_stream.c","LIBUNA_INLINE \\\newlineint libuna_base64_triplet_copy_from_base64_stream(\newline     uint32_t *base64_triplet,\newline     const uint8_t *base64_stream,\newline     size_t base64_stream_size,\newline     size_t *base64_stream_index,\newline     uint8_t *padding_size,\newline     uint32_t base64_variant,\newline     libcerror_error_t **error )\newline{\newline	static char *function        = &quotlibuna_base64_triplet_copy_from_base64_stream&quot;\newline	size_t base64_character_size = 0;\newline	size_t stream_index          = 0;\newline	uint32_t base64_character    = 0;\newline	uint8_t padding_character    = 0;\newline	uint8_t sixtet1              = 0;\newline	uint8_t sixtet2              = 0;\newline	uint8_t sixtet3              = 0;\newline	uint8_t sixtet4              = 0;\newline\newline	if( base64_triplet == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 triplet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid base64 stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *base64_stream_index &gt= base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: base64 stream string too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( padding_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid padding size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0x0f000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_PADDING_NONE:\newline			padding_character = 0;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_OPTIONAL:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_REQUIRED:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character_size = 1;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			base64_character_size = 2;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			base64_character_size = 4;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	stream_index = *base64_stream_index;\newline\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet1,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 1st sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet2,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 2nd sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*padding_size = 2;\newline\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 3rd base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet3 = 0;\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet3,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 3rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 3rd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 4th base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet4 = 0;\newline		}\newline		else if( *padding_size &gt 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4th base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet4,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 4th base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*base64_triplet   = sixtet1;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet2;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet3;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet4;\newline\newline	*base64_stream_index = stream_index;\newline\newline	return( 1 );\newline}\newline","Copies a base64 triplet from a base64 stream\newline \newline The padding size will still be set to indicate the number of\newline sixtets in the triplet\newline \newline Returns 1 if successful or -1 on error\newline \newline","1851940","concat-deps.c","static void emit_single_boost_header(void)\newline{\newline#define BOOST_TARGET &quot/UnpackedTarball/boost.done&quot\newline    fprintf(stdout, &quot%s&quot BOOST_TARGET &quot &quot, work_dir);\newline}\newline","\newline We collapse tens of internal boost headers to the unpacked target, such\newline that you can re-compile / install boost and all is well.\newline \newline","4938294","xmu.c","int XmuPrintDefaultErrorMessage (Display *dpy, XErrorEvent *event, FILE *fp)\newline{\newline    char buffer[BUFSIZ];\newline    char mesg[BUFSIZ];\newline    char number[32];\newline    char *mtype = &quotXlibMessage&quot;\newline    _XExtension *ext = (_XExtension *)NULL;\newline    XGetErrorText(dpy, event-&gterror_code, buffer, BUFSIZ);\newline    XGetErrorDatabaseText(dpy, mtype, &quotXError&quot, &quotX Error&quot, mesg, BUFSIZ);\newline    fprintf(fp, &quot%s:  %s\\n  &quot, mesg, buffer);\newline    XGetErrorDatabaseText(dpy, mtype, &quotMajorCode&quot, &quotRequest Major code %d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtrequest_code);\newline    if (event-&gtrequest_code &lt 128) {\newline	sprintf(number, &quot%d&quot, event-&gtrequest_code);\newline	XGetErrorDatabaseText(dpy, &quotXRequest&quot, number, &quot&quot, buffer, BUFSIZ);\newline    } else {\newline	/* XXX this is non-portable */\newline	for (ext = dpy-&gtext_procs;\newline	     ext &amp&amp (ext-&gtcodes.major_opcode != event-&gtrequest_code);\newline	     ext = ext-&gtnext)\newline	  ;\newline	if (ext)\newline	    strcpy(buffer, ext-&gtname);\newline	else\newline	    buffer[0] = &#039\\0&#039;\newline    }\newline    fprintf(fp, &quot (%s)&quot, buffer);\newline    fputs(&quot\\n  &quot, fp);\newline#if (XtSpecificationRelease &gt= 5)\newline    if (event-&gtrequest_code &gt= 128) {\newline	XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			      mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtminor_code);\newline	if (ext) {\newline	    sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline	    XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline	    fprintf(fp, &quot (%s)&quot, buffer);\newline	}\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline    if (event-&gterror_code &gt= 128) {\newline	/* let extensions try to print the values */\newline	/* XXX this is non-portable code */\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_values)\newline		(*ext-&gterror_values)(dpy, event, fp);\newline	}\newline	/* the rest is a fallback, providing a simple default */\newline	/* kludge, try to find the extension that caused it */\newline	buffer[0] = &#039\\0&#039;\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_string)\newline		(*ext-&gterror_string)(dpy, event-&gterror_code, &ampext-&gtcodes,\newline				     buffer, BUFSIZ);\newline	    if (buffer[0])\newline		break;\newline	}\newline	if (buffer[0])\newline	    sprintf(buffer, &quot%s.%d&quot, ext-&gtname,\newline		    event-&gterror_code - ext-&gtcodes.first_error);\newline	else\newline	    strcpy(buffer, &quotValue&quot);\newline	XGetErrorDatabaseText(dpy, mtype, buffer, &quot&quot, mesg, BUFSIZ);\newline	if (*mesg) {\newline	    fprintf(fp, mesg, event-&gtresourceid);\newline	    fputs(&quot\\n  &quot, fp);\newline	}\newline    } else if ((event-&gterror_code == BadWindow) ||\newline	       (event-&gterror_code == BadPixmap) ||\newline	       (event-&gterror_code == BadCursor) ||\newline	       (event-&gterror_code == BadFont) ||\newline	       (event-&gterror_code == BadDrawable) ||\newline	       (event-&gterror_code == BadColor) ||\newline	       (event-&gterror_code == BadGC) ||\newline	       (event-&gterror_code == BadIDChoice) ||\newline	       (event-&gterror_code == BadValue) ||\newline	       (event-&gterror_code == BadAtom)) {\newline	if (event-&gterror_code == BadValue)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotValue&quot, &quotValue 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else if (event-&gterror_code == BadAtom)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotAtomID&quot, &quotAtomID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else\newline	    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtresourceid);\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline#elif (XtSpecificationRelease == 4)\newline    XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtminor_code);\newline    fputs(&quot\\n  &quot, fp);\newline    if (ext) {\newline      sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline      XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline      fprintf(fp, &quot (%s)&quot, buffer);\newline    }\newline    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtresourceid);\newline    fputs(&quot\\n  &quot, fp);\newline#else\newlineERROR! Unsupported release of X11\newline#endif\newline    XGetErrorDatabaseText(dpy, mtype, &quotErrorSerial&quot, &quotError Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtserial);\newline    fputs(&quot\\n  &quot, fp);\newline    XGetErrorDatabaseText(dpy, mtype, &quotCurrentSerial&quot, &quotCurrent Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, NextRequest(dpy)-1);\newline    fputs(&quot\\n&quot, fp);\newline    if (event-&gterror_code == BadImplementation) return 0;\newline    return 1;\newline}\newline","\newline XmuPrintDefaultErrorMessage - print a nice error that looks like the usual\newline message. Return 1 if the caller should consider exiting, else 0.\newline \newline","772479","coverity_model.c","void *memccpy(void *dest, const void *src, int c, size_t n)\newline{\newline	const char *s = src;\newline	char *d = dest;\newline\newline	while (n-- &gt 0)\newline		if ((*d++ = *s++) == (char) c)\newline			return d;\newline\newline	return 0;\newline}\newline","simple_memccpy() from glibc \newline","1305953","filter_chain.c","int fc_register_match(const char *name, match_proc_t proc) /* {{{ */\newline{\newline  fc_match_t *m;\newline\newline  DEBUG(&quotfc_register_match (%s);&quot, name);\newline\newline  m = calloc(1, sizeof(*m));\newline  if (m == NULL)\newline    return (-ENOMEM);\newline\newline  sstrncpy(m-&gtname, name, sizeof(m-&gtname));\newline  memcpy(&ampm-&gtproc, &ampproc, sizeof(m-&gtproc));\newline\newline  if (match_list_head == NULL) {\newline    match_list_head = m;\newline  } else {\newline    fc_match_t *ptr;\newline\newline    ptr = match_list_head;\newline    while (ptr-&gtnext != NULL)\newline      ptr = ptr-&gtnext;\newline\newline    ptr-&gtnext = m;\newline  }\newline\newline  return (0);\newline} /* }}} int fc_register_match */\newline","Add a match to list of available matches. \newline","12245","rxstack.c","Client *get_new_client( )\newline{\newline   Client *retval = (Client *)malloc( sizeof( Client ) ) ;\newline\newline   if ( retval == NULL )\newline      return NULL ;\newline   memset( retval, 0, sizeof( Client ) ) ;\newline   retval-&gtsocket = -1 ;\newline   retval-&gtdeadline.milli = -1 ; /* deadline not used --&gt infinite timeout */\newline\newline   retval-&gtnext = clients ;\newline   if ( clients != NULL )\newline      clients-&gtprev = retval ;\newline   clients = retval ;\newline   return retval ;\newline}\newline","Creates a new client and appends it in front of the current clients.\newline Don&#039t forget to set a default_queue and the socket at once.\newline \newline","6007706","dfinscmp.c","static void CloseDefinstancesFiles(\newline  void *theEnv,\newline  FILE *moduleFile,\newline  FILE *definstancesFile,\newline  int maxIndices)\newline  {\newline   int count = maxIndices;\newline   int arrayVersion = 0;\newline\newline   if (definstancesFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,definstancesFile,&ampcount,&amparrayVersion,\newline                                         maxIndices,NULL,NULL);\newline     }\newline\newline   if (moduleFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,moduleFile,&ampcount,&amparrayVersion,maxIndices,NULL,NULL);\newline     }\newline  }\newline","\newlineNAME : CloseDefinstancesFiles\newlineDESCRIPTION : Closes construct compiler files\newlinefor definstances structures\newlineINPUTS : 1) The definstances module file\newline2) The definstances structure file\newline3) The maximum number of indices\newlineallowed in an array\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Files closed\newlineNOTES : None\newline \newline","1085640","pns.c","static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\newline                                   uint8_t sub,\newline                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\newline{\newline#ifndef FIXED_POINT\newline    uint16_t i;\newline    real_t energy = 0.0;\newline\newline    real_t scale = (real_t)1.0/(real_t)size;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\newline        spec[i] = tmp;\newline        energy += tmp*tmp;\newline    }\newline\newline    scale = (real_t)1.0/(real_t)sqrt(energy);\newline    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\newline    for (i = 0; i &lt size; i++)\newline    {\newline        spec[i] *= scale;\newline    }\newline#else\newline    uint16_t i;\newline    real_t energy = 0, scale;\newline    int32_t exp, frac;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        /* this can be replaced by a 16 bit random generator!!!! */\newline        real_t tmp = (int32_t)ne_rng(__r1, __r2);\newline        if (tmp &lt 0)\newline            tmp = -(tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline        else\newline            tmp = (tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline\newline        energy += MUL_R(tmp,tmp);\newline\newline        spec[i] = tmp;\newline    }\newline\newline    energy = fp_sqrt(energy);\newline    if (energy &gt 0)\newline    {\newline        scale = DIV(REAL_CONST(1),energy);\newline\newline        exp = scale_factor &gt&gt 2;\newline        frac = scale_factor &amp 3;\newline\newline        /* IMDCT pre-scaling */\newline        exp -= sub;\newline\newline        if (exp &lt 0)\newline            scale &gt&gt= -exp;\newline        else\newline            scale &lt&lt= exp;\newline\newline        if (frac)\newline            scale = MUL_C(scale, pow2_table[frac]);\newline\newline        for (i = 0; i &lt size; i++)\newline        {\newline            spec[i] = MUL_R(spec[i], scale);\newline        }\newline    }\newline#endif\newline}\newline","The function gen_rand_vector(addr, size) generates a vector of length\newline&ltsize&gt with signed random values of average energy MEAN_NRG per random\newlinevalue. A suitable random number generator can be realized using one\newlinemultiplication/accumulation per random value.\newline \newline","12911","files.c","void find_shared_library(const tsd_t *TSD, const char *inname, const char *inenv, char *retname)\newline{\newline   char *paths;\newline   char outname[REXX_PATH_MAX+1];\newline   char *env_path;\newline\newline   strcpy( retname, inname );\newline   env_path = mygetenv( TSD, inenv, NULL, 0 ); /* fixes bug 595293 */\newline   if ( !env_path )\newline      return;\newline   paths = env_path;\newline   while ( paths &amp&amp *paths )\newline   {\newline      int pathlen;\newline      char *sep;\newline\newline      sep = strchr( paths, PATH_SEPARATOR );\newline      pathlen = sep ? sep-paths : strlen( paths );\newline      strncpy( outname, paths, pathlen );\newline      outname[pathlen] = 0;\newline\newline      if ( ( pathlen &gt 0 ) &amp&amp ( outname[pathlen-1] != FILE_SEPARATOR ) )\newline         strcat( outname, FILE_SEPARATOR_STR );\newline      strcat( outname, inname );\newline      paths = sep ? sep+1 : 0; /* set up for next pass */\newline      if ( access( outname,F_OK ) == 0)\newline      {\newline         strcpy( retname,outname );\newline         break;\newline      }\newline   }\newline   FreeTSD( env_path );\newline   return;\newline}\newline","\newline find_shared_library is used for HP/UX purpose only.\newline It looks for the file inname in the content of the environment variable\newline inenv and puts the result into retname. retname has to have a size of\newline at least REXX_PATH_MAX+1.\newline retname becomes inname if no other file is found.\newline \newline","","","","on","","on","","on","","","","on","","","on","","on","","","on","on","","","","","on","","on","","","","on","","on","on","","","","on","","","","perform http initialization here","set up the class that handles loading of tcl classes","Sets the file pointer into the IDS file.","{}","Copies a base64 triplet from a base64 stream","{}","print a nice error that looks like the usualmessage.","{}","Add a match to list of available matches.","Creates a new client","Closes construct compiler filesfor definstances structures","{}","generates a vector of length<size> with signed random values","looks for the file inname in the content of the environment variable","{}","Empties the selection.","{}","Creates a security identifier","sprintf into a fixed size buffer.","{}","{}"
"372AGES0I453MAUWLNYDJ9FJSLWRX3","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3MH9DQ757WCM30OGQ9YFPHYXCILGUP","A34KOONPP0VOOI","Approved","Wed Apr 17 14:31:28 PDT 2019","Wed Apr 17 14:53:12 PDT 2019","Fri Apr 19 14:53:12 PDT 2019","2019-04-19 21:53:21 UTC","","","1304","100% (1/1)","100% (1/1)","100% (1/1)","4913405","http_client.c","static void _http_init(Slapi_ComponentId *plugin_id)\newline{\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot--&gt _http_init -- BEGIN\\n&quot,0,0,0);\newline	\newline	http_impl_init(plugin_id);\newline\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot&lt-- _http_init -- END\\n&quot,0,0,0);\newline}\newline","\newline perform http initialization here \newline \newline","1807476","regress.c","RegressTestFundamentalObject *\newlineregress_test_value_get_fundamental_object (const GValue * value)\newline{\newline  g_return_val_if_fail (REGRESS_TEST_VALUE_HOLDS_FUNDAMENTAL_OBJECT (value), NULL);\newline\newline  return value-&gtdata[0].v_pointer;\newline}\newline","\newline regress_test_value_get_fundamental_object: (skip)\newline @value:\newline \newline","1003211","lp_price.c","STATIC int coldual(lprec *lp, int row_nr, REAL *prow, int *nzprow,\newline                                          REAL *drow, int *nzdrow,\newline                                          MYBOOL dualphase1, MYBOOL skipupdate,\newline                                          int *candidatecount, REAL *xviol)\newline{\newline  int      i, iy, iz, ix, k, nbound;\newline  LREAL    w, g, quot;\newline  REAL     viol, p, epspivot = lp-&gtepspivot;\newline#ifdef MachinePrecRoundRHS\newline  REAL     epsvalue = lp-&gtepsmachine;\newline#else\newline  REAL     epsvalue = lp-&gtepsvalue;\newline#endif\newline  pricerec current, candidate;\newline  MYBOOL   isbatch = FALSE, /* Requires that lp-&gtlongsteps-&gtsize &gt lp-&gtsum */\newline           dolongsteps = (MYBOOL) (lp-&gtlongsteps != NULL);\newline\newline  /* Initialize */\newline  if(dolongsteps &amp&amp !dualphase1)\newline    dolongsteps = AUTOMATIC;  /* Sets Phase1 = TRUE, Phase2 = AUTOMATIC */\newline  current.theta    = lp-&gtinfinite;\newline  current.pivot    = 0;\newline  current.varno    = 0;\newline  current.epspivot = epspivot;\newline  current.isdual   = TRUE;\newline  current.lp       = lp;\newline  candidate.epspivot = epspivot;\newline  candidate.isdual = TRUE;\newline  candidate.lp     = lp;\newline  *candidatecount  = 0;\newline\newline  /* Compute reduced costs */\newline  if(!skipupdate) {\newline#ifdef UseDualReducedCostUpdate\newline    /* Recompute from scratch only at the beginning, otherwise update */\newline    if((lp-&gtcurrent_iter &gt 0) &amp&amp (refactRecent(lp) &lt AUTOMATIC))\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               NULL, NULL,\newline                               MAT_ROUNDDEFAULT);\newline    else\newline#endif\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               drow, nzdrow,\newline                               MAT_ROUNDDEFAULT);\newline  }\newline\newline#if 0\newline  /* Override all above to do in-line testing with fixed test set */\newline  if(lp-&gtrows &gt 1 &amp&amp lp-&gtcolumns &gt 10)\newline    longdual_testset(lp, 10, row_nr, prow, nzprow, drow, nzdrow);\newline#endif\newline\newline  /* Compute the current violation of the bounds of the outgoing variable,\newline     negative for violation of lower bound, positive for upper bound violation.\newline     (Basic variables are always lower-bounded, by lp_solve convention) */\newline  g = 1;\newline  viol = lp-&gtrhs[row_nr];\newline  if(viol &gt 0) {   /* Check if the leaving variable is &gt= its upper bound */\newline    p = lp-&gtupbo[lp-&gtvar_basic[row_nr]];\newline    if(p &lt lp-&gtinfinite) {\newline      viol -= p;\newline      my_roundzero(viol, epsvalue);\newline      if(viol &gt 0)\newline        g = -1;\newline    }\newline    /* Do validation of numerics */\newline    if(g == 1) {\newline      if(viol &gt= lp-&gtinfinite) {\newline        report(lp, IMPORTANT, &quotcoldual: Large basic solution value %g at iter %.0f indicates numerical instability\\n&quot,\newline                               lp-&gtrhs[row_nr], (double) get_total_iter(lp));\newline        lp-&gtspx_status = NUMFAILURE;\newline        return( 0 );\newline\newline      }\newline      if(skipupdate)\newline        report(lp, DETAILED, &quotcoldual: Inaccurate bound-flip accuracy at iter %.0f\\n&quot,\newline                              (double) get_total_iter(lp));\newline      else\newline        report(lp, SEVERE,   &quotcoldual: Leaving variable %d does not violate bounds at iter %.0f\\n&quot,\newline                              row_nr, (double) get_total_iter(lp));\newline      return( -1 );\newline    }\newline  }\newline\newline  /* Update local value of pivot setting */\newline  lp-&gt_piv_rule_ = get_piv_rule(lp);\newline\newline  /* Condense list of relevant targets */\newline  p = 0;\newline  k = 0;\newline  nbound = 0;\newline  ix = 1;\newline  iy = nzprow[0];\newline  for(ix = 1; ix &lt= iy; ix++) {\newline    i = nzprow[ix];\newline    w = prow[i] * g;            /* Change sign if upper bound of the leaving variable is violated   */\newline    w *= 2*lp-&gtis_lower[i] - 1; /* Change sign if the non-basic variable is currently upper-bounded */\newline\newline    /* Check if the candidate is worth using for anything */\newline    if(w &lt -epsvalue) {\newline      /* Tally bounded variables */\newline      if(lp-&gtupbo[i] &lt lp-&gtinfinite)\newline        nbound++;\newline\newline      /* Update the nz-index */\newline      k++;\newline      nzprow[k] = i;\newline      SETMAX(p, -w);\newline    }\newline#ifdef Paranoia\newline    else {\newline      if(lp-&gtspx_trace) {\newline        report(lp, FULL, &quotcoldual: Candidate variable prow[%d] rejected with %g too small\\n&quot,\newline                         i, w);\newline      }\newline    }\newline#endif\newline\newline  }\newline  nzprow[0] = k;\newline  if(xviol != NULL)\newline    *xviol = p;\newline\newline#ifdef UseRelativePivot_Dual\newline/*  epspivot *= sqrt(lp-&gtmatA-&gtdynrange) / lp-&gtmatA-&gtinfnorm; */\newline  epspivot /= MAX(1, sqrt(lp-&gtmatA-&gtrowmax[row_nr]));\newline#endif\newline  current.epspivot   = epspivot;\newline  candidate.epspivot = epspivot;\newline\newline  /* Initialize the long-step structures if indicated */\newline  if(dolongsteps) {\newline    if((nzprow[0] &lt= 1) || (nbound == 0)) {  /* Don&#039t bother */\newline      dolongsteps = FALSE;\newline      lp-&gtlongsteps-&gtindexSet[0] = 0;\newline    }\newline    else {\newline      multi_restart(lp-&gtlongsteps);\newline      multi_valueInit(lp-&gtlongsteps, g*viol, lp-&gtrhs[0]);\newline    }\newline  }\newline\newline  /* Loop over all entering column candidates */\newline  ix = 1;\newline  iy = nzprow[0];\newline  makePriceLoop(lp, &ampix, &ampiy, &ampiz);\newline  iy *= iz;\newline  for(; ix*iz &lt= iy; ix += iz) {\newline    i = nzprow[ix];\newline\newline    /* Compute the dual ratio (prow = w and drow = cbar in Chvatal&#039s &quotnomenclatura&quot) */\newline    w    = prow[i] * g;         /* Change sign if upper bound of the leaving variable is violated   */\newline    quot = -drow[i] / w;        /* Remember this sign-reversal in multi_recompute!                  */\newline\newline    /* Apply the selected pivot strategy (smallest theta) */\newline    candidate.theta = quot;  /* Note that abs() is applied in findSubstitutionVar */\newline    candidate.pivot = w;\newline    candidate.varno = i;\newline\newline    /* Collect candidates for minor iterations/bound flips */\newline    if(dolongsteps) {\newline      if(isbatch &amp&amp (ix == iy))\newline        isbatch = AUTOMATIC;\newline      if(collectMinorVar(&ampcandidate, lp-&gtlongsteps, (MYBOOL) (dolongsteps == AUTOMATIC), isbatch) &amp&amp\newline         lp-&gtspx_trace)\newline        report(lp, DETAILED, &quotcoldual: Long-dual break point with %d bound-flip variables\\n&quot,\newline                             lp-&gtlongsteps-&gtused);\newline      if(lp-&gtspx_status == FATHOMED)\newline        return( 0 );\newline    }\newline\newline    /* We have a candidate for entering the basis; check if it is better than the incumbent */\newline    else if(findSubstitutionVar(&ampcurrent, &ampcandidate, candidatecount))\newline      break;\newline  }\newline\newline  /* Set entering variable and long-step bound swap variables */\newline  if(dolongsteps) {\newline    *candidatecount = lp-&gtlongsteps-&gtused;\newline    i = multi_enteringvar(lp-&gtlongsteps, NULL, 3);\newline  }\newline  else\newline    i = current.varno;\newline\newline  if(lp-&gtspx_trace)\newline    report(lp, NORMAL, &quotcoldual: Entering column %d, reduced cost %g, pivot value %g, bound swaps %d\\n&quot,\newline                       i, drow[i], prow[i], multi_used(lp-&gtlongsteps));\newline\newline  return( i );\newline} /* coldual */\newline","Find the dual simplex entering non-basic variable \newline","4713257","ximasel.cpp","bool CxImage::SelectionClear()\newline{\newline	if (pSelection){\newline		memset(pSelection,0,head.biWidth * head.biHeight);\newline		info.rSelectionBox.left = head.biWidth;\newline		info.rSelectionBox.bottom = head.biHeight;\newline		info.rSelectionBox.right = info.rSelectionBox.top = 0;\newline		return true;\newline	}\newline	return false;\newline}\newline","\newline Empties the selection.\newline \newline","1213526","cdirect.c","static nlopt_result divide_rect(double *rdiv, params *p)\newline{\newline     int i;\newline     const int n = p-&gtn;\newline     const int L = p-&gtL;\newline     double *c = rdiv + 3; /* center of rect to divide */\newline     double *w = c + n; /* widths of rect to divide */\newline     double wmax = w[0];\newline     int imax = 0, nlongest = 0;\newline     rb_node *node;\newline\newline     for (i = 1; i &lt n; ++i)\newline	  if (w[i] &gt wmax)\newline	       wmax = w[imax = i];\newline     for (i = 0; i &lt n; ++i)\newline	  if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL)\newline	       ++nlongest;\newline     if (p-&gtwhich_div == 1 || (p-&gtwhich_div == 0 &amp&amp nlongest == n)) {\newline	  /* trisect all longest sides, in increasing order of the average\newline	     function value along that direction */\newline	  double *fv = p-&gtwork;\newline	  int *isort = p-&gtiwork;\newline	  for (i = 0; i &lt n; ++i) {\newline	       if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL) {\newline		    double csave = c[i];\newline		    c[i] = csave - w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i], c, p, 0);\newline		    c[i] = csave + w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i+1], c, p, 0);\newline		    c[i] = csave;\newline	       }\newline	       else {\newline		    fv[2*i] = fv[2*i+1] = HUGE_VAL;\newline	       }\newline	  }\newline	  sort_fv(n, fv, isort);\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  for (i = 0; i &lt nlongest; ++i) {\newline	       int k;\newline	       w[isort[i]] *= THIRD;\newline	       rdiv[0] = rect_diameter(n, w, p);\newline	       rdiv[2] = p-&gtage++;\newline	       node = rb_tree_resort(&ampp-&gtrtree, node);\newline	       for (k = 0; k &lt= 1; ++k) {\newline		    double *rnew;\newline		    ALLOC_RECT(rnew, L);\newline		    memcpy(rnew, rdiv, sizeof(double) * L);\newline		    rnew[3 + isort[i]] += w[isort[i]] * (2*k-1);\newline		    rnew[1] = fv[2*isort[i]+k];\newline		    rnew[2] = p-&gtage++;\newline		    if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline			 free(rnew);\newline			 return NLOPT_OUT_OF_MEMORY;\newline		    }\newline	       }\newline	  }\newline     }\newline     else {\newline	  int k;\newline	  if (nlongest &gt 1 &amp&amp p-&gtwhich_div == 2) { \newline               /* randomly choose longest side */\newline	       i = nlopt_iurand(nlongest);\newline	       for (k = 0; k &lt n; ++k)\newline		    if (wmax - w[k] &lt= wmax * EQUAL_SIDE_TOL) {\newline			 if (!i) { i = k; break; }\newline			 --i;\newline		    }\newline	  }\newline	  else\newline	       i = imax; /* trisect longest side */\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  w[i] *= THIRD;\newline	  rdiv[0] = rect_diameter(n, w, p);\newline	  rdiv[2] = p-&gtage++;\newline	  node = rb_tree_resort(&ampp-&gtrtree, node);\newline	  for (k = 0; k &lt= 1; ++k) {\newline	       double *rnew;\newline	       ALLOC_RECT(rnew, L);\newline	       memcpy(rnew, rdiv, sizeof(double) * L);\newline	       rnew[3 + i] += w[i] * (2*k-1);\newline	       FUNCTION_EVAL(rnew[1], rnew + 3, p, rnew);\newline	       rnew[2] = p-&gtage++;\newline	       if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline		    free(rnew);\newline		    return NLOPT_OUT_OF_MEMORY;\newline	       }\newline	  }\newline     }\newline     return NLOPT_SUCCESS;\newline}\newline","divide rectangle idiv in the list p-&gtrects \newline","1118681","libfwnt_security_identifier.c","int libfwnt_security_identifier_initialize(\newline     libfwnt_security_identifier_t **security_identifier,\newline     libcerror_error_t **error )\newline{\newline	libfwnt_internal_security_identifier_t *internal_security_identifier = NULL;\newline	static char *function                                                = &quotlibfwnt_security_identifier_initialize&quot;\newline\newline	if( security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid security identifier.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *security_identifier != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid security identifier value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_security_identifier = memory_allocate_structure(\newline	                                libfwnt_internal_security_identifier_t );\newline\newline	if( internal_security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     internal_security_identifier,\newline	     0,\newline	     sizeof( libfwnt_internal_security_identifier_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	*security_identifier = (libfwnt_security_identifier_t *) internal_security_identifier;\newline\newline	return( 1 );\newline\newlineon_error:\newline	if( internal_security_identifier != NULL )\newline	{\newline		memory_free(\newline		 internal_security_identifier );\newline	}\newline	return( -1 );\newline}\newline","Creates a security identifier\newline Make sure the value security_identifier is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","3908740","jsprf.cpp","JS_PUBLIC_API(JSUint32) JS_snprintf(char *out, JSUint32 outlen, const char *fmt, ...)\newline{\newline    va_list ap;\newline    int rv;\newline\newline    JS_ASSERT((JSInt32)outlen &gt 0);\newline    if ((JSInt32)outlen &lt= 0) {\newline        return 0;\newline    }\newline\newline    va_start(ap, fmt);\newline    rv = JS_vsnprintf(out, outlen, fmt, ap);\newline    va_end(ap);\newline    return rv;\newline}\newline","\newline sprintf into a fixed size buffer. Make sure there is a NUL at the end\newline when finished.\newline \newline","3687433","cdrfifo.c","int Cdrfifo_attach_follow_up_fds(struct CdrfifO *o, int source_fd, int dest_fd,\newline                                 int flag)\newline{\newline if(o-&gtfollow_up_fd_counter&gt=Cdrfifo_ffd_maX)\newline   return(0);\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][0]= source_fd;\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][1]= dest_fd;\newline  o-&gtfollow_up_fd_counter++;\newline  return(o-&gtfollow_up_fd_counter);\newline}\newline","Attach a further pair of input and output fd which will use the same\newlinefifo buffer when its predecessors are exhausted. Reading will start as\newlinesoon as reading of the predecessor encounters EOF. Writing will start\newlineas soon as all pending predecessor data are written.\newline@return index number of new item + 1, &lt=0 indicates error\newline \newline","1781824","ocean.c","static void gfs_free_surface_pressure (GfsDomain * toplayer,\newline				       GfsMultilevelParams * par,\newline				       GfsAdvectionParams * apar,\newline				       GfsVariable * p,\newline				       GfsVariable * div,\newline				       GfsVariable * divn,\newline				       GfsVariable * res,\newline				       gdouble G)\newline{\newline  FreeSurfaceParams fp;\newline  GfsVariable * res1;\newline\newline  g_return_if_fail (toplayer != NULL);\newline  g_return_if_fail (par != NULL);\newline  g_return_if_fail (apar != NULL);\newline  g_return_if_fail (p != NULL);\newline  g_return_if_fail (div != NULL);\newline  g_return_if_fail (divn != NULL);\newline  g_return_if_fail (G &gt 0.);\newline\newline  fp.pn = p;\newline  fp.div = div;\newline  fp.dia = gfs_temporary_variable (toplayer);\newline  res1 = res ? res : gfs_temporary_variable (toplayer);\newline  fp.divn = divn;\newline  fp.dt = apar-&gtdt;\newline  fp.G = G;\newline\newline  /* compute MAC divergence */\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,\newline			    (FttCellTraverseFunc) normal_divergence, &ampfp);\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,\newline  			    (FttCellTraverseFunc) scale_divergence_helmoltz, &ampfp);\newline  \newline  /* solve for pressure */\newline  par-&gtdimension = 2;\newline  par-&gtpoisson_solve (toplayer, par, p, fp.div, res1, fp.dia, apar-&gtdt);\newline#if !FTT_2D\newline  gfs_domain_traverse_merged (toplayer, (GfsMergedTraverseFunc) merge_pressures, p);\newline#endif\newline\newline  if (!res)\newline    gts_object_destroy (GTS_OBJECT (res1));\newline  gts_object_destroy (GTS_OBJECT (fp.dia));\newline}\newline","\newline gfs_free_surface_pressure:\newline @toplayer: a #GfsDomain.\newline @par: the multigrid paramaters.\newline @apar: the advection parameters.\newline \newline \newline","888223","tcl_class.c","t_class * tclpd_class_new(const char *name, int flags) {\newline    t_class *c = class_new(gensym(name), (t_newmethod)tclpd_new,\newline        (t_method)tclpd_free, sizeof(t_tcl), flags, A_GIMME, A_NULL);\newline\newline    if(!class_table)\newline        class_table = hashtable_new(1 &lt&lt 7);\newline    if(!class_table_get(name))\newline        class_table_add(name, c);\newline\newline    class_addanything(c, tclpd_anything);\newline\newline    // is this really necessary given that there is already a &#039anything&#039 handler?\newline    class_addmethod(c, (t_method)tclpd_loadbang, gensym(&quotloadbang&quot), A_NULL);\newline    \newline    class_addmethod(c, (t_method)tclpd_open, gensym(&quotmenu-open&quot), A_NULL);\newline\newline    char buf[80];\newline    Tcl_Obj *res;\newline    int res_i;\newline\newline    // use properties function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::properties]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setpropertiesfn(c, tclpd_properties);\newline        }\newline    }\newline\newline    // use save function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::save]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setsavefn(c, tclpd_save);\newline        }\newline    }\newline\newline    return c;\newline}\newline","set up the class that handles loading of tcl classes \newline","3676136","libics_binary.c","Ics_Error IcsSetIdsBlock (Ics_Header* IcsStruct, long offset, int whence)\newline{\newline   ICSINIT;\newline   Ics_BlockRead* br = (Ics_BlockRead*)IcsStruct-&gtBlockRead;\newline\newline   switch (IcsStruct-&gtCompression) {\newline      case IcsCompr_uncompressed:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               if (fseek(br-&gtDataFilePtr, (long)offset, whence) != 0) {\newline                  error = ferror(br-&gtDataFilePtr) ? IcsErr_FReadIds : IcsErr_EndOfStream;\newline               }\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#ifdef ICS_ZLIB\newline      case IcsCompr_gzip:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               error = IcsSetZipBlock (IcsStruct, offset, whence);\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#endif\newline      case IcsCompr_compress:\newline         error = IcsErr_BlockNotAllowed;\newline         break;\newline      default:\newline         error = IcsErr_UnknownCompression;\newline   }\newline\newline   return error;\newline}\newline","\newline Sets the file pointer into the IDS file.\newline \newline","5198035","apc_pool.c","PHP_APCU_API apc_pool* apc_pool_create(apc_pool_type pool_type,\newline                                       apc_malloc_t allocate, \newline                                       apc_free_t deallocate,\newline                                       apc_protect_t protect,\newline                                       apc_unprotect_t unprotect) \newline{\newline    if(pool_type == APC_UNPOOL) {\newline        return apc_unpool_create(pool_type, allocate, deallocate, protect, unprotect);\newline    }\newline\newline    return apc_realpool_create(pool_type, allocate, deallocate, protect,  unprotect);\newline}\newline","{{{ apc_pool_create \newline","2796020","libuna_base64_stream.c","LIBUNA_INLINE \\\newlineint libuna_base64_triplet_copy_from_base64_stream(\newline     uint32_t *base64_triplet,\newline     const uint8_t *base64_stream,\newline     size_t base64_stream_size,\newline     size_t *base64_stream_index,\newline     uint8_t *padding_size,\newline     uint32_t base64_variant,\newline     libcerror_error_t **error )\newline{\newline	static char *function        = &quotlibuna_base64_triplet_copy_from_base64_stream&quot;\newline	size_t base64_character_size = 0;\newline	size_t stream_index          = 0;\newline	uint32_t base64_character    = 0;\newline	uint8_t padding_character    = 0;\newline	uint8_t sixtet1              = 0;\newline	uint8_t sixtet2              = 0;\newline	uint8_t sixtet3              = 0;\newline	uint8_t sixtet4              = 0;\newline\newline	if( base64_triplet == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 triplet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid base64 stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *base64_stream_index &gt= base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: base64 stream string too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( padding_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid padding size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0x0f000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_PADDING_NONE:\newline			padding_character = 0;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_OPTIONAL:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_REQUIRED:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character_size = 1;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			base64_character_size = 2;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			base64_character_size = 4;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	stream_index = *base64_stream_index;\newline\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet1,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 1st sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet2,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 2nd sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*padding_size = 2;\newline\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 3rd base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet3 = 0;\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet3,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 3rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 3rd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 4th base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet4 = 0;\newline		}\newline		else if( *padding_size &gt 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4th base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet4,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 4th base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*base64_triplet   = sixtet1;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet2;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet3;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet4;\newline\newline	*base64_stream_index = stream_index;\newline\newline	return( 1 );\newline}\newline","Copies a base64 triplet from a base64 stream\newline \newline The padding size will still be set to indicate the number of\newline sixtets in the triplet\newline \newline Returns 1 if successful or -1 on error\newline \newline","1851940","concat-deps.c","static void emit_single_boost_header(void)\newline{\newline#define BOOST_TARGET &quot/UnpackedTarball/boost.done&quot\newline    fprintf(stdout, &quot%s&quot BOOST_TARGET &quot &quot, work_dir);\newline}\newline","\newline We collapse tens of internal boost headers to the unpacked target, such\newline that you can re-compile / install boost and all is well.\newline \newline","4938294","xmu.c","int XmuPrintDefaultErrorMessage (Display *dpy, XErrorEvent *event, FILE *fp)\newline{\newline    char buffer[BUFSIZ];\newline    char mesg[BUFSIZ];\newline    char number[32];\newline    char *mtype = &quotXlibMessage&quot;\newline    _XExtension *ext = (_XExtension *)NULL;\newline    XGetErrorText(dpy, event-&gterror_code, buffer, BUFSIZ);\newline    XGetErrorDatabaseText(dpy, mtype, &quotXError&quot, &quotX Error&quot, mesg, BUFSIZ);\newline    fprintf(fp, &quot%s:  %s\\n  &quot, mesg, buffer);\newline    XGetErrorDatabaseText(dpy, mtype, &quotMajorCode&quot, &quotRequest Major code %d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtrequest_code);\newline    if (event-&gtrequest_code &lt 128) {\newline	sprintf(number, &quot%d&quot, event-&gtrequest_code);\newline	XGetErrorDatabaseText(dpy, &quotXRequest&quot, number, &quot&quot, buffer, BUFSIZ);\newline    } else {\newline	/* XXX this is non-portable */\newline	for (ext = dpy-&gtext_procs;\newline	     ext &amp&amp (ext-&gtcodes.major_opcode != event-&gtrequest_code);\newline	     ext = ext-&gtnext)\newline	  ;\newline	if (ext)\newline	    strcpy(buffer, ext-&gtname);\newline	else\newline	    buffer[0] = &#039\\0&#039;\newline    }\newline    fprintf(fp, &quot (%s)&quot, buffer);\newline    fputs(&quot\\n  &quot, fp);\newline#if (XtSpecificationRelease &gt= 5)\newline    if (event-&gtrequest_code &gt= 128) {\newline	XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			      mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtminor_code);\newline	if (ext) {\newline	    sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline	    XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline	    fprintf(fp, &quot (%s)&quot, buffer);\newline	}\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline    if (event-&gterror_code &gt= 128) {\newline	/* let extensions try to print the values */\newline	/* XXX this is non-portable code */\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_values)\newline		(*ext-&gterror_values)(dpy, event, fp);\newline	}\newline	/* the rest is a fallback, providing a simple default */\newline	/* kludge, try to find the extension that caused it */\newline	buffer[0] = &#039\\0&#039;\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_string)\newline		(*ext-&gterror_string)(dpy, event-&gterror_code, &ampext-&gtcodes,\newline				     buffer, BUFSIZ);\newline	    if (buffer[0])\newline		break;\newline	}\newline	if (buffer[0])\newline	    sprintf(buffer, &quot%s.%d&quot, ext-&gtname,\newline		    event-&gterror_code - ext-&gtcodes.first_error);\newline	else\newline	    strcpy(buffer, &quotValue&quot);\newline	XGetErrorDatabaseText(dpy, mtype, buffer, &quot&quot, mesg, BUFSIZ);\newline	if (*mesg) {\newline	    fprintf(fp, mesg, event-&gtresourceid);\newline	    fputs(&quot\\n  &quot, fp);\newline	}\newline    } else if ((event-&gterror_code == BadWindow) ||\newline	       (event-&gterror_code == BadPixmap) ||\newline	       (event-&gterror_code == BadCursor) ||\newline	       (event-&gterror_code == BadFont) ||\newline	       (event-&gterror_code == BadDrawable) ||\newline	       (event-&gterror_code == BadColor) ||\newline	       (event-&gterror_code == BadGC) ||\newline	       (event-&gterror_code == BadIDChoice) ||\newline	       (event-&gterror_code == BadValue) ||\newline	       (event-&gterror_code == BadAtom)) {\newline	if (event-&gterror_code == BadValue)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotValue&quot, &quotValue 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else if (event-&gterror_code == BadAtom)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotAtomID&quot, &quotAtomID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else\newline	    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtresourceid);\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline#elif (XtSpecificationRelease == 4)\newline    XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtminor_code);\newline    fputs(&quot\\n  &quot, fp);\newline    if (ext) {\newline      sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline      XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline      fprintf(fp, &quot (%s)&quot, buffer);\newline    }\newline    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtresourceid);\newline    fputs(&quot\\n  &quot, fp);\newline#else\newlineERROR! Unsupported release of X11\newline#endif\newline    XGetErrorDatabaseText(dpy, mtype, &quotErrorSerial&quot, &quotError Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtserial);\newline    fputs(&quot\\n  &quot, fp);\newline    XGetErrorDatabaseText(dpy, mtype, &quotCurrentSerial&quot, &quotCurrent Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, NextRequest(dpy)-1);\newline    fputs(&quot\\n&quot, fp);\newline    if (event-&gterror_code == BadImplementation) return 0;\newline    return 1;\newline}\newline","\newline XmuPrintDefaultErrorMessage - print a nice error that looks like the usual\newline message. Return 1 if the caller should consider exiting, else 0.\newline \newline","772479","coverity_model.c","void *memccpy(void *dest, const void *src, int c, size_t n)\newline{\newline	const char *s = src;\newline	char *d = dest;\newline\newline	while (n-- &gt 0)\newline		if ((*d++ = *s++) == (char) c)\newline			return d;\newline\newline	return 0;\newline}\newline","simple_memccpy() from glibc \newline","1305953","filter_chain.c","int fc_register_match(const char *name, match_proc_t proc) /* {{{ */\newline{\newline  fc_match_t *m;\newline\newline  DEBUG(&quotfc_register_match (%s);&quot, name);\newline\newline  m = calloc(1, sizeof(*m));\newline  if (m == NULL)\newline    return (-ENOMEM);\newline\newline  sstrncpy(m-&gtname, name, sizeof(m-&gtname));\newline  memcpy(&ampm-&gtproc, &ampproc, sizeof(m-&gtproc));\newline\newline  if (match_list_head == NULL) {\newline    match_list_head = m;\newline  } else {\newline    fc_match_t *ptr;\newline\newline    ptr = match_list_head;\newline    while (ptr-&gtnext != NULL)\newline      ptr = ptr-&gtnext;\newline\newline    ptr-&gtnext = m;\newline  }\newline\newline  return (0);\newline} /* }}} int fc_register_match */\newline","Add a match to list of available matches. \newline","12245","rxstack.c","Client *get_new_client( )\newline{\newline   Client *retval = (Client *)malloc( sizeof( Client ) ) ;\newline\newline   if ( retval == NULL )\newline      return NULL ;\newline   memset( retval, 0, sizeof( Client ) ) ;\newline   retval-&gtsocket = -1 ;\newline   retval-&gtdeadline.milli = -1 ; /* deadline not used --&gt infinite timeout */\newline\newline   retval-&gtnext = clients ;\newline   if ( clients != NULL )\newline      clients-&gtprev = retval ;\newline   clients = retval ;\newline   return retval ;\newline}\newline","Creates a new client and appends it in front of the current clients.\newline Don&#039t forget to set a default_queue and the socket at once.\newline \newline","6007706","dfinscmp.c","static void CloseDefinstancesFiles(\newline  void *theEnv,\newline  FILE *moduleFile,\newline  FILE *definstancesFile,\newline  int maxIndices)\newline  {\newline   int count = maxIndices;\newline   int arrayVersion = 0;\newline\newline   if (definstancesFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,definstancesFile,&ampcount,&amparrayVersion,\newline                                         maxIndices,NULL,NULL);\newline     }\newline\newline   if (moduleFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,moduleFile,&ampcount,&amparrayVersion,maxIndices,NULL,NULL);\newline     }\newline  }\newline","\newlineNAME : CloseDefinstancesFiles\newlineDESCRIPTION : Closes construct compiler files\newlinefor definstances structures\newlineINPUTS : 1) The definstances module file\newline2) The definstances structure file\newline3) The maximum number of indices\newlineallowed in an array\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Files closed\newlineNOTES : None\newline \newline","1085640","pns.c","static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\newline                                   uint8_t sub,\newline                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\newline{\newline#ifndef FIXED_POINT\newline    uint16_t i;\newline    real_t energy = 0.0;\newline\newline    real_t scale = (real_t)1.0/(real_t)size;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\newline        spec[i] = tmp;\newline        energy += tmp*tmp;\newline    }\newline\newline    scale = (real_t)1.0/(real_t)sqrt(energy);\newline    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\newline    for (i = 0; i &lt size; i++)\newline    {\newline        spec[i] *= scale;\newline    }\newline#else\newline    uint16_t i;\newline    real_t energy = 0, scale;\newline    int32_t exp, frac;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        /* this can be replaced by a 16 bit random generator!!!! */\newline        real_t tmp = (int32_t)ne_rng(__r1, __r2);\newline        if (tmp &lt 0)\newline            tmp = -(tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline        else\newline            tmp = (tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline\newline        energy += MUL_R(tmp,tmp);\newline\newline        spec[i] = tmp;\newline    }\newline\newline    energy = fp_sqrt(energy);\newline    if (energy &gt 0)\newline    {\newline        scale = DIV(REAL_CONST(1),energy);\newline\newline        exp = scale_factor &gt&gt 2;\newline        frac = scale_factor &amp 3;\newline\newline        /* IMDCT pre-scaling */\newline        exp -= sub;\newline\newline        if (exp &lt 0)\newline            scale &gt&gt= -exp;\newline        else\newline            scale &lt&lt= exp;\newline\newline        if (frac)\newline            scale = MUL_C(scale, pow2_table[frac]);\newline\newline        for (i = 0; i &lt size; i++)\newline        {\newline            spec[i] = MUL_R(spec[i], scale);\newline        }\newline    }\newline#endif\newline}\newline","The function gen_rand_vector(addr, size) generates a vector of length\newline&ltsize&gt with signed random values of average energy MEAN_NRG per random\newlinevalue. A suitable random number generator can be realized using one\newlinemultiplication/accumulation per random value.\newline \newline","12911","files.c","void find_shared_library(const tsd_t *TSD, const char *inname, const char *inenv, char *retname)\newline{\newline   char *paths;\newline   char outname[REXX_PATH_MAX+1];\newline   char *env_path;\newline\newline   strcpy( retname, inname );\newline   env_path = mygetenv( TSD, inenv, NULL, 0 ); /* fixes bug 595293 */\newline   if ( !env_path )\newline      return;\newline   paths = env_path;\newline   while ( paths &amp&amp *paths )\newline   {\newline      int pathlen;\newline      char *sep;\newline\newline      sep = strchr( paths, PATH_SEPARATOR );\newline      pathlen = sep ? sep-paths : strlen( paths );\newline      strncpy( outname, paths, pathlen );\newline      outname[pathlen] = 0;\newline\newline      if ( ( pathlen &gt 0 ) &amp&amp ( outname[pathlen-1] != FILE_SEPARATOR ) )\newline         strcat( outname, FILE_SEPARATOR_STR );\newline      strcat( outname, inname );\newline      paths = sep ? sep+1 : 0; /* set up for next pass */\newline      if ( access( outname,F_OK ) == 0)\newline      {\newline         strcpy( retname,outname );\newline         break;\newline      }\newline   }\newline   FreeTSD( env_path );\newline   return;\newline}\newline","\newline find_shared_library is used for HP/UX purpose only.\newline It looks for the file inname in the content of the environment variable\newline inenv and puts the result into retname. retname has to have a size of\newline at least REXX_PATH_MAX+1.\newline retname becomes inname if no other file is found.\newline \newline","","","","on","","","","on","","","","on","","","on","","","","","","on","","","","","","","","","","on","","","on","on","","","","","","on","","perform http initialization","set up the class that handles loading of tcl classes","Sets the file pointer into the IDS file.","{}","Copies a base64 triplet from a base64 stream","install boost","print a nice error that looks like the usualmessage.","{}","Add a match to list of available matches.","Creates a new client and appends it in front of the current","Closes construct compiler filesfor definstances structures","{}","generates a vector of length<size> with signed random values of average","looks for the file inname in the content of the environment variable","{}","Empties the selection.","divide rectangle idiv in the list","Creates a security identifier","sprintf into a fixed size buffer.","Attach a further pair of input and output fd which will use","{}"
"372AGES0I453MAUWLNYDJ9FJSLWRX3","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3R08VXYT7CVG2B2KS69M1S61YW57W6","A3SYA8EDAEOOF7","Approved","Wed Apr 17 16:22:10 PDT 2019","Wed Apr 17 16:26:05 PDT 2019","Fri Apr 19 16:26:05 PDT 2019","2019-04-19 23:26:21 UTC","","","235","100% (17/17)","100% (17/17)","100% (17/17)","4913405","http_client.c","static void _http_init(Slapi_ComponentId *plugin_id)\newline{\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot--&gt _http_init -- BEGIN\\n&quot,0,0,0);\newline	\newline	http_impl_init(plugin_id);\newline\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot&lt-- _http_init -- END\\n&quot,0,0,0);\newline}\newline","\newline perform http initialization here \newline \newline","1807476","regress.c","RegressTestFundamentalObject *\newlineregress_test_value_get_fundamental_object (const GValue * value)\newline{\newline  g_return_val_if_fail (REGRESS_TEST_VALUE_HOLDS_FUNDAMENTAL_OBJECT (value), NULL);\newline\newline  return value-&gtdata[0].v_pointer;\newline}\newline","\newline regress_test_value_get_fundamental_object: (skip)\newline @value:\newline \newline","1003211","lp_price.c","STATIC int coldual(lprec *lp, int row_nr, REAL *prow, int *nzprow,\newline                                          REAL *drow, int *nzdrow,\newline                                          MYBOOL dualphase1, MYBOOL skipupdate,\newline                                          int *candidatecount, REAL *xviol)\newline{\newline  int      i, iy, iz, ix, k, nbound;\newline  LREAL    w, g, quot;\newline  REAL     viol, p, epspivot = lp-&gtepspivot;\newline#ifdef MachinePrecRoundRHS\newline  REAL     epsvalue = lp-&gtepsmachine;\newline#else\newline  REAL     epsvalue = lp-&gtepsvalue;\newline#endif\newline  pricerec current, candidate;\newline  MYBOOL   isbatch = FALSE, /* Requires that lp-&gtlongsteps-&gtsize &gt lp-&gtsum */\newline           dolongsteps = (MYBOOL) (lp-&gtlongsteps != NULL);\newline\newline  /* Initialize */\newline  if(dolongsteps &amp&amp !dualphase1)\newline    dolongsteps = AUTOMATIC;  /* Sets Phase1 = TRUE, Phase2 = AUTOMATIC */\newline  current.theta    = lp-&gtinfinite;\newline  current.pivot    = 0;\newline  current.varno    = 0;\newline  current.epspivot = epspivot;\newline  current.isdual   = TRUE;\newline  current.lp       = lp;\newline  candidate.epspivot = epspivot;\newline  candidate.isdual = TRUE;\newline  candidate.lp     = lp;\newline  *candidatecount  = 0;\newline\newline  /* Compute reduced costs */\newline  if(!skipupdate) {\newline#ifdef UseDualReducedCostUpdate\newline    /* Recompute from scratch only at the beginning, otherwise update */\newline    if((lp-&gtcurrent_iter &gt 0) &amp&amp (refactRecent(lp) &lt AUTOMATIC))\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               NULL, NULL,\newline                               MAT_ROUNDDEFAULT);\newline    else\newline#endif\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               drow, nzdrow,\newline                               MAT_ROUNDDEFAULT);\newline  }\newline\newline#if 0\newline  /* Override all above to do in-line testing with fixed test set */\newline  if(lp-&gtrows &gt 1 &amp&amp lp-&gtcolumns &gt 10)\newline    longdual_testset(lp, 10, row_nr, prow, nzprow, drow, nzdrow);\newline#endif\newline\newline  /* Compute the current violation of the bounds of the outgoing variable,\newline     negative for violation of lower bound, positive for upper bound violation.\newline     (Basic variables are always lower-bounded, by lp_solve convention) */\newline  g = 1;\newline  viol = lp-&gtrhs[row_nr];\newline  if(viol &gt 0) {   /* Check if the leaving variable is &gt= its upper bound */\newline    p = lp-&gtupbo[lp-&gtvar_basic[row_nr]];\newline    if(p &lt lp-&gtinfinite) {\newline      viol -= p;\newline      my_roundzero(viol, epsvalue);\newline      if(viol &gt 0)\newline        g = -1;\newline    }\newline    /* Do validation of numerics */\newline    if(g == 1) {\newline      if(viol &gt= lp-&gtinfinite) {\newline        report(lp, IMPORTANT, &quotcoldual: Large basic solution value %g at iter %.0f indicates numerical instability\\n&quot,\newline                               lp-&gtrhs[row_nr], (double) get_total_iter(lp));\newline        lp-&gtspx_status = NUMFAILURE;\newline        return( 0 );\newline\newline      }\newline      if(skipupdate)\newline        report(lp, DETAILED, &quotcoldual: Inaccurate bound-flip accuracy at iter %.0f\\n&quot,\newline                              (double) get_total_iter(lp));\newline      else\newline        report(lp, SEVERE,   &quotcoldual: Leaving variable %d does not violate bounds at iter %.0f\\n&quot,\newline                              row_nr, (double) get_total_iter(lp));\newline      return( -1 );\newline    }\newline  }\newline\newline  /* Update local value of pivot setting */\newline  lp-&gt_piv_rule_ = get_piv_rule(lp);\newline\newline  /* Condense list of relevant targets */\newline  p = 0;\newline  k = 0;\newline  nbound = 0;\newline  ix = 1;\newline  iy = nzprow[0];\newline  for(ix = 1; ix &lt= iy; ix++) {\newline    i = nzprow[ix];\newline    w = prow[i] * g;            /* Change sign if upper bound of the leaving variable is violated   */\newline    w *= 2*lp-&gtis_lower[i] - 1; /* Change sign if the non-basic variable is currently upper-bounded */\newline\newline    /* Check if the candidate is worth using for anything */\newline    if(w &lt -epsvalue) {\newline      /* Tally bounded variables */\newline      if(lp-&gtupbo[i] &lt lp-&gtinfinite)\newline        nbound++;\newline\newline      /* Update the nz-index */\newline      k++;\newline      nzprow[k] = i;\newline      SETMAX(p, -w);\newline    }\newline#ifdef Paranoia\newline    else {\newline      if(lp-&gtspx_trace) {\newline        report(lp, FULL, &quotcoldual: Candidate variable prow[%d] rejected with %g too small\\n&quot,\newline                         i, w);\newline      }\newline    }\newline#endif\newline\newline  }\newline  nzprow[0] = k;\newline  if(xviol != NULL)\newline    *xviol = p;\newline\newline#ifdef UseRelativePivot_Dual\newline/*  epspivot *= sqrt(lp-&gtmatA-&gtdynrange) / lp-&gtmatA-&gtinfnorm; */\newline  epspivot /= MAX(1, sqrt(lp-&gtmatA-&gtrowmax[row_nr]));\newline#endif\newline  current.epspivot   = epspivot;\newline  candidate.epspivot = epspivot;\newline\newline  /* Initialize the long-step structures if indicated */\newline  if(dolongsteps) {\newline    if((nzprow[0] &lt= 1) || (nbound == 0)) {  /* Don&#039t bother */\newline      dolongsteps = FALSE;\newline      lp-&gtlongsteps-&gtindexSet[0] = 0;\newline    }\newline    else {\newline      multi_restart(lp-&gtlongsteps);\newline      multi_valueInit(lp-&gtlongsteps, g*viol, lp-&gtrhs[0]);\newline    }\newline  }\newline\newline  /* Loop over all entering column candidates */\newline  ix = 1;\newline  iy = nzprow[0];\newline  makePriceLoop(lp, &ampix, &ampiy, &ampiz);\newline  iy *= iz;\newline  for(; ix*iz &lt= iy; ix += iz) {\newline    i = nzprow[ix];\newline\newline    /* Compute the dual ratio (prow = w and drow = cbar in Chvatal&#039s &quotnomenclatura&quot) */\newline    w    = prow[i] * g;         /* Change sign if upper bound of the leaving variable is violated   */\newline    quot = -drow[i] / w;        /* Remember this sign-reversal in multi_recompute!                  */\newline\newline    /* Apply the selected pivot strategy (smallest theta) */\newline    candidate.theta = quot;  /* Note that abs() is applied in findSubstitutionVar */\newline    candidate.pivot = w;\newline    candidate.varno = i;\newline\newline    /* Collect candidates for minor iterations/bound flips */\newline    if(dolongsteps) {\newline      if(isbatch &amp&amp (ix == iy))\newline        isbatch = AUTOMATIC;\newline      if(collectMinorVar(&ampcandidate, lp-&gtlongsteps, (MYBOOL) (dolongsteps == AUTOMATIC), isbatch) &amp&amp\newline         lp-&gtspx_trace)\newline        report(lp, DETAILED, &quotcoldual: Long-dual break point with %d bound-flip variables\\n&quot,\newline                             lp-&gtlongsteps-&gtused);\newline      if(lp-&gtspx_status == FATHOMED)\newline        return( 0 );\newline    }\newline\newline    /* We have a candidate for entering the basis; check if it is better than the incumbent */\newline    else if(findSubstitutionVar(&ampcurrent, &ampcandidate, candidatecount))\newline      break;\newline  }\newline\newline  /* Set entering variable and long-step bound swap variables */\newline  if(dolongsteps) {\newline    *candidatecount = lp-&gtlongsteps-&gtused;\newline    i = multi_enteringvar(lp-&gtlongsteps, NULL, 3);\newline  }\newline  else\newline    i = current.varno;\newline\newline  if(lp-&gtspx_trace)\newline    report(lp, NORMAL, &quotcoldual: Entering column %d, reduced cost %g, pivot value %g, bound swaps %d\\n&quot,\newline                       i, drow[i], prow[i], multi_used(lp-&gtlongsteps));\newline\newline  return( i );\newline} /* coldual */\newline","Find the dual simplex entering non-basic variable \newline","4713257","ximasel.cpp","bool CxImage::SelectionClear()\newline{\newline	if (pSelection){\newline		memset(pSelection,0,head.biWidth * head.biHeight);\newline		info.rSelectionBox.left = head.biWidth;\newline		info.rSelectionBox.bottom = head.biHeight;\newline		info.rSelectionBox.right = info.rSelectionBox.top = 0;\newline		return true;\newline	}\newline	return false;\newline}\newline","\newline Empties the selection.\newline \newline","1213526","cdirect.c","static nlopt_result divide_rect(double *rdiv, params *p)\newline{\newline     int i;\newline     const int n = p-&gtn;\newline     const int L = p-&gtL;\newline     double *c = rdiv + 3; /* center of rect to divide */\newline     double *w = c + n; /* widths of rect to divide */\newline     double wmax = w[0];\newline     int imax = 0, nlongest = 0;\newline     rb_node *node;\newline\newline     for (i = 1; i &lt n; ++i)\newline	  if (w[i] &gt wmax)\newline	       wmax = w[imax = i];\newline     for (i = 0; i &lt n; ++i)\newline	  if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL)\newline	       ++nlongest;\newline     if (p-&gtwhich_div == 1 || (p-&gtwhich_div == 0 &amp&amp nlongest == n)) {\newline	  /* trisect all longest sides, in increasing order of the average\newline	     function value along that direction */\newline	  double *fv = p-&gtwork;\newline	  int *isort = p-&gtiwork;\newline	  for (i = 0; i &lt n; ++i) {\newline	       if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL) {\newline		    double csave = c[i];\newline		    c[i] = csave - w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i], c, p, 0);\newline		    c[i] = csave + w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i+1], c, p, 0);\newline		    c[i] = csave;\newline	       }\newline	       else {\newline		    fv[2*i] = fv[2*i+1] = HUGE_VAL;\newline	       }\newline	  }\newline	  sort_fv(n, fv, isort);\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  for (i = 0; i &lt nlongest; ++i) {\newline	       int k;\newline	       w[isort[i]] *= THIRD;\newline	       rdiv[0] = rect_diameter(n, w, p);\newline	       rdiv[2] = p-&gtage++;\newline	       node = rb_tree_resort(&ampp-&gtrtree, node);\newline	       for (k = 0; k &lt= 1; ++k) {\newline		    double *rnew;\newline		    ALLOC_RECT(rnew, L);\newline		    memcpy(rnew, rdiv, sizeof(double) * L);\newline		    rnew[3 + isort[i]] += w[isort[i]] * (2*k-1);\newline		    rnew[1] = fv[2*isort[i]+k];\newline		    rnew[2] = p-&gtage++;\newline		    if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline			 free(rnew);\newline			 return NLOPT_OUT_OF_MEMORY;\newline		    }\newline	       }\newline	  }\newline     }\newline     else {\newline	  int k;\newline	  if (nlongest &gt 1 &amp&amp p-&gtwhich_div == 2) { \newline               /* randomly choose longest side */\newline	       i = nlopt_iurand(nlongest);\newline	       for (k = 0; k &lt n; ++k)\newline		    if (wmax - w[k] &lt= wmax * EQUAL_SIDE_TOL) {\newline			 if (!i) { i = k; break; }\newline			 --i;\newline		    }\newline	  }\newline	  else\newline	       i = imax; /* trisect longest side */\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  w[i] *= THIRD;\newline	  rdiv[0] = rect_diameter(n, w, p);\newline	  rdiv[2] = p-&gtage++;\newline	  node = rb_tree_resort(&ampp-&gtrtree, node);\newline	  for (k = 0; k &lt= 1; ++k) {\newline	       double *rnew;\newline	       ALLOC_RECT(rnew, L);\newline	       memcpy(rnew, rdiv, sizeof(double) * L);\newline	       rnew[3 + i] += w[i] * (2*k-1);\newline	       FUNCTION_EVAL(rnew[1], rnew + 3, p, rnew);\newline	       rnew[2] = p-&gtage++;\newline	       if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline		    free(rnew);\newline		    return NLOPT_OUT_OF_MEMORY;\newline	       }\newline	  }\newline     }\newline     return NLOPT_SUCCESS;\newline}\newline","divide rectangle idiv in the list p-&gtrects \newline","1118681","libfwnt_security_identifier.c","int libfwnt_security_identifier_initialize(\newline     libfwnt_security_identifier_t **security_identifier,\newline     libcerror_error_t **error )\newline{\newline	libfwnt_internal_security_identifier_t *internal_security_identifier = NULL;\newline	static char *function                                                = &quotlibfwnt_security_identifier_initialize&quot;\newline\newline	if( security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid security identifier.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *security_identifier != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid security identifier value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_security_identifier = memory_allocate_structure(\newline	                                libfwnt_internal_security_identifier_t );\newline\newline	if( internal_security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     internal_security_identifier,\newline	     0,\newline	     sizeof( libfwnt_internal_security_identifier_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	*security_identifier = (libfwnt_security_identifier_t *) internal_security_identifier;\newline\newline	return( 1 );\newline\newlineon_error:\newline	if( internal_security_identifier != NULL )\newline	{\newline		memory_free(\newline		 internal_security_identifier );\newline	}\newline	return( -1 );\newline}\newline","Creates a security identifier\newline Make sure the value security_identifier is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","3908740","jsprf.cpp","JS_PUBLIC_API(JSUint32) JS_snprintf(char *out, JSUint32 outlen, const char *fmt, ...)\newline{\newline    va_list ap;\newline    int rv;\newline\newline    JS_ASSERT((JSInt32)outlen &gt 0);\newline    if ((JSInt32)outlen &lt= 0) {\newline        return 0;\newline    }\newline\newline    va_start(ap, fmt);\newline    rv = JS_vsnprintf(out, outlen, fmt, ap);\newline    va_end(ap);\newline    return rv;\newline}\newline","\newline sprintf into a fixed size buffer. Make sure there is a NUL at the end\newline when finished.\newline \newline","3687433","cdrfifo.c","int Cdrfifo_attach_follow_up_fds(struct CdrfifO *o, int source_fd, int dest_fd,\newline                                 int flag)\newline{\newline if(o-&gtfollow_up_fd_counter&gt=Cdrfifo_ffd_maX)\newline   return(0);\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][0]= source_fd;\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][1]= dest_fd;\newline  o-&gtfollow_up_fd_counter++;\newline  return(o-&gtfollow_up_fd_counter);\newline}\newline","Attach a further pair of input and output fd which will use the same\newlinefifo buffer when its predecessors are exhausted. Reading will start as\newlinesoon as reading of the predecessor encounters EOF. Writing will start\newlineas soon as all pending predecessor data are written.\newline@return index number of new item + 1, &lt=0 indicates error\newline \newline","1781824","ocean.c","static void gfs_free_surface_pressure (GfsDomain * toplayer,\newline				       GfsMultilevelParams * par,\newline				       GfsAdvectionParams * apar,\newline				       GfsVariable * p,\newline				       GfsVariable * div,\newline				       GfsVariable * divn,\newline				       GfsVariable * res,\newline				       gdouble G)\newline{\newline  FreeSurfaceParams fp;\newline  GfsVariable * res1;\newline\newline  g_return_if_fail (toplayer != NULL);\newline  g_return_if_fail (par != NULL);\newline  g_return_if_fail (apar != NULL);\newline  g_return_if_fail (p != NULL);\newline  g_return_if_fail (div != NULL);\newline  g_return_if_fail (divn != NULL);\newline  g_return_if_fail (G &gt 0.);\newline\newline  fp.pn = p;\newline  fp.div = div;\newline  fp.dia = gfs_temporary_variable (toplayer);\newline  res1 = res ? res : gfs_temporary_variable (toplayer);\newline  fp.divn = divn;\newline  fp.dt = apar-&gtdt;\newline  fp.G = G;\newline\newline  /* compute MAC divergence */\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,\newline			    (FttCellTraverseFunc) normal_divergence, &ampfp);\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,\newline  			    (FttCellTraverseFunc) scale_divergence_helmoltz, &ampfp);\newline  \newline  /* solve for pressure */\newline  par-&gtdimension = 2;\newline  par-&gtpoisson_solve (toplayer, par, p, fp.div, res1, fp.dia, apar-&gtdt);\newline#if !FTT_2D\newline  gfs_domain_traverse_merged (toplayer, (GfsMergedTraverseFunc) merge_pressures, p);\newline#endif\newline\newline  if (!res)\newline    gts_object_destroy (GTS_OBJECT (res1));\newline  gts_object_destroy (GTS_OBJECT (fp.dia));\newline}\newline","\newline gfs_free_surface_pressure:\newline @toplayer: a #GfsDomain.\newline @par: the multigrid paramaters.\newline @apar: the advection parameters.\newline \newline \newline","888223","tcl_class.c","t_class * tclpd_class_new(const char *name, int flags) {\newline    t_class *c = class_new(gensym(name), (t_newmethod)tclpd_new,\newline        (t_method)tclpd_free, sizeof(t_tcl), flags, A_GIMME, A_NULL);\newline\newline    if(!class_table)\newline        class_table = hashtable_new(1 &lt&lt 7);\newline    if(!class_table_get(name))\newline        class_table_add(name, c);\newline\newline    class_addanything(c, tclpd_anything);\newline\newline    // is this really necessary given that there is already a &#039anything&#039 handler?\newline    class_addmethod(c, (t_method)tclpd_loadbang, gensym(&quotloadbang&quot), A_NULL);\newline    \newline    class_addmethod(c, (t_method)tclpd_open, gensym(&quotmenu-open&quot), A_NULL);\newline\newline    char buf[80];\newline    Tcl_Obj *res;\newline    int res_i;\newline\newline    // use properties function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::properties]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setpropertiesfn(c, tclpd_properties);\newline        }\newline    }\newline\newline    // use save function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::save]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setsavefn(c, tclpd_save);\newline        }\newline    }\newline\newline    return c;\newline}\newline","set up the class that handles loading of tcl classes \newline","3676136","libics_binary.c","Ics_Error IcsSetIdsBlock (Ics_Header* IcsStruct, long offset, int whence)\newline{\newline   ICSINIT;\newline   Ics_BlockRead* br = (Ics_BlockRead*)IcsStruct-&gtBlockRead;\newline\newline   switch (IcsStruct-&gtCompression) {\newline      case IcsCompr_uncompressed:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               if (fseek(br-&gtDataFilePtr, (long)offset, whence) != 0) {\newline                  error = ferror(br-&gtDataFilePtr) ? IcsErr_FReadIds : IcsErr_EndOfStream;\newline               }\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#ifdef ICS_ZLIB\newline      case IcsCompr_gzip:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               error = IcsSetZipBlock (IcsStruct, offset, whence);\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#endif\newline      case IcsCompr_compress:\newline         error = IcsErr_BlockNotAllowed;\newline         break;\newline      default:\newline         error = IcsErr_UnknownCompression;\newline   }\newline\newline   return error;\newline}\newline","\newline Sets the file pointer into the IDS file.\newline \newline","5198035","apc_pool.c","PHP_APCU_API apc_pool* apc_pool_create(apc_pool_type pool_type,\newline                                       apc_malloc_t allocate, \newline                                       apc_free_t deallocate,\newline                                       apc_protect_t protect,\newline                                       apc_unprotect_t unprotect) \newline{\newline    if(pool_type == APC_UNPOOL) {\newline        return apc_unpool_create(pool_type, allocate, deallocate, protect, unprotect);\newline    }\newline\newline    return apc_realpool_create(pool_type, allocate, deallocate, protect,  unprotect);\newline}\newline","{{{ apc_pool_create \newline","2796020","libuna_base64_stream.c","LIBUNA_INLINE \\\newlineint libuna_base64_triplet_copy_from_base64_stream(\newline     uint32_t *base64_triplet,\newline     const uint8_t *base64_stream,\newline     size_t base64_stream_size,\newline     size_t *base64_stream_index,\newline     uint8_t *padding_size,\newline     uint32_t base64_variant,\newline     libcerror_error_t **error )\newline{\newline	static char *function        = &quotlibuna_base64_triplet_copy_from_base64_stream&quot;\newline	size_t base64_character_size = 0;\newline	size_t stream_index          = 0;\newline	uint32_t base64_character    = 0;\newline	uint8_t padding_character    = 0;\newline	uint8_t sixtet1              = 0;\newline	uint8_t sixtet2              = 0;\newline	uint8_t sixtet3              = 0;\newline	uint8_t sixtet4              = 0;\newline\newline	if( base64_triplet == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 triplet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid base64 stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *base64_stream_index &gt= base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: base64 stream string too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( padding_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid padding size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0x0f000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_PADDING_NONE:\newline			padding_character = 0;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_OPTIONAL:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_REQUIRED:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character_size = 1;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			base64_character_size = 2;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			base64_character_size = 4;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	stream_index = *base64_stream_index;\newline\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet1,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 1st sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet2,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 2nd sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*padding_size = 2;\newline\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 3rd base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet3 = 0;\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet3,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 3rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 3rd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 4th base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet4 = 0;\newline		}\newline		else if( *padding_size &gt 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4th base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet4,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 4th base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*base64_triplet   = sixtet1;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet2;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet3;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet4;\newline\newline	*base64_stream_index = stream_index;\newline\newline	return( 1 );\newline}\newline","Copies a base64 triplet from a base64 stream\newline \newline The padding size will still be set to indicate the number of\newline sixtets in the triplet\newline \newline Returns 1 if successful or -1 on error\newline \newline","1851940","concat-deps.c","static void emit_single_boost_header(void)\newline{\newline#define BOOST_TARGET &quot/UnpackedTarball/boost.done&quot\newline    fprintf(stdout, &quot%s&quot BOOST_TARGET &quot &quot, work_dir);\newline}\newline","\newline We collapse tens of internal boost headers to the unpacked target, such\newline that you can re-compile / install boost and all is well.\newline \newline","4938294","xmu.c","int XmuPrintDefaultErrorMessage (Display *dpy, XErrorEvent *event, FILE *fp)\newline{\newline    char buffer[BUFSIZ];\newline    char mesg[BUFSIZ];\newline    char number[32];\newline    char *mtype = &quotXlibMessage&quot;\newline    _XExtension *ext = (_XExtension *)NULL;\newline    XGetErrorText(dpy, event-&gterror_code, buffer, BUFSIZ);\newline    XGetErrorDatabaseText(dpy, mtype, &quotXError&quot, &quotX Error&quot, mesg, BUFSIZ);\newline    fprintf(fp, &quot%s:  %s\\n  &quot, mesg, buffer);\newline    XGetErrorDatabaseText(dpy, mtype, &quotMajorCode&quot, &quotRequest Major code %d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtrequest_code);\newline    if (event-&gtrequest_code &lt 128) {\newline	sprintf(number, &quot%d&quot, event-&gtrequest_code);\newline	XGetErrorDatabaseText(dpy, &quotXRequest&quot, number, &quot&quot, buffer, BUFSIZ);\newline    } else {\newline	/* XXX this is non-portable */\newline	for (ext = dpy-&gtext_procs;\newline	     ext &amp&amp (ext-&gtcodes.major_opcode != event-&gtrequest_code);\newline	     ext = ext-&gtnext)\newline	  ;\newline	if (ext)\newline	    strcpy(buffer, ext-&gtname);\newline	else\newline	    buffer[0] = &#039\\0&#039;\newline    }\newline    fprintf(fp, &quot (%s)&quot, buffer);\newline    fputs(&quot\\n  &quot, fp);\newline#if (XtSpecificationRelease &gt= 5)\newline    if (event-&gtrequest_code &gt= 128) {\newline	XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			      mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtminor_code);\newline	if (ext) {\newline	    sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline	    XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline	    fprintf(fp, &quot (%s)&quot, buffer);\newline	}\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline    if (event-&gterror_code &gt= 128) {\newline	/* let extensions try to print the values */\newline	/* XXX this is non-portable code */\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_values)\newline		(*ext-&gterror_values)(dpy, event, fp);\newline	}\newline	/* the rest is a fallback, providing a simple default */\newline	/* kludge, try to find the extension that caused it */\newline	buffer[0] = &#039\\0&#039;\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_string)\newline		(*ext-&gterror_string)(dpy, event-&gterror_code, &ampext-&gtcodes,\newline				     buffer, BUFSIZ);\newline	    if (buffer[0])\newline		break;\newline	}\newline	if (buffer[0])\newline	    sprintf(buffer, &quot%s.%d&quot, ext-&gtname,\newline		    event-&gterror_code - ext-&gtcodes.first_error);\newline	else\newline	    strcpy(buffer, &quotValue&quot);\newline	XGetErrorDatabaseText(dpy, mtype, buffer, &quot&quot, mesg, BUFSIZ);\newline	if (*mesg) {\newline	    fprintf(fp, mesg, event-&gtresourceid);\newline	    fputs(&quot\\n  &quot, fp);\newline	}\newline    } else if ((event-&gterror_code == BadWindow) ||\newline	       (event-&gterror_code == BadPixmap) ||\newline	       (event-&gterror_code == BadCursor) ||\newline	       (event-&gterror_code == BadFont) ||\newline	       (event-&gterror_code == BadDrawable) ||\newline	       (event-&gterror_code == BadColor) ||\newline	       (event-&gterror_code == BadGC) ||\newline	       (event-&gterror_code == BadIDChoice) ||\newline	       (event-&gterror_code == BadValue) ||\newline	       (event-&gterror_code == BadAtom)) {\newline	if (event-&gterror_code == BadValue)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotValue&quot, &quotValue 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else if (event-&gterror_code == BadAtom)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotAtomID&quot, &quotAtomID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else\newline	    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtresourceid);\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline#elif (XtSpecificationRelease == 4)\newline    XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtminor_code);\newline    fputs(&quot\\n  &quot, fp);\newline    if (ext) {\newline      sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline      XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline      fprintf(fp, &quot (%s)&quot, buffer);\newline    }\newline    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtresourceid);\newline    fputs(&quot\\n  &quot, fp);\newline#else\newlineERROR! Unsupported release of X11\newline#endif\newline    XGetErrorDatabaseText(dpy, mtype, &quotErrorSerial&quot, &quotError Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtserial);\newline    fputs(&quot\\n  &quot, fp);\newline    XGetErrorDatabaseText(dpy, mtype, &quotCurrentSerial&quot, &quotCurrent Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, NextRequest(dpy)-1);\newline    fputs(&quot\\n&quot, fp);\newline    if (event-&gterror_code == BadImplementation) return 0;\newline    return 1;\newline}\newline","\newline XmuPrintDefaultErrorMessage - print a nice error that looks like the usual\newline message. Return 1 if the caller should consider exiting, else 0.\newline \newline","772479","coverity_model.c","void *memccpy(void *dest, const void *src, int c, size_t n)\newline{\newline	const char *s = src;\newline	char *d = dest;\newline\newline	while (n-- &gt 0)\newline		if ((*d++ = *s++) == (char) c)\newline			return d;\newline\newline	return 0;\newline}\newline","simple_memccpy() from glibc \newline","1305953","filter_chain.c","int fc_register_match(const char *name, match_proc_t proc) /* {{{ */\newline{\newline  fc_match_t *m;\newline\newline  DEBUG(&quotfc_register_match (%s);&quot, name);\newline\newline  m = calloc(1, sizeof(*m));\newline  if (m == NULL)\newline    return (-ENOMEM);\newline\newline  sstrncpy(m-&gtname, name, sizeof(m-&gtname));\newline  memcpy(&ampm-&gtproc, &ampproc, sizeof(m-&gtproc));\newline\newline  if (match_list_head == NULL) {\newline    match_list_head = m;\newline  } else {\newline    fc_match_t *ptr;\newline\newline    ptr = match_list_head;\newline    while (ptr-&gtnext != NULL)\newline      ptr = ptr-&gtnext;\newline\newline    ptr-&gtnext = m;\newline  }\newline\newline  return (0);\newline} /* }}} int fc_register_match */\newline","Add a match to list of available matches. \newline","12245","rxstack.c","Client *get_new_client( )\newline{\newline   Client *retval = (Client *)malloc( sizeof( Client ) ) ;\newline\newline   if ( retval == NULL )\newline      return NULL ;\newline   memset( retval, 0, sizeof( Client ) ) ;\newline   retval-&gtsocket = -1 ;\newline   retval-&gtdeadline.milli = -1 ; /* deadline not used --&gt infinite timeout */\newline\newline   retval-&gtnext = clients ;\newline   if ( clients != NULL )\newline      clients-&gtprev = retval ;\newline   clients = retval ;\newline   return retval ;\newline}\newline","Creates a new client and appends it in front of the current clients.\newline Don&#039t forget to set a default_queue and the socket at once.\newline \newline","6007706","dfinscmp.c","static void CloseDefinstancesFiles(\newline  void *theEnv,\newline  FILE *moduleFile,\newline  FILE *definstancesFile,\newline  int maxIndices)\newline  {\newline   int count = maxIndices;\newline   int arrayVersion = 0;\newline\newline   if (definstancesFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,definstancesFile,&ampcount,&amparrayVersion,\newline                                         maxIndices,NULL,NULL);\newline     }\newline\newline   if (moduleFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,moduleFile,&ampcount,&amparrayVersion,maxIndices,NULL,NULL);\newline     }\newline  }\newline","\newlineNAME : CloseDefinstancesFiles\newlineDESCRIPTION : Closes construct compiler files\newlinefor definstances structures\newlineINPUTS : 1) The definstances module file\newline2) The definstances structure file\newline3) The maximum number of indices\newlineallowed in an array\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Files closed\newlineNOTES : None\newline \newline","1085640","pns.c","static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\newline                                   uint8_t sub,\newline                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\newline{\newline#ifndef FIXED_POINT\newline    uint16_t i;\newline    real_t energy = 0.0;\newline\newline    real_t scale = (real_t)1.0/(real_t)size;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\newline        spec[i] = tmp;\newline        energy += tmp*tmp;\newline    }\newline\newline    scale = (real_t)1.0/(real_t)sqrt(energy);\newline    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\newline    for (i = 0; i &lt size; i++)\newline    {\newline        spec[i] *= scale;\newline    }\newline#else\newline    uint16_t i;\newline    real_t energy = 0, scale;\newline    int32_t exp, frac;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        /* this can be replaced by a 16 bit random generator!!!! */\newline        real_t tmp = (int32_t)ne_rng(__r1, __r2);\newline        if (tmp &lt 0)\newline            tmp = -(tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline        else\newline            tmp = (tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline\newline        energy += MUL_R(tmp,tmp);\newline\newline        spec[i] = tmp;\newline    }\newline\newline    energy = fp_sqrt(energy);\newline    if (energy &gt 0)\newline    {\newline        scale = DIV(REAL_CONST(1),energy);\newline\newline        exp = scale_factor &gt&gt 2;\newline        frac = scale_factor &amp 3;\newline\newline        /* IMDCT pre-scaling */\newline        exp -= sub;\newline\newline        if (exp &lt 0)\newline            scale &gt&gt= -exp;\newline        else\newline            scale &lt&lt= exp;\newline\newline        if (frac)\newline            scale = MUL_C(scale, pow2_table[frac]);\newline\newline        for (i = 0; i &lt size; i++)\newline        {\newline            spec[i] = MUL_R(spec[i], scale);\newline        }\newline    }\newline#endif\newline}\newline","The function gen_rand_vector(addr, size) generates a vector of length\newline&ltsize&gt with signed random values of average energy MEAN_NRG per random\newlinevalue. A suitable random number generator can be realized using one\newlinemultiplication/accumulation per random value.\newline \newline","12911","files.c","void find_shared_library(const tsd_t *TSD, const char *inname, const char *inenv, char *retname)\newline{\newline   char *paths;\newline   char outname[REXX_PATH_MAX+1];\newline   char *env_path;\newline\newline   strcpy( retname, inname );\newline   env_path = mygetenv( TSD, inenv, NULL, 0 ); /* fixes bug 595293 */\newline   if ( !env_path )\newline      return;\newline   paths = env_path;\newline   while ( paths &amp&amp *paths )\newline   {\newline      int pathlen;\newline      char *sep;\newline\newline      sep = strchr( paths, PATH_SEPARATOR );\newline      pathlen = sep ? sep-paths : strlen( paths );\newline      strncpy( outname, paths, pathlen );\newline      outname[pathlen] = 0;\newline\newline      if ( ( pathlen &gt 0 ) &amp&amp ( outname[pathlen-1] != FILE_SEPARATOR ) )\newline         strcat( outname, FILE_SEPARATOR_STR );\newline      strcat( outname, inname );\newline      paths = sep ? sep+1 : 0; /* set up for next pass */\newline      if ( access( outname,F_OK ) == 0)\newline      {\newline         strcpy( retname,outname );\newline         break;\newline      }\newline   }\newline   FreeTSD( env_path );\newline   return;\newline}\newline","\newline find_shared_library is used for HP/UX purpose only.\newline It looks for the file inname in the content of the environment variable\newline inenv and puts the result into retname. retname has to have a size of\newline at least REXX_PATH_MAX+1.\newline retname becomes inname if no other file is found.\newline \newline","","","","on","","","","on","","","","on","","","","","","","on","","on","","","","","","on","","","","","","","","on","","","","","","on","","perform http initialization","set up the class","Sets the file pointer into the IDS file.","{}","Copies a base64 triplet from a base64 stream","re-compile / install boost","print a nice error","{}","Add a match to list of available matches.","Creates a new client and appends it","Closes construct compiler files","{}","generates a vector","looks for the file","Find the dual simplex","Empties the selection.","divide rectangle","Creates a security identifier","{}","Attach a further pair of input and output","{}"
"372AGES0I453MAUWLNYDJ9FJSLWRX3","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3T111IHZ5EQF8Y9R89X0SPPQ1609R1","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:47:55 PDT 2019","Wed Apr 17 12:53:52 PDT 2019","Fri Apr 19 12:53:52 PDT 2019","2019-04-19 19:54:21 UTC","","","357","100% (27/27)","100% (27/27)","100% (27/27)","4913405","http_client.c","static void _http_init(Slapi_ComponentId *plugin_id)\newline{\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot--&gt _http_init -- BEGIN\\n&quot,0,0,0);\newline	\newline	http_impl_init(plugin_id);\newline\newline	LDAPDebug( LDAP_DEBUG_PLUGIN, &quot&lt-- _http_init -- END\\n&quot,0,0,0);\newline}\newline","\newline perform http initialization here \newline \newline","1807476","regress.c","RegressTestFundamentalObject *\newlineregress_test_value_get_fundamental_object (const GValue * value)\newline{\newline  g_return_val_if_fail (REGRESS_TEST_VALUE_HOLDS_FUNDAMENTAL_OBJECT (value), NULL);\newline\newline  return value-&gtdata[0].v_pointer;\newline}\newline","\newline regress_test_value_get_fundamental_object: (skip)\newline @value:\newline \newline","1003211","lp_price.c","STATIC int coldual(lprec *lp, int row_nr, REAL *prow, int *nzprow,\newline                                          REAL *drow, int *nzdrow,\newline                                          MYBOOL dualphase1, MYBOOL skipupdate,\newline                                          int *candidatecount, REAL *xviol)\newline{\newline  int      i, iy, iz, ix, k, nbound;\newline  LREAL    w, g, quot;\newline  REAL     viol, p, epspivot = lp-&gtepspivot;\newline#ifdef MachinePrecRoundRHS\newline  REAL     epsvalue = lp-&gtepsmachine;\newline#else\newline  REAL     epsvalue = lp-&gtepsvalue;\newline#endif\newline  pricerec current, candidate;\newline  MYBOOL   isbatch = FALSE, /* Requires that lp-&gtlongsteps-&gtsize &gt lp-&gtsum */\newline           dolongsteps = (MYBOOL) (lp-&gtlongsteps != NULL);\newline\newline  /* Initialize */\newline  if(dolongsteps &amp&amp !dualphase1)\newline    dolongsteps = AUTOMATIC;  /* Sets Phase1 = TRUE, Phase2 = AUTOMATIC */\newline  current.theta    = lp-&gtinfinite;\newline  current.pivot    = 0;\newline  current.varno    = 0;\newline  current.epspivot = epspivot;\newline  current.isdual   = TRUE;\newline  current.lp       = lp;\newline  candidate.epspivot = epspivot;\newline  candidate.isdual = TRUE;\newline  candidate.lp     = lp;\newline  *candidatecount  = 0;\newline\newline  /* Compute reduced costs */\newline  if(!skipupdate) {\newline#ifdef UseDualReducedCostUpdate\newline    /* Recompute from scratch only at the beginning, otherwise update */\newline    if((lp-&gtcurrent_iter &gt 0) &amp&amp (refactRecent(lp) &lt AUTOMATIC))\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               NULL, NULL,\newline                               MAT_ROUNDDEFAULT);\newline    else\newline#endif\newline      compute_reducedcosts(lp, TRUE, row_nr, NULL, TRUE,\newline                               prow, nzprow,\newline                               drow, nzdrow,\newline                               MAT_ROUNDDEFAULT);\newline  }\newline\newline#if 0\newline  /* Override all above to do in-line testing with fixed test set */\newline  if(lp-&gtrows &gt 1 &amp&amp lp-&gtcolumns &gt 10)\newline    longdual_testset(lp, 10, row_nr, prow, nzprow, drow, nzdrow);\newline#endif\newline\newline  /* Compute the current violation of the bounds of the outgoing variable,\newline     negative for violation of lower bound, positive for upper bound violation.\newline     (Basic variables are always lower-bounded, by lp_solve convention) */\newline  g = 1;\newline  viol = lp-&gtrhs[row_nr];\newline  if(viol &gt 0) {   /* Check if the leaving variable is &gt= its upper bound */\newline    p = lp-&gtupbo[lp-&gtvar_basic[row_nr]];\newline    if(p &lt lp-&gtinfinite) {\newline      viol -= p;\newline      my_roundzero(viol, epsvalue);\newline      if(viol &gt 0)\newline        g = -1;\newline    }\newline    /* Do validation of numerics */\newline    if(g == 1) {\newline      if(viol &gt= lp-&gtinfinite) {\newline        report(lp, IMPORTANT, &quotcoldual: Large basic solution value %g at iter %.0f indicates numerical instability\\n&quot,\newline                               lp-&gtrhs[row_nr], (double) get_total_iter(lp));\newline        lp-&gtspx_status = NUMFAILURE;\newline        return( 0 );\newline\newline      }\newline      if(skipupdate)\newline        report(lp, DETAILED, &quotcoldual: Inaccurate bound-flip accuracy at iter %.0f\\n&quot,\newline                              (double) get_total_iter(lp));\newline      else\newline        report(lp, SEVERE,   &quotcoldual: Leaving variable %d does not violate bounds at iter %.0f\\n&quot,\newline                              row_nr, (double) get_total_iter(lp));\newline      return( -1 );\newline    }\newline  }\newline\newline  /* Update local value of pivot setting */\newline  lp-&gt_piv_rule_ = get_piv_rule(lp);\newline\newline  /* Condense list of relevant targets */\newline  p = 0;\newline  k = 0;\newline  nbound = 0;\newline  ix = 1;\newline  iy = nzprow[0];\newline  for(ix = 1; ix &lt= iy; ix++) {\newline    i = nzprow[ix];\newline    w = prow[i] * g;            /* Change sign if upper bound of the leaving variable is violated   */\newline    w *= 2*lp-&gtis_lower[i] - 1; /* Change sign if the non-basic variable is currently upper-bounded */\newline\newline    /* Check if the candidate is worth using for anything */\newline    if(w &lt -epsvalue) {\newline      /* Tally bounded variables */\newline      if(lp-&gtupbo[i] &lt lp-&gtinfinite)\newline        nbound++;\newline\newline      /* Update the nz-index */\newline      k++;\newline      nzprow[k] = i;\newline      SETMAX(p, -w);\newline    }\newline#ifdef Paranoia\newline    else {\newline      if(lp-&gtspx_trace) {\newline        report(lp, FULL, &quotcoldual: Candidate variable prow[%d] rejected with %g too small\\n&quot,\newline                         i, w);\newline      }\newline    }\newline#endif\newline\newline  }\newline  nzprow[0] = k;\newline  if(xviol != NULL)\newline    *xviol = p;\newline\newline#ifdef UseRelativePivot_Dual\newline/*  epspivot *= sqrt(lp-&gtmatA-&gtdynrange) / lp-&gtmatA-&gtinfnorm; */\newline  epspivot /= MAX(1, sqrt(lp-&gtmatA-&gtrowmax[row_nr]));\newline#endif\newline  current.epspivot   = epspivot;\newline  candidate.epspivot = epspivot;\newline\newline  /* Initialize the long-step structures if indicated */\newline  if(dolongsteps) {\newline    if((nzprow[0] &lt= 1) || (nbound == 0)) {  /* Don&#039t bother */\newline      dolongsteps = FALSE;\newline      lp-&gtlongsteps-&gtindexSet[0] = 0;\newline    }\newline    else {\newline      multi_restart(lp-&gtlongsteps);\newline      multi_valueInit(lp-&gtlongsteps, g*viol, lp-&gtrhs[0]);\newline    }\newline  }\newline\newline  /* Loop over all entering column candidates */\newline  ix = 1;\newline  iy = nzprow[0];\newline  makePriceLoop(lp, &ampix, &ampiy, &ampiz);\newline  iy *= iz;\newline  for(; ix*iz &lt= iy; ix += iz) {\newline    i = nzprow[ix];\newline\newline    /* Compute the dual ratio (prow = w and drow = cbar in Chvatal&#039s &quotnomenclatura&quot) */\newline    w    = prow[i] * g;         /* Change sign if upper bound of the leaving variable is violated   */\newline    quot = -drow[i] / w;        /* Remember this sign-reversal in multi_recompute!                  */\newline\newline    /* Apply the selected pivot strategy (smallest theta) */\newline    candidate.theta = quot;  /* Note that abs() is applied in findSubstitutionVar */\newline    candidate.pivot = w;\newline    candidate.varno = i;\newline\newline    /* Collect candidates for minor iterations/bound flips */\newline    if(dolongsteps) {\newline      if(isbatch &amp&amp (ix == iy))\newline        isbatch = AUTOMATIC;\newline      if(collectMinorVar(&ampcandidate, lp-&gtlongsteps, (MYBOOL) (dolongsteps == AUTOMATIC), isbatch) &amp&amp\newline         lp-&gtspx_trace)\newline        report(lp, DETAILED, &quotcoldual: Long-dual break point with %d bound-flip variables\\n&quot,\newline                             lp-&gtlongsteps-&gtused);\newline      if(lp-&gtspx_status == FATHOMED)\newline        return( 0 );\newline    }\newline\newline    /* We have a candidate for entering the basis; check if it is better than the incumbent */\newline    else if(findSubstitutionVar(&ampcurrent, &ampcandidate, candidatecount))\newline      break;\newline  }\newline\newline  /* Set entering variable and long-step bound swap variables */\newline  if(dolongsteps) {\newline    *candidatecount = lp-&gtlongsteps-&gtused;\newline    i = multi_enteringvar(lp-&gtlongsteps, NULL, 3);\newline  }\newline  else\newline    i = current.varno;\newline\newline  if(lp-&gtspx_trace)\newline    report(lp, NORMAL, &quotcoldual: Entering column %d, reduced cost %g, pivot value %g, bound swaps %d\\n&quot,\newline                       i, drow[i], prow[i], multi_used(lp-&gtlongsteps));\newline\newline  return( i );\newline} /* coldual */\newline","Find the dual simplex entering non-basic variable \newline","4713257","ximasel.cpp","bool CxImage::SelectionClear()\newline{\newline	if (pSelection){\newline		memset(pSelection,0,head.biWidth * head.biHeight);\newline		info.rSelectionBox.left = head.biWidth;\newline		info.rSelectionBox.bottom = head.biHeight;\newline		info.rSelectionBox.right = info.rSelectionBox.top = 0;\newline		return true;\newline	}\newline	return false;\newline}\newline","\newline Empties the selection.\newline \newline","1213526","cdirect.c","static nlopt_result divide_rect(double *rdiv, params *p)\newline{\newline     int i;\newline     const int n = p-&gtn;\newline     const int L = p-&gtL;\newline     double *c = rdiv + 3; /* center of rect to divide */\newline     double *w = c + n; /* widths of rect to divide */\newline     double wmax = w[0];\newline     int imax = 0, nlongest = 0;\newline     rb_node *node;\newline\newline     for (i = 1; i &lt n; ++i)\newline	  if (w[i] &gt wmax)\newline	       wmax = w[imax = i];\newline     for (i = 0; i &lt n; ++i)\newline	  if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL)\newline	       ++nlongest;\newline     if (p-&gtwhich_div == 1 || (p-&gtwhich_div == 0 &amp&amp nlongest == n)) {\newline	  /* trisect all longest sides, in increasing order of the average\newline	     function value along that direction */\newline	  double *fv = p-&gtwork;\newline	  int *isort = p-&gtiwork;\newline	  for (i = 0; i &lt n; ++i) {\newline	       if (wmax - w[i] &lt= wmax * EQUAL_SIDE_TOL) {\newline		    double csave = c[i];\newline		    c[i] = csave - w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i], c, p, 0);\newline		    c[i] = csave + w[i] * THIRD;\newline		    FUNCTION_EVAL(fv[2*i+1], c, p, 0);\newline		    c[i] = csave;\newline	       }\newline	       else {\newline		    fv[2*i] = fv[2*i+1] = HUGE_VAL;\newline	       }\newline	  }\newline	  sort_fv(n, fv, isort);\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  for (i = 0; i &lt nlongest; ++i) {\newline	       int k;\newline	       w[isort[i]] *= THIRD;\newline	       rdiv[0] = rect_diameter(n, w, p);\newline	       rdiv[2] = p-&gtage++;\newline	       node = rb_tree_resort(&ampp-&gtrtree, node);\newline	       for (k = 0; k &lt= 1; ++k) {\newline		    double *rnew;\newline		    ALLOC_RECT(rnew, L);\newline		    memcpy(rnew, rdiv, sizeof(double) * L);\newline		    rnew[3 + isort[i]] += w[isort[i]] * (2*k-1);\newline		    rnew[1] = fv[2*isort[i]+k];\newline		    rnew[2] = p-&gtage++;\newline		    if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline			 free(rnew);\newline			 return NLOPT_OUT_OF_MEMORY;\newline		    }\newline	       }\newline	  }\newline     }\newline     else {\newline	  int k;\newline	  if (nlongest &gt 1 &amp&amp p-&gtwhich_div == 2) { \newline               /* randomly choose longest side */\newline	       i = nlopt_iurand(nlongest);\newline	       for (k = 0; k &lt n; ++k)\newline		    if (wmax - w[k] &lt= wmax * EQUAL_SIDE_TOL) {\newline			 if (!i) { i = k; break; }\newline			 --i;\newline		    }\newline	  }\newline	  else\newline	       i = imax; /* trisect longest side */\newline	  if (!(node = rb_tree_find(&ampp-&gtrtree, rdiv)))\newline	       return NLOPT_FAILURE;\newline	  w[i] *= THIRD;\newline	  rdiv[0] = rect_diameter(n, w, p);\newline	  rdiv[2] = p-&gtage++;\newline	  node = rb_tree_resort(&ampp-&gtrtree, node);\newline	  for (k = 0; k &lt= 1; ++k) {\newline	       double *rnew;\newline	       ALLOC_RECT(rnew, L);\newline	       memcpy(rnew, rdiv, sizeof(double) * L);\newline	       rnew[3 + i] += w[i] * (2*k-1);\newline	       FUNCTION_EVAL(rnew[1], rnew + 3, p, rnew);\newline	       rnew[2] = p-&gtage++;\newline	       if (!rb_tree_insert(&ampp-&gtrtree, rnew)) {\newline		    free(rnew);\newline		    return NLOPT_OUT_OF_MEMORY;\newline	       }\newline	  }\newline     }\newline     return NLOPT_SUCCESS;\newline}\newline","divide rectangle idiv in the list p-&gtrects \newline","1118681","libfwnt_security_identifier.c","int libfwnt_security_identifier_initialize(\newline     libfwnt_security_identifier_t **security_identifier,\newline     libcerror_error_t **error )\newline{\newline	libfwnt_internal_security_identifier_t *internal_security_identifier = NULL;\newline	static char *function                                                = &quotlibfwnt_security_identifier_initialize&quot;\newline\newline	if( security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid security identifier.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *security_identifier != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid security identifier value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_security_identifier = memory_allocate_structure(\newline	                                libfwnt_internal_security_identifier_t );\newline\newline	if( internal_security_identifier == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     internal_security_identifier,\newline	     0,\newline	     sizeof( libfwnt_internal_security_identifier_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear security identifier.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	*security_identifier = (libfwnt_security_identifier_t *) internal_security_identifier;\newline\newline	return( 1 );\newline\newlineon_error:\newline	if( internal_security_identifier != NULL )\newline	{\newline		memory_free(\newline		 internal_security_identifier );\newline	}\newline	return( -1 );\newline}\newline","Creates a security identifier\newline Make sure the value security_identifier is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","3908740","jsprf.cpp","JS_PUBLIC_API(JSUint32) JS_snprintf(char *out, JSUint32 outlen, const char *fmt, ...)\newline{\newline    va_list ap;\newline    int rv;\newline\newline    JS_ASSERT((JSInt32)outlen &gt 0);\newline    if ((JSInt32)outlen &lt= 0) {\newline        return 0;\newline    }\newline\newline    va_start(ap, fmt);\newline    rv = JS_vsnprintf(out, outlen, fmt, ap);\newline    va_end(ap);\newline    return rv;\newline}\newline","\newline sprintf into a fixed size buffer. Make sure there is a NUL at the end\newline when finished.\newline \newline","3687433","cdrfifo.c","int Cdrfifo_attach_follow_up_fds(struct CdrfifO *o, int source_fd, int dest_fd,\newline                                 int flag)\newline{\newline if(o-&gtfollow_up_fd_counter&gt=Cdrfifo_ffd_maX)\newline   return(0);\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][0]= source_fd;\newline  o-&gtfollow_up_fds[o-&gtfollow_up_fd_counter][1]= dest_fd;\newline  o-&gtfollow_up_fd_counter++;\newline  return(o-&gtfollow_up_fd_counter);\newline}\newline","Attach a further pair of input and output fd which will use the same\newlinefifo buffer when its predecessors are exhausted. Reading will start as\newlinesoon as reading of the predecessor encounters EOF. Writing will start\newlineas soon as all pending predecessor data are written.\newline@return index number of new item + 1, &lt=0 indicates error\newline \newline","1781824","ocean.c","static void gfs_free_surface_pressure (GfsDomain * toplayer,\newline				       GfsMultilevelParams * par,\newline				       GfsAdvectionParams * apar,\newline				       GfsVariable * p,\newline				       GfsVariable * div,\newline				       GfsVariable * divn,\newline				       GfsVariable * res,\newline				       gdouble G)\newline{\newline  FreeSurfaceParams fp;\newline  GfsVariable * res1;\newline\newline  g_return_if_fail (toplayer != NULL);\newline  g_return_if_fail (par != NULL);\newline  g_return_if_fail (apar != NULL);\newline  g_return_if_fail (p != NULL);\newline  g_return_if_fail (div != NULL);\newline  g_return_if_fail (divn != NULL);\newline  g_return_if_fail (G &gt 0.);\newline\newline  fp.pn = p;\newline  fp.div = div;\newline  fp.dia = gfs_temporary_variable (toplayer);\newline  res1 = res ? res : gfs_temporary_variable (toplayer);\newline  fp.divn = divn;\newline  fp.dt = apar-&gtdt;\newline  fp.G = G;\newline\newline  /* compute MAC divergence */\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_LEAFS, -1,\newline			    (FttCellTraverseFunc) normal_divergence, &ampfp);\newline  gfs_domain_cell_traverse (toplayer, FTT_PRE_ORDER, FTT_TRAVERSE_ALL, -1,\newline  			    (FttCellTraverseFunc) scale_divergence_helmoltz, &ampfp);\newline  \newline  /* solve for pressure */\newline  par-&gtdimension = 2;\newline  par-&gtpoisson_solve (toplayer, par, p, fp.div, res1, fp.dia, apar-&gtdt);\newline#if !FTT_2D\newline  gfs_domain_traverse_merged (toplayer, (GfsMergedTraverseFunc) merge_pressures, p);\newline#endif\newline\newline  if (!res)\newline    gts_object_destroy (GTS_OBJECT (res1));\newline  gts_object_destroy (GTS_OBJECT (fp.dia));\newline}\newline","\newline gfs_free_surface_pressure:\newline @toplayer: a #GfsDomain.\newline @par: the multigrid paramaters.\newline @apar: the advection parameters.\newline \newline \newline","888223","tcl_class.c","t_class * tclpd_class_new(const char *name, int flags) {\newline    t_class *c = class_new(gensym(name), (t_newmethod)tclpd_new,\newline        (t_method)tclpd_free, sizeof(t_tcl), flags, A_GIMME, A_NULL);\newline\newline    if(!class_table)\newline        class_table = hashtable_new(1 &lt&lt 7);\newline    if(!class_table_get(name))\newline        class_table_add(name, c);\newline\newline    class_addanything(c, tclpd_anything);\newline\newline    // is this really necessary given that there is already a &#039anything&#039 handler?\newline    class_addmethod(c, (t_method)tclpd_loadbang, gensym(&quotloadbang&quot), A_NULL);\newline    \newline    class_addmethod(c, (t_method)tclpd_open, gensym(&quotmenu-open&quot), A_NULL);\newline\newline    char buf[80];\newline    Tcl_Obj *res;\newline    int res_i;\newline\newline    // use properties function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::properties]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setpropertiesfn(c, tclpd_properties);\newline        }\newline    }\newline\newline    // use save function if exists in tcl space.\newline    snprintf(buf, 80, &quotllength [info procs ::%s::save]&quot, name);\newline    if(Tcl_Eval(tclpd_interp, buf) == TCL_OK) {\newline        res = Tcl_GetObjResult(tclpd_interp);\newline        if(Tcl_GetIntFromObj(tclpd_interp, res, &ampres_i) == TCL_OK &amp&amp res_i &gt 0) {\newline            class_setsavefn(c, tclpd_save);\newline        }\newline    }\newline\newline    return c;\newline}\newline","set up the class that handles loading of tcl classes \newline","3676136","libics_binary.c","Ics_Error IcsSetIdsBlock (Ics_Header* IcsStruct, long offset, int whence)\newline{\newline   ICSINIT;\newline   Ics_BlockRead* br = (Ics_BlockRead*)IcsStruct-&gtBlockRead;\newline\newline   switch (IcsStruct-&gtCompression) {\newline      case IcsCompr_uncompressed:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               if (fseek(br-&gtDataFilePtr, (long)offset, whence) != 0) {\newline                  error = ferror(br-&gtDataFilePtr) ? IcsErr_FReadIds : IcsErr_EndOfStream;\newline               }\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#ifdef ICS_ZLIB\newline      case IcsCompr_gzip:\newline         switch (whence) {\newline            case SEEK_SET:\newline            case SEEK_CUR:\newline               error = IcsSetZipBlock (IcsStruct, offset, whence);\newline               break;\newline            default:\newline               error = IcsErr_IllParameter;\newline         }\newline         break;\newline#endif\newline      case IcsCompr_compress:\newline         error = IcsErr_BlockNotAllowed;\newline         break;\newline      default:\newline         error = IcsErr_UnknownCompression;\newline   }\newline\newline   return error;\newline}\newline","\newline Sets the file pointer into the IDS file.\newline \newline","5198035","apc_pool.c","PHP_APCU_API apc_pool* apc_pool_create(apc_pool_type pool_type,\newline                                       apc_malloc_t allocate, \newline                                       apc_free_t deallocate,\newline                                       apc_protect_t protect,\newline                                       apc_unprotect_t unprotect) \newline{\newline    if(pool_type == APC_UNPOOL) {\newline        return apc_unpool_create(pool_type, allocate, deallocate, protect, unprotect);\newline    }\newline\newline    return apc_realpool_create(pool_type, allocate, deallocate, protect,  unprotect);\newline}\newline","{{{ apc_pool_create \newline","2796020","libuna_base64_stream.c","LIBUNA_INLINE \\\newlineint libuna_base64_triplet_copy_from_base64_stream(\newline     uint32_t *base64_triplet,\newline     const uint8_t *base64_stream,\newline     size_t base64_stream_size,\newline     size_t *base64_stream_index,\newline     uint8_t *padding_size,\newline     uint32_t base64_variant,\newline     libcerror_error_t **error )\newline{\newline	static char *function        = &quotlibuna_base64_triplet_copy_from_base64_stream&quot;\newline	size_t base64_character_size = 0;\newline	size_t stream_index          = 0;\newline	uint32_t base64_character    = 0;\newline	uint8_t padding_character    = 0;\newline	uint8_t sixtet1              = 0;\newline	uint8_t sixtet2              = 0;\newline	uint8_t sixtet3              = 0;\newline	uint8_t sixtet4              = 0;\newline\newline	if( base64_triplet == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 triplet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid base64 stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( base64_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid base64 stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *base64_stream_index &gt= base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: base64 stream string too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( padding_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid padding size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0x0f000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_PADDING_NONE:\newline			padding_character = 0;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_OPTIONAL:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_PADDING_REQUIRED:\newline			padding_character = (uint8_t) &#039=&#039;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character_size = 1;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			base64_character_size = 2;\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			base64_character_size = 4;\newline			break;\newline\newline		default:\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: unsupported base64 variant.&quot,\newline			 function );\newline\newline			return( -1 );\newline	}\newline	stream_index = *base64_stream_index;\newline\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 1st base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet1,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 1st sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &gt base64_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	switch( base64_variant &amp 0xf0000000UL )\newline	{\newline		case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline			base64_character = base64_stream[ stream_index ];\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline			byte_stream_copy_to_uint16_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint16_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline			byte_stream_copy_to_uint32_big_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline\newline		case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline			byte_stream_copy_to_uint32_little_endian(\newline			 &amp( base64_stream[ stream_index ] ),\newline			 base64_character );\newline			break;\newline	}\newline	stream_index += base64_character_size;\newline\newline	if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline		 &quot%s: invalid 2nd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libuna_base64_character_copy_to_sixtet(\newline	     (uint8_t) base64_character,\newline	     &ampsixtet2,\newline	     base64_variant,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\newline		 &quot%s: unable to copy base64 character to 2nd sixtet.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*padding_size = 2;\newline\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 3rd base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet3 = 0;\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet3,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 3rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 3rd base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( ( stream_index + base64_character_size ) &lt= base64_stream_size )\newline	{\newline		switch( base64_variant &amp 0xf0000000UL )\newline		{\newline			case LIBUNA_BASE64_VARIANT_ENCODING_BYTE_STREAM:\newline				base64_character = base64_stream[ stream_index ];\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_BIG_ENDIAN:\newline				byte_stream_copy_to_uint16_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF16_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint16_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_BIG_ENDIAN:\newline				byte_stream_copy_to_uint32_big_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline\newline			case LIBUNA_BASE64_VARIANT_ENCODING_UTF32_LITTLE_ENDIAN:\newline				byte_stream_copy_to_uint32_little_endian(\newline				 &amp( base64_stream[ stream_index ] ),\newline				 base64_character );\newline				break;\newline		}\newline		stream_index += base64_character_size;\newline\newline		if( ( base64_character &amp 0xffffff00UL ) != 0 )\newline		{\newline			libcerror_error_set(\newline			 error,\newline			 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline			 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline			 &quot%s: invalid 4th base64 character.&quot,\newline			 function );\newline\newline			return( -1 );\newline		}\newline		if( ( padding_character != 0 )\newline		 &amp&amp ( base64_character == (uint32_t) padding_character ) )\newline		{\newline			sixtet4 = 0;\newline		}\newline		else if( *padding_size &gt 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4th base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline		}\newline		else if( libuna_base64_character_copy_to_sixtet(\newline		          (uint8_t) base64_character,\newline		          &ampsixtet4,\newline		          base64_variant,\newline		          error ) != 1 )\newline		{\newline			if( padding_character != 0 )\newline			{\newline				libcerror_error_set(\newline				 error,\newline				 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline				 LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\newline				 &quot%s: invalid 4rd base64 sixtet.&quot,\newline				 function );\newline\newline				return( -1 );\newline			}\newline			libcerror_error_free(\newline			 error );\newline		}\newline		else\newline		{\newline			*padding_size -= 1;\newline		}\newline	}\newline	else if( padding_character != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: missing 4th base64 character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*base64_triplet   = sixtet1;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet2;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet3;\newline	*base64_triplet &lt&lt= 6;\newline	*base64_triplet  |= sixtet4;\newline\newline	*base64_stream_index = stream_index;\newline\newline	return( 1 );\newline}\newline","Copies a base64 triplet from a base64 stream\newline \newline The padding size will still be set to indicate the number of\newline sixtets in the triplet\newline \newline Returns 1 if successful or -1 on error\newline \newline","1851940","concat-deps.c","static void emit_single_boost_header(void)\newline{\newline#define BOOST_TARGET &quot/UnpackedTarball/boost.done&quot\newline    fprintf(stdout, &quot%s&quot BOOST_TARGET &quot &quot, work_dir);\newline}\newline","\newline We collapse tens of internal boost headers to the unpacked target, such\newline that you can re-compile / install boost and all is well.\newline \newline","4938294","xmu.c","int XmuPrintDefaultErrorMessage (Display *dpy, XErrorEvent *event, FILE *fp)\newline{\newline    char buffer[BUFSIZ];\newline    char mesg[BUFSIZ];\newline    char number[32];\newline    char *mtype = &quotXlibMessage&quot;\newline    _XExtension *ext = (_XExtension *)NULL;\newline    XGetErrorText(dpy, event-&gterror_code, buffer, BUFSIZ);\newline    XGetErrorDatabaseText(dpy, mtype, &quotXError&quot, &quotX Error&quot, mesg, BUFSIZ);\newline    fprintf(fp, &quot%s:  %s\\n  &quot, mesg, buffer);\newline    XGetErrorDatabaseText(dpy, mtype, &quotMajorCode&quot, &quotRequest Major code %d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtrequest_code);\newline    if (event-&gtrequest_code &lt 128) {\newline	sprintf(number, &quot%d&quot, event-&gtrequest_code);\newline	XGetErrorDatabaseText(dpy, &quotXRequest&quot, number, &quot&quot, buffer, BUFSIZ);\newline    } else {\newline	/* XXX this is non-portable */\newline	for (ext = dpy-&gtext_procs;\newline	     ext &amp&amp (ext-&gtcodes.major_opcode != event-&gtrequest_code);\newline	     ext = ext-&gtnext)\newline	  ;\newline	if (ext)\newline	    strcpy(buffer, ext-&gtname);\newline	else\newline	    buffer[0] = &#039\\0&#039;\newline    }\newline    fprintf(fp, &quot (%s)&quot, buffer);\newline    fputs(&quot\\n  &quot, fp);\newline#if (XtSpecificationRelease &gt= 5)\newline    if (event-&gtrequest_code &gt= 128) {\newline	XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			      mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtminor_code);\newline	if (ext) {\newline	    sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline	    XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline	    fprintf(fp, &quot (%s)&quot, buffer);\newline	}\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline    if (event-&gterror_code &gt= 128) {\newline	/* let extensions try to print the values */\newline	/* XXX this is non-portable code */\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_values)\newline		(*ext-&gterror_values)(dpy, event, fp);\newline	}\newline	/* the rest is a fallback, providing a simple default */\newline	/* kludge, try to find the extension that caused it */\newline	buffer[0] = &#039\\0&#039;\newline	for (ext = dpy-&gtext_procs; ext; ext = ext-&gtnext) {\newline	    if (ext-&gterror_string)\newline		(*ext-&gterror_string)(dpy, event-&gterror_code, &ampext-&gtcodes,\newline				     buffer, BUFSIZ);\newline	    if (buffer[0])\newline		break;\newline	}\newline	if (buffer[0])\newline	    sprintf(buffer, &quot%s.%d&quot, ext-&gtname,\newline		    event-&gterror_code - ext-&gtcodes.first_error);\newline	else\newline	    strcpy(buffer, &quotValue&quot);\newline	XGetErrorDatabaseText(dpy, mtype, buffer, &quot&quot, mesg, BUFSIZ);\newline	if (*mesg) {\newline	    fprintf(fp, mesg, event-&gtresourceid);\newline	    fputs(&quot\\n  &quot, fp);\newline	}\newline    } else if ((event-&gterror_code == BadWindow) ||\newline	       (event-&gterror_code == BadPixmap) ||\newline	       (event-&gterror_code == BadCursor) ||\newline	       (event-&gterror_code == BadFont) ||\newline	       (event-&gterror_code == BadDrawable) ||\newline	       (event-&gterror_code == BadColor) ||\newline	       (event-&gterror_code == BadGC) ||\newline	       (event-&gterror_code == BadIDChoice) ||\newline	       (event-&gterror_code == BadValue) ||\newline	       (event-&gterror_code == BadAtom)) {\newline	if (event-&gterror_code == BadValue)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotValue&quot, &quotValue 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else if (event-&gterror_code == BadAtom)\newline	    XGetErrorDatabaseText(dpy, mtype, &quotAtomID&quot, &quotAtomID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	else\newline	    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline				  mesg, BUFSIZ);\newline	fprintf(fp, mesg, event-&gtresourceid);\newline	fputs(&quot\\n  &quot, fp);\newline    }\newline#elif (XtSpecificationRelease == 4)\newline    XGetErrorDatabaseText(dpy, mtype, &quotMinorCode&quot, &quotRequest Minor code %d&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtminor_code);\newline    fputs(&quot\\n  &quot, fp);\newline    if (ext) {\newline      sprintf(mesg, &quot%s.%d&quot, ext-&gtname, event-&gtminor_code);\newline      XGetErrorDatabaseText(dpy, &quotXRequest&quot, mesg, &quot&quot, buffer, BUFSIZ);\newline      fprintf(fp, &quot (%s)&quot, buffer);\newline    }\newline    XGetErrorDatabaseText(dpy, mtype, &quotResourceID&quot, &quotResourceID 0x%x&quot,\newline			  mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtresourceid);\newline    fputs(&quot\\n  &quot, fp);\newline#else\newlineERROR! Unsupported release of X11\newline#endif\newline    XGetErrorDatabaseText(dpy, mtype, &quotErrorSerial&quot, &quotError Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, event-&gtserial);\newline    fputs(&quot\\n  &quot, fp);\newline    XGetErrorDatabaseText(dpy, mtype, &quotCurrentSerial&quot, &quotCurrent Serial #%d&quot,\newline	mesg, BUFSIZ);\newline    fprintf(fp, mesg, NextRequest(dpy)-1);\newline    fputs(&quot\\n&quot, fp);\newline    if (event-&gterror_code == BadImplementation) return 0;\newline    return 1;\newline}\newline","\newline XmuPrintDefaultErrorMessage - print a nice error that looks like the usual\newline message. Return 1 if the caller should consider exiting, else 0.\newline \newline","772479","coverity_model.c","void *memccpy(void *dest, const void *src, int c, size_t n)\newline{\newline	const char *s = src;\newline	char *d = dest;\newline\newline	while (n-- &gt 0)\newline		if ((*d++ = *s++) == (char) c)\newline			return d;\newline\newline	return 0;\newline}\newline","simple_memccpy() from glibc \newline","1305953","filter_chain.c","int fc_register_match(const char *name, match_proc_t proc) /* {{{ */\newline{\newline  fc_match_t *m;\newline\newline  DEBUG(&quotfc_register_match (%s);&quot, name);\newline\newline  m = calloc(1, sizeof(*m));\newline  if (m == NULL)\newline    return (-ENOMEM);\newline\newline  sstrncpy(m-&gtname, name, sizeof(m-&gtname));\newline  memcpy(&ampm-&gtproc, &ampproc, sizeof(m-&gtproc));\newline\newline  if (match_list_head == NULL) {\newline    match_list_head = m;\newline  } else {\newline    fc_match_t *ptr;\newline\newline    ptr = match_list_head;\newline    while (ptr-&gtnext != NULL)\newline      ptr = ptr-&gtnext;\newline\newline    ptr-&gtnext = m;\newline  }\newline\newline  return (0);\newline} /* }}} int fc_register_match */\newline","Add a match to list of available matches. \newline","12245","rxstack.c","Client *get_new_client( )\newline{\newline   Client *retval = (Client *)malloc( sizeof( Client ) ) ;\newline\newline   if ( retval == NULL )\newline      return NULL ;\newline   memset( retval, 0, sizeof( Client ) ) ;\newline   retval-&gtsocket = -1 ;\newline   retval-&gtdeadline.milli = -1 ; /* deadline not used --&gt infinite timeout */\newline\newline   retval-&gtnext = clients ;\newline   if ( clients != NULL )\newline      clients-&gtprev = retval ;\newline   clients = retval ;\newline   return retval ;\newline}\newline","Creates a new client and appends it in front of the current clients.\newline Don&#039t forget to set a default_queue and the socket at once.\newline \newline","6007706","dfinscmp.c","static void CloseDefinstancesFiles(\newline  void *theEnv,\newline  FILE *moduleFile,\newline  FILE *definstancesFile,\newline  int maxIndices)\newline  {\newline   int count = maxIndices;\newline   int arrayVersion = 0;\newline\newline   if (definstancesFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,definstancesFile,&ampcount,&amparrayVersion,\newline                                         maxIndices,NULL,NULL);\newline     }\newline\newline   if (moduleFile != NULL)\newline     {\newline      count = maxIndices;\newline      CloseFileIfNeeded(theEnv,moduleFile,&ampcount,&amparrayVersion,maxIndices,NULL,NULL);\newline     }\newline  }\newline","\newlineNAME : CloseDefinstancesFiles\newlineDESCRIPTION : Closes construct compiler files\newlinefor definstances structures\newlineINPUTS : 1) The definstances module file\newline2) The definstances structure file\newline3) The maximum number of indices\newlineallowed in an array\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Files closed\newlineNOTES : None\newline \newline","1085640","pns.c","static INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\newline                                   uint8_t sub,\newline                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\newline{\newline#ifndef FIXED_POINT\newline    uint16_t i;\newline    real_t energy = 0.0;\newline\newline    real_t scale = (real_t)1.0/(real_t)size;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\newline        spec[i] = tmp;\newline        energy += tmp*tmp;\newline    }\newline\newline    scale = (real_t)1.0/(real_t)sqrt(energy);\newline    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\newline    for (i = 0; i &lt size; i++)\newline    {\newline        spec[i] *= scale;\newline    }\newline#else\newline    uint16_t i;\newline    real_t energy = 0, scale;\newline    int32_t exp, frac;\newline\newline    for (i = 0; i &lt size; i++)\newline    {\newline        /* this can be replaced by a 16 bit random generator!!!! */\newline        real_t tmp = (int32_t)ne_rng(__r1, __r2);\newline        if (tmp &lt 0)\newline            tmp = -(tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline        else\newline            tmp = (tmp &amp ((1&lt&lt(REAL_BITS-1))-1));\newline\newline        energy += MUL_R(tmp,tmp);\newline\newline        spec[i] = tmp;\newline    }\newline\newline    energy = fp_sqrt(energy);\newline    if (energy &gt 0)\newline    {\newline        scale = DIV(REAL_CONST(1),energy);\newline\newline        exp = scale_factor &gt&gt 2;\newline        frac = scale_factor &amp 3;\newline\newline        /* IMDCT pre-scaling */\newline        exp -= sub;\newline\newline        if (exp &lt 0)\newline            scale &gt&gt= -exp;\newline        else\newline            scale &lt&lt= exp;\newline\newline        if (frac)\newline            scale = MUL_C(scale, pow2_table[frac]);\newline\newline        for (i = 0; i &lt size; i++)\newline        {\newline            spec[i] = MUL_R(spec[i], scale);\newline        }\newline    }\newline#endif\newline}\newline","The function gen_rand_vector(addr, size) generates a vector of length\newline&ltsize&gt with signed random values of average energy MEAN_NRG per random\newlinevalue. A suitable random number generator can be realized using one\newlinemultiplication/accumulation per random value.\newline \newline","12911","files.c","void find_shared_library(const tsd_t *TSD, const char *inname, const char *inenv, char *retname)\newline{\newline   char *paths;\newline   char outname[REXX_PATH_MAX+1];\newline   char *env_path;\newline\newline   strcpy( retname, inname );\newline   env_path = mygetenv( TSD, inenv, NULL, 0 ); /* fixes bug 595293 */\newline   if ( !env_path )\newline      return;\newline   paths = env_path;\newline   while ( paths &amp&amp *paths )\newline   {\newline      int pathlen;\newline      char *sep;\newline\newline      sep = strchr( paths, PATH_SEPARATOR );\newline      pathlen = sep ? sep-paths : strlen( paths );\newline      strncpy( outname, paths, pathlen );\newline      outname[pathlen] = 0;\newline\newline      if ( ( pathlen &gt 0 ) &amp&amp ( outname[pathlen-1] != FILE_SEPARATOR ) )\newline         strcat( outname, FILE_SEPARATOR_STR );\newline      strcat( outname, inname );\newline      paths = sep ? sep+1 : 0; /* set up for next pass */\newline      if ( access( outname,F_OK ) == 0)\newline      {\newline         strcpy( retname,outname );\newline         break;\newline      }\newline   }\newline   FreeTSD( env_path );\newline   return;\newline}\newline","\newline find_shared_library is used for HP/UX purpose only.\newline It looks for the file inname in the content of the environment variable\newline inenv and puts the result into retname. retname has to have a size of\newline at least REXX_PATH_MAX+1.\newline retname becomes inname if no other file is found.\newline \newline","","","","on","","on","","on","","","","on","","","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","perform http initialization","set up the class that handles loading of tcl classes","Sets the file pointer into the IDS file.","{}","Copies a base64 triplet from a base64 stream","{}","print a nice error that looks like the usualmessage.","{}","Add a match to list of available matches.","Creates a new client and appends it in front","Closes construct compiler filesfor definstances structures","{}","generates a vector","looks for the file","Find the dual simplex entering non-basic variable","Empties the selection.","divide rectangle idiv in the list","Creates a security identifier","sprintf into a fixed size buffer.","Attach a further pair of input and output","{}"
"391FPZIE4CMYGCMYKDBWLYE9BUHUHH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3FQ5JJ512LOEAW0QJZ789EYWB3YNKW","A3GYDQWF4X4NID","Approved","Wed Apr 17 13:43:51 PDT 2019","Wed Apr 17 13:53:58 PDT 2019","Fri Apr 19 13:53:58 PDT 2019","2019-04-19 20:54:21 UTC","","","607","100% (1/1)","100% (1/1)","100% (1/1)","5197779","mozplugger-helper.c","static void setSwallowMutexOwner(uint32_t hostId, uint32_t pid)\newline{\newline     unsigned long temp[2] = {hostId, pid};\newline\newline     D(&quotSetting swallow mutex owner, hostId = 0x%08X, pid=%u\\n&quot, \newline                                            (unsigned) hostId, (unsigned) pid); \newline     XChangeProperty(display, wattr.root, swallowMutex,\newline                        XA_INTEGER, 32, PropModeAppend,\newline                        (unsigned char*) (&amptemp), 2);\newline}\newline","\newline Set owner of mutex semaphore\newline \newline @param[in] hostId The ID of the new owner of the mutex\newline @param[in] pid The process ID of the mutex\newline \newline @return none\newline \newline \newline","283896","ematch.c","void rtnl_ematch_unlink(struct rtnl_ematch *ematch)\newline{\newline	NL_DBG(2, &quotunlinked ematch %p from any lists\\n&quot, ematch);\newline\newline	if (!nl_list_empty(&ampematch-&gte_childs))\newline		NL_DBG(1, &quotwarning: ematch %p with childs was unlinked\\n&quot,\newline			  ematch);\newline\newline	nl_list_del(&ampematch-&gte_list);\newline	nl_init_list_head(&ampematch-&gte_list);\newline}\newline","\newline Remove ematch from the list of ematches it is linked to.\newline @arg ematch ematch object\newline \newline","517677","memory.c","char *caml_alloc_for_heap (asize_t request)\newline{\newline  char *mem;\newline  void *block;\newline                                              Assert (request % Page_size == 0);\newline  mem = caml_aligned_malloc (request + sizeof (heap_chunk_head),\newline                             sizeof (heap_chunk_head), &ampblock);\newline  if (mem == NULL) return NULL;\newline  mem += sizeof (heap_chunk_head);\newline  Chunk_size (mem) = request;\newline  Chunk_block (mem) = block;\newline  return mem;\newline}\newline","Allocate a block of the requested size, to be passed to\newline[caml_add_to_heap] later.\newline[request] must be a multiple of [Page_size].\newline[caml_alloc_for_heap] returns NULL if the request cannot be satisfied.\newlineThe returned pointer is a hp, but the header must be initialized by\newlinethe caller.\newline \newline","1528478","charcnv.c","size_t convert_charset ( charset_t from_set, charset_t to_set, charset_t cap_charset, const char *src, size_t src_len, char *dest, size_t dest_len, u_int16_t *flags)\newline{\newline    size_t i_len, o_len;\newline    ucs2_t *u;\newline    ucs2_t buffer[MAXPATHLEN +2];\newline    ucs2_t buffer2[MAXPATHLEN +2];\newline\newline    lazy_initialize_conv();\newline\newline    /* convert from_set to UCS2 */\newline    if ((size_t)(-1) == ( o_len = pull_charset_flags( from_set, cap_charset, src, src_len,\newline                                                      (char *) buffer, sizeof(buffer) -2, flags)) ) {\newline        LOG(log_error, logtype_default, &quotConversion failed ( %s to CH_UCS2 )&quot, charset_name(from_set));\newline        return (size_t) -1;\newline    }\newline\newline    if ( o_len == 0)\newline        return o_len;\newline\newline    /* Do pre/decomposition */\newline    i_len = sizeof(buffer2) -2;\newline    u = buffer2;\newline    if (CHECK_FLAGS(flags, CONV_DECOMPOSE) || (charsets[to_set] &amp&amp (charsets[to_set]-&gtflags &amp CHARSET_DECOMPOSED)) ) {\newline        if ( (size_t)-1 == (i_len = decompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_PRECOMPOSE) || !charsets[from_set] || (charsets[from_set]-&gtflags &amp CHARSET_DECOMPOSED)) {\newline        if ( (size_t)-1 == (i_len = precompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else {\newline        u = buffer;\newline        i_len = o_len;\newline    }\newline    /* null terminate */\newline    u[i_len] = 0;\newline    u[i_len +1] = 0;\newline\newline    /* Do case conversions */\newline    if (CHECK_FLAGS(flags, CONV_TOUPPER)) {\newline        strupper_w(u);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_TOLOWER)) {\newline        strlower_w(u);\newline    }\newline\newline    /* Convert UCS2 to to_set */\newline    if ((size_t)(-1) == ( o_len = push_charset_flags( to_set, cap_charset, (char *)u, i_len, dest, dest_len, flags )) ) {\newline        LOG(log_error, logtype_default,\newline            &quotConversion failed (CH_UCS2 to %s):%s&quot, charset_name(to_set), strerror(errno));\newline        return (size_t) -1;\newline    }\newline    /* null terminate */\newline    dest[o_len] = 0;\newline    dest[o_len +1] = 0;\newline\newline    return o_len;\newline}\newline","\newline FIXME the size is a mess we really need a malloc/free logic\newline `dest size must be dest_len +2\newline \newline","2609159","isl_schedule_read.c","__isl_give isl_schedule *isl_schedule_read_from_file(isl_ctx *ctx, FILE *input)\newline{\newline	struct isl_stream *s;\newline	isl_schedule *schedule;\newline\newline	s = isl_stream_new_file(ctx, input);\newline	if (!s)\newline		return NULL;\newline	schedule = isl_stream_read_schedule(s);\newline	isl_stream_free(s);\newline\newline	return schedule;\newline}\newline","Read an isl_schedule from &quotinput&quot.\newline \newline","4357933","_colormap.c","Field _dxfeditor_to_opacity(Array opmap)\newline{\newline   int i,num_op,new_num,offset=0;\newline   Field opacity;\newline   float *op_pts,*op_data;\newline   Array a,b;\newline   Map *op;\newline\newline   opacity = NULL;\newline   /* if array is NULL create a default opacity field */\newline   if (!opmap){\newline      num_op = 2;\newline      opacity = (Field)_dxfcolorfield(NULL,NULL,num_op,0);\newline      a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline      b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline      op_pts = (float *)DXGetArrayData(a);\newline      op_data = (float *)DXGetArrayData(b);\newline      op_pts[0] = 0.0;\newline      op_pts[1] = 1.0;\newline      op_data[0] = op_data[1] = 1.0;\newline   }\newline      \newline   if (!DXGetArrayInfo(opmap,&ampnum_op,NULL,NULL,NULL,NULL))\newline      goto error;\newline   op = (Map *)DXGetArrayData(opmap);\newline   /* check for missing end points */\newline   new_num=num_op;\newline   if (op[num_op-1].level != 1.0)\newline      new_num++;\newline   if (op[0].level != 0.0) {\newline      offset = 1;\newline      new_num++;\newline   }\newline   \newline   /* build new field */\newline   opacity = (Field)_dxfcolorfield(NULL,NULL,new_num,0);\newline   a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline   b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline   op_pts = (float *)DXGetArrayData(a);\newline   op_data = (float *)DXGetArrayData(b);\newline   if (offset == 1){\newline      op_pts[0] = 0.0;\newline      op_data[0] = op[0].value;\newline   }\newline   if (op[num_op-1].level != 1.0){\newline      op_pts[new_num-1] = 1.0;\newline      op_data[new_num-1] = op[num_op-1].value;\newline   }\newline   for (i=0; i&ltnum_op; i++){\newline      op_pts[offset + i] = op[i].level;\newline      op_data[offset + i] = op[i].value;\newline   }\newline\newline   if (!DXEndField(opacity))\newline      goto error;\newline   \newline   return (Field)opacity;\newline\newlineerror:\newline   if (opacity) DXDelete((Object)opacity);\newline   return NULL;\newline}\newline","input the opacity positions array and the opacity field \newline will be returned\newline \newline","3630269","chunk.c","static	skip_alloc_t	*insert_address(void *address, const int free_b,\newline					const unsigned int tot_size)\newline{\newline  skip_alloc_t	*new_p;\newline  \newline  /* get a new entry */\newline  new_p = get_slot();\newline  if (new_p == NULL) {\newline    /* error code set in get_slot */\newline    return NULL;\newline  }\newline  if (free_b) {\newline    new_p-&gtsa_flags = ALLOC_FLAG_FREE;\newline  }\newline  else {\newline    new_p-&gtsa_flags = ALLOC_FLAG_USER;\newline  }\newline  new_p-&gtsa_mem = address;\newline  new_p-&gtsa_total_size = tot_size;\newline  \newline  /* now try and insert the slot into the skip-list */\newline  if (! insert_slot(new_p, free_b)) {\newline    /* Sanity check.  error code set in insert_slot(). */\newline    return NULL;\newline  }\newline  \newline  return new_p;\newline}\newline","\newline static skip_alloc_t insert_address\newline \newline DESCRIPTION:\newline \newline Insert an address entry into a skip list.\newline \newline RETURNS:\newline \newline Success - Valid slot pointer.\newline \newline Failure - NULL\newline \newline ARGUMENTS:\newline \newline address -&gt Address we are inserting into the address list.\newline \newline free_b -&gt Insert a free address in the free-size list otherwise it\newline will go into the used address list.\newline \newline tot_size -&gt Total size of the chunk that we are inserting into the\newline list.\newline \newline","3104274","dev_name.c","int nulldev(void)\newline{\newline	return (D_SUCCESS);\newline}\newline","\newline Routines placed in empty entries in the device tables\newline \newline","5197386","pam_chroot.c","int _pam_do_chroot(pam_handle_t *pamh, struct _pam_opts *opts) {\newline	int err,debug;\newline	char const *user;\newline\newline	debug = opts-&gtflags &amp _PAM_OPTS_DEBUG;\newline\newline	err = pam_get_user(pamh, &ampuser, NULL);\newline	if(PAM_CONV_AGAIN == err) {\newline		_pam_log(LOG_NOTICE, &quot$s: retry username lookup later&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_INCOMPLETE;\newline	} else if(PAM_SUCCESS != err) {\newline		_pam_log(LOG_ERR, &quot%s: can&#039t get username&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_SYSERR;\newline	}\newline\newline	if(opts-&gtchroot_dir) { /* overrides the conf file */\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: chrootdir (%s) specified, ignoring conf file&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir);\newline		}\newline		err = _PAM_CHROOT_OK;\newline	} else {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: reading config file (%s)&quot, opts-&gtmodule, opts-&gtconf);\newline		}\newline		err = _pam_get_chrootdir(user, opts);\newline	}\newline\newline	if(_PAM_CHROOT_OK == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: preparing to chroot()&quot, opts-&gtmodule);\newline		}\newline\newline		if(NULL == opts-&gtchroot_dir) {\newline			/* This is a state that I should never see.  If the user wasn&#039t in\newline			 * the conf file, then USERNOTFOUND should have been returned. */\newline			_pam_log(LOG_ERR,\newline					&quot%s: no chroot_dir set for \\&quot%s\\&quot&quot, opts-&gtmodule, user);\newline			return _PAM_CHROOT_INTERNALERR;\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_SECCHECKS) {\newline			if(0 != _pam_check_path_perms(opts-&gtchroot_dir, opts)) {\newline				_pam_log(LOG_ERR,\newline						&quot%s: chroot_dir \\&quot%s\\&quot failed security check&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline				return _PAM_CHROOT_SYSERR;\newline			}\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_NO_CHROOT) {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: no_chroot is set, skipping chroot(%s)&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		} else if(chdir(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chdir(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else if(chroot(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chroot(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: chroot(%s) ok&quot, opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		}\newline		return _PAM_CHROOT_OK;\newline	} else if(_PAM_CHROOT_USERNOTFOUND == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: no match for %s in %s&quot,\newline					opts-&gtmodule, user, opts-&gtconf);\newline		}\newline		return _PAM_CHROOT_USERNOTFOUND;\newline	} else {\newline		_pam_log(LOG_ERR,\newline				&quot%s: error determining chrootdir: user=\\&quot%s\\&quot, dir=\\&quot%s\\&quot&quot,\newline				opts-&gtmodule, user, opts-&gtchroot_dir);\newline		return err;\newline	}\newline}\newline","This is the workhorse function. All of the pam_sm_ functions should\newline initialize a _pam_opts struct with the command line args and flags,\newline then pass it to this function \newline","6626641","copt.c","static char *subst(char *pat)\newline{\newline  char buf[MAXLINE];\newline  char *cp, *cp1, *cp2, *varptr;\newline  long num;\newline  int i = 0;\newline  int j, pos;\newline\newline  while (*pat)\newline	if (pat[0] == &#039%&#039 &amp&amp isdigit(pat[1])) {\newline		/* Substitute with value of variable */\newline		cp = vars[pat[1] - &#0390&#039];\newline		while (cp != NULL &amp&amp *cp) {\newline			buf[i++] = *cp++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline		pat += 2;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039(&#039) {\newline		/* Substitute with expression */\newline		cp = pat + 2;\newline		if ((pat = strchr(cp, &#039)&#039)) == NULL || pat - cp &lt= 0)\newline			num = 0;\newline		else\newline			num = eval(cp, pat - cp);\newline		if (i &gt= MAXLINE - 20) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline		i += sprintf(&ampbuf[i], &quot%s$%lx&quot, num &lt 0 ? &quot-&quot : &quot&quot, labs(num));\newline		pat++;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039=&#039) {\newline		/* Substitute with converted variable */\newline		/* First seperate all parts of the pattern string */\newline		cp = pat + 2;\newline		cp1 = cp2 = varptr = NULL;\newline		if (*cp == &#039[&#039) {\newline			cp1 = ++cp;\newline			while (*cp &amp&amp *cp != &#039]&#039)\newline				cp++;\newline			if (cp[0] == &#039]&#039 &amp&amp cp[1] == &#039[&#039) {\newline				cp += 2;\newline				cp2 = cp;\newline				while (*cp &amp&amp *cp != &#039]&#039)\newline					cp++;\newline				if (cp[0] == &#039]&#039 &amp&amp isdigit(cp[1]))\newline					 varptr = vars[cp[1] - &#0390&#039];\newline			}\newline		}\newline		if (cp1 == NULL || cp2 == NULL || varptr == NULL) {\newline			buf[i++] = *pat++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline			continue;\newline		}\newline		pat = cp + 2;\newline		/* Now scan through the first string to find variable value */\newline		cp1--;\newline		pos = 0;\newline		while (*cp1 != &#039]&#039) {\newline			cp1++;\newline			j = strcspn(cp1, &quot|]&quot);\newline			if (strlen(varptr) == j &amp&amp !strncmp(cp1, varptr, j))\newline				break;\newline			pos++;\newline			cp1 += j;\newline		}\newline		if (*cp1 == &#039]&#039)\newline			continue;\newline		/* Scan through the second string to find the conversion */\newline		cp2--;\newline		while (*cp2 != &#039]&#039 &amp&amp pos &gt 0) {\newline			cp2++;\newline			j = strcspn(cp2, &quot|]&quot);\newline			pos--;\newline			cp2 += j;\newline		}\newline		if (*cp2 == &#039]&#039 || pos != 0)\newline			continue;\newline		/* Insert conversion string into destination */\newline		cp2++;\newline		while (*cp2 != &#039|&#039 &amp&amp *cp2 != &#039]&#039) {\newline			buf[i++] = *cp2++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline	} else {\newline		buf[i++] = *pat++;\newline		if (i &gt= MAXLINE - 1) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline	}\newline\newline  buf[i] = &#039\\0&#039;\newline  return(install(buf, i));\newline}\newline","\newline Substitute variables in a string\newline \newline","3370483","htmlgenerator.cpp","void HtmlGenerator::generateAssociatedPropertyNotes(const FunctionNode* fn)\newline{\newline    if (fn-&gthasAssociatedProperties()) {\newline        out() &lt&lt &quot&ltp&gt&ltb&gtNote:&lt/b&gt &quot;\newline        PropNodeList propertyNodes = fn-&gtassociatedProperties();\newline        std::sort(propertyNodes.begin(), propertyNodes.end(), Node::nodeNameLessThan);\newline        foreach (const PropertyNode* pn, propertyNodes) {\newline            QString msg;\newline            switch (pn-&gtrole(fn)) {\newline            case PropertyNode::Getter:\newline                msg = QStringLiteral(&quotGetter function &quot);\newline                break;\newline            case PropertyNode::Setter:\newline                msg = QStringLiteral(&quotSetter function &quot);\newline                break;\newline            case PropertyNode::Resetter:\newline                msg = QStringLiteral(&quotResetter function &quot);\newline                break;\newline            case PropertyNode::Notifier:\newline                msg = QStringLiteral(&quotNotifier signal &quot);\newline                break;\newline            default:\newline                break;\newline            }\newline            QString link = linkForNode(pn, 0);\newline            out() &lt&lt msg &lt&lt &quotfor property &lta href=\\&quot&quot &lt&lt link &lt&lt &quot\\&quot&gt&quot &lt&lt pn-&gtname() &lt&lt &quot&lt/a&gt. &quot;\newline        }\newline        out() &lt&lt &quot&lt/p&gt&quot;\newline    }\newline}\newline","!\newlineGenerates bold Note lines that explain how function \\a fn\newlineis associated with each of its associated properties.\newline \newline","5084075","mock_buckets.c","apr_status_t serf_bucket_mock_more_data_arrived(serf_bucket_t *bucket)\newline{\newline    mockbkt_context_t *ctx = bucket-&gtdata;\newline    mockbkt_action *action;\newline    apr_status_t status;\newline\newline    status = next_action(ctx);\newline    if (status)\newline        return status;\newline\newline    action = &ampctx-&gtactions[ctx-&gtcurrent_action];\newline    if (ctx-&gtremaining_data == 0 &amp&amp action-&gtstatus == APR_EAGAIN) {\newline        ctx-&gtremaining_times--;\newline        action-&gttimes--;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","An action { &quot&quot, 0, APR_EAGAIN } means that serf should exit serf_context_run\newlineand pass the buck back to the application. As long as no new data arrives,\newlinethis action remains active.\newline\newlineThis function allows the &#039application&#039 to trigger the arrival of more data.\newlineIf the current action is { &quot&quot, 0, APR_EAGAIN }, reduce the number of times\newlinethe action should run by one, and proceed with the next action if needed.\newline \newline","5206276","main.c","void new_vi(void)\newline{\newline   gs_apply_cheats();\newline\newline   main_check_inputs();\newline\newline#if 0\newline   timed_sections_refresh();\newline\newline   pause_loop();\newline\newline   apply_speed_limiter();\newline#endif\newline}\newline","called on vertical interrupt.\newline Allow the core to perform various things \newline","3684765","get_neigh.c","static void invalidate_route(struct routeinfo *routehead, unsigned short node)\newline{\newline	struct routeinfo *route, *cheaproute = NULL;\newline\newline	for (route = routehead-&gtnext; route; route=route-&gtnext)\newline	{\newline		if (route-&gtrouter == node)\newline		{\newline			route-&gtvalid = 0;\newline		}\newline	}\newline	set_lowest_cost_route(routehead, node);\newline}\newline","When a routing node goes down, look for alternative routes. \newline","77424","ola-rdm.cpp","void DisplayPIDsAndExit(uint16_t manufacturer_id,\newline                        const PidStoreHelper &amppid_helper) {\newline  vector&ltstring&gt pid_names;\newline  pid_helper.SupportedPids(manufacturer_id, &amppid_names);\newline  sort(pid_names.begin(), pid_names.end());\newline\newline  vector&ltstring&gt::const_iterator iter = pid_names.begin();\newline  for (; iter != pid_names.end(); ++iter) {\newline    cout &lt&lt *iter &lt&lt endl;\newline  }\newline  exit(ola::EXIT_OK);\newline}\newline","\newline Dump the list of known pids\newline \newline","216178","subtitle_free.c","void quvi_subtitle_free(quvi_subtitle_t handle)\newline{\newline  m_subtitle_free(handle);\newline}\newline","@brief Free all of memory used by a subtitle handle\newline@note If handle is NULL the function simply returns\newline@sa @ref parse_subtitle\newline@ingroup subprop\newline \newline","4322322","util.h","static inline void memcpy_safe(void *dst, const void *src, size_t n) {\newline        if (n == 0)\newline                return;\newline        assert(src);\newline        memcpy(dst, src, n);\newline}\newline","\newline Normal memcpy requires src to be nonnull. We do nothing if n is 0.\newline \newline","6372657","integck.c","static int recover_tested_fs(void)\newline{\newline	int ret;\newline	unsigned long flags;\newline	unsigned int  um_rorw, rorw2;\newline	struct mntent *mntent;\newline\newline	CHECK(chdir(&quot/&quot) == 0);\newline\newline	/* Choose what to do */\newline	um_rorw = random_no(2);\newline	rorw2 = random_no(2);\newline\newline	/*\newline	 * At this point we do not know for sure whether the tested FS is\newline	 * mounted, because the emulated power cut error could have happened\newline	 * while mounting in &#039remount_tested_fs()&#039.\newline	 */\newline	mntent = get_tested_fs_mntent();\newline	if (mntent)\newline		CHECK(umount(fsinfo.mount_point) != -1);\newline\newline	if (args.reattach)\newline		CHECK(reattach() == 0);\newline\newline	if (!um_rorw) {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/W&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline	} else {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags | MS_RDONLY,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/O&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, mounted R/O, but cannot re-mount it R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	if (rorw2) {\newline		flags = fsinfo.mount_flags | MS_RDONLY | MS_REMOUNT;\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotcannot re-mount %s R/O&quot, fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotremounted %s R/O, but cannot re-mount it back R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Recover the tested file-system from an emulated power cut failure by\newline unmounting it and mounting it again.\newline \newline","675719","read-dict.c","void add_empty_word(Dictionary const dict, X_node *x)\newline{\newline	Exp *zn, *an;\newline	E_list *elist, *flist;\newline	Exp_list eli = { NULL };\newline\newline	/* The left-wall already has ZZZ-. The right-wall will not arrive here. */\newline	if (MT_WALL == x-&gtword-&gtmorpheme_type) return;\newline\newline	/* Replace plain-word-exp by {ZZZ+} &amp (plain-word-exp) in each X_node.  */\newline	for(; NULL != x; x = x-&gtnext)\newline	{\newline		/* Ignore stems for now, decreases a little the overhead for\newline		 * stem-suffix languages. */\newline		if (is_stem(x-&gtstring)) continue; /* Avoid an unneeded overhead. */\newline		//lgdebug(+0, &quotProcessing &#039%s&#039\\n&quot, x-&gtstring);\newline\newline		/* zn points at {ZZZ+} */\newline		zn = Exp_create(&ampeli);\newline		zn-&gtdir = &#039+&#039;\newline		zn-&gtu.string = string_set_add(EMPTY_CONNECTOR, dict-&gtstring_set);\newline		zn-&gtmulti = false;\newline		zn-&gttype = CONNECTOR_type;\newline		zn-&gtcost = 0.0;\newline		zn = make_optional_node(&ampeli, zn);\newline\newline		/* flist is plain-word-exp */\newline		flist = (E_list *) xalloc(sizeof(E_list));\newline		flist-&gtnext = NULL;\newline		flist-&gte = x-&gtexp;\newline\newline		/* elist is {ZZZ+} , (plain-word-exp) */\newline		elist = (E_list *) xalloc(sizeof(E_list));\newline		elist-&gtnext = flist;\newline		elist-&gte = zn;\newline\newline		/* an will be {ZZZ+} &amp (plain-word-exp) */\newline		an = Exp_create(&ampeli);\newline		an-&gttype = AND_type;\newline		an-&gtcost = 0.0;\newline		an-&gtu.l = elist;\newline\newline		x-&gtexp = an;\newline	}\newline}\newline","Insert ZZZ+ connectors.\newline This function was mainly used to support using empty-words, a concept\newline that has been eliminated. However, it is still used to support linking of\newline quotes that don&#039t get the QUc/QUd links.\newline \newline","6062221","mkeot.c","static bool read_2be_signed(FILE *f, short *x)\newline{\newline  unsigned char s[2];\newline  union {short s; unsigned short u;} h;\newline\newline  if (fread(s, 1, 2, f) != 2) return false;\newline  h.u = (s[0] &lt&lt 8) + s[1];\newline  *x = h.s;\newline  return true;\newline}\newline","read_2be_signed -- read a big endian short \newline","1805380","sha1.c","void MYSQL_SHA1Update(MYSQL_SHA1_CTX * context, const unsigned char *input,\newline			   size_t inputLen)\newline{\newline	unsigned int i, index, partLen;\newline\newline	/* Compute number of bytes mod 64 */\newline	index = (unsigned int) ((context-&gtcount[0] &gt&gt 3) &amp 0x3F);\newline\newline	/* Update number of bits */\newline	if ((context-&gtcount[0] += ((uint32) inputLen &lt&lt 3))\newline		&lt ((uint32) inputLen &lt&lt 3))\newline		context-&gtcount[1]++;\newline	context-&gtcount[1] += ((uint32) inputLen &gt&gt 29);\newline\newline	partLen = 64 - index;\newline\newline	/* Transform as many times as possible.\newline	 */\newline	if (inputLen &gt= partLen) {\newline		memcpy\newline			((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) input, partLen);\newline		SHA1Transform(context-&gtstate, context-&gtbuffer);\newline\newline		for (i = partLen; i + 63 &lt inputLen; i += 64)\newline			SHA1Transform(context-&gtstate, &ampinput[i]);\newline\newline		index = 0;\newline	} else\newline		i = 0;\newline\newline	/* Buffer remaining input */\newline	memcpy\newline		((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) &amp input[i],\newline		 inputLen - i);\newline}\newline","{{{ MYSQL_SHA1Update\newlineSHA1 block update operation. Continues an SHA1 message-digest\newlineoperation, processing another message block, and updating the\newlinecontext.\newline \newline","","","","","","","","","","","","","","","","on","","","","","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","","on","on","on","on","","Set owner of mutex semaphore","Substitute variables in a string","Generates bold Note lines","allows the 'application' to trigger the arrival of more data.","Allow the core to perform various things","look for alternative routes.","Dump the list of known pids","Free all of memory used by a subtitle handle","Normal memcpy","Recover the tested file-system from an emulated power cut failure","support using empty-words,","Remove ematch from the list of ematches it is linked to.","read a big endian short","MYSQL_SHA1UpdateSHA1 block update operation.","Allocate a block of the requested size,","{}","Read an isl_schedule from ""input"".","input the opacity positions array and the opacity field will be returned","Insert an address entry into a skip list.","placed in empty entries in the device tables","{}"
"391FPZIE4CMYGCMYKDBWLYE9BUHUHH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3ND9UOO81K2FHWRMW0AWKXO2TEPWLF","AK1X37UFDPT4I","Approved","Wed Apr 17 12:27:43 PDT 2019","Wed Apr 17 12:32:03 PDT 2019","Fri Apr 19 12:32:03 PDT 2019","2019-04-19 19:32:21 UTC","","","260","100% (51/51)","100% (51/51)","100% (51/51)","5197779","mozplugger-helper.c","static void setSwallowMutexOwner(uint32_t hostId, uint32_t pid)\newline{\newline     unsigned long temp[2] = {hostId, pid};\newline\newline     D(&quotSetting swallow mutex owner, hostId = 0x%08X, pid=%u\\n&quot, \newline                                            (unsigned) hostId, (unsigned) pid); \newline     XChangeProperty(display, wattr.root, swallowMutex,\newline                        XA_INTEGER, 32, PropModeAppend,\newline                        (unsigned char*) (&amptemp), 2);\newline}\newline","\newline Set owner of mutex semaphore\newline \newline @param[in] hostId The ID of the new owner of the mutex\newline @param[in] pid The process ID of the mutex\newline \newline @return none\newline \newline \newline","283896","ematch.c","void rtnl_ematch_unlink(struct rtnl_ematch *ematch)\newline{\newline	NL_DBG(2, &quotunlinked ematch %p from any lists\\n&quot, ematch);\newline\newline	if (!nl_list_empty(&ampematch-&gte_childs))\newline		NL_DBG(1, &quotwarning: ematch %p with childs was unlinked\\n&quot,\newline			  ematch);\newline\newline	nl_list_del(&ampematch-&gte_list);\newline	nl_init_list_head(&ampematch-&gte_list);\newline}\newline","\newline Remove ematch from the list of ematches it is linked to.\newline @arg ematch ematch object\newline \newline","517677","memory.c","char *caml_alloc_for_heap (asize_t request)\newline{\newline  char *mem;\newline  void *block;\newline                                              Assert (request % Page_size == 0);\newline  mem = caml_aligned_malloc (request + sizeof (heap_chunk_head),\newline                             sizeof (heap_chunk_head), &ampblock);\newline  if (mem == NULL) return NULL;\newline  mem += sizeof (heap_chunk_head);\newline  Chunk_size (mem) = request;\newline  Chunk_block (mem) = block;\newline  return mem;\newline}\newline","Allocate a block of the requested size, to be passed to\newline[caml_add_to_heap] later.\newline[request] must be a multiple of [Page_size].\newline[caml_alloc_for_heap] returns NULL if the request cannot be satisfied.\newlineThe returned pointer is a hp, but the header must be initialized by\newlinethe caller.\newline \newline","1528478","charcnv.c","size_t convert_charset ( charset_t from_set, charset_t to_set, charset_t cap_charset, const char *src, size_t src_len, char *dest, size_t dest_len, u_int16_t *flags)\newline{\newline    size_t i_len, o_len;\newline    ucs2_t *u;\newline    ucs2_t buffer[MAXPATHLEN +2];\newline    ucs2_t buffer2[MAXPATHLEN +2];\newline\newline    lazy_initialize_conv();\newline\newline    /* convert from_set to UCS2 */\newline    if ((size_t)(-1) == ( o_len = pull_charset_flags( from_set, cap_charset, src, src_len,\newline                                                      (char *) buffer, sizeof(buffer) -2, flags)) ) {\newline        LOG(log_error, logtype_default, &quotConversion failed ( %s to CH_UCS2 )&quot, charset_name(from_set));\newline        return (size_t) -1;\newline    }\newline\newline    if ( o_len == 0)\newline        return o_len;\newline\newline    /* Do pre/decomposition */\newline    i_len = sizeof(buffer2) -2;\newline    u = buffer2;\newline    if (CHECK_FLAGS(flags, CONV_DECOMPOSE) || (charsets[to_set] &amp&amp (charsets[to_set]-&gtflags &amp CHARSET_DECOMPOSED)) ) {\newline        if ( (size_t)-1 == (i_len = decompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_PRECOMPOSE) || !charsets[from_set] || (charsets[from_set]-&gtflags &amp CHARSET_DECOMPOSED)) {\newline        if ( (size_t)-1 == (i_len = precompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else {\newline        u = buffer;\newline        i_len = o_len;\newline    }\newline    /* null terminate */\newline    u[i_len] = 0;\newline    u[i_len +1] = 0;\newline\newline    /* Do case conversions */\newline    if (CHECK_FLAGS(flags, CONV_TOUPPER)) {\newline        strupper_w(u);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_TOLOWER)) {\newline        strlower_w(u);\newline    }\newline\newline    /* Convert UCS2 to to_set */\newline    if ((size_t)(-1) == ( o_len = push_charset_flags( to_set, cap_charset, (char *)u, i_len, dest, dest_len, flags )) ) {\newline        LOG(log_error, logtype_default,\newline            &quotConversion failed (CH_UCS2 to %s):%s&quot, charset_name(to_set), strerror(errno));\newline        return (size_t) -1;\newline    }\newline    /* null terminate */\newline    dest[o_len] = 0;\newline    dest[o_len +1] = 0;\newline\newline    return o_len;\newline}\newline","\newline FIXME the size is a mess we really need a malloc/free logic\newline `dest size must be dest_len +2\newline \newline","2609159","isl_schedule_read.c","__isl_give isl_schedule *isl_schedule_read_from_file(isl_ctx *ctx, FILE *input)\newline{\newline	struct isl_stream *s;\newline	isl_schedule *schedule;\newline\newline	s = isl_stream_new_file(ctx, input);\newline	if (!s)\newline		return NULL;\newline	schedule = isl_stream_read_schedule(s);\newline	isl_stream_free(s);\newline\newline	return schedule;\newline}\newline","Read an isl_schedule from &quotinput&quot.\newline \newline","4357933","_colormap.c","Field _dxfeditor_to_opacity(Array opmap)\newline{\newline   int i,num_op,new_num,offset=0;\newline   Field opacity;\newline   float *op_pts,*op_data;\newline   Array a,b;\newline   Map *op;\newline\newline   opacity = NULL;\newline   /* if array is NULL create a default opacity field */\newline   if (!opmap){\newline      num_op = 2;\newline      opacity = (Field)_dxfcolorfield(NULL,NULL,num_op,0);\newline      a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline      b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline      op_pts = (float *)DXGetArrayData(a);\newline      op_data = (float *)DXGetArrayData(b);\newline      op_pts[0] = 0.0;\newline      op_pts[1] = 1.0;\newline      op_data[0] = op_data[1] = 1.0;\newline   }\newline      \newline   if (!DXGetArrayInfo(opmap,&ampnum_op,NULL,NULL,NULL,NULL))\newline      goto error;\newline   op = (Map *)DXGetArrayData(opmap);\newline   /* check for missing end points */\newline   new_num=num_op;\newline   if (op[num_op-1].level != 1.0)\newline      new_num++;\newline   if (op[0].level != 0.0) {\newline      offset = 1;\newline      new_num++;\newline   }\newline   \newline   /* build new field */\newline   opacity = (Field)_dxfcolorfield(NULL,NULL,new_num,0);\newline   a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline   b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline   op_pts = (float *)DXGetArrayData(a);\newline   op_data = (float *)DXGetArrayData(b);\newline   if (offset == 1){\newline      op_pts[0] = 0.0;\newline      op_data[0] = op[0].value;\newline   }\newline   if (op[num_op-1].level != 1.0){\newline      op_pts[new_num-1] = 1.0;\newline      op_data[new_num-1] = op[num_op-1].value;\newline   }\newline   for (i=0; i&ltnum_op; i++){\newline      op_pts[offset + i] = op[i].level;\newline      op_data[offset + i] = op[i].value;\newline   }\newline\newline   if (!DXEndField(opacity))\newline      goto error;\newline   \newline   return (Field)opacity;\newline\newlineerror:\newline   if (opacity) DXDelete((Object)opacity);\newline   return NULL;\newline}\newline","input the opacity positions array and the opacity field \newline will be returned\newline \newline","3630269","chunk.c","static	skip_alloc_t	*insert_address(void *address, const int free_b,\newline					const unsigned int tot_size)\newline{\newline  skip_alloc_t	*new_p;\newline  \newline  /* get a new entry */\newline  new_p = get_slot();\newline  if (new_p == NULL) {\newline    /* error code set in get_slot */\newline    return NULL;\newline  }\newline  if (free_b) {\newline    new_p-&gtsa_flags = ALLOC_FLAG_FREE;\newline  }\newline  else {\newline    new_p-&gtsa_flags = ALLOC_FLAG_USER;\newline  }\newline  new_p-&gtsa_mem = address;\newline  new_p-&gtsa_total_size = tot_size;\newline  \newline  /* now try and insert the slot into the skip-list */\newline  if (! insert_slot(new_p, free_b)) {\newline    /* Sanity check.  error code set in insert_slot(). */\newline    return NULL;\newline  }\newline  \newline  return new_p;\newline}\newline","\newline static skip_alloc_t insert_address\newline \newline DESCRIPTION:\newline \newline Insert an address entry into a skip list.\newline \newline RETURNS:\newline \newline Success - Valid slot pointer.\newline \newline Failure - NULL\newline \newline ARGUMENTS:\newline \newline address -&gt Address we are inserting into the address list.\newline \newline free_b -&gt Insert a free address in the free-size list otherwise it\newline will go into the used address list.\newline \newline tot_size -&gt Total size of the chunk that we are inserting into the\newline list.\newline \newline","3104274","dev_name.c","int nulldev(void)\newline{\newline	return (D_SUCCESS);\newline}\newline","\newline Routines placed in empty entries in the device tables\newline \newline","5197386","pam_chroot.c","int _pam_do_chroot(pam_handle_t *pamh, struct _pam_opts *opts) {\newline	int err,debug;\newline	char const *user;\newline\newline	debug = opts-&gtflags &amp _PAM_OPTS_DEBUG;\newline\newline	err = pam_get_user(pamh, &ampuser, NULL);\newline	if(PAM_CONV_AGAIN == err) {\newline		_pam_log(LOG_NOTICE, &quot$s: retry username lookup later&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_INCOMPLETE;\newline	} else if(PAM_SUCCESS != err) {\newline		_pam_log(LOG_ERR, &quot%s: can&#039t get username&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_SYSERR;\newline	}\newline\newline	if(opts-&gtchroot_dir) { /* overrides the conf file */\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: chrootdir (%s) specified, ignoring conf file&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir);\newline		}\newline		err = _PAM_CHROOT_OK;\newline	} else {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: reading config file (%s)&quot, opts-&gtmodule, opts-&gtconf);\newline		}\newline		err = _pam_get_chrootdir(user, opts);\newline	}\newline\newline	if(_PAM_CHROOT_OK == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: preparing to chroot()&quot, opts-&gtmodule);\newline		}\newline\newline		if(NULL == opts-&gtchroot_dir) {\newline			/* This is a state that I should never see.  If the user wasn&#039t in\newline			 * the conf file, then USERNOTFOUND should have been returned. */\newline			_pam_log(LOG_ERR,\newline					&quot%s: no chroot_dir set for \\&quot%s\\&quot&quot, opts-&gtmodule, user);\newline			return _PAM_CHROOT_INTERNALERR;\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_SECCHECKS) {\newline			if(0 != _pam_check_path_perms(opts-&gtchroot_dir, opts)) {\newline				_pam_log(LOG_ERR,\newline						&quot%s: chroot_dir \\&quot%s\\&quot failed security check&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline				return _PAM_CHROOT_SYSERR;\newline			}\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_NO_CHROOT) {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: no_chroot is set, skipping chroot(%s)&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		} else if(chdir(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chdir(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else if(chroot(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chroot(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: chroot(%s) ok&quot, opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		}\newline		return _PAM_CHROOT_OK;\newline	} else if(_PAM_CHROOT_USERNOTFOUND == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: no match for %s in %s&quot,\newline					opts-&gtmodule, user, opts-&gtconf);\newline		}\newline		return _PAM_CHROOT_USERNOTFOUND;\newline	} else {\newline		_pam_log(LOG_ERR,\newline				&quot%s: error determining chrootdir: user=\\&quot%s\\&quot, dir=\\&quot%s\\&quot&quot,\newline				opts-&gtmodule, user, opts-&gtchroot_dir);\newline		return err;\newline	}\newline}\newline","This is the workhorse function. All of the pam_sm_ functions should\newline initialize a _pam_opts struct with the command line args and flags,\newline then pass it to this function \newline","6626641","copt.c","static char *subst(char *pat)\newline{\newline  char buf[MAXLINE];\newline  char *cp, *cp1, *cp2, *varptr;\newline  long num;\newline  int i = 0;\newline  int j, pos;\newline\newline  while (*pat)\newline	if (pat[0] == &#039%&#039 &amp&amp isdigit(pat[1])) {\newline		/* Substitute with value of variable */\newline		cp = vars[pat[1] - &#0390&#039];\newline		while (cp != NULL &amp&amp *cp) {\newline			buf[i++] = *cp++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline		pat += 2;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039(&#039) {\newline		/* Substitute with expression */\newline		cp = pat + 2;\newline		if ((pat = strchr(cp, &#039)&#039)) == NULL || pat - cp &lt= 0)\newline			num = 0;\newline		else\newline			num = eval(cp, pat - cp);\newline		if (i &gt= MAXLINE - 20) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline		i += sprintf(&ampbuf[i], &quot%s$%lx&quot, num &lt 0 ? &quot-&quot : &quot&quot, labs(num));\newline		pat++;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039=&#039) {\newline		/* Substitute with converted variable */\newline		/* First seperate all parts of the pattern string */\newline		cp = pat + 2;\newline		cp1 = cp2 = varptr = NULL;\newline		if (*cp == &#039[&#039) {\newline			cp1 = ++cp;\newline			while (*cp &amp&amp *cp != &#039]&#039)\newline				cp++;\newline			if (cp[0] == &#039]&#039 &amp&amp cp[1] == &#039[&#039) {\newline				cp += 2;\newline				cp2 = cp;\newline				while (*cp &amp&amp *cp != &#039]&#039)\newline					cp++;\newline				if (cp[0] == &#039]&#039 &amp&amp isdigit(cp[1]))\newline					 varptr = vars[cp[1] - &#0390&#039];\newline			}\newline		}\newline		if (cp1 == NULL || cp2 == NULL || varptr == NULL) {\newline			buf[i++] = *pat++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline			continue;\newline		}\newline		pat = cp + 2;\newline		/* Now scan through the first string to find variable value */\newline		cp1--;\newline		pos = 0;\newline		while (*cp1 != &#039]&#039) {\newline			cp1++;\newline			j = strcspn(cp1, &quot|]&quot);\newline			if (strlen(varptr) == j &amp&amp !strncmp(cp1, varptr, j))\newline				break;\newline			pos++;\newline			cp1 += j;\newline		}\newline		if (*cp1 == &#039]&#039)\newline			continue;\newline		/* Scan through the second string to find the conversion */\newline		cp2--;\newline		while (*cp2 != &#039]&#039 &amp&amp pos &gt 0) {\newline			cp2++;\newline			j = strcspn(cp2, &quot|]&quot);\newline			pos--;\newline			cp2 += j;\newline		}\newline		if (*cp2 == &#039]&#039 || pos != 0)\newline			continue;\newline		/* Insert conversion string into destination */\newline		cp2++;\newline		while (*cp2 != &#039|&#039 &amp&amp *cp2 != &#039]&#039) {\newline			buf[i++] = *cp2++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline	} else {\newline		buf[i++] = *pat++;\newline		if (i &gt= MAXLINE - 1) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline	}\newline\newline  buf[i] = &#039\\0&#039;\newline  return(install(buf, i));\newline}\newline","\newline Substitute variables in a string\newline \newline","3370483","htmlgenerator.cpp","void HtmlGenerator::generateAssociatedPropertyNotes(const FunctionNode* fn)\newline{\newline    if (fn-&gthasAssociatedProperties()) {\newline        out() &lt&lt &quot&ltp&gt&ltb&gtNote:&lt/b&gt &quot;\newline        PropNodeList propertyNodes = fn-&gtassociatedProperties();\newline        std::sort(propertyNodes.begin(), propertyNodes.end(), Node::nodeNameLessThan);\newline        foreach (const PropertyNode* pn, propertyNodes) {\newline            QString msg;\newline            switch (pn-&gtrole(fn)) {\newline            case PropertyNode::Getter:\newline                msg = QStringLiteral(&quotGetter function &quot);\newline                break;\newline            case PropertyNode::Setter:\newline                msg = QStringLiteral(&quotSetter function &quot);\newline                break;\newline            case PropertyNode::Resetter:\newline                msg = QStringLiteral(&quotResetter function &quot);\newline                break;\newline            case PropertyNode::Notifier:\newline                msg = QStringLiteral(&quotNotifier signal &quot);\newline                break;\newline            default:\newline                break;\newline            }\newline            QString link = linkForNode(pn, 0);\newline            out() &lt&lt msg &lt&lt &quotfor property &lta href=\\&quot&quot &lt&lt link &lt&lt &quot\\&quot&gt&quot &lt&lt pn-&gtname() &lt&lt &quot&lt/a&gt. &quot;\newline        }\newline        out() &lt&lt &quot&lt/p&gt&quot;\newline    }\newline}\newline","!\newlineGenerates bold Note lines that explain how function \\a fn\newlineis associated with each of its associated properties.\newline \newline","5084075","mock_buckets.c","apr_status_t serf_bucket_mock_more_data_arrived(serf_bucket_t *bucket)\newline{\newline    mockbkt_context_t *ctx = bucket-&gtdata;\newline    mockbkt_action *action;\newline    apr_status_t status;\newline\newline    status = next_action(ctx);\newline    if (status)\newline        return status;\newline\newline    action = &ampctx-&gtactions[ctx-&gtcurrent_action];\newline    if (ctx-&gtremaining_data == 0 &amp&amp action-&gtstatus == APR_EAGAIN) {\newline        ctx-&gtremaining_times--;\newline        action-&gttimes--;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","An action { &quot&quot, 0, APR_EAGAIN } means that serf should exit serf_context_run\newlineand pass the buck back to the application. As long as no new data arrives,\newlinethis action remains active.\newline\newlineThis function allows the &#039application&#039 to trigger the arrival of more data.\newlineIf the current action is { &quot&quot, 0, APR_EAGAIN }, reduce the number of times\newlinethe action should run by one, and proceed with the next action if needed.\newline \newline","5206276","main.c","void new_vi(void)\newline{\newline   gs_apply_cheats();\newline\newline   main_check_inputs();\newline\newline#if 0\newline   timed_sections_refresh();\newline\newline   pause_loop();\newline\newline   apply_speed_limiter();\newline#endif\newline}\newline","called on vertical interrupt.\newline Allow the core to perform various things \newline","3684765","get_neigh.c","static void invalidate_route(struct routeinfo *routehead, unsigned short node)\newline{\newline	struct routeinfo *route, *cheaproute = NULL;\newline\newline	for (route = routehead-&gtnext; route; route=route-&gtnext)\newline	{\newline		if (route-&gtrouter == node)\newline		{\newline			route-&gtvalid = 0;\newline		}\newline	}\newline	set_lowest_cost_route(routehead, node);\newline}\newline","When a routing node goes down, look for alternative routes. \newline","77424","ola-rdm.cpp","void DisplayPIDsAndExit(uint16_t manufacturer_id,\newline                        const PidStoreHelper &amppid_helper) {\newline  vector&ltstring&gt pid_names;\newline  pid_helper.SupportedPids(manufacturer_id, &amppid_names);\newline  sort(pid_names.begin(), pid_names.end());\newline\newline  vector&ltstring&gt::const_iterator iter = pid_names.begin();\newline  for (; iter != pid_names.end(); ++iter) {\newline    cout &lt&lt *iter &lt&lt endl;\newline  }\newline  exit(ola::EXIT_OK);\newline}\newline","\newline Dump the list of known pids\newline \newline","216178","subtitle_free.c","void quvi_subtitle_free(quvi_subtitle_t handle)\newline{\newline  m_subtitle_free(handle);\newline}\newline","@brief Free all of memory used by a subtitle handle\newline@note If handle is NULL the function simply returns\newline@sa @ref parse_subtitle\newline@ingroup subprop\newline \newline","4322322","util.h","static inline void memcpy_safe(void *dst, const void *src, size_t n) {\newline        if (n == 0)\newline                return;\newline        assert(src);\newline        memcpy(dst, src, n);\newline}\newline","\newline Normal memcpy requires src to be nonnull. We do nothing if n is 0.\newline \newline","6372657","integck.c","static int recover_tested_fs(void)\newline{\newline	int ret;\newline	unsigned long flags;\newline	unsigned int  um_rorw, rorw2;\newline	struct mntent *mntent;\newline\newline	CHECK(chdir(&quot/&quot) == 0);\newline\newline	/* Choose what to do */\newline	um_rorw = random_no(2);\newline	rorw2 = random_no(2);\newline\newline	/*\newline	 * At this point we do not know for sure whether the tested FS is\newline	 * mounted, because the emulated power cut error could have happened\newline	 * while mounting in &#039remount_tested_fs()&#039.\newline	 */\newline	mntent = get_tested_fs_mntent();\newline	if (mntent)\newline		CHECK(umount(fsinfo.mount_point) != -1);\newline\newline	if (args.reattach)\newline		CHECK(reattach() == 0);\newline\newline	if (!um_rorw) {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/W&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline	} else {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags | MS_RDONLY,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/O&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, mounted R/O, but cannot re-mount it R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	if (rorw2) {\newline		flags = fsinfo.mount_flags | MS_RDONLY | MS_REMOUNT;\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotcannot re-mount %s R/O&quot, fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotremounted %s R/O, but cannot re-mount it back R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Recover the tested file-system from an emulated power cut failure by\newline unmounting it and mounting it again.\newline \newline","675719","read-dict.c","void add_empty_word(Dictionary const dict, X_node *x)\newline{\newline	Exp *zn, *an;\newline	E_list *elist, *flist;\newline	Exp_list eli = { NULL };\newline\newline	/* The left-wall already has ZZZ-. The right-wall will not arrive here. */\newline	if (MT_WALL == x-&gtword-&gtmorpheme_type) return;\newline\newline	/* Replace plain-word-exp by {ZZZ+} &amp (plain-word-exp) in each X_node.  */\newline	for(; NULL != x; x = x-&gtnext)\newline	{\newline		/* Ignore stems for now, decreases a little the overhead for\newline		 * stem-suffix languages. */\newline		if (is_stem(x-&gtstring)) continue; /* Avoid an unneeded overhead. */\newline		//lgdebug(+0, &quotProcessing &#039%s&#039\\n&quot, x-&gtstring);\newline\newline		/* zn points at {ZZZ+} */\newline		zn = Exp_create(&ampeli);\newline		zn-&gtdir = &#039+&#039;\newline		zn-&gtu.string = string_set_add(EMPTY_CONNECTOR, dict-&gtstring_set);\newline		zn-&gtmulti = false;\newline		zn-&gttype = CONNECTOR_type;\newline		zn-&gtcost = 0.0;\newline		zn = make_optional_node(&ampeli, zn);\newline\newline		/* flist is plain-word-exp */\newline		flist = (E_list *) xalloc(sizeof(E_list));\newline		flist-&gtnext = NULL;\newline		flist-&gte = x-&gtexp;\newline\newline		/* elist is {ZZZ+} , (plain-word-exp) */\newline		elist = (E_list *) xalloc(sizeof(E_list));\newline		elist-&gtnext = flist;\newline		elist-&gte = zn;\newline\newline		/* an will be {ZZZ+} &amp (plain-word-exp) */\newline		an = Exp_create(&ampeli);\newline		an-&gttype = AND_type;\newline		an-&gtcost = 0.0;\newline		an-&gtu.l = elist;\newline\newline		x-&gtexp = an;\newline	}\newline}\newline","Insert ZZZ+ connectors.\newline This function was mainly used to support using empty-words, a concept\newline that has been eliminated. However, it is still used to support linking of\newline quotes that don&#039t get the QUc/QUd links.\newline \newline","6062221","mkeot.c","static bool read_2be_signed(FILE *f, short *x)\newline{\newline  unsigned char s[2];\newline  union {short s; unsigned short u;} h;\newline\newline  if (fread(s, 1, 2, f) != 2) return false;\newline  h.u = (s[0] &lt&lt 8) + s[1];\newline  *x = h.s;\newline  return true;\newline}\newline","read_2be_signed -- read a big endian short \newline","1805380","sha1.c","void MYSQL_SHA1Update(MYSQL_SHA1_CTX * context, const unsigned char *input,\newline			   size_t inputLen)\newline{\newline	unsigned int i, index, partLen;\newline\newline	/* Compute number of bytes mod 64 */\newline	index = (unsigned int) ((context-&gtcount[0] &gt&gt 3) &amp 0x3F);\newline\newline	/* Update number of bits */\newline	if ((context-&gtcount[0] += ((uint32) inputLen &lt&lt 3))\newline		&lt ((uint32) inputLen &lt&lt 3))\newline		context-&gtcount[1]++;\newline	context-&gtcount[1] += ((uint32) inputLen &gt&gt 29);\newline\newline	partLen = 64 - index;\newline\newline	/* Transform as many times as possible.\newline	 */\newline	if (inputLen &gt= partLen) {\newline		memcpy\newline			((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) input, partLen);\newline		SHA1Transform(context-&gtstate, context-&gtbuffer);\newline\newline		for (i = partLen; i + 63 &lt inputLen; i += 64)\newline			SHA1Transform(context-&gtstate, &ampinput[i]);\newline\newline		index = 0;\newline	} else\newline		i = 0;\newline\newline	/* Buffer remaining input */\newline	memcpy\newline		((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) &amp input[i],\newline		 inputLen - i);\newline}\newline","{{{ MYSQL_SHA1Update\newlineSHA1 block update operation. Continues an SHA1 message-digest\newlineoperation, processing another message block, and updating the\newlinecontext.\newline \newline","","","","","","","","","","","","","","","","on","","","","","on","","","on","","","","","","on","","","","","","","","","","","","","Set owner of mutex semaphore","Substitute variables in a string","Generates bold Note lines","allows the 'application' to trigger the arrival of more data.","Allow the core to perform various things","When a routing node goes down, look for alternative routes.","Dump the list of known pids","Free all of memory used by a subtitle handle","Normal memcpy requires src to be nonnull.","Recover the tested file-system from an emulated power cut failure","Insert ZZZ+ connectors.","Remove ematch from the list of ematches it is linked to.","read a big endian short","SHA1 block update operation.","Allocate a block of the requested size,","{}","Read an isl_schedule from ""input"".","input the opacity positions array and the opacity field will be returned","Insert an address entry into a skip list.","Routines placed in empty entries in the device tables","{}"
"391FPZIE4CMYGCMYKDBWLYE9BUHUHH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3NOKK93PR187UQV3UETMLWRIDF3EEI","A3SYA8EDAEOOF7","Approved","Wed Apr 17 16:17:16 PDT 2019","Wed Apr 17 16:22:08 PDT 2019","Fri Apr 19 16:22:08 PDT 2019","2019-04-19 23:22:25 UTC","","","292","100% (17/17)","100% (17/17)","100% (17/17)","5197779","mozplugger-helper.c","static void setSwallowMutexOwner(uint32_t hostId, uint32_t pid)\newline{\newline     unsigned long temp[2] = {hostId, pid};\newline\newline     D(&quotSetting swallow mutex owner, hostId = 0x%08X, pid=%u\\n&quot, \newline                                            (unsigned) hostId, (unsigned) pid); \newline     XChangeProperty(display, wattr.root, swallowMutex,\newline                        XA_INTEGER, 32, PropModeAppend,\newline                        (unsigned char*) (&amptemp), 2);\newline}\newline","\newline Set owner of mutex semaphore\newline \newline @param[in] hostId The ID of the new owner of the mutex\newline @param[in] pid The process ID of the mutex\newline \newline @return none\newline \newline \newline","283896","ematch.c","void rtnl_ematch_unlink(struct rtnl_ematch *ematch)\newline{\newline	NL_DBG(2, &quotunlinked ematch %p from any lists\\n&quot, ematch);\newline\newline	if (!nl_list_empty(&ampematch-&gte_childs))\newline		NL_DBG(1, &quotwarning: ematch %p with childs was unlinked\\n&quot,\newline			  ematch);\newline\newline	nl_list_del(&ampematch-&gte_list);\newline	nl_init_list_head(&ampematch-&gte_list);\newline}\newline","\newline Remove ematch from the list of ematches it is linked to.\newline @arg ematch ematch object\newline \newline","517677","memory.c","char *caml_alloc_for_heap (asize_t request)\newline{\newline  char *mem;\newline  void *block;\newline                                              Assert (request % Page_size == 0);\newline  mem = caml_aligned_malloc (request + sizeof (heap_chunk_head),\newline                             sizeof (heap_chunk_head), &ampblock);\newline  if (mem == NULL) return NULL;\newline  mem += sizeof (heap_chunk_head);\newline  Chunk_size (mem) = request;\newline  Chunk_block (mem) = block;\newline  return mem;\newline}\newline","Allocate a block of the requested size, to be passed to\newline[caml_add_to_heap] later.\newline[request] must be a multiple of [Page_size].\newline[caml_alloc_for_heap] returns NULL if the request cannot be satisfied.\newlineThe returned pointer is a hp, but the header must be initialized by\newlinethe caller.\newline \newline","1528478","charcnv.c","size_t convert_charset ( charset_t from_set, charset_t to_set, charset_t cap_charset, const char *src, size_t src_len, char *dest, size_t dest_len, u_int16_t *flags)\newline{\newline    size_t i_len, o_len;\newline    ucs2_t *u;\newline    ucs2_t buffer[MAXPATHLEN +2];\newline    ucs2_t buffer2[MAXPATHLEN +2];\newline\newline    lazy_initialize_conv();\newline\newline    /* convert from_set to UCS2 */\newline    if ((size_t)(-1) == ( o_len = pull_charset_flags( from_set, cap_charset, src, src_len,\newline                                                      (char *) buffer, sizeof(buffer) -2, flags)) ) {\newline        LOG(log_error, logtype_default, &quotConversion failed ( %s to CH_UCS2 )&quot, charset_name(from_set));\newline        return (size_t) -1;\newline    }\newline\newline    if ( o_len == 0)\newline        return o_len;\newline\newline    /* Do pre/decomposition */\newline    i_len = sizeof(buffer2) -2;\newline    u = buffer2;\newline    if (CHECK_FLAGS(flags, CONV_DECOMPOSE) || (charsets[to_set] &amp&amp (charsets[to_set]-&gtflags &amp CHARSET_DECOMPOSED)) ) {\newline        if ( (size_t)-1 == (i_len = decompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_PRECOMPOSE) || !charsets[from_set] || (charsets[from_set]-&gtflags &amp CHARSET_DECOMPOSED)) {\newline        if ( (size_t)-1 == (i_len = precompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else {\newline        u = buffer;\newline        i_len = o_len;\newline    }\newline    /* null terminate */\newline    u[i_len] = 0;\newline    u[i_len +1] = 0;\newline\newline    /* Do case conversions */\newline    if (CHECK_FLAGS(flags, CONV_TOUPPER)) {\newline        strupper_w(u);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_TOLOWER)) {\newline        strlower_w(u);\newline    }\newline\newline    /* Convert UCS2 to to_set */\newline    if ((size_t)(-1) == ( o_len = push_charset_flags( to_set, cap_charset, (char *)u, i_len, dest, dest_len, flags )) ) {\newline        LOG(log_error, logtype_default,\newline            &quotConversion failed (CH_UCS2 to %s):%s&quot, charset_name(to_set), strerror(errno));\newline        return (size_t) -1;\newline    }\newline    /* null terminate */\newline    dest[o_len] = 0;\newline    dest[o_len +1] = 0;\newline\newline    return o_len;\newline}\newline","\newline FIXME the size is a mess we really need a malloc/free logic\newline `dest size must be dest_len +2\newline \newline","2609159","isl_schedule_read.c","__isl_give isl_schedule *isl_schedule_read_from_file(isl_ctx *ctx, FILE *input)\newline{\newline	struct isl_stream *s;\newline	isl_schedule *schedule;\newline\newline	s = isl_stream_new_file(ctx, input);\newline	if (!s)\newline		return NULL;\newline	schedule = isl_stream_read_schedule(s);\newline	isl_stream_free(s);\newline\newline	return schedule;\newline}\newline","Read an isl_schedule from &quotinput&quot.\newline \newline","4357933","_colormap.c","Field _dxfeditor_to_opacity(Array opmap)\newline{\newline   int i,num_op,new_num,offset=0;\newline   Field opacity;\newline   float *op_pts,*op_data;\newline   Array a,b;\newline   Map *op;\newline\newline   opacity = NULL;\newline   /* if array is NULL create a default opacity field */\newline   if (!opmap){\newline      num_op = 2;\newline      opacity = (Field)_dxfcolorfield(NULL,NULL,num_op,0);\newline      a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline      b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline      op_pts = (float *)DXGetArrayData(a);\newline      op_data = (float *)DXGetArrayData(b);\newline      op_pts[0] = 0.0;\newline      op_pts[1] = 1.0;\newline      op_data[0] = op_data[1] = 1.0;\newline   }\newline      \newline   if (!DXGetArrayInfo(opmap,&ampnum_op,NULL,NULL,NULL,NULL))\newline      goto error;\newline   op = (Map *)DXGetArrayData(opmap);\newline   /* check for missing end points */\newline   new_num=num_op;\newline   if (op[num_op-1].level != 1.0)\newline      new_num++;\newline   if (op[0].level != 0.0) {\newline      offset = 1;\newline      new_num++;\newline   }\newline   \newline   /* build new field */\newline   opacity = (Field)_dxfcolorfield(NULL,NULL,new_num,0);\newline   a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline   b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline   op_pts = (float *)DXGetArrayData(a);\newline   op_data = (float *)DXGetArrayData(b);\newline   if (offset == 1){\newline      op_pts[0] = 0.0;\newline      op_data[0] = op[0].value;\newline   }\newline   if (op[num_op-1].level != 1.0){\newline      op_pts[new_num-1] = 1.0;\newline      op_data[new_num-1] = op[num_op-1].value;\newline   }\newline   for (i=0; i&ltnum_op; i++){\newline      op_pts[offset + i] = op[i].level;\newline      op_data[offset + i] = op[i].value;\newline   }\newline\newline   if (!DXEndField(opacity))\newline      goto error;\newline   \newline   return (Field)opacity;\newline\newlineerror:\newline   if (opacity) DXDelete((Object)opacity);\newline   return NULL;\newline}\newline","input the opacity positions array and the opacity field \newline will be returned\newline \newline","3630269","chunk.c","static	skip_alloc_t	*insert_address(void *address, const int free_b,\newline					const unsigned int tot_size)\newline{\newline  skip_alloc_t	*new_p;\newline  \newline  /* get a new entry */\newline  new_p = get_slot();\newline  if (new_p == NULL) {\newline    /* error code set in get_slot */\newline    return NULL;\newline  }\newline  if (free_b) {\newline    new_p-&gtsa_flags = ALLOC_FLAG_FREE;\newline  }\newline  else {\newline    new_p-&gtsa_flags = ALLOC_FLAG_USER;\newline  }\newline  new_p-&gtsa_mem = address;\newline  new_p-&gtsa_total_size = tot_size;\newline  \newline  /* now try and insert the slot into the skip-list */\newline  if (! insert_slot(new_p, free_b)) {\newline    /* Sanity check.  error code set in insert_slot(). */\newline    return NULL;\newline  }\newline  \newline  return new_p;\newline}\newline","\newline static skip_alloc_t insert_address\newline \newline DESCRIPTION:\newline \newline Insert an address entry into a skip list.\newline \newline RETURNS:\newline \newline Success - Valid slot pointer.\newline \newline Failure - NULL\newline \newline ARGUMENTS:\newline \newline address -&gt Address we are inserting into the address list.\newline \newline free_b -&gt Insert a free address in the free-size list otherwise it\newline will go into the used address list.\newline \newline tot_size -&gt Total size of the chunk that we are inserting into the\newline list.\newline \newline","3104274","dev_name.c","int nulldev(void)\newline{\newline	return (D_SUCCESS);\newline}\newline","\newline Routines placed in empty entries in the device tables\newline \newline","5197386","pam_chroot.c","int _pam_do_chroot(pam_handle_t *pamh, struct _pam_opts *opts) {\newline	int err,debug;\newline	char const *user;\newline\newline	debug = opts-&gtflags &amp _PAM_OPTS_DEBUG;\newline\newline	err = pam_get_user(pamh, &ampuser, NULL);\newline	if(PAM_CONV_AGAIN == err) {\newline		_pam_log(LOG_NOTICE, &quot$s: retry username lookup later&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_INCOMPLETE;\newline	} else if(PAM_SUCCESS != err) {\newline		_pam_log(LOG_ERR, &quot%s: can&#039t get username&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_SYSERR;\newline	}\newline\newline	if(opts-&gtchroot_dir) { /* overrides the conf file */\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: chrootdir (%s) specified, ignoring conf file&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir);\newline		}\newline		err = _PAM_CHROOT_OK;\newline	} else {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: reading config file (%s)&quot, opts-&gtmodule, opts-&gtconf);\newline		}\newline		err = _pam_get_chrootdir(user, opts);\newline	}\newline\newline	if(_PAM_CHROOT_OK == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: preparing to chroot()&quot, opts-&gtmodule);\newline		}\newline\newline		if(NULL == opts-&gtchroot_dir) {\newline			/* This is a state that I should never see.  If the user wasn&#039t in\newline			 * the conf file, then USERNOTFOUND should have been returned. */\newline			_pam_log(LOG_ERR,\newline					&quot%s: no chroot_dir set for \\&quot%s\\&quot&quot, opts-&gtmodule, user);\newline			return _PAM_CHROOT_INTERNALERR;\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_SECCHECKS) {\newline			if(0 != _pam_check_path_perms(opts-&gtchroot_dir, opts)) {\newline				_pam_log(LOG_ERR,\newline						&quot%s: chroot_dir \\&quot%s\\&quot failed security check&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline				return _PAM_CHROOT_SYSERR;\newline			}\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_NO_CHROOT) {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: no_chroot is set, skipping chroot(%s)&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		} else if(chdir(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chdir(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else if(chroot(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chroot(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: chroot(%s) ok&quot, opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		}\newline		return _PAM_CHROOT_OK;\newline	} else if(_PAM_CHROOT_USERNOTFOUND == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: no match for %s in %s&quot,\newline					opts-&gtmodule, user, opts-&gtconf);\newline		}\newline		return _PAM_CHROOT_USERNOTFOUND;\newline	} else {\newline		_pam_log(LOG_ERR,\newline				&quot%s: error determining chrootdir: user=\\&quot%s\\&quot, dir=\\&quot%s\\&quot&quot,\newline				opts-&gtmodule, user, opts-&gtchroot_dir);\newline		return err;\newline	}\newline}\newline","This is the workhorse function. All of the pam_sm_ functions should\newline initialize a _pam_opts struct with the command line args and flags,\newline then pass it to this function \newline","6626641","copt.c","static char *subst(char *pat)\newline{\newline  char buf[MAXLINE];\newline  char *cp, *cp1, *cp2, *varptr;\newline  long num;\newline  int i = 0;\newline  int j, pos;\newline\newline  while (*pat)\newline	if (pat[0] == &#039%&#039 &amp&amp isdigit(pat[1])) {\newline		/* Substitute with value of variable */\newline		cp = vars[pat[1] - &#0390&#039];\newline		while (cp != NULL &amp&amp *cp) {\newline			buf[i++] = *cp++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline		pat += 2;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039(&#039) {\newline		/* Substitute with expression */\newline		cp = pat + 2;\newline		if ((pat = strchr(cp, &#039)&#039)) == NULL || pat - cp &lt= 0)\newline			num = 0;\newline		else\newline			num = eval(cp, pat - cp);\newline		if (i &gt= MAXLINE - 20) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline		i += sprintf(&ampbuf[i], &quot%s$%lx&quot, num &lt 0 ? &quot-&quot : &quot&quot, labs(num));\newline		pat++;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039=&#039) {\newline		/* Substitute with converted variable */\newline		/* First seperate all parts of the pattern string */\newline		cp = pat + 2;\newline		cp1 = cp2 = varptr = NULL;\newline		if (*cp == &#039[&#039) {\newline			cp1 = ++cp;\newline			while (*cp &amp&amp *cp != &#039]&#039)\newline				cp++;\newline			if (cp[0] == &#039]&#039 &amp&amp cp[1] == &#039[&#039) {\newline				cp += 2;\newline				cp2 = cp;\newline				while (*cp &amp&amp *cp != &#039]&#039)\newline					cp++;\newline				if (cp[0] == &#039]&#039 &amp&amp isdigit(cp[1]))\newline					 varptr = vars[cp[1] - &#0390&#039];\newline			}\newline		}\newline		if (cp1 == NULL || cp2 == NULL || varptr == NULL) {\newline			buf[i++] = *pat++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline			continue;\newline		}\newline		pat = cp + 2;\newline		/* Now scan through the first string to find variable value */\newline		cp1--;\newline		pos = 0;\newline		while (*cp1 != &#039]&#039) {\newline			cp1++;\newline			j = strcspn(cp1, &quot|]&quot);\newline			if (strlen(varptr) == j &amp&amp !strncmp(cp1, varptr, j))\newline				break;\newline			pos++;\newline			cp1 += j;\newline		}\newline		if (*cp1 == &#039]&#039)\newline			continue;\newline		/* Scan through the second string to find the conversion */\newline		cp2--;\newline		while (*cp2 != &#039]&#039 &amp&amp pos &gt 0) {\newline			cp2++;\newline			j = strcspn(cp2, &quot|]&quot);\newline			pos--;\newline			cp2 += j;\newline		}\newline		if (*cp2 == &#039]&#039 || pos != 0)\newline			continue;\newline		/* Insert conversion string into destination */\newline		cp2++;\newline		while (*cp2 != &#039|&#039 &amp&amp *cp2 != &#039]&#039) {\newline			buf[i++] = *cp2++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline	} else {\newline		buf[i++] = *pat++;\newline		if (i &gt= MAXLINE - 1) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline	}\newline\newline  buf[i] = &#039\\0&#039;\newline  return(install(buf, i));\newline}\newline","\newline Substitute variables in a string\newline \newline","3370483","htmlgenerator.cpp","void HtmlGenerator::generateAssociatedPropertyNotes(const FunctionNode* fn)\newline{\newline    if (fn-&gthasAssociatedProperties()) {\newline        out() &lt&lt &quot&ltp&gt&ltb&gtNote:&lt/b&gt &quot;\newline        PropNodeList propertyNodes = fn-&gtassociatedProperties();\newline        std::sort(propertyNodes.begin(), propertyNodes.end(), Node::nodeNameLessThan);\newline        foreach (const PropertyNode* pn, propertyNodes) {\newline            QString msg;\newline            switch (pn-&gtrole(fn)) {\newline            case PropertyNode::Getter:\newline                msg = QStringLiteral(&quotGetter function &quot);\newline                break;\newline            case PropertyNode::Setter:\newline                msg = QStringLiteral(&quotSetter function &quot);\newline                break;\newline            case PropertyNode::Resetter:\newline                msg = QStringLiteral(&quotResetter function &quot);\newline                break;\newline            case PropertyNode::Notifier:\newline                msg = QStringLiteral(&quotNotifier signal &quot);\newline                break;\newline            default:\newline                break;\newline            }\newline            QString link = linkForNode(pn, 0);\newline            out() &lt&lt msg &lt&lt &quotfor property &lta href=\\&quot&quot &lt&lt link &lt&lt &quot\\&quot&gt&quot &lt&lt pn-&gtname() &lt&lt &quot&lt/a&gt. &quot;\newline        }\newline        out() &lt&lt &quot&lt/p&gt&quot;\newline    }\newline}\newline","!\newlineGenerates bold Note lines that explain how function \\a fn\newlineis associated with each of its associated properties.\newline \newline","5084075","mock_buckets.c","apr_status_t serf_bucket_mock_more_data_arrived(serf_bucket_t *bucket)\newline{\newline    mockbkt_context_t *ctx = bucket-&gtdata;\newline    mockbkt_action *action;\newline    apr_status_t status;\newline\newline    status = next_action(ctx);\newline    if (status)\newline        return status;\newline\newline    action = &ampctx-&gtactions[ctx-&gtcurrent_action];\newline    if (ctx-&gtremaining_data == 0 &amp&amp action-&gtstatus == APR_EAGAIN) {\newline        ctx-&gtremaining_times--;\newline        action-&gttimes--;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","An action { &quot&quot, 0, APR_EAGAIN } means that serf should exit serf_context_run\newlineand pass the buck back to the application. As long as no new data arrives,\newlinethis action remains active.\newline\newlineThis function allows the &#039application&#039 to trigger the arrival of more data.\newlineIf the current action is { &quot&quot, 0, APR_EAGAIN }, reduce the number of times\newlinethe action should run by one, and proceed with the next action if needed.\newline \newline","5206276","main.c","void new_vi(void)\newline{\newline   gs_apply_cheats();\newline\newline   main_check_inputs();\newline\newline#if 0\newline   timed_sections_refresh();\newline\newline   pause_loop();\newline\newline   apply_speed_limiter();\newline#endif\newline}\newline","called on vertical interrupt.\newline Allow the core to perform various things \newline","3684765","get_neigh.c","static void invalidate_route(struct routeinfo *routehead, unsigned short node)\newline{\newline	struct routeinfo *route, *cheaproute = NULL;\newline\newline	for (route = routehead-&gtnext; route; route=route-&gtnext)\newline	{\newline		if (route-&gtrouter == node)\newline		{\newline			route-&gtvalid = 0;\newline		}\newline	}\newline	set_lowest_cost_route(routehead, node);\newline}\newline","When a routing node goes down, look for alternative routes. \newline","77424","ola-rdm.cpp","void DisplayPIDsAndExit(uint16_t manufacturer_id,\newline                        const PidStoreHelper &amppid_helper) {\newline  vector&ltstring&gt pid_names;\newline  pid_helper.SupportedPids(manufacturer_id, &amppid_names);\newline  sort(pid_names.begin(), pid_names.end());\newline\newline  vector&ltstring&gt::const_iterator iter = pid_names.begin();\newline  for (; iter != pid_names.end(); ++iter) {\newline    cout &lt&lt *iter &lt&lt endl;\newline  }\newline  exit(ola::EXIT_OK);\newline}\newline","\newline Dump the list of known pids\newline \newline","216178","subtitle_free.c","void quvi_subtitle_free(quvi_subtitle_t handle)\newline{\newline  m_subtitle_free(handle);\newline}\newline","@brief Free all of memory used by a subtitle handle\newline@note If handle is NULL the function simply returns\newline@sa @ref parse_subtitle\newline@ingroup subprop\newline \newline","4322322","util.h","static inline void memcpy_safe(void *dst, const void *src, size_t n) {\newline        if (n == 0)\newline                return;\newline        assert(src);\newline        memcpy(dst, src, n);\newline}\newline","\newline Normal memcpy requires src to be nonnull. We do nothing if n is 0.\newline \newline","6372657","integck.c","static int recover_tested_fs(void)\newline{\newline	int ret;\newline	unsigned long flags;\newline	unsigned int  um_rorw, rorw2;\newline	struct mntent *mntent;\newline\newline	CHECK(chdir(&quot/&quot) == 0);\newline\newline	/* Choose what to do */\newline	um_rorw = random_no(2);\newline	rorw2 = random_no(2);\newline\newline	/*\newline	 * At this point we do not know for sure whether the tested FS is\newline	 * mounted, because the emulated power cut error could have happened\newline	 * while mounting in &#039remount_tested_fs()&#039.\newline	 */\newline	mntent = get_tested_fs_mntent();\newline	if (mntent)\newline		CHECK(umount(fsinfo.mount_point) != -1);\newline\newline	if (args.reattach)\newline		CHECK(reattach() == 0);\newline\newline	if (!um_rorw) {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/W&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline	} else {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags | MS_RDONLY,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/O&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, mounted R/O, but cannot re-mount it R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	if (rorw2) {\newline		flags = fsinfo.mount_flags | MS_RDONLY | MS_REMOUNT;\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotcannot re-mount %s R/O&quot, fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotremounted %s R/O, but cannot re-mount it back R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Recover the tested file-system from an emulated power cut failure by\newline unmounting it and mounting it again.\newline \newline","675719","read-dict.c","void add_empty_word(Dictionary const dict, X_node *x)\newline{\newline	Exp *zn, *an;\newline	E_list *elist, *flist;\newline	Exp_list eli = { NULL };\newline\newline	/* The left-wall already has ZZZ-. The right-wall will not arrive here. */\newline	if (MT_WALL == x-&gtword-&gtmorpheme_type) return;\newline\newline	/* Replace plain-word-exp by {ZZZ+} &amp (plain-word-exp) in each X_node.  */\newline	for(; NULL != x; x = x-&gtnext)\newline	{\newline		/* Ignore stems for now, decreases a little the overhead for\newline		 * stem-suffix languages. */\newline		if (is_stem(x-&gtstring)) continue; /* Avoid an unneeded overhead. */\newline		//lgdebug(+0, &quotProcessing &#039%s&#039\\n&quot, x-&gtstring);\newline\newline		/* zn points at {ZZZ+} */\newline		zn = Exp_create(&ampeli);\newline		zn-&gtdir = &#039+&#039;\newline		zn-&gtu.string = string_set_add(EMPTY_CONNECTOR, dict-&gtstring_set);\newline		zn-&gtmulti = false;\newline		zn-&gttype = CONNECTOR_type;\newline		zn-&gtcost = 0.0;\newline		zn = make_optional_node(&ampeli, zn);\newline\newline		/* flist is plain-word-exp */\newline		flist = (E_list *) xalloc(sizeof(E_list));\newline		flist-&gtnext = NULL;\newline		flist-&gte = x-&gtexp;\newline\newline		/* elist is {ZZZ+} , (plain-word-exp) */\newline		elist = (E_list *) xalloc(sizeof(E_list));\newline		elist-&gtnext = flist;\newline		elist-&gte = zn;\newline\newline		/* an will be {ZZZ+} &amp (plain-word-exp) */\newline		an = Exp_create(&ampeli);\newline		an-&gttype = AND_type;\newline		an-&gtcost = 0.0;\newline		an-&gtu.l = elist;\newline\newline		x-&gtexp = an;\newline	}\newline}\newline","Insert ZZZ+ connectors.\newline This function was mainly used to support using empty-words, a concept\newline that has been eliminated. However, it is still used to support linking of\newline quotes that don&#039t get the QUc/QUd links.\newline \newline","6062221","mkeot.c","static bool read_2be_signed(FILE *f, short *x)\newline{\newline  unsigned char s[2];\newline  union {short s; unsigned short u;} h;\newline\newline  if (fread(s, 1, 2, f) != 2) return false;\newline  h.u = (s[0] &lt&lt 8) + s[1];\newline  *x = h.s;\newline  return true;\newline}\newline","read_2be_signed -- read a big endian short \newline","1805380","sha1.c","void MYSQL_SHA1Update(MYSQL_SHA1_CTX * context, const unsigned char *input,\newline			   size_t inputLen)\newline{\newline	unsigned int i, index, partLen;\newline\newline	/* Compute number of bytes mod 64 */\newline	index = (unsigned int) ((context-&gtcount[0] &gt&gt 3) &amp 0x3F);\newline\newline	/* Update number of bits */\newline	if ((context-&gtcount[0] += ((uint32) inputLen &lt&lt 3))\newline		&lt ((uint32) inputLen &lt&lt 3))\newline		context-&gtcount[1]++;\newline	context-&gtcount[1] += ((uint32) inputLen &gt&gt 29);\newline\newline	partLen = 64 - index;\newline\newline	/* Transform as many times as possible.\newline	 */\newline	if (inputLen &gt= partLen) {\newline		memcpy\newline			((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) input, partLen);\newline		SHA1Transform(context-&gtstate, context-&gtbuffer);\newline\newline		for (i = partLen; i + 63 &lt inputLen; i += 64)\newline			SHA1Transform(context-&gtstate, &ampinput[i]);\newline\newline		index = 0;\newline	} else\newline		i = 0;\newline\newline	/* Buffer remaining input */\newline	memcpy\newline		((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) &amp input[i],\newline		 inputLen - i);\newline}\newline","{{{ MYSQL_SHA1Update\newlineSHA1 block update operation. Continues an SHA1 message-digest\newlineoperation, processing another message block, and updating the\newlinecontext.\newline \newline","","","","","","","","","","","","","","","","on","","","","","","","","on","","","","","","","on","on","","","","","","","","on","","","Set owner of mutex semaphore","Substitute variables in a string","Generates bold Note lines","trigger the arrival of more data.","perform various things","look for alternative routes.","Dump the list","Free all of memory used by a subtitle handle","We do nothing","Recover the tested file-system","linking of quotes","Remove ematch from the list of ematches it is linked to.","read","updating the context.","Allocate a block","{}","Read an isl_schedule from ""input"".","input the opacity positions","Insert an address entry into a skip list.","Routines placed in empty entries in the device tables","initialize a _pam_opts struct"
"391FPZIE4CMYGCMYKDBWLYE9BUHUHH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3YGXWBAF70HA5QEW9HBEMMFOFCB4CK","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:15:26 PDT 2019","Wed Apr 17 12:21:43 PDT 2019","Fri Apr 19 12:21:43 PDT 2019","2019-04-19 19:22:21 UTC","","","377","100% (27/27)","100% (27/27)","100% (27/27)","5197779","mozplugger-helper.c","static void setSwallowMutexOwner(uint32_t hostId, uint32_t pid)\newline{\newline     unsigned long temp[2] = {hostId, pid};\newline\newline     D(&quotSetting swallow mutex owner, hostId = 0x%08X, pid=%u\\n&quot, \newline                                            (unsigned) hostId, (unsigned) pid); \newline     XChangeProperty(display, wattr.root, swallowMutex,\newline                        XA_INTEGER, 32, PropModeAppend,\newline                        (unsigned char*) (&amptemp), 2);\newline}\newline","\newline Set owner of mutex semaphore\newline \newline @param[in] hostId The ID of the new owner of the mutex\newline @param[in] pid The process ID of the mutex\newline \newline @return none\newline \newline \newline","283896","ematch.c","void rtnl_ematch_unlink(struct rtnl_ematch *ematch)\newline{\newline	NL_DBG(2, &quotunlinked ematch %p from any lists\\n&quot, ematch);\newline\newline	if (!nl_list_empty(&ampematch-&gte_childs))\newline		NL_DBG(1, &quotwarning: ematch %p with childs was unlinked\\n&quot,\newline			  ematch);\newline\newline	nl_list_del(&ampematch-&gte_list);\newline	nl_init_list_head(&ampematch-&gte_list);\newline}\newline","\newline Remove ematch from the list of ematches it is linked to.\newline @arg ematch ematch object\newline \newline","517677","memory.c","char *caml_alloc_for_heap (asize_t request)\newline{\newline  char *mem;\newline  void *block;\newline                                              Assert (request % Page_size == 0);\newline  mem = caml_aligned_malloc (request + sizeof (heap_chunk_head),\newline                             sizeof (heap_chunk_head), &ampblock);\newline  if (mem == NULL) return NULL;\newline  mem += sizeof (heap_chunk_head);\newline  Chunk_size (mem) = request;\newline  Chunk_block (mem) = block;\newline  return mem;\newline}\newline","Allocate a block of the requested size, to be passed to\newline[caml_add_to_heap] later.\newline[request] must be a multiple of [Page_size].\newline[caml_alloc_for_heap] returns NULL if the request cannot be satisfied.\newlineThe returned pointer is a hp, but the header must be initialized by\newlinethe caller.\newline \newline","1528478","charcnv.c","size_t convert_charset ( charset_t from_set, charset_t to_set, charset_t cap_charset, const char *src, size_t src_len, char *dest, size_t dest_len, u_int16_t *flags)\newline{\newline    size_t i_len, o_len;\newline    ucs2_t *u;\newline    ucs2_t buffer[MAXPATHLEN +2];\newline    ucs2_t buffer2[MAXPATHLEN +2];\newline\newline    lazy_initialize_conv();\newline\newline    /* convert from_set to UCS2 */\newline    if ((size_t)(-1) == ( o_len = pull_charset_flags( from_set, cap_charset, src, src_len,\newline                                                      (char *) buffer, sizeof(buffer) -2, flags)) ) {\newline        LOG(log_error, logtype_default, &quotConversion failed ( %s to CH_UCS2 )&quot, charset_name(from_set));\newline        return (size_t) -1;\newline    }\newline\newline    if ( o_len == 0)\newline        return o_len;\newline\newline    /* Do pre/decomposition */\newline    i_len = sizeof(buffer2) -2;\newline    u = buffer2;\newline    if (CHECK_FLAGS(flags, CONV_DECOMPOSE) || (charsets[to_set] &amp&amp (charsets[to_set]-&gtflags &amp CHARSET_DECOMPOSED)) ) {\newline        if ( (size_t)-1 == (i_len = decompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_PRECOMPOSE) || !charsets[from_set] || (charsets[from_set]-&gtflags &amp CHARSET_DECOMPOSED)) {\newline        if ( (size_t)-1 == (i_len = precompose_w(buffer, o_len, u, &ampi_len)) )\newline            return (size_t)(-1);\newline    }\newline    else {\newline        u = buffer;\newline        i_len = o_len;\newline    }\newline    /* null terminate */\newline    u[i_len] = 0;\newline    u[i_len +1] = 0;\newline\newline    /* Do case conversions */\newline    if (CHECK_FLAGS(flags, CONV_TOUPPER)) {\newline        strupper_w(u);\newline    }\newline    else if (CHECK_FLAGS(flags, CONV_TOLOWER)) {\newline        strlower_w(u);\newline    }\newline\newline    /* Convert UCS2 to to_set */\newline    if ((size_t)(-1) == ( o_len = push_charset_flags( to_set, cap_charset, (char *)u, i_len, dest, dest_len, flags )) ) {\newline        LOG(log_error, logtype_default,\newline            &quotConversion failed (CH_UCS2 to %s):%s&quot, charset_name(to_set), strerror(errno));\newline        return (size_t) -1;\newline    }\newline    /* null terminate */\newline    dest[o_len] = 0;\newline    dest[o_len +1] = 0;\newline\newline    return o_len;\newline}\newline","\newline FIXME the size is a mess we really need a malloc/free logic\newline `dest size must be dest_len +2\newline \newline","2609159","isl_schedule_read.c","__isl_give isl_schedule *isl_schedule_read_from_file(isl_ctx *ctx, FILE *input)\newline{\newline	struct isl_stream *s;\newline	isl_schedule *schedule;\newline\newline	s = isl_stream_new_file(ctx, input);\newline	if (!s)\newline		return NULL;\newline	schedule = isl_stream_read_schedule(s);\newline	isl_stream_free(s);\newline\newline	return schedule;\newline}\newline","Read an isl_schedule from &quotinput&quot.\newline \newline","4357933","_colormap.c","Field _dxfeditor_to_opacity(Array opmap)\newline{\newline   int i,num_op,new_num,offset=0;\newline   Field opacity;\newline   float *op_pts,*op_data;\newline   Array a,b;\newline   Map *op;\newline\newline   opacity = NULL;\newline   /* if array is NULL create a default opacity field */\newline   if (!opmap){\newline      num_op = 2;\newline      opacity = (Field)_dxfcolorfield(NULL,NULL,num_op,0);\newline      a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline      b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline      op_pts = (float *)DXGetArrayData(a);\newline      op_data = (float *)DXGetArrayData(b);\newline      op_pts[0] = 0.0;\newline      op_pts[1] = 1.0;\newline      op_data[0] = op_data[1] = 1.0;\newline   }\newline      \newline   if (!DXGetArrayInfo(opmap,&ampnum_op,NULL,NULL,NULL,NULL))\newline      goto error;\newline   op = (Map *)DXGetArrayData(opmap);\newline   /* check for missing end points */\newline   new_num=num_op;\newline   if (op[num_op-1].level != 1.0)\newline      new_num++;\newline   if (op[0].level != 0.0) {\newline      offset = 1;\newline      new_num++;\newline   }\newline   \newline   /* build new field */\newline   opacity = (Field)_dxfcolorfield(NULL,NULL,new_num,0);\newline   a = (Array)DXGetComponentValue((Field)opacity,&quotpositions&quot);\newline   b = (Array)DXGetComponentValue((Field)opacity,&quotdata&quot);\newline   op_pts = (float *)DXGetArrayData(a);\newline   op_data = (float *)DXGetArrayData(b);\newline   if (offset == 1){\newline      op_pts[0] = 0.0;\newline      op_data[0] = op[0].value;\newline   }\newline   if (op[num_op-1].level != 1.0){\newline      op_pts[new_num-1] = 1.0;\newline      op_data[new_num-1] = op[num_op-1].value;\newline   }\newline   for (i=0; i&ltnum_op; i++){\newline      op_pts[offset + i] = op[i].level;\newline      op_data[offset + i] = op[i].value;\newline   }\newline\newline   if (!DXEndField(opacity))\newline      goto error;\newline   \newline   return (Field)opacity;\newline\newlineerror:\newline   if (opacity) DXDelete((Object)opacity);\newline   return NULL;\newline}\newline","input the opacity positions array and the opacity field \newline will be returned\newline \newline","3630269","chunk.c","static	skip_alloc_t	*insert_address(void *address, const int free_b,\newline					const unsigned int tot_size)\newline{\newline  skip_alloc_t	*new_p;\newline  \newline  /* get a new entry */\newline  new_p = get_slot();\newline  if (new_p == NULL) {\newline    /* error code set in get_slot */\newline    return NULL;\newline  }\newline  if (free_b) {\newline    new_p-&gtsa_flags = ALLOC_FLAG_FREE;\newline  }\newline  else {\newline    new_p-&gtsa_flags = ALLOC_FLAG_USER;\newline  }\newline  new_p-&gtsa_mem = address;\newline  new_p-&gtsa_total_size = tot_size;\newline  \newline  /* now try and insert the slot into the skip-list */\newline  if (! insert_slot(new_p, free_b)) {\newline    /* Sanity check.  error code set in insert_slot(). */\newline    return NULL;\newline  }\newline  \newline  return new_p;\newline}\newline","\newline static skip_alloc_t insert_address\newline \newline DESCRIPTION:\newline \newline Insert an address entry into a skip list.\newline \newline RETURNS:\newline \newline Success - Valid slot pointer.\newline \newline Failure - NULL\newline \newline ARGUMENTS:\newline \newline address -&gt Address we are inserting into the address list.\newline \newline free_b -&gt Insert a free address in the free-size list otherwise it\newline will go into the used address list.\newline \newline tot_size -&gt Total size of the chunk that we are inserting into the\newline list.\newline \newline","3104274","dev_name.c","int nulldev(void)\newline{\newline	return (D_SUCCESS);\newline}\newline","\newline Routines placed in empty entries in the device tables\newline \newline","5197386","pam_chroot.c","int _pam_do_chroot(pam_handle_t *pamh, struct _pam_opts *opts) {\newline	int err,debug;\newline	char const *user;\newline\newline	debug = opts-&gtflags &amp _PAM_OPTS_DEBUG;\newline\newline	err = pam_get_user(pamh, &ampuser, NULL);\newline	if(PAM_CONV_AGAIN == err) {\newline		_pam_log(LOG_NOTICE, &quot$s: retry username lookup later&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_INCOMPLETE;\newline	} else if(PAM_SUCCESS != err) {\newline		_pam_log(LOG_ERR, &quot%s: can&#039t get username&quot, opts-&gtmodule);\newline		return _PAM_CHROOT_SYSERR;\newline	}\newline\newline	if(opts-&gtchroot_dir) { /* overrides the conf file */\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: chrootdir (%s) specified, ignoring conf file&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir);\newline		}\newline		err = _PAM_CHROOT_OK;\newline	} else {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE,\newline					&quot%s: reading config file (%s)&quot, opts-&gtmodule, opts-&gtconf);\newline		}\newline		err = _pam_get_chrootdir(user, opts);\newline	}\newline\newline	if(_PAM_CHROOT_OK == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: preparing to chroot()&quot, opts-&gtmodule);\newline		}\newline\newline		if(NULL == opts-&gtchroot_dir) {\newline			/* This is a state that I should never see.  If the user wasn&#039t in\newline			 * the conf file, then USERNOTFOUND should have been returned. */\newline			_pam_log(LOG_ERR,\newline					&quot%s: no chroot_dir set for \\&quot%s\\&quot&quot, opts-&gtmodule, user);\newline			return _PAM_CHROOT_INTERNALERR;\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_SECCHECKS) {\newline			if(0 != _pam_check_path_perms(opts-&gtchroot_dir, opts)) {\newline				_pam_log(LOG_ERR,\newline						&quot%s: chroot_dir \\&quot%s\\&quot failed security check&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline				return _PAM_CHROOT_SYSERR;\newline			}\newline		}\newline\newline		if(opts-&gtflags &amp _PAM_OPTS_NO_CHROOT) {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: no_chroot is set, skipping chroot(%s)&quot,\newline						opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		} else if(chdir(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chdir(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else if(chroot(opts-&gtchroot_dir) != 0) {\newline			_pam_log(LOG_ERR,\newline					&quot%s: chroot(%s): %s&quot,\newline					opts-&gtmodule, opts-&gtchroot_dir, strerror(errno));\newline			return _PAM_CHROOT_SYSERR;\newline		} else {\newline			if(debug) {\newline				_pam_log(LOG_NOTICE,\newline						&quot%s: chroot(%s) ok&quot, opts-&gtmodule, opts-&gtchroot_dir);\newline			}\newline		}\newline		return _PAM_CHROOT_OK;\newline	} else if(_PAM_CHROOT_USERNOTFOUND == err) {\newline		if(debug) {\newline			_pam_log(LOG_NOTICE, &quot%s: no match for %s in %s&quot,\newline					opts-&gtmodule, user, opts-&gtconf);\newline		}\newline		return _PAM_CHROOT_USERNOTFOUND;\newline	} else {\newline		_pam_log(LOG_ERR,\newline				&quot%s: error determining chrootdir: user=\\&quot%s\\&quot, dir=\\&quot%s\\&quot&quot,\newline				opts-&gtmodule, user, opts-&gtchroot_dir);\newline		return err;\newline	}\newline}\newline","This is the workhorse function. All of the pam_sm_ functions should\newline initialize a _pam_opts struct with the command line args and flags,\newline then pass it to this function \newline","6626641","copt.c","static char *subst(char *pat)\newline{\newline  char buf[MAXLINE];\newline  char *cp, *cp1, *cp2, *varptr;\newline  long num;\newline  int i = 0;\newline  int j, pos;\newline\newline  while (*pat)\newline	if (pat[0] == &#039%&#039 &amp&amp isdigit(pat[1])) {\newline		/* Substitute with value of variable */\newline		cp = vars[pat[1] - &#0390&#039];\newline		while (cp != NULL &amp&amp *cp) {\newline			buf[i++] = *cp++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline		pat += 2;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039(&#039) {\newline		/* Substitute with expression */\newline		cp = pat + 2;\newline		if ((pat = strchr(cp, &#039)&#039)) == NULL || pat - cp &lt= 0)\newline			num = 0;\newline		else\newline			num = eval(cp, pat - cp);\newline		if (i &gt= MAXLINE - 20) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline		i += sprintf(&ampbuf[i], &quot%s$%lx&quot, num &lt 0 ? &quot-&quot : &quot&quot, labs(num));\newline		pat++;\newline	} else if (pat[0] == &#039%&#039 &amp&amp pat[1] == &#039=&#039) {\newline		/* Substitute with converted variable */\newline		/* First seperate all parts of the pattern string */\newline		cp = pat + 2;\newline		cp1 = cp2 = varptr = NULL;\newline		if (*cp == &#039[&#039) {\newline			cp1 = ++cp;\newline			while (*cp &amp&amp *cp != &#039]&#039)\newline				cp++;\newline			if (cp[0] == &#039]&#039 &amp&amp cp[1] == &#039[&#039) {\newline				cp += 2;\newline				cp2 = cp;\newline				while (*cp &amp&amp *cp != &#039]&#039)\newline					cp++;\newline				if (cp[0] == &#039]&#039 &amp&amp isdigit(cp[1]))\newline					 varptr = vars[cp[1] - &#0390&#039];\newline			}\newline		}\newline		if (cp1 == NULL || cp2 == NULL || varptr == NULL) {\newline			buf[i++] = *pat++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline			continue;\newline		}\newline		pat = cp + 2;\newline		/* Now scan through the first string to find variable value */\newline		cp1--;\newline		pos = 0;\newline		while (*cp1 != &#039]&#039) {\newline			cp1++;\newline			j = strcspn(cp1, &quot|]&quot);\newline			if (strlen(varptr) == j &amp&amp !strncmp(cp1, varptr, j))\newline				break;\newline			pos++;\newline			cp1 += j;\newline		}\newline		if (*cp1 == &#039]&#039)\newline			continue;\newline		/* Scan through the second string to find the conversion */\newline		cp2--;\newline		while (*cp2 != &#039]&#039 &amp&amp pos &gt 0) {\newline			cp2++;\newline			j = strcspn(cp2, &quot|]&quot);\newline			pos--;\newline			cp2 += j;\newline		}\newline		if (*cp2 == &#039]&#039 || pos != 0)\newline			continue;\newline		/* Insert conversion string into destination */\newline		cp2++;\newline		while (*cp2 != &#039|&#039 &amp&amp *cp2 != &#039]&#039) {\newline			buf[i++] = *cp2++;\newline			if (i &gt= MAXLINE - 1) {\newline				fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline				exit(1);\newline			}\newline		}\newline	} else {\newline		buf[i++] = *pat++;\newline		if (i &gt= MAXLINE - 1) {\newline			fprintf(stderr, &quot%s: line too long\\n&quot, progname);\newline			exit(1);\newline		}\newline	}\newline\newline  buf[i] = &#039\\0&#039;\newline  return(install(buf, i));\newline}\newline","\newline Substitute variables in a string\newline \newline","3370483","htmlgenerator.cpp","void HtmlGenerator::generateAssociatedPropertyNotes(const FunctionNode* fn)\newline{\newline    if (fn-&gthasAssociatedProperties()) {\newline        out() &lt&lt &quot&ltp&gt&ltb&gtNote:&lt/b&gt &quot;\newline        PropNodeList propertyNodes = fn-&gtassociatedProperties();\newline        std::sort(propertyNodes.begin(), propertyNodes.end(), Node::nodeNameLessThan);\newline        foreach (const PropertyNode* pn, propertyNodes) {\newline            QString msg;\newline            switch (pn-&gtrole(fn)) {\newline            case PropertyNode::Getter:\newline                msg = QStringLiteral(&quotGetter function &quot);\newline                break;\newline            case PropertyNode::Setter:\newline                msg = QStringLiteral(&quotSetter function &quot);\newline                break;\newline            case PropertyNode::Resetter:\newline                msg = QStringLiteral(&quotResetter function &quot);\newline                break;\newline            case PropertyNode::Notifier:\newline                msg = QStringLiteral(&quotNotifier signal &quot);\newline                break;\newline            default:\newline                break;\newline            }\newline            QString link = linkForNode(pn, 0);\newline            out() &lt&lt msg &lt&lt &quotfor property &lta href=\\&quot&quot &lt&lt link &lt&lt &quot\\&quot&gt&quot &lt&lt pn-&gtname() &lt&lt &quot&lt/a&gt. &quot;\newline        }\newline        out() &lt&lt &quot&lt/p&gt&quot;\newline    }\newline}\newline","!\newlineGenerates bold Note lines that explain how function \\a fn\newlineis associated with each of its associated properties.\newline \newline","5084075","mock_buckets.c","apr_status_t serf_bucket_mock_more_data_arrived(serf_bucket_t *bucket)\newline{\newline    mockbkt_context_t *ctx = bucket-&gtdata;\newline    mockbkt_action *action;\newline    apr_status_t status;\newline\newline    status = next_action(ctx);\newline    if (status)\newline        return status;\newline\newline    action = &ampctx-&gtactions[ctx-&gtcurrent_action];\newline    if (ctx-&gtremaining_data == 0 &amp&amp action-&gtstatus == APR_EAGAIN) {\newline        ctx-&gtremaining_times--;\newline        action-&gttimes--;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","An action { &quot&quot, 0, APR_EAGAIN } means that serf should exit serf_context_run\newlineand pass the buck back to the application. As long as no new data arrives,\newlinethis action remains active.\newline\newlineThis function allows the &#039application&#039 to trigger the arrival of more data.\newlineIf the current action is { &quot&quot, 0, APR_EAGAIN }, reduce the number of times\newlinethe action should run by one, and proceed with the next action if needed.\newline \newline","5206276","main.c","void new_vi(void)\newline{\newline   gs_apply_cheats();\newline\newline   main_check_inputs();\newline\newline#if 0\newline   timed_sections_refresh();\newline\newline   pause_loop();\newline\newline   apply_speed_limiter();\newline#endif\newline}\newline","called on vertical interrupt.\newline Allow the core to perform various things \newline","3684765","get_neigh.c","static void invalidate_route(struct routeinfo *routehead, unsigned short node)\newline{\newline	struct routeinfo *route, *cheaproute = NULL;\newline\newline	for (route = routehead-&gtnext; route; route=route-&gtnext)\newline	{\newline		if (route-&gtrouter == node)\newline		{\newline			route-&gtvalid = 0;\newline		}\newline	}\newline	set_lowest_cost_route(routehead, node);\newline}\newline","When a routing node goes down, look for alternative routes. \newline","77424","ola-rdm.cpp","void DisplayPIDsAndExit(uint16_t manufacturer_id,\newline                        const PidStoreHelper &amppid_helper) {\newline  vector&ltstring&gt pid_names;\newline  pid_helper.SupportedPids(manufacturer_id, &amppid_names);\newline  sort(pid_names.begin(), pid_names.end());\newline\newline  vector&ltstring&gt::const_iterator iter = pid_names.begin();\newline  for (; iter != pid_names.end(); ++iter) {\newline    cout &lt&lt *iter &lt&lt endl;\newline  }\newline  exit(ola::EXIT_OK);\newline}\newline","\newline Dump the list of known pids\newline \newline","216178","subtitle_free.c","void quvi_subtitle_free(quvi_subtitle_t handle)\newline{\newline  m_subtitle_free(handle);\newline}\newline","@brief Free all of memory used by a subtitle handle\newline@note If handle is NULL the function simply returns\newline@sa @ref parse_subtitle\newline@ingroup subprop\newline \newline","4322322","util.h","static inline void memcpy_safe(void *dst, const void *src, size_t n) {\newline        if (n == 0)\newline                return;\newline        assert(src);\newline        memcpy(dst, src, n);\newline}\newline","\newline Normal memcpy requires src to be nonnull. We do nothing if n is 0.\newline \newline","6372657","integck.c","static int recover_tested_fs(void)\newline{\newline	int ret;\newline	unsigned long flags;\newline	unsigned int  um_rorw, rorw2;\newline	struct mntent *mntent;\newline\newline	CHECK(chdir(&quot/&quot) == 0);\newline\newline	/* Choose what to do */\newline	um_rorw = random_no(2);\newline	rorw2 = random_no(2);\newline\newline	/*\newline	 * At this point we do not know for sure whether the tested FS is\newline	 * mounted, because the emulated power cut error could have happened\newline	 * while mounting in &#039remount_tested_fs()&#039.\newline	 */\newline	mntent = get_tested_fs_mntent();\newline	if (mntent)\newline		CHECK(umount(fsinfo.mount_point) != -1);\newline\newline	if (args.reattach)\newline		CHECK(reattach() == 0);\newline\newline	if (!um_rorw) {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/W&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline	} else {\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, fsinfo.mount_flags | MS_RDONLY,\newline			    fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, but cannot mount it back R/O&quot,\newline			    fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point,\newline			    fsinfo.fstype, flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotunmounted %s, mounted R/O, but cannot re-mount it R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	if (rorw2) {\newline		flags = fsinfo.mount_flags | MS_RDONLY | MS_REMOUNT;\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotcannot re-mount %s R/O&quot, fsinfo.mount_point);\newline			return -1;\newline		}\newline\newline		flags = fsinfo.mount_flags | MS_REMOUNT;\newline		flags &amp= ~((unsigned long)MS_RDONLY);\newline		ret = mount(fsinfo.fsdev, fsinfo.mount_point, fsinfo.fstype,\newline			    flags, fsinfo.mount_opts);\newline		if (ret) {\newline			pcv(&quotremounted %s R/O, but cannot re-mount it back R/W&quot,\newline			     fsinfo.mount_point);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Recover the tested file-system from an emulated power cut failure by\newline unmounting it and mounting it again.\newline \newline","675719","read-dict.c","void add_empty_word(Dictionary const dict, X_node *x)\newline{\newline	Exp *zn, *an;\newline	E_list *elist, *flist;\newline	Exp_list eli = { NULL };\newline\newline	/* The left-wall already has ZZZ-. The right-wall will not arrive here. */\newline	if (MT_WALL == x-&gtword-&gtmorpheme_type) return;\newline\newline	/* Replace plain-word-exp by {ZZZ+} &amp (plain-word-exp) in each X_node.  */\newline	for(; NULL != x; x = x-&gtnext)\newline	{\newline		/* Ignore stems for now, decreases a little the overhead for\newline		 * stem-suffix languages. */\newline		if (is_stem(x-&gtstring)) continue; /* Avoid an unneeded overhead. */\newline		//lgdebug(+0, &quotProcessing &#039%s&#039\\n&quot, x-&gtstring);\newline\newline		/* zn points at {ZZZ+} */\newline		zn = Exp_create(&ampeli);\newline		zn-&gtdir = &#039+&#039;\newline		zn-&gtu.string = string_set_add(EMPTY_CONNECTOR, dict-&gtstring_set);\newline		zn-&gtmulti = false;\newline		zn-&gttype = CONNECTOR_type;\newline		zn-&gtcost = 0.0;\newline		zn = make_optional_node(&ampeli, zn);\newline\newline		/* flist is plain-word-exp */\newline		flist = (E_list *) xalloc(sizeof(E_list));\newline		flist-&gtnext = NULL;\newline		flist-&gte = x-&gtexp;\newline\newline		/* elist is {ZZZ+} , (plain-word-exp) */\newline		elist = (E_list *) xalloc(sizeof(E_list));\newline		elist-&gtnext = flist;\newline		elist-&gte = zn;\newline\newline		/* an will be {ZZZ+} &amp (plain-word-exp) */\newline		an = Exp_create(&ampeli);\newline		an-&gttype = AND_type;\newline		an-&gtcost = 0.0;\newline		an-&gtu.l = elist;\newline\newline		x-&gtexp = an;\newline	}\newline}\newline","Insert ZZZ+ connectors.\newline This function was mainly used to support using empty-words, a concept\newline that has been eliminated. However, it is still used to support linking of\newline quotes that don&#039t get the QUc/QUd links.\newline \newline","6062221","mkeot.c","static bool read_2be_signed(FILE *f, short *x)\newline{\newline  unsigned char s[2];\newline  union {short s; unsigned short u;} h;\newline\newline  if (fread(s, 1, 2, f) != 2) return false;\newline  h.u = (s[0] &lt&lt 8) + s[1];\newline  *x = h.s;\newline  return true;\newline}\newline","read_2be_signed -- read a big endian short \newline","1805380","sha1.c","void MYSQL_SHA1Update(MYSQL_SHA1_CTX * context, const unsigned char *input,\newline			   size_t inputLen)\newline{\newline	unsigned int i, index, partLen;\newline\newline	/* Compute number of bytes mod 64 */\newline	index = (unsigned int) ((context-&gtcount[0] &gt&gt 3) &amp 0x3F);\newline\newline	/* Update number of bits */\newline	if ((context-&gtcount[0] += ((uint32) inputLen &lt&lt 3))\newline		&lt ((uint32) inputLen &lt&lt 3))\newline		context-&gtcount[1]++;\newline	context-&gtcount[1] += ((uint32) inputLen &gt&gt 29);\newline\newline	partLen = 64 - index;\newline\newline	/* Transform as many times as possible.\newline	 */\newline	if (inputLen &gt= partLen) {\newline		memcpy\newline			((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) input, partLen);\newline		SHA1Transform(context-&gtstate, context-&gtbuffer);\newline\newline		for (i = partLen; i + 63 &lt inputLen; i += 64)\newline			SHA1Transform(context-&gtstate, &ampinput[i]);\newline\newline		index = 0;\newline	} else\newline		i = 0;\newline\newline	/* Buffer remaining input */\newline	memcpy\newline		((unsigned char*) &amp context-&gtbuffer[index], (unsigned char*) &amp input[i],\newline		 inputLen - i);\newline}\newline","{{{ MYSQL_SHA1Update\newlineSHA1 block update operation. Continues an SHA1 message-digest\newlineoperation, processing another message block, and updating the\newlinecontext.\newline \newline","","","","","","","","","on","","","","","","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","Set owner of mutex semaphore","Substitute variables in a string","Generates bold Note lines","allows the 'application' to trigger the arrival of more data.","Allow the core to perform various things","When a routing node goes down, look for alternative routes.","Dump the list of known pids","Free all of memory used by a subtitle handle","{}","Recover the tested file-system from an emulated power cut failure","Insert ZZZ+ connectors.","Remove ematch from the list of ematches it is linked to.","read a big endian short","block update operation.","Allocate a block of the requested size,","{}","Read an isl_schedule from ""input"".","opacity field will be returned","Insert an address entry into a skip list.","Routines placed in empty entries in the device tables","{}"
"3D1TUISJWI0YC7XIQVTHLAFOB7WUIA","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3483FV8BEEJBMVQ8VCFN77QGZC526V","AK1X37UFDPT4I","Approved","Wed Apr 17 12:22:06 PDT 2019","Wed Apr 17 12:27:34 PDT 2019","Fri Apr 19 12:27:34 PDT 2019","2019-04-19 19:28:21 UTC","","","328","100% (51/51)","100% (51/51)","100% (51/51)","4378774","fsck.c","static int digest_encode(const char *src, int len, char *dst)\newline{\newline	int i = 0, bits = 0, ac = 0;\newline	char *cp = dst;\newline\newline	while (i &lt len) {\newline		ac += (((unsigned char) src[i]) &lt&lt bits);\newline		bits += 8;\newline		do {\newline			*cp++ = lookup_table[ac &amp 0x3f];\newline			ac &gt&gt= 6;\newline			bits -= 6;\newline		} while (bits &gt= 6);\newline		i++;\newline	}\newline	if (bits)\newline		*cp++ = lookup_table[ac &amp 0x3f];\newline	*cp = 0;\newline	return cp - dst;\newline}\newline","\newline digest_encode() -\newline \newline Encodes the input digest using characters from the set [a-zA-Z0-9_+].\newline The encoded string is roughly 4/3 times the size of the input string.\newline \newline","5980191","mur_read_file.c","uint4 mur_prev(jnl_ctl_list *jctl, off_jnl_t dskaddr)\newline{\newline	off_jnl_t	buff_offset;\newline	uint4		status, partial_reclen;\newline	jrec_suffix	*suffix;\newline	mur_buff_desc_t	*swap_buff;\newline	boolean_t	good_suffix, good_prefix;\newline	mur_read_desc_t	*mur_desc;\newline\newline	mur_desc = jctl-&gtreg_ctl-&gtmur_desc;\newline	if (0 != dskaddr)\newline	{ /* read record at dskaddr */\newline		assert(dskaddr &lt jctl-&gteof_addr);\newline		assert(dskaddr &gt= JNL_HDR_LEN);\newline		if (dskaddr &gt= jctl-&gteof_addr || dskaddr &lt JNL_HDR_LEN)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotRequested offset out of range [prev]&quot));\newline			return (dskaddr &gt= jctl-&gteof_addr ? ERR_JNLREADEOF : ERR_JNLREADBOF);\newline		}\newline		assert(dskaddr == ROUND_UP2(dskaddr, JNL_REC_START_BNDRY)); /* dskaddr must be aligned at JNL_REC_START_BNDRY */\newline		MUR_FREAD_CANCEL(jctl, mur_desc, status);\newline		if (SS_NORMAL != status)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotCould not cancel prior read [prev]&quot), jctl-&gtstatus);\newline			return jctl-&gtstatus;\newline		}\newline		mur_desc-&gtbuff_index = 1;\newline		mur_desc-&gtcur_buff = &ampmur_desc-&gtseq_buff[mur_desc-&gtbuff_index];\newline		mur_desc-&gtsec_buff = &ampmur_desc-&gtseq_buff[1 - mur_desc-&gtbuff_index];\newline		mur_desc-&gtcur_buff-&gtdskaddr = ROUND_DOWN2(dskaddr, MUR_BUFF_SIZE);\newline		mur_desc-&gtcur_buff-&gtblen = MIN(MUR_BUFF_SIZE, jctl-&gteof_addr - mur_desc-&gtcur_buff-&gtdskaddr);\newline		buff_offset = dskaddr - mur_desc-&gtcur_buff-&gtdskaddr;\newline		assert(JREC_PREFIX_UPTO_LEN_SIZE &lt= mur_desc-&gtcur_buff-&gtblen - buff_offset);\newline			/* we rely on reading at least up to the record length field (forwptr) */\newline		if (SS_NORMAL != (status = mur_freadw(jctl, mur_desc-&gtcur_buff)))\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline					LEN_AND_LIT(&quotError from synchronous read into cur_buff [prev]&quot), status);\newline			return status;\newline		}\newline		mur_desc-&gtjnlrec = (jnl_record *)(mur_desc-&gtcur_buff-&gtbase + buff_offset);\newline		good_suffix = TRUE;\newline		if (FALSE != (good_prefix = IS_VALID_LEN_FROM_PREFIX(mur_desc-&gtjnlrec, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjreclen = mur_desc-&gtjnlrec-&gtprefix.forwptr;\newline			if (MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr)\newline			{ /* while we process the just read chunk, post a read for the immediately preceding chunk */\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline					   	LEN_AND_LIT(&quotCould not initiate read into sec_buff in [prev] (dskaddr &gt 0)&quot),\newline						status);\newline					return status;\newline				}\newline			} else\newline			{ /* we read the beginning MUR_BUFF_SIZE (or smaller) chunk from file, no previous chunk exists */\newline				assert(0 == mur_desc-&gtcur_buff-&gtdskaddr);\newline			}\newline			if (buff_offset + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gtblen)\newline			{ /* Journal record straddles MUR_BUFF_SIZE boundary, did not read the entire record, read what&#039s left into\newline			   * aux_buff2 which is located at the end of seq_buff[1], the current buffer */\newline				mur_desc-&gtaux_buff2.dskaddr = mur_desc-&gtcur_buff-&gtdskaddr + mur_desc-&gtcur_buff-&gtblen;\newline				mur_desc-&gtaux_buff2.blen = (buff_offset + mur_desc-&gtjreclen - mur_desc-&gtcur_buff-&gtblen);\newline				if (FALSE != (good_prefix =\newline					(jctl-&gteof_addr - mur_desc-&gtaux_buff2.dskaddr &gt= mur_desc-&gtaux_buff2.blen)))\newline				{\newline					if (SS_NORMAL != (status = mur_freadw(jctl, &ampmur_desc-&gtaux_buff2)))\newline					{\newline						gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3,\newline							jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, mur_desc-&gtaux_buff2.dskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError in synchronous read into aux_buff [prev]&quot), status);\newline						return status;\newline					}\newline				} else\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3,\newline						jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, dskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond end of file [prev] (dskaddr &gt 0)&quot));\newline					return ERR_JNLBADRECFMT;\newline				}\newline			}\newline		} /* end good_prefix */\newline	} else\newline	{ /* dskaddr == 0, locate the previous record in the buffer, reading from disk if necessary */\newline		assert(JNL_HDR_LEN &lt= jctl-&gtrec_offset);\newline		suffix = (jrec_suffix *)((char *)mur_desc-&gtjnlrec - JREC_SUFFIX_SIZE);\newline		/* ok to test with possibly invalid backptr, we test for validity below */\newline		if (((unsigned char *)suffix &gt mur_desc-&gtcur_buff-&gtbase)\newline			&amp&amp (((unsigned char *)mur_desc-&gtjnlrec - suffix-&gtbackptr) &gt= mur_desc-&gtcur_buff-&gtbase))\newline		{	/* prev record is contained completely in the current buffer */\newline			if ((0 == mur_desc-&gtbuff_index)\newline				&amp&amp ((unsigned char *)mur_desc-&gtjnlrec + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gttop)\newline				&amp&amp (0 &lt mur_desc-&gtcur_buff-&gtdskaddr)) /* end of rec in sec_buff and there is data to be read */\newline			{ /* we just finished processing the journal record that straddled seq_buff[0] and seq_buff[1],\newline			   * start read in the now free secondary buffer (seq_buff[1]) to overlap with processing */\newline				assert(MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr);\newline				assert(!mur_desc-&gtsec_buff-&gtread_in_progress);\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotCould not initiate read into sec_buff [prev] (dskaddr == 0)&quot), status);\newline					return status;\newline				}\newline			}\newline		} else\newline		{ /* prev record completely in sec_buff or overlaps cur_buff and sec_buff */\newline			if (0 == mur_desc-&gtbuff_index)\newline			{ /* copy partial record to just past the end of seq_buff[1], i.e., aux_seq_buff[1] to make the record\newline			   * available in contiguous memory */\newline				partial_reclen = (uint4)((unsigned char *)mur_desc-&gtjnlrec - mur_desc-&gtseq_buff[0].base);\newline				if (0 &lt partial_reclen)\newline					memcpy(mur_desc-&gtseq_buff[1].top, mur_desc-&gtseq_buff[0].base, partial_reclen);\newline				suffix = (jrec_suffix *)(mur_desc-&gtseq_buff[1].top + partial_reclen - JREC_SUFFIX_SIZE);\newline			}\newline			/* before switching the buffers, wait for completion of pending I/O */\newline			if (mur_desc-&gtsec_buff-&gtread_in_progress)\newline			{\newline				MUR_FREAD_WAIT(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError waiting for sec_buff read to complete [prev]&quot),\newline							status);\newline					return status;\newline				}\newline			}\newline			/* If possible, overlap I/O with processing, read into available buffer */\newline			if ((0 == mur_desc-&gtbuff_index || /* we just copied partial record (if any), OR */\newline			    (unsigned char *)mur_desc-&gtjnlrec == mur_desc-&gtcur_buff-&gtbase) /* we completely processed cur_buff */\newline				&amp&amp 0 &lt mur_desc-&gtsec_buff-&gtdskaddr) /* there is data to be read */\newline			{\newline				assert(mur_desc-&gtsec_buff-&gtdskaddr &gt= MUR_BUFF_SIZE);\newline				mur_desc-&gtcur_buff-&gtdskaddr = mur_desc-&gtsec_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtcur_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotCould not initiate read into cur_buff [prev]&quot), status);\newline					return status;\newline				}\newline			}\newline			/* Make the buffer that has data that was previously read current */\newline			mur_desc-&gtbuff_index = 1 - mur_desc-&gtbuff_index;\newline			swap_buff = mur_desc-&gtcur_buff;\newline			mur_desc-&gtcur_buff = mur_desc-&gtsec_buff;\newline			mur_desc-&gtsec_buff = swap_buff;\newline		}\newline		good_prefix = TRUE;\newline		if (FALSE != (good_suffix = IS_VALID_LEN_FROM_SUFFIX(suffix, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjnlrec = (jnl_record *)((char *)suffix + JREC_SUFFIX_SIZE - suffix-&gtbackptr);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &gt= mur_desc-&gtcur_buff-&gtbase);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &lt  mur_desc-&gtcur_buff-&gttop);\newline			mur_desc-&gtjreclen = suffix-&gtbackptr;\newline			if (jctl-&gtrec_offset &lt mur_desc-&gtjreclen + JNL_HDR_LEN)\newline			{\newline				gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, jctl-&gtrec_offset, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond beginning of file [prev]&quot));\newline				return ERR_JNLBADRECFMT;\newline			}\newline		}\newline	} /* end of dskaddr == 0 */\newline	if (good_prefix &amp&amp good_suffix &amp&amp IS_VALID_JNLREC(mur_desc-&gtjnlrec, jctl-&gtjfh))\newline		return SS_NORMAL;\newline	return ERR_JNLBADRECFMT;\newline}\newline","#GTM_THREAD_SAFE : The below function (mur_prev) is thread-safe \newline","3428267","ccid_usb.c","static void Multi_PollingTerminate(struct usbDevice_MultiSlot_Extension *msExt)\newline{\newline	struct libusb_transfer *transfer;\newline\newline	if (msExt &amp&amp !msExt-&gtterminated)\newline	{\newline		msExt-&gtterminated = TRUE;\newline\newline		transfer = usbDevice[msExt-&gtreader_index].polling_transfer;\newline\newline		if (transfer)\newline		{\newline			int ret;\newline\newline			ret = libusb_cancel_transfer(transfer);\newline			if (ret &lt 0)\newline				DEBUG_CRITICAL2(&quotlibusb_cancel_transfer failed: %d&quot, ret);\newline		}\newline	}\newline} /* Multi_PollingTerminate */\newline","\newline \newline Multi_PollingTerminate\newline \newline \newline","5830889","server.c","static void clearq(struct server_list *xx)\newline{\newline  struct server_list *x;\newline\newline  while (xx) {\newline    x = xx-&gtnext;\newline    if (xx-&gtname)\newline      nfree(xx-&gtname);\newline    if (xx-&gtpass)\newline      nfree(xx-&gtpass);\newline    if (xx-&gtrealname)\newline      nfree(xx-&gtrealname);\newline    nfree(xx);\newline    xx = x;\newline  }\newline}\newline","Clear out the given server_list.\newline \newline","1448774","check_inifcns.cpp","static unsigned inifcns_check_tan()\newline{\newline	unsigned result = 0;\newline	bool errorflag;\newline	\newline	// compare tan((q*Pi).evalf()) with tan(q*Pi).eval().evalf() at various\newline	// points.  E.g. if tan(Pi/12) returns something symbolic this should be\newline	// equal to 2-sqrt(3).  This routine will spot programming mistakes of \newline	// this kind:\newline	errorflag = false;\newline	ex argument;\newline	numeric epsilon(double(1e-8));\newline	for (int n=-340; n&lt=340; ++n) {\newline		if (!(n%30) &amp&amp (n%60))  // skip poles\newline			++n;\newline		argument = n*Pi/60;\newline		if (abs(tan(evalf(argument))-evalf(tan(argument)))&gtepsilon) {\newline			clog &lt&lt &quottan(&quot &lt&lt argument &lt&lt &quot) returns &quot\newline			     &lt&lt tan(argument) &lt&lt endl;\newline			errorflag = true;\newline		}\newline	}\newline	if (errorflag)\newline		++result;\newline	\newline	return result;\newline}\newline","Simple tests on the tangent trigonometric function. \newline","6038115","dmmain.c","static int display_close(void *handle, void *device)\newline{\newline    IMAGE *img = image_find(handle, device);\newline    if (img == NULL)\newline       return -1;\newline\newline    gsdll_poll(handle);\newline\newline    /* remove from list */\newline    if (img == first_image)\newline        first_image = img-&gtnext;\newline    else\newline    {\newline        IMAGE *tmp;\newline        for (tmp = first_image; tmp!=0; tmp=tmp-&gtnext)\newline        {\newline            if (img == tmp-&gtnext)\newline            tmp-&gtnext = img-&gtnext;\newline        }\newline    }\newline\newline    DisposePixMap(img-&gtpixmapHdl);   // need to go in doCloseWindow()\newline    DisposeWindow(img-&gtwindowRef);\newline\newline    free(img);\newline\newline    return 0;\newline}\newline","This is the last event from this device. \newline","812839","webkitwebnavigationaction.cpp","gint webkit_web_navigation_action_get_button(WebKitWebNavigationAction* navigationAction)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_WEB_NAVIGATION_ACTION(navigationAction), -1);\newline\newline    return navigationAction-&gtpriv-&gtbutton;\newline}\newline","\newline webkit_web_navigation_action_get_button:\newline @navigationAction: a #WebKitWebNavigationAction\newline \newline The GTK+ identifier for the mouse button used to click. Notice that GTK+ button values\newline are 1, 2 and 3 for left, middle and right buttons, so they are DOM button values +1. If the action was not\newline initiated by a mouse click the value will be -1.\newline \newline Return value: the mouse button used to click\newline \newline Since: 1.0.3\newline \newline","6362084","disks.cpp","int DiskEntry::sysCall(QString &amp completeCommand)\newline{\newline    if (readingSysStdErrOut || sysProc-&gtstate() == QProcess::Running )\newline        return -1;\newline\newline    sysStringErrOut=i18n(&quotCalled: %1\\n\\n&quot, completeCommand); // put the called command on ErrOut\newline    sysProc-&gtclearProgram();\newline\newline    //Split command and arguments to use the new API, otherwise it doesn&#039t work\newline    QTextStream tS(&ampcompleteCommand);\newline\newline    QString command;\newline    tS &gt&gt command;\newline\newline    QString tmp;\newline    QStringList args;\newline    while( !tS.atEnd() )\newline    {\newline        tS &gt&gt tmp;\newline        args &lt&lt tmp;\newline    }\newline\newline    sysProc-&gtsetProgram(command, args);\newline    sysProc-&gtstart();\newline\newline    if ( !sysProc-&gtwaitForStarted(-1) )\newline        qCCritical(KDF) &lt&lt i18n(&quotcould not execute %1&quot, command) ;\newline\newline    sysProc-&gtwaitForFinished(-1);\newline\newline    if (sysProc-&gtexitCode()!=0)\newline        emit sysCallError(this, sysProc-&gtexitStatus());\newline\newline    return (sysProc-&gtexitCode());\newline}\newline","\newline starts a command on the underlying system via /bin/sh\newline \newline","2726110","rnd.c","int32 rnd ()\newline{\newline  register long low, high, test;\newline\newline  high = rnd_seed / RNG_Q;\newline  low = rnd_seed % RNG_Q;\newline  test = RNG_A * low - RNG_R * high;\newline  if (test &gt 0)\newline    rnd_seed = test;\newline  else\newline    rnd_seed = test + RNG_M;\newline  return rnd_seed;\newline}\newline","returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 \newline","893020","script_functions.c","int c_pin_window(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotpin_window: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline		if (window) {\newline			wnck_window_pin(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Pins the window\newline \newline","6449222","qwt_plot.cpp","bool QwtPlot::eventFilter( QObject *object, QEvent *event )\newline{\newline    if ( object == d_data-&gtcanvas )\newline    {\newline        if ( event-&gttype() == QEvent::Resize )\newline        {\newline            updateCanvasMargins();\newline        }\newline        else if ( event-&gttype() == QEvent::ContentsRectChange )\newline        {\newline            updateLayout();\newline        }\newline    }\newline\newline    return QFrame::eventFilter( object, event );\newline}\newline","!\newline\\brief Event filter\newlineThe plot handles the following events for the canvas:\newline- QEvent::Resize\newlineThe canvas margins might depend on its size\newline- QEvent::ContentsRectChange\newlineThe layout needs to be recalculated\newline\\param object Object to be filtered\newline\\param event Event\newline\\return See QFrame::eventFilter()\newline\\sa updateCanvasMargins(), updateLayout()\newline \newline","2776384","msc.c","static const char *findAttrib(const struct MscAttribTag *attr, MscAttribType a)\newline{\newline    while(attr != NULL &amp&amp attr-&gttype != a)\newline    {\newline        attr = attr-&gtnext;\newline    }\newline\newline    if(attr != NULL)\newline    {\newline        return attr-&gtvalue;\newline    }\newline    else\newline    {\newline        return NULL;\newline    }\newline}\newline","Find come attrbute in an attribute list.\newline \newline \\param[in] attr Head of the linked list to search.\newline \\param[in] a The attribute type to find.\newline \\retval NULL If the attribute was not found or the passed list was NULL.\newline \newline","6582023","zeroconf.c","int dcc_zeroconf_add_hosts(struct dcc_hostdef **ret_list, int *ret_nhosts, int n_slots, struct dcc_hostdef **ret_prev) {\newline    char *host_file = NULL, *lock_file = NULL, *s = NULL;\newline    int lock_fd = -1, host_fd = -1;\newline    int fork_daemon = 0;\newline    int r = -1;\newline    char *dir;\newline    struct stat st;\newline\newline    if (get_zeroconf_dir(&ampdir) != 0) {\newline        rs_log_crit(&quotfailed to get zeroconf dir.\\n&quot);\newline        goto finish;\newline    }\newline\newline    lock_file = malloc(strlen(dir) + sizeof(&quot/lock&quot));\newline    assert(lock_file);\newline    sprintf(lock_file, &quot%s/lock&quot, dir);\newline\newline    host_file = malloc(strlen(dir) + sizeof(&quot/hosts&quot));\newline    assert(host_file);\newline    sprintf(host_file, &quot%s/hosts&quot, dir);\newline\newline    /* Open lock file */\newline    if ((lock_fd = open(lock_file, O_RDWR|O_CREAT, 0666)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, lock_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Try to lock the lock file */\newline    if (generic_lock(lock_fd, 1, 1, 0) &gt= 0) {\newline        /* The lock succeeded =&gt there&#039s no daemon running yet! */\newline        fork_daemon = 1;\newline        generic_lock(lock_fd, 1, 0, 0);\newline    }\newline\newline    close(lock_fd);\newline\newline    /* Shall we fork a new daemon? */\newline    if (fork_daemon) {\newline        pid_t pid;\newline\newline        rs_log_info(&quotSpawning zeroconf daemon.\\n&quot);\newline\newline        if ((pid = fork()) == -1) {\newline            rs_log_crit(&quotfork() failed: %s\\n&quot, strerror(errno));\newline            goto finish;\newline        } else if (pid == 0) {\newline            int fd;\newline            /* Child */\newline\newline            /* Close file descriptors and replace them by /dev/null */\newline            close(0);\newline            close(1);\newline            close(2);\newline            fd = open(&quot/dev/null&quot, O_RDWR);\newline            assert(fd == 0);\newline            fd = dup(0);\newline            assert(fd == 1);\newline            fd = dup(0);\newline            assert(fd == 2);\newline\newline#ifdef HAVE_SETSID\newline            setsid();\newline#endif\newline\newline            chdir(&quot/&quot);\newline            rs_add_logger(rs_logger_syslog, RS_LOG_DEBUG, NULL, 0);\newline            _exit(daemon_proc(host_file, lock_file, n_slots));\newline        }\newline\newline        /* Parent */\newline\newline        /* Wait some time for initial host gathering */\newline        usleep(1000000);         /* 1000 ms */\newline    }\newline\newline    /* Open host list read-only */\newline    if ((host_fd = open(host_file, O_RDONLY)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, host_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* A read lock */\newline    if (generic_lock(host_fd, 0, 1, 1) &lt 0) {\newline        rs_log_crit(&quotlock failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Get file size */\newline    if (fstat(host_fd, &ampst) &lt 0) {\newline        rs_log_crit(&quotstat() failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    if (st.st_size &gt= MAX_FILE_SIZE) {\newline        rs_log_crit(&quotfile too large.\\n&quot);\newline        goto finish;\newline    }\newline\newline    /* read file data */\newline    s = malloc((size_t) st.st_size+1);\newline    assert(s);\newline\newline    if (dcc_readx(host_fd, s, (size_t) st.st_size) != 0) {\newline        rs_log_crit(&quotfailed to read from file.\\n&quot);\newline        goto finish;\newline    }\newline    s[st.st_size] = 0;\newline\newline    /* Parse host data */\newline    if (dcc_parse_hosts(s, host_file, ret_list, ret_nhosts, ret_prev) != 0) {\newline        rs_log_crit(&quotfailed to parse host file.\\n&quot);\newline        goto finish;\newline    }\newline\newline    r = 0;\newline\newlinefinish:\newline    if (host_fd &gt= 0) {\newline        generic_lock(host_fd, 0, 0, 1);\newline        close(host_fd);\newline    }\newline\newline    free(lock_file);\newline    free(host_file);\newline    free(s);\newline\newline    return r;\newline}\newline","Get the host list from zeroconf \newline","2144342","jose.c","static char *oidc_jose_alg_to_openssl_digest(const char *alg) {\newline	if ((strcmp(alg, &quotRS256&quot) == 0) || (strcmp(alg, &quotPS256&quot) == 0)\newline			|| (strcmp(alg, &quotHS256&quot) == 0) || (strcmp(alg, &quotES256&quot) == 0)) {\newline		return &quotsha256&quot;\newline	}\newline	if ((strcmp(alg, &quotRS384&quot) == 0) || (strcmp(alg, &quotPS384&quot) == 0)\newline			|| (strcmp(alg, &quotHS384&quot) == 0) || (strcmp(alg, &quotES384&quot) == 0)) {\newline		return &quotsha384&quot;\newline	}\newline	if ((strcmp(alg, &quotRS512&quot) == 0) || (strcmp(alg, &quotPS512&quot) == 0)\newline			|| (strcmp(alg, &quotHS512&quot) == 0) || (strcmp(alg, &quotES512&quot) == 0)) {\newline		return &quotsha512&quot;\newline	}\newline	if (strcmp(alg, &quotNONE&quot) == 0) {\newline		return &quotNONE&quot;\newline	}\newline	return NULL;\newline}\newline","\newline return the OpenSSL hash algorithm associated with a specified JWT algorithm\newline \newline","3774541","webvtt.c","static GF_WebVTTCue *gf_webvtt_cue_split_at(GF_WebVTTCue *cue, GF_WebVTTTimestamp *time)\newline{\newline	GF_WebVTTCue *dup_cue;\newline\newline	cue-&gtsplit         = GF_TRUE;\newline	cue-&gtorig_start    = cue-&gtstart;\newline	cue-&gtorig_end      = cue-&gtend;\newline\newline	GF_SAFEALLOC(dup_cue, GF_WebVTTCue);\newline	dup_cue-&gtsplit          = GF_TRUE;\newline	dup_cue-&gtstart          = *time;\newline	dup_cue-&gtend            = cue-&gtend;\newline	dup_cue-&gtorig_start     = cue-&gtorig_start;\newline	dup_cue-&gtorig_end       = cue-&gtorig_end;\newline	dup_cue-&gtid             = gf_strdup((cue-&gtid ? cue-&gtid : &quot&quot));\newline	dup_cue-&gtsettings       = gf_strdup((cue-&gtsettings ? cue-&gtsettings : &quot&quot));\newline	dup_cue-&gttext           = gf_strdup((cue-&gttext ? cue-&gttext : &quot&quot));\newline\newline	cue-&gtend = *time;\newline	return dup_cue;\newline}\newline","adjust the end of the overlapped cue in the previous sample \newline","131765","lvm.c","const TObject *luaV_gettable (lua_State *L, StkId t) {\newline  Closure *tm;\newline  int tg;\newline  if (ttype(t) == LUA_TTABLE &amp&amp  /* `t&#039 is a table? */\newline      ((tg = hvalue(t)-&gthtag) == LUA_TTABLE ||  /* with default tag? */\newline        luaT_gettm(L, tg, TM_GETTABLE) == NULL)) { /* or no TM? */\newline    /* do a primitive get */\newline    const TObject *h = luaH_get(L, hvalue(t), L-&gttop-1);\newline    /* result is no nil or there is no `index&#039 tag method? */\newline    if (ttype(h) != LUA_TNIL || ((tm=luaT_gettm(L, tg, TM_INDEX)) == NULL))\newline      return h;  /* return result */\newline    /* else call `index&#039 tag method */\newline  }\newline  else {  /* try a `gettable&#039 tag method */\newline    tm = luaT_gettmbyObj(L, t, TM_GETTABLE);\newline  }\newline  if (tm != NULL) {  /* is there a tag method? */\newline    luaD_checkstack(L, 2);\newline    *(L-&gttop+1) = *(L-&gttop-1);  /* key */\newline    *L-&gttop = *t;  /* table */\newline    clvalue(L-&gttop-1) = tm;  /* tag method */\newline    ttype(L-&gttop-1) = LUA_TFUNCTION;\newline    L-&gttop += 2;\newline    luaD_call(L, L-&gttop - 3, 1);\newline    return L-&gttop - 1;  /* call result */\newline  }\newline  else {  /* no tag method */\newline    luaG_typeerror(L, t, &quotindex&quot);\newline    return NULL;  /* to avoid warnings */\newline  }\newline}\newline","\newline Function to index a table.\newline Receives the table at `t&#039 and the key at top.\newline \newline","3069061","nxsreader.cpp","NxsBlock *NxsReader::FindBlockByTitle(const BlockReaderList &amp chosenBlockList, const char *title, unsigned *nMatches)\newline	{\newline	BlockReaderList  found = FindAllBlocksByTitle(chosenBlockList, title);\newline\newline	if (found.empty())\newline		{\newline		if (nMatches)\newline			*nMatches = 0;\newline		return NULL;\newline		}\newline	if (nMatches)\newline		*nMatches = (unsigned)found.size();\newline	return (NxsBlock *) found.back();\newline	}\newline","! \\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.\newline In the event of ties, the most recently read block is returned.\newline If `title` is NULL, then any block is considered a match.\newline On output nMatches will be the number of matches (if `nMatches` is not NULL).\newline NULL will be returned if there are no matches.\newline \newline","4385305","utility.c","void ln_rad_to_dms (double radians, struct ln_dms *dms)\newline{\newline    double degrees = ln_rad_to_deg(radians);\newline    \newline    ln_deg_to_dms(degrees, dms);\newline}\newline","convert radians to dms \newline","1659570","progressbar.c","static void toggle_orientation( GtkWidget    *widget,\newline                                ProgressData *pdata )\newline{\newline  switch (gtk_progress_bar_get_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar))) {\newline  case GTK_PROGRESS_LEFT_TO_RIGHT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_RIGHT_TO_LEFT);\newline    break;\newline  case GTK_PROGRESS_RIGHT_TO_LEFT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_LEFT_TO_RIGHT);\newline    break;\newline  default:;\newline    /* do nothing */\newline  }\newline}\newline","Callback that toggles the orientation of the progress bar \newline","5758787","transport.c","int _libssh2_transport_read(LIBSSH2_SESSION * session)\newline{\newline    int rc;\newline    struct transportpacket *p = &ampsession-&gtpacket;\newline    int remainbuf;\newline    int remainpack;\newline    int numbytes;\newline    int numdecrypt;\newline    unsigned char block[MAX_BLOCKSIZE];\newline    int blocksize;\newline    int encrypted = 1;\newline    size_t total_num;\newline\newline    /* default clear the bit */\newline    session-&gtsocket_block_directions &amp= ~LIBSSH2_SESSION_BLOCK_INBOUND;\newline\newline    /*\newline     * All channels, systems, subsystems, etc eventually make it down here\newline     * when looking for more incoming data. If a key exchange is going on\newline     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\newline     * ONLY send key exchange related traffic. In non-blocking mode, there is\newline     * a chance to break out of the kex_exchange function with an EAGAIN\newline     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\newline     * active, then we must redirect to the key exchange. However, if\newline     * kex_exchange is active (as in it is the one that calls this execution\newline     * of packet_read, then don&#039t redirect, as that would be an infinite loop!\newline     */\newline\newline    if (session-&gtstate &amp LIBSSH2_STATE_EXCHANGING_KEYS &amp&amp\newline        !(session-&gtstate &amp LIBSSH2_STATE_KEX_ACTIVE)) {\newline\newline        /* Whoever wants a packet won&#039t get anything until the key re-exchange\newline         * is done!\newline         */\newline        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, &quotRedirecting into the&quot\newline                       &quot key re-exchange from _libssh2_transport_read&quot);\newline        rc = _libssh2_kex_exchange(session, 1, &ampsession-&gtstartup_key_state);\newline        if (rc)\newline            return rc;\newline    }\newline\newline    /*\newline     * =============================== NOTE ===============================\newline     * I know this is very ugly and not a really good use of &quotgoto&quot, but\newline     * this case statement would be even uglier to do it any other way\newline     */\newline    if (session-&gtreadPack_state == libssh2_NB_state_jump1) {\newline        session-&gtreadPack_state = libssh2_NB_state_idle;\newline        encrypted = session-&gtreadPack_encrypted;\newline        goto libssh2_transport_read_point1;\newline    }\newline\newline    do {\newline        if (session-&gtsocket_state == LIBSSH2_SOCKET_DISCONNECTED) {\newline            return LIBSSH2_ERROR_NONE;\newline        }\newline\newline        if (session-&gtstate &amp LIBSSH2_STATE_NEWKEYS) {\newline            blocksize = session-&gtremote.crypt-&gtblocksize;\newline        } else {\newline            encrypted = 0;      /* not encrypted */\newline            blocksize = 5;      /* not strictly true, but we can use 5 here to\newline                                   make the checks below work fine still */\newline        }\newline\newline        /* read/use a whole big chunk into a temporary area stored in\newline           the LIBSSH2_SESSION struct. We will decrypt data from that\newline           buffer into the packet buffer so this temp one doesn&#039t have\newline           to be able to keep a whole SSH packet, just be large enough\newline           so that we can read big chunks from the network layer. */\newline\newline        /* how much data there is remaining in the buffer to deal with\newline           before we should read more from the network */\newline        remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline\newline        /* if remainbuf turns negative we have a bad internal error */\newline        assert(remainbuf &gt= 0);\newline\newline        if (remainbuf &lt blocksize) {\newline            /* If we have less than a blocksize left, it is too\newline               little data to deal with, read more */\newline            ssize_t nread;\newline\newline            /* move any remainder to the start of the buffer so\newline               that we can do a full refill */\newline            if (remainbuf) {\newline                memmove(p-&gtbuf, &ampp-&gtbuf[p-&gtreadidx], remainbuf);\newline                p-&gtreadidx = 0;\newline                p-&gtwriteidx = remainbuf;\newline            } else {\newline                /* nothing to move, just zero the indexes */\newline                p-&gtreadidx = p-&gtwriteidx = 0;\newline            }\newline\newline            /* now read a big chunk from the network into the temp buffer */\newline            nread =\newline                LIBSSH2_RECV(session, &ampp-&gtbuf[remainbuf],\newline                              PACKETBUFSIZE - remainbuf,\newline                              LIBSSH2_SOCKET_RECV_FLAGS(session));\newline            if (nread &lt= 0) {\newline                /* check if this is due to EAGAIN and return the special\newline                   return code if so, error out normally otherwise */\newline                if ((nread &lt 0) &amp&amp (nread == -EAGAIN)) {\newline                    session-&gtsocket_block_directions |=\newline                        LIBSSH2_SESSION_BLOCK_INBOUND;\newline                    return LIBSSH2_ERROR_EAGAIN;\newline                }\newline                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                               &quotError recving %d bytes (got %d)&quot,\newline                               PACKETBUFSIZE - remainbuf, -nread);\newline                return LIBSSH2_ERROR_SOCKET_RECV;\newline            }\newline            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                           &quotRecved %d/%d bytes to %p+%d&quot, nread,\newline                           PACKETBUFSIZE - remainbuf, p-&gtbuf, remainbuf);\newline\newline            debugdump(session, &quotlibssh2_transport_read() raw&quot,\newline                      &ampp-&gtbuf[remainbuf], nread);\newline            /* advance write pointer */\newline            p-&gtwriteidx += nread;\newline\newline            /* update remainbuf counter */\newline            remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline        }\newline\newline        /* how much data to deal with from the buffer */\newline        numbytes = remainbuf;\newline\newline        if (!p-&gttotal_num) {\newline            /* No payload package area allocated yet. To know the\newline               size of this payload, we need to decrypt the first\newline               blocksize data. */\newline\newline            if (numbytes &lt blocksize) {\newline                /* we can&#039t act on anything less than blocksize, but this\newline                   check is only done for the initial block since once we have\newline                   got the start of a block we can in fact deal with fractions\newline                */\newline                session-&gtsocket_block_directions |=\newline                    LIBSSH2_SESSION_BLOCK_INBOUND;\newline                return LIBSSH2_ERROR_EAGAIN;\newline            }\newline\newline            if (encrypted) {\newline                rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], block, blocksize);\newline                if (rc != LIBSSH2_ERROR_NONE) {\newline                    return rc;\newline                }\newline                /* save the first 5 bytes of the decrypted package, to be\newline                   used in the hash calculation later down. */\newline                memcpy(p-&gtinit, &ampp-&gtbuf[p-&gtreadidx], 5);\newline            } else {\newline                /* the data is plain, just copy it verbatim to\newline                   the working block buffer */\newline                memcpy(block, &ampp-&gtbuf[p-&gtreadidx], blocksize);\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += blocksize;\newline\newline            /* we now have the initial blocksize bytes decrypted,\newline             * and we can extract packet and padding length from it\newline             */\newline            p-&gtpacket_length = _libssh2_ntohu32(block);\newline            if (p-&gtpacket_length &lt 1)\newline                return LIBSSH2_ERROR_DECRYPT;\newline\newline            p-&gtpadding_length = block[4];\newline\newline            /* total_num is the number of bytes following the initial\newline               (5 bytes) packet length and padding length fields */\newline            total_num =\newline                p-&gtpacket_length - 1 +\newline                (encrypted ? session-&gtremote.mac-&gtmac_len : 0);\newline\newline            /* RFC4253 section 6.1 Maximum Packet Length says:\newline             *\newline             * &quotAll implementations MUST be able to process\newline             * packets with uncompressed payload length of 32768\newline             * bytes or less and total packet size of 35000 bytes\newline             * or less (including length, padding length, payload,\newline             * padding, and MAC.).&quot\newline             */\newline            if (total_num &gt LIBSSH2_PACKET_MAXPAYLOAD) {\newline                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\newline            }\newline\newline            /* Get a packet handle put data into. We get one to\newline               hold all data, including padding and MAC. */\newline            p-&gtpayload = LIBSSH2_ALLOC(session, total_num);\newline            if (!p-&gtpayload) {\newline                return LIBSSH2_ERROR_ALLOC;\newline            }\newline            p-&gttotal_num = total_num;\newline            /* init write pointer to start of payload buffer */\newline            p-&gtwptr = p-&gtpayload;\newline\newline            if (blocksize &gt 5) {\newline                /* copy the data from index 5 to the end of\newline                   the blocksize from the temporary buffer to\newline                   the start of the decrypted buffer */\newline                memcpy(p-&gtwptr, &ampblock[5], blocksize - 5);\newline                p-&gtwptr += blocksize - 5;       /* advance write pointer */\newline            }\newline\newline            /* init the data_num field to the number of bytes of\newline               the package read so far */\newline            p-&gtdata_num = p-&gtwptr - p-&gtpayload;\newline\newline            /* we already dealt with a blocksize worth of data */\newline            numbytes -= blocksize;\newline        }\newline\newline        /* how much there is left to add to the current payload\newline           package */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (numbytes &gt remainpack) {\newline            /* if we have more data in the buffer than what is going into this\newline               particular packet, we limit this round to this packet only */\newline            numbytes = remainpack;\newline        }\newline\newline        if (encrypted) {\newline            /* At the end of the incoming stream, there is a MAC,\newline               and we don&#039t want to decrypt that since we need it\newline               &quotraw&quot. We MUST however decrypt the padding data\newline               since it is used for the hash later on. */\newline            int skip = session-&gtremote.mac-&gtmac_len;\newline\newline            /* if what we have plus numbytes is bigger than the\newline               total minus the skip margin, we should lower the\newline               amount to decrypt even more */\newline            if ((p-&gtdata_num + numbytes) &gt (p-&gttotal_num - skip)) {\newline                numdecrypt = (p-&gttotal_num - skip) - p-&gtdata_num;\newline            } else {\newline                int frac;\newline                numdecrypt = numbytes;\newline                frac = numdecrypt % blocksize;\newline                if (frac) {\newline                    /* not an aligned amount of blocks,\newline                       align it */\newline                    numdecrypt -= frac;\newline                    /* and make it no unencrypted data\newline                       after it */\newline                    numbytes = 0;\newline                }\newline            }\newline        } else {\newline            /* unencrypted data should not be decrypted at all */\newline            numdecrypt = 0;\newline        }\newline\newline        /* if there are bytes to decrypt, do that */\newline        if (numdecrypt &gt 0) {\newline            /* now decrypt the lot */\newline            rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], p-&gtwptr, numdecrypt);\newline            if (rc != LIBSSH2_ERROR_NONE) {\newline                p-&gttotal_num = 0;   /* no packet buffer available */\newline                return rc;\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numdecrypt;\newline            /* advance write pointer */\newline            p-&gtwptr += numdecrypt;\newline            /* increase data_num */\newline            p-&gtdata_num += numdecrypt;\newline\newline            /* bytes left to take care of without decryption */\newline            numbytes -= numdecrypt;\newline        }\newline\newline        /* if there are bytes to copy that aren&#039t decrypted, simply\newline           copy them as-is to the target buffer */\newline        if (numbytes &gt 0) {\newline            memcpy(p-&gtwptr, &ampp-&gtbuf[p-&gtreadidx], numbytes);\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numbytes;\newline            /* advance write pointer */\newline            p-&gtwptr += numbytes;\newline            /* increase data_num */\newline            p-&gtdata_num += numbytes;\newline        }\newline\newline        /* now check how much data there&#039s left to read to finish the\newline           current packet */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (!remainpack) {\newline            /* we have a full packet */\newline          libssh2_transport_read_point1:\newline            rc = fullpacket(session, encrypted);\newline            if (rc == LIBSSH2_ERROR_EAGAIN) {\newline\newline                if (session-&gtpackAdd_state != libssh2_NB_state_idle)\newline                {\newline                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\newline                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If that\newline                     * returns LIBSSH2_ERROR_EAGAIN but the packAdd_state is idle,\newline                     * then the packet has been added to the brigade, but some\newline                     * immediate action that was taken based on the packet\newline                     * type (such as key re-exchange) is not yet complete.\newline                     * Clear the way for a new packet to be read in.\newline                     */\newline                    session-&gtreadPack_encrypted = encrypted;\newline                    session-&gtreadPack_state = libssh2_NB_state_jump1;\newline                }\newline\newline                return rc;\newline            }\newline\newline            p-&gttotal_num = 0;   /* no packet buffer available */\newline\newline            return rc;\newline        }\newline    } while (1);                /* loop */\newline\newline    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\newline}\newline","\newline This function reads the binary stream as specified in chapter 6 of RFC4253\newline &quotThe Secure Shell (SSH) Transport Layer Protocol&quot\newline \newline DOES NOT call _libssh2_error() for ANY error case.\newline \newline","1480360","configdialog.cpp","void ConfigDialog::on_checkBoxAutoclear_clicked() {\newline  on_comboBoxClipboard_activated(1);\newline}\newline","\newline @brief ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked, update\newline state via ConfigDialog::on_comboBoxClipboard_activated\newline \newline","","","","","","","","","","","","on","","on","on","","","on","","","","","","","","","","","","","","","","","","","","","","","","","Encodes the input digest","Pins the window","Event filter","Find come attrbute in an attribute list.","Get the host list from zeroconf","return the OpenSSL hash algorithm associated with a specified JWT algorithm","adjust the end of the overlapped cue in the previous sample","index a table.","\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.","convert radians to dms","toggles the orientation of the progress bar","{}","reads the binary stream","{}","{}","Clear out the given server_list.","Simple tests on the tangent trigonometric function.","{}","GTK+ identifier for the mouse button used to click.","starts a command on the underlying system","returns a pseudo-random number"
"3D1TUISJWI0YC7XIQVTHLAFOB7WUIA","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","38BQUHLA9W0RI5055QK13GQ5QIWMOD","AMD1LYNQAH3R8","Approved","Wed Apr 17 13:36:10 PDT 2019","Wed Apr 17 13:42:37 PDT 2019","Fri Apr 19 13:42:37 PDT 2019","2019-04-19 20:43:21 UTC","","","387","100% (27/27)","100% (27/27)","100% (27/27)","4378774","fsck.c","static int digest_encode(const char *src, int len, char *dst)\newline{\newline	int i = 0, bits = 0, ac = 0;\newline	char *cp = dst;\newline\newline	while (i &lt len) {\newline		ac += (((unsigned char) src[i]) &lt&lt bits);\newline		bits += 8;\newline		do {\newline			*cp++ = lookup_table[ac &amp 0x3f];\newline			ac &gt&gt= 6;\newline			bits -= 6;\newline		} while (bits &gt= 6);\newline		i++;\newline	}\newline	if (bits)\newline		*cp++ = lookup_table[ac &amp 0x3f];\newline	*cp = 0;\newline	return cp - dst;\newline}\newline","\newline digest_encode() -\newline \newline Encodes the input digest using characters from the set [a-zA-Z0-9_+].\newline The encoded string is roughly 4/3 times the size of the input string.\newline \newline","5980191","mur_read_file.c","uint4 mur_prev(jnl_ctl_list *jctl, off_jnl_t dskaddr)\newline{\newline	off_jnl_t	buff_offset;\newline	uint4		status, partial_reclen;\newline	jrec_suffix	*suffix;\newline	mur_buff_desc_t	*swap_buff;\newline	boolean_t	good_suffix, good_prefix;\newline	mur_read_desc_t	*mur_desc;\newline\newline	mur_desc = jctl-&gtreg_ctl-&gtmur_desc;\newline	if (0 != dskaddr)\newline	{ /* read record at dskaddr */\newline		assert(dskaddr &lt jctl-&gteof_addr);\newline		assert(dskaddr &gt= JNL_HDR_LEN);\newline		if (dskaddr &gt= jctl-&gteof_addr || dskaddr &lt JNL_HDR_LEN)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotRequested offset out of range [prev]&quot));\newline			return (dskaddr &gt= jctl-&gteof_addr ? ERR_JNLREADEOF : ERR_JNLREADBOF);\newline		}\newline		assert(dskaddr == ROUND_UP2(dskaddr, JNL_REC_START_BNDRY)); /* dskaddr must be aligned at JNL_REC_START_BNDRY */\newline		MUR_FREAD_CANCEL(jctl, mur_desc, status);\newline		if (SS_NORMAL != status)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotCould not cancel prior read [prev]&quot), jctl-&gtstatus);\newline			return jctl-&gtstatus;\newline		}\newline		mur_desc-&gtbuff_index = 1;\newline		mur_desc-&gtcur_buff = &ampmur_desc-&gtseq_buff[mur_desc-&gtbuff_index];\newline		mur_desc-&gtsec_buff = &ampmur_desc-&gtseq_buff[1 - mur_desc-&gtbuff_index];\newline		mur_desc-&gtcur_buff-&gtdskaddr = ROUND_DOWN2(dskaddr, MUR_BUFF_SIZE);\newline		mur_desc-&gtcur_buff-&gtblen = MIN(MUR_BUFF_SIZE, jctl-&gteof_addr - mur_desc-&gtcur_buff-&gtdskaddr);\newline		buff_offset = dskaddr - mur_desc-&gtcur_buff-&gtdskaddr;\newline		assert(JREC_PREFIX_UPTO_LEN_SIZE &lt= mur_desc-&gtcur_buff-&gtblen - buff_offset);\newline			/* we rely on reading at least up to the record length field (forwptr) */\newline		if (SS_NORMAL != (status = mur_freadw(jctl, mur_desc-&gtcur_buff)))\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline					LEN_AND_LIT(&quotError from synchronous read into cur_buff [prev]&quot), status);\newline			return status;\newline		}\newline		mur_desc-&gtjnlrec = (jnl_record *)(mur_desc-&gtcur_buff-&gtbase + buff_offset);\newline		good_suffix = TRUE;\newline		if (FALSE != (good_prefix = IS_VALID_LEN_FROM_PREFIX(mur_desc-&gtjnlrec, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjreclen = mur_desc-&gtjnlrec-&gtprefix.forwptr;\newline			if (MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr)\newline			{ /* while we process the just read chunk, post a read for the immediately preceding chunk */\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline					   	LEN_AND_LIT(&quotCould not initiate read into sec_buff in [prev] (dskaddr &gt 0)&quot),\newline						status);\newline					return status;\newline				}\newline			} else\newline			{ /* we read the beginning MUR_BUFF_SIZE (or smaller) chunk from file, no previous chunk exists */\newline				assert(0 == mur_desc-&gtcur_buff-&gtdskaddr);\newline			}\newline			if (buff_offset + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gtblen)\newline			{ /* Journal record straddles MUR_BUFF_SIZE boundary, did not read the entire record, read what&#039s left into\newline			   * aux_buff2 which is located at the end of seq_buff[1], the current buffer */\newline				mur_desc-&gtaux_buff2.dskaddr = mur_desc-&gtcur_buff-&gtdskaddr + mur_desc-&gtcur_buff-&gtblen;\newline				mur_desc-&gtaux_buff2.blen = (buff_offset + mur_desc-&gtjreclen - mur_desc-&gtcur_buff-&gtblen);\newline				if (FALSE != (good_prefix =\newline					(jctl-&gteof_addr - mur_desc-&gtaux_buff2.dskaddr &gt= mur_desc-&gtaux_buff2.blen)))\newline				{\newline					if (SS_NORMAL != (status = mur_freadw(jctl, &ampmur_desc-&gtaux_buff2)))\newline					{\newline						gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3,\newline							jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, mur_desc-&gtaux_buff2.dskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError in synchronous read into aux_buff [prev]&quot), status);\newline						return status;\newline					}\newline				} else\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3,\newline						jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, dskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond end of file [prev] (dskaddr &gt 0)&quot));\newline					return ERR_JNLBADRECFMT;\newline				}\newline			}\newline		} /* end good_prefix */\newline	} else\newline	{ /* dskaddr == 0, locate the previous record in the buffer, reading from disk if necessary */\newline		assert(JNL_HDR_LEN &lt= jctl-&gtrec_offset);\newline		suffix = (jrec_suffix *)((char *)mur_desc-&gtjnlrec - JREC_SUFFIX_SIZE);\newline		/* ok to test with possibly invalid backptr, we test for validity below */\newline		if (((unsigned char *)suffix &gt mur_desc-&gtcur_buff-&gtbase)\newline			&amp&amp (((unsigned char *)mur_desc-&gtjnlrec - suffix-&gtbackptr) &gt= mur_desc-&gtcur_buff-&gtbase))\newline		{	/* prev record is contained completely in the current buffer */\newline			if ((0 == mur_desc-&gtbuff_index)\newline				&amp&amp ((unsigned char *)mur_desc-&gtjnlrec + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gttop)\newline				&amp&amp (0 &lt mur_desc-&gtcur_buff-&gtdskaddr)) /* end of rec in sec_buff and there is data to be read */\newline			{ /* we just finished processing the journal record that straddled seq_buff[0] and seq_buff[1],\newline			   * start read in the now free secondary buffer (seq_buff[1]) to overlap with processing */\newline				assert(MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr);\newline				assert(!mur_desc-&gtsec_buff-&gtread_in_progress);\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotCould not initiate read into sec_buff [prev] (dskaddr == 0)&quot), status);\newline					return status;\newline				}\newline			}\newline		} else\newline		{ /* prev record completely in sec_buff or overlaps cur_buff and sec_buff */\newline			if (0 == mur_desc-&gtbuff_index)\newline			{ /* copy partial record to just past the end of seq_buff[1], i.e., aux_seq_buff[1] to make the record\newline			   * available in contiguous memory */\newline				partial_reclen = (uint4)((unsigned char *)mur_desc-&gtjnlrec - mur_desc-&gtseq_buff[0].base);\newline				if (0 &lt partial_reclen)\newline					memcpy(mur_desc-&gtseq_buff[1].top, mur_desc-&gtseq_buff[0].base, partial_reclen);\newline				suffix = (jrec_suffix *)(mur_desc-&gtseq_buff[1].top + partial_reclen - JREC_SUFFIX_SIZE);\newline			}\newline			/* before switching the buffers, wait for completion of pending I/O */\newline			if (mur_desc-&gtsec_buff-&gtread_in_progress)\newline			{\newline				MUR_FREAD_WAIT(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError waiting for sec_buff read to complete [prev]&quot),\newline							status);\newline					return status;\newline				}\newline			}\newline			/* If possible, overlap I/O with processing, read into available buffer */\newline			if ((0 == mur_desc-&gtbuff_index || /* we just copied partial record (if any), OR */\newline			    (unsigned char *)mur_desc-&gtjnlrec == mur_desc-&gtcur_buff-&gtbase) /* we completely processed cur_buff */\newline				&amp&amp 0 &lt mur_desc-&gtsec_buff-&gtdskaddr) /* there is data to be read */\newline			{\newline				assert(mur_desc-&gtsec_buff-&gtdskaddr &gt= MUR_BUFF_SIZE);\newline				mur_desc-&gtcur_buff-&gtdskaddr = mur_desc-&gtsec_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtcur_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotCould not initiate read into cur_buff [prev]&quot), status);\newline					return status;\newline				}\newline			}\newline			/* Make the buffer that has data that was previously read current */\newline			mur_desc-&gtbuff_index = 1 - mur_desc-&gtbuff_index;\newline			swap_buff = mur_desc-&gtcur_buff;\newline			mur_desc-&gtcur_buff = mur_desc-&gtsec_buff;\newline			mur_desc-&gtsec_buff = swap_buff;\newline		}\newline		good_prefix = TRUE;\newline		if (FALSE != (good_suffix = IS_VALID_LEN_FROM_SUFFIX(suffix, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjnlrec = (jnl_record *)((char *)suffix + JREC_SUFFIX_SIZE - suffix-&gtbackptr);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &gt= mur_desc-&gtcur_buff-&gtbase);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &lt  mur_desc-&gtcur_buff-&gttop);\newline			mur_desc-&gtjreclen = suffix-&gtbackptr;\newline			if (jctl-&gtrec_offset &lt mur_desc-&gtjreclen + JNL_HDR_LEN)\newline			{\newline				gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, jctl-&gtrec_offset, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond beginning of file [prev]&quot));\newline				return ERR_JNLBADRECFMT;\newline			}\newline		}\newline	} /* end of dskaddr == 0 */\newline	if (good_prefix &amp&amp good_suffix &amp&amp IS_VALID_JNLREC(mur_desc-&gtjnlrec, jctl-&gtjfh))\newline		return SS_NORMAL;\newline	return ERR_JNLBADRECFMT;\newline}\newline","#GTM_THREAD_SAFE : The below function (mur_prev) is thread-safe \newline","3428267","ccid_usb.c","static void Multi_PollingTerminate(struct usbDevice_MultiSlot_Extension *msExt)\newline{\newline	struct libusb_transfer *transfer;\newline\newline	if (msExt &amp&amp !msExt-&gtterminated)\newline	{\newline		msExt-&gtterminated = TRUE;\newline\newline		transfer = usbDevice[msExt-&gtreader_index].polling_transfer;\newline\newline		if (transfer)\newline		{\newline			int ret;\newline\newline			ret = libusb_cancel_transfer(transfer);\newline			if (ret &lt 0)\newline				DEBUG_CRITICAL2(&quotlibusb_cancel_transfer failed: %d&quot, ret);\newline		}\newline	}\newline} /* Multi_PollingTerminate */\newline","\newline \newline Multi_PollingTerminate\newline \newline \newline","5830889","server.c","static void clearq(struct server_list *xx)\newline{\newline  struct server_list *x;\newline\newline  while (xx) {\newline    x = xx-&gtnext;\newline    if (xx-&gtname)\newline      nfree(xx-&gtname);\newline    if (xx-&gtpass)\newline      nfree(xx-&gtpass);\newline    if (xx-&gtrealname)\newline      nfree(xx-&gtrealname);\newline    nfree(xx);\newline    xx = x;\newline  }\newline}\newline","Clear out the given server_list.\newline \newline","1448774","check_inifcns.cpp","static unsigned inifcns_check_tan()\newline{\newline	unsigned result = 0;\newline	bool errorflag;\newline	\newline	// compare tan((q*Pi).evalf()) with tan(q*Pi).eval().evalf() at various\newline	// points.  E.g. if tan(Pi/12) returns something symbolic this should be\newline	// equal to 2-sqrt(3).  This routine will spot programming mistakes of \newline	// this kind:\newline	errorflag = false;\newline	ex argument;\newline	numeric epsilon(double(1e-8));\newline	for (int n=-340; n&lt=340; ++n) {\newline		if (!(n%30) &amp&amp (n%60))  // skip poles\newline			++n;\newline		argument = n*Pi/60;\newline		if (abs(tan(evalf(argument))-evalf(tan(argument)))&gtepsilon) {\newline			clog &lt&lt &quottan(&quot &lt&lt argument &lt&lt &quot) returns &quot\newline			     &lt&lt tan(argument) &lt&lt endl;\newline			errorflag = true;\newline		}\newline	}\newline	if (errorflag)\newline		++result;\newline	\newline	return result;\newline}\newline","Simple tests on the tangent trigonometric function. \newline","6038115","dmmain.c","static int display_close(void *handle, void *device)\newline{\newline    IMAGE *img = image_find(handle, device);\newline    if (img == NULL)\newline       return -1;\newline\newline    gsdll_poll(handle);\newline\newline    /* remove from list */\newline    if (img == first_image)\newline        first_image = img-&gtnext;\newline    else\newline    {\newline        IMAGE *tmp;\newline        for (tmp = first_image; tmp!=0; tmp=tmp-&gtnext)\newline        {\newline            if (img == tmp-&gtnext)\newline            tmp-&gtnext = img-&gtnext;\newline        }\newline    }\newline\newline    DisposePixMap(img-&gtpixmapHdl);   // need to go in doCloseWindow()\newline    DisposeWindow(img-&gtwindowRef);\newline\newline    free(img);\newline\newline    return 0;\newline}\newline","This is the last event from this device. \newline","812839","webkitwebnavigationaction.cpp","gint webkit_web_navigation_action_get_button(WebKitWebNavigationAction* navigationAction)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_WEB_NAVIGATION_ACTION(navigationAction), -1);\newline\newline    return navigationAction-&gtpriv-&gtbutton;\newline}\newline","\newline webkit_web_navigation_action_get_button:\newline @navigationAction: a #WebKitWebNavigationAction\newline \newline The GTK+ identifier for the mouse button used to click. Notice that GTK+ button values\newline are 1, 2 and 3 for left, middle and right buttons, so they are DOM button values +1. If the action was not\newline initiated by a mouse click the value will be -1.\newline \newline Return value: the mouse button used to click\newline \newline Since: 1.0.3\newline \newline","6362084","disks.cpp","int DiskEntry::sysCall(QString &amp completeCommand)\newline{\newline    if (readingSysStdErrOut || sysProc-&gtstate() == QProcess::Running )\newline        return -1;\newline\newline    sysStringErrOut=i18n(&quotCalled: %1\\n\\n&quot, completeCommand); // put the called command on ErrOut\newline    sysProc-&gtclearProgram();\newline\newline    //Split command and arguments to use the new API, otherwise it doesn&#039t work\newline    QTextStream tS(&ampcompleteCommand);\newline\newline    QString command;\newline    tS &gt&gt command;\newline\newline    QString tmp;\newline    QStringList args;\newline    while( !tS.atEnd() )\newline    {\newline        tS &gt&gt tmp;\newline        args &lt&lt tmp;\newline    }\newline\newline    sysProc-&gtsetProgram(command, args);\newline    sysProc-&gtstart();\newline\newline    if ( !sysProc-&gtwaitForStarted(-1) )\newline        qCCritical(KDF) &lt&lt i18n(&quotcould not execute %1&quot, command) ;\newline\newline    sysProc-&gtwaitForFinished(-1);\newline\newline    if (sysProc-&gtexitCode()!=0)\newline        emit sysCallError(this, sysProc-&gtexitStatus());\newline\newline    return (sysProc-&gtexitCode());\newline}\newline","\newline starts a command on the underlying system via /bin/sh\newline \newline","2726110","rnd.c","int32 rnd ()\newline{\newline  register long low, high, test;\newline\newline  high = rnd_seed / RNG_Q;\newline  low = rnd_seed % RNG_Q;\newline  test = RNG_A * low - RNG_R * high;\newline  if (test &gt 0)\newline    rnd_seed = test;\newline  else\newline    rnd_seed = test + RNG_M;\newline  return rnd_seed;\newline}\newline","returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 \newline","893020","script_functions.c","int c_pin_window(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotpin_window: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline		if (window) {\newline			wnck_window_pin(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Pins the window\newline \newline","6449222","qwt_plot.cpp","bool QwtPlot::eventFilter( QObject *object, QEvent *event )\newline{\newline    if ( object == d_data-&gtcanvas )\newline    {\newline        if ( event-&gttype() == QEvent::Resize )\newline        {\newline            updateCanvasMargins();\newline        }\newline        else if ( event-&gttype() == QEvent::ContentsRectChange )\newline        {\newline            updateLayout();\newline        }\newline    }\newline\newline    return QFrame::eventFilter( object, event );\newline}\newline","!\newline\\brief Event filter\newlineThe plot handles the following events for the canvas:\newline- QEvent::Resize\newlineThe canvas margins might depend on its size\newline- QEvent::ContentsRectChange\newlineThe layout needs to be recalculated\newline\\param object Object to be filtered\newline\\param event Event\newline\\return See QFrame::eventFilter()\newline\\sa updateCanvasMargins(), updateLayout()\newline \newline","2776384","msc.c","static const char *findAttrib(const struct MscAttribTag *attr, MscAttribType a)\newline{\newline    while(attr != NULL &amp&amp attr-&gttype != a)\newline    {\newline        attr = attr-&gtnext;\newline    }\newline\newline    if(attr != NULL)\newline    {\newline        return attr-&gtvalue;\newline    }\newline    else\newline    {\newline        return NULL;\newline    }\newline}\newline","Find come attrbute in an attribute list.\newline \newline \\param[in] attr Head of the linked list to search.\newline \\param[in] a The attribute type to find.\newline \\retval NULL If the attribute was not found or the passed list was NULL.\newline \newline","6582023","zeroconf.c","int dcc_zeroconf_add_hosts(struct dcc_hostdef **ret_list, int *ret_nhosts, int n_slots, struct dcc_hostdef **ret_prev) {\newline    char *host_file = NULL, *lock_file = NULL, *s = NULL;\newline    int lock_fd = -1, host_fd = -1;\newline    int fork_daemon = 0;\newline    int r = -1;\newline    char *dir;\newline    struct stat st;\newline\newline    if (get_zeroconf_dir(&ampdir) != 0) {\newline        rs_log_crit(&quotfailed to get zeroconf dir.\\n&quot);\newline        goto finish;\newline    }\newline\newline    lock_file = malloc(strlen(dir) + sizeof(&quot/lock&quot));\newline    assert(lock_file);\newline    sprintf(lock_file, &quot%s/lock&quot, dir);\newline\newline    host_file = malloc(strlen(dir) + sizeof(&quot/hosts&quot));\newline    assert(host_file);\newline    sprintf(host_file, &quot%s/hosts&quot, dir);\newline\newline    /* Open lock file */\newline    if ((lock_fd = open(lock_file, O_RDWR|O_CREAT, 0666)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, lock_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Try to lock the lock file */\newline    if (generic_lock(lock_fd, 1, 1, 0) &gt= 0) {\newline        /* The lock succeeded =&gt there&#039s no daemon running yet! */\newline        fork_daemon = 1;\newline        generic_lock(lock_fd, 1, 0, 0);\newline    }\newline\newline    close(lock_fd);\newline\newline    /* Shall we fork a new daemon? */\newline    if (fork_daemon) {\newline        pid_t pid;\newline\newline        rs_log_info(&quotSpawning zeroconf daemon.\\n&quot);\newline\newline        if ((pid = fork()) == -1) {\newline            rs_log_crit(&quotfork() failed: %s\\n&quot, strerror(errno));\newline            goto finish;\newline        } else if (pid == 0) {\newline            int fd;\newline            /* Child */\newline\newline            /* Close file descriptors and replace them by /dev/null */\newline            close(0);\newline            close(1);\newline            close(2);\newline            fd = open(&quot/dev/null&quot, O_RDWR);\newline            assert(fd == 0);\newline            fd = dup(0);\newline            assert(fd == 1);\newline            fd = dup(0);\newline            assert(fd == 2);\newline\newline#ifdef HAVE_SETSID\newline            setsid();\newline#endif\newline\newline            chdir(&quot/&quot);\newline            rs_add_logger(rs_logger_syslog, RS_LOG_DEBUG, NULL, 0);\newline            _exit(daemon_proc(host_file, lock_file, n_slots));\newline        }\newline\newline        /* Parent */\newline\newline        /* Wait some time for initial host gathering */\newline        usleep(1000000);         /* 1000 ms */\newline    }\newline\newline    /* Open host list read-only */\newline    if ((host_fd = open(host_file, O_RDONLY)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, host_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* A read lock */\newline    if (generic_lock(host_fd, 0, 1, 1) &lt 0) {\newline        rs_log_crit(&quotlock failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Get file size */\newline    if (fstat(host_fd, &ampst) &lt 0) {\newline        rs_log_crit(&quotstat() failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    if (st.st_size &gt= MAX_FILE_SIZE) {\newline        rs_log_crit(&quotfile too large.\\n&quot);\newline        goto finish;\newline    }\newline\newline    /* read file data */\newline    s = malloc((size_t) st.st_size+1);\newline    assert(s);\newline\newline    if (dcc_readx(host_fd, s, (size_t) st.st_size) != 0) {\newline        rs_log_crit(&quotfailed to read from file.\\n&quot);\newline        goto finish;\newline    }\newline    s[st.st_size] = 0;\newline\newline    /* Parse host data */\newline    if (dcc_parse_hosts(s, host_file, ret_list, ret_nhosts, ret_prev) != 0) {\newline        rs_log_crit(&quotfailed to parse host file.\\n&quot);\newline        goto finish;\newline    }\newline\newline    r = 0;\newline\newlinefinish:\newline    if (host_fd &gt= 0) {\newline        generic_lock(host_fd, 0, 0, 1);\newline        close(host_fd);\newline    }\newline\newline    free(lock_file);\newline    free(host_file);\newline    free(s);\newline\newline    return r;\newline}\newline","Get the host list from zeroconf \newline","2144342","jose.c","static char *oidc_jose_alg_to_openssl_digest(const char *alg) {\newline	if ((strcmp(alg, &quotRS256&quot) == 0) || (strcmp(alg, &quotPS256&quot) == 0)\newline			|| (strcmp(alg, &quotHS256&quot) == 0) || (strcmp(alg, &quotES256&quot) == 0)) {\newline		return &quotsha256&quot;\newline	}\newline	if ((strcmp(alg, &quotRS384&quot) == 0) || (strcmp(alg, &quotPS384&quot) == 0)\newline			|| (strcmp(alg, &quotHS384&quot) == 0) || (strcmp(alg, &quotES384&quot) == 0)) {\newline		return &quotsha384&quot;\newline	}\newline	if ((strcmp(alg, &quotRS512&quot) == 0) || (strcmp(alg, &quotPS512&quot) == 0)\newline			|| (strcmp(alg, &quotHS512&quot) == 0) || (strcmp(alg, &quotES512&quot) == 0)) {\newline		return &quotsha512&quot;\newline	}\newline	if (strcmp(alg, &quotNONE&quot) == 0) {\newline		return &quotNONE&quot;\newline	}\newline	return NULL;\newline}\newline","\newline return the OpenSSL hash algorithm associated with a specified JWT algorithm\newline \newline","3774541","webvtt.c","static GF_WebVTTCue *gf_webvtt_cue_split_at(GF_WebVTTCue *cue, GF_WebVTTTimestamp *time)\newline{\newline	GF_WebVTTCue *dup_cue;\newline\newline	cue-&gtsplit         = GF_TRUE;\newline	cue-&gtorig_start    = cue-&gtstart;\newline	cue-&gtorig_end      = cue-&gtend;\newline\newline	GF_SAFEALLOC(dup_cue, GF_WebVTTCue);\newline	dup_cue-&gtsplit          = GF_TRUE;\newline	dup_cue-&gtstart          = *time;\newline	dup_cue-&gtend            = cue-&gtend;\newline	dup_cue-&gtorig_start     = cue-&gtorig_start;\newline	dup_cue-&gtorig_end       = cue-&gtorig_end;\newline	dup_cue-&gtid             = gf_strdup((cue-&gtid ? cue-&gtid : &quot&quot));\newline	dup_cue-&gtsettings       = gf_strdup((cue-&gtsettings ? cue-&gtsettings : &quot&quot));\newline	dup_cue-&gttext           = gf_strdup((cue-&gttext ? cue-&gttext : &quot&quot));\newline\newline	cue-&gtend = *time;\newline	return dup_cue;\newline}\newline","adjust the end of the overlapped cue in the previous sample \newline","131765","lvm.c","const TObject *luaV_gettable (lua_State *L, StkId t) {\newline  Closure *tm;\newline  int tg;\newline  if (ttype(t) == LUA_TTABLE &amp&amp  /* `t&#039 is a table? */\newline      ((tg = hvalue(t)-&gthtag) == LUA_TTABLE ||  /* with default tag? */\newline        luaT_gettm(L, tg, TM_GETTABLE) == NULL)) { /* or no TM? */\newline    /* do a primitive get */\newline    const TObject *h = luaH_get(L, hvalue(t), L-&gttop-1);\newline    /* result is no nil or there is no `index&#039 tag method? */\newline    if (ttype(h) != LUA_TNIL || ((tm=luaT_gettm(L, tg, TM_INDEX)) == NULL))\newline      return h;  /* return result */\newline    /* else call `index&#039 tag method */\newline  }\newline  else {  /* try a `gettable&#039 tag method */\newline    tm = luaT_gettmbyObj(L, t, TM_GETTABLE);\newline  }\newline  if (tm != NULL) {  /* is there a tag method? */\newline    luaD_checkstack(L, 2);\newline    *(L-&gttop+1) = *(L-&gttop-1);  /* key */\newline    *L-&gttop = *t;  /* table */\newline    clvalue(L-&gttop-1) = tm;  /* tag method */\newline    ttype(L-&gttop-1) = LUA_TFUNCTION;\newline    L-&gttop += 2;\newline    luaD_call(L, L-&gttop - 3, 1);\newline    return L-&gttop - 1;  /* call result */\newline  }\newline  else {  /* no tag method */\newline    luaG_typeerror(L, t, &quotindex&quot);\newline    return NULL;  /* to avoid warnings */\newline  }\newline}\newline","\newline Function to index a table.\newline Receives the table at `t&#039 and the key at top.\newline \newline","3069061","nxsreader.cpp","NxsBlock *NxsReader::FindBlockByTitle(const BlockReaderList &amp chosenBlockList, const char *title, unsigned *nMatches)\newline	{\newline	BlockReaderList  found = FindAllBlocksByTitle(chosenBlockList, title);\newline\newline	if (found.empty())\newline		{\newline		if (nMatches)\newline			*nMatches = 0;\newline		return NULL;\newline		}\newline	if (nMatches)\newline		*nMatches = (unsigned)found.size();\newline	return (NxsBlock *) found.back();\newline	}\newline","! \\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.\newline In the event of ties, the most recently read block is returned.\newline If `title` is NULL, then any block is considered a match.\newline On output nMatches will be the number of matches (if `nMatches` is not NULL).\newline NULL will be returned if there are no matches.\newline \newline","4385305","utility.c","void ln_rad_to_dms (double radians, struct ln_dms *dms)\newline{\newline    double degrees = ln_rad_to_deg(radians);\newline    \newline    ln_deg_to_dms(degrees, dms);\newline}\newline","convert radians to dms \newline","1659570","progressbar.c","static void toggle_orientation( GtkWidget    *widget,\newline                                ProgressData *pdata )\newline{\newline  switch (gtk_progress_bar_get_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar))) {\newline  case GTK_PROGRESS_LEFT_TO_RIGHT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_RIGHT_TO_LEFT);\newline    break;\newline  case GTK_PROGRESS_RIGHT_TO_LEFT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_LEFT_TO_RIGHT);\newline    break;\newline  default:;\newline    /* do nothing */\newline  }\newline}\newline","Callback that toggles the orientation of the progress bar \newline","5758787","transport.c","int _libssh2_transport_read(LIBSSH2_SESSION * session)\newline{\newline    int rc;\newline    struct transportpacket *p = &ampsession-&gtpacket;\newline    int remainbuf;\newline    int remainpack;\newline    int numbytes;\newline    int numdecrypt;\newline    unsigned char block[MAX_BLOCKSIZE];\newline    int blocksize;\newline    int encrypted = 1;\newline    size_t total_num;\newline\newline    /* default clear the bit */\newline    session-&gtsocket_block_directions &amp= ~LIBSSH2_SESSION_BLOCK_INBOUND;\newline\newline    /*\newline     * All channels, systems, subsystems, etc eventually make it down here\newline     * when looking for more incoming data. If a key exchange is going on\newline     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\newline     * ONLY send key exchange related traffic. In non-blocking mode, there is\newline     * a chance to break out of the kex_exchange function with an EAGAIN\newline     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\newline     * active, then we must redirect to the key exchange. However, if\newline     * kex_exchange is active (as in it is the one that calls this execution\newline     * of packet_read, then don&#039t redirect, as that would be an infinite loop!\newline     */\newline\newline    if (session-&gtstate &amp LIBSSH2_STATE_EXCHANGING_KEYS &amp&amp\newline        !(session-&gtstate &amp LIBSSH2_STATE_KEX_ACTIVE)) {\newline\newline        /* Whoever wants a packet won&#039t get anything until the key re-exchange\newline         * is done!\newline         */\newline        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, &quotRedirecting into the&quot\newline                       &quot key re-exchange from _libssh2_transport_read&quot);\newline        rc = _libssh2_kex_exchange(session, 1, &ampsession-&gtstartup_key_state);\newline        if (rc)\newline            return rc;\newline    }\newline\newline    /*\newline     * =============================== NOTE ===============================\newline     * I know this is very ugly and not a really good use of &quotgoto&quot, but\newline     * this case statement would be even uglier to do it any other way\newline     */\newline    if (session-&gtreadPack_state == libssh2_NB_state_jump1) {\newline        session-&gtreadPack_state = libssh2_NB_state_idle;\newline        encrypted = session-&gtreadPack_encrypted;\newline        goto libssh2_transport_read_point1;\newline    }\newline\newline    do {\newline        if (session-&gtsocket_state == LIBSSH2_SOCKET_DISCONNECTED) {\newline            return LIBSSH2_ERROR_NONE;\newline        }\newline\newline        if (session-&gtstate &amp LIBSSH2_STATE_NEWKEYS) {\newline            blocksize = session-&gtremote.crypt-&gtblocksize;\newline        } else {\newline            encrypted = 0;      /* not encrypted */\newline            blocksize = 5;      /* not strictly true, but we can use 5 here to\newline                                   make the checks below work fine still */\newline        }\newline\newline        /* read/use a whole big chunk into a temporary area stored in\newline           the LIBSSH2_SESSION struct. We will decrypt data from that\newline           buffer into the packet buffer so this temp one doesn&#039t have\newline           to be able to keep a whole SSH packet, just be large enough\newline           so that we can read big chunks from the network layer. */\newline\newline        /* how much data there is remaining in the buffer to deal with\newline           before we should read more from the network */\newline        remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline\newline        /* if remainbuf turns negative we have a bad internal error */\newline        assert(remainbuf &gt= 0);\newline\newline        if (remainbuf &lt blocksize) {\newline            /* If we have less than a blocksize left, it is too\newline               little data to deal with, read more */\newline            ssize_t nread;\newline\newline            /* move any remainder to the start of the buffer so\newline               that we can do a full refill */\newline            if (remainbuf) {\newline                memmove(p-&gtbuf, &ampp-&gtbuf[p-&gtreadidx], remainbuf);\newline                p-&gtreadidx = 0;\newline                p-&gtwriteidx = remainbuf;\newline            } else {\newline                /* nothing to move, just zero the indexes */\newline                p-&gtreadidx = p-&gtwriteidx = 0;\newline            }\newline\newline            /* now read a big chunk from the network into the temp buffer */\newline            nread =\newline                LIBSSH2_RECV(session, &ampp-&gtbuf[remainbuf],\newline                              PACKETBUFSIZE - remainbuf,\newline                              LIBSSH2_SOCKET_RECV_FLAGS(session));\newline            if (nread &lt= 0) {\newline                /* check if this is due to EAGAIN and return the special\newline                   return code if so, error out normally otherwise */\newline                if ((nread &lt 0) &amp&amp (nread == -EAGAIN)) {\newline                    session-&gtsocket_block_directions |=\newline                        LIBSSH2_SESSION_BLOCK_INBOUND;\newline                    return LIBSSH2_ERROR_EAGAIN;\newline                }\newline                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                               &quotError recving %d bytes (got %d)&quot,\newline                               PACKETBUFSIZE - remainbuf, -nread);\newline                return LIBSSH2_ERROR_SOCKET_RECV;\newline            }\newline            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                           &quotRecved %d/%d bytes to %p+%d&quot, nread,\newline                           PACKETBUFSIZE - remainbuf, p-&gtbuf, remainbuf);\newline\newline            debugdump(session, &quotlibssh2_transport_read() raw&quot,\newline                      &ampp-&gtbuf[remainbuf], nread);\newline            /* advance write pointer */\newline            p-&gtwriteidx += nread;\newline\newline            /* update remainbuf counter */\newline            remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline        }\newline\newline        /* how much data to deal with from the buffer */\newline        numbytes = remainbuf;\newline\newline        if (!p-&gttotal_num) {\newline            /* No payload package area allocated yet. To know the\newline               size of this payload, we need to decrypt the first\newline               blocksize data. */\newline\newline            if (numbytes &lt blocksize) {\newline                /* we can&#039t act on anything less than blocksize, but this\newline                   check is only done for the initial block since once we have\newline                   got the start of a block we can in fact deal with fractions\newline                */\newline                session-&gtsocket_block_directions |=\newline                    LIBSSH2_SESSION_BLOCK_INBOUND;\newline                return LIBSSH2_ERROR_EAGAIN;\newline            }\newline\newline            if (encrypted) {\newline                rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], block, blocksize);\newline                if (rc != LIBSSH2_ERROR_NONE) {\newline                    return rc;\newline                }\newline                /* save the first 5 bytes of the decrypted package, to be\newline                   used in the hash calculation later down. */\newline                memcpy(p-&gtinit, &ampp-&gtbuf[p-&gtreadidx], 5);\newline            } else {\newline                /* the data is plain, just copy it verbatim to\newline                   the working block buffer */\newline                memcpy(block, &ampp-&gtbuf[p-&gtreadidx], blocksize);\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += blocksize;\newline\newline            /* we now have the initial blocksize bytes decrypted,\newline             * and we can extract packet and padding length from it\newline             */\newline            p-&gtpacket_length = _libssh2_ntohu32(block);\newline            if (p-&gtpacket_length &lt 1)\newline                return LIBSSH2_ERROR_DECRYPT;\newline\newline            p-&gtpadding_length = block[4];\newline\newline            /* total_num is the number of bytes following the initial\newline               (5 bytes) packet length and padding length fields */\newline            total_num =\newline                p-&gtpacket_length - 1 +\newline                (encrypted ? session-&gtremote.mac-&gtmac_len : 0);\newline\newline            /* RFC4253 section 6.1 Maximum Packet Length says:\newline             *\newline             * &quotAll implementations MUST be able to process\newline             * packets with uncompressed payload length of 32768\newline             * bytes or less and total packet size of 35000 bytes\newline             * or less (including length, padding length, payload,\newline             * padding, and MAC.).&quot\newline             */\newline            if (total_num &gt LIBSSH2_PACKET_MAXPAYLOAD) {\newline                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\newline            }\newline\newline            /* Get a packet handle put data into. We get one to\newline               hold all data, including padding and MAC. */\newline            p-&gtpayload = LIBSSH2_ALLOC(session, total_num);\newline            if (!p-&gtpayload) {\newline                return LIBSSH2_ERROR_ALLOC;\newline            }\newline            p-&gttotal_num = total_num;\newline            /* init write pointer to start of payload buffer */\newline            p-&gtwptr = p-&gtpayload;\newline\newline            if (blocksize &gt 5) {\newline                /* copy the data from index 5 to the end of\newline                   the blocksize from the temporary buffer to\newline                   the start of the decrypted buffer */\newline                memcpy(p-&gtwptr, &ampblock[5], blocksize - 5);\newline                p-&gtwptr += blocksize - 5;       /* advance write pointer */\newline            }\newline\newline            /* init the data_num field to the number of bytes of\newline               the package read so far */\newline            p-&gtdata_num = p-&gtwptr - p-&gtpayload;\newline\newline            /* we already dealt with a blocksize worth of data */\newline            numbytes -= blocksize;\newline        }\newline\newline        /* how much there is left to add to the current payload\newline           package */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (numbytes &gt remainpack) {\newline            /* if we have more data in the buffer than what is going into this\newline               particular packet, we limit this round to this packet only */\newline            numbytes = remainpack;\newline        }\newline\newline        if (encrypted) {\newline            /* At the end of the incoming stream, there is a MAC,\newline               and we don&#039t want to decrypt that since we need it\newline               &quotraw&quot. We MUST however decrypt the padding data\newline               since it is used for the hash later on. */\newline            int skip = session-&gtremote.mac-&gtmac_len;\newline\newline            /* if what we have plus numbytes is bigger than the\newline               total minus the skip margin, we should lower the\newline               amount to decrypt even more */\newline            if ((p-&gtdata_num + numbytes) &gt (p-&gttotal_num - skip)) {\newline                numdecrypt = (p-&gttotal_num - skip) - p-&gtdata_num;\newline            } else {\newline                int frac;\newline                numdecrypt = numbytes;\newline                frac = numdecrypt % blocksize;\newline                if (frac) {\newline                    /* not an aligned amount of blocks,\newline                       align it */\newline                    numdecrypt -= frac;\newline                    /* and make it no unencrypted data\newline                       after it */\newline                    numbytes = 0;\newline                }\newline            }\newline        } else {\newline            /* unencrypted data should not be decrypted at all */\newline            numdecrypt = 0;\newline        }\newline\newline        /* if there are bytes to decrypt, do that */\newline        if (numdecrypt &gt 0) {\newline            /* now decrypt the lot */\newline            rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], p-&gtwptr, numdecrypt);\newline            if (rc != LIBSSH2_ERROR_NONE) {\newline                p-&gttotal_num = 0;   /* no packet buffer available */\newline                return rc;\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numdecrypt;\newline            /* advance write pointer */\newline            p-&gtwptr += numdecrypt;\newline            /* increase data_num */\newline            p-&gtdata_num += numdecrypt;\newline\newline            /* bytes left to take care of without decryption */\newline            numbytes -= numdecrypt;\newline        }\newline\newline        /* if there are bytes to copy that aren&#039t decrypted, simply\newline           copy them as-is to the target buffer */\newline        if (numbytes &gt 0) {\newline            memcpy(p-&gtwptr, &ampp-&gtbuf[p-&gtreadidx], numbytes);\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numbytes;\newline            /* advance write pointer */\newline            p-&gtwptr += numbytes;\newline            /* increase data_num */\newline            p-&gtdata_num += numbytes;\newline        }\newline\newline        /* now check how much data there&#039s left to read to finish the\newline           current packet */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (!remainpack) {\newline            /* we have a full packet */\newline          libssh2_transport_read_point1:\newline            rc = fullpacket(session, encrypted);\newline            if (rc == LIBSSH2_ERROR_EAGAIN) {\newline\newline                if (session-&gtpackAdd_state != libssh2_NB_state_idle)\newline                {\newline                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\newline                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If that\newline                     * returns LIBSSH2_ERROR_EAGAIN but the packAdd_state is idle,\newline                     * then the packet has been added to the brigade, but some\newline                     * immediate action that was taken based on the packet\newline                     * type (such as key re-exchange) is not yet complete.\newline                     * Clear the way for a new packet to be read in.\newline                     */\newline                    session-&gtreadPack_encrypted = encrypted;\newline                    session-&gtreadPack_state = libssh2_NB_state_jump1;\newline                }\newline\newline                return rc;\newline            }\newline\newline            p-&gttotal_num = 0;   /* no packet buffer available */\newline\newline            return rc;\newline        }\newline    } while (1);                /* loop */\newline\newline    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\newline}\newline","\newline This function reads the binary stream as specified in chapter 6 of RFC4253\newline &quotThe Secure Shell (SSH) Transport Layer Protocol&quot\newline \newline DOES NOT call _libssh2_error() for ANY error case.\newline \newline","1480360","configdialog.cpp","void ConfigDialog::on_checkBoxAutoclear_clicked() {\newline  on_comboBoxClipboard_activated(1);\newline}\newline","\newline @brief ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked, update\newline state via ConfigDialog::on_comboBoxClipboard_activated\newline \newline","","","","","","","","","","","","on","","","on","","","on","","","","","","","","","","","","","","","","","","","","","","","","","Encodes the input digest using characters from the set","Pins the window","Event filter","Find come attrbute in an attribute list.","Get the host list","return the OpenSSL hash algorithm associated with a specified JWT algorithm","adjust the end of the overlapped cue","Function to index a table.","\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.","convert radians to dms","Callback that toggles the orientation of the progress bar","{}","reads the binary stream","checkbox clicked, updatestate","{}","Clear out the given server_list.","tests on the tangent trigonometric function.","{}","The GTK+ identifier for the mouse button used to click.","starts a command on the underlying system","returns a pseudo-random number"
"3D1TUISJWI0YC7XIQVTHLAFOB7WUIA","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3AWETUDC92SHLQOLMKXQRLQSTBTZIM","A25F6WT9CIM0Z5","Rejected","Wed Apr 17 09:54:08 PDT 2019","Wed Apr 17 10:09:49 PDT 2019","Fri Apr 19 10:09:49 PDT 2019","","Wed Apr 17 13:10:14 PDT 2019","These results appear to be spam, or represent a misunderstanding of the task","941","0% (0/1)","0% (0/1)","0% (0/1)","4378774","fsck.c","static int digest_encode(const char *src, int len, char *dst)\newline{\newline	int i = 0, bits = 0, ac = 0;\newline	char *cp = dst;\newline\newline	while (i &lt len) {\newline		ac += (((unsigned char) src[i]) &lt&lt bits);\newline		bits += 8;\newline		do {\newline			*cp++ = lookup_table[ac &amp 0x3f];\newline			ac &gt&gt= 6;\newline			bits -= 6;\newline		} while (bits &gt= 6);\newline		i++;\newline	}\newline	if (bits)\newline		*cp++ = lookup_table[ac &amp 0x3f];\newline	*cp = 0;\newline	return cp - dst;\newline}\newline","\newline digest_encode() -\newline \newline Encodes the input digest using characters from the set [a-zA-Z0-9_+].\newline The encoded string is roughly 4/3 times the size of the input string.\newline \newline","5980191","mur_read_file.c","uint4 mur_prev(jnl_ctl_list *jctl, off_jnl_t dskaddr)\newline{\newline	off_jnl_t	buff_offset;\newline	uint4		status, partial_reclen;\newline	jrec_suffix	*suffix;\newline	mur_buff_desc_t	*swap_buff;\newline	boolean_t	good_suffix, good_prefix;\newline	mur_read_desc_t	*mur_desc;\newline\newline	mur_desc = jctl-&gtreg_ctl-&gtmur_desc;\newline	if (0 != dskaddr)\newline	{ /* read record at dskaddr */\newline		assert(dskaddr &lt jctl-&gteof_addr);\newline		assert(dskaddr &gt= JNL_HDR_LEN);\newline		if (dskaddr &gt= jctl-&gteof_addr || dskaddr &lt JNL_HDR_LEN)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotRequested offset out of range [prev]&quot));\newline			return (dskaddr &gt= jctl-&gteof_addr ? ERR_JNLREADEOF : ERR_JNLREADBOF);\newline		}\newline		assert(dskaddr == ROUND_UP2(dskaddr, JNL_REC_START_BNDRY)); /* dskaddr must be aligned at JNL_REC_START_BNDRY */\newline		MUR_FREAD_CANCEL(jctl, mur_desc, status);\newline		if (SS_NORMAL != status)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotCould not cancel prior read [prev]&quot), jctl-&gtstatus);\newline			return jctl-&gtstatus;\newline		}\newline		mur_desc-&gtbuff_index = 1;\newline		mur_desc-&gtcur_buff = &ampmur_desc-&gtseq_buff[mur_desc-&gtbuff_index];\newline		mur_desc-&gtsec_buff = &ampmur_desc-&gtseq_buff[1 - mur_desc-&gtbuff_index];\newline		mur_desc-&gtcur_buff-&gtdskaddr = ROUND_DOWN2(dskaddr, MUR_BUFF_SIZE);\newline		mur_desc-&gtcur_buff-&gtblen = MIN(MUR_BUFF_SIZE, jctl-&gteof_addr - mur_desc-&gtcur_buff-&gtdskaddr);\newline		buff_offset = dskaddr - mur_desc-&gtcur_buff-&gtdskaddr;\newline		assert(JREC_PREFIX_UPTO_LEN_SIZE &lt= mur_desc-&gtcur_buff-&gtblen - buff_offset);\newline			/* we rely on reading at least up to the record length field (forwptr) */\newline		if (SS_NORMAL != (status = mur_freadw(jctl, mur_desc-&gtcur_buff)))\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline					LEN_AND_LIT(&quotError from synchronous read into cur_buff [prev]&quot), status);\newline			return status;\newline		}\newline		mur_desc-&gtjnlrec = (jnl_record *)(mur_desc-&gtcur_buff-&gtbase + buff_offset);\newline		good_suffix = TRUE;\newline		if (FALSE != (good_prefix = IS_VALID_LEN_FROM_PREFIX(mur_desc-&gtjnlrec, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjreclen = mur_desc-&gtjnlrec-&gtprefix.forwptr;\newline			if (MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr)\newline			{ /* while we process the just read chunk, post a read for the immediately preceding chunk */\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline					   	LEN_AND_LIT(&quotCould not initiate read into sec_buff in [prev] (dskaddr &gt 0)&quot),\newline						status);\newline					return status;\newline				}\newline			} else\newline			{ /* we read the beginning MUR_BUFF_SIZE (or smaller) chunk from file, no previous chunk exists */\newline				assert(0 == mur_desc-&gtcur_buff-&gtdskaddr);\newline			}\newline			if (buff_offset + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gtblen)\newline			{ /* Journal record straddles MUR_BUFF_SIZE boundary, did not read the entire record, read what&#039s left into\newline			   * aux_buff2 which is located at the end of seq_buff[1], the current buffer */\newline				mur_desc-&gtaux_buff2.dskaddr = mur_desc-&gtcur_buff-&gtdskaddr + mur_desc-&gtcur_buff-&gtblen;\newline				mur_desc-&gtaux_buff2.blen = (buff_offset + mur_desc-&gtjreclen - mur_desc-&gtcur_buff-&gtblen);\newline				if (FALSE != (good_prefix =\newline					(jctl-&gteof_addr - mur_desc-&gtaux_buff2.dskaddr &gt= mur_desc-&gtaux_buff2.blen)))\newline				{\newline					if (SS_NORMAL != (status = mur_freadw(jctl, &ampmur_desc-&gtaux_buff2)))\newline					{\newline						gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3,\newline							jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, mur_desc-&gtaux_buff2.dskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError in synchronous read into aux_buff [prev]&quot), status);\newline						return status;\newline					}\newline				} else\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3,\newline						jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, dskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond end of file [prev] (dskaddr &gt 0)&quot));\newline					return ERR_JNLBADRECFMT;\newline				}\newline			}\newline		} /* end good_prefix */\newline	} else\newline	{ /* dskaddr == 0, locate the previous record in the buffer, reading from disk if necessary */\newline		assert(JNL_HDR_LEN &lt= jctl-&gtrec_offset);\newline		suffix = (jrec_suffix *)((char *)mur_desc-&gtjnlrec - JREC_SUFFIX_SIZE);\newline		/* ok to test with possibly invalid backptr, we test for validity below */\newline		if (((unsigned char *)suffix &gt mur_desc-&gtcur_buff-&gtbase)\newline			&amp&amp (((unsigned char *)mur_desc-&gtjnlrec - suffix-&gtbackptr) &gt= mur_desc-&gtcur_buff-&gtbase))\newline		{	/* prev record is contained completely in the current buffer */\newline			if ((0 == mur_desc-&gtbuff_index)\newline				&amp&amp ((unsigned char *)mur_desc-&gtjnlrec + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gttop)\newline				&amp&amp (0 &lt mur_desc-&gtcur_buff-&gtdskaddr)) /* end of rec in sec_buff and there is data to be read */\newline			{ /* we just finished processing the journal record that straddled seq_buff[0] and seq_buff[1],\newline			   * start read in the now free secondary buffer (seq_buff[1]) to overlap with processing */\newline				assert(MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr);\newline				assert(!mur_desc-&gtsec_buff-&gtread_in_progress);\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotCould not initiate read into sec_buff [prev] (dskaddr == 0)&quot), status);\newline					return status;\newline				}\newline			}\newline		} else\newline		{ /* prev record completely in sec_buff or overlaps cur_buff and sec_buff */\newline			if (0 == mur_desc-&gtbuff_index)\newline			{ /* copy partial record to just past the end of seq_buff[1], i.e., aux_seq_buff[1] to make the record\newline			   * available in contiguous memory */\newline				partial_reclen = (uint4)((unsigned char *)mur_desc-&gtjnlrec - mur_desc-&gtseq_buff[0].base);\newline				if (0 &lt partial_reclen)\newline					memcpy(mur_desc-&gtseq_buff[1].top, mur_desc-&gtseq_buff[0].base, partial_reclen);\newline				suffix = (jrec_suffix *)(mur_desc-&gtseq_buff[1].top + partial_reclen - JREC_SUFFIX_SIZE);\newline			}\newline			/* before switching the buffers, wait for completion of pending I/O */\newline			if (mur_desc-&gtsec_buff-&gtread_in_progress)\newline			{\newline				MUR_FREAD_WAIT(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError waiting for sec_buff read to complete [prev]&quot),\newline							status);\newline					return status;\newline				}\newline			}\newline			/* If possible, overlap I/O with processing, read into available buffer */\newline			if ((0 == mur_desc-&gtbuff_index || /* we just copied partial record (if any), OR */\newline			    (unsigned char *)mur_desc-&gtjnlrec == mur_desc-&gtcur_buff-&gtbase) /* we completely processed cur_buff */\newline				&amp&amp 0 &lt mur_desc-&gtsec_buff-&gtdskaddr) /* there is data to be read */\newline			{\newline				assert(mur_desc-&gtsec_buff-&gtdskaddr &gt= MUR_BUFF_SIZE);\newline				mur_desc-&gtcur_buff-&gtdskaddr = mur_desc-&gtsec_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtcur_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotCould not initiate read into cur_buff [prev]&quot), status);\newline					return status;\newline				}\newline			}\newline			/* Make the buffer that has data that was previously read current */\newline			mur_desc-&gtbuff_index = 1 - mur_desc-&gtbuff_index;\newline			swap_buff = mur_desc-&gtcur_buff;\newline			mur_desc-&gtcur_buff = mur_desc-&gtsec_buff;\newline			mur_desc-&gtsec_buff = swap_buff;\newline		}\newline		good_prefix = TRUE;\newline		if (FALSE != (good_suffix = IS_VALID_LEN_FROM_SUFFIX(suffix, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjnlrec = (jnl_record *)((char *)suffix + JREC_SUFFIX_SIZE - suffix-&gtbackptr);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &gt= mur_desc-&gtcur_buff-&gtbase);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &lt  mur_desc-&gtcur_buff-&gttop);\newline			mur_desc-&gtjreclen = suffix-&gtbackptr;\newline			if (jctl-&gtrec_offset &lt mur_desc-&gtjreclen + JNL_HDR_LEN)\newline			{\newline				gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, jctl-&gtrec_offset, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond beginning of file [prev]&quot));\newline				return ERR_JNLBADRECFMT;\newline			}\newline		}\newline	} /* end of dskaddr == 0 */\newline	if (good_prefix &amp&amp good_suffix &amp&amp IS_VALID_JNLREC(mur_desc-&gtjnlrec, jctl-&gtjfh))\newline		return SS_NORMAL;\newline	return ERR_JNLBADRECFMT;\newline}\newline","#GTM_THREAD_SAFE : The below function (mur_prev) is thread-safe \newline","3428267","ccid_usb.c","static void Multi_PollingTerminate(struct usbDevice_MultiSlot_Extension *msExt)\newline{\newline	struct libusb_transfer *transfer;\newline\newline	if (msExt &amp&amp !msExt-&gtterminated)\newline	{\newline		msExt-&gtterminated = TRUE;\newline\newline		transfer = usbDevice[msExt-&gtreader_index].polling_transfer;\newline\newline		if (transfer)\newline		{\newline			int ret;\newline\newline			ret = libusb_cancel_transfer(transfer);\newline			if (ret &lt 0)\newline				DEBUG_CRITICAL2(&quotlibusb_cancel_transfer failed: %d&quot, ret);\newline		}\newline	}\newline} /* Multi_PollingTerminate */\newline","\newline \newline Multi_PollingTerminate\newline \newline \newline","5830889","server.c","static void clearq(struct server_list *xx)\newline{\newline  struct server_list *x;\newline\newline  while (xx) {\newline    x = xx-&gtnext;\newline    if (xx-&gtname)\newline      nfree(xx-&gtname);\newline    if (xx-&gtpass)\newline      nfree(xx-&gtpass);\newline    if (xx-&gtrealname)\newline      nfree(xx-&gtrealname);\newline    nfree(xx);\newline    xx = x;\newline  }\newline}\newline","Clear out the given server_list.\newline \newline","1448774","check_inifcns.cpp","static unsigned inifcns_check_tan()\newline{\newline	unsigned result = 0;\newline	bool errorflag;\newline	\newline	// compare tan((q*Pi).evalf()) with tan(q*Pi).eval().evalf() at various\newline	// points.  E.g. if tan(Pi/12) returns something symbolic this should be\newline	// equal to 2-sqrt(3).  This routine will spot programming mistakes of \newline	// this kind:\newline	errorflag = false;\newline	ex argument;\newline	numeric epsilon(double(1e-8));\newline	for (int n=-340; n&lt=340; ++n) {\newline		if (!(n%30) &amp&amp (n%60))  // skip poles\newline			++n;\newline		argument = n*Pi/60;\newline		if (abs(tan(evalf(argument))-evalf(tan(argument)))&gtepsilon) {\newline			clog &lt&lt &quottan(&quot &lt&lt argument &lt&lt &quot) returns &quot\newline			     &lt&lt tan(argument) &lt&lt endl;\newline			errorflag = true;\newline		}\newline	}\newline	if (errorflag)\newline		++result;\newline	\newline	return result;\newline}\newline","Simple tests on the tangent trigonometric function. \newline","6038115","dmmain.c","static int display_close(void *handle, void *device)\newline{\newline    IMAGE *img = image_find(handle, device);\newline    if (img == NULL)\newline       return -1;\newline\newline    gsdll_poll(handle);\newline\newline    /* remove from list */\newline    if (img == first_image)\newline        first_image = img-&gtnext;\newline    else\newline    {\newline        IMAGE *tmp;\newline        for (tmp = first_image; tmp!=0; tmp=tmp-&gtnext)\newline        {\newline            if (img == tmp-&gtnext)\newline            tmp-&gtnext = img-&gtnext;\newline        }\newline    }\newline\newline    DisposePixMap(img-&gtpixmapHdl);   // need to go in doCloseWindow()\newline    DisposeWindow(img-&gtwindowRef);\newline\newline    free(img);\newline\newline    return 0;\newline}\newline","This is the last event from this device. \newline","812839","webkitwebnavigationaction.cpp","gint webkit_web_navigation_action_get_button(WebKitWebNavigationAction* navigationAction)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_WEB_NAVIGATION_ACTION(navigationAction), -1);\newline\newline    return navigationAction-&gtpriv-&gtbutton;\newline}\newline","\newline webkit_web_navigation_action_get_button:\newline @navigationAction: a #WebKitWebNavigationAction\newline \newline The GTK+ identifier for the mouse button used to click. Notice that GTK+ button values\newline are 1, 2 and 3 for left, middle and right buttons, so they are DOM button values +1. If the action was not\newline initiated by a mouse click the value will be -1.\newline \newline Return value: the mouse button used to click\newline \newline Since: 1.0.3\newline \newline","6362084","disks.cpp","int DiskEntry::sysCall(QString &amp completeCommand)\newline{\newline    if (readingSysStdErrOut || sysProc-&gtstate() == QProcess::Running )\newline        return -1;\newline\newline    sysStringErrOut=i18n(&quotCalled: %1\\n\\n&quot, completeCommand); // put the called command on ErrOut\newline    sysProc-&gtclearProgram();\newline\newline    //Split command and arguments to use the new API, otherwise it doesn&#039t work\newline    QTextStream tS(&ampcompleteCommand);\newline\newline    QString command;\newline    tS &gt&gt command;\newline\newline    QString tmp;\newline    QStringList args;\newline    while( !tS.atEnd() )\newline    {\newline        tS &gt&gt tmp;\newline        args &lt&lt tmp;\newline    }\newline\newline    sysProc-&gtsetProgram(command, args);\newline    sysProc-&gtstart();\newline\newline    if ( !sysProc-&gtwaitForStarted(-1) )\newline        qCCritical(KDF) &lt&lt i18n(&quotcould not execute %1&quot, command) ;\newline\newline    sysProc-&gtwaitForFinished(-1);\newline\newline    if (sysProc-&gtexitCode()!=0)\newline        emit sysCallError(this, sysProc-&gtexitStatus());\newline\newline    return (sysProc-&gtexitCode());\newline}\newline","\newline starts a command on the underlying system via /bin/sh\newline \newline","2726110","rnd.c","int32 rnd ()\newline{\newline  register long low, high, test;\newline\newline  high = rnd_seed / RNG_Q;\newline  low = rnd_seed % RNG_Q;\newline  test = RNG_A * low - RNG_R * high;\newline  if (test &gt 0)\newline    rnd_seed = test;\newline  else\newline    rnd_seed = test + RNG_M;\newline  return rnd_seed;\newline}\newline","returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 \newline","893020","script_functions.c","int c_pin_window(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotpin_window: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline		if (window) {\newline			wnck_window_pin(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Pins the window\newline \newline","6449222","qwt_plot.cpp","bool QwtPlot::eventFilter( QObject *object, QEvent *event )\newline{\newline    if ( object == d_data-&gtcanvas )\newline    {\newline        if ( event-&gttype() == QEvent::Resize )\newline        {\newline            updateCanvasMargins();\newline        }\newline        else if ( event-&gttype() == QEvent::ContentsRectChange )\newline        {\newline            updateLayout();\newline        }\newline    }\newline\newline    return QFrame::eventFilter( object, event );\newline}\newline","!\newline\\brief Event filter\newlineThe plot handles the following events for the canvas:\newline- QEvent::Resize\newlineThe canvas margins might depend on its size\newline- QEvent::ContentsRectChange\newlineThe layout needs to be recalculated\newline\\param object Object to be filtered\newline\\param event Event\newline\\return See QFrame::eventFilter()\newline\\sa updateCanvasMargins(), updateLayout()\newline \newline","2776384","msc.c","static const char *findAttrib(const struct MscAttribTag *attr, MscAttribType a)\newline{\newline    while(attr != NULL &amp&amp attr-&gttype != a)\newline    {\newline        attr = attr-&gtnext;\newline    }\newline\newline    if(attr != NULL)\newline    {\newline        return attr-&gtvalue;\newline    }\newline    else\newline    {\newline        return NULL;\newline    }\newline}\newline","Find come attrbute in an attribute list.\newline \newline \\param[in] attr Head of the linked list to search.\newline \\param[in] a The attribute type to find.\newline \\retval NULL If the attribute was not found or the passed list was NULL.\newline \newline","6582023","zeroconf.c","int dcc_zeroconf_add_hosts(struct dcc_hostdef **ret_list, int *ret_nhosts, int n_slots, struct dcc_hostdef **ret_prev) {\newline    char *host_file = NULL, *lock_file = NULL, *s = NULL;\newline    int lock_fd = -1, host_fd = -1;\newline    int fork_daemon = 0;\newline    int r = -1;\newline    char *dir;\newline    struct stat st;\newline\newline    if (get_zeroconf_dir(&ampdir) != 0) {\newline        rs_log_crit(&quotfailed to get zeroconf dir.\\n&quot);\newline        goto finish;\newline    }\newline\newline    lock_file = malloc(strlen(dir) + sizeof(&quot/lock&quot));\newline    assert(lock_file);\newline    sprintf(lock_file, &quot%s/lock&quot, dir);\newline\newline    host_file = malloc(strlen(dir) + sizeof(&quot/hosts&quot));\newline    assert(host_file);\newline    sprintf(host_file, &quot%s/hosts&quot, dir);\newline\newline    /* Open lock file */\newline    if ((lock_fd = open(lock_file, O_RDWR|O_CREAT, 0666)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, lock_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Try to lock the lock file */\newline    if (generic_lock(lock_fd, 1, 1, 0) &gt= 0) {\newline        /* The lock succeeded =&gt there&#039s no daemon running yet! */\newline        fork_daemon = 1;\newline        generic_lock(lock_fd, 1, 0, 0);\newline    }\newline\newline    close(lock_fd);\newline\newline    /* Shall we fork a new daemon? */\newline    if (fork_daemon) {\newline        pid_t pid;\newline\newline        rs_log_info(&quotSpawning zeroconf daemon.\\n&quot);\newline\newline        if ((pid = fork()) == -1) {\newline            rs_log_crit(&quotfork() failed: %s\\n&quot, strerror(errno));\newline            goto finish;\newline        } else if (pid == 0) {\newline            int fd;\newline            /* Child */\newline\newline            /* Close file descriptors and replace them by /dev/null */\newline            close(0);\newline            close(1);\newline            close(2);\newline            fd = open(&quot/dev/null&quot, O_RDWR);\newline            assert(fd == 0);\newline            fd = dup(0);\newline            assert(fd == 1);\newline            fd = dup(0);\newline            assert(fd == 2);\newline\newline#ifdef HAVE_SETSID\newline            setsid();\newline#endif\newline\newline            chdir(&quot/&quot);\newline            rs_add_logger(rs_logger_syslog, RS_LOG_DEBUG, NULL, 0);\newline            _exit(daemon_proc(host_file, lock_file, n_slots));\newline        }\newline\newline        /* Parent */\newline\newline        /* Wait some time for initial host gathering */\newline        usleep(1000000);         /* 1000 ms */\newline    }\newline\newline    /* Open host list read-only */\newline    if ((host_fd = open(host_file, O_RDONLY)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, host_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* A read lock */\newline    if (generic_lock(host_fd, 0, 1, 1) &lt 0) {\newline        rs_log_crit(&quotlock failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Get file size */\newline    if (fstat(host_fd, &ampst) &lt 0) {\newline        rs_log_crit(&quotstat() failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    if (st.st_size &gt= MAX_FILE_SIZE) {\newline        rs_log_crit(&quotfile too large.\\n&quot);\newline        goto finish;\newline    }\newline\newline    /* read file data */\newline    s = malloc((size_t) st.st_size+1);\newline    assert(s);\newline\newline    if (dcc_readx(host_fd, s, (size_t) st.st_size) != 0) {\newline        rs_log_crit(&quotfailed to read from file.\\n&quot);\newline        goto finish;\newline    }\newline    s[st.st_size] = 0;\newline\newline    /* Parse host data */\newline    if (dcc_parse_hosts(s, host_file, ret_list, ret_nhosts, ret_prev) != 0) {\newline        rs_log_crit(&quotfailed to parse host file.\\n&quot);\newline        goto finish;\newline    }\newline\newline    r = 0;\newline\newlinefinish:\newline    if (host_fd &gt= 0) {\newline        generic_lock(host_fd, 0, 0, 1);\newline        close(host_fd);\newline    }\newline\newline    free(lock_file);\newline    free(host_file);\newline    free(s);\newline\newline    return r;\newline}\newline","Get the host list from zeroconf \newline","2144342","jose.c","static char *oidc_jose_alg_to_openssl_digest(const char *alg) {\newline	if ((strcmp(alg, &quotRS256&quot) == 0) || (strcmp(alg, &quotPS256&quot) == 0)\newline			|| (strcmp(alg, &quotHS256&quot) == 0) || (strcmp(alg, &quotES256&quot) == 0)) {\newline		return &quotsha256&quot;\newline	}\newline	if ((strcmp(alg, &quotRS384&quot) == 0) || (strcmp(alg, &quotPS384&quot) == 0)\newline			|| (strcmp(alg, &quotHS384&quot) == 0) || (strcmp(alg, &quotES384&quot) == 0)) {\newline		return &quotsha384&quot;\newline	}\newline	if ((strcmp(alg, &quotRS512&quot) == 0) || (strcmp(alg, &quotPS512&quot) == 0)\newline			|| (strcmp(alg, &quotHS512&quot) == 0) || (strcmp(alg, &quotES512&quot) == 0)) {\newline		return &quotsha512&quot;\newline	}\newline	if (strcmp(alg, &quotNONE&quot) == 0) {\newline		return &quotNONE&quot;\newline	}\newline	return NULL;\newline}\newline","\newline return the OpenSSL hash algorithm associated with a specified JWT algorithm\newline \newline","3774541","webvtt.c","static GF_WebVTTCue *gf_webvtt_cue_split_at(GF_WebVTTCue *cue, GF_WebVTTTimestamp *time)\newline{\newline	GF_WebVTTCue *dup_cue;\newline\newline	cue-&gtsplit         = GF_TRUE;\newline	cue-&gtorig_start    = cue-&gtstart;\newline	cue-&gtorig_end      = cue-&gtend;\newline\newline	GF_SAFEALLOC(dup_cue, GF_WebVTTCue);\newline	dup_cue-&gtsplit          = GF_TRUE;\newline	dup_cue-&gtstart          = *time;\newline	dup_cue-&gtend            = cue-&gtend;\newline	dup_cue-&gtorig_start     = cue-&gtorig_start;\newline	dup_cue-&gtorig_end       = cue-&gtorig_end;\newline	dup_cue-&gtid             = gf_strdup((cue-&gtid ? cue-&gtid : &quot&quot));\newline	dup_cue-&gtsettings       = gf_strdup((cue-&gtsettings ? cue-&gtsettings : &quot&quot));\newline	dup_cue-&gttext           = gf_strdup((cue-&gttext ? cue-&gttext : &quot&quot));\newline\newline	cue-&gtend = *time;\newline	return dup_cue;\newline}\newline","adjust the end of the overlapped cue in the previous sample \newline","131765","lvm.c","const TObject *luaV_gettable (lua_State *L, StkId t) {\newline  Closure *tm;\newline  int tg;\newline  if (ttype(t) == LUA_TTABLE &amp&amp  /* `t&#039 is a table? */\newline      ((tg = hvalue(t)-&gthtag) == LUA_TTABLE ||  /* with default tag? */\newline        luaT_gettm(L, tg, TM_GETTABLE) == NULL)) { /* or no TM? */\newline    /* do a primitive get */\newline    const TObject *h = luaH_get(L, hvalue(t), L-&gttop-1);\newline    /* result is no nil or there is no `index&#039 tag method? */\newline    if (ttype(h) != LUA_TNIL || ((tm=luaT_gettm(L, tg, TM_INDEX)) == NULL))\newline      return h;  /* return result */\newline    /* else call `index&#039 tag method */\newline  }\newline  else {  /* try a `gettable&#039 tag method */\newline    tm = luaT_gettmbyObj(L, t, TM_GETTABLE);\newline  }\newline  if (tm != NULL) {  /* is there a tag method? */\newline    luaD_checkstack(L, 2);\newline    *(L-&gttop+1) = *(L-&gttop-1);  /* key */\newline    *L-&gttop = *t;  /* table */\newline    clvalue(L-&gttop-1) = tm;  /* tag method */\newline    ttype(L-&gttop-1) = LUA_TFUNCTION;\newline    L-&gttop += 2;\newline    luaD_call(L, L-&gttop - 3, 1);\newline    return L-&gttop - 1;  /* call result */\newline  }\newline  else {  /* no tag method */\newline    luaG_typeerror(L, t, &quotindex&quot);\newline    return NULL;  /* to avoid warnings */\newline  }\newline}\newline","\newline Function to index a table.\newline Receives the table at `t&#039 and the key at top.\newline \newline","3069061","nxsreader.cpp","NxsBlock *NxsReader::FindBlockByTitle(const BlockReaderList &amp chosenBlockList, const char *title, unsigned *nMatches)\newline	{\newline	BlockReaderList  found = FindAllBlocksByTitle(chosenBlockList, title);\newline\newline	if (found.empty())\newline		{\newline		if (nMatches)\newline			*nMatches = 0;\newline		return NULL;\newline		}\newline	if (nMatches)\newline		*nMatches = (unsigned)found.size();\newline	return (NxsBlock *) found.back();\newline	}\newline","! \\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.\newline In the event of ties, the most recently read block is returned.\newline If `title` is NULL, then any block is considered a match.\newline On output nMatches will be the number of matches (if `nMatches` is not NULL).\newline NULL will be returned if there are no matches.\newline \newline","4385305","utility.c","void ln_rad_to_dms (double radians, struct ln_dms *dms)\newline{\newline    double degrees = ln_rad_to_deg(radians);\newline    \newline    ln_deg_to_dms(degrees, dms);\newline}\newline","convert radians to dms \newline","1659570","progressbar.c","static void toggle_orientation( GtkWidget    *widget,\newline                                ProgressData *pdata )\newline{\newline  switch (gtk_progress_bar_get_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar))) {\newline  case GTK_PROGRESS_LEFT_TO_RIGHT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_RIGHT_TO_LEFT);\newline    break;\newline  case GTK_PROGRESS_RIGHT_TO_LEFT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_LEFT_TO_RIGHT);\newline    break;\newline  default:;\newline    /* do nothing */\newline  }\newline}\newline","Callback that toggles the orientation of the progress bar \newline","5758787","transport.c","int _libssh2_transport_read(LIBSSH2_SESSION * session)\newline{\newline    int rc;\newline    struct transportpacket *p = &ampsession-&gtpacket;\newline    int remainbuf;\newline    int remainpack;\newline    int numbytes;\newline    int numdecrypt;\newline    unsigned char block[MAX_BLOCKSIZE];\newline    int blocksize;\newline    int encrypted = 1;\newline    size_t total_num;\newline\newline    /* default clear the bit */\newline    session-&gtsocket_block_directions &amp= ~LIBSSH2_SESSION_BLOCK_INBOUND;\newline\newline    /*\newline     * All channels, systems, subsystems, etc eventually make it down here\newline     * when looking for more incoming data. If a key exchange is going on\newline     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\newline     * ONLY send key exchange related traffic. In non-blocking mode, there is\newline     * a chance to break out of the kex_exchange function with an EAGAIN\newline     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\newline     * active, then we must redirect to the key exchange. However, if\newline     * kex_exchange is active (as in it is the one that calls this execution\newline     * of packet_read, then don&#039t redirect, as that would be an infinite loop!\newline     */\newline\newline    if (session-&gtstate &amp LIBSSH2_STATE_EXCHANGING_KEYS &amp&amp\newline        !(session-&gtstate &amp LIBSSH2_STATE_KEX_ACTIVE)) {\newline\newline        /* Whoever wants a packet won&#039t get anything until the key re-exchange\newline         * is done!\newline         */\newline        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, &quotRedirecting into the&quot\newline                       &quot key re-exchange from _libssh2_transport_read&quot);\newline        rc = _libssh2_kex_exchange(session, 1, &ampsession-&gtstartup_key_state);\newline        if (rc)\newline            return rc;\newline    }\newline\newline    /*\newline     * =============================== NOTE ===============================\newline     * I know this is very ugly and not a really good use of &quotgoto&quot, but\newline     * this case statement would be even uglier to do it any other way\newline     */\newline    if (session-&gtreadPack_state == libssh2_NB_state_jump1) {\newline        session-&gtreadPack_state = libssh2_NB_state_idle;\newline        encrypted = session-&gtreadPack_encrypted;\newline        goto libssh2_transport_read_point1;\newline    }\newline\newline    do {\newline        if (session-&gtsocket_state == LIBSSH2_SOCKET_DISCONNECTED) {\newline            return LIBSSH2_ERROR_NONE;\newline        }\newline\newline        if (session-&gtstate &amp LIBSSH2_STATE_NEWKEYS) {\newline            blocksize = session-&gtremote.crypt-&gtblocksize;\newline        } else {\newline            encrypted = 0;      /* not encrypted */\newline            blocksize = 5;      /* not strictly true, but we can use 5 here to\newline                                   make the checks below work fine still */\newline        }\newline\newline        /* read/use a whole big chunk into a temporary area stored in\newline           the LIBSSH2_SESSION struct. We will decrypt data from that\newline           buffer into the packet buffer so this temp one doesn&#039t have\newline           to be able to keep a whole SSH packet, just be large enough\newline           so that we can read big chunks from the network layer. */\newline\newline        /* how much data there is remaining in the buffer to deal with\newline           before we should read more from the network */\newline        remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline\newline        /* if remainbuf turns negative we have a bad internal error */\newline        assert(remainbuf &gt= 0);\newline\newline        if (remainbuf &lt blocksize) {\newline            /* If we have less than a blocksize left, it is too\newline               little data to deal with, read more */\newline            ssize_t nread;\newline\newline            /* move any remainder to the start of the buffer so\newline               that we can do a full refill */\newline            if (remainbuf) {\newline                memmove(p-&gtbuf, &ampp-&gtbuf[p-&gtreadidx], remainbuf);\newline                p-&gtreadidx = 0;\newline                p-&gtwriteidx = remainbuf;\newline            } else {\newline                /* nothing to move, just zero the indexes */\newline                p-&gtreadidx = p-&gtwriteidx = 0;\newline            }\newline\newline            /* now read a big chunk from the network into the temp buffer */\newline            nread =\newline                LIBSSH2_RECV(session, &ampp-&gtbuf[remainbuf],\newline                              PACKETBUFSIZE - remainbuf,\newline                              LIBSSH2_SOCKET_RECV_FLAGS(session));\newline            if (nread &lt= 0) {\newline                /* check if this is due to EAGAIN and return the special\newline                   return code if so, error out normally otherwise */\newline                if ((nread &lt 0) &amp&amp (nread == -EAGAIN)) {\newline                    session-&gtsocket_block_directions |=\newline                        LIBSSH2_SESSION_BLOCK_INBOUND;\newline                    return LIBSSH2_ERROR_EAGAIN;\newline                }\newline                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                               &quotError recving %d bytes (got %d)&quot,\newline                               PACKETBUFSIZE - remainbuf, -nread);\newline                return LIBSSH2_ERROR_SOCKET_RECV;\newline            }\newline            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                           &quotRecved %d/%d bytes to %p+%d&quot, nread,\newline                           PACKETBUFSIZE - remainbuf, p-&gtbuf, remainbuf);\newline\newline            debugdump(session, &quotlibssh2_transport_read() raw&quot,\newline                      &ampp-&gtbuf[remainbuf], nread);\newline            /* advance write pointer */\newline            p-&gtwriteidx += nread;\newline\newline            /* update remainbuf counter */\newline            remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline        }\newline\newline        /* how much data to deal with from the buffer */\newline        numbytes = remainbuf;\newline\newline        if (!p-&gttotal_num) {\newline            /* No payload package area allocated yet. To know the\newline               size of this payload, we need to decrypt the first\newline               blocksize data. */\newline\newline            if (numbytes &lt blocksize) {\newline                /* we can&#039t act on anything less than blocksize, but this\newline                   check is only done for the initial block since once we have\newline                   got the start of a block we can in fact deal with fractions\newline                */\newline                session-&gtsocket_block_directions |=\newline                    LIBSSH2_SESSION_BLOCK_INBOUND;\newline                return LIBSSH2_ERROR_EAGAIN;\newline            }\newline\newline            if (encrypted) {\newline                rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], block, blocksize);\newline                if (rc != LIBSSH2_ERROR_NONE) {\newline                    return rc;\newline                }\newline                /* save the first 5 bytes of the decrypted package, to be\newline                   used in the hash calculation later down. */\newline                memcpy(p-&gtinit, &ampp-&gtbuf[p-&gtreadidx], 5);\newline            } else {\newline                /* the data is plain, just copy it verbatim to\newline                   the working block buffer */\newline                memcpy(block, &ampp-&gtbuf[p-&gtreadidx], blocksize);\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += blocksize;\newline\newline            /* we now have the initial blocksize bytes decrypted,\newline             * and we can extract packet and padding length from it\newline             */\newline            p-&gtpacket_length = _libssh2_ntohu32(block);\newline            if (p-&gtpacket_length &lt 1)\newline                return LIBSSH2_ERROR_DECRYPT;\newline\newline            p-&gtpadding_length = block[4];\newline\newline            /* total_num is the number of bytes following the initial\newline               (5 bytes) packet length and padding length fields */\newline            total_num =\newline                p-&gtpacket_length - 1 +\newline                (encrypted ? session-&gtremote.mac-&gtmac_len : 0);\newline\newline            /* RFC4253 section 6.1 Maximum Packet Length says:\newline             *\newline             * &quotAll implementations MUST be able to process\newline             * packets with uncompressed payload length of 32768\newline             * bytes or less and total packet size of 35000 bytes\newline             * or less (including length, padding length, payload,\newline             * padding, and MAC.).&quot\newline             */\newline            if (total_num &gt LIBSSH2_PACKET_MAXPAYLOAD) {\newline                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\newline            }\newline\newline            /* Get a packet handle put data into. We get one to\newline               hold all data, including padding and MAC. */\newline            p-&gtpayload = LIBSSH2_ALLOC(session, total_num);\newline            if (!p-&gtpayload) {\newline                return LIBSSH2_ERROR_ALLOC;\newline            }\newline            p-&gttotal_num = total_num;\newline            /* init write pointer to start of payload buffer */\newline            p-&gtwptr = p-&gtpayload;\newline\newline            if (blocksize &gt 5) {\newline                /* copy the data from index 5 to the end of\newline                   the blocksize from the temporary buffer to\newline                   the start of the decrypted buffer */\newline                memcpy(p-&gtwptr, &ampblock[5], blocksize - 5);\newline                p-&gtwptr += blocksize - 5;       /* advance write pointer */\newline            }\newline\newline            /* init the data_num field to the number of bytes of\newline               the package read so far */\newline            p-&gtdata_num = p-&gtwptr - p-&gtpayload;\newline\newline            /* we already dealt with a blocksize worth of data */\newline            numbytes -= blocksize;\newline        }\newline\newline        /* how much there is left to add to the current payload\newline           package */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (numbytes &gt remainpack) {\newline            /* if we have more data in the buffer than what is going into this\newline               particular packet, we limit this round to this packet only */\newline            numbytes = remainpack;\newline        }\newline\newline        if (encrypted) {\newline            /* At the end of the incoming stream, there is a MAC,\newline               and we don&#039t want to decrypt that since we need it\newline               &quotraw&quot. We MUST however decrypt the padding data\newline               since it is used for the hash later on. */\newline            int skip = session-&gtremote.mac-&gtmac_len;\newline\newline            /* if what we have plus numbytes is bigger than the\newline               total minus the skip margin, we should lower the\newline               amount to decrypt even more */\newline            if ((p-&gtdata_num + numbytes) &gt (p-&gttotal_num - skip)) {\newline                numdecrypt = (p-&gttotal_num - skip) - p-&gtdata_num;\newline            } else {\newline                int frac;\newline                numdecrypt = numbytes;\newline                frac = numdecrypt % blocksize;\newline                if (frac) {\newline                    /* not an aligned amount of blocks,\newline                       align it */\newline                    numdecrypt -= frac;\newline                    /* and make it no unencrypted data\newline                       after it */\newline                    numbytes = 0;\newline                }\newline            }\newline        } else {\newline            /* unencrypted data should not be decrypted at all */\newline            numdecrypt = 0;\newline        }\newline\newline        /* if there are bytes to decrypt, do that */\newline        if (numdecrypt &gt 0) {\newline            /* now decrypt the lot */\newline            rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], p-&gtwptr, numdecrypt);\newline            if (rc != LIBSSH2_ERROR_NONE) {\newline                p-&gttotal_num = 0;   /* no packet buffer available */\newline                return rc;\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numdecrypt;\newline            /* advance write pointer */\newline            p-&gtwptr += numdecrypt;\newline            /* increase data_num */\newline            p-&gtdata_num += numdecrypt;\newline\newline            /* bytes left to take care of without decryption */\newline            numbytes -= numdecrypt;\newline        }\newline\newline        /* if there are bytes to copy that aren&#039t decrypted, simply\newline           copy them as-is to the target buffer */\newline        if (numbytes &gt 0) {\newline            memcpy(p-&gtwptr, &ampp-&gtbuf[p-&gtreadidx], numbytes);\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numbytes;\newline            /* advance write pointer */\newline            p-&gtwptr += numbytes;\newline            /* increase data_num */\newline            p-&gtdata_num += numbytes;\newline        }\newline\newline        /* now check how much data there&#039s left to read to finish the\newline           current packet */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (!remainpack) {\newline            /* we have a full packet */\newline          libssh2_transport_read_point1:\newline            rc = fullpacket(session, encrypted);\newline            if (rc == LIBSSH2_ERROR_EAGAIN) {\newline\newline                if (session-&gtpackAdd_state != libssh2_NB_state_idle)\newline                {\newline                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\newline                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If that\newline                     * returns LIBSSH2_ERROR_EAGAIN but the packAdd_state is idle,\newline                     * then the packet has been added to the brigade, but some\newline                     * immediate action that was taken based on the packet\newline                     * type (such as key re-exchange) is not yet complete.\newline                     * Clear the way for a new packet to be read in.\newline                     */\newline                    session-&gtreadPack_encrypted = encrypted;\newline                    session-&gtreadPack_state = libssh2_NB_state_jump1;\newline                }\newline\newline                return rc;\newline            }\newline\newline            p-&gttotal_num = 0;   /* no packet buffer available */\newline\newline            return rc;\newline        }\newline    } while (1);                /* loop */\newline\newline    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\newline}\newline","\newline This function reads the binary stream as specified in chapter 6 of RFC4253\newline &quotThe Secure Shell (SSH) Transport Layer Protocol&quot\newline \newline DOES NOT call _libssh2_error() for ANY error case.\newline \newline","1480360","configdialog.cpp","void ConfigDialog::on_checkBoxAutoclear_clicked() {\newline  on_comboBoxClipboard_activated(1);\newline}\newline","\newline @brief ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked, update\newline state via ConfigDialog::on_comboBoxClipboard_activated\newline \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","encoded string","Pins the window","canvas margins","Find come attrbute in an attribute list.","zeroconf","return the OpenSSL hash algorithm associated with a specified JWT algorithm","adjust the end of the overlapped cue in the previous sample","Function to index a table.","! \returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.","convert radians to dms","Callback that toggles the orientation of the progress bar","The below function (mur_prev) is thread-safe","""The Secure Shell (SSH) Transport Layer Protocol""","ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked,","Multi_PollingTerminate","server_list.","tangent trigonometric function.","last event","webkit_web_navigation_action_get_button:","/bin/sh","1, 2, ..., RNG_M - 1"
"3D1TUISJWI0YC7XIQVTHLAFOB7WUIA","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3CN4LGXD5XON8TF159T3JD77I0Q4YP","A3GJDP8RBLUWTT","Approved","Wed Apr 17 12:01:41 PDT 2019","Wed Apr 17 12:11:17 PDT 2019","Fri Apr 19 12:11:17 PDT 2019","2019-04-19 19:11:21 UTC","","","576","100% (2/2)","100% (2/2)","100% (2/2)","4378774","fsck.c","static int digest_encode(const char *src, int len, char *dst)\newline{\newline	int i = 0, bits = 0, ac = 0;\newline	char *cp = dst;\newline\newline	while (i &lt len) {\newline		ac += (((unsigned char) src[i]) &lt&lt bits);\newline		bits += 8;\newline		do {\newline			*cp++ = lookup_table[ac &amp 0x3f];\newline			ac &gt&gt= 6;\newline			bits -= 6;\newline		} while (bits &gt= 6);\newline		i++;\newline	}\newline	if (bits)\newline		*cp++ = lookup_table[ac &amp 0x3f];\newline	*cp = 0;\newline	return cp - dst;\newline}\newline","\newline digest_encode() -\newline \newline Encodes the input digest using characters from the set [a-zA-Z0-9_+].\newline The encoded string is roughly 4/3 times the size of the input string.\newline \newline","5980191","mur_read_file.c","uint4 mur_prev(jnl_ctl_list *jctl, off_jnl_t dskaddr)\newline{\newline	off_jnl_t	buff_offset;\newline	uint4		status, partial_reclen;\newline	jrec_suffix	*suffix;\newline	mur_buff_desc_t	*swap_buff;\newline	boolean_t	good_suffix, good_prefix;\newline	mur_read_desc_t	*mur_desc;\newline\newline	mur_desc = jctl-&gtreg_ctl-&gtmur_desc;\newline	if (0 != dskaddr)\newline	{ /* read record at dskaddr */\newline		assert(dskaddr &lt jctl-&gteof_addr);\newline		assert(dskaddr &gt= JNL_HDR_LEN);\newline		if (dskaddr &gt= jctl-&gteof_addr || dskaddr &lt JNL_HDR_LEN)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotRequested offset out of range [prev]&quot));\newline			return (dskaddr &gt= jctl-&gteof_addr ? ERR_JNLREADEOF : ERR_JNLREADBOF);\newline		}\newline		assert(dskaddr == ROUND_UP2(dskaddr, JNL_REC_START_BNDRY)); /* dskaddr must be aligned at JNL_REC_START_BNDRY */\newline		MUR_FREAD_CANCEL(jctl, mur_desc, status);\newline		if (SS_NORMAL != status)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotCould not cancel prior read [prev]&quot), jctl-&gtstatus);\newline			return jctl-&gtstatus;\newline		}\newline		mur_desc-&gtbuff_index = 1;\newline		mur_desc-&gtcur_buff = &ampmur_desc-&gtseq_buff[mur_desc-&gtbuff_index];\newline		mur_desc-&gtsec_buff = &ampmur_desc-&gtseq_buff[1 - mur_desc-&gtbuff_index];\newline		mur_desc-&gtcur_buff-&gtdskaddr = ROUND_DOWN2(dskaddr, MUR_BUFF_SIZE);\newline		mur_desc-&gtcur_buff-&gtblen = MIN(MUR_BUFF_SIZE, jctl-&gteof_addr - mur_desc-&gtcur_buff-&gtdskaddr);\newline		buff_offset = dskaddr - mur_desc-&gtcur_buff-&gtdskaddr;\newline		assert(JREC_PREFIX_UPTO_LEN_SIZE &lt= mur_desc-&gtcur_buff-&gtblen - buff_offset);\newline			/* we rely on reading at least up to the record length field (forwptr) */\newline		if (SS_NORMAL != (status = mur_freadw(jctl, mur_desc-&gtcur_buff)))\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline					LEN_AND_LIT(&quotError from synchronous read into cur_buff [prev]&quot), status);\newline			return status;\newline		}\newline		mur_desc-&gtjnlrec = (jnl_record *)(mur_desc-&gtcur_buff-&gtbase + buff_offset);\newline		good_suffix = TRUE;\newline		if (FALSE != (good_prefix = IS_VALID_LEN_FROM_PREFIX(mur_desc-&gtjnlrec, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjreclen = mur_desc-&gtjnlrec-&gtprefix.forwptr;\newline			if (MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr)\newline			{ /* while we process the just read chunk, post a read for the immediately preceding chunk */\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline					   	LEN_AND_LIT(&quotCould not initiate read into sec_buff in [prev] (dskaddr &gt 0)&quot),\newline						status);\newline					return status;\newline				}\newline			} else\newline			{ /* we read the beginning MUR_BUFF_SIZE (or smaller) chunk from file, no previous chunk exists */\newline				assert(0 == mur_desc-&gtcur_buff-&gtdskaddr);\newline			}\newline			if (buff_offset + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gtblen)\newline			{ /* Journal record straddles MUR_BUFF_SIZE boundary, did not read the entire record, read what&#039s left into\newline			   * aux_buff2 which is located at the end of seq_buff[1], the current buffer */\newline				mur_desc-&gtaux_buff2.dskaddr = mur_desc-&gtcur_buff-&gtdskaddr + mur_desc-&gtcur_buff-&gtblen;\newline				mur_desc-&gtaux_buff2.blen = (buff_offset + mur_desc-&gtjreclen - mur_desc-&gtcur_buff-&gtblen);\newline				if (FALSE != (good_prefix =\newline					(jctl-&gteof_addr - mur_desc-&gtaux_buff2.dskaddr &gt= mur_desc-&gtaux_buff2.blen)))\newline				{\newline					if (SS_NORMAL != (status = mur_freadw(jctl, &ampmur_desc-&gtaux_buff2)))\newline					{\newline						gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3,\newline							jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, mur_desc-&gtaux_buff2.dskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError in synchronous read into aux_buff [prev]&quot), status);\newline						return status;\newline					}\newline				} else\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3,\newline						jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, dskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond end of file [prev] (dskaddr &gt 0)&quot));\newline					return ERR_JNLBADRECFMT;\newline				}\newline			}\newline		} /* end good_prefix */\newline	} else\newline	{ /* dskaddr == 0, locate the previous record in the buffer, reading from disk if necessary */\newline		assert(JNL_HDR_LEN &lt= jctl-&gtrec_offset);\newline		suffix = (jrec_suffix *)((char *)mur_desc-&gtjnlrec - JREC_SUFFIX_SIZE);\newline		/* ok to test with possibly invalid backptr, we test for validity below */\newline		if (((unsigned char *)suffix &gt mur_desc-&gtcur_buff-&gtbase)\newline			&amp&amp (((unsigned char *)mur_desc-&gtjnlrec - suffix-&gtbackptr) &gt= mur_desc-&gtcur_buff-&gtbase))\newline		{	/* prev record is contained completely in the current buffer */\newline			if ((0 == mur_desc-&gtbuff_index)\newline				&amp&amp ((unsigned char *)mur_desc-&gtjnlrec + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gttop)\newline				&amp&amp (0 &lt mur_desc-&gtcur_buff-&gtdskaddr)) /* end of rec in sec_buff and there is data to be read */\newline			{ /* we just finished processing the journal record that straddled seq_buff[0] and seq_buff[1],\newline			   * start read in the now free secondary buffer (seq_buff[1]) to overlap with processing */\newline				assert(MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr);\newline				assert(!mur_desc-&gtsec_buff-&gtread_in_progress);\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotCould not initiate read into sec_buff [prev] (dskaddr == 0)&quot), status);\newline					return status;\newline				}\newline			}\newline		} else\newline		{ /* prev record completely in sec_buff or overlaps cur_buff and sec_buff */\newline			if (0 == mur_desc-&gtbuff_index)\newline			{ /* copy partial record to just past the end of seq_buff[1], i.e., aux_seq_buff[1] to make the record\newline			   * available in contiguous memory */\newline				partial_reclen = (uint4)((unsigned char *)mur_desc-&gtjnlrec - mur_desc-&gtseq_buff[0].base);\newline				if (0 &lt partial_reclen)\newline					memcpy(mur_desc-&gtseq_buff[1].top, mur_desc-&gtseq_buff[0].base, partial_reclen);\newline				suffix = (jrec_suffix *)(mur_desc-&gtseq_buff[1].top + partial_reclen - JREC_SUFFIX_SIZE);\newline			}\newline			/* before switching the buffers, wait for completion of pending I/O */\newline			if (mur_desc-&gtsec_buff-&gtread_in_progress)\newline			{\newline				MUR_FREAD_WAIT(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError waiting for sec_buff read to complete [prev]&quot),\newline							status);\newline					return status;\newline				}\newline			}\newline			/* If possible, overlap I/O with processing, read into available buffer */\newline			if ((0 == mur_desc-&gtbuff_index || /* we just copied partial record (if any), OR */\newline			    (unsigned char *)mur_desc-&gtjnlrec == mur_desc-&gtcur_buff-&gtbase) /* we completely processed cur_buff */\newline				&amp&amp 0 &lt mur_desc-&gtsec_buff-&gtdskaddr) /* there is data to be read */\newline			{\newline				assert(mur_desc-&gtsec_buff-&gtdskaddr &gt= MUR_BUFF_SIZE);\newline				mur_desc-&gtcur_buff-&gtdskaddr = mur_desc-&gtsec_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtcur_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotCould not initiate read into cur_buff [prev]&quot), status);\newline					return status;\newline				}\newline			}\newline			/* Make the buffer that has data that was previously read current */\newline			mur_desc-&gtbuff_index = 1 - mur_desc-&gtbuff_index;\newline			swap_buff = mur_desc-&gtcur_buff;\newline			mur_desc-&gtcur_buff = mur_desc-&gtsec_buff;\newline			mur_desc-&gtsec_buff = swap_buff;\newline		}\newline		good_prefix = TRUE;\newline		if (FALSE != (good_suffix = IS_VALID_LEN_FROM_SUFFIX(suffix, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjnlrec = (jnl_record *)((char *)suffix + JREC_SUFFIX_SIZE - suffix-&gtbackptr);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &gt= mur_desc-&gtcur_buff-&gtbase);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &lt  mur_desc-&gtcur_buff-&gttop);\newline			mur_desc-&gtjreclen = suffix-&gtbackptr;\newline			if (jctl-&gtrec_offset &lt mur_desc-&gtjreclen + JNL_HDR_LEN)\newline			{\newline				gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, jctl-&gtrec_offset, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond beginning of file [prev]&quot));\newline				return ERR_JNLBADRECFMT;\newline			}\newline		}\newline	} /* end of dskaddr == 0 */\newline	if (good_prefix &amp&amp good_suffix &amp&amp IS_VALID_JNLREC(mur_desc-&gtjnlrec, jctl-&gtjfh))\newline		return SS_NORMAL;\newline	return ERR_JNLBADRECFMT;\newline}\newline","#GTM_THREAD_SAFE : The below function (mur_prev) is thread-safe \newline","3428267","ccid_usb.c","static void Multi_PollingTerminate(struct usbDevice_MultiSlot_Extension *msExt)\newline{\newline	struct libusb_transfer *transfer;\newline\newline	if (msExt &amp&amp !msExt-&gtterminated)\newline	{\newline		msExt-&gtterminated = TRUE;\newline\newline		transfer = usbDevice[msExt-&gtreader_index].polling_transfer;\newline\newline		if (transfer)\newline		{\newline			int ret;\newline\newline			ret = libusb_cancel_transfer(transfer);\newline			if (ret &lt 0)\newline				DEBUG_CRITICAL2(&quotlibusb_cancel_transfer failed: %d&quot, ret);\newline		}\newline	}\newline} /* Multi_PollingTerminate */\newline","\newline \newline Multi_PollingTerminate\newline \newline \newline","5830889","server.c","static void clearq(struct server_list *xx)\newline{\newline  struct server_list *x;\newline\newline  while (xx) {\newline    x = xx-&gtnext;\newline    if (xx-&gtname)\newline      nfree(xx-&gtname);\newline    if (xx-&gtpass)\newline      nfree(xx-&gtpass);\newline    if (xx-&gtrealname)\newline      nfree(xx-&gtrealname);\newline    nfree(xx);\newline    xx = x;\newline  }\newline}\newline","Clear out the given server_list.\newline \newline","1448774","check_inifcns.cpp","static unsigned inifcns_check_tan()\newline{\newline	unsigned result = 0;\newline	bool errorflag;\newline	\newline	// compare tan((q*Pi).evalf()) with tan(q*Pi).eval().evalf() at various\newline	// points.  E.g. if tan(Pi/12) returns something symbolic this should be\newline	// equal to 2-sqrt(3).  This routine will spot programming mistakes of \newline	// this kind:\newline	errorflag = false;\newline	ex argument;\newline	numeric epsilon(double(1e-8));\newline	for (int n=-340; n&lt=340; ++n) {\newline		if (!(n%30) &amp&amp (n%60))  // skip poles\newline			++n;\newline		argument = n*Pi/60;\newline		if (abs(tan(evalf(argument))-evalf(tan(argument)))&gtepsilon) {\newline			clog &lt&lt &quottan(&quot &lt&lt argument &lt&lt &quot) returns &quot\newline			     &lt&lt tan(argument) &lt&lt endl;\newline			errorflag = true;\newline		}\newline	}\newline	if (errorflag)\newline		++result;\newline	\newline	return result;\newline}\newline","Simple tests on the tangent trigonometric function. \newline","6038115","dmmain.c","static int display_close(void *handle, void *device)\newline{\newline    IMAGE *img = image_find(handle, device);\newline    if (img == NULL)\newline       return -1;\newline\newline    gsdll_poll(handle);\newline\newline    /* remove from list */\newline    if (img == first_image)\newline        first_image = img-&gtnext;\newline    else\newline    {\newline        IMAGE *tmp;\newline        for (tmp = first_image; tmp!=0; tmp=tmp-&gtnext)\newline        {\newline            if (img == tmp-&gtnext)\newline            tmp-&gtnext = img-&gtnext;\newline        }\newline    }\newline\newline    DisposePixMap(img-&gtpixmapHdl);   // need to go in doCloseWindow()\newline    DisposeWindow(img-&gtwindowRef);\newline\newline    free(img);\newline\newline    return 0;\newline}\newline","This is the last event from this device. \newline","812839","webkitwebnavigationaction.cpp","gint webkit_web_navigation_action_get_button(WebKitWebNavigationAction* navigationAction)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_WEB_NAVIGATION_ACTION(navigationAction), -1);\newline\newline    return navigationAction-&gtpriv-&gtbutton;\newline}\newline","\newline webkit_web_navigation_action_get_button:\newline @navigationAction: a #WebKitWebNavigationAction\newline \newline The GTK+ identifier for the mouse button used to click. Notice that GTK+ button values\newline are 1, 2 and 3 for left, middle and right buttons, so they are DOM button values +1. If the action was not\newline initiated by a mouse click the value will be -1.\newline \newline Return value: the mouse button used to click\newline \newline Since: 1.0.3\newline \newline","6362084","disks.cpp","int DiskEntry::sysCall(QString &amp completeCommand)\newline{\newline    if (readingSysStdErrOut || sysProc-&gtstate() == QProcess::Running )\newline        return -1;\newline\newline    sysStringErrOut=i18n(&quotCalled: %1\\n\\n&quot, completeCommand); // put the called command on ErrOut\newline    sysProc-&gtclearProgram();\newline\newline    //Split command and arguments to use the new API, otherwise it doesn&#039t work\newline    QTextStream tS(&ampcompleteCommand);\newline\newline    QString command;\newline    tS &gt&gt command;\newline\newline    QString tmp;\newline    QStringList args;\newline    while( !tS.atEnd() )\newline    {\newline        tS &gt&gt tmp;\newline        args &lt&lt tmp;\newline    }\newline\newline    sysProc-&gtsetProgram(command, args);\newline    sysProc-&gtstart();\newline\newline    if ( !sysProc-&gtwaitForStarted(-1) )\newline        qCCritical(KDF) &lt&lt i18n(&quotcould not execute %1&quot, command) ;\newline\newline    sysProc-&gtwaitForFinished(-1);\newline\newline    if (sysProc-&gtexitCode()!=0)\newline        emit sysCallError(this, sysProc-&gtexitStatus());\newline\newline    return (sysProc-&gtexitCode());\newline}\newline","\newline starts a command on the underlying system via /bin/sh\newline \newline","2726110","rnd.c","int32 rnd ()\newline{\newline  register long low, high, test;\newline\newline  high = rnd_seed / RNG_Q;\newline  low = rnd_seed % RNG_Q;\newline  test = RNG_A * low - RNG_R * high;\newline  if (test &gt 0)\newline    rnd_seed = test;\newline  else\newline    rnd_seed = test + RNG_M;\newline  return rnd_seed;\newline}\newline","returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 \newline","893020","script_functions.c","int c_pin_window(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotpin_window: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline		if (window) {\newline			wnck_window_pin(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Pins the window\newline \newline","6449222","qwt_plot.cpp","bool QwtPlot::eventFilter( QObject *object, QEvent *event )\newline{\newline    if ( object == d_data-&gtcanvas )\newline    {\newline        if ( event-&gttype() == QEvent::Resize )\newline        {\newline            updateCanvasMargins();\newline        }\newline        else if ( event-&gttype() == QEvent::ContentsRectChange )\newline        {\newline            updateLayout();\newline        }\newline    }\newline\newline    return QFrame::eventFilter( object, event );\newline}\newline","!\newline\\brief Event filter\newlineThe plot handles the following events for the canvas:\newline- QEvent::Resize\newlineThe canvas margins might depend on its size\newline- QEvent::ContentsRectChange\newlineThe layout needs to be recalculated\newline\\param object Object to be filtered\newline\\param event Event\newline\\return See QFrame::eventFilter()\newline\\sa updateCanvasMargins(), updateLayout()\newline \newline","2776384","msc.c","static const char *findAttrib(const struct MscAttribTag *attr, MscAttribType a)\newline{\newline    while(attr != NULL &amp&amp attr-&gttype != a)\newline    {\newline        attr = attr-&gtnext;\newline    }\newline\newline    if(attr != NULL)\newline    {\newline        return attr-&gtvalue;\newline    }\newline    else\newline    {\newline        return NULL;\newline    }\newline}\newline","Find come attrbute in an attribute list.\newline \newline \\param[in] attr Head of the linked list to search.\newline \\param[in] a The attribute type to find.\newline \\retval NULL If the attribute was not found or the passed list was NULL.\newline \newline","6582023","zeroconf.c","int dcc_zeroconf_add_hosts(struct dcc_hostdef **ret_list, int *ret_nhosts, int n_slots, struct dcc_hostdef **ret_prev) {\newline    char *host_file = NULL, *lock_file = NULL, *s = NULL;\newline    int lock_fd = -1, host_fd = -1;\newline    int fork_daemon = 0;\newline    int r = -1;\newline    char *dir;\newline    struct stat st;\newline\newline    if (get_zeroconf_dir(&ampdir) != 0) {\newline        rs_log_crit(&quotfailed to get zeroconf dir.\\n&quot);\newline        goto finish;\newline    }\newline\newline    lock_file = malloc(strlen(dir) + sizeof(&quot/lock&quot));\newline    assert(lock_file);\newline    sprintf(lock_file, &quot%s/lock&quot, dir);\newline\newline    host_file = malloc(strlen(dir) + sizeof(&quot/hosts&quot));\newline    assert(host_file);\newline    sprintf(host_file, &quot%s/hosts&quot, dir);\newline\newline    /* Open lock file */\newline    if ((lock_fd = open(lock_file, O_RDWR|O_CREAT, 0666)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, lock_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Try to lock the lock file */\newline    if (generic_lock(lock_fd, 1, 1, 0) &gt= 0) {\newline        /* The lock succeeded =&gt there&#039s no daemon running yet! */\newline        fork_daemon = 1;\newline        generic_lock(lock_fd, 1, 0, 0);\newline    }\newline\newline    close(lock_fd);\newline\newline    /* Shall we fork a new daemon? */\newline    if (fork_daemon) {\newline        pid_t pid;\newline\newline        rs_log_info(&quotSpawning zeroconf daemon.\\n&quot);\newline\newline        if ((pid = fork()) == -1) {\newline            rs_log_crit(&quotfork() failed: %s\\n&quot, strerror(errno));\newline            goto finish;\newline        } else if (pid == 0) {\newline            int fd;\newline            /* Child */\newline\newline            /* Close file descriptors and replace them by /dev/null */\newline            close(0);\newline            close(1);\newline            close(2);\newline            fd = open(&quot/dev/null&quot, O_RDWR);\newline            assert(fd == 0);\newline            fd = dup(0);\newline            assert(fd == 1);\newline            fd = dup(0);\newline            assert(fd == 2);\newline\newline#ifdef HAVE_SETSID\newline            setsid();\newline#endif\newline\newline            chdir(&quot/&quot);\newline            rs_add_logger(rs_logger_syslog, RS_LOG_DEBUG, NULL, 0);\newline            _exit(daemon_proc(host_file, lock_file, n_slots));\newline        }\newline\newline        /* Parent */\newline\newline        /* Wait some time for initial host gathering */\newline        usleep(1000000);         /* 1000 ms */\newline    }\newline\newline    /* Open host list read-only */\newline    if ((host_fd = open(host_file, O_RDONLY)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, host_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* A read lock */\newline    if (generic_lock(host_fd, 0, 1, 1) &lt 0) {\newline        rs_log_crit(&quotlock failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Get file size */\newline    if (fstat(host_fd, &ampst) &lt 0) {\newline        rs_log_crit(&quotstat() failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    if (st.st_size &gt= MAX_FILE_SIZE) {\newline        rs_log_crit(&quotfile too large.\\n&quot);\newline        goto finish;\newline    }\newline\newline    /* read file data */\newline    s = malloc((size_t) st.st_size+1);\newline    assert(s);\newline\newline    if (dcc_readx(host_fd, s, (size_t) st.st_size) != 0) {\newline        rs_log_crit(&quotfailed to read from file.\\n&quot);\newline        goto finish;\newline    }\newline    s[st.st_size] = 0;\newline\newline    /* Parse host data */\newline    if (dcc_parse_hosts(s, host_file, ret_list, ret_nhosts, ret_prev) != 0) {\newline        rs_log_crit(&quotfailed to parse host file.\\n&quot);\newline        goto finish;\newline    }\newline\newline    r = 0;\newline\newlinefinish:\newline    if (host_fd &gt= 0) {\newline        generic_lock(host_fd, 0, 0, 1);\newline        close(host_fd);\newline    }\newline\newline    free(lock_file);\newline    free(host_file);\newline    free(s);\newline\newline    return r;\newline}\newline","Get the host list from zeroconf \newline","2144342","jose.c","static char *oidc_jose_alg_to_openssl_digest(const char *alg) {\newline	if ((strcmp(alg, &quotRS256&quot) == 0) || (strcmp(alg, &quotPS256&quot) == 0)\newline			|| (strcmp(alg, &quotHS256&quot) == 0) || (strcmp(alg, &quotES256&quot) == 0)) {\newline		return &quotsha256&quot;\newline	}\newline	if ((strcmp(alg, &quotRS384&quot) == 0) || (strcmp(alg, &quotPS384&quot) == 0)\newline			|| (strcmp(alg, &quotHS384&quot) == 0) || (strcmp(alg, &quotES384&quot) == 0)) {\newline		return &quotsha384&quot;\newline	}\newline	if ((strcmp(alg, &quotRS512&quot) == 0) || (strcmp(alg, &quotPS512&quot) == 0)\newline			|| (strcmp(alg, &quotHS512&quot) == 0) || (strcmp(alg, &quotES512&quot) == 0)) {\newline		return &quotsha512&quot;\newline	}\newline	if (strcmp(alg, &quotNONE&quot) == 0) {\newline		return &quotNONE&quot;\newline	}\newline	return NULL;\newline}\newline","\newline return the OpenSSL hash algorithm associated with a specified JWT algorithm\newline \newline","3774541","webvtt.c","static GF_WebVTTCue *gf_webvtt_cue_split_at(GF_WebVTTCue *cue, GF_WebVTTTimestamp *time)\newline{\newline	GF_WebVTTCue *dup_cue;\newline\newline	cue-&gtsplit         = GF_TRUE;\newline	cue-&gtorig_start    = cue-&gtstart;\newline	cue-&gtorig_end      = cue-&gtend;\newline\newline	GF_SAFEALLOC(dup_cue, GF_WebVTTCue);\newline	dup_cue-&gtsplit          = GF_TRUE;\newline	dup_cue-&gtstart          = *time;\newline	dup_cue-&gtend            = cue-&gtend;\newline	dup_cue-&gtorig_start     = cue-&gtorig_start;\newline	dup_cue-&gtorig_end       = cue-&gtorig_end;\newline	dup_cue-&gtid             = gf_strdup((cue-&gtid ? cue-&gtid : &quot&quot));\newline	dup_cue-&gtsettings       = gf_strdup((cue-&gtsettings ? cue-&gtsettings : &quot&quot));\newline	dup_cue-&gttext           = gf_strdup((cue-&gttext ? cue-&gttext : &quot&quot));\newline\newline	cue-&gtend = *time;\newline	return dup_cue;\newline}\newline","adjust the end of the overlapped cue in the previous sample \newline","131765","lvm.c","const TObject *luaV_gettable (lua_State *L, StkId t) {\newline  Closure *tm;\newline  int tg;\newline  if (ttype(t) == LUA_TTABLE &amp&amp  /* `t&#039 is a table? */\newline      ((tg = hvalue(t)-&gthtag) == LUA_TTABLE ||  /* with default tag? */\newline        luaT_gettm(L, tg, TM_GETTABLE) == NULL)) { /* or no TM? */\newline    /* do a primitive get */\newline    const TObject *h = luaH_get(L, hvalue(t), L-&gttop-1);\newline    /* result is no nil or there is no `index&#039 tag method? */\newline    if (ttype(h) != LUA_TNIL || ((tm=luaT_gettm(L, tg, TM_INDEX)) == NULL))\newline      return h;  /* return result */\newline    /* else call `index&#039 tag method */\newline  }\newline  else {  /* try a `gettable&#039 tag method */\newline    tm = luaT_gettmbyObj(L, t, TM_GETTABLE);\newline  }\newline  if (tm != NULL) {  /* is there a tag method? */\newline    luaD_checkstack(L, 2);\newline    *(L-&gttop+1) = *(L-&gttop-1);  /* key */\newline    *L-&gttop = *t;  /* table */\newline    clvalue(L-&gttop-1) = tm;  /* tag method */\newline    ttype(L-&gttop-1) = LUA_TFUNCTION;\newline    L-&gttop += 2;\newline    luaD_call(L, L-&gttop - 3, 1);\newline    return L-&gttop - 1;  /* call result */\newline  }\newline  else {  /* no tag method */\newline    luaG_typeerror(L, t, &quotindex&quot);\newline    return NULL;  /* to avoid warnings */\newline  }\newline}\newline","\newline Function to index a table.\newline Receives the table at `t&#039 and the key at top.\newline \newline","3069061","nxsreader.cpp","NxsBlock *NxsReader::FindBlockByTitle(const BlockReaderList &amp chosenBlockList, const char *title, unsigned *nMatches)\newline	{\newline	BlockReaderList  found = FindAllBlocksByTitle(chosenBlockList, title);\newline\newline	if (found.empty())\newline		{\newline		if (nMatches)\newline			*nMatches = 0;\newline		return NULL;\newline		}\newline	if (nMatches)\newline		*nMatches = (unsigned)found.size();\newline	return (NxsBlock *) found.back();\newline	}\newline","! \\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.\newline In the event of ties, the most recently read block is returned.\newline If `title` is NULL, then any block is considered a match.\newline On output nMatches will be the number of matches (if `nMatches` is not NULL).\newline NULL will be returned if there are no matches.\newline \newline","4385305","utility.c","void ln_rad_to_dms (double radians, struct ln_dms *dms)\newline{\newline    double degrees = ln_rad_to_deg(radians);\newline    \newline    ln_deg_to_dms(degrees, dms);\newline}\newline","convert radians to dms \newline","1659570","progressbar.c","static void toggle_orientation( GtkWidget    *widget,\newline                                ProgressData *pdata )\newline{\newline  switch (gtk_progress_bar_get_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar))) {\newline  case GTK_PROGRESS_LEFT_TO_RIGHT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_RIGHT_TO_LEFT);\newline    break;\newline  case GTK_PROGRESS_RIGHT_TO_LEFT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_LEFT_TO_RIGHT);\newline    break;\newline  default:;\newline    /* do nothing */\newline  }\newline}\newline","Callback that toggles the orientation of the progress bar \newline","5758787","transport.c","int _libssh2_transport_read(LIBSSH2_SESSION * session)\newline{\newline    int rc;\newline    struct transportpacket *p = &ampsession-&gtpacket;\newline    int remainbuf;\newline    int remainpack;\newline    int numbytes;\newline    int numdecrypt;\newline    unsigned char block[MAX_BLOCKSIZE];\newline    int blocksize;\newline    int encrypted = 1;\newline    size_t total_num;\newline\newline    /* default clear the bit */\newline    session-&gtsocket_block_directions &amp= ~LIBSSH2_SESSION_BLOCK_INBOUND;\newline\newline    /*\newline     * All channels, systems, subsystems, etc eventually make it down here\newline     * when looking for more incoming data. If a key exchange is going on\newline     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\newline     * ONLY send key exchange related traffic. In non-blocking mode, there is\newline     * a chance to break out of the kex_exchange function with an EAGAIN\newline     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\newline     * active, then we must redirect to the key exchange. However, if\newline     * kex_exchange is active (as in it is the one that calls this execution\newline     * of packet_read, then don&#039t redirect, as that would be an infinite loop!\newline     */\newline\newline    if (session-&gtstate &amp LIBSSH2_STATE_EXCHANGING_KEYS &amp&amp\newline        !(session-&gtstate &amp LIBSSH2_STATE_KEX_ACTIVE)) {\newline\newline        /* Whoever wants a packet won&#039t get anything until the key re-exchange\newline         * is done!\newline         */\newline        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, &quotRedirecting into the&quot\newline                       &quot key re-exchange from _libssh2_transport_read&quot);\newline        rc = _libssh2_kex_exchange(session, 1, &ampsession-&gtstartup_key_state);\newline        if (rc)\newline            return rc;\newline    }\newline\newline    /*\newline     * =============================== NOTE ===============================\newline     * I know this is very ugly and not a really good use of &quotgoto&quot, but\newline     * this case statement would be even uglier to do it any other way\newline     */\newline    if (session-&gtreadPack_state == libssh2_NB_state_jump1) {\newline        session-&gtreadPack_state = libssh2_NB_state_idle;\newline        encrypted = session-&gtreadPack_encrypted;\newline        goto libssh2_transport_read_point1;\newline    }\newline\newline    do {\newline        if (session-&gtsocket_state == LIBSSH2_SOCKET_DISCONNECTED) {\newline            return LIBSSH2_ERROR_NONE;\newline        }\newline\newline        if (session-&gtstate &amp LIBSSH2_STATE_NEWKEYS) {\newline            blocksize = session-&gtremote.crypt-&gtblocksize;\newline        } else {\newline            encrypted = 0;      /* not encrypted */\newline            blocksize = 5;      /* not strictly true, but we can use 5 here to\newline                                   make the checks below work fine still */\newline        }\newline\newline        /* read/use a whole big chunk into a temporary area stored in\newline           the LIBSSH2_SESSION struct. We will decrypt data from that\newline           buffer into the packet buffer so this temp one doesn&#039t have\newline           to be able to keep a whole SSH packet, just be large enough\newline           so that we can read big chunks from the network layer. */\newline\newline        /* how much data there is remaining in the buffer to deal with\newline           before we should read more from the network */\newline        remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline\newline        /* if remainbuf turns negative we have a bad internal error */\newline        assert(remainbuf &gt= 0);\newline\newline        if (remainbuf &lt blocksize) {\newline            /* If we have less than a blocksize left, it is too\newline               little data to deal with, read more */\newline            ssize_t nread;\newline\newline            /* move any remainder to the start of the buffer so\newline               that we can do a full refill */\newline            if (remainbuf) {\newline                memmove(p-&gtbuf, &ampp-&gtbuf[p-&gtreadidx], remainbuf);\newline                p-&gtreadidx = 0;\newline                p-&gtwriteidx = remainbuf;\newline            } else {\newline                /* nothing to move, just zero the indexes */\newline                p-&gtreadidx = p-&gtwriteidx = 0;\newline            }\newline\newline            /* now read a big chunk from the network into the temp buffer */\newline            nread =\newline                LIBSSH2_RECV(session, &ampp-&gtbuf[remainbuf],\newline                              PACKETBUFSIZE - remainbuf,\newline                              LIBSSH2_SOCKET_RECV_FLAGS(session));\newline            if (nread &lt= 0) {\newline                /* check if this is due to EAGAIN and return the special\newline                   return code if so, error out normally otherwise */\newline                if ((nread &lt 0) &amp&amp (nread == -EAGAIN)) {\newline                    session-&gtsocket_block_directions |=\newline                        LIBSSH2_SESSION_BLOCK_INBOUND;\newline                    return LIBSSH2_ERROR_EAGAIN;\newline                }\newline                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                               &quotError recving %d bytes (got %d)&quot,\newline                               PACKETBUFSIZE - remainbuf, -nread);\newline                return LIBSSH2_ERROR_SOCKET_RECV;\newline            }\newline            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                           &quotRecved %d/%d bytes to %p+%d&quot, nread,\newline                           PACKETBUFSIZE - remainbuf, p-&gtbuf, remainbuf);\newline\newline            debugdump(session, &quotlibssh2_transport_read() raw&quot,\newline                      &ampp-&gtbuf[remainbuf], nread);\newline            /* advance write pointer */\newline            p-&gtwriteidx += nread;\newline\newline            /* update remainbuf counter */\newline            remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline        }\newline\newline        /* how much data to deal with from the buffer */\newline        numbytes = remainbuf;\newline\newline        if (!p-&gttotal_num) {\newline            /* No payload package area allocated yet. To know the\newline               size of this payload, we need to decrypt the first\newline               blocksize data. */\newline\newline            if (numbytes &lt blocksize) {\newline                /* we can&#039t act on anything less than blocksize, but this\newline                   check is only done for the initial block since once we have\newline                   got the start of a block we can in fact deal with fractions\newline                */\newline                session-&gtsocket_block_directions |=\newline                    LIBSSH2_SESSION_BLOCK_INBOUND;\newline                return LIBSSH2_ERROR_EAGAIN;\newline            }\newline\newline            if (encrypted) {\newline                rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], block, blocksize);\newline                if (rc != LIBSSH2_ERROR_NONE) {\newline                    return rc;\newline                }\newline                /* save the first 5 bytes of the decrypted package, to be\newline                   used in the hash calculation later down. */\newline                memcpy(p-&gtinit, &ampp-&gtbuf[p-&gtreadidx], 5);\newline            } else {\newline                /* the data is plain, just copy it verbatim to\newline                   the working block buffer */\newline                memcpy(block, &ampp-&gtbuf[p-&gtreadidx], blocksize);\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += blocksize;\newline\newline            /* we now have the initial blocksize bytes decrypted,\newline             * and we can extract packet and padding length from it\newline             */\newline            p-&gtpacket_length = _libssh2_ntohu32(block);\newline            if (p-&gtpacket_length &lt 1)\newline                return LIBSSH2_ERROR_DECRYPT;\newline\newline            p-&gtpadding_length = block[4];\newline\newline            /* total_num is the number of bytes following the initial\newline               (5 bytes) packet length and padding length fields */\newline            total_num =\newline                p-&gtpacket_length - 1 +\newline                (encrypted ? session-&gtremote.mac-&gtmac_len : 0);\newline\newline            /* RFC4253 section 6.1 Maximum Packet Length says:\newline             *\newline             * &quotAll implementations MUST be able to process\newline             * packets with uncompressed payload length of 32768\newline             * bytes or less and total packet size of 35000 bytes\newline             * or less (including length, padding length, payload,\newline             * padding, and MAC.).&quot\newline             */\newline            if (total_num &gt LIBSSH2_PACKET_MAXPAYLOAD) {\newline                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\newline            }\newline\newline            /* Get a packet handle put data into. We get one to\newline               hold all data, including padding and MAC. */\newline            p-&gtpayload = LIBSSH2_ALLOC(session, total_num);\newline            if (!p-&gtpayload) {\newline                return LIBSSH2_ERROR_ALLOC;\newline            }\newline            p-&gttotal_num = total_num;\newline            /* init write pointer to start of payload buffer */\newline            p-&gtwptr = p-&gtpayload;\newline\newline            if (blocksize &gt 5) {\newline                /* copy the data from index 5 to the end of\newline                   the blocksize from the temporary buffer to\newline                   the start of the decrypted buffer */\newline                memcpy(p-&gtwptr, &ampblock[5], blocksize - 5);\newline                p-&gtwptr += blocksize - 5;       /* advance write pointer */\newline            }\newline\newline            /* init the data_num field to the number of bytes of\newline               the package read so far */\newline            p-&gtdata_num = p-&gtwptr - p-&gtpayload;\newline\newline            /* we already dealt with a blocksize worth of data */\newline            numbytes -= blocksize;\newline        }\newline\newline        /* how much there is left to add to the current payload\newline           package */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (numbytes &gt remainpack) {\newline            /* if we have more data in the buffer than what is going into this\newline               particular packet, we limit this round to this packet only */\newline            numbytes = remainpack;\newline        }\newline\newline        if (encrypted) {\newline            /* At the end of the incoming stream, there is a MAC,\newline               and we don&#039t want to decrypt that since we need it\newline               &quotraw&quot. We MUST however decrypt the padding data\newline               since it is used for the hash later on. */\newline            int skip = session-&gtremote.mac-&gtmac_len;\newline\newline            /* if what we have plus numbytes is bigger than the\newline               total minus the skip margin, we should lower the\newline               amount to decrypt even more */\newline            if ((p-&gtdata_num + numbytes) &gt (p-&gttotal_num - skip)) {\newline                numdecrypt = (p-&gttotal_num - skip) - p-&gtdata_num;\newline            } else {\newline                int frac;\newline                numdecrypt = numbytes;\newline                frac = numdecrypt % blocksize;\newline                if (frac) {\newline                    /* not an aligned amount of blocks,\newline                       align it */\newline                    numdecrypt -= frac;\newline                    /* and make it no unencrypted data\newline                       after it */\newline                    numbytes = 0;\newline                }\newline            }\newline        } else {\newline            /* unencrypted data should not be decrypted at all */\newline            numdecrypt = 0;\newline        }\newline\newline        /* if there are bytes to decrypt, do that */\newline        if (numdecrypt &gt 0) {\newline            /* now decrypt the lot */\newline            rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], p-&gtwptr, numdecrypt);\newline            if (rc != LIBSSH2_ERROR_NONE) {\newline                p-&gttotal_num = 0;   /* no packet buffer available */\newline                return rc;\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numdecrypt;\newline            /* advance write pointer */\newline            p-&gtwptr += numdecrypt;\newline            /* increase data_num */\newline            p-&gtdata_num += numdecrypt;\newline\newline            /* bytes left to take care of without decryption */\newline            numbytes -= numdecrypt;\newline        }\newline\newline        /* if there are bytes to copy that aren&#039t decrypted, simply\newline           copy them as-is to the target buffer */\newline        if (numbytes &gt 0) {\newline            memcpy(p-&gtwptr, &ampp-&gtbuf[p-&gtreadidx], numbytes);\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numbytes;\newline            /* advance write pointer */\newline            p-&gtwptr += numbytes;\newline            /* increase data_num */\newline            p-&gtdata_num += numbytes;\newline        }\newline\newline        /* now check how much data there&#039s left to read to finish the\newline           current packet */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (!remainpack) {\newline            /* we have a full packet */\newline          libssh2_transport_read_point1:\newline            rc = fullpacket(session, encrypted);\newline            if (rc == LIBSSH2_ERROR_EAGAIN) {\newline\newline                if (session-&gtpackAdd_state != libssh2_NB_state_idle)\newline                {\newline                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\newline                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If that\newline                     * returns LIBSSH2_ERROR_EAGAIN but the packAdd_state is idle,\newline                     * then the packet has been added to the brigade, but some\newline                     * immediate action that was taken based on the packet\newline                     * type (such as key re-exchange) is not yet complete.\newline                     * Clear the way for a new packet to be read in.\newline                     */\newline                    session-&gtreadPack_encrypted = encrypted;\newline                    session-&gtreadPack_state = libssh2_NB_state_jump1;\newline                }\newline\newline                return rc;\newline            }\newline\newline            p-&gttotal_num = 0;   /* no packet buffer available */\newline\newline            return rc;\newline        }\newline    } while (1);                /* loop */\newline\newline    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\newline}\newline","\newline This function reads the binary stream as specified in chapter 6 of RFC4253\newline &quotThe Secure Shell (SSH) Transport Layer Protocol&quot\newline \newline DOES NOT call _libssh2_error() for ANY error case.\newline \newline","1480360","configdialog.cpp","void ConfigDialog::on_checkBoxAutoclear_clicked() {\newline  on_comboBoxClipboard_activated(1);\newline}\newline","\newline @brief ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked, update\newline state via ConfigDialog::on_comboBoxClipboard_activated\newline \newline","","","","","","","","","","","","on","","","on","","","on","","","","","","on","","","","","","","","","","on","","","","","","on","","","Encodes the input digest using characters","Pins the window","The plot handles the following events for the canvas:","Find come attrbute in an attribute list.","Get the host list from zeroconf","return the OpenSSL hash algorithm associated with a specified JWT algorithm","adjust the end of the overlapped cue in the previous sample","Function to index a table.","\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.","convert","Callback","{}","This function reads the binary stream","update state via ConfigDialog::on_comboBoxClipboard_activated","{}","Clear out the given server_list.","Simple tests on the tangent trigonometric function.","{}","Return value: the mouse button used to click","starts a command on the underlying system via /bin/sh","returns a pseudo-random number"
"3D1TUISJWI0YC7XIQVTHLAFOB7WUIA","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3WI0P0II61SRBOM8KP22EL8GSQ9RDS","A32ILJI1G0IXOQ","Approved","Wed Apr 17 12:31:20 PDT 2019","Wed Apr 17 12:39:55 PDT 2019","Fri Apr 19 12:39:55 PDT 2019","2019-04-19 19:40:21 UTC","","","515","100% (1/1)","100% (1/1)","100% (1/1)","4378774","fsck.c","static int digest_encode(const char *src, int len, char *dst)\newline{\newline	int i = 0, bits = 0, ac = 0;\newline	char *cp = dst;\newline\newline	while (i &lt len) {\newline		ac += (((unsigned char) src[i]) &lt&lt bits);\newline		bits += 8;\newline		do {\newline			*cp++ = lookup_table[ac &amp 0x3f];\newline			ac &gt&gt= 6;\newline			bits -= 6;\newline		} while (bits &gt= 6);\newline		i++;\newline	}\newline	if (bits)\newline		*cp++ = lookup_table[ac &amp 0x3f];\newline	*cp = 0;\newline	return cp - dst;\newline}\newline","\newline digest_encode() -\newline \newline Encodes the input digest using characters from the set [a-zA-Z0-9_+].\newline The encoded string is roughly 4/3 times the size of the input string.\newline \newline","5980191","mur_read_file.c","uint4 mur_prev(jnl_ctl_list *jctl, off_jnl_t dskaddr)\newline{\newline	off_jnl_t	buff_offset;\newline	uint4		status, partial_reclen;\newline	jrec_suffix	*suffix;\newline	mur_buff_desc_t	*swap_buff;\newline	boolean_t	good_suffix, good_prefix;\newline	mur_read_desc_t	*mur_desc;\newline\newline	mur_desc = jctl-&gtreg_ctl-&gtmur_desc;\newline	if (0 != dskaddr)\newline	{ /* read record at dskaddr */\newline		assert(dskaddr &lt jctl-&gteof_addr);\newline		assert(dskaddr &gt= JNL_HDR_LEN);\newline		if (dskaddr &gt= jctl-&gteof_addr || dskaddr &lt JNL_HDR_LEN)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotRequested offset out of range [prev]&quot));\newline			return (dskaddr &gt= jctl-&gteof_addr ? ERR_JNLREADEOF : ERR_JNLREADBOF);\newline		}\newline		assert(dskaddr == ROUND_UP2(dskaddr, JNL_REC_START_BNDRY)); /* dskaddr must be aligned at JNL_REC_START_BNDRY */\newline		MUR_FREAD_CANCEL(jctl, mur_desc, status);\newline		if (SS_NORMAL != status)\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					dskaddr, ERR_TEXT, 2, LEN_AND_LIT(&quotCould not cancel prior read [prev]&quot), jctl-&gtstatus);\newline			return jctl-&gtstatus;\newline		}\newline		mur_desc-&gtbuff_index = 1;\newline		mur_desc-&gtcur_buff = &ampmur_desc-&gtseq_buff[mur_desc-&gtbuff_index];\newline		mur_desc-&gtsec_buff = &ampmur_desc-&gtseq_buff[1 - mur_desc-&gtbuff_index];\newline		mur_desc-&gtcur_buff-&gtdskaddr = ROUND_DOWN2(dskaddr, MUR_BUFF_SIZE);\newline		mur_desc-&gtcur_buff-&gtblen = MIN(MUR_BUFF_SIZE, jctl-&gteof_addr - mur_desc-&gtcur_buff-&gtdskaddr);\newline		buff_offset = dskaddr - mur_desc-&gtcur_buff-&gtdskaddr;\newline		assert(JREC_PREFIX_UPTO_LEN_SIZE &lt= mur_desc-&gtcur_buff-&gtblen - buff_offset);\newline			/* we rely on reading at least up to the record length field (forwptr) */\newline		if (SS_NORMAL != (status = mur_freadw(jctl, mur_desc-&gtcur_buff)))\newline		{\newline			gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len, jctl-&gtjnl_fn,\newline					mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline					LEN_AND_LIT(&quotError from synchronous read into cur_buff [prev]&quot), status);\newline			return status;\newline		}\newline		mur_desc-&gtjnlrec = (jnl_record *)(mur_desc-&gtcur_buff-&gtbase + buff_offset);\newline		good_suffix = TRUE;\newline		if (FALSE != (good_prefix = IS_VALID_LEN_FROM_PREFIX(mur_desc-&gtjnlrec, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjreclen = mur_desc-&gtjnlrec-&gtprefix.forwptr;\newline			if (MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr)\newline			{ /* while we process the just read chunk, post a read for the immediately preceding chunk */\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline					   	LEN_AND_LIT(&quotCould not initiate read into sec_buff in [prev] (dskaddr &gt 0)&quot),\newline						status);\newline					return status;\newline				}\newline			} else\newline			{ /* we read the beginning MUR_BUFF_SIZE (or smaller) chunk from file, no previous chunk exists */\newline				assert(0 == mur_desc-&gtcur_buff-&gtdskaddr);\newline			}\newline			if (buff_offset + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gtblen)\newline			{ /* Journal record straddles MUR_BUFF_SIZE boundary, did not read the entire record, read what&#039s left into\newline			   * aux_buff2 which is located at the end of seq_buff[1], the current buffer */\newline				mur_desc-&gtaux_buff2.dskaddr = mur_desc-&gtcur_buff-&gtdskaddr + mur_desc-&gtcur_buff-&gtblen;\newline				mur_desc-&gtaux_buff2.blen = (buff_offset + mur_desc-&gtjreclen - mur_desc-&gtcur_buff-&gtblen);\newline				if (FALSE != (good_prefix =\newline					(jctl-&gteof_addr - mur_desc-&gtaux_buff2.dskaddr &gt= mur_desc-&gtaux_buff2.blen)))\newline				{\newline					if (SS_NORMAL != (status = mur_freadw(jctl, &ampmur_desc-&gtaux_buff2)))\newline					{\newline						gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3,\newline							jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, mur_desc-&gtaux_buff2.dskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError in synchronous read into aux_buff [prev]&quot), status);\newline						return status;\newline					}\newline				} else\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3,\newline						jctl-&gtjnl_fn_len, jctl-&gtjnl_fn, dskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond end of file [prev] (dskaddr &gt 0)&quot));\newline					return ERR_JNLBADRECFMT;\newline				}\newline			}\newline		} /* end good_prefix */\newline	} else\newline	{ /* dskaddr == 0, locate the previous record in the buffer, reading from disk if necessary */\newline		assert(JNL_HDR_LEN &lt= jctl-&gtrec_offset);\newline		suffix = (jrec_suffix *)((char *)mur_desc-&gtjnlrec - JREC_SUFFIX_SIZE);\newline		/* ok to test with possibly invalid backptr, we test for validity below */\newline		if (((unsigned char *)suffix &gt mur_desc-&gtcur_buff-&gtbase)\newline			&amp&amp (((unsigned char *)mur_desc-&gtjnlrec - suffix-&gtbackptr) &gt= mur_desc-&gtcur_buff-&gtbase))\newline		{	/* prev record is contained completely in the current buffer */\newline			if ((0 == mur_desc-&gtbuff_index)\newline				&amp&amp ((unsigned char *)mur_desc-&gtjnlrec + mur_desc-&gtjreclen &gt mur_desc-&gtcur_buff-&gttop)\newline				&amp&amp (0 &lt mur_desc-&gtcur_buff-&gtdskaddr)) /* end of rec in sec_buff and there is data to be read */\newline			{ /* we just finished processing the journal record that straddled seq_buff[0] and seq_buff[1],\newline			   * start read in the now free secondary buffer (seq_buff[1]) to overlap with processing */\newline				assert(MUR_BUFF_SIZE &lt= mur_desc-&gtcur_buff-&gtdskaddr);\newline				assert(!mur_desc-&gtsec_buff-&gtread_in_progress);\newline				mur_desc-&gtsec_buff-&gtdskaddr = mur_desc-&gtcur_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotCould not initiate read into sec_buff [prev] (dskaddr == 0)&quot), status);\newline					return status;\newline				}\newline			}\newline		} else\newline		{ /* prev record completely in sec_buff or overlaps cur_buff and sec_buff */\newline			if (0 == mur_desc-&gtbuff_index)\newline			{ /* copy partial record to just past the end of seq_buff[1], i.e., aux_seq_buff[1] to make the record\newline			   * available in contiguous memory */\newline				partial_reclen = (uint4)((unsigned char *)mur_desc-&gtjnlrec - mur_desc-&gtseq_buff[0].base);\newline				if (0 &lt partial_reclen)\newline					memcpy(mur_desc-&gtseq_buff[1].top, mur_desc-&gtseq_buff[0].base, partial_reclen);\newline				suffix = (jrec_suffix *)(mur_desc-&gtseq_buff[1].top + partial_reclen - JREC_SUFFIX_SIZE);\newline			}\newline			/* before switching the buffers, wait for completion of pending I/O */\newline			if (mur_desc-&gtsec_buff-&gtread_in_progress)\newline			{\newline				MUR_FREAD_WAIT(jctl, mur_desc-&gtsec_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtsec_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotError waiting for sec_buff read to complete [prev]&quot),\newline							status);\newline					return status;\newline				}\newline			}\newline			/* If possible, overlap I/O with processing, read into available buffer */\newline			if ((0 == mur_desc-&gtbuff_index || /* we just copied partial record (if any), OR */\newline			    (unsigned char *)mur_desc-&gtjnlrec == mur_desc-&gtcur_buff-&gtbase) /* we completely processed cur_buff */\newline				&amp&amp 0 &lt mur_desc-&gtsec_buff-&gtdskaddr) /* there is data to be read */\newline			{\newline				assert(mur_desc-&gtsec_buff-&gtdskaddr &gt= MUR_BUFF_SIZE);\newline				mur_desc-&gtcur_buff-&gtdskaddr = mur_desc-&gtsec_buff-&gtdskaddr - MUR_BUFF_SIZE;\newline				MUR_FREAD_START(jctl, mur_desc-&gtcur_buff, status);\newline				if (SS_NORMAL != status)\newline				{\newline					gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(10) ERR_JNLREAD, 3, jctl-&gtjnl_fn_len,\newline							jctl-&gtjnl_fn, mur_desc-&gtcur_buff-&gtdskaddr, ERR_TEXT, 2,\newline							LEN_AND_LIT(&quotCould not initiate read into cur_buff [prev]&quot), status);\newline					return status;\newline				}\newline			}\newline			/* Make the buffer that has data that was previously read current */\newline			mur_desc-&gtbuff_index = 1 - mur_desc-&gtbuff_index;\newline			swap_buff = mur_desc-&gtcur_buff;\newline			mur_desc-&gtcur_buff = mur_desc-&gtsec_buff;\newline			mur_desc-&gtsec_buff = swap_buff;\newline		}\newline		good_prefix = TRUE;\newline		if (FALSE != (good_suffix = IS_VALID_LEN_FROM_SUFFIX(suffix, jctl-&gtjfh)))\newline		{\newline			mur_desc-&gtjnlrec = (jnl_record *)((char *)suffix + JREC_SUFFIX_SIZE - suffix-&gtbackptr);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &gt= mur_desc-&gtcur_buff-&gtbase);\newline			assert((unsigned char *)mur_desc-&gtjnlrec &lt  mur_desc-&gtcur_buff-&gttop);\newline			mur_desc-&gtjreclen = suffix-&gtbackptr;\newline			if (jctl-&gtrec_offset &lt mur_desc-&gtjreclen + JNL_HDR_LEN)\newline			{\newline				gtm_putmsg_csa(CSA_ARG(JCTL2CSA(jctl)) VARLSTCNT(9) ERR_JNLUNXPCTERR, 3, jctl-&gtjnl_fn_len,\newline						jctl-&gtjnl_fn, jctl-&gtrec_offset, ERR_TEXT, 2,\newline						LEN_AND_LIT(&quotRequested offset beyond beginning of file [prev]&quot));\newline				return ERR_JNLBADRECFMT;\newline			}\newline		}\newline	} /* end of dskaddr == 0 */\newline	if (good_prefix &amp&amp good_suffix &amp&amp IS_VALID_JNLREC(mur_desc-&gtjnlrec, jctl-&gtjfh))\newline		return SS_NORMAL;\newline	return ERR_JNLBADRECFMT;\newline}\newline","#GTM_THREAD_SAFE : The below function (mur_prev) is thread-safe \newline","3428267","ccid_usb.c","static void Multi_PollingTerminate(struct usbDevice_MultiSlot_Extension *msExt)\newline{\newline	struct libusb_transfer *transfer;\newline\newline	if (msExt &amp&amp !msExt-&gtterminated)\newline	{\newline		msExt-&gtterminated = TRUE;\newline\newline		transfer = usbDevice[msExt-&gtreader_index].polling_transfer;\newline\newline		if (transfer)\newline		{\newline			int ret;\newline\newline			ret = libusb_cancel_transfer(transfer);\newline			if (ret &lt 0)\newline				DEBUG_CRITICAL2(&quotlibusb_cancel_transfer failed: %d&quot, ret);\newline		}\newline	}\newline} /* Multi_PollingTerminate */\newline","\newline \newline Multi_PollingTerminate\newline \newline \newline","5830889","server.c","static void clearq(struct server_list *xx)\newline{\newline  struct server_list *x;\newline\newline  while (xx) {\newline    x = xx-&gtnext;\newline    if (xx-&gtname)\newline      nfree(xx-&gtname);\newline    if (xx-&gtpass)\newline      nfree(xx-&gtpass);\newline    if (xx-&gtrealname)\newline      nfree(xx-&gtrealname);\newline    nfree(xx);\newline    xx = x;\newline  }\newline}\newline","Clear out the given server_list.\newline \newline","1448774","check_inifcns.cpp","static unsigned inifcns_check_tan()\newline{\newline	unsigned result = 0;\newline	bool errorflag;\newline	\newline	// compare tan((q*Pi).evalf()) with tan(q*Pi).eval().evalf() at various\newline	// points.  E.g. if tan(Pi/12) returns something symbolic this should be\newline	// equal to 2-sqrt(3).  This routine will spot programming mistakes of \newline	// this kind:\newline	errorflag = false;\newline	ex argument;\newline	numeric epsilon(double(1e-8));\newline	for (int n=-340; n&lt=340; ++n) {\newline		if (!(n%30) &amp&amp (n%60))  // skip poles\newline			++n;\newline		argument = n*Pi/60;\newline		if (abs(tan(evalf(argument))-evalf(tan(argument)))&gtepsilon) {\newline			clog &lt&lt &quottan(&quot &lt&lt argument &lt&lt &quot) returns &quot\newline			     &lt&lt tan(argument) &lt&lt endl;\newline			errorflag = true;\newline		}\newline	}\newline	if (errorflag)\newline		++result;\newline	\newline	return result;\newline}\newline","Simple tests on the tangent trigonometric function. \newline","6038115","dmmain.c","static int display_close(void *handle, void *device)\newline{\newline    IMAGE *img = image_find(handle, device);\newline    if (img == NULL)\newline       return -1;\newline\newline    gsdll_poll(handle);\newline\newline    /* remove from list */\newline    if (img == first_image)\newline        first_image = img-&gtnext;\newline    else\newline    {\newline        IMAGE *tmp;\newline        for (tmp = first_image; tmp!=0; tmp=tmp-&gtnext)\newline        {\newline            if (img == tmp-&gtnext)\newline            tmp-&gtnext = img-&gtnext;\newline        }\newline    }\newline\newline    DisposePixMap(img-&gtpixmapHdl);   // need to go in doCloseWindow()\newline    DisposeWindow(img-&gtwindowRef);\newline\newline    free(img);\newline\newline    return 0;\newline}\newline","This is the last event from this device. \newline","812839","webkitwebnavigationaction.cpp","gint webkit_web_navigation_action_get_button(WebKitWebNavigationAction* navigationAction)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_WEB_NAVIGATION_ACTION(navigationAction), -1);\newline\newline    return navigationAction-&gtpriv-&gtbutton;\newline}\newline","\newline webkit_web_navigation_action_get_button:\newline @navigationAction: a #WebKitWebNavigationAction\newline \newline The GTK+ identifier for the mouse button used to click. Notice that GTK+ button values\newline are 1, 2 and 3 for left, middle and right buttons, so they are DOM button values +1. If the action was not\newline initiated by a mouse click the value will be -1.\newline \newline Return value: the mouse button used to click\newline \newline Since: 1.0.3\newline \newline","6362084","disks.cpp","int DiskEntry::sysCall(QString &amp completeCommand)\newline{\newline    if (readingSysStdErrOut || sysProc-&gtstate() == QProcess::Running )\newline        return -1;\newline\newline    sysStringErrOut=i18n(&quotCalled: %1\\n\\n&quot, completeCommand); // put the called command on ErrOut\newline    sysProc-&gtclearProgram();\newline\newline    //Split command and arguments to use the new API, otherwise it doesn&#039t work\newline    QTextStream tS(&ampcompleteCommand);\newline\newline    QString command;\newline    tS &gt&gt command;\newline\newline    QString tmp;\newline    QStringList args;\newline    while( !tS.atEnd() )\newline    {\newline        tS &gt&gt tmp;\newline        args &lt&lt tmp;\newline    }\newline\newline    sysProc-&gtsetProgram(command, args);\newline    sysProc-&gtstart();\newline\newline    if ( !sysProc-&gtwaitForStarted(-1) )\newline        qCCritical(KDF) &lt&lt i18n(&quotcould not execute %1&quot, command) ;\newline\newline    sysProc-&gtwaitForFinished(-1);\newline\newline    if (sysProc-&gtexitCode()!=0)\newline        emit sysCallError(this, sysProc-&gtexitStatus());\newline\newline    return (sysProc-&gtexitCode());\newline}\newline","\newline starts a command on the underlying system via /bin/sh\newline \newline","2726110","rnd.c","int32 rnd ()\newline{\newline  register long low, high, test;\newline\newline  high = rnd_seed / RNG_Q;\newline  low = rnd_seed % RNG_Q;\newline  test = RNG_A * low - RNG_R * high;\newline  if (test &gt 0)\newline    rnd_seed = test;\newline  else\newline    rnd_seed = test + RNG_M;\newline  return rnd_seed;\newline}\newline","returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 \newline","893020","script_functions.c","int c_pin_window(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotpin_window: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline		if (window) {\newline			wnck_window_pin(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline","\newline Pins the window\newline \newline","6449222","qwt_plot.cpp","bool QwtPlot::eventFilter( QObject *object, QEvent *event )\newline{\newline    if ( object == d_data-&gtcanvas )\newline    {\newline        if ( event-&gttype() == QEvent::Resize )\newline        {\newline            updateCanvasMargins();\newline        }\newline        else if ( event-&gttype() == QEvent::ContentsRectChange )\newline        {\newline            updateLayout();\newline        }\newline    }\newline\newline    return QFrame::eventFilter( object, event );\newline}\newline","!\newline\\brief Event filter\newlineThe plot handles the following events for the canvas:\newline- QEvent::Resize\newlineThe canvas margins might depend on its size\newline- QEvent::ContentsRectChange\newlineThe layout needs to be recalculated\newline\\param object Object to be filtered\newline\\param event Event\newline\\return See QFrame::eventFilter()\newline\\sa updateCanvasMargins(), updateLayout()\newline \newline","2776384","msc.c","static const char *findAttrib(const struct MscAttribTag *attr, MscAttribType a)\newline{\newline    while(attr != NULL &amp&amp attr-&gttype != a)\newline    {\newline        attr = attr-&gtnext;\newline    }\newline\newline    if(attr != NULL)\newline    {\newline        return attr-&gtvalue;\newline    }\newline    else\newline    {\newline        return NULL;\newline    }\newline}\newline","Find come attrbute in an attribute list.\newline \newline \\param[in] attr Head of the linked list to search.\newline \\param[in] a The attribute type to find.\newline \\retval NULL If the attribute was not found or the passed list was NULL.\newline \newline","6582023","zeroconf.c","int dcc_zeroconf_add_hosts(struct dcc_hostdef **ret_list, int *ret_nhosts, int n_slots, struct dcc_hostdef **ret_prev) {\newline    char *host_file = NULL, *lock_file = NULL, *s = NULL;\newline    int lock_fd = -1, host_fd = -1;\newline    int fork_daemon = 0;\newline    int r = -1;\newline    char *dir;\newline    struct stat st;\newline\newline    if (get_zeroconf_dir(&ampdir) != 0) {\newline        rs_log_crit(&quotfailed to get zeroconf dir.\\n&quot);\newline        goto finish;\newline    }\newline\newline    lock_file = malloc(strlen(dir) + sizeof(&quot/lock&quot));\newline    assert(lock_file);\newline    sprintf(lock_file, &quot%s/lock&quot, dir);\newline\newline    host_file = malloc(strlen(dir) + sizeof(&quot/hosts&quot));\newline    assert(host_file);\newline    sprintf(host_file, &quot%s/hosts&quot, dir);\newline\newline    /* Open lock file */\newline    if ((lock_fd = open(lock_file, O_RDWR|O_CREAT, 0666)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, lock_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Try to lock the lock file */\newline    if (generic_lock(lock_fd, 1, 1, 0) &gt= 0) {\newline        /* The lock succeeded =&gt there&#039s no daemon running yet! */\newline        fork_daemon = 1;\newline        generic_lock(lock_fd, 1, 0, 0);\newline    }\newline\newline    close(lock_fd);\newline\newline    /* Shall we fork a new daemon? */\newline    if (fork_daemon) {\newline        pid_t pid;\newline\newline        rs_log_info(&quotSpawning zeroconf daemon.\\n&quot);\newline\newline        if ((pid = fork()) == -1) {\newline            rs_log_crit(&quotfork() failed: %s\\n&quot, strerror(errno));\newline            goto finish;\newline        } else if (pid == 0) {\newline            int fd;\newline            /* Child */\newline\newline            /* Close file descriptors and replace them by /dev/null */\newline            close(0);\newline            close(1);\newline            close(2);\newline            fd = open(&quot/dev/null&quot, O_RDWR);\newline            assert(fd == 0);\newline            fd = dup(0);\newline            assert(fd == 1);\newline            fd = dup(0);\newline            assert(fd == 2);\newline\newline#ifdef HAVE_SETSID\newline            setsid();\newline#endif\newline\newline            chdir(&quot/&quot);\newline            rs_add_logger(rs_logger_syslog, RS_LOG_DEBUG, NULL, 0);\newline            _exit(daemon_proc(host_file, lock_file, n_slots));\newline        }\newline\newline        /* Parent */\newline\newline        /* Wait some time for initial host gathering */\newline        usleep(1000000);         /* 1000 ms */\newline    }\newline\newline    /* Open host list read-only */\newline    if ((host_fd = open(host_file, O_RDONLY)) &lt 0) {\newline        rs_log_crit(&quotopen(&#039%s&#039) failed: %s\\n&quot, host_file, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* A read lock */\newline    if (generic_lock(host_fd, 0, 1, 1) &lt 0) {\newline        rs_log_crit(&quotlock failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    /* Get file size */\newline    if (fstat(host_fd, &ampst) &lt 0) {\newline        rs_log_crit(&quotstat() failed: %s\\n&quot, strerror(errno));\newline        goto finish;\newline    }\newline\newline    if (st.st_size &gt= MAX_FILE_SIZE) {\newline        rs_log_crit(&quotfile too large.\\n&quot);\newline        goto finish;\newline    }\newline\newline    /* read file data */\newline    s = malloc((size_t) st.st_size+1);\newline    assert(s);\newline\newline    if (dcc_readx(host_fd, s, (size_t) st.st_size) != 0) {\newline        rs_log_crit(&quotfailed to read from file.\\n&quot);\newline        goto finish;\newline    }\newline    s[st.st_size] = 0;\newline\newline    /* Parse host data */\newline    if (dcc_parse_hosts(s, host_file, ret_list, ret_nhosts, ret_prev) != 0) {\newline        rs_log_crit(&quotfailed to parse host file.\\n&quot);\newline        goto finish;\newline    }\newline\newline    r = 0;\newline\newlinefinish:\newline    if (host_fd &gt= 0) {\newline        generic_lock(host_fd, 0, 0, 1);\newline        close(host_fd);\newline    }\newline\newline    free(lock_file);\newline    free(host_file);\newline    free(s);\newline\newline    return r;\newline}\newline","Get the host list from zeroconf \newline","2144342","jose.c","static char *oidc_jose_alg_to_openssl_digest(const char *alg) {\newline	if ((strcmp(alg, &quotRS256&quot) == 0) || (strcmp(alg, &quotPS256&quot) == 0)\newline			|| (strcmp(alg, &quotHS256&quot) == 0) || (strcmp(alg, &quotES256&quot) == 0)) {\newline		return &quotsha256&quot;\newline	}\newline	if ((strcmp(alg, &quotRS384&quot) == 0) || (strcmp(alg, &quotPS384&quot) == 0)\newline			|| (strcmp(alg, &quotHS384&quot) == 0) || (strcmp(alg, &quotES384&quot) == 0)) {\newline		return &quotsha384&quot;\newline	}\newline	if ((strcmp(alg, &quotRS512&quot) == 0) || (strcmp(alg, &quotPS512&quot) == 0)\newline			|| (strcmp(alg, &quotHS512&quot) == 0) || (strcmp(alg, &quotES512&quot) == 0)) {\newline		return &quotsha512&quot;\newline	}\newline	if (strcmp(alg, &quotNONE&quot) == 0) {\newline		return &quotNONE&quot;\newline	}\newline	return NULL;\newline}\newline","\newline return the OpenSSL hash algorithm associated with a specified JWT algorithm\newline \newline","3774541","webvtt.c","static GF_WebVTTCue *gf_webvtt_cue_split_at(GF_WebVTTCue *cue, GF_WebVTTTimestamp *time)\newline{\newline	GF_WebVTTCue *dup_cue;\newline\newline	cue-&gtsplit         = GF_TRUE;\newline	cue-&gtorig_start    = cue-&gtstart;\newline	cue-&gtorig_end      = cue-&gtend;\newline\newline	GF_SAFEALLOC(dup_cue, GF_WebVTTCue);\newline	dup_cue-&gtsplit          = GF_TRUE;\newline	dup_cue-&gtstart          = *time;\newline	dup_cue-&gtend            = cue-&gtend;\newline	dup_cue-&gtorig_start     = cue-&gtorig_start;\newline	dup_cue-&gtorig_end       = cue-&gtorig_end;\newline	dup_cue-&gtid             = gf_strdup((cue-&gtid ? cue-&gtid : &quot&quot));\newline	dup_cue-&gtsettings       = gf_strdup((cue-&gtsettings ? cue-&gtsettings : &quot&quot));\newline	dup_cue-&gttext           = gf_strdup((cue-&gttext ? cue-&gttext : &quot&quot));\newline\newline	cue-&gtend = *time;\newline	return dup_cue;\newline}\newline","adjust the end of the overlapped cue in the previous sample \newline","131765","lvm.c","const TObject *luaV_gettable (lua_State *L, StkId t) {\newline  Closure *tm;\newline  int tg;\newline  if (ttype(t) == LUA_TTABLE &amp&amp  /* `t&#039 is a table? */\newline      ((tg = hvalue(t)-&gthtag) == LUA_TTABLE ||  /* with default tag? */\newline        luaT_gettm(L, tg, TM_GETTABLE) == NULL)) { /* or no TM? */\newline    /* do a primitive get */\newline    const TObject *h = luaH_get(L, hvalue(t), L-&gttop-1);\newline    /* result is no nil or there is no `index&#039 tag method? */\newline    if (ttype(h) != LUA_TNIL || ((tm=luaT_gettm(L, tg, TM_INDEX)) == NULL))\newline      return h;  /* return result */\newline    /* else call `index&#039 tag method */\newline  }\newline  else {  /* try a `gettable&#039 tag method */\newline    tm = luaT_gettmbyObj(L, t, TM_GETTABLE);\newline  }\newline  if (tm != NULL) {  /* is there a tag method? */\newline    luaD_checkstack(L, 2);\newline    *(L-&gttop+1) = *(L-&gttop-1);  /* key */\newline    *L-&gttop = *t;  /* table */\newline    clvalue(L-&gttop-1) = tm;  /* tag method */\newline    ttype(L-&gttop-1) = LUA_TFUNCTION;\newline    L-&gttop += 2;\newline    luaD_call(L, L-&gttop - 3, 1);\newline    return L-&gttop - 1;  /* call result */\newline  }\newline  else {  /* no tag method */\newline    luaG_typeerror(L, t, &quotindex&quot);\newline    return NULL;  /* to avoid warnings */\newline  }\newline}\newline","\newline Function to index a table.\newline Receives the table at `t&#039 and the key at top.\newline \newline","3069061","nxsreader.cpp","NxsBlock *NxsReader::FindBlockByTitle(const BlockReaderList &amp chosenBlockList, const char *title, unsigned *nMatches)\newline	{\newline	BlockReaderList  found = FindAllBlocksByTitle(chosenBlockList, title);\newline\newline	if (found.empty())\newline		{\newline		if (nMatches)\newline			*nMatches = 0;\newline		return NULL;\newline		}\newline	if (nMatches)\newline		*nMatches = (unsigned)found.size();\newline	return (NxsBlock *) found.back();\newline	}\newline","! \\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.\newline In the event of ties, the most recently read block is returned.\newline If `title` is NULL, then any block is considered a match.\newline On output nMatches will be the number of matches (if `nMatches` is not NULL).\newline NULL will be returned if there are no matches.\newline \newline","4385305","utility.c","void ln_rad_to_dms (double radians, struct ln_dms *dms)\newline{\newline    double degrees = ln_rad_to_deg(radians);\newline    \newline    ln_deg_to_dms(degrees, dms);\newline}\newline","convert radians to dms \newline","1659570","progressbar.c","static void toggle_orientation( GtkWidget    *widget,\newline                                ProgressData *pdata )\newline{\newline  switch (gtk_progress_bar_get_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar))) {\newline  case GTK_PROGRESS_LEFT_TO_RIGHT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_RIGHT_TO_LEFT);\newline    break;\newline  case GTK_PROGRESS_RIGHT_TO_LEFT:\newline    gtk_progress_bar_set_orientation (GTK_PROGRESS_BAR (pdata-&gtpbar), \newline				      GTK_PROGRESS_LEFT_TO_RIGHT);\newline    break;\newline  default:;\newline    /* do nothing */\newline  }\newline}\newline","Callback that toggles the orientation of the progress bar \newline","5758787","transport.c","int _libssh2_transport_read(LIBSSH2_SESSION * session)\newline{\newline    int rc;\newline    struct transportpacket *p = &ampsession-&gtpacket;\newline    int remainbuf;\newline    int remainpack;\newline    int numbytes;\newline    int numdecrypt;\newline    unsigned char block[MAX_BLOCKSIZE];\newline    int blocksize;\newline    int encrypted = 1;\newline    size_t total_num;\newline\newline    /* default clear the bit */\newline    session-&gtsocket_block_directions &amp= ~LIBSSH2_SESSION_BLOCK_INBOUND;\newline\newline    /*\newline     * All channels, systems, subsystems, etc eventually make it down here\newline     * when looking for more incoming data. If a key exchange is going on\newline     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\newline     * ONLY send key exchange related traffic. In non-blocking mode, there is\newline     * a chance to break out of the kex_exchange function with an EAGAIN\newline     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\newline     * active, then we must redirect to the key exchange. However, if\newline     * kex_exchange is active (as in it is the one that calls this execution\newline     * of packet_read, then don&#039t redirect, as that would be an infinite loop!\newline     */\newline\newline    if (session-&gtstate &amp LIBSSH2_STATE_EXCHANGING_KEYS &amp&amp\newline        !(session-&gtstate &amp LIBSSH2_STATE_KEX_ACTIVE)) {\newline\newline        /* Whoever wants a packet won&#039t get anything until the key re-exchange\newline         * is done!\newline         */\newline        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, &quotRedirecting into the&quot\newline                       &quot key re-exchange from _libssh2_transport_read&quot);\newline        rc = _libssh2_kex_exchange(session, 1, &ampsession-&gtstartup_key_state);\newline        if (rc)\newline            return rc;\newline    }\newline\newline    /*\newline     * =============================== NOTE ===============================\newline     * I know this is very ugly and not a really good use of &quotgoto&quot, but\newline     * this case statement would be even uglier to do it any other way\newline     */\newline    if (session-&gtreadPack_state == libssh2_NB_state_jump1) {\newline        session-&gtreadPack_state = libssh2_NB_state_idle;\newline        encrypted = session-&gtreadPack_encrypted;\newline        goto libssh2_transport_read_point1;\newline    }\newline\newline    do {\newline        if (session-&gtsocket_state == LIBSSH2_SOCKET_DISCONNECTED) {\newline            return LIBSSH2_ERROR_NONE;\newline        }\newline\newline        if (session-&gtstate &amp LIBSSH2_STATE_NEWKEYS) {\newline            blocksize = session-&gtremote.crypt-&gtblocksize;\newline        } else {\newline            encrypted = 0;      /* not encrypted */\newline            blocksize = 5;      /* not strictly true, but we can use 5 here to\newline                                   make the checks below work fine still */\newline        }\newline\newline        /* read/use a whole big chunk into a temporary area stored in\newline           the LIBSSH2_SESSION struct. We will decrypt data from that\newline           buffer into the packet buffer so this temp one doesn&#039t have\newline           to be able to keep a whole SSH packet, just be large enough\newline           so that we can read big chunks from the network layer. */\newline\newline        /* how much data there is remaining in the buffer to deal with\newline           before we should read more from the network */\newline        remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline\newline        /* if remainbuf turns negative we have a bad internal error */\newline        assert(remainbuf &gt= 0);\newline\newline        if (remainbuf &lt blocksize) {\newline            /* If we have less than a blocksize left, it is too\newline               little data to deal with, read more */\newline            ssize_t nread;\newline\newline            /* move any remainder to the start of the buffer so\newline               that we can do a full refill */\newline            if (remainbuf) {\newline                memmove(p-&gtbuf, &ampp-&gtbuf[p-&gtreadidx], remainbuf);\newline                p-&gtreadidx = 0;\newline                p-&gtwriteidx = remainbuf;\newline            } else {\newline                /* nothing to move, just zero the indexes */\newline                p-&gtreadidx = p-&gtwriteidx = 0;\newline            }\newline\newline            /* now read a big chunk from the network into the temp buffer */\newline            nread =\newline                LIBSSH2_RECV(session, &ampp-&gtbuf[remainbuf],\newline                              PACKETBUFSIZE - remainbuf,\newline                              LIBSSH2_SOCKET_RECV_FLAGS(session));\newline            if (nread &lt= 0) {\newline                /* check if this is due to EAGAIN and return the special\newline                   return code if so, error out normally otherwise */\newline                if ((nread &lt 0) &amp&amp (nread == -EAGAIN)) {\newline                    session-&gtsocket_block_directions |=\newline                        LIBSSH2_SESSION_BLOCK_INBOUND;\newline                    return LIBSSH2_ERROR_EAGAIN;\newline                }\newline                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                               &quotError recving %d bytes (got %d)&quot,\newline                               PACKETBUFSIZE - remainbuf, -nread);\newline                return LIBSSH2_ERROR_SOCKET_RECV;\newline            }\newline            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\newline                           &quotRecved %d/%d bytes to %p+%d&quot, nread,\newline                           PACKETBUFSIZE - remainbuf, p-&gtbuf, remainbuf);\newline\newline            debugdump(session, &quotlibssh2_transport_read() raw&quot,\newline                      &ampp-&gtbuf[remainbuf], nread);\newline            /* advance write pointer */\newline            p-&gtwriteidx += nread;\newline\newline            /* update remainbuf counter */\newline            remainbuf = p-&gtwriteidx - p-&gtreadidx;\newline        }\newline\newline        /* how much data to deal with from the buffer */\newline        numbytes = remainbuf;\newline\newline        if (!p-&gttotal_num) {\newline            /* No payload package area allocated yet. To know the\newline               size of this payload, we need to decrypt the first\newline               blocksize data. */\newline\newline            if (numbytes &lt blocksize) {\newline                /* we can&#039t act on anything less than blocksize, but this\newline                   check is only done for the initial block since once we have\newline                   got the start of a block we can in fact deal with fractions\newline                */\newline                session-&gtsocket_block_directions |=\newline                    LIBSSH2_SESSION_BLOCK_INBOUND;\newline                return LIBSSH2_ERROR_EAGAIN;\newline            }\newline\newline            if (encrypted) {\newline                rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], block, blocksize);\newline                if (rc != LIBSSH2_ERROR_NONE) {\newline                    return rc;\newline                }\newline                /* save the first 5 bytes of the decrypted package, to be\newline                   used in the hash calculation later down. */\newline                memcpy(p-&gtinit, &ampp-&gtbuf[p-&gtreadidx], 5);\newline            } else {\newline                /* the data is plain, just copy it verbatim to\newline                   the working block buffer */\newline                memcpy(block, &ampp-&gtbuf[p-&gtreadidx], blocksize);\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += blocksize;\newline\newline            /* we now have the initial blocksize bytes decrypted,\newline             * and we can extract packet and padding length from it\newline             */\newline            p-&gtpacket_length = _libssh2_ntohu32(block);\newline            if (p-&gtpacket_length &lt 1)\newline                return LIBSSH2_ERROR_DECRYPT;\newline\newline            p-&gtpadding_length = block[4];\newline\newline            /* total_num is the number of bytes following the initial\newline               (5 bytes) packet length and padding length fields */\newline            total_num =\newline                p-&gtpacket_length - 1 +\newline                (encrypted ? session-&gtremote.mac-&gtmac_len : 0);\newline\newline            /* RFC4253 section 6.1 Maximum Packet Length says:\newline             *\newline             * &quotAll implementations MUST be able to process\newline             * packets with uncompressed payload length of 32768\newline             * bytes or less and total packet size of 35000 bytes\newline             * or less (including length, padding length, payload,\newline             * padding, and MAC.).&quot\newline             */\newline            if (total_num &gt LIBSSH2_PACKET_MAXPAYLOAD) {\newline                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\newline            }\newline\newline            /* Get a packet handle put data into. We get one to\newline               hold all data, including padding and MAC. */\newline            p-&gtpayload = LIBSSH2_ALLOC(session, total_num);\newline            if (!p-&gtpayload) {\newline                return LIBSSH2_ERROR_ALLOC;\newline            }\newline            p-&gttotal_num = total_num;\newline            /* init write pointer to start of payload buffer */\newline            p-&gtwptr = p-&gtpayload;\newline\newline            if (blocksize &gt 5) {\newline                /* copy the data from index 5 to the end of\newline                   the blocksize from the temporary buffer to\newline                   the start of the decrypted buffer */\newline                memcpy(p-&gtwptr, &ampblock[5], blocksize - 5);\newline                p-&gtwptr += blocksize - 5;       /* advance write pointer */\newline            }\newline\newline            /* init the data_num field to the number of bytes of\newline               the package read so far */\newline            p-&gtdata_num = p-&gtwptr - p-&gtpayload;\newline\newline            /* we already dealt with a blocksize worth of data */\newline            numbytes -= blocksize;\newline        }\newline\newline        /* how much there is left to add to the current payload\newline           package */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (numbytes &gt remainpack) {\newline            /* if we have more data in the buffer than what is going into this\newline               particular packet, we limit this round to this packet only */\newline            numbytes = remainpack;\newline        }\newline\newline        if (encrypted) {\newline            /* At the end of the incoming stream, there is a MAC,\newline               and we don&#039t want to decrypt that since we need it\newline               &quotraw&quot. We MUST however decrypt the padding data\newline               since it is used for the hash later on. */\newline            int skip = session-&gtremote.mac-&gtmac_len;\newline\newline            /* if what we have plus numbytes is bigger than the\newline               total minus the skip margin, we should lower the\newline               amount to decrypt even more */\newline            if ((p-&gtdata_num + numbytes) &gt (p-&gttotal_num - skip)) {\newline                numdecrypt = (p-&gttotal_num - skip) - p-&gtdata_num;\newline            } else {\newline                int frac;\newline                numdecrypt = numbytes;\newline                frac = numdecrypt % blocksize;\newline                if (frac) {\newline                    /* not an aligned amount of blocks,\newline                       align it */\newline                    numdecrypt -= frac;\newline                    /* and make it no unencrypted data\newline                       after it */\newline                    numbytes = 0;\newline                }\newline            }\newline        } else {\newline            /* unencrypted data should not be decrypted at all */\newline            numdecrypt = 0;\newline        }\newline\newline        /* if there are bytes to decrypt, do that */\newline        if (numdecrypt &gt 0) {\newline            /* now decrypt the lot */\newline            rc = decrypt(session, &ampp-&gtbuf[p-&gtreadidx], p-&gtwptr, numdecrypt);\newline            if (rc != LIBSSH2_ERROR_NONE) {\newline                p-&gttotal_num = 0;   /* no packet buffer available */\newline                return rc;\newline            }\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numdecrypt;\newline            /* advance write pointer */\newline            p-&gtwptr += numdecrypt;\newline            /* increase data_num */\newline            p-&gtdata_num += numdecrypt;\newline\newline            /* bytes left to take care of without decryption */\newline            numbytes -= numdecrypt;\newline        }\newline\newline        /* if there are bytes to copy that aren&#039t decrypted, simply\newline           copy them as-is to the target buffer */\newline        if (numbytes &gt 0) {\newline            memcpy(p-&gtwptr, &ampp-&gtbuf[p-&gtreadidx], numbytes);\newline\newline            /* advance the read pointer */\newline            p-&gtreadidx += numbytes;\newline            /* advance write pointer */\newline            p-&gtwptr += numbytes;\newline            /* increase data_num */\newline            p-&gtdata_num += numbytes;\newline        }\newline\newline        /* now check how much data there&#039s left to read to finish the\newline           current packet */\newline        remainpack = p-&gttotal_num - p-&gtdata_num;\newline\newline        if (!remainpack) {\newline            /* we have a full packet */\newline          libssh2_transport_read_point1:\newline            rc = fullpacket(session, encrypted);\newline            if (rc == LIBSSH2_ERROR_EAGAIN) {\newline\newline                if (session-&gtpackAdd_state != libssh2_NB_state_idle)\newline                {\newline                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\newline                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If that\newline                     * returns LIBSSH2_ERROR_EAGAIN but the packAdd_state is idle,\newline                     * then the packet has been added to the brigade, but some\newline                     * immediate action that was taken based on the packet\newline                     * type (such as key re-exchange) is not yet complete.\newline                     * Clear the way for a new packet to be read in.\newline                     */\newline                    session-&gtreadPack_encrypted = encrypted;\newline                    session-&gtreadPack_state = libssh2_NB_state_jump1;\newline                }\newline\newline                return rc;\newline            }\newline\newline            p-&gttotal_num = 0;   /* no packet buffer available */\newline\newline            return rc;\newline        }\newline    } while (1);                /* loop */\newline\newline    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\newline}\newline","\newline This function reads the binary stream as specified in chapter 6 of RFC4253\newline &quotThe Secure Shell (SSH) Transport Layer Protocol&quot\newline \newline DOES NOT call _libssh2_error() for ANY error case.\newline \newline","1480360","configdialog.cpp","void ConfigDialog::on_checkBoxAutoclear_clicked() {\newline  on_comboBoxClipboard_activated(1);\newline}\newline","\newline @brief ConfigDialog::on_checkBoxAutoclear_clicked checkbox clicked, update\newline state via ConfigDialog::on_comboBoxClipboard_activated\newline \newline","","","","","","","","","","","","on","on","on","on","","","on","on","","","","","","","","","","","","","","","","","","","","","","","","Encodes the input digest using characters from the set [a-zA-Z0-9_+].","Pins the window","The plot handles the following events for the canvas:","Find come attrbute in an attribute list.","Get the host list from zeroconf","return the OpenSSL hash algorithm associated with a specified JWT algorithm","adjust the end of the overlapped cue in the previous sample","Receives the table at `t' and the key at top.","\returns a NxsBlock from `chosenBlockList` with a Title that matches `title`.","convert radians to dms","Callback that toggles the orientation of the progress bar","{}","{}","{}","{}","Clear out the given server_list.","Simple tests on the tangent trigonometric function.","{}","{}","starts a command on the underlying system","returns a pseudo-random number"
"3E9ZFLPWOYSQTBRDV0445HES5PDXI5","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3570Y55XZPJ3K98L0AV4S24A880YGD","A2OTF82MP99XKI","Approved","Wed Apr 17 19:13:44 PDT 2019","Wed Apr 17 19:22:10 PDT 2019","Fri Apr 19 19:22:10 PDT 2019","2019-04-20 02:22:21 UTC","","","506","100% (1/1)","100% (1/1)","100% (1/1)","6006719","genrccom.c","globle int EnvIsDefmethodDeletable(\newline  void *theEnv,\newline  void *ptr,\newline  unsigned theIndex)\newline  {\newline   if (! ConstructsDeletable(theEnv))\newline     { return FALSE; }\newline\newline   if (((DEFGENERIC *) ptr)-&gtmethods[FindMethodByIndex((DEFGENERIC *) ptr,theIndex)].system)\newline     return(FALSE);\newline   \newline#if (! BLOAD_ONLY) &amp&amp (! RUN_TIME)\newline   return((MethodsExecuting((DEFGENERIC *) ptr) == FALSE) ? TRUE : FALSE);\newline#else\newline   return FALSE;\newline#endif\newline  }\newline","\newlineNAME : EnvIsDefmethodDeletable\newlineDESCRIPTION : Determines if a generic function\newlinemethod can be deleted\newlineINPUTS : 1) Address of the generic function\newline2) Index of the method\newlineRETURNS : TRUE if deletable, FALSE otherwise\newlineSIDE EFFECTS : None\newlineNOTES : None\newline \newline","3330891","swepcalc.c","int InpHouseNr (struct houses *hsp, CSEC pp, CSEC *coff)\newline{ \newline  CSEC cx;\newline  int i = 2;\newline  cx = swe_difcsn(pp, hsp-&gtcusp [1] + coff [1]); \newline  while(i&lt13 &amp&amp  cx &gt= swe_difcsn(hsp-&gtcusp[i] + coff[i], hsp-&gtcusp[1] + coff[1])) \newline    i++;\newline  return (i - 1);\newline}\newline","\newlinereturns the inp-house number, where pp is in \newlinehouses are numbered from 1 .. 12\newline \newline","1025475","site_sample.c","static int pick_endpoint(const score_matrices *sm, int width,\newline			 int seq_len, int strand) {\newline  double **dp_mat = strand == &#039+&#039 ? sm-&gtdp_mat : sm-&gtrc_mat;\newline\newline  if (strand == 0)  /* the sequence is unaligned */\newline    return -1;  /* dummy value, hopefully never used */\newline\newline  return pick_dbl(dp_mat[width], seq_len+1) - dp_mat[width];\newline}\newline","Stochastically choose an alignment endpoint, using the DP matrix \newline","4357976","describe.c","static Error traverse(Object o, struct info *ip, int nosee)\newline{\newline    Object subo;\newline    Class curclass;\newline    int i;\newline\newline    switch (curclass = DXGetObjectClass(o)) {\newline      case CLASS_FIELD:\newline	return validfield((Field)o, ip, nosee);\newline	\newline      case CLASS_GROUP:\newline	/* traverse members */\newline	for (i=0; (subo = DXGetEnumeratedMember((Group)o, i, NULL)); i++) {\newline	    if (!traverse(subo, ip, nosee))\newline		return ERROR;\newline	}\newline	break;\newline	\newline      case CLASS_SCREEN:\newline	if (!DXGetScreenInfo((Screen)o, &ampsubo, NULL, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, 1);\newline\newline      case CLASS_XFORM:\newline	if (!DXGetXformInfo((Xform)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);\newline\newline      case CLASS_CLIPPED:\newline	if (!DXGetClippedInfo((Clipped)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);  /* is this right? */\newline\newline      case CLASS_LIGHT:\newline	ip-&gtri.nlights++;\newline	break;\newline	\newline      case CLASS_INTERPOLATOR:\newline      case CLASS_MAX:\newline      case CLASS_MIN:\newline      case CLASS_PRIVATE:\newline      case CLASS_DELETED:\newline      case CLASS_STRING:\newline      case CLASS_ARRAY:\newline      case CLASS_CAMERA:	\newline      default:\newline	for (i=0; i&ltip-&gtri.badobjs; i++) {\newline	    if (ip-&gtri.badclass[i] == curclass)\newline		return OK;\newline	}\newline	ip-&gtri.badobjs++;\newline	ip-&gtri.badclass = (Class *)DXReAllocate((Pointer)ip-&gtri.badclass, \newline						sizeof(Class) * ip-&gtri.badobjs);\newline	ip-&gtri.badclass[ip-&gtri.badobjs - 1] = curclass;\newline\newline	break;\newline    }\newline\newline    return OK;\newline}\newline","accumulate info about what&#039s what\newline \newline","1446123","fdd.c","int fdd_scanvar(BDD r, int var)\newline{\newline   int *allvar;\newline   int res;\newline\newline   CHECK(r);\newline   if (r == bddfalse)\newline      return -1;\newline   if (var &lt 0  ||  var &gt= fdvarnum)\newline      return bdd_error(BDD_VAR);\newline\newline   allvar = fdd_scanallvar(r);\newline   res = allvar[var];\newline   free(allvar);\newline\newline   return res;\newline}\newline","\newlineNAME { fdd\\_scanvar }\newlineSECTION { fdd }\newlineSHORT { Finds one satisfying value of a FDD variable }\newlinePROTO { int fdd_scanvar(BDD r, int var) }\newlineDESCR { Finds one satisfying assignment of the FDD variable {\\tt var} in the\newlineBDD {\\tt r} and returns this value. }\newlineRETURN { The value of a satisfying assignment of {\\tt var}. If {\\tt r} is\newlinethe trivially false BDD, then a negative value is returned. }\newlineALSO { fdd\\_scanallvar }\newline \newline","5179064","xml_relax_ng.c","static VALUE validate_document(VALUE self, VALUE document)\newline{\newline  xmlDocPtr doc;\newline  xmlRelaxNGPtr schema;\newline  VALUE errors;\newline  xmlRelaxNGValidCtxtPtr valid_ctxt;\newline\newline  Data_Get_Struct(self, xmlRelaxNG, schema);\newline  Data_Get_Struct(document, xmlDoc, doc);\newline\newline  errors = rb_ary_new();\newline\newline  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\newline\newline  if(NULL == valid_ctxt) {\newline    /* we have a problem */\newline    rb_raise(rb_eRuntimeError, &quotCould not create a validation context&quot);\newline  }\newline\newline#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\newline  xmlRelaxNGSetValidStructuredErrors(\newline    valid_ctxt,\newline    Nokogiri_error_array_pusher,\newline    (void *)errors\newline  );\newline#endif\newline\newline  xmlRelaxNGValidateDoc(valid_ctxt, doc);\newline\newline  xmlRelaxNGFreeValidCtxt(valid_ctxt);\newline\newline  return errors;\newline}\newline","\newline call-seq:\newline validate_document(document)\newline \newline Validate a Nokogiri::XML::Document against this RelaxNG schema.\newline \newline","4854568","fsm_var.c","void fsm_var_remove(\newline  fsm_var* fv  /*!&lt Pointer to FSM variable structure to remove from global list */\newline) { PROFILE(FSM_VAR_REMOVE);\newline\newline  fsm_var* curr;  /* Pointer to current FSM variable structure in list */\newline  fsm_var* last;  /* Pointer to last FSM variable structure evaluated */\newline\newline  /* Find matching FSM variable structure */\newline  curr = fsm_var_head;\newline  last = NULL;\newline  while( (curr != NULL) &amp&amp (curr != fv) ) {\newline    last = curr;\newline    curr = curr-&gtnext;\newline  }\newline\newline  /* If a matching FSM variable structure was found, remove it from the global list. */\newline  if( curr != NULL ) {\newline\newline    if( (curr == fsm_var_head) &amp&amp (curr == fsm_var_tail) ) {\newline      fsm_var_head = fsm_var_tail = NULL;\newline    } else if( curr == fsm_var_head ) {\newline      fsm_var_head = curr-&gtnext;\newline    } else if( curr == fsm_var_tail ) {\newline      fsm_var_tail = last;\newline    } else {\newline      last-&gtnext = curr-&gtnext;\newline    }\newline\newline    fsm_var_dealloc( curr );\newline\newline  }\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineSearches global FSM variable list for matching FSM variable structure.\newlineWhen match is found, remove the structure and deallocate it from memory\newlinebeing sure to keep the global list intact.\newline \newline","1078422","audio_alsa_out.c","static int my_snd_mixer_wait(snd_mixer_t *mixer, int timeout) {\newline  struct pollfd  spfds[16];\newline  struct pollfd *pfds = spfds;\newline  int            err, count;\newline\newline  count = snd_mixer_poll_descriptors(mixer, pfds, sizeof(spfds) / sizeof(spfds[0]));\newline\newline  if (count &lt 0)\newline    return count;\newline\newline  if ((unsigned int) count &gt sizeof(spfds) / sizeof(spfds[0])) {\newline    pfds = calloc(count, sizeof(*pfds));\newline\newline    if (!pfds)\newline      return -ENOMEM;\newline\newline    err = snd_mixer_poll_descriptors(mixer, pfds, (unsigned int) count);\newline    assert(err == count);\newline  }\newline\newline  err = poll(pfds, (unsigned int) count, timeout);\newline\newline  if (err &lt 0)\newline    return -errno;\newline\newline  return err;\newline}\newline","Stolen from alsa-lib \newline","5137482","rfc1035.c","int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, \newline			     struct bogus_addr *baddr, time_t now)\newline{\newline  unsigned char *p;\newline  int i, qtype, qclass, rdlen;\newline  unsigned long ttl;\newline  struct bogus_addr *baddrp;\newline\newline  /* skip over questions */\newline  if (!(p = skip_questions(header, qlen)))\newline    return 0; /* bad packet */\newline\newline  for (i = ntohs(header-&gtancount); i != 0; i--)\newline    {\newline      if (!extract_name(header, qlen, &ampp, name, 1, 10))\newline	return 0; /* bad packet */\newline  \newline      GETSHORT(qtype, p); \newline      GETSHORT(qclass, p);\newline      GETLONG(ttl, p);\newline      GETSHORT(rdlen, p);\newline      \newline      if (qclass == C_IN &amp&amp qtype == T_A)\newline	{\newline	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))\newline	    return 0;\newline	  \newline	  for (baddrp = baddr; baddrp; baddrp = baddrp-&gtnext)\newline	    if (memcmp(&ampbaddrp-&gtaddr, p, INADDRSZ) == 0)\newline	      {\newline		/* Found a bogus address. Insert that info here, since there no SOA record\newline		   to get the ttl from in the normal processing */\newline		cache_start_insert();\newline		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);\newline		cache_end_insert();\newline		\newline		return 1;\newline	      }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, qlen, rdlen))\newline	return 0;\newline    }\newline  \newline  return 0;\newline}\newline","Is the packet a reply with the answer address equal to addr?\newlineIf so mung is into an NXDOMAIN reply and also put that information\newlinein the cache. \newline","4945349","context.c","int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable)\newline{\newline	return set_flag(cxt, MNT_FL_NOMTAB, disable);\newline}\newline","\newline mnt_context_disable_mtab:\newline @cxt: mount context\newline @disable: TRUE or FALSE\newline \newline Disable/enable mtab update (see mount(8) man page, option -n).\newline \newline Returns: 0 on success, negative number in case of error.\newline \newline","3007780","init_finalize.c","int PARMCI_Finalize(void) {\newline  int nfreed;\newline\newline  /* GA/TCGMSG end up calling ARMCI_Finalize() multiple times. */\newline  if (ARMCII_GLOBAL_STATE.init_count == 0) {\newline    return 0;\newline  }\newline\newline  ARMCII_GLOBAL_STATE.init_count--;\newline\newline  /* Only finalize on the last matching call */\newline  if (ARMCII_GLOBAL_STATE.init_count &gt 0) {\newline    return 0;\newline  }\newline\newline#ifdef HAVE_PTHREADS\newline    /* Destroy the asynchronous progress thread */\newline    {\newline        if(ARMCII_GLOBAL_STATE.progress_thread) {\newline            progress_active = 0;\newline            int rc = pthread_join(ARMCI_Progress_thread, NULL);\newline            if (rc) {\newline                ARMCII_Warning(&quotARMCI progress thread join failed (%d).\\n&quot, rc);\newline            }\newline        }\newline    }\newline#endif\newline\newline  nfreed = gmr_destroy_all();\newline\newline  if (nfreed &gt 0 &amp&amp ARMCI_GROUP_WORLD.rank == 0)\newline    ARMCII_Warning(&quotFreed %d leaked allocations\\n&quot, nfreed);\newline\newline  /* Free GOP operators */\newline\newline  MPI_Op_free(&ampMPI_ABSMIN_OP);\newline  MPI_Op_free(&ampMPI_ABSMAX_OP);\newline\newline  MPI_Op_free(&ampMPI_SELMIN_OP);\newline  MPI_Op_free(&ampMPI_SELMAX_OP);\newline\newline  ARMCI_Cleanup();\newline\newline  ARMCI_Group_free(&ampARMCI_GROUP_WORLD);\newline\newline  return 0;\newline}\newline","Finalize ARMCI. Must be called before MPI is finalized. ARMCI calls are\newline not valid after finalization. Collective on world group.\newline \newline @return Zero on success\newline \newline","1491823","priorityq-heap.cpp","PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )\newline{\newline  long curr;\newline  PQhandle free_handle;\newline\newline  curr = ++ pq-&gtsize;\newline  if( (curr*2) &gt pq-&gtmax ) {\newline    PQnode *saveNodes= pq-&gtnodes;\newline    PQhandleElem *saveHandles= pq-&gthandles;\newline\newline    /* If the heap overflows, double its size. */\newline    pq-&gtmax &lt&lt= 1;\newline    pq-&gtnodes = (PQnode *)memRealloc( pq-&gtnodes, \newline				     (size_t) \newline				     ((pq-&gtmax + 1) * sizeof( pq-&gtnodes[0] )));\newline    if (pq-&gtnodes == NULL) {\newline       pq-&gtnodes = saveNodes;	/* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline    pq-&gthandles = (PQhandleElem *)memRealloc( pq-&gthandles,\newline			                     (size_t)\newline			                      ((pq-&gtmax + 1) * \newline					       sizeof( pq-&gthandles[0] )));\newline    if (pq-&gthandles == NULL) {\newline       pq-&gthandles = saveHandles; /* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline  }\newline\newline  if( pq-&gtfreeList == 0 ) {\newline    free_handle = curr;\newline  } else {\newline    free_handle = pq-&gtfreeList;\newline    pq-&gtfreeList = pq-&gthandles[free_handle].node;\newline  }\newline\newline  pq-&gtnodes[curr].handle = free_handle;\newline  pq-&gthandles[free_handle].node = curr;\newline  pq-&gthandles[free_handle].key = keyNew;\newline\newline  if( pq-&gtinitialized ) {\newline    FloatUp( pq, curr );\newline  }\newline  assert(free_handle != LONG_MAX);\newline  return free_handle;\newline}\newline","returns LONG_MAX iff out of memory \newline","557191","bbrun.c","void bb_run_stopwaiting(void){\newline  dowait = 0;\newline}\newline","\newline Cancels waiting for processes to finish - use when doing a fast shutdown.\newline \newline","675746","dictionary.c","Afdict_class * afdict_find(Dictionary afdict, const char * con, bool notify_err)\newline{\newline	const char ** ac;\newline\newline	for (ac = afdict_classname;\newline	     ac &lt &ampafdict_classname[ARRAY_SIZE(afdict_classname)]; ac++)\newline	{\newline		if (0 == strcmp(*ac, con))\newline			return &ampafdict-&gtafdict_class[ac - afdict_classname];\newline	}\newline	if (notify_err) {\newline		prt_error(&quotWarning: Unknown class name %s found near line %d of %s.\\n&quot\newline		          &quot\\tThis class name will be ignored.\\n&quot,\newline		          con, afdict-&gtline_number, afdict-&gtname);\newline	}\newline	return NULL;\newline}\newline","\newline Find the affix table entry for given connector name.\newline If the connector name is not in the table, return NULL.\newline \newline","3068865","nxstoken.h","inline const char *NxsToken::GetTokenAsCStr(\newline  bool respect_case)	/* determines whether token is converted to upper case before being returned */\newline	{\newline	if (!respect_case)\newline		ToUpper();\newline\newline	return token.c_str();\newline	}\newline","!\newline Returns the data member `token&#039 as a C-style string. Specifying false for`respect_case&#039 parameter causes all\newline characters in `token&#039 to be converted to upper case before the `token&#039 C-string is returned. Specifying true\newline results in GetTokenAsCStr returning exactly what it read from the file.\newline \newline","5034941","utility_funcs.c","int g15daemon_cfg_remove_key(config_section_t *section, char *key){\newline    \newline    config_items_t *new = NULL;\newline    config_items_t *next = NULL;\newline    config_items_t *prev = NULL;\newline    if(section==NULL)\newline        return -1;\newline    \newline    if((uf_search_confitem(section, key))){\newline        new=uf_search_confitem(section, key);\newline        prev=new-&gtprev;\newline        next=new-&gtnext;\newline        if(prev){\newline            prev-&gtnext=new-&gtnext;\newline        }else{\newline             if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline                else\newline                    section-&gtitems=next;\newline            }\newline\newline        if(new-&gthead==new){\newline            if(prev){\newline                prev-&gthead = prev;\newline                section-&gtitems-&gthead=prev;\newline            }\newline            if(!prev){\newline                if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline            }\newline        }\newline        if(next){\newline            if(prev)\newline            	next-&gtprev=prev;\newline            else\newline                next-&gtprev=NULL;\newline        }\newline        free(new-&gtkey);\newline        free(new-&gtvalue);\newline        free(new);\newline    }\newline    return 0;\newline}\newline","remoe a key/value pair from named section \newline","6572891","lomoco.c","static void query (mouse_t *m, struct usb_device *device) {\newline	usb_dev_handle *handle;\newline	unsigned int  addr;\newline\newline	/*\newline	 * For dual receivers C502, C504 and C505, the mouse is the\newline	 * second device and uses an addr of 1 in the value and index\newline	 * fields&#039 high byte. 1 &lt&lt 8\newline	 */\newline	addr = m-&gtis_dual ? 1 &lt&lt 8 : 0;\newline\newline	/* Try to open the device */\newline	handle = usb_open (device);\newline\newline	if (handle == NULL) {\newline		perror (&quotError opening USB device&quot);\newline		exit (EXIT_FAILURE);\newline	}\newline\newline	/* Parse CSR Status (this one&#039s huge) \newline	*  for wireless mouse\newline	*/\newline	if (m-&gthas_csr) {\newline		query_csr(m, handle, addr);\newline	}\newline\newline\newline	/* The RES extension */\newline	if (m-&gthas_res) {\newline		query_res(m, handle, addr);\newline	}\newline	\newline\newline	/* The SMS extension */\newline	if (m-&gthas_sms) {\newline		query_sms(m, handle, addr);\newline	}\newline\newline	query_usb(m, device);\newline\newline	printf (&quot\\n&quot);\newline\newline	(void) usb_close (handle);\newline}\newline","\newline Description: print mouse specific things like current resolution, \newline state of sms, and for wireless mouse additional: \newline receiver type, battery strenght and so on\newline \newline Parameters: mouse_t m\newline struct with the mouse specs\newline usb_device device\newline the device which should be queried\newline \newline Retrun: void\newline \newline","6511628","jar.c","JarFile* jclass_jar_open(const char *zipfile)\newline{\newline	/* allocate */\newline	JarFile *zip = (JarFile *) malloc (sizeof (JarFile));\newline\newline	/* open */\newline	zip-&gtfp = my_open (zipfile, &quotrb&quot);\newline	if (zip-&gtfp == NULL)\newline	{\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* go to end */\newline	if (fseek (zip-&gtfp, 0L, SEEK_END) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* get length */\newline	zip-&gtlength = ftell (zip-&gtfp);\newline	if (zip-&gtlength &lt= 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read ecd data */\newline	if (ecd_read (zip) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* compile ecd info */\newline	zip-&gtend_of_cent_dir_sig = read_dword (zip-&gtecd + ZIPESIG);\newline	zip-&gtnumber_of_this_disk = read_word (zip-&gtecd + ZIPEDSK);\newline	zip-&gtnumber_of_disk_start_cent_dir = read_word (zip-&gtecd + ZIPECEN);\newline	zip-&gttotal_entries_cent_dir_this_disk =\newline		read_word (zip-&gtecd + ZIPENUM);\newline	zip-&gttotal_entries_cent_dir = read_word (zip-&gtecd + ZIPECENN);\newline	zip-&gtsize_of_cent_dir = read_dword (zip-&gtecd + ZIPECSZ);\newline	zip-&gtoffset_to_start_of_cent_dir = read_dword (zip-&gtecd + ZIPEOFST);\newline\newline	/* verify that we can work with this zipfile (no disk spanning allowed) */\newline	if ((zip-&gtnumber_of_this_disk != zip-&gtnumber_of_disk_start_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir_this_disk !=\newline		zip-&gttotal_entries_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir &lt 1))\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fseek (zip-&gtfp, zip-&gtoffset_to_start_of_cent_dir, SEEK_SET) != 0)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read from start of central directory */\newline	zip-&gtcd = (char *) malloc (zip-&gtsize_of_cent_dir);\newline	if (zip-&gtcd == NULL)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fread (zip-&gtcd, zip-&gtsize_of_cent_dir, 1, zip-&gtfp) != 1)\newline	{\newline		free (zip-&gtcd);\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* reset ent */\newline	zip-&gtent.name = NULL;\newline\newline	/* rewind */\newline	zip-&gtcd_pos = 0;\newline\newline	return zip;\newline}\newline","\newline jclass_jar_open\newline @filename: The filename for the jar file.\newline \newline Opens a jar stream for reading.\newline \newline Returns: A newly allocated jar stream on success,\newline or NULL if any error occured.\newline \newline","2152693","rolodex.c","int insertPhoneEntryCB (EObjectType cdkType GCC_UNUSED, void *object, void\newline			*clientData, chtype key GCC_UNUSED)\newline{\newline   /* Declare local variables. */\newline   CDKSCROLL *scrollp = (CDKSCROLL *)object;\newline   SPhoneData *phoneData = (SPhoneData *) clientData;\newline   SPhoneRecord *phoneRecord = &ampphoneData-&gtrecord[phoneData-&gtrecordCount];\newline   char temp[MYSIZE];\newline\newline   /* Make the scrolling list disappear. */\newline   eraseCDKScroll (scrollp);\newline\newline   /* Call the function which gets phone record information. */\newline   if (addPhoneRecord (ScreenOf (scrollp), phoneData) == 0)\newline   {\newline      sprintf (temp, &quot%s (%s)&quot, phoneRecord-&gtname, GLineType[phoneRecord-&gtlineType]);\newline      addCDKScrollItem (scrollp, temp);\newline   }\newline\newline   /* Redraw the scrolling list. */\newline   drawCDKScroll (scrollp, ObjOf (scrollp)-&gtbox);\newline   return (FALSE);\newline}\newline","\newline This allows the user to insert a new phone entry into the database.\newline \newline","5131880","fnotifystat.c","static void show_usage(void)\newline{\newline	printf(&quot%s, version %s\\n\\n&quot, app_name, VERSION);\newline	printf(&quotOptions are:\\n&quot\newline		&quot  -c     cumulative totals over time\\n&quot\newline		&quot  -d     strip directory off the filenames\\n&quot\newline		&quot  -D     order stats by unique device\\n&quot\newline		&quot  -f     force output\\n&quot\newline		&quot  -h     show this help\\n&quot\newline		&quot  -i     specify pathnames to include on path events\\n&quot\newline		&quot  -I     order stats by unique device and inode\\n&quot\newline		&quot  -m     merge events on same file and pid in same second\\n&quot\newline		&quot  -n     no stats, just -v verbose mode only\\n&quot\newline		&quot  -p PID collect stats for just process with pid PID\\n&quot\newline		&quot  -P     sort stats by process ID\\n&quot\newline		&quot  -s     disable scaling of file counts\\n&quot\newline		&quot  -t N   show just the busiest N files\\n&quot\newline		&quot  -T     show timestamp\\n&quot\newline		&quot  -v     verbose mode, dump out all file activity\\n&quot\newline		&quot  -x     specify pathnames to exclude on path events\\n&quot);\newline}\newline","\newline show_usage()\newline how to use\newline \newline","1461728","plustek-pp_image.c","static void fnDataDirect( pScanData ps, pVoid pBuf, pVoid pImg, ULong bl )\newline{\newline	_VAR_NOT_USED( ps );\newline	memcpy( pBuf, pImg, bl );\newline}\newline","This routine used in the condition:\newline 1) The data type is B/W or GrayScale.\newline 2) The required horizontal resolution doesn&#039t exceed the optic spec.\newline 3) The required vertical resolution exceeds the optic spec.\newline So, the vertcal lines have to average with previous line to smooth the\newline image.\newline \newline","","","","","","","","","","","","","","on","","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","Determines if a generic functionmethod can be deleted","Disable/enable mtab update (see mount(8) man page, option -n).","Finalize ARMCI.","returns LONG_MAX iff out of memory","Cancels waiting for processes to finish","Find the affix table entry for given connector name.","Returns the data member `token' as a C-style string.","remoe a key/value pair from named section","print mouse specific things like current resolution,","Opens a jar stream for reading.","allows the user to insert a new phone entry into the database.","returns the inp-house number, where pp is in","show_usage()how to use","{}","Stochastically choose an alignment endpoint, using the DP matrix","accumulate info about what's what","Finds one satisfying value of a FDD variable","Validate a Nokogiri::XML::Document against this RelaxNG schema.","Searches global FSM variable list for matching FSM variable structure.","{}","{}"
"3E9ZFLPWOYSQTBRDV0445HES5PDXI5","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3LYA37P8IQNC9NBTG92ZIJY2UDXBK6","AMD1LYNQAH3R8","Approved","Wed Apr 17 11:57:38 PDT 2019","Wed Apr 17 12:09:13 PDT 2019","Fri Apr 19 12:09:13 PDT 2019","2019-04-19 19:09:21 UTC","","","695","100% (27/27)","100% (27/27)","100% (27/27)","6006719","genrccom.c","globle int EnvIsDefmethodDeletable(\newline  void *theEnv,\newline  void *ptr,\newline  unsigned theIndex)\newline  {\newline   if (! ConstructsDeletable(theEnv))\newline     { return FALSE; }\newline\newline   if (((DEFGENERIC *) ptr)-&gtmethods[FindMethodByIndex((DEFGENERIC *) ptr,theIndex)].system)\newline     return(FALSE);\newline   \newline#if (! BLOAD_ONLY) &amp&amp (! RUN_TIME)\newline   return((MethodsExecuting((DEFGENERIC *) ptr) == FALSE) ? TRUE : FALSE);\newline#else\newline   return FALSE;\newline#endif\newline  }\newline","\newlineNAME : EnvIsDefmethodDeletable\newlineDESCRIPTION : Determines if a generic function\newlinemethod can be deleted\newlineINPUTS : 1) Address of the generic function\newline2) Index of the method\newlineRETURNS : TRUE if deletable, FALSE otherwise\newlineSIDE EFFECTS : None\newlineNOTES : None\newline \newline","3330891","swepcalc.c","int InpHouseNr (struct houses *hsp, CSEC pp, CSEC *coff)\newline{ \newline  CSEC cx;\newline  int i = 2;\newline  cx = swe_difcsn(pp, hsp-&gtcusp [1] + coff [1]); \newline  while(i&lt13 &amp&amp  cx &gt= swe_difcsn(hsp-&gtcusp[i] + coff[i], hsp-&gtcusp[1] + coff[1])) \newline    i++;\newline  return (i - 1);\newline}\newline","\newlinereturns the inp-house number, where pp is in \newlinehouses are numbered from 1 .. 12\newline \newline","1025475","site_sample.c","static int pick_endpoint(const score_matrices *sm, int width,\newline			 int seq_len, int strand) {\newline  double **dp_mat = strand == &#039+&#039 ? sm-&gtdp_mat : sm-&gtrc_mat;\newline\newline  if (strand == 0)  /* the sequence is unaligned */\newline    return -1;  /* dummy value, hopefully never used */\newline\newline  return pick_dbl(dp_mat[width], seq_len+1) - dp_mat[width];\newline}\newline","Stochastically choose an alignment endpoint, using the DP matrix \newline","4357976","describe.c","static Error traverse(Object o, struct info *ip, int nosee)\newline{\newline    Object subo;\newline    Class curclass;\newline    int i;\newline\newline    switch (curclass = DXGetObjectClass(o)) {\newline      case CLASS_FIELD:\newline	return validfield((Field)o, ip, nosee);\newline	\newline      case CLASS_GROUP:\newline	/* traverse members */\newline	for (i=0; (subo = DXGetEnumeratedMember((Group)o, i, NULL)); i++) {\newline	    if (!traverse(subo, ip, nosee))\newline		return ERROR;\newline	}\newline	break;\newline	\newline      case CLASS_SCREEN:\newline	if (!DXGetScreenInfo((Screen)o, &ampsubo, NULL, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, 1);\newline\newline      case CLASS_XFORM:\newline	if (!DXGetXformInfo((Xform)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);\newline\newline      case CLASS_CLIPPED:\newline	if (!DXGetClippedInfo((Clipped)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);  /* is this right? */\newline\newline      case CLASS_LIGHT:\newline	ip-&gtri.nlights++;\newline	break;\newline	\newline      case CLASS_INTERPOLATOR:\newline      case CLASS_MAX:\newline      case CLASS_MIN:\newline      case CLASS_PRIVATE:\newline      case CLASS_DELETED:\newline      case CLASS_STRING:\newline      case CLASS_ARRAY:\newline      case CLASS_CAMERA:	\newline      default:\newline	for (i=0; i&ltip-&gtri.badobjs; i++) {\newline	    if (ip-&gtri.badclass[i] == curclass)\newline		return OK;\newline	}\newline	ip-&gtri.badobjs++;\newline	ip-&gtri.badclass = (Class *)DXReAllocate((Pointer)ip-&gtri.badclass, \newline						sizeof(Class) * ip-&gtri.badobjs);\newline	ip-&gtri.badclass[ip-&gtri.badobjs - 1] = curclass;\newline\newline	break;\newline    }\newline\newline    return OK;\newline}\newline","accumulate info about what&#039s what\newline \newline","1446123","fdd.c","int fdd_scanvar(BDD r, int var)\newline{\newline   int *allvar;\newline   int res;\newline\newline   CHECK(r);\newline   if (r == bddfalse)\newline      return -1;\newline   if (var &lt 0  ||  var &gt= fdvarnum)\newline      return bdd_error(BDD_VAR);\newline\newline   allvar = fdd_scanallvar(r);\newline   res = allvar[var];\newline   free(allvar);\newline\newline   return res;\newline}\newline","\newlineNAME { fdd\\_scanvar }\newlineSECTION { fdd }\newlineSHORT { Finds one satisfying value of a FDD variable }\newlinePROTO { int fdd_scanvar(BDD r, int var) }\newlineDESCR { Finds one satisfying assignment of the FDD variable {\\tt var} in the\newlineBDD {\\tt r} and returns this value. }\newlineRETURN { The value of a satisfying assignment of {\\tt var}. If {\\tt r} is\newlinethe trivially false BDD, then a negative value is returned. }\newlineALSO { fdd\\_scanallvar }\newline \newline","5179064","xml_relax_ng.c","static VALUE validate_document(VALUE self, VALUE document)\newline{\newline  xmlDocPtr doc;\newline  xmlRelaxNGPtr schema;\newline  VALUE errors;\newline  xmlRelaxNGValidCtxtPtr valid_ctxt;\newline\newline  Data_Get_Struct(self, xmlRelaxNG, schema);\newline  Data_Get_Struct(document, xmlDoc, doc);\newline\newline  errors = rb_ary_new();\newline\newline  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\newline\newline  if(NULL == valid_ctxt) {\newline    /* we have a problem */\newline    rb_raise(rb_eRuntimeError, &quotCould not create a validation context&quot);\newline  }\newline\newline#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\newline  xmlRelaxNGSetValidStructuredErrors(\newline    valid_ctxt,\newline    Nokogiri_error_array_pusher,\newline    (void *)errors\newline  );\newline#endif\newline\newline  xmlRelaxNGValidateDoc(valid_ctxt, doc);\newline\newline  xmlRelaxNGFreeValidCtxt(valid_ctxt);\newline\newline  return errors;\newline}\newline","\newline call-seq:\newline validate_document(document)\newline \newline Validate a Nokogiri::XML::Document against this RelaxNG schema.\newline \newline","4854568","fsm_var.c","void fsm_var_remove(\newline  fsm_var* fv  /*!&lt Pointer to FSM variable structure to remove from global list */\newline) { PROFILE(FSM_VAR_REMOVE);\newline\newline  fsm_var* curr;  /* Pointer to current FSM variable structure in list */\newline  fsm_var* last;  /* Pointer to last FSM variable structure evaluated */\newline\newline  /* Find matching FSM variable structure */\newline  curr = fsm_var_head;\newline  last = NULL;\newline  while( (curr != NULL) &amp&amp (curr != fv) ) {\newline    last = curr;\newline    curr = curr-&gtnext;\newline  }\newline\newline  /* If a matching FSM variable structure was found, remove it from the global list. */\newline  if( curr != NULL ) {\newline\newline    if( (curr == fsm_var_head) &amp&amp (curr == fsm_var_tail) ) {\newline      fsm_var_head = fsm_var_tail = NULL;\newline    } else if( curr == fsm_var_head ) {\newline      fsm_var_head = curr-&gtnext;\newline    } else if( curr == fsm_var_tail ) {\newline      fsm_var_tail = last;\newline    } else {\newline      last-&gtnext = curr-&gtnext;\newline    }\newline\newline    fsm_var_dealloc( curr );\newline\newline  }\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineSearches global FSM variable list for matching FSM variable structure.\newlineWhen match is found, remove the structure and deallocate it from memory\newlinebeing sure to keep the global list intact.\newline \newline","1078422","audio_alsa_out.c","static int my_snd_mixer_wait(snd_mixer_t *mixer, int timeout) {\newline  struct pollfd  spfds[16];\newline  struct pollfd *pfds = spfds;\newline  int            err, count;\newline\newline  count = snd_mixer_poll_descriptors(mixer, pfds, sizeof(spfds) / sizeof(spfds[0]));\newline\newline  if (count &lt 0)\newline    return count;\newline\newline  if ((unsigned int) count &gt sizeof(spfds) / sizeof(spfds[0])) {\newline    pfds = calloc(count, sizeof(*pfds));\newline\newline    if (!pfds)\newline      return -ENOMEM;\newline\newline    err = snd_mixer_poll_descriptors(mixer, pfds, (unsigned int) count);\newline    assert(err == count);\newline  }\newline\newline  err = poll(pfds, (unsigned int) count, timeout);\newline\newline  if (err &lt 0)\newline    return -errno;\newline\newline  return err;\newline}\newline","Stolen from alsa-lib \newline","5137482","rfc1035.c","int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, \newline			     struct bogus_addr *baddr, time_t now)\newline{\newline  unsigned char *p;\newline  int i, qtype, qclass, rdlen;\newline  unsigned long ttl;\newline  struct bogus_addr *baddrp;\newline\newline  /* skip over questions */\newline  if (!(p = skip_questions(header, qlen)))\newline    return 0; /* bad packet */\newline\newline  for (i = ntohs(header-&gtancount); i != 0; i--)\newline    {\newline      if (!extract_name(header, qlen, &ampp, name, 1, 10))\newline	return 0; /* bad packet */\newline  \newline      GETSHORT(qtype, p); \newline      GETSHORT(qclass, p);\newline      GETLONG(ttl, p);\newline      GETSHORT(rdlen, p);\newline      \newline      if (qclass == C_IN &amp&amp qtype == T_A)\newline	{\newline	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))\newline	    return 0;\newline	  \newline	  for (baddrp = baddr; baddrp; baddrp = baddrp-&gtnext)\newline	    if (memcmp(&ampbaddrp-&gtaddr, p, INADDRSZ) == 0)\newline	      {\newline		/* Found a bogus address. Insert that info here, since there no SOA record\newline		   to get the ttl from in the normal processing */\newline		cache_start_insert();\newline		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);\newline		cache_end_insert();\newline		\newline		return 1;\newline	      }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, qlen, rdlen))\newline	return 0;\newline    }\newline  \newline  return 0;\newline}\newline","Is the packet a reply with the answer address equal to addr?\newlineIf so mung is into an NXDOMAIN reply and also put that information\newlinein the cache. \newline","4945349","context.c","int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable)\newline{\newline	return set_flag(cxt, MNT_FL_NOMTAB, disable);\newline}\newline","\newline mnt_context_disable_mtab:\newline @cxt: mount context\newline @disable: TRUE or FALSE\newline \newline Disable/enable mtab update (see mount(8) man page, option -n).\newline \newline Returns: 0 on success, negative number in case of error.\newline \newline","3007780","init_finalize.c","int PARMCI_Finalize(void) {\newline  int nfreed;\newline\newline  /* GA/TCGMSG end up calling ARMCI_Finalize() multiple times. */\newline  if (ARMCII_GLOBAL_STATE.init_count == 0) {\newline    return 0;\newline  }\newline\newline  ARMCII_GLOBAL_STATE.init_count--;\newline\newline  /* Only finalize on the last matching call */\newline  if (ARMCII_GLOBAL_STATE.init_count &gt 0) {\newline    return 0;\newline  }\newline\newline#ifdef HAVE_PTHREADS\newline    /* Destroy the asynchronous progress thread */\newline    {\newline        if(ARMCII_GLOBAL_STATE.progress_thread) {\newline            progress_active = 0;\newline            int rc = pthread_join(ARMCI_Progress_thread, NULL);\newline            if (rc) {\newline                ARMCII_Warning(&quotARMCI progress thread join failed (%d).\\n&quot, rc);\newline            }\newline        }\newline    }\newline#endif\newline\newline  nfreed = gmr_destroy_all();\newline\newline  if (nfreed &gt 0 &amp&amp ARMCI_GROUP_WORLD.rank == 0)\newline    ARMCII_Warning(&quotFreed %d leaked allocations\\n&quot, nfreed);\newline\newline  /* Free GOP operators */\newline\newline  MPI_Op_free(&ampMPI_ABSMIN_OP);\newline  MPI_Op_free(&ampMPI_ABSMAX_OP);\newline\newline  MPI_Op_free(&ampMPI_SELMIN_OP);\newline  MPI_Op_free(&ampMPI_SELMAX_OP);\newline\newline  ARMCI_Cleanup();\newline\newline  ARMCI_Group_free(&ampARMCI_GROUP_WORLD);\newline\newline  return 0;\newline}\newline","Finalize ARMCI. Must be called before MPI is finalized. ARMCI calls are\newline not valid after finalization. Collective on world group.\newline \newline @return Zero on success\newline \newline","1491823","priorityq-heap.cpp","PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )\newline{\newline  long curr;\newline  PQhandle free_handle;\newline\newline  curr = ++ pq-&gtsize;\newline  if( (curr*2) &gt pq-&gtmax ) {\newline    PQnode *saveNodes= pq-&gtnodes;\newline    PQhandleElem *saveHandles= pq-&gthandles;\newline\newline    /* If the heap overflows, double its size. */\newline    pq-&gtmax &lt&lt= 1;\newline    pq-&gtnodes = (PQnode *)memRealloc( pq-&gtnodes, \newline				     (size_t) \newline				     ((pq-&gtmax + 1) * sizeof( pq-&gtnodes[0] )));\newline    if (pq-&gtnodes == NULL) {\newline       pq-&gtnodes = saveNodes;	/* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline    pq-&gthandles = (PQhandleElem *)memRealloc( pq-&gthandles,\newline			                     (size_t)\newline			                      ((pq-&gtmax + 1) * \newline					       sizeof( pq-&gthandles[0] )));\newline    if (pq-&gthandles == NULL) {\newline       pq-&gthandles = saveHandles; /* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline  }\newline\newline  if( pq-&gtfreeList == 0 ) {\newline    free_handle = curr;\newline  } else {\newline    free_handle = pq-&gtfreeList;\newline    pq-&gtfreeList = pq-&gthandles[free_handle].node;\newline  }\newline\newline  pq-&gtnodes[curr].handle = free_handle;\newline  pq-&gthandles[free_handle].node = curr;\newline  pq-&gthandles[free_handle].key = keyNew;\newline\newline  if( pq-&gtinitialized ) {\newline    FloatUp( pq, curr );\newline  }\newline  assert(free_handle != LONG_MAX);\newline  return free_handle;\newline}\newline","returns LONG_MAX iff out of memory \newline","557191","bbrun.c","void bb_run_stopwaiting(void){\newline  dowait = 0;\newline}\newline","\newline Cancels waiting for processes to finish - use when doing a fast shutdown.\newline \newline","675746","dictionary.c","Afdict_class * afdict_find(Dictionary afdict, const char * con, bool notify_err)\newline{\newline	const char ** ac;\newline\newline	for (ac = afdict_classname;\newline	     ac &lt &ampafdict_classname[ARRAY_SIZE(afdict_classname)]; ac++)\newline	{\newline		if (0 == strcmp(*ac, con))\newline			return &ampafdict-&gtafdict_class[ac - afdict_classname];\newline	}\newline	if (notify_err) {\newline		prt_error(&quotWarning: Unknown class name %s found near line %d of %s.\\n&quot\newline		          &quot\\tThis class name will be ignored.\\n&quot,\newline		          con, afdict-&gtline_number, afdict-&gtname);\newline	}\newline	return NULL;\newline}\newline","\newline Find the affix table entry for given connector name.\newline If the connector name is not in the table, return NULL.\newline \newline","3068865","nxstoken.h","inline const char *NxsToken::GetTokenAsCStr(\newline  bool respect_case)	/* determines whether token is converted to upper case before being returned */\newline	{\newline	if (!respect_case)\newline		ToUpper();\newline\newline	return token.c_str();\newline	}\newline","!\newline Returns the data member `token&#039 as a C-style string. Specifying false for`respect_case&#039 parameter causes all\newline characters in `token&#039 to be converted to upper case before the `token&#039 C-string is returned. Specifying true\newline results in GetTokenAsCStr returning exactly what it read from the file.\newline \newline","5034941","utility_funcs.c","int g15daemon_cfg_remove_key(config_section_t *section, char *key){\newline    \newline    config_items_t *new = NULL;\newline    config_items_t *next = NULL;\newline    config_items_t *prev = NULL;\newline    if(section==NULL)\newline        return -1;\newline    \newline    if((uf_search_confitem(section, key))){\newline        new=uf_search_confitem(section, key);\newline        prev=new-&gtprev;\newline        next=new-&gtnext;\newline        if(prev){\newline            prev-&gtnext=new-&gtnext;\newline        }else{\newline             if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline                else\newline                    section-&gtitems=next;\newline            }\newline\newline        if(new-&gthead==new){\newline            if(prev){\newline                prev-&gthead = prev;\newline                section-&gtitems-&gthead=prev;\newline            }\newline            if(!prev){\newline                if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline            }\newline        }\newline        if(next){\newline            if(prev)\newline            	next-&gtprev=prev;\newline            else\newline                next-&gtprev=NULL;\newline        }\newline        free(new-&gtkey);\newline        free(new-&gtvalue);\newline        free(new);\newline    }\newline    return 0;\newline}\newline","remoe a key/value pair from named section \newline","6572891","lomoco.c","static void query (mouse_t *m, struct usb_device *device) {\newline	usb_dev_handle *handle;\newline	unsigned int  addr;\newline\newline	/*\newline	 * For dual receivers C502, C504 and C505, the mouse is the\newline	 * second device and uses an addr of 1 in the value and index\newline	 * fields&#039 high byte. 1 &lt&lt 8\newline	 */\newline	addr = m-&gtis_dual ? 1 &lt&lt 8 : 0;\newline\newline	/* Try to open the device */\newline	handle = usb_open (device);\newline\newline	if (handle == NULL) {\newline		perror (&quotError opening USB device&quot);\newline		exit (EXIT_FAILURE);\newline	}\newline\newline	/* Parse CSR Status (this one&#039s huge) \newline	*  for wireless mouse\newline	*/\newline	if (m-&gthas_csr) {\newline		query_csr(m, handle, addr);\newline	}\newline\newline\newline	/* The RES extension */\newline	if (m-&gthas_res) {\newline		query_res(m, handle, addr);\newline	}\newline	\newline\newline	/* The SMS extension */\newline	if (m-&gthas_sms) {\newline		query_sms(m, handle, addr);\newline	}\newline\newline	query_usb(m, device);\newline\newline	printf (&quot\\n&quot);\newline\newline	(void) usb_close (handle);\newline}\newline","\newline Description: print mouse specific things like current resolution, \newline state of sms, and for wireless mouse additional: \newline receiver type, battery strenght and so on\newline \newline Parameters: mouse_t m\newline struct with the mouse specs\newline usb_device device\newline the device which should be queried\newline \newline Retrun: void\newline \newline","6511628","jar.c","JarFile* jclass_jar_open(const char *zipfile)\newline{\newline	/* allocate */\newline	JarFile *zip = (JarFile *) malloc (sizeof (JarFile));\newline\newline	/* open */\newline	zip-&gtfp = my_open (zipfile, &quotrb&quot);\newline	if (zip-&gtfp == NULL)\newline	{\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* go to end */\newline	if (fseek (zip-&gtfp, 0L, SEEK_END) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* get length */\newline	zip-&gtlength = ftell (zip-&gtfp);\newline	if (zip-&gtlength &lt= 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read ecd data */\newline	if (ecd_read (zip) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* compile ecd info */\newline	zip-&gtend_of_cent_dir_sig = read_dword (zip-&gtecd + ZIPESIG);\newline	zip-&gtnumber_of_this_disk = read_word (zip-&gtecd + ZIPEDSK);\newline	zip-&gtnumber_of_disk_start_cent_dir = read_word (zip-&gtecd + ZIPECEN);\newline	zip-&gttotal_entries_cent_dir_this_disk =\newline		read_word (zip-&gtecd + ZIPENUM);\newline	zip-&gttotal_entries_cent_dir = read_word (zip-&gtecd + ZIPECENN);\newline	zip-&gtsize_of_cent_dir = read_dword (zip-&gtecd + ZIPECSZ);\newline	zip-&gtoffset_to_start_of_cent_dir = read_dword (zip-&gtecd + ZIPEOFST);\newline\newline	/* verify that we can work with this zipfile (no disk spanning allowed) */\newline	if ((zip-&gtnumber_of_this_disk != zip-&gtnumber_of_disk_start_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir_this_disk !=\newline		zip-&gttotal_entries_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir &lt 1))\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fseek (zip-&gtfp, zip-&gtoffset_to_start_of_cent_dir, SEEK_SET) != 0)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read from start of central directory */\newline	zip-&gtcd = (char *) malloc (zip-&gtsize_of_cent_dir);\newline	if (zip-&gtcd == NULL)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fread (zip-&gtcd, zip-&gtsize_of_cent_dir, 1, zip-&gtfp) != 1)\newline	{\newline		free (zip-&gtcd);\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* reset ent */\newline	zip-&gtent.name = NULL;\newline\newline	/* rewind */\newline	zip-&gtcd_pos = 0;\newline\newline	return zip;\newline}\newline","\newline jclass_jar_open\newline @filename: The filename for the jar file.\newline \newline Opens a jar stream for reading.\newline \newline Returns: A newly allocated jar stream on success,\newline or NULL if any error occured.\newline \newline","2152693","rolodex.c","int insertPhoneEntryCB (EObjectType cdkType GCC_UNUSED, void *object, void\newline			*clientData, chtype key GCC_UNUSED)\newline{\newline   /* Declare local variables. */\newline   CDKSCROLL *scrollp = (CDKSCROLL *)object;\newline   SPhoneData *phoneData = (SPhoneData *) clientData;\newline   SPhoneRecord *phoneRecord = &ampphoneData-&gtrecord[phoneData-&gtrecordCount];\newline   char temp[MYSIZE];\newline\newline   /* Make the scrolling list disappear. */\newline   eraseCDKScroll (scrollp);\newline\newline   /* Call the function which gets phone record information. */\newline   if (addPhoneRecord (ScreenOf (scrollp), phoneData) == 0)\newline   {\newline      sprintf (temp, &quot%s (%s)&quot, phoneRecord-&gtname, GLineType[phoneRecord-&gtlineType]);\newline      addCDKScrollItem (scrollp, temp);\newline   }\newline\newline   /* Redraw the scrolling list. */\newline   drawCDKScroll (scrollp, ObjOf (scrollp)-&gtbox);\newline   return (FALSE);\newline}\newline","\newline This allows the user to insert a new phone entry into the database.\newline \newline","5131880","fnotifystat.c","static void show_usage(void)\newline{\newline	printf(&quot%s, version %s\\n\\n&quot, app_name, VERSION);\newline	printf(&quotOptions are:\\n&quot\newline		&quot  -c     cumulative totals over time\\n&quot\newline		&quot  -d     strip directory off the filenames\\n&quot\newline		&quot  -D     order stats by unique device\\n&quot\newline		&quot  -f     force output\\n&quot\newline		&quot  -h     show this help\\n&quot\newline		&quot  -i     specify pathnames to include on path events\\n&quot\newline		&quot  -I     order stats by unique device and inode\\n&quot\newline		&quot  -m     merge events on same file and pid in same second\\n&quot\newline		&quot  -n     no stats, just -v verbose mode only\\n&quot\newline		&quot  -p PID collect stats for just process with pid PID\\n&quot\newline		&quot  -P     sort stats by process ID\\n&quot\newline		&quot  -s     disable scaling of file counts\\n&quot\newline		&quot  -t N   show just the busiest N files\\n&quot\newline		&quot  -T     show timestamp\\n&quot\newline		&quot  -v     verbose mode, dump out all file activity\\n&quot\newline		&quot  -x     specify pathnames to exclude on path events\\n&quot);\newline}\newline","\newline show_usage()\newline how to use\newline \newline","1461728","plustek-pp_image.c","static void fnDataDirect( pScanData ps, pVoid pBuf, pVoid pImg, ULong bl )\newline{\newline	_VAR_NOT_USED( ps );\newline	memcpy( pBuf, pImg, bl );\newline}\newline","This routine used in the condition:\newline 1) The data type is B/W or GrayScale.\newline 2) The required horizontal resolution doesn&#039t exceed the optic spec.\newline 3) The required vertical resolution exceeds the optic spec.\newline So, the vertcal lines have to average with previous line to smooth the\newline image.\newline \newline","","","","","","","","","","","","","on","on","","","on","on","","on","on","","","","","","","","","","","","","","","","","","","","","","Determines if a generic functionmethod can be deleted","Disable/enable mtab update","Finalize ARMCI.","returns LONG_MAX iff out of memory","Cancels waiting for processes to finish","Find the affix table entry for given connector name.","Returns the data member `token' as a C-style string.","remoe a key/value pair","print mouse specific things","Opens a jar stream for reading.","allows the user to insert a new phone entry into the database.","returns the inp-house number,","{}","{}","Stochastically choose an alignment endpoint,","accumulate info","{}","{}","Searches global FSM variable list for matching FSM variable structure.","{}","{}"
"3E9ZFLPWOYSQTBRDV0445HES5PDXI5","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3S06PH7KSR43IJNRMVNN8UQ3OR91DY","A18JD2MXWESMG7","Approved","Wed Apr 17 09:52:55 PDT 2019","Wed Apr 17 10:01:38 PDT 2019","Fri Apr 19 10:01:38 PDT 2019","2019-04-19 17:02:21 UTC","","","523","100% (1/1)","100% (1/1)","100% (1/1)","6006719","genrccom.c","globle int EnvIsDefmethodDeletable(\newline  void *theEnv,\newline  void *ptr,\newline  unsigned theIndex)\newline  {\newline   if (! ConstructsDeletable(theEnv))\newline     { return FALSE; }\newline\newline   if (((DEFGENERIC *) ptr)-&gtmethods[FindMethodByIndex((DEFGENERIC *) ptr,theIndex)].system)\newline     return(FALSE);\newline   \newline#if (! BLOAD_ONLY) &amp&amp (! RUN_TIME)\newline   return((MethodsExecuting((DEFGENERIC *) ptr) == FALSE) ? TRUE : FALSE);\newline#else\newline   return FALSE;\newline#endif\newline  }\newline","\newlineNAME : EnvIsDefmethodDeletable\newlineDESCRIPTION : Determines if a generic function\newlinemethod can be deleted\newlineINPUTS : 1) Address of the generic function\newline2) Index of the method\newlineRETURNS : TRUE if deletable, FALSE otherwise\newlineSIDE EFFECTS : None\newlineNOTES : None\newline \newline","3330891","swepcalc.c","int InpHouseNr (struct houses *hsp, CSEC pp, CSEC *coff)\newline{ \newline  CSEC cx;\newline  int i = 2;\newline  cx = swe_difcsn(pp, hsp-&gtcusp [1] + coff [1]); \newline  while(i&lt13 &amp&amp  cx &gt= swe_difcsn(hsp-&gtcusp[i] + coff[i], hsp-&gtcusp[1] + coff[1])) \newline    i++;\newline  return (i - 1);\newline}\newline","\newlinereturns the inp-house number, where pp is in \newlinehouses are numbered from 1 .. 12\newline \newline","1025475","site_sample.c","static int pick_endpoint(const score_matrices *sm, int width,\newline			 int seq_len, int strand) {\newline  double **dp_mat = strand == &#039+&#039 ? sm-&gtdp_mat : sm-&gtrc_mat;\newline\newline  if (strand == 0)  /* the sequence is unaligned */\newline    return -1;  /* dummy value, hopefully never used */\newline\newline  return pick_dbl(dp_mat[width], seq_len+1) - dp_mat[width];\newline}\newline","Stochastically choose an alignment endpoint, using the DP matrix \newline","4357976","describe.c","static Error traverse(Object o, struct info *ip, int nosee)\newline{\newline    Object subo;\newline    Class curclass;\newline    int i;\newline\newline    switch (curclass = DXGetObjectClass(o)) {\newline      case CLASS_FIELD:\newline	return validfield((Field)o, ip, nosee);\newline	\newline      case CLASS_GROUP:\newline	/* traverse members */\newline	for (i=0; (subo = DXGetEnumeratedMember((Group)o, i, NULL)); i++) {\newline	    if (!traverse(subo, ip, nosee))\newline		return ERROR;\newline	}\newline	break;\newline	\newline      case CLASS_SCREEN:\newline	if (!DXGetScreenInfo((Screen)o, &ampsubo, NULL, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, 1);\newline\newline      case CLASS_XFORM:\newline	if (!DXGetXformInfo((Xform)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);\newline\newline      case CLASS_CLIPPED:\newline	if (!DXGetClippedInfo((Clipped)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);  /* is this right? */\newline\newline      case CLASS_LIGHT:\newline	ip-&gtri.nlights++;\newline	break;\newline	\newline      case CLASS_INTERPOLATOR:\newline      case CLASS_MAX:\newline      case CLASS_MIN:\newline      case CLASS_PRIVATE:\newline      case CLASS_DELETED:\newline      case CLASS_STRING:\newline      case CLASS_ARRAY:\newline      case CLASS_CAMERA:	\newline      default:\newline	for (i=0; i&ltip-&gtri.badobjs; i++) {\newline	    if (ip-&gtri.badclass[i] == curclass)\newline		return OK;\newline	}\newline	ip-&gtri.badobjs++;\newline	ip-&gtri.badclass = (Class *)DXReAllocate((Pointer)ip-&gtri.badclass, \newline						sizeof(Class) * ip-&gtri.badobjs);\newline	ip-&gtri.badclass[ip-&gtri.badobjs - 1] = curclass;\newline\newline	break;\newline    }\newline\newline    return OK;\newline}\newline","accumulate info about what&#039s what\newline \newline","1446123","fdd.c","int fdd_scanvar(BDD r, int var)\newline{\newline   int *allvar;\newline   int res;\newline\newline   CHECK(r);\newline   if (r == bddfalse)\newline      return -1;\newline   if (var &lt 0  ||  var &gt= fdvarnum)\newline      return bdd_error(BDD_VAR);\newline\newline   allvar = fdd_scanallvar(r);\newline   res = allvar[var];\newline   free(allvar);\newline\newline   return res;\newline}\newline","\newlineNAME { fdd\\_scanvar }\newlineSECTION { fdd }\newlineSHORT { Finds one satisfying value of a FDD variable }\newlinePROTO { int fdd_scanvar(BDD r, int var) }\newlineDESCR { Finds one satisfying assignment of the FDD variable {\\tt var} in the\newlineBDD {\\tt r} and returns this value. }\newlineRETURN { The value of a satisfying assignment of {\\tt var}. If {\\tt r} is\newlinethe trivially false BDD, then a negative value is returned. }\newlineALSO { fdd\\_scanallvar }\newline \newline","5179064","xml_relax_ng.c","static VALUE validate_document(VALUE self, VALUE document)\newline{\newline  xmlDocPtr doc;\newline  xmlRelaxNGPtr schema;\newline  VALUE errors;\newline  xmlRelaxNGValidCtxtPtr valid_ctxt;\newline\newline  Data_Get_Struct(self, xmlRelaxNG, schema);\newline  Data_Get_Struct(document, xmlDoc, doc);\newline\newline  errors = rb_ary_new();\newline\newline  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\newline\newline  if(NULL == valid_ctxt) {\newline    /* we have a problem */\newline    rb_raise(rb_eRuntimeError, &quotCould not create a validation context&quot);\newline  }\newline\newline#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\newline  xmlRelaxNGSetValidStructuredErrors(\newline    valid_ctxt,\newline    Nokogiri_error_array_pusher,\newline    (void *)errors\newline  );\newline#endif\newline\newline  xmlRelaxNGValidateDoc(valid_ctxt, doc);\newline\newline  xmlRelaxNGFreeValidCtxt(valid_ctxt);\newline\newline  return errors;\newline}\newline","\newline call-seq:\newline validate_document(document)\newline \newline Validate a Nokogiri::XML::Document against this RelaxNG schema.\newline \newline","4854568","fsm_var.c","void fsm_var_remove(\newline  fsm_var* fv  /*!&lt Pointer to FSM variable structure to remove from global list */\newline) { PROFILE(FSM_VAR_REMOVE);\newline\newline  fsm_var* curr;  /* Pointer to current FSM variable structure in list */\newline  fsm_var* last;  /* Pointer to last FSM variable structure evaluated */\newline\newline  /* Find matching FSM variable structure */\newline  curr = fsm_var_head;\newline  last = NULL;\newline  while( (curr != NULL) &amp&amp (curr != fv) ) {\newline    last = curr;\newline    curr = curr-&gtnext;\newline  }\newline\newline  /* If a matching FSM variable structure was found, remove it from the global list. */\newline  if( curr != NULL ) {\newline\newline    if( (curr == fsm_var_head) &amp&amp (curr == fsm_var_tail) ) {\newline      fsm_var_head = fsm_var_tail = NULL;\newline    } else if( curr == fsm_var_head ) {\newline      fsm_var_head = curr-&gtnext;\newline    } else if( curr == fsm_var_tail ) {\newline      fsm_var_tail = last;\newline    } else {\newline      last-&gtnext = curr-&gtnext;\newline    }\newline\newline    fsm_var_dealloc( curr );\newline\newline  }\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineSearches global FSM variable list for matching FSM variable structure.\newlineWhen match is found, remove the structure and deallocate it from memory\newlinebeing sure to keep the global list intact.\newline \newline","1078422","audio_alsa_out.c","static int my_snd_mixer_wait(snd_mixer_t *mixer, int timeout) {\newline  struct pollfd  spfds[16];\newline  struct pollfd *pfds = spfds;\newline  int            err, count;\newline\newline  count = snd_mixer_poll_descriptors(mixer, pfds, sizeof(spfds) / sizeof(spfds[0]));\newline\newline  if (count &lt 0)\newline    return count;\newline\newline  if ((unsigned int) count &gt sizeof(spfds) / sizeof(spfds[0])) {\newline    pfds = calloc(count, sizeof(*pfds));\newline\newline    if (!pfds)\newline      return -ENOMEM;\newline\newline    err = snd_mixer_poll_descriptors(mixer, pfds, (unsigned int) count);\newline    assert(err == count);\newline  }\newline\newline  err = poll(pfds, (unsigned int) count, timeout);\newline\newline  if (err &lt 0)\newline    return -errno;\newline\newline  return err;\newline}\newline","Stolen from alsa-lib \newline","5137482","rfc1035.c","int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, \newline			     struct bogus_addr *baddr, time_t now)\newline{\newline  unsigned char *p;\newline  int i, qtype, qclass, rdlen;\newline  unsigned long ttl;\newline  struct bogus_addr *baddrp;\newline\newline  /* skip over questions */\newline  if (!(p = skip_questions(header, qlen)))\newline    return 0; /* bad packet */\newline\newline  for (i = ntohs(header-&gtancount); i != 0; i--)\newline    {\newline      if (!extract_name(header, qlen, &ampp, name, 1, 10))\newline	return 0; /* bad packet */\newline  \newline      GETSHORT(qtype, p); \newline      GETSHORT(qclass, p);\newline      GETLONG(ttl, p);\newline      GETSHORT(rdlen, p);\newline      \newline      if (qclass == C_IN &amp&amp qtype == T_A)\newline	{\newline	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))\newline	    return 0;\newline	  \newline	  for (baddrp = baddr; baddrp; baddrp = baddrp-&gtnext)\newline	    if (memcmp(&ampbaddrp-&gtaddr, p, INADDRSZ) == 0)\newline	      {\newline		/* Found a bogus address. Insert that info here, since there no SOA record\newline		   to get the ttl from in the normal processing */\newline		cache_start_insert();\newline		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);\newline		cache_end_insert();\newline		\newline		return 1;\newline	      }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, qlen, rdlen))\newline	return 0;\newline    }\newline  \newline  return 0;\newline}\newline","Is the packet a reply with the answer address equal to addr?\newlineIf so mung is into an NXDOMAIN reply and also put that information\newlinein the cache. \newline","4945349","context.c","int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable)\newline{\newline	return set_flag(cxt, MNT_FL_NOMTAB, disable);\newline}\newline","\newline mnt_context_disable_mtab:\newline @cxt: mount context\newline @disable: TRUE or FALSE\newline \newline Disable/enable mtab update (see mount(8) man page, option -n).\newline \newline Returns: 0 on success, negative number in case of error.\newline \newline","3007780","init_finalize.c","int PARMCI_Finalize(void) {\newline  int nfreed;\newline\newline  /* GA/TCGMSG end up calling ARMCI_Finalize() multiple times. */\newline  if (ARMCII_GLOBAL_STATE.init_count == 0) {\newline    return 0;\newline  }\newline\newline  ARMCII_GLOBAL_STATE.init_count--;\newline\newline  /* Only finalize on the last matching call */\newline  if (ARMCII_GLOBAL_STATE.init_count &gt 0) {\newline    return 0;\newline  }\newline\newline#ifdef HAVE_PTHREADS\newline    /* Destroy the asynchronous progress thread */\newline    {\newline        if(ARMCII_GLOBAL_STATE.progress_thread) {\newline            progress_active = 0;\newline            int rc = pthread_join(ARMCI_Progress_thread, NULL);\newline            if (rc) {\newline                ARMCII_Warning(&quotARMCI progress thread join failed (%d).\\n&quot, rc);\newline            }\newline        }\newline    }\newline#endif\newline\newline  nfreed = gmr_destroy_all();\newline\newline  if (nfreed &gt 0 &amp&amp ARMCI_GROUP_WORLD.rank == 0)\newline    ARMCII_Warning(&quotFreed %d leaked allocations\\n&quot, nfreed);\newline\newline  /* Free GOP operators */\newline\newline  MPI_Op_free(&ampMPI_ABSMIN_OP);\newline  MPI_Op_free(&ampMPI_ABSMAX_OP);\newline\newline  MPI_Op_free(&ampMPI_SELMIN_OP);\newline  MPI_Op_free(&ampMPI_SELMAX_OP);\newline\newline  ARMCI_Cleanup();\newline\newline  ARMCI_Group_free(&ampARMCI_GROUP_WORLD);\newline\newline  return 0;\newline}\newline","Finalize ARMCI. Must be called before MPI is finalized. ARMCI calls are\newline not valid after finalization. Collective on world group.\newline \newline @return Zero on success\newline \newline","1491823","priorityq-heap.cpp","PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )\newline{\newline  long curr;\newline  PQhandle free_handle;\newline\newline  curr = ++ pq-&gtsize;\newline  if( (curr*2) &gt pq-&gtmax ) {\newline    PQnode *saveNodes= pq-&gtnodes;\newline    PQhandleElem *saveHandles= pq-&gthandles;\newline\newline    /* If the heap overflows, double its size. */\newline    pq-&gtmax &lt&lt= 1;\newline    pq-&gtnodes = (PQnode *)memRealloc( pq-&gtnodes, \newline				     (size_t) \newline				     ((pq-&gtmax + 1) * sizeof( pq-&gtnodes[0] )));\newline    if (pq-&gtnodes == NULL) {\newline       pq-&gtnodes = saveNodes;	/* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline    pq-&gthandles = (PQhandleElem *)memRealloc( pq-&gthandles,\newline			                     (size_t)\newline			                      ((pq-&gtmax + 1) * \newline					       sizeof( pq-&gthandles[0] )));\newline    if (pq-&gthandles == NULL) {\newline       pq-&gthandles = saveHandles; /* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline  }\newline\newline  if( pq-&gtfreeList == 0 ) {\newline    free_handle = curr;\newline  } else {\newline    free_handle = pq-&gtfreeList;\newline    pq-&gtfreeList = pq-&gthandles[free_handle].node;\newline  }\newline\newline  pq-&gtnodes[curr].handle = free_handle;\newline  pq-&gthandles[free_handle].node = curr;\newline  pq-&gthandles[free_handle].key = keyNew;\newline\newline  if( pq-&gtinitialized ) {\newline    FloatUp( pq, curr );\newline  }\newline  assert(free_handle != LONG_MAX);\newline  return free_handle;\newline}\newline","returns LONG_MAX iff out of memory \newline","557191","bbrun.c","void bb_run_stopwaiting(void){\newline  dowait = 0;\newline}\newline","\newline Cancels waiting for processes to finish - use when doing a fast shutdown.\newline \newline","675746","dictionary.c","Afdict_class * afdict_find(Dictionary afdict, const char * con, bool notify_err)\newline{\newline	const char ** ac;\newline\newline	for (ac = afdict_classname;\newline	     ac &lt &ampafdict_classname[ARRAY_SIZE(afdict_classname)]; ac++)\newline	{\newline		if (0 == strcmp(*ac, con))\newline			return &ampafdict-&gtafdict_class[ac - afdict_classname];\newline	}\newline	if (notify_err) {\newline		prt_error(&quotWarning: Unknown class name %s found near line %d of %s.\\n&quot\newline		          &quot\\tThis class name will be ignored.\\n&quot,\newline		          con, afdict-&gtline_number, afdict-&gtname);\newline	}\newline	return NULL;\newline}\newline","\newline Find the affix table entry for given connector name.\newline If the connector name is not in the table, return NULL.\newline \newline","3068865","nxstoken.h","inline const char *NxsToken::GetTokenAsCStr(\newline  bool respect_case)	/* determines whether token is converted to upper case before being returned */\newline	{\newline	if (!respect_case)\newline		ToUpper();\newline\newline	return token.c_str();\newline	}\newline","!\newline Returns the data member `token&#039 as a C-style string. Specifying false for`respect_case&#039 parameter causes all\newline characters in `token&#039 to be converted to upper case before the `token&#039 C-string is returned. Specifying true\newline results in GetTokenAsCStr returning exactly what it read from the file.\newline \newline","5034941","utility_funcs.c","int g15daemon_cfg_remove_key(config_section_t *section, char *key){\newline    \newline    config_items_t *new = NULL;\newline    config_items_t *next = NULL;\newline    config_items_t *prev = NULL;\newline    if(section==NULL)\newline        return -1;\newline    \newline    if((uf_search_confitem(section, key))){\newline        new=uf_search_confitem(section, key);\newline        prev=new-&gtprev;\newline        next=new-&gtnext;\newline        if(prev){\newline            prev-&gtnext=new-&gtnext;\newline        }else{\newline             if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline                else\newline                    section-&gtitems=next;\newline            }\newline\newline        if(new-&gthead==new){\newline            if(prev){\newline                prev-&gthead = prev;\newline                section-&gtitems-&gthead=prev;\newline            }\newline            if(!prev){\newline                if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline            }\newline        }\newline        if(next){\newline            if(prev)\newline            	next-&gtprev=prev;\newline            else\newline                next-&gtprev=NULL;\newline        }\newline        free(new-&gtkey);\newline        free(new-&gtvalue);\newline        free(new);\newline    }\newline    return 0;\newline}\newline","remoe a key/value pair from named section \newline","6572891","lomoco.c","static void query (mouse_t *m, struct usb_device *device) {\newline	usb_dev_handle *handle;\newline	unsigned int  addr;\newline\newline	/*\newline	 * For dual receivers C502, C504 and C505, the mouse is the\newline	 * second device and uses an addr of 1 in the value and index\newline	 * fields&#039 high byte. 1 &lt&lt 8\newline	 */\newline	addr = m-&gtis_dual ? 1 &lt&lt 8 : 0;\newline\newline	/* Try to open the device */\newline	handle = usb_open (device);\newline\newline	if (handle == NULL) {\newline		perror (&quotError opening USB device&quot);\newline		exit (EXIT_FAILURE);\newline	}\newline\newline	/* Parse CSR Status (this one&#039s huge) \newline	*  for wireless mouse\newline	*/\newline	if (m-&gthas_csr) {\newline		query_csr(m, handle, addr);\newline	}\newline\newline\newline	/* The RES extension */\newline	if (m-&gthas_res) {\newline		query_res(m, handle, addr);\newline	}\newline	\newline\newline	/* The SMS extension */\newline	if (m-&gthas_sms) {\newline		query_sms(m, handle, addr);\newline	}\newline\newline	query_usb(m, device);\newline\newline	printf (&quot\\n&quot);\newline\newline	(void) usb_close (handle);\newline}\newline","\newline Description: print mouse specific things like current resolution, \newline state of sms, and for wireless mouse additional: \newline receiver type, battery strenght and so on\newline \newline Parameters: mouse_t m\newline struct with the mouse specs\newline usb_device device\newline the device which should be queried\newline \newline Retrun: void\newline \newline","6511628","jar.c","JarFile* jclass_jar_open(const char *zipfile)\newline{\newline	/* allocate */\newline	JarFile *zip = (JarFile *) malloc (sizeof (JarFile));\newline\newline	/* open */\newline	zip-&gtfp = my_open (zipfile, &quotrb&quot);\newline	if (zip-&gtfp == NULL)\newline	{\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* go to end */\newline	if (fseek (zip-&gtfp, 0L, SEEK_END) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* get length */\newline	zip-&gtlength = ftell (zip-&gtfp);\newline	if (zip-&gtlength &lt= 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read ecd data */\newline	if (ecd_read (zip) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* compile ecd info */\newline	zip-&gtend_of_cent_dir_sig = read_dword (zip-&gtecd + ZIPESIG);\newline	zip-&gtnumber_of_this_disk = read_word (zip-&gtecd + ZIPEDSK);\newline	zip-&gtnumber_of_disk_start_cent_dir = read_word (zip-&gtecd + ZIPECEN);\newline	zip-&gttotal_entries_cent_dir_this_disk =\newline		read_word (zip-&gtecd + ZIPENUM);\newline	zip-&gttotal_entries_cent_dir = read_word (zip-&gtecd + ZIPECENN);\newline	zip-&gtsize_of_cent_dir = read_dword (zip-&gtecd + ZIPECSZ);\newline	zip-&gtoffset_to_start_of_cent_dir = read_dword (zip-&gtecd + ZIPEOFST);\newline\newline	/* verify that we can work with this zipfile (no disk spanning allowed) */\newline	if ((zip-&gtnumber_of_this_disk != zip-&gtnumber_of_disk_start_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir_this_disk !=\newline		zip-&gttotal_entries_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir &lt 1))\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fseek (zip-&gtfp, zip-&gtoffset_to_start_of_cent_dir, SEEK_SET) != 0)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read from start of central directory */\newline	zip-&gtcd = (char *) malloc (zip-&gtsize_of_cent_dir);\newline	if (zip-&gtcd == NULL)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fread (zip-&gtcd, zip-&gtsize_of_cent_dir, 1, zip-&gtfp) != 1)\newline	{\newline		free (zip-&gtcd);\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* reset ent */\newline	zip-&gtent.name = NULL;\newline\newline	/* rewind */\newline	zip-&gtcd_pos = 0;\newline\newline	return zip;\newline}\newline","\newline jclass_jar_open\newline @filename: The filename for the jar file.\newline \newline Opens a jar stream for reading.\newline \newline Returns: A newly allocated jar stream on success,\newline or NULL if any error occured.\newline \newline","2152693","rolodex.c","int insertPhoneEntryCB (EObjectType cdkType GCC_UNUSED, void *object, void\newline			*clientData, chtype key GCC_UNUSED)\newline{\newline   /* Declare local variables. */\newline   CDKSCROLL *scrollp = (CDKSCROLL *)object;\newline   SPhoneData *phoneData = (SPhoneData *) clientData;\newline   SPhoneRecord *phoneRecord = &ampphoneData-&gtrecord[phoneData-&gtrecordCount];\newline   char temp[MYSIZE];\newline\newline   /* Make the scrolling list disappear. */\newline   eraseCDKScroll (scrollp);\newline\newline   /* Call the function which gets phone record information. */\newline   if (addPhoneRecord (ScreenOf (scrollp), phoneData) == 0)\newline   {\newline      sprintf (temp, &quot%s (%s)&quot, phoneRecord-&gtname, GLineType[phoneRecord-&gtlineType]);\newline      addCDKScrollItem (scrollp, temp);\newline   }\newline\newline   /* Redraw the scrolling list. */\newline   drawCDKScroll (scrollp, ObjOf (scrollp)-&gtbox);\newline   return (FALSE);\newline}\newline","\newline This allows the user to insert a new phone entry into the database.\newline \newline","5131880","fnotifystat.c","static void show_usage(void)\newline{\newline	printf(&quot%s, version %s\\n\\n&quot, app_name, VERSION);\newline	printf(&quotOptions are:\\n&quot\newline		&quot  -c     cumulative totals over time\\n&quot\newline		&quot  -d     strip directory off the filenames\\n&quot\newline		&quot  -D     order stats by unique device\\n&quot\newline		&quot  -f     force output\\n&quot\newline		&quot  -h     show this help\\n&quot\newline		&quot  -i     specify pathnames to include on path events\\n&quot\newline		&quot  -I     order stats by unique device and inode\\n&quot\newline		&quot  -m     merge events on same file and pid in same second\\n&quot\newline		&quot  -n     no stats, just -v verbose mode only\\n&quot\newline		&quot  -p PID collect stats for just process with pid PID\\n&quot\newline		&quot  -P     sort stats by process ID\\n&quot\newline		&quot  -s     disable scaling of file counts\\n&quot\newline		&quot  -t N   show just the busiest N files\\n&quot\newline		&quot  -T     show timestamp\\n&quot\newline		&quot  -v     verbose mode, dump out all file activity\\n&quot\newline		&quot  -x     specify pathnames to exclude on path events\\n&quot);\newline}\newline","\newline show_usage()\newline how to use\newline \newline","1461728","plustek-pp_image.c","static void fnDataDirect( pScanData ps, pVoid pBuf, pVoid pImg, ULong bl )\newline{\newline	_VAR_NOT_USED( ps );\newline	memcpy( pBuf, pImg, bl );\newline}\newline","This routine used in the condition:\newline 1) The data type is B/W or GrayScale.\newline 2) The required horizontal resolution doesn&#039t exceed the optic spec.\newline 3) The required vertical resolution exceeds the optic spec.\newline So, the vertcal lines have to average with previous line to smooth the\newline image.\newline \newline","","","on","","","on","","","","","","","on","on","","","","on","","on","on","","","","","","","","","","","","","","","","","on","","","","","Determines if a generic functionmethod can be deleted","Disable/enable mtab update","{}","returns LONG_MAX iff out of memory","Cancels waiting for processes to finish","{}","Returns the data member `token' as a C-style string.","remoe a key/value pair from named section","print mouse specific things like current resolution, state of sms,","Opens a jar stream for reading.","allows the user to insert a new phone entry into the database.","returns the inp-house number,","{}","{}","Stochastically choose an alignment endpoint,","accumulate info about what's what","Finds one satisfying value of a FDD variable","{}","Searches global FSM variable list for matching FSM variable structure.","{}","{}"
"3E9ZFLPWOYSQTBRDV0445HES5PDXI5","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3TE3O85730848EOSN0ILI2HCVZG2RQ","A2RU4CSRZTTWD7","Approved","Wed Apr 17 12:05:54 PDT 2019","Wed Apr 17 12:19:42 PDT 2019","Fri Apr 19 12:19:42 PDT 2019","2019-04-19 19:20:21 UTC","","","828","100% (1/1)","100% (1/1)","100% (1/1)","6006719","genrccom.c","globle int EnvIsDefmethodDeletable(\newline  void *theEnv,\newline  void *ptr,\newline  unsigned theIndex)\newline  {\newline   if (! ConstructsDeletable(theEnv))\newline     { return FALSE; }\newline\newline   if (((DEFGENERIC *) ptr)-&gtmethods[FindMethodByIndex((DEFGENERIC *) ptr,theIndex)].system)\newline     return(FALSE);\newline   \newline#if (! BLOAD_ONLY) &amp&amp (! RUN_TIME)\newline   return((MethodsExecuting((DEFGENERIC *) ptr) == FALSE) ? TRUE : FALSE);\newline#else\newline   return FALSE;\newline#endif\newline  }\newline","\newlineNAME : EnvIsDefmethodDeletable\newlineDESCRIPTION : Determines if a generic function\newlinemethod can be deleted\newlineINPUTS : 1) Address of the generic function\newline2) Index of the method\newlineRETURNS : TRUE if deletable, FALSE otherwise\newlineSIDE EFFECTS : None\newlineNOTES : None\newline \newline","3330891","swepcalc.c","int InpHouseNr (struct houses *hsp, CSEC pp, CSEC *coff)\newline{ \newline  CSEC cx;\newline  int i = 2;\newline  cx = swe_difcsn(pp, hsp-&gtcusp [1] + coff [1]); \newline  while(i&lt13 &amp&amp  cx &gt= swe_difcsn(hsp-&gtcusp[i] + coff[i], hsp-&gtcusp[1] + coff[1])) \newline    i++;\newline  return (i - 1);\newline}\newline","\newlinereturns the inp-house number, where pp is in \newlinehouses are numbered from 1 .. 12\newline \newline","1025475","site_sample.c","static int pick_endpoint(const score_matrices *sm, int width,\newline			 int seq_len, int strand) {\newline  double **dp_mat = strand == &#039+&#039 ? sm-&gtdp_mat : sm-&gtrc_mat;\newline\newline  if (strand == 0)  /* the sequence is unaligned */\newline    return -1;  /* dummy value, hopefully never used */\newline\newline  return pick_dbl(dp_mat[width], seq_len+1) - dp_mat[width];\newline}\newline","Stochastically choose an alignment endpoint, using the DP matrix \newline","4357976","describe.c","static Error traverse(Object o, struct info *ip, int nosee)\newline{\newline    Object subo;\newline    Class curclass;\newline    int i;\newline\newline    switch (curclass = DXGetObjectClass(o)) {\newline      case CLASS_FIELD:\newline	return validfield((Field)o, ip, nosee);\newline	\newline      case CLASS_GROUP:\newline	/* traverse members */\newline	for (i=0; (subo = DXGetEnumeratedMember((Group)o, i, NULL)); i++) {\newline	    if (!traverse(subo, ip, nosee))\newline		return ERROR;\newline	}\newline	break;\newline	\newline      case CLASS_SCREEN:\newline	if (!DXGetScreenInfo((Screen)o, &ampsubo, NULL, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, 1);\newline\newline      case CLASS_XFORM:\newline	if (!DXGetXformInfo((Xform)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);\newline\newline      case CLASS_CLIPPED:\newline	if (!DXGetClippedInfo((Clipped)o, &ampsubo, NULL))\newline	    return ERROR;\newline\newline	return traverse(subo, ip, nosee);  /* is this right? */\newline\newline      case CLASS_LIGHT:\newline	ip-&gtri.nlights++;\newline	break;\newline	\newline      case CLASS_INTERPOLATOR:\newline      case CLASS_MAX:\newline      case CLASS_MIN:\newline      case CLASS_PRIVATE:\newline      case CLASS_DELETED:\newline      case CLASS_STRING:\newline      case CLASS_ARRAY:\newline      case CLASS_CAMERA:	\newline      default:\newline	for (i=0; i&ltip-&gtri.badobjs; i++) {\newline	    if (ip-&gtri.badclass[i] == curclass)\newline		return OK;\newline	}\newline	ip-&gtri.badobjs++;\newline	ip-&gtri.badclass = (Class *)DXReAllocate((Pointer)ip-&gtri.badclass, \newline						sizeof(Class) * ip-&gtri.badobjs);\newline	ip-&gtri.badclass[ip-&gtri.badobjs - 1] = curclass;\newline\newline	break;\newline    }\newline\newline    return OK;\newline}\newline","accumulate info about what&#039s what\newline \newline","1446123","fdd.c","int fdd_scanvar(BDD r, int var)\newline{\newline   int *allvar;\newline   int res;\newline\newline   CHECK(r);\newline   if (r == bddfalse)\newline      return -1;\newline   if (var &lt 0  ||  var &gt= fdvarnum)\newline      return bdd_error(BDD_VAR);\newline\newline   allvar = fdd_scanallvar(r);\newline   res = allvar[var];\newline   free(allvar);\newline\newline   return res;\newline}\newline","\newlineNAME { fdd\\_scanvar }\newlineSECTION { fdd }\newlineSHORT { Finds one satisfying value of a FDD variable }\newlinePROTO { int fdd_scanvar(BDD r, int var) }\newlineDESCR { Finds one satisfying assignment of the FDD variable {\\tt var} in the\newlineBDD {\\tt r} and returns this value. }\newlineRETURN { The value of a satisfying assignment of {\\tt var}. If {\\tt r} is\newlinethe trivially false BDD, then a negative value is returned. }\newlineALSO { fdd\\_scanallvar }\newline \newline","5179064","xml_relax_ng.c","static VALUE validate_document(VALUE self, VALUE document)\newline{\newline  xmlDocPtr doc;\newline  xmlRelaxNGPtr schema;\newline  VALUE errors;\newline  xmlRelaxNGValidCtxtPtr valid_ctxt;\newline\newline  Data_Get_Struct(self, xmlRelaxNG, schema);\newline  Data_Get_Struct(document, xmlDoc, doc);\newline\newline  errors = rb_ary_new();\newline\newline  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\newline\newline  if(NULL == valid_ctxt) {\newline    /* we have a problem */\newline    rb_raise(rb_eRuntimeError, &quotCould not create a validation context&quot);\newline  }\newline\newline#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\newline  xmlRelaxNGSetValidStructuredErrors(\newline    valid_ctxt,\newline    Nokogiri_error_array_pusher,\newline    (void *)errors\newline  );\newline#endif\newline\newline  xmlRelaxNGValidateDoc(valid_ctxt, doc);\newline\newline  xmlRelaxNGFreeValidCtxt(valid_ctxt);\newline\newline  return errors;\newline}\newline","\newline call-seq:\newline validate_document(document)\newline \newline Validate a Nokogiri::XML::Document against this RelaxNG schema.\newline \newline","4854568","fsm_var.c","void fsm_var_remove(\newline  fsm_var* fv  /*!&lt Pointer to FSM variable structure to remove from global list */\newline) { PROFILE(FSM_VAR_REMOVE);\newline\newline  fsm_var* curr;  /* Pointer to current FSM variable structure in list */\newline  fsm_var* last;  /* Pointer to last FSM variable structure evaluated */\newline\newline  /* Find matching FSM variable structure */\newline  curr = fsm_var_head;\newline  last = NULL;\newline  while( (curr != NULL) &amp&amp (curr != fv) ) {\newline    last = curr;\newline    curr = curr-&gtnext;\newline  }\newline\newline  /* If a matching FSM variable structure was found, remove it from the global list. */\newline  if( curr != NULL ) {\newline\newline    if( (curr == fsm_var_head) &amp&amp (curr == fsm_var_tail) ) {\newline      fsm_var_head = fsm_var_tail = NULL;\newline    } else if( curr == fsm_var_head ) {\newline      fsm_var_head = curr-&gtnext;\newline    } else if( curr == fsm_var_tail ) {\newline      fsm_var_tail = last;\newline    } else {\newline      last-&gtnext = curr-&gtnext;\newline    }\newline\newline    fsm_var_dealloc( curr );\newline\newline  }\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineSearches global FSM variable list for matching FSM variable structure.\newlineWhen match is found, remove the structure and deallocate it from memory\newlinebeing sure to keep the global list intact.\newline \newline","1078422","audio_alsa_out.c","static int my_snd_mixer_wait(snd_mixer_t *mixer, int timeout) {\newline  struct pollfd  spfds[16];\newline  struct pollfd *pfds = spfds;\newline  int            err, count;\newline\newline  count = snd_mixer_poll_descriptors(mixer, pfds, sizeof(spfds) / sizeof(spfds[0]));\newline\newline  if (count &lt 0)\newline    return count;\newline\newline  if ((unsigned int) count &gt sizeof(spfds) / sizeof(spfds[0])) {\newline    pfds = calloc(count, sizeof(*pfds));\newline\newline    if (!pfds)\newline      return -ENOMEM;\newline\newline    err = snd_mixer_poll_descriptors(mixer, pfds, (unsigned int) count);\newline    assert(err == count);\newline  }\newline\newline  err = poll(pfds, (unsigned int) count, timeout);\newline\newline  if (err &lt 0)\newline    return -errno;\newline\newline  return err;\newline}\newline","Stolen from alsa-lib \newline","5137482","rfc1035.c","int check_for_bogus_wildcard(struct dns_header *header, size_t qlen, char *name, \newline			     struct bogus_addr *baddr, time_t now)\newline{\newline  unsigned char *p;\newline  int i, qtype, qclass, rdlen;\newline  unsigned long ttl;\newline  struct bogus_addr *baddrp;\newline\newline  /* skip over questions */\newline  if (!(p = skip_questions(header, qlen)))\newline    return 0; /* bad packet */\newline\newline  for (i = ntohs(header-&gtancount); i != 0; i--)\newline    {\newline      if (!extract_name(header, qlen, &ampp, name, 1, 10))\newline	return 0; /* bad packet */\newline  \newline      GETSHORT(qtype, p); \newline      GETSHORT(qclass, p);\newline      GETLONG(ttl, p);\newline      GETSHORT(rdlen, p);\newline      \newline      if (qclass == C_IN &amp&amp qtype == T_A)\newline	{\newline	  if (!CHECK_LEN(header, p, qlen, INADDRSZ))\newline	    return 0;\newline	  \newline	  for (baddrp = baddr; baddrp; baddrp = baddrp-&gtnext)\newline	    if (memcmp(&ampbaddrp-&gtaddr, p, INADDRSZ) == 0)\newline	      {\newline		/* Found a bogus address. Insert that info here, since there no SOA record\newline		   to get the ttl from in the normal processing */\newline		cache_start_insert();\newline		cache_insert(name, NULL, now, ttl, F_IPV4 | F_FORWARD | F_NEG | F_NXDOMAIN);\newline		cache_end_insert();\newline		\newline		return 1;\newline	      }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, qlen, rdlen))\newline	return 0;\newline    }\newline  \newline  return 0;\newline}\newline","Is the packet a reply with the answer address equal to addr?\newlineIf so mung is into an NXDOMAIN reply and also put that information\newlinein the cache. \newline","4945349","context.c","int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable)\newline{\newline	return set_flag(cxt, MNT_FL_NOMTAB, disable);\newline}\newline","\newline mnt_context_disable_mtab:\newline @cxt: mount context\newline @disable: TRUE or FALSE\newline \newline Disable/enable mtab update (see mount(8) man page, option -n).\newline \newline Returns: 0 on success, negative number in case of error.\newline \newline","3007780","init_finalize.c","int PARMCI_Finalize(void) {\newline  int nfreed;\newline\newline  /* GA/TCGMSG end up calling ARMCI_Finalize() multiple times. */\newline  if (ARMCII_GLOBAL_STATE.init_count == 0) {\newline    return 0;\newline  }\newline\newline  ARMCII_GLOBAL_STATE.init_count--;\newline\newline  /* Only finalize on the last matching call */\newline  if (ARMCII_GLOBAL_STATE.init_count &gt 0) {\newline    return 0;\newline  }\newline\newline#ifdef HAVE_PTHREADS\newline    /* Destroy the asynchronous progress thread */\newline    {\newline        if(ARMCII_GLOBAL_STATE.progress_thread) {\newline            progress_active = 0;\newline            int rc = pthread_join(ARMCI_Progress_thread, NULL);\newline            if (rc) {\newline                ARMCII_Warning(&quotARMCI progress thread join failed (%d).\\n&quot, rc);\newline            }\newline        }\newline    }\newline#endif\newline\newline  nfreed = gmr_destroy_all();\newline\newline  if (nfreed &gt 0 &amp&amp ARMCI_GROUP_WORLD.rank == 0)\newline    ARMCII_Warning(&quotFreed %d leaked allocations\\n&quot, nfreed);\newline\newline  /* Free GOP operators */\newline\newline  MPI_Op_free(&ampMPI_ABSMIN_OP);\newline  MPI_Op_free(&ampMPI_ABSMAX_OP);\newline\newline  MPI_Op_free(&ampMPI_SELMIN_OP);\newline  MPI_Op_free(&ampMPI_SELMAX_OP);\newline\newline  ARMCI_Cleanup();\newline\newline  ARMCI_Group_free(&ampARMCI_GROUP_WORLD);\newline\newline  return 0;\newline}\newline","Finalize ARMCI. Must be called before MPI is finalized. ARMCI calls are\newline not valid after finalization. Collective on world group.\newline \newline @return Zero on success\newline \newline","1491823","priorityq-heap.cpp","PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )\newline{\newline  long curr;\newline  PQhandle free_handle;\newline\newline  curr = ++ pq-&gtsize;\newline  if( (curr*2) &gt pq-&gtmax ) {\newline    PQnode *saveNodes= pq-&gtnodes;\newline    PQhandleElem *saveHandles= pq-&gthandles;\newline\newline    /* If the heap overflows, double its size. */\newline    pq-&gtmax &lt&lt= 1;\newline    pq-&gtnodes = (PQnode *)memRealloc( pq-&gtnodes, \newline				     (size_t) \newline				     ((pq-&gtmax + 1) * sizeof( pq-&gtnodes[0] )));\newline    if (pq-&gtnodes == NULL) {\newline       pq-&gtnodes = saveNodes;	/* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline    pq-&gthandles = (PQhandleElem *)memRealloc( pq-&gthandles,\newline			                     (size_t)\newline			                      ((pq-&gtmax + 1) * \newline					       sizeof( pq-&gthandles[0] )));\newline    if (pq-&gthandles == NULL) {\newline       pq-&gthandles = saveHandles; /* restore ptr to free upon return */\newline       return LONG_MAX;\newline    }\newline  }\newline\newline  if( pq-&gtfreeList == 0 ) {\newline    free_handle = curr;\newline  } else {\newline    free_handle = pq-&gtfreeList;\newline    pq-&gtfreeList = pq-&gthandles[free_handle].node;\newline  }\newline\newline  pq-&gtnodes[curr].handle = free_handle;\newline  pq-&gthandles[free_handle].node = curr;\newline  pq-&gthandles[free_handle].key = keyNew;\newline\newline  if( pq-&gtinitialized ) {\newline    FloatUp( pq, curr );\newline  }\newline  assert(free_handle != LONG_MAX);\newline  return free_handle;\newline}\newline","returns LONG_MAX iff out of memory \newline","557191","bbrun.c","void bb_run_stopwaiting(void){\newline  dowait = 0;\newline}\newline","\newline Cancels waiting for processes to finish - use when doing a fast shutdown.\newline \newline","675746","dictionary.c","Afdict_class * afdict_find(Dictionary afdict, const char * con, bool notify_err)\newline{\newline	const char ** ac;\newline\newline	for (ac = afdict_classname;\newline	     ac &lt &ampafdict_classname[ARRAY_SIZE(afdict_classname)]; ac++)\newline	{\newline		if (0 == strcmp(*ac, con))\newline			return &ampafdict-&gtafdict_class[ac - afdict_classname];\newline	}\newline	if (notify_err) {\newline		prt_error(&quotWarning: Unknown class name %s found near line %d of %s.\\n&quot\newline		          &quot\\tThis class name will be ignored.\\n&quot,\newline		          con, afdict-&gtline_number, afdict-&gtname);\newline	}\newline	return NULL;\newline}\newline","\newline Find the affix table entry for given connector name.\newline If the connector name is not in the table, return NULL.\newline \newline","3068865","nxstoken.h","inline const char *NxsToken::GetTokenAsCStr(\newline  bool respect_case)	/* determines whether token is converted to upper case before being returned */\newline	{\newline	if (!respect_case)\newline		ToUpper();\newline\newline	return token.c_str();\newline	}\newline","!\newline Returns the data member `token&#039 as a C-style string. Specifying false for`respect_case&#039 parameter causes all\newline characters in `token&#039 to be converted to upper case before the `token&#039 C-string is returned. Specifying true\newline results in GetTokenAsCStr returning exactly what it read from the file.\newline \newline","5034941","utility_funcs.c","int g15daemon_cfg_remove_key(config_section_t *section, char *key){\newline    \newline    config_items_t *new = NULL;\newline    config_items_t *next = NULL;\newline    config_items_t *prev = NULL;\newline    if(section==NULL)\newline        return -1;\newline    \newline    if((uf_search_confitem(section, key))){\newline        new=uf_search_confitem(section, key);\newline        prev=new-&gtprev;\newline        next=new-&gtnext;\newline        if(prev){\newline            prev-&gtnext=new-&gtnext;\newline        }else{\newline             if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline                else\newline                    section-&gtitems=next;\newline            }\newline\newline        if(new-&gthead==new){\newline            if(prev){\newline                prev-&gthead = prev;\newline                section-&gtitems-&gthead=prev;\newline            }\newline            if(!prev){\newline                if(!next) {\newline                    free(section-&gtitems);\newline                    section-&gtitems=NULL;\newline                }\newline            }\newline        }\newline        if(next){\newline            if(prev)\newline            	next-&gtprev=prev;\newline            else\newline                next-&gtprev=NULL;\newline        }\newline        free(new-&gtkey);\newline        free(new-&gtvalue);\newline        free(new);\newline    }\newline    return 0;\newline}\newline","remoe a key/value pair from named section \newline","6572891","lomoco.c","static void query (mouse_t *m, struct usb_device *device) {\newline	usb_dev_handle *handle;\newline	unsigned int  addr;\newline\newline	/*\newline	 * For dual receivers C502, C504 and C505, the mouse is the\newline	 * second device and uses an addr of 1 in the value and index\newline	 * fields&#039 high byte. 1 &lt&lt 8\newline	 */\newline	addr = m-&gtis_dual ? 1 &lt&lt 8 : 0;\newline\newline	/* Try to open the device */\newline	handle = usb_open (device);\newline\newline	if (handle == NULL) {\newline		perror (&quotError opening USB device&quot);\newline		exit (EXIT_FAILURE);\newline	}\newline\newline	/* Parse CSR Status (this one&#039s huge) \newline	*  for wireless mouse\newline	*/\newline	if (m-&gthas_csr) {\newline		query_csr(m, handle, addr);\newline	}\newline\newline\newline	/* The RES extension */\newline	if (m-&gthas_res) {\newline		query_res(m, handle, addr);\newline	}\newline	\newline\newline	/* The SMS extension */\newline	if (m-&gthas_sms) {\newline		query_sms(m, handle, addr);\newline	}\newline\newline	query_usb(m, device);\newline\newline	printf (&quot\\n&quot);\newline\newline	(void) usb_close (handle);\newline}\newline","\newline Description: print mouse specific things like current resolution, \newline state of sms, and for wireless mouse additional: \newline receiver type, battery strenght and so on\newline \newline Parameters: mouse_t m\newline struct with the mouse specs\newline usb_device device\newline the device which should be queried\newline \newline Retrun: void\newline \newline","6511628","jar.c","JarFile* jclass_jar_open(const char *zipfile)\newline{\newline	/* allocate */\newline	JarFile *zip = (JarFile *) malloc (sizeof (JarFile));\newline\newline	/* open */\newline	zip-&gtfp = my_open (zipfile, &quotrb&quot);\newline	if (zip-&gtfp == NULL)\newline	{\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* go to end */\newline	if (fseek (zip-&gtfp, 0L, SEEK_END) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* get length */\newline	zip-&gtlength = ftell (zip-&gtfp);\newline	if (zip-&gtlength &lt= 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read ecd data */\newline	if (ecd_read (zip) != 0)\newline	{\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* compile ecd info */\newline	zip-&gtend_of_cent_dir_sig = read_dword (zip-&gtecd + ZIPESIG);\newline	zip-&gtnumber_of_this_disk = read_word (zip-&gtecd + ZIPEDSK);\newline	zip-&gtnumber_of_disk_start_cent_dir = read_word (zip-&gtecd + ZIPECEN);\newline	zip-&gttotal_entries_cent_dir_this_disk =\newline		read_word (zip-&gtecd + ZIPENUM);\newline	zip-&gttotal_entries_cent_dir = read_word (zip-&gtecd + ZIPECENN);\newline	zip-&gtsize_of_cent_dir = read_dword (zip-&gtecd + ZIPECSZ);\newline	zip-&gtoffset_to_start_of_cent_dir = read_dword (zip-&gtecd + ZIPEOFST);\newline\newline	/* verify that we can work with this zipfile (no disk spanning allowed) */\newline	if ((zip-&gtnumber_of_this_disk != zip-&gtnumber_of_disk_start_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir_this_disk !=\newline		zip-&gttotal_entries_cent_dir)\newline	    || (zip-&gttotal_entries_cent_dir &lt 1))\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fseek (zip-&gtfp, zip-&gtoffset_to_start_of_cent_dir, SEEK_SET) != 0)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* read from start of central directory */\newline	zip-&gtcd = (char *) malloc (zip-&gtsize_of_cent_dir);\newline	if (zip-&gtcd == NULL)\newline	{\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	if (fread (zip-&gtcd, zip-&gtsize_of_cent_dir, 1, zip-&gtfp) != 1)\newline	{\newline		free (zip-&gtcd);\newline		free (zip-&gtecd);\newline		fclose (zip-&gtfp);\newline		free (zip);\newline		return NULL;\newline	}\newline\newline	/* reset ent */\newline	zip-&gtent.name = NULL;\newline\newline	/* rewind */\newline	zip-&gtcd_pos = 0;\newline\newline	return zip;\newline}\newline","\newline jclass_jar_open\newline @filename: The filename for the jar file.\newline \newline Opens a jar stream for reading.\newline \newline Returns: A newly allocated jar stream on success,\newline or NULL if any error occured.\newline \newline","2152693","rolodex.c","int insertPhoneEntryCB (EObjectType cdkType GCC_UNUSED, void *object, void\newline			*clientData, chtype key GCC_UNUSED)\newline{\newline   /* Declare local variables. */\newline   CDKSCROLL *scrollp = (CDKSCROLL *)object;\newline   SPhoneData *phoneData = (SPhoneData *) clientData;\newline   SPhoneRecord *phoneRecord = &ampphoneData-&gtrecord[phoneData-&gtrecordCount];\newline   char temp[MYSIZE];\newline\newline   /* Make the scrolling list disappear. */\newline   eraseCDKScroll (scrollp);\newline\newline   /* Call the function which gets phone record information. */\newline   if (addPhoneRecord (ScreenOf (scrollp), phoneData) == 0)\newline   {\newline      sprintf (temp, &quot%s (%s)&quot, phoneRecord-&gtname, GLineType[phoneRecord-&gtlineType]);\newline      addCDKScrollItem (scrollp, temp);\newline   }\newline\newline   /* Redraw the scrolling list. */\newline   drawCDKScroll (scrollp, ObjOf (scrollp)-&gtbox);\newline   return (FALSE);\newline}\newline","\newline This allows the user to insert a new phone entry into the database.\newline \newline","5131880","fnotifystat.c","static void show_usage(void)\newline{\newline	printf(&quot%s, version %s\\n\\n&quot, app_name, VERSION);\newline	printf(&quotOptions are:\\n&quot\newline		&quot  -c     cumulative totals over time\\n&quot\newline		&quot  -d     strip directory off the filenames\\n&quot\newline		&quot  -D     order stats by unique device\\n&quot\newline		&quot  -f     force output\\n&quot\newline		&quot  -h     show this help\\n&quot\newline		&quot  -i     specify pathnames to include on path events\\n&quot\newline		&quot  -I     order stats by unique device and inode\\n&quot\newline		&quot  -m     merge events on same file and pid in same second\\n&quot\newline		&quot  -n     no stats, just -v verbose mode only\\n&quot\newline		&quot  -p PID collect stats for just process with pid PID\\n&quot\newline		&quot  -P     sort stats by process ID\\n&quot\newline		&quot  -s     disable scaling of file counts\\n&quot\newline		&quot  -t N   show just the busiest N files\\n&quot\newline		&quot  -T     show timestamp\\n&quot\newline		&quot  -v     verbose mode, dump out all file activity\\n&quot\newline		&quot  -x     specify pathnames to exclude on path events\\n&quot);\newline}\newline","\newline show_usage()\newline how to use\newline \newline","1461728","plustek-pp_image.c","static void fnDataDirect( pScanData ps, pVoid pBuf, pVoid pImg, ULong bl )\newline{\newline	_VAR_NOT_USED( ps );\newline	memcpy( pBuf, pImg, bl );\newline}\newline","This routine used in the condition:\newline 1) The data type is B/W or GrayScale.\newline 2) The required horizontal resolution doesn&#039t exceed the optic spec.\newline 3) The required vertical resolution exceeds the optic spec.\newline So, the vertcal lines have to average with previous line to smooth the\newline image.\newline \newline","","","","","","","","","","","","","on","","","on","","","","on","","","","","","","","","","","","","","","","","","","","","","on","Determines if a generic function method can be deleted","Disable/enable mtab update","Finalize ARMCI.","returns LONG_MAX iff out of memory","Cancels waiting for processes to finish","Find the affix table entry for given connector name.","Returns the data member `token' as a C-style string.","remoe a key/value pair from named section","print mouse specific things","Opens a jar stream for reading.","insert a new phone entry into the database.","returns the inp-house number,","{}","to smooth the image.","choose an alignment endpoint,","{}","Finds one satisfying value of a FDD variable","Validate a Nokogiri::XML::Document against this RelaxNG schema.","Searches global FSM variable list for matching FSM variable structure.","{}","put that information in the cache."
"3EGKVCRQFWS5683HUMYP28HOC5OBYH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","39N5ACM9HENUWLTCVHTBNUPB0N39PY","A3GJDP8RBLUWTT","Approved","Wed Apr 17 12:11:24 PDT 2019","Wed Apr 17 12:16:36 PDT 2019","Fri Apr 19 12:16:36 PDT 2019","2019-04-19 19:17:21 UTC","","","312","100% (2/2)","100% (2/2)","100% (2/2)","5964550","im.c","faim_export int aim_im_sendch2_sendfile_cancel(aim_session_t *sess, struct aim_oft_info *oft_info)\newline{\newline	aim_conn_t *conn;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline\newline	if (!sess || !(conn = aim_conn_findbygroup(sess, 0x0004)) || !oft_info)\newline		return -EINVAL;\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 10 + 11+strlen(oft_info-&gtsn) + 4+2+8+16)))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0004, 0x0006, 0x0000, NULL, 0);\newline	aim_putsnac(&ampfr-&gtdata, 0x0004, 0x0006, 0x0000, snacid);\newline\newline	/* ICBM header */\newline	aim_im_puticbm(&ampfr-&gtdata, oft_info-&gtcookie, 0x0002, oft_info-&gtsn);\newline\newline	aimbs_put16(&ampfr-&gtdata, 0x0005);\newline	aimbs_put16(&ampfr-&gtdata, 0x001a);\newline	aimbs_put16(&ampfr-&gtdata, AIM_RENDEZVOUS_CANCEL);\newline	aimbs_putraw(&ampfr-&gtdata, oft_info-&gtcookie, 8);\newline	aim_putcap(&ampfr-&gtdata, AIM_CAPS_SENDFILE);\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Subtype 0x0006 - Send a &quotcancel this file transfer&quot message?\newline \newline \newline","2300406","pre.c","int DoSetExternalAttr(UBYTE *s)\newline{\newline#ifdef WITHEXTERNALCHANNEL\newline	int lnam,lval;\newline	UBYTE *nam,*val;\newline#else\newline	DUMMYUSE(s);\newline#endif\newline	if ( AP.PreSwitchModes[AP.PreSwitchLevel] != EXECUTINGPRESWITCH ) return(0);\newline	if ( AP.PreIfStack[AP.PreIfLevel] != EXECUTINGIF ) return(0);\newline\newline#ifdef WITHEXTERNALCHANNEL\newline	do{\newline		/*Read the name:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		s=pickupword(nam=s);\newline		lnam=s-nam;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		if(*s++!=&#039=&#039){\newline			MesPrint(&quot@External channel:&#039=&#039 expected instead of %s&quot,s-1);\newline			return(-1);\newline		}\newline		/*Read the value:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		val=s;\newline\newline		for(;;){\newline			UBYTE *m;\newline			s=pickupword(s);\newline			m=s;\newline			while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline         if( (*s == &#039,&#039)||(*s == &#039\\n&#039)||(*s == &#039;&#039)||(*s == &#039\\0&#039) ){\newline				s=m;\newline				break;\newline			}\newline		}/*for(;;)*/\newline\newline		lval=s-val;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline\newline		if(strINCmp((UBYTE *)SHELL,nam,lnam)==0){\newline			if(AX.shellname!=NULL)\newline				M_free(AX.shellname,&quotexternal channel shellname&quot);\newline			if(strINCmp((UBYTE *)NOSHELL,val,lval)==0)\newline				AX.shellname=NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.shellname=Malloc1(lval+1,&quotexternal channel shellname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else if(strINCmp((UBYTE *)DAEMON,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.daemonize = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.daemonize = 0;\newline			else{\newline				MesPrint(&quot@External channel:true or false expected for %s&quot,DAEMON);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILLALL,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 0;\newline			else{\newline				MesPrint(&quot@External channel: true or false expected for %s&quot,KILLALL);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILL,nam,lnam)==0){\newline			int i,n=0;\newline			for(i=0;i&ltlval;i++)\newline				if( *val&gt=&#0390&#039 &amp&amp *val&lt= &#0399&#039 )\newline					n = 10*n + *val++  - &#0390&#039;\newline				else{\newline					MesPrint(&quot@External channel: number expected for %s&quot,KILL);\newline					return(-1);\newline				}\newline				AX.killSignal=n;\newline		}else	if(strINCmp((UBYTE *)STDERR,nam,lnam)==0){\newline			if( AX.stderrname != NULL ) {\newline				M_free(AX.stderrname,&quotexternal channel stderrname&quot);\newline			}\newline			if(strINCmp((UBYTE *)TERMINAL,val,lval)==0)\newline				AX.stderrname = NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.stderrname=Malloc1(lval+1,&quotexternal channel stderrname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else{\newline			nam[lnam+1]=&#039\\0&#039;\newline			MesPrint(&quot@External channel: unrecognized attribute&quot,nam);\newline			return(-1);\newline		}\newline	}while(*s++ == &#039,&#039);\newline	if(  (*(s-1)&gt&#039 &#039)&amp&amp(*(s-1)!=&#039;&#039)  ){\newline		MesPrint(&quot@External channel: syntax error: %s&quot,s-1);\newline		return(-1);\newline	}\newline   return(0);\newline#else /*ifdef WITHEXTERNALCHANNEL*/\newline	Error0(&quotExternal channel: not implemented on this computer/system&quot);\newline	return(-1);\newline#endif /*ifdef WITHEXTERNALCHANNEL ... else*/\newline}\newline","\newline Expects comma-separated list of pairs name=value\newline \newline","4045357","androresolvd.c","int __futex_wait(volatile void *ftx, int val, const struct timespec *timeout)\newline{\newline	return syscall(SYS_futex, ftx, FUTEX_WAIT, val, (void *)timeout, NULL, NULL);\newline}\newline","\newline This syscall is required by Android&#039s properties handling in system_properties.c\newline \newline","3213244","configure.c","void SetBox(char *text, FILE *fd, char **arg,int *junk)\newline{\newline  int num;\newline\newline  if(Scr.NumBoxes &lt MAX_BOXES)\newline    {\newline      /* Standard X11 geometry string */\newline      num = sscanf(text,&quot%d%d%d%d&quot,&ampScr.IconBoxes[Scr.NumBoxes][0],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][1],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][2],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][3]);\newline\newline      /* check for negative locations */\newline      if(Scr.IconBoxes[Scr.NumBoxes][0] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][0] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][1] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][1] += Scr.MyDisplayHeight;\newline\newline      if(Scr.IconBoxes[Scr.NumBoxes][2] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][2] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][3] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][3] += Scr.MyDisplayHeight;\newline\newline      if(num == 4)\newline	Scr.NumBoxes++;\newline    }\newline}\newline","\newline \newline Reads Dimensions for an icon box from the config file\newline \newline \newline","2787820","lwgeodetic.c","void geographic_point_init(double lon, double lat, GEOGRAPHIC_POINT *g)\newline{\newline	g-&gtlat = latitude_radians_normalize(deg2rad(lat));\newline	g-&gtlon = longitude_radians_normalize(deg2rad(lon));\newline}\newline","\newline Initialize a geographic point\newline @param lon longitude in degrees\newline @param lat latitude in degrees\newline \newline","4487750","bg_misc.c","void BG_EvaluateTrajectoryDelta( const trajectory_t *tr, int atTime, vec3_t result ) {\newline	float	deltaTime;\newline	float	phase;\newline\newline	switch( tr-&gttrType ) {\newline	case TR_STATIONARY:\newline	case TR_INTERPOLATE:\newline		VectorClear( result );\newline		break;\newline	case TR_LINEAR:\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_SINE:\newline		deltaTime = ( atTime - tr-&gttrTime ) / (float) tr-&gttrDuration;\newline		phase = cos( deltaTime * M_PI * 2 );	// derivative of sin = cos\newline		phase *= 0.5;\newline		VectorScale( tr-&gttrDelta, phase, result );\newline		break;\newline	case TR_LINEAR_STOP:\newline		if ( atTime &gt tr-&gttrTime + tr-&gttrDuration ) {\newline			VectorClear( result );\newline			return;\newline		}\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_GRAVITY:\newline		deltaTime = ( atTime - tr-&gttrTime ) * 0.001;	// milliseconds to seconds\newline		VectorCopy( tr-&gttrDelta, result );\newline		result[2] -= DEFAULT_GRAVITY * deltaTime;		// FIXME: local gravity...\newline		break;\newline	default:\newline		Com_Error( ERR_DROP, &quotBG_EvaluateTrajectoryDelta: unknown trType: %i&quot, tr-&gttrTime );\newline		break;\newline	}\newline}\newline","\newline================\newlineBG_EvaluateTrajectoryDelta\newlineFor determining velocity at a given time\newline================\newline \newline","5357659","file.c","int CDECL MSVCRT__vfwprintf_l(MSVCRT_FILE* file, const MSVCRT_wchar_t *format,\newline        MSVCRT__locale_t locale, __ms_va_list valist)\newline{\newline    BOOL tmp_buf;\newline    int ret;\newline\newline    if (!MSVCRT_CHECK_PMT( file != NULL )) return -1;\newline\newline    MSVCRT__lock_file(file);\newline    tmp_buf = add_std_buffer(file);\newline    ret = pf_printf_w(puts_clbk_file_w, file, format, locale, 0, arg_clbk_valist, NULL, &ampvalist);\newline    if(tmp_buf) remove_std_buffer(file);\newline    MSVCRT__unlock_file(file);\newline\newline    return ret;\newline}\newline","\newline _vfwprintf_l (MSVCRT.@)\newline \newline","4515228","bb_boxc.c","static void wdp_to_wapboxes(void *arg)\newline{\newline    List *route_info;\newline    AddrPar *ap;\newline    Boxc *conn;\newline    Msg *msg;\newline    int i;\newline\newline    gwlist_add_producer(flow_threads);\newline    gwlist_add_producer(wapbox_list);\newline\newline    route_info = gwlist_create();\newline\newline\newline    while(bb_status != BB_DEAD) {\newline\newline	    gwlist_consume(suspended);	/* block here if suspended */\newline\newline	    if ((msg = gwlist_consume(incoming_wdp)) == NULL)\newline	         break;\newline\newline	    gw_assert(msg_type(msg) == wdp_datagram);\newline\newline	    conn = route_msg(route_info, msg);\newline	    if (conn == NULL) {\newline	        warning(0, &quotCannot route message, discard it&quot);\newline	        msg_destroy(msg);\newline	        continue;\newline	    }\newline	    gwlist_produce(conn-&gtincoming, msg);\newline    }\newline    debug(&quotbb&quot, 0, &quotwdp_to_wapboxes: destroying lists&quot);\newline    while((ap = gwlist_extract_first(route_info)) != NULL)\newline	ap_destroy(ap);\newline\newline    gw_assert(gwlist_len(route_info) == 0);\newline    gwlist_destroy(route_info, NULL);\newline\newline    gwlist_lock(wapbox_list);\newline    for(i=0; i &lt gwlist_len(wapbox_list); i++) {\newline	    conn = gwlist_get(wapbox_list, i);\newline	    gwlist_remove_producer(conn-&gtincoming);\newline	    conn-&gtalive = 0;\newline    }\newline    gwlist_unlock(wapbox_list);\newline\newline    gwlist_remove_producer(wapbox_list);\newline    gwlist_remove_producer(flow_threads);\newline}\newline","\newline this thread listens to incoming_wdp list\newline and then routs messages to proper wapbox\newline \newline","5892597","submesh.c","void fill_master_el_info(EL_INFO *mst_el_info,\newline			 const EL_INFO *el_info,\newline			 FLAGS fill_flags)\newline{\newline  FUNCNAME(&quotfill_master_el_info&quot);\newline  int dim = el_info-&gtmesh-&gtdim;\newline  int mst_ov, mst_t = 0, mst_o = 0;\newline\newline  DEBUG_TEST_EXIT(el_info-&gtfill_flag &amp FILL_MASTER_INFO,\newline		  &quotMaster element link not present in &quot\newline		  &quotslave element descriptor.\\n&quot);\newline\newline  memset(mst_el_info, 0, sizeof(*mst_el_info));\newline\newline  mst_el_info-&gtfill_flag = FILL_NOTHING;\newline  mst_el_info-&gtmesh      = get_master(el_info-&gtmesh);\newline\newline  mst_el_info-&gtmacro_el  = el_info-&gtmacro_el-&gtmaster.macro_el;\newline  mst_el_info-&gtel        = el_info-&gtmaster.el;\newline  mst_el_info-&gtparent    = NULL /* could do better here */;\newline\newline  mst_el_info-&gtel_geom_cache.fill_flag  = 0U;\newline  mst_el_info-&gtel_geom_cache.current_el = mst_el_info-&gtel;\newline  \newline  mst_ov = el_info-&gtmaster.opp_vertex;\newline\newline#if DIM_MAX &gt 2\newline  if (dim == 2) {\newline    mst_t = el_info-&gtmaster.el_type;\newline    mst_o = el_info-&gtmaster.orientation;\newline    \newline    mst_el_info-&gtfill_flag |= FILL_ORIENTATION;\newline\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  COPY_DOW(el_info-&gtcoord[sv], mst_el_info-&gtcoord[v]);\newline	}\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v, e;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[v],\newline			  el_info-&gtvertex_bound[sv]);\newline	} else {\newline	  BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[v]);\newline	}\newline      }\newline      for (e = 0; e &lt N_EDGES_3D; e++) {\newline	BNDRY_FLAGS_INIT(mst_el_info-&gtedge_bound[e]);\newline      }\newline      for (e = 0; e &lt N_EDGES_2D; e++) {\newline	int mst_edge = master_edge_3d[!!mst_t][mst_o &lt 0][mst_ov][e];\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_edge],\newline			el_info-&gtedge_bound[e]);\newline      }\newline      mst_el_info-&gtface_bound[mst_ov] = el_info-&gtface_bound[0];\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  } else\newline#endif\newline  {\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	COPY_DOW(el_info-&gtcoord[v], mst_el_info-&gtcoord[mv]);\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[mv],\newline			el_info-&gtvertex_bound[v]);\newline      }\newline      BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[mst_ov]);\newline      if (dim == 1) {\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_ov],\newline			el_info-&gtedge_bound[0]);\newline      }\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  }\newline\newline  if (fill_flags &amp FILL_NEIGH) {\newline    mst_el_info-&gtneigh[mst_ov] = el_info-&gtmst_neigh.el;\newline    mst_el_info-&gtopp_vertex[mst_ov] = el_info-&gtmst_neigh.opp_vertex;\newline    mst_el_info-&gtfill_flag |= FILL_NEIGH;\newline    if (fill_flags &amp FILL_OPP_COORDS) {\newline      COPY_DOW(el_info-&gtmst_neigh.opp_coord, mst_el_info-&gtopp_coord[mst_ov]);\newline      mst_el_info-&gtfill_flag |= FILL_OPP_COORDS;\newline    }\newline  }\newline\newline  mst_el_info-&gtel_type      = mst_t;\newline  mst_el_info-&gtorientation  = mst_o;\newline\newline  if (fill_flags &amp FILL_COORDS) {\newline    mst_el_info-&gtfill_flag |= FILL_COORDS;\newline    COPY_DOW(el_info-&gtmaster.opp_coord, mst_el_info-&gtcoord[mst_ov]);\newline  }\newline}\newline","Construct an EL_INFO structure for the master element attached to\newline the given slave element. This requires FILL_MASTER_INFO to be set\newline in the fill-flags of el_info.\newline \newline The master element will have its el_type and orientation set. If\newline the slave EL_INFO has co-ordinate information, then also the master\newline EL_INFO will be equipped with co-ordinate information.\newline \newline","1345392","verify_packages.c","static PromiseResult VerifyPromisedPackage(EvalContext *ctx, Attributes a, const Promise *pp)\newline{\newline    const char *package = pp-&gtpromiser;\newline\newline    PromiseResult result = PROMISE_RESULT_NOOP;\newline    if (a.packages.package_version)\newline    {\newline        /* The version is specified separately */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified explicitly in promise body&quot, a.packages.package_version);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, a.packages.package_version, &quot*&quot, false));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result,\newline                                             CheckPackageState(ctx, a, pp, package, a.packages.package_version,\newline                                                               RlistScalarValue(rp), false));\newline            }\newline        }\newline    }\newline    else if (a.packages.package_version_regex)\newline    {\newline        /* The name, version and arch are to be extracted from the promiser */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified implicitly in promiser&#039s name&quot, a.packages.package_version_regex);\newline\newline        char version[CF_MAXVARSIZE];\newline        char name[CF_MAXVARSIZE];\newline        char arch[CF_MAXVARSIZE];\newline        strlcpy(version, ExtractFirstReference(a.packages.package_version_regex, package), CF_MAXVARSIZE);\newline        strlcpy(name, ExtractFirstReference(a.packages.package_name_regex, package), CF_MAXVARSIZE);\newline        strlcpy(arch, ExtractFirstReference(a.packages.package_arch_regex, package), CF_MAXVARSIZE);\newline\newline        if (!arch[0])\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        if (strcmp(arch, &quotCF_NOMATCH&quot) == 0)    // no match on arch regex, use any arch\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        Log(LOG_LEVEL_VERBOSE, &quot ... trying arch &#039%s&#039 and version &#039%s&#039&quot, arch, version);\newline        result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, name, version, arch, false));\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version was not specified&quot);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039 and any version &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, &quot*&quot, true));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039 and any version &#039*&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, RlistScalarValue(rp), true));\newline            }\newline        }\newline    }\newline\newline    return result;\newline}\newline","\newline@brief Verifies a promised package operation as defined by a and pp\newlineCalled by VerifyPackagesPromise for any non-patch operation.\newline package name is pp-&gtpromiser\newline promise result starts as NOOP\newline if package version is given\newline if no architecture given, the promise result comes from CheckPackageState with name, version, any architecture &#039 &#039, no_version=false\newline else if architectures were given, the promise result comes from CheckPackageState with name, version, arch, no_version=false FOR EACH ARCHITECTURE\newline else if package_version_regex is given\newline assume that package_name_regex and package_arch_regex are also given and use the 3 regexes to extract name, version, arch\newline if the arch extraction failed, use any architecture &#039 &#039\newline the promise result comes from CheckPackageState with name, version, arch, no_version=false)\newline else (no explicit version is given) (SAME LOOP AS EXPLICIT VERSION LOOP ABOVE)\newline if no architecture given, the promise result comes from CheckPackageState with name, any version &quot &quot, any architecture &#039 &#039, no_version=true\newline else if architectures were given, the promise result comes from CheckPackageState with name, any version &quot &quot, arch, no_version=true FOR EACH ARCHITECTURE\newline@param ctx [in] The evaluation context\newline@param a [in] the Attributes specifying how to compare\newline@param pp [in] the Promise for this operation\newline@returns the promise result as set by CheckPackageState\newline \newline","6366566","decorate_background.cpp","bool FrontFacing(Point3f viewPos,\newline                 int axis, int side,\newline                 Point3f minP, Point3f maxP)\newline{\newline  assert (side==0 || side ==1);\newline  assert (axis&gt=0 &amp&amp axis &lt 3);\newline  Point3f N(0,0,0);\newline  Point3f C = (minP+maxP)/2.0;\newline\newline  if(side == 1) {\newline      C[axis] = maxP[axis];\newline      N[axis]=-1;\newline  }\newline\newline  if(side == 0) {\newline    C[axis] = minP[axis];\newline    N[axis]=1;\newline  }\newline  Point3f vpc = viewPos-C;\newline//  qDebug(&quotFaceCenter %f %f %f - %f %f %f&quot,C[0],C[1],C[2],N[0],N[1],N[2]);\newline//  qDebug(&quotVPC        %f %f %f&quot,vpc[0],vpc[1],vpc[2]);\newline  return vpc*N &gt 0;\newline}\newline","return true if the side of a box is front facing with respet of the give viewpoint.\newlineside 0, axis i == min on than i-th axis\newlineside 1, axis i == min on than i-th axis\newlinequesto capita se il prodotto scalare tra il vettore normale entro della faccia\newline \newline","2741554","xfs_format.h","static inline uint xfs_dinode_size(int version)\newline{\newline	if (version == 3)\newline		return sizeof(struct xfs_dinode);\newline	return offsetof(struct xfs_dinode, di_crc);\newline}\newline","\newline Size of the core inode on disk. Version 1 and 2 inodes have\newline the same size, but version 3 has grown a few additional fields.\newline \newline","2059881","fluid_synth.c","void\newlinefluid_synth_tuning_iteration_start(fluid_synth_t* synth)\newline{\newline  fluid_return_if_fail (synth != NULL);\newline  fluid_synth_api_enter(synth);\newline  fluid_private_set (synth-&gttuning_iter, FLUID_INT_TO_POINTER (0), NULL);\newline  fluid_synth_api_exit(synth);\newline}\newline","\newline Start tuning iteration.\newline @param synth FluidSynth instance\newline \newline","1827703","qcustomplot.cpp","void QCPAxis::setSelectedLabelFont(const QFont &ampfont)\newline{\newline  mSelectedLabelFont = font;\newline}\newline","!\newlineSets the font that is used for the axis label when it is selected.\newline\newline\\see setLabelFont, setSelectable, setSelected, QCustomPlot::setInteractions\newline \newline","3591538","features_cpu.c","uint64_t cpu_features_get(void)\newline{\newline   int flags[4];\newline   int vendor_shuffle[3];\newline   char vendor[13]     = {0};\newline   size_t len          = 0;\newline   uint64_t cpu_flags  = 0;\newline   uint64_t cpu        = 0;\newline   unsigned max_flag   = 0;\newline#if defined(CPU_X86) &amp&amp !defined(__MACH__)\newline   int vendor_is_intel = 0;\newline   const int avx_flags = (1 &lt&lt 27) | (1 &lt&lt 28);\newline#endif\newline\newline   char buf[sizeof(&quot MMX MMXEXT SSE SSE2 SSE3 SSSE3 SS4 SSE4.2 AES AVX AVX2 NEON VMX VMX128 VFPU PS&quot)];\newline\newline   memset(buf, 0, sizeof(buf));\newline\newline   (void)len;\newline   (void)cpu_flags;\newline   (void)flags;\newline   (void)max_flag;\newline   (void)vendor;\newline   (void)vendor_shuffle;\newline\newline#if defined(__MACH__)\newline   len     = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.mmx&quot, NULL, &amplen, NULL, 0) == 0)\newline   {\newline      cpu |= RETRO_SIMD_MMX;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.supplementalsse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_1&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.aes&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AES;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx1_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx2_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.altivec&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_VMX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.neon&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_NEON;\newline\newline#elif defined(CPU_X86)\newline   (void)avx_flags;\newline\newline   x86_cpuid(0, flags);\newline   vendor_shuffle[0] = flags[1];\newline   vendor_shuffle[1] = flags[3];\newline   vendor_shuffle[2] = flags[2];\newline   memcpy(vendor, vendor_shuffle, sizeof(vendor_shuffle));\newline\newline   /* printf(&quot[CPUID]: Vendor: %s\\n&quot, vendor); */\newline\newline   vendor_is_intel = (\newline         flags[1] == VENDOR_INTEL_b &amp&amp\newline         flags[2] == VENDOR_INTEL_c &amp&amp\newline         flags[3] == VENDOR_INTEL_d);\newline\newline   max_flag = flags[0];\newline   if (max_flag &lt 1) /* Does CPUID not support func = 1? (unlikely ...) */\newline      return 0;\newline\newline   x86_cpuid(1, flags);\newline\newline   if (flags[3] &amp (1 &lt&lt 23))\newline      cpu |= RETRO_SIMD_MMX;\newline\newline   if (flags[3] &amp (1 &lt&lt 25))\newline   {\newline      /* SSE also implies MMXEXT (according to FFmpeg source). */\newline      cpu |= RETRO_SIMD_SSE;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline\newline   if (flags[3] &amp (1 &lt&lt 26))\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   if (flags[2] &amp (1 &lt&lt 0))\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 9))\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 19))\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   if (flags[2] &amp (1 &lt&lt 20))\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   if ((flags[2] &amp (1 &lt&lt 23)))\newline      cpu |= RETRO_SIMD_POPCNT;\newline\newline   if (vendor_is_intel &amp&amp (flags[2] &amp (1 &lt&lt 22)))\newline      cpu |= RETRO_SIMD_MOVBE;\newline\newline   if (flags[2] &amp (1 &lt&lt 25))\newline      cpu |= RETRO_SIMD_AES;\newline\newline\newline   /* Must only perform xgetbv check if we have\newline    * AVX CPU support (guaranteed to have at least i686). */\newline   if (((flags[2] &amp avx_flags) == avx_flags)\newline         &amp&amp ((xgetbv_x86(0) &amp 0x6) == 0x6))\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   if (max_flag &gt= 7)\newline   {\newline      x86_cpuid(7, flags);\newline      if (flags[1] &amp (1 &lt&lt 5))\newline         cpu |= RETRO_SIMD_AVX2;\newline   }\newline\newline   x86_cpuid(0x80000000, flags);\newline   max_flag = flags[0];\newline   if (max_flag &gt= 0x80000001u)\newline   {\newline      x86_cpuid(0x80000001, flags);\newline      if (flags[3] &amp (1 &lt&lt 23))\newline         cpu |= RETRO_SIMD_MMX;\newline      if (flags[3] &amp (1 &lt&lt 22))\newline         cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline#elif defined(__linux__)\newline   if (check_arm_cpu_feature(&quotneon&quot))\newline   {\newline      cpu |= RETRO_SIMD_NEON;\newline#ifdef __ARM_NEON__\newline      arm_enable_runfast_mode();\newline#endif\newline   }\newline\newline   if (check_arm_cpu_feature(&quotvfpv3&quot))\newline      cpu |= RETRO_SIMD_VFPV3;\newline\newline   if (check_arm_cpu_feature(&quotvfpv4&quot))\newline      cpu |= RETRO_SIMD_VFPV4;\newline\newline#if 0\newline    check_arm_cpu_feature(&quotswp&quot);\newline    check_arm_cpu_feature(&quothalf&quot);\newline    check_arm_cpu_feature(&quotthumb&quot);\newline    check_arm_cpu_feature(&quotfastmult&quot);\newline    check_arm_cpu_feature(&quotvfp&quot);\newline    check_arm_cpu_feature(&quotedsp&quot);\newline    check_arm_cpu_feature(&quotthumbee&quot);\newline    check_arm_cpu_feature(&quottls&quot);\newline    check_arm_cpu_feature(&quotidiva&quot);\newline    check_arm_cpu_feature(&quotidivt&quot);\newline#endif\newline\newline#elif defined(__ARM_NEON__)\newline   cpu |= RETRO_SIMD_NEON;\newline   arm_enable_runfast_mode();\newline#elif defined(__ALTIVEC__)\newline   cpu |= RETRO_SIMD_VMX;\newline#elif defined(XBOX360)\newline   cpu |= RETRO_SIMD_VMX128;\newline#elif defined(PSP)\newline   cpu |= RETRO_SIMD_VFPU;\newline#elif defined(GEKKO)\newline   cpu |= RETRO_SIMD_PS;\newline#endif\newline\newline   if (cpu &amp RETRO_SIMD_MMX)    strlcat(buf, &quot MMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_MMXEXT) strlcat(buf, &quot MMXEXT&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE)    strlcat(buf, &quot SSE&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE2)   strlcat(buf, &quot SSE2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE3)   strlcat(buf, &quot SSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSSE3)  strlcat(buf, &quot SSSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE4)   strlcat(buf, &quot SSE4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE42)  strlcat(buf, &quot SSE4.2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AES)    strlcat(buf, &quot AES&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX)    strlcat(buf, &quot AVX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX2)   strlcat(buf, &quot AVX2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_NEON)   strlcat(buf, &quot NEON&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV3)  strlcat(buf, &quot VFPv3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV4)  strlcat(buf, &quot VFPv4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX)    strlcat(buf, &quot VMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX128) strlcat(buf, &quot VMX128&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPU)   strlcat(buf, &quot VFPU&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_PS)     strlcat(buf, &quot PS&quot, sizeof(buf));\newline\newline   return cpu;\newline}\newline","\newline cpu_features_get:\newline \newline Gets CPU features..\newline \newline Returns: bitmask of all CPU features available.\newline \newline","3989953","3dsplay.c","void *convert_to_RGB_Surface(SDL_Surface *bitmap)\newline{\newline  unsigned char *pixel = (unsigned char *)malloc(sizeof(char) * 4 * bitmap-&gth * bitmap-&gtw); \newline  int soff = 0;   \newline  int doff = 0;   \newline  int x, y;\newline  unsigned char *spixels = (unsigned char *)bitmap-&gtpixels;\newline  SDL_Palette *pal = bitmap-&gtformat-&gtpalette; \newline\newline  for (y = 0; y &lt bitmap-&gth; y++)\newline    for (x = 0; x &lt bitmap-&gtw; x++)\newline    {\newline      SDL_Color* col = &amppal-&gtcolors[spixels[soff]];\newline\newline      pixel[doff] = col-&gtr; \newline      pixel[doff+1] = col-&gtg; \newline      pixel[doff+2] = col-&gtb; \newline      pixel[doff+3] = 255; \newline      doff += 4; \newline      soff++;\newline    }\newline\newline    return (void *)pixel; \newline}\newline","\newline Convert an SDL bitmap for use with OpenGL.\newline \newline Written by Gernot &lt gz@lysator.liu.se &gt\newline \newline","1778844","config.c","int config_parse_args(int argc, const char **argv, abl_args *args, log_context *logContext) {\newline    int argn;\newline    int err;\newline\newline    config_clear(args);\newline\newline    for (argn = 0; argn &lt argc; argn++) {\newline        err = parse_arg(argv[argn], args, logContext);\newline        if (err) {\newline            return err;\newline        }\newline    }\newline\newline    if (logContext-&gtdebug)\newline        dump_args(args, logContext);\newline\newline    return 0;\newline}\newline","Parse our argments and populate an abl_args structure accordingly.\newline \newline","6010187","rsim.c","private int setpowtrace()\newline  {\newline    apply(xpowtrace, vpowtrace, plus_minus);\newline    set_vec_nodes( POWWATCHVECTOR );\newline    return( 0 );\newline  }\newline","\newline mark nodes and vectors for cap tracing\newline \newline","2744494","apr_dbd_odbc.c","static int odbc_pvbquery(apr_pool_t *pool, apr_dbd_t *handle, int *nrows,\newline                         apr_dbd_prepared_t *statement, va_list args)\newline{\newline    const char **values;\newline    int i;\newline\newline    values = apr_palloc(pool, sizeof(*values) * statement-&gtnvals);\newline    for (i = 0; i &lt statement-&gtnvals; i++)\newline        values[i] = va_arg(args, const char *);\newline    return odbc_pbquery(pool, handle, nrows, statement, (const void **)values);\newline}\newline","pvbquery: query using a prepared statement + binary args \newline","3923291","mincmorph.c","char    *get_real_from_string(char *string, double *value)\newline{\newline   char    *ptr;\newline\newline   /* skip a [ or : else we probably don&#039t belong here */\newline   if(string[0] == &#039[&#039 || string[0] == &#039:&#039){\newline      string++;\newline      }\newline\newline   /* get a double */\newline   *value = strtod(&ampstring[0], &ampptr);\newline\newline   /* if nothing found return a default value */\newline   if(&ampstring[0] == ptr){\newline      *value = DEF_DOUBLE;\newline      }\newline\newline   /* skip over a possible &#039]&#039 */\newline   if(ptr[0] == &#039]&#039){\newline      ptr++;\newline      }\newline\newline   return ptr;\newline   }\newline","as it was input if nothing found \newline","6419704","commands.c","static int cmd_load(const char *filename)\newline{\newline    int slotnum =\newline	load_file(expand_filename_tilde(filename),\newline		  LOADFILE_READifPRESENT);\newline\newline    if (slotnum &gt= 0)\newline    {\newline	lookup.slot = lookup.slot_info[slotnum];\newline	return COMMAND_RUNS_OK;\newline    }\newline    return COMMAND_HAS_ERROR;\newline}\newline","\newline Given a filename, load it.\newline \newline","","","","","","","","","","","","on","on","","","","","","on","","","","","on","","","","","","","","","","","","","","","","","on","on","Send a ""cancel this file transfer"" message?","Verifies a promised package operation as defined by a and pp","return true if the side of a box is front facing","Size of the core inode on disk.","Start tuning iteration.","Sets the font that is used for the axis label","Gets CPU features..","Convert an SDL bitmap for use with OpenGL.","Parse our argments and populate an abl_args structure accordingly.","mark nodes and vectors for cap tracing","query using a prepared statement + binary args","{}","{}","Given a filename, load it.","This syscall is required by Android's properties handling in system_properties.c","Reads Dimensions for an icon box from the config file","Initialize a geographic point","For determining velocity at a given time","{}","routs messages to proper wapbox","Construct an EL_INFO structure for the master element"
"3EGKVCRQFWS5683HUMYP28HOC5OBYH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3DR23U6WE5E9J9D0K9IHKIRJGO4TEZ","A2MF174E19LY8D","Approved","Wed Apr 17 14:57:56 PDT 2019","Wed Apr 17 15:00:36 PDT 2019","Fri Apr 19 15:00:36 PDT 2019","2019-04-19 22:01:21 UTC","","","160","100% (4/4)","100% (4/4)","100% (4/4)","5964550","im.c","faim_export int aim_im_sendch2_sendfile_cancel(aim_session_t *sess, struct aim_oft_info *oft_info)\newline{\newline	aim_conn_t *conn;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline\newline	if (!sess || !(conn = aim_conn_findbygroup(sess, 0x0004)) || !oft_info)\newline		return -EINVAL;\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 10 + 11+strlen(oft_info-&gtsn) + 4+2+8+16)))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0004, 0x0006, 0x0000, NULL, 0);\newline	aim_putsnac(&ampfr-&gtdata, 0x0004, 0x0006, 0x0000, snacid);\newline\newline	/* ICBM header */\newline	aim_im_puticbm(&ampfr-&gtdata, oft_info-&gtcookie, 0x0002, oft_info-&gtsn);\newline\newline	aimbs_put16(&ampfr-&gtdata, 0x0005);\newline	aimbs_put16(&ampfr-&gtdata, 0x001a);\newline	aimbs_put16(&ampfr-&gtdata, AIM_RENDEZVOUS_CANCEL);\newline	aimbs_putraw(&ampfr-&gtdata, oft_info-&gtcookie, 8);\newline	aim_putcap(&ampfr-&gtdata, AIM_CAPS_SENDFILE);\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Subtype 0x0006 - Send a &quotcancel this file transfer&quot message?\newline \newline \newline","2300406","pre.c","int DoSetExternalAttr(UBYTE *s)\newline{\newline#ifdef WITHEXTERNALCHANNEL\newline	int lnam,lval;\newline	UBYTE *nam,*val;\newline#else\newline	DUMMYUSE(s);\newline#endif\newline	if ( AP.PreSwitchModes[AP.PreSwitchLevel] != EXECUTINGPRESWITCH ) return(0);\newline	if ( AP.PreIfStack[AP.PreIfLevel] != EXECUTINGIF ) return(0);\newline\newline#ifdef WITHEXTERNALCHANNEL\newline	do{\newline		/*Read the name:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		s=pickupword(nam=s);\newline		lnam=s-nam;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		if(*s++!=&#039=&#039){\newline			MesPrint(&quot@External channel:&#039=&#039 expected instead of %s&quot,s-1);\newline			return(-1);\newline		}\newline		/*Read the value:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		val=s;\newline\newline		for(;;){\newline			UBYTE *m;\newline			s=pickupword(s);\newline			m=s;\newline			while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline         if( (*s == &#039,&#039)||(*s == &#039\\n&#039)||(*s == &#039;&#039)||(*s == &#039\\0&#039) ){\newline				s=m;\newline				break;\newline			}\newline		}/*for(;;)*/\newline\newline		lval=s-val;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline\newline		if(strINCmp((UBYTE *)SHELL,nam,lnam)==0){\newline			if(AX.shellname!=NULL)\newline				M_free(AX.shellname,&quotexternal channel shellname&quot);\newline			if(strINCmp((UBYTE *)NOSHELL,val,lval)==0)\newline				AX.shellname=NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.shellname=Malloc1(lval+1,&quotexternal channel shellname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else if(strINCmp((UBYTE *)DAEMON,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.daemonize = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.daemonize = 0;\newline			else{\newline				MesPrint(&quot@External channel:true or false expected for %s&quot,DAEMON);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILLALL,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 0;\newline			else{\newline				MesPrint(&quot@External channel: true or false expected for %s&quot,KILLALL);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILL,nam,lnam)==0){\newline			int i,n=0;\newline			for(i=0;i&ltlval;i++)\newline				if( *val&gt=&#0390&#039 &amp&amp *val&lt= &#0399&#039 )\newline					n = 10*n + *val++  - &#0390&#039;\newline				else{\newline					MesPrint(&quot@External channel: number expected for %s&quot,KILL);\newline					return(-1);\newline				}\newline				AX.killSignal=n;\newline		}else	if(strINCmp((UBYTE *)STDERR,nam,lnam)==0){\newline			if( AX.stderrname != NULL ) {\newline				M_free(AX.stderrname,&quotexternal channel stderrname&quot);\newline			}\newline			if(strINCmp((UBYTE *)TERMINAL,val,lval)==0)\newline				AX.stderrname = NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.stderrname=Malloc1(lval+1,&quotexternal channel stderrname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else{\newline			nam[lnam+1]=&#039\\0&#039;\newline			MesPrint(&quot@External channel: unrecognized attribute&quot,nam);\newline			return(-1);\newline		}\newline	}while(*s++ == &#039,&#039);\newline	if(  (*(s-1)&gt&#039 &#039)&amp&amp(*(s-1)!=&#039;&#039)  ){\newline		MesPrint(&quot@External channel: syntax error: %s&quot,s-1);\newline		return(-1);\newline	}\newline   return(0);\newline#else /*ifdef WITHEXTERNALCHANNEL*/\newline	Error0(&quotExternal channel: not implemented on this computer/system&quot);\newline	return(-1);\newline#endif /*ifdef WITHEXTERNALCHANNEL ... else*/\newline}\newline","\newline Expects comma-separated list of pairs name=value\newline \newline","4045357","androresolvd.c","int __futex_wait(volatile void *ftx, int val, const struct timespec *timeout)\newline{\newline	return syscall(SYS_futex, ftx, FUTEX_WAIT, val, (void *)timeout, NULL, NULL);\newline}\newline","\newline This syscall is required by Android&#039s properties handling in system_properties.c\newline \newline","3213244","configure.c","void SetBox(char *text, FILE *fd, char **arg,int *junk)\newline{\newline  int num;\newline\newline  if(Scr.NumBoxes &lt MAX_BOXES)\newline    {\newline      /* Standard X11 geometry string */\newline      num = sscanf(text,&quot%d%d%d%d&quot,&ampScr.IconBoxes[Scr.NumBoxes][0],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][1],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][2],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][3]);\newline\newline      /* check for negative locations */\newline      if(Scr.IconBoxes[Scr.NumBoxes][0] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][0] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][1] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][1] += Scr.MyDisplayHeight;\newline\newline      if(Scr.IconBoxes[Scr.NumBoxes][2] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][2] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][3] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][3] += Scr.MyDisplayHeight;\newline\newline      if(num == 4)\newline	Scr.NumBoxes++;\newline    }\newline}\newline","\newline \newline Reads Dimensions for an icon box from the config file\newline \newline \newline","2787820","lwgeodetic.c","void geographic_point_init(double lon, double lat, GEOGRAPHIC_POINT *g)\newline{\newline	g-&gtlat = latitude_radians_normalize(deg2rad(lat));\newline	g-&gtlon = longitude_radians_normalize(deg2rad(lon));\newline}\newline","\newline Initialize a geographic point\newline @param lon longitude in degrees\newline @param lat latitude in degrees\newline \newline","4487750","bg_misc.c","void BG_EvaluateTrajectoryDelta( const trajectory_t *tr, int atTime, vec3_t result ) {\newline	float	deltaTime;\newline	float	phase;\newline\newline	switch( tr-&gttrType ) {\newline	case TR_STATIONARY:\newline	case TR_INTERPOLATE:\newline		VectorClear( result );\newline		break;\newline	case TR_LINEAR:\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_SINE:\newline		deltaTime = ( atTime - tr-&gttrTime ) / (float) tr-&gttrDuration;\newline		phase = cos( deltaTime * M_PI * 2 );	// derivative of sin = cos\newline		phase *= 0.5;\newline		VectorScale( tr-&gttrDelta, phase, result );\newline		break;\newline	case TR_LINEAR_STOP:\newline		if ( atTime &gt tr-&gttrTime + tr-&gttrDuration ) {\newline			VectorClear( result );\newline			return;\newline		}\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_GRAVITY:\newline		deltaTime = ( atTime - tr-&gttrTime ) * 0.001;	// milliseconds to seconds\newline		VectorCopy( tr-&gttrDelta, result );\newline		result[2] -= DEFAULT_GRAVITY * deltaTime;		// FIXME: local gravity...\newline		break;\newline	default:\newline		Com_Error( ERR_DROP, &quotBG_EvaluateTrajectoryDelta: unknown trType: %i&quot, tr-&gttrTime );\newline		break;\newline	}\newline}\newline","\newline================\newlineBG_EvaluateTrajectoryDelta\newlineFor determining velocity at a given time\newline================\newline \newline","5357659","file.c","int CDECL MSVCRT__vfwprintf_l(MSVCRT_FILE* file, const MSVCRT_wchar_t *format,\newline        MSVCRT__locale_t locale, __ms_va_list valist)\newline{\newline    BOOL tmp_buf;\newline    int ret;\newline\newline    if (!MSVCRT_CHECK_PMT( file != NULL )) return -1;\newline\newline    MSVCRT__lock_file(file);\newline    tmp_buf = add_std_buffer(file);\newline    ret = pf_printf_w(puts_clbk_file_w, file, format, locale, 0, arg_clbk_valist, NULL, &ampvalist);\newline    if(tmp_buf) remove_std_buffer(file);\newline    MSVCRT__unlock_file(file);\newline\newline    return ret;\newline}\newline","\newline _vfwprintf_l (MSVCRT.@)\newline \newline","4515228","bb_boxc.c","static void wdp_to_wapboxes(void *arg)\newline{\newline    List *route_info;\newline    AddrPar *ap;\newline    Boxc *conn;\newline    Msg *msg;\newline    int i;\newline\newline    gwlist_add_producer(flow_threads);\newline    gwlist_add_producer(wapbox_list);\newline\newline    route_info = gwlist_create();\newline\newline\newline    while(bb_status != BB_DEAD) {\newline\newline	    gwlist_consume(suspended);	/* block here if suspended */\newline\newline	    if ((msg = gwlist_consume(incoming_wdp)) == NULL)\newline	         break;\newline\newline	    gw_assert(msg_type(msg) == wdp_datagram);\newline\newline	    conn = route_msg(route_info, msg);\newline	    if (conn == NULL) {\newline	        warning(0, &quotCannot route message, discard it&quot);\newline	        msg_destroy(msg);\newline	        continue;\newline	    }\newline	    gwlist_produce(conn-&gtincoming, msg);\newline    }\newline    debug(&quotbb&quot, 0, &quotwdp_to_wapboxes: destroying lists&quot);\newline    while((ap = gwlist_extract_first(route_info)) != NULL)\newline	ap_destroy(ap);\newline\newline    gw_assert(gwlist_len(route_info) == 0);\newline    gwlist_destroy(route_info, NULL);\newline\newline    gwlist_lock(wapbox_list);\newline    for(i=0; i &lt gwlist_len(wapbox_list); i++) {\newline	    conn = gwlist_get(wapbox_list, i);\newline	    gwlist_remove_producer(conn-&gtincoming);\newline	    conn-&gtalive = 0;\newline    }\newline    gwlist_unlock(wapbox_list);\newline\newline    gwlist_remove_producer(wapbox_list);\newline    gwlist_remove_producer(flow_threads);\newline}\newline","\newline this thread listens to incoming_wdp list\newline and then routs messages to proper wapbox\newline \newline","5892597","submesh.c","void fill_master_el_info(EL_INFO *mst_el_info,\newline			 const EL_INFO *el_info,\newline			 FLAGS fill_flags)\newline{\newline  FUNCNAME(&quotfill_master_el_info&quot);\newline  int dim = el_info-&gtmesh-&gtdim;\newline  int mst_ov, mst_t = 0, mst_o = 0;\newline\newline  DEBUG_TEST_EXIT(el_info-&gtfill_flag &amp FILL_MASTER_INFO,\newline		  &quotMaster element link not present in &quot\newline		  &quotslave element descriptor.\\n&quot);\newline\newline  memset(mst_el_info, 0, sizeof(*mst_el_info));\newline\newline  mst_el_info-&gtfill_flag = FILL_NOTHING;\newline  mst_el_info-&gtmesh      = get_master(el_info-&gtmesh);\newline\newline  mst_el_info-&gtmacro_el  = el_info-&gtmacro_el-&gtmaster.macro_el;\newline  mst_el_info-&gtel        = el_info-&gtmaster.el;\newline  mst_el_info-&gtparent    = NULL /* could do better here */;\newline\newline  mst_el_info-&gtel_geom_cache.fill_flag  = 0U;\newline  mst_el_info-&gtel_geom_cache.current_el = mst_el_info-&gtel;\newline  \newline  mst_ov = el_info-&gtmaster.opp_vertex;\newline\newline#if DIM_MAX &gt 2\newline  if (dim == 2) {\newline    mst_t = el_info-&gtmaster.el_type;\newline    mst_o = el_info-&gtmaster.orientation;\newline    \newline    mst_el_info-&gtfill_flag |= FILL_ORIENTATION;\newline\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  COPY_DOW(el_info-&gtcoord[sv], mst_el_info-&gtcoord[v]);\newline	}\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v, e;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[v],\newline			  el_info-&gtvertex_bound[sv]);\newline	} else {\newline	  BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[v]);\newline	}\newline      }\newline      for (e = 0; e &lt N_EDGES_3D; e++) {\newline	BNDRY_FLAGS_INIT(mst_el_info-&gtedge_bound[e]);\newline      }\newline      for (e = 0; e &lt N_EDGES_2D; e++) {\newline	int mst_edge = master_edge_3d[!!mst_t][mst_o &lt 0][mst_ov][e];\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_edge],\newline			el_info-&gtedge_bound[e]);\newline      }\newline      mst_el_info-&gtface_bound[mst_ov] = el_info-&gtface_bound[0];\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  } else\newline#endif\newline  {\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	COPY_DOW(el_info-&gtcoord[v], mst_el_info-&gtcoord[mv]);\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[mv],\newline			el_info-&gtvertex_bound[v]);\newline      }\newline      BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[mst_ov]);\newline      if (dim == 1) {\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_ov],\newline			el_info-&gtedge_bound[0]);\newline      }\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  }\newline\newline  if (fill_flags &amp FILL_NEIGH) {\newline    mst_el_info-&gtneigh[mst_ov] = el_info-&gtmst_neigh.el;\newline    mst_el_info-&gtopp_vertex[mst_ov] = el_info-&gtmst_neigh.opp_vertex;\newline    mst_el_info-&gtfill_flag |= FILL_NEIGH;\newline    if (fill_flags &amp FILL_OPP_COORDS) {\newline      COPY_DOW(el_info-&gtmst_neigh.opp_coord, mst_el_info-&gtopp_coord[mst_ov]);\newline      mst_el_info-&gtfill_flag |= FILL_OPP_COORDS;\newline    }\newline  }\newline\newline  mst_el_info-&gtel_type      = mst_t;\newline  mst_el_info-&gtorientation  = mst_o;\newline\newline  if (fill_flags &amp FILL_COORDS) {\newline    mst_el_info-&gtfill_flag |= FILL_COORDS;\newline    COPY_DOW(el_info-&gtmaster.opp_coord, mst_el_info-&gtcoord[mst_ov]);\newline  }\newline}\newline","Construct an EL_INFO structure for the master element attached to\newline the given slave element. This requires FILL_MASTER_INFO to be set\newline in the fill-flags of el_info.\newline \newline The master element will have its el_type and orientation set. If\newline the slave EL_INFO has co-ordinate information, then also the master\newline EL_INFO will be equipped with co-ordinate information.\newline \newline","1345392","verify_packages.c","static PromiseResult VerifyPromisedPackage(EvalContext *ctx, Attributes a, const Promise *pp)\newline{\newline    const char *package = pp-&gtpromiser;\newline\newline    PromiseResult result = PROMISE_RESULT_NOOP;\newline    if (a.packages.package_version)\newline    {\newline        /* The version is specified separately */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified explicitly in promise body&quot, a.packages.package_version);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, a.packages.package_version, &quot*&quot, false));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result,\newline                                             CheckPackageState(ctx, a, pp, package, a.packages.package_version,\newline                                                               RlistScalarValue(rp), false));\newline            }\newline        }\newline    }\newline    else if (a.packages.package_version_regex)\newline    {\newline        /* The name, version and arch are to be extracted from the promiser */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified implicitly in promiser&#039s name&quot, a.packages.package_version_regex);\newline\newline        char version[CF_MAXVARSIZE];\newline        char name[CF_MAXVARSIZE];\newline        char arch[CF_MAXVARSIZE];\newline        strlcpy(version, ExtractFirstReference(a.packages.package_version_regex, package), CF_MAXVARSIZE);\newline        strlcpy(name, ExtractFirstReference(a.packages.package_name_regex, package), CF_MAXVARSIZE);\newline        strlcpy(arch, ExtractFirstReference(a.packages.package_arch_regex, package), CF_MAXVARSIZE);\newline\newline        if (!arch[0])\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        if (strcmp(arch, &quotCF_NOMATCH&quot) == 0)    // no match on arch regex, use any arch\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        Log(LOG_LEVEL_VERBOSE, &quot ... trying arch &#039%s&#039 and version &#039%s&#039&quot, arch, version);\newline        result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, name, version, arch, false));\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version was not specified&quot);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039 and any version &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, &quot*&quot, true));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039 and any version &#039*&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, RlistScalarValue(rp), true));\newline            }\newline        }\newline    }\newline\newline    return result;\newline}\newline","\newline@brief Verifies a promised package operation as defined by a and pp\newlineCalled by VerifyPackagesPromise for any non-patch operation.\newline package name is pp-&gtpromiser\newline promise result starts as NOOP\newline if package version is given\newline if no architecture given, the promise result comes from CheckPackageState with name, version, any architecture &#039 &#039, no_version=false\newline else if architectures were given, the promise result comes from CheckPackageState with name, version, arch, no_version=false FOR EACH ARCHITECTURE\newline else if package_version_regex is given\newline assume that package_name_regex and package_arch_regex are also given and use the 3 regexes to extract name, version, arch\newline if the arch extraction failed, use any architecture &#039 &#039\newline the promise result comes from CheckPackageState with name, version, arch, no_version=false)\newline else (no explicit version is given) (SAME LOOP AS EXPLICIT VERSION LOOP ABOVE)\newline if no architecture given, the promise result comes from CheckPackageState with name, any version &quot &quot, any architecture &#039 &#039, no_version=true\newline else if architectures were given, the promise result comes from CheckPackageState with name, any version &quot &quot, arch, no_version=true FOR EACH ARCHITECTURE\newline@param ctx [in] The evaluation context\newline@param a [in] the Attributes specifying how to compare\newline@param pp [in] the Promise for this operation\newline@returns the promise result as set by CheckPackageState\newline \newline","6366566","decorate_background.cpp","bool FrontFacing(Point3f viewPos,\newline                 int axis, int side,\newline                 Point3f minP, Point3f maxP)\newline{\newline  assert (side==0 || side ==1);\newline  assert (axis&gt=0 &amp&amp axis &lt 3);\newline  Point3f N(0,0,0);\newline  Point3f C = (minP+maxP)/2.0;\newline\newline  if(side == 1) {\newline      C[axis] = maxP[axis];\newline      N[axis]=-1;\newline  }\newline\newline  if(side == 0) {\newline    C[axis] = minP[axis];\newline    N[axis]=1;\newline  }\newline  Point3f vpc = viewPos-C;\newline//  qDebug(&quotFaceCenter %f %f %f - %f %f %f&quot,C[0],C[1],C[2],N[0],N[1],N[2]);\newline//  qDebug(&quotVPC        %f %f %f&quot,vpc[0],vpc[1],vpc[2]);\newline  return vpc*N &gt 0;\newline}\newline","return true if the side of a box is front facing with respet of the give viewpoint.\newlineside 0, axis i == min on than i-th axis\newlineside 1, axis i == min on than i-th axis\newlinequesto capita se il prodotto scalare tra il vettore normale entro della faccia\newline \newline","2741554","xfs_format.h","static inline uint xfs_dinode_size(int version)\newline{\newline	if (version == 3)\newline		return sizeof(struct xfs_dinode);\newline	return offsetof(struct xfs_dinode, di_crc);\newline}\newline","\newline Size of the core inode on disk. Version 1 and 2 inodes have\newline the same size, but version 3 has grown a few additional fields.\newline \newline","2059881","fluid_synth.c","void\newlinefluid_synth_tuning_iteration_start(fluid_synth_t* synth)\newline{\newline  fluid_return_if_fail (synth != NULL);\newline  fluid_synth_api_enter(synth);\newline  fluid_private_set (synth-&gttuning_iter, FLUID_INT_TO_POINTER (0), NULL);\newline  fluid_synth_api_exit(synth);\newline}\newline","\newline Start tuning iteration.\newline @param synth FluidSynth instance\newline \newline","1827703","qcustomplot.cpp","void QCPAxis::setSelectedLabelFont(const QFont &ampfont)\newline{\newline  mSelectedLabelFont = font;\newline}\newline","!\newlineSets the font that is used for the axis label when it is selected.\newline\newline\\see setLabelFont, setSelectable, setSelected, QCustomPlot::setInteractions\newline \newline","3591538","features_cpu.c","uint64_t cpu_features_get(void)\newline{\newline   int flags[4];\newline   int vendor_shuffle[3];\newline   char vendor[13]     = {0};\newline   size_t len          = 0;\newline   uint64_t cpu_flags  = 0;\newline   uint64_t cpu        = 0;\newline   unsigned max_flag   = 0;\newline#if defined(CPU_X86) &amp&amp !defined(__MACH__)\newline   int vendor_is_intel = 0;\newline   const int avx_flags = (1 &lt&lt 27) | (1 &lt&lt 28);\newline#endif\newline\newline   char buf[sizeof(&quot MMX MMXEXT SSE SSE2 SSE3 SSSE3 SS4 SSE4.2 AES AVX AVX2 NEON VMX VMX128 VFPU PS&quot)];\newline\newline   memset(buf, 0, sizeof(buf));\newline\newline   (void)len;\newline   (void)cpu_flags;\newline   (void)flags;\newline   (void)max_flag;\newline   (void)vendor;\newline   (void)vendor_shuffle;\newline\newline#if defined(__MACH__)\newline   len     = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.mmx&quot, NULL, &amplen, NULL, 0) == 0)\newline   {\newline      cpu |= RETRO_SIMD_MMX;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.supplementalsse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_1&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.aes&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AES;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx1_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx2_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.altivec&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_VMX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.neon&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_NEON;\newline\newline#elif defined(CPU_X86)\newline   (void)avx_flags;\newline\newline   x86_cpuid(0, flags);\newline   vendor_shuffle[0] = flags[1];\newline   vendor_shuffle[1] = flags[3];\newline   vendor_shuffle[2] = flags[2];\newline   memcpy(vendor, vendor_shuffle, sizeof(vendor_shuffle));\newline\newline   /* printf(&quot[CPUID]: Vendor: %s\\n&quot, vendor); */\newline\newline   vendor_is_intel = (\newline         flags[1] == VENDOR_INTEL_b &amp&amp\newline         flags[2] == VENDOR_INTEL_c &amp&amp\newline         flags[3] == VENDOR_INTEL_d);\newline\newline   max_flag = flags[0];\newline   if (max_flag &lt 1) /* Does CPUID not support func = 1? (unlikely ...) */\newline      return 0;\newline\newline   x86_cpuid(1, flags);\newline\newline   if (flags[3] &amp (1 &lt&lt 23))\newline      cpu |= RETRO_SIMD_MMX;\newline\newline   if (flags[3] &amp (1 &lt&lt 25))\newline   {\newline      /* SSE also implies MMXEXT (according to FFmpeg source). */\newline      cpu |= RETRO_SIMD_SSE;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline\newline   if (flags[3] &amp (1 &lt&lt 26))\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   if (flags[2] &amp (1 &lt&lt 0))\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 9))\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 19))\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   if (flags[2] &amp (1 &lt&lt 20))\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   if ((flags[2] &amp (1 &lt&lt 23)))\newline      cpu |= RETRO_SIMD_POPCNT;\newline\newline   if (vendor_is_intel &amp&amp (flags[2] &amp (1 &lt&lt 22)))\newline      cpu |= RETRO_SIMD_MOVBE;\newline\newline   if (flags[2] &amp (1 &lt&lt 25))\newline      cpu |= RETRO_SIMD_AES;\newline\newline\newline   /* Must only perform xgetbv check if we have\newline    * AVX CPU support (guaranteed to have at least i686). */\newline   if (((flags[2] &amp avx_flags) == avx_flags)\newline         &amp&amp ((xgetbv_x86(0) &amp 0x6) == 0x6))\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   if (max_flag &gt= 7)\newline   {\newline      x86_cpuid(7, flags);\newline      if (flags[1] &amp (1 &lt&lt 5))\newline         cpu |= RETRO_SIMD_AVX2;\newline   }\newline\newline   x86_cpuid(0x80000000, flags);\newline   max_flag = flags[0];\newline   if (max_flag &gt= 0x80000001u)\newline   {\newline      x86_cpuid(0x80000001, flags);\newline      if (flags[3] &amp (1 &lt&lt 23))\newline         cpu |= RETRO_SIMD_MMX;\newline      if (flags[3] &amp (1 &lt&lt 22))\newline         cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline#elif defined(__linux__)\newline   if (check_arm_cpu_feature(&quotneon&quot))\newline   {\newline      cpu |= RETRO_SIMD_NEON;\newline#ifdef __ARM_NEON__\newline      arm_enable_runfast_mode();\newline#endif\newline   }\newline\newline   if (check_arm_cpu_feature(&quotvfpv3&quot))\newline      cpu |= RETRO_SIMD_VFPV3;\newline\newline   if (check_arm_cpu_feature(&quotvfpv4&quot))\newline      cpu |= RETRO_SIMD_VFPV4;\newline\newline#if 0\newline    check_arm_cpu_feature(&quotswp&quot);\newline    check_arm_cpu_feature(&quothalf&quot);\newline    check_arm_cpu_feature(&quotthumb&quot);\newline    check_arm_cpu_feature(&quotfastmult&quot);\newline    check_arm_cpu_feature(&quotvfp&quot);\newline    check_arm_cpu_feature(&quotedsp&quot);\newline    check_arm_cpu_feature(&quotthumbee&quot);\newline    check_arm_cpu_feature(&quottls&quot);\newline    check_arm_cpu_feature(&quotidiva&quot);\newline    check_arm_cpu_feature(&quotidivt&quot);\newline#endif\newline\newline#elif defined(__ARM_NEON__)\newline   cpu |= RETRO_SIMD_NEON;\newline   arm_enable_runfast_mode();\newline#elif defined(__ALTIVEC__)\newline   cpu |= RETRO_SIMD_VMX;\newline#elif defined(XBOX360)\newline   cpu |= RETRO_SIMD_VMX128;\newline#elif defined(PSP)\newline   cpu |= RETRO_SIMD_VFPU;\newline#elif defined(GEKKO)\newline   cpu |= RETRO_SIMD_PS;\newline#endif\newline\newline   if (cpu &amp RETRO_SIMD_MMX)    strlcat(buf, &quot MMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_MMXEXT) strlcat(buf, &quot MMXEXT&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE)    strlcat(buf, &quot SSE&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE2)   strlcat(buf, &quot SSE2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE3)   strlcat(buf, &quot SSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSSE3)  strlcat(buf, &quot SSSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE4)   strlcat(buf, &quot SSE4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE42)  strlcat(buf, &quot SSE4.2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AES)    strlcat(buf, &quot AES&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX)    strlcat(buf, &quot AVX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX2)   strlcat(buf, &quot AVX2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_NEON)   strlcat(buf, &quot NEON&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV3)  strlcat(buf, &quot VFPv3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV4)  strlcat(buf, &quot VFPv4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX)    strlcat(buf, &quot VMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX128) strlcat(buf, &quot VMX128&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPU)   strlcat(buf, &quot VFPU&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_PS)     strlcat(buf, &quot PS&quot, sizeof(buf));\newline\newline   return cpu;\newline}\newline","\newline cpu_features_get:\newline \newline Gets CPU features..\newline \newline Returns: bitmask of all CPU features available.\newline \newline","3989953","3dsplay.c","void *convert_to_RGB_Surface(SDL_Surface *bitmap)\newline{\newline  unsigned char *pixel = (unsigned char *)malloc(sizeof(char) * 4 * bitmap-&gth * bitmap-&gtw); \newline  int soff = 0;   \newline  int doff = 0;   \newline  int x, y;\newline  unsigned char *spixels = (unsigned char *)bitmap-&gtpixels;\newline  SDL_Palette *pal = bitmap-&gtformat-&gtpalette; \newline\newline  for (y = 0; y &lt bitmap-&gth; y++)\newline    for (x = 0; x &lt bitmap-&gtw; x++)\newline    {\newline      SDL_Color* col = &amppal-&gtcolors[spixels[soff]];\newline\newline      pixel[doff] = col-&gtr; \newline      pixel[doff+1] = col-&gtg; \newline      pixel[doff+2] = col-&gtb; \newline      pixel[doff+3] = 255; \newline      doff += 4; \newline      soff++;\newline    }\newline\newline    return (void *)pixel; \newline}\newline","\newline Convert an SDL bitmap for use with OpenGL.\newline \newline Written by Gernot &lt gz@lysator.liu.se &gt\newline \newline","1778844","config.c","int config_parse_args(int argc, const char **argv, abl_args *args, log_context *logContext) {\newline    int argn;\newline    int err;\newline\newline    config_clear(args);\newline\newline    for (argn = 0; argn &lt argc; argn++) {\newline        err = parse_arg(argv[argn], args, logContext);\newline        if (err) {\newline            return err;\newline        }\newline    }\newline\newline    if (logContext-&gtdebug)\newline        dump_args(args, logContext);\newline\newline    return 0;\newline}\newline","Parse our argments and populate an abl_args structure accordingly.\newline \newline","6010187","rsim.c","private int setpowtrace()\newline  {\newline    apply(xpowtrace, vpowtrace, plus_minus);\newline    set_vec_nodes( POWWATCHVECTOR );\newline    return( 0 );\newline  }\newline","\newline mark nodes and vectors for cap tracing\newline \newline","2744494","apr_dbd_odbc.c","static int odbc_pvbquery(apr_pool_t *pool, apr_dbd_t *handle, int *nrows,\newline                         apr_dbd_prepared_t *statement, va_list args)\newline{\newline    const char **values;\newline    int i;\newline\newline    values = apr_palloc(pool, sizeof(*values) * statement-&gtnvals);\newline    for (i = 0; i &lt statement-&gtnvals; i++)\newline        values[i] = va_arg(args, const char *);\newline    return odbc_pbquery(pool, handle, nrows, statement, (const void **)values);\newline}\newline","pvbquery: query using a prepared statement + binary args \newline","3923291","mincmorph.c","char    *get_real_from_string(char *string, double *value)\newline{\newline   char    *ptr;\newline\newline   /* skip a [ or : else we probably don&#039t belong here */\newline   if(string[0] == &#039[&#039 || string[0] == &#039:&#039){\newline      string++;\newline      }\newline\newline   /* get a double */\newline   *value = strtod(&ampstring[0], &ampptr);\newline\newline   /* if nothing found return a default value */\newline   if(&ampstring[0] == ptr){\newline      *value = DEF_DOUBLE;\newline      }\newline\newline   /* skip over a possible &#039]&#039 */\newline   if(ptr[0] == &#039]&#039){\newline      ptr++;\newline      }\newline\newline   return ptr;\newline   }\newline","as it was input if nothing found \newline","6419704","commands.c","static int cmd_load(const char *filename)\newline{\newline    int slotnum =\newline	load_file(expand_filename_tilde(filename),\newline		  LOADFILE_READifPRESENT);\newline\newline    if (slotnum &gt= 0)\newline    {\newline	lookup.slot = lookup.slot_info[slotnum];\newline	return COMMAND_RUNS_OK;\newline    }\newline    return COMMAND_HAS_ERROR;\newline}\newline","\newline Given a filename, load it.\newline \newline","","on","","on","","","","","","","","","on","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","Send a ""cancel this file transfer"" message?","{}","return true","{}","Start tuning iteration.","Sets the font that is used for the axis label","Returns: bitmask of all CPU features available.","Convert an SDL bitmap for use with OpenGL.","Parse our argments and populate an abl_args structure accordingly.","mark nodes and vectors for cap tracing","query using a prepared statement + binary args","comma-separated list of pairs","{}","load it.","handling in system_properties.c","Reads Dimensions for an icon box from the config file","Initialize a geographic point","determining velocity at a given time","{}","thread listens to incoming_wdp listand then routs messages to proper wapbox","EL_INFO structure for the master element attached tothe given slave element."
"3EGKVCRQFWS5683HUMYP28HOC5OBYH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3IOEN3P9S7J4XA8CC8F92OGB76461V","A3UVGDHG6324FB","Approved","Wed Apr 17 10:52:37 PDT 2019","Wed Apr 17 11:09:14 PDT 2019","Fri Apr 19 11:09:14 PDT 2019","2019-04-19 18:09:21 UTC","","","997","100% (4/4)","100% (4/4)","100% (4/4)","5964550","im.c","faim_export int aim_im_sendch2_sendfile_cancel(aim_session_t *sess, struct aim_oft_info *oft_info)\newline{\newline	aim_conn_t *conn;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline\newline	if (!sess || !(conn = aim_conn_findbygroup(sess, 0x0004)) || !oft_info)\newline		return -EINVAL;\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 10 + 11+strlen(oft_info-&gtsn) + 4+2+8+16)))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0004, 0x0006, 0x0000, NULL, 0);\newline	aim_putsnac(&ampfr-&gtdata, 0x0004, 0x0006, 0x0000, snacid);\newline\newline	/* ICBM header */\newline	aim_im_puticbm(&ampfr-&gtdata, oft_info-&gtcookie, 0x0002, oft_info-&gtsn);\newline\newline	aimbs_put16(&ampfr-&gtdata, 0x0005);\newline	aimbs_put16(&ampfr-&gtdata, 0x001a);\newline	aimbs_put16(&ampfr-&gtdata, AIM_RENDEZVOUS_CANCEL);\newline	aimbs_putraw(&ampfr-&gtdata, oft_info-&gtcookie, 8);\newline	aim_putcap(&ampfr-&gtdata, AIM_CAPS_SENDFILE);\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Subtype 0x0006 - Send a &quotcancel this file transfer&quot message?\newline \newline \newline","2300406","pre.c","int DoSetExternalAttr(UBYTE *s)\newline{\newline#ifdef WITHEXTERNALCHANNEL\newline	int lnam,lval;\newline	UBYTE *nam,*val;\newline#else\newline	DUMMYUSE(s);\newline#endif\newline	if ( AP.PreSwitchModes[AP.PreSwitchLevel] != EXECUTINGPRESWITCH ) return(0);\newline	if ( AP.PreIfStack[AP.PreIfLevel] != EXECUTINGIF ) return(0);\newline\newline#ifdef WITHEXTERNALCHANNEL\newline	do{\newline		/*Read the name:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		s=pickupword(nam=s);\newline		lnam=s-nam;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		if(*s++!=&#039=&#039){\newline			MesPrint(&quot@External channel:&#039=&#039 expected instead of %s&quot,s-1);\newline			return(-1);\newline		}\newline		/*Read the value:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		val=s;\newline\newline		for(;;){\newline			UBYTE *m;\newline			s=pickupword(s);\newline			m=s;\newline			while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline         if( (*s == &#039,&#039)||(*s == &#039\\n&#039)||(*s == &#039;&#039)||(*s == &#039\\0&#039) ){\newline				s=m;\newline				break;\newline			}\newline		}/*for(;;)*/\newline\newline		lval=s-val;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline\newline		if(strINCmp((UBYTE *)SHELL,nam,lnam)==0){\newline			if(AX.shellname!=NULL)\newline				M_free(AX.shellname,&quotexternal channel shellname&quot);\newline			if(strINCmp((UBYTE *)NOSHELL,val,lval)==0)\newline				AX.shellname=NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.shellname=Malloc1(lval+1,&quotexternal channel shellname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else if(strINCmp((UBYTE *)DAEMON,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.daemonize = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.daemonize = 0;\newline			else{\newline				MesPrint(&quot@External channel:true or false expected for %s&quot,DAEMON);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILLALL,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 0;\newline			else{\newline				MesPrint(&quot@External channel: true or false expected for %s&quot,KILLALL);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILL,nam,lnam)==0){\newline			int i,n=0;\newline			for(i=0;i&ltlval;i++)\newline				if( *val&gt=&#0390&#039 &amp&amp *val&lt= &#0399&#039 )\newline					n = 10*n + *val++  - &#0390&#039;\newline				else{\newline					MesPrint(&quot@External channel: number expected for %s&quot,KILL);\newline					return(-1);\newline				}\newline				AX.killSignal=n;\newline		}else	if(strINCmp((UBYTE *)STDERR,nam,lnam)==0){\newline			if( AX.stderrname != NULL ) {\newline				M_free(AX.stderrname,&quotexternal channel stderrname&quot);\newline			}\newline			if(strINCmp((UBYTE *)TERMINAL,val,lval)==0)\newline				AX.stderrname = NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.stderrname=Malloc1(lval+1,&quotexternal channel stderrname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else{\newline			nam[lnam+1]=&#039\\0&#039;\newline			MesPrint(&quot@External channel: unrecognized attribute&quot,nam);\newline			return(-1);\newline		}\newline	}while(*s++ == &#039,&#039);\newline	if(  (*(s-1)&gt&#039 &#039)&amp&amp(*(s-1)!=&#039;&#039)  ){\newline		MesPrint(&quot@External channel: syntax error: %s&quot,s-1);\newline		return(-1);\newline	}\newline   return(0);\newline#else /*ifdef WITHEXTERNALCHANNEL*/\newline	Error0(&quotExternal channel: not implemented on this computer/system&quot);\newline	return(-1);\newline#endif /*ifdef WITHEXTERNALCHANNEL ... else*/\newline}\newline","\newline Expects comma-separated list of pairs name=value\newline \newline","4045357","androresolvd.c","int __futex_wait(volatile void *ftx, int val, const struct timespec *timeout)\newline{\newline	return syscall(SYS_futex, ftx, FUTEX_WAIT, val, (void *)timeout, NULL, NULL);\newline}\newline","\newline This syscall is required by Android&#039s properties handling in system_properties.c\newline \newline","3213244","configure.c","void SetBox(char *text, FILE *fd, char **arg,int *junk)\newline{\newline  int num;\newline\newline  if(Scr.NumBoxes &lt MAX_BOXES)\newline    {\newline      /* Standard X11 geometry string */\newline      num = sscanf(text,&quot%d%d%d%d&quot,&ampScr.IconBoxes[Scr.NumBoxes][0],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][1],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][2],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][3]);\newline\newline      /* check for negative locations */\newline      if(Scr.IconBoxes[Scr.NumBoxes][0] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][0] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][1] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][1] += Scr.MyDisplayHeight;\newline\newline      if(Scr.IconBoxes[Scr.NumBoxes][2] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][2] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][3] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][3] += Scr.MyDisplayHeight;\newline\newline      if(num == 4)\newline	Scr.NumBoxes++;\newline    }\newline}\newline","\newline \newline Reads Dimensions for an icon box from the config file\newline \newline \newline","2787820","lwgeodetic.c","void geographic_point_init(double lon, double lat, GEOGRAPHIC_POINT *g)\newline{\newline	g-&gtlat = latitude_radians_normalize(deg2rad(lat));\newline	g-&gtlon = longitude_radians_normalize(deg2rad(lon));\newline}\newline","\newline Initialize a geographic point\newline @param lon longitude in degrees\newline @param lat latitude in degrees\newline \newline","4487750","bg_misc.c","void BG_EvaluateTrajectoryDelta( const trajectory_t *tr, int atTime, vec3_t result ) {\newline	float	deltaTime;\newline	float	phase;\newline\newline	switch( tr-&gttrType ) {\newline	case TR_STATIONARY:\newline	case TR_INTERPOLATE:\newline		VectorClear( result );\newline		break;\newline	case TR_LINEAR:\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_SINE:\newline		deltaTime = ( atTime - tr-&gttrTime ) / (float) tr-&gttrDuration;\newline		phase = cos( deltaTime * M_PI * 2 );	// derivative of sin = cos\newline		phase *= 0.5;\newline		VectorScale( tr-&gttrDelta, phase, result );\newline		break;\newline	case TR_LINEAR_STOP:\newline		if ( atTime &gt tr-&gttrTime + tr-&gttrDuration ) {\newline			VectorClear( result );\newline			return;\newline		}\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_GRAVITY:\newline		deltaTime = ( atTime - tr-&gttrTime ) * 0.001;	// milliseconds to seconds\newline		VectorCopy( tr-&gttrDelta, result );\newline		result[2] -= DEFAULT_GRAVITY * deltaTime;		// FIXME: local gravity...\newline		break;\newline	default:\newline		Com_Error( ERR_DROP, &quotBG_EvaluateTrajectoryDelta: unknown trType: %i&quot, tr-&gttrTime );\newline		break;\newline	}\newline}\newline","\newline================\newlineBG_EvaluateTrajectoryDelta\newlineFor determining velocity at a given time\newline================\newline \newline","5357659","file.c","int CDECL MSVCRT__vfwprintf_l(MSVCRT_FILE* file, const MSVCRT_wchar_t *format,\newline        MSVCRT__locale_t locale, __ms_va_list valist)\newline{\newline    BOOL tmp_buf;\newline    int ret;\newline\newline    if (!MSVCRT_CHECK_PMT( file != NULL )) return -1;\newline\newline    MSVCRT__lock_file(file);\newline    tmp_buf = add_std_buffer(file);\newline    ret = pf_printf_w(puts_clbk_file_w, file, format, locale, 0, arg_clbk_valist, NULL, &ampvalist);\newline    if(tmp_buf) remove_std_buffer(file);\newline    MSVCRT__unlock_file(file);\newline\newline    return ret;\newline}\newline","\newline _vfwprintf_l (MSVCRT.@)\newline \newline","4515228","bb_boxc.c","static void wdp_to_wapboxes(void *arg)\newline{\newline    List *route_info;\newline    AddrPar *ap;\newline    Boxc *conn;\newline    Msg *msg;\newline    int i;\newline\newline    gwlist_add_producer(flow_threads);\newline    gwlist_add_producer(wapbox_list);\newline\newline    route_info = gwlist_create();\newline\newline\newline    while(bb_status != BB_DEAD) {\newline\newline	    gwlist_consume(suspended);	/* block here if suspended */\newline\newline	    if ((msg = gwlist_consume(incoming_wdp)) == NULL)\newline	         break;\newline\newline	    gw_assert(msg_type(msg) == wdp_datagram);\newline\newline	    conn = route_msg(route_info, msg);\newline	    if (conn == NULL) {\newline	        warning(0, &quotCannot route message, discard it&quot);\newline	        msg_destroy(msg);\newline	        continue;\newline	    }\newline	    gwlist_produce(conn-&gtincoming, msg);\newline    }\newline    debug(&quotbb&quot, 0, &quotwdp_to_wapboxes: destroying lists&quot);\newline    while((ap = gwlist_extract_first(route_info)) != NULL)\newline	ap_destroy(ap);\newline\newline    gw_assert(gwlist_len(route_info) == 0);\newline    gwlist_destroy(route_info, NULL);\newline\newline    gwlist_lock(wapbox_list);\newline    for(i=0; i &lt gwlist_len(wapbox_list); i++) {\newline	    conn = gwlist_get(wapbox_list, i);\newline	    gwlist_remove_producer(conn-&gtincoming);\newline	    conn-&gtalive = 0;\newline    }\newline    gwlist_unlock(wapbox_list);\newline\newline    gwlist_remove_producer(wapbox_list);\newline    gwlist_remove_producer(flow_threads);\newline}\newline","\newline this thread listens to incoming_wdp list\newline and then routs messages to proper wapbox\newline \newline","5892597","submesh.c","void fill_master_el_info(EL_INFO *mst_el_info,\newline			 const EL_INFO *el_info,\newline			 FLAGS fill_flags)\newline{\newline  FUNCNAME(&quotfill_master_el_info&quot);\newline  int dim = el_info-&gtmesh-&gtdim;\newline  int mst_ov, mst_t = 0, mst_o = 0;\newline\newline  DEBUG_TEST_EXIT(el_info-&gtfill_flag &amp FILL_MASTER_INFO,\newline		  &quotMaster element link not present in &quot\newline		  &quotslave element descriptor.\\n&quot);\newline\newline  memset(mst_el_info, 0, sizeof(*mst_el_info));\newline\newline  mst_el_info-&gtfill_flag = FILL_NOTHING;\newline  mst_el_info-&gtmesh      = get_master(el_info-&gtmesh);\newline\newline  mst_el_info-&gtmacro_el  = el_info-&gtmacro_el-&gtmaster.macro_el;\newline  mst_el_info-&gtel        = el_info-&gtmaster.el;\newline  mst_el_info-&gtparent    = NULL /* could do better here */;\newline\newline  mst_el_info-&gtel_geom_cache.fill_flag  = 0U;\newline  mst_el_info-&gtel_geom_cache.current_el = mst_el_info-&gtel;\newline  \newline  mst_ov = el_info-&gtmaster.opp_vertex;\newline\newline#if DIM_MAX &gt 2\newline  if (dim == 2) {\newline    mst_t = el_info-&gtmaster.el_type;\newline    mst_o = el_info-&gtmaster.orientation;\newline    \newline    mst_el_info-&gtfill_flag |= FILL_ORIENTATION;\newline\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  COPY_DOW(el_info-&gtcoord[sv], mst_el_info-&gtcoord[v]);\newline	}\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v, e;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[v],\newline			  el_info-&gtvertex_bound[sv]);\newline	} else {\newline	  BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[v]);\newline	}\newline      }\newline      for (e = 0; e &lt N_EDGES_3D; e++) {\newline	BNDRY_FLAGS_INIT(mst_el_info-&gtedge_bound[e]);\newline      }\newline      for (e = 0; e &lt N_EDGES_2D; e++) {\newline	int mst_edge = master_edge_3d[!!mst_t][mst_o &lt 0][mst_ov][e];\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_edge],\newline			el_info-&gtedge_bound[e]);\newline      }\newline      mst_el_info-&gtface_bound[mst_ov] = el_info-&gtface_bound[0];\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  } else\newline#endif\newline  {\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	COPY_DOW(el_info-&gtcoord[v], mst_el_info-&gtcoord[mv]);\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[mv],\newline			el_info-&gtvertex_bound[v]);\newline      }\newline      BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[mst_ov]);\newline      if (dim == 1) {\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_ov],\newline			el_info-&gtedge_bound[0]);\newline      }\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  }\newline\newline  if (fill_flags &amp FILL_NEIGH) {\newline    mst_el_info-&gtneigh[mst_ov] = el_info-&gtmst_neigh.el;\newline    mst_el_info-&gtopp_vertex[mst_ov] = el_info-&gtmst_neigh.opp_vertex;\newline    mst_el_info-&gtfill_flag |= FILL_NEIGH;\newline    if (fill_flags &amp FILL_OPP_COORDS) {\newline      COPY_DOW(el_info-&gtmst_neigh.opp_coord, mst_el_info-&gtopp_coord[mst_ov]);\newline      mst_el_info-&gtfill_flag |= FILL_OPP_COORDS;\newline    }\newline  }\newline\newline  mst_el_info-&gtel_type      = mst_t;\newline  mst_el_info-&gtorientation  = mst_o;\newline\newline  if (fill_flags &amp FILL_COORDS) {\newline    mst_el_info-&gtfill_flag |= FILL_COORDS;\newline    COPY_DOW(el_info-&gtmaster.opp_coord, mst_el_info-&gtcoord[mst_ov]);\newline  }\newline}\newline","Construct an EL_INFO structure for the master element attached to\newline the given slave element. This requires FILL_MASTER_INFO to be set\newline in the fill-flags of el_info.\newline \newline The master element will have its el_type and orientation set. If\newline the slave EL_INFO has co-ordinate information, then also the master\newline EL_INFO will be equipped with co-ordinate information.\newline \newline","1345392","verify_packages.c","static PromiseResult VerifyPromisedPackage(EvalContext *ctx, Attributes a, const Promise *pp)\newline{\newline    const char *package = pp-&gtpromiser;\newline\newline    PromiseResult result = PROMISE_RESULT_NOOP;\newline    if (a.packages.package_version)\newline    {\newline        /* The version is specified separately */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified explicitly in promise body&quot, a.packages.package_version);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, a.packages.package_version, &quot*&quot, false));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result,\newline                                             CheckPackageState(ctx, a, pp, package, a.packages.package_version,\newline                                                               RlistScalarValue(rp), false));\newline            }\newline        }\newline    }\newline    else if (a.packages.package_version_regex)\newline    {\newline        /* The name, version and arch are to be extracted from the promiser */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified implicitly in promiser&#039s name&quot, a.packages.package_version_regex);\newline\newline        char version[CF_MAXVARSIZE];\newline        char name[CF_MAXVARSIZE];\newline        char arch[CF_MAXVARSIZE];\newline        strlcpy(version, ExtractFirstReference(a.packages.package_version_regex, package), CF_MAXVARSIZE);\newline        strlcpy(name, ExtractFirstReference(a.packages.package_name_regex, package), CF_MAXVARSIZE);\newline        strlcpy(arch, ExtractFirstReference(a.packages.package_arch_regex, package), CF_MAXVARSIZE);\newline\newline        if (!arch[0])\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        if (strcmp(arch, &quotCF_NOMATCH&quot) == 0)    // no match on arch regex, use any arch\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        Log(LOG_LEVEL_VERBOSE, &quot ... trying arch &#039%s&#039 and version &#039%s&#039&quot, arch, version);\newline        result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, name, version, arch, false));\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version was not specified&quot);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039 and any version &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, &quot*&quot, true));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039 and any version &#039*&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, RlistScalarValue(rp), true));\newline            }\newline        }\newline    }\newline\newline    return result;\newline}\newline","\newline@brief Verifies a promised package operation as defined by a and pp\newlineCalled by VerifyPackagesPromise for any non-patch operation.\newline package name is pp-&gtpromiser\newline promise result starts as NOOP\newline if package version is given\newline if no architecture given, the promise result comes from CheckPackageState with name, version, any architecture &#039 &#039, no_version=false\newline else if architectures were given, the promise result comes from CheckPackageState with name, version, arch, no_version=false FOR EACH ARCHITECTURE\newline else if package_version_regex is given\newline assume that package_name_regex and package_arch_regex are also given and use the 3 regexes to extract name, version, arch\newline if the arch extraction failed, use any architecture &#039 &#039\newline the promise result comes from CheckPackageState with name, version, arch, no_version=false)\newline else (no explicit version is given) (SAME LOOP AS EXPLICIT VERSION LOOP ABOVE)\newline if no architecture given, the promise result comes from CheckPackageState with name, any version &quot &quot, any architecture &#039 &#039, no_version=true\newline else if architectures were given, the promise result comes from CheckPackageState with name, any version &quot &quot, arch, no_version=true FOR EACH ARCHITECTURE\newline@param ctx [in] The evaluation context\newline@param a [in] the Attributes specifying how to compare\newline@param pp [in] the Promise for this operation\newline@returns the promise result as set by CheckPackageState\newline \newline","6366566","decorate_background.cpp","bool FrontFacing(Point3f viewPos,\newline                 int axis, int side,\newline                 Point3f minP, Point3f maxP)\newline{\newline  assert (side==0 || side ==1);\newline  assert (axis&gt=0 &amp&amp axis &lt 3);\newline  Point3f N(0,0,0);\newline  Point3f C = (minP+maxP)/2.0;\newline\newline  if(side == 1) {\newline      C[axis] = maxP[axis];\newline      N[axis]=-1;\newline  }\newline\newline  if(side == 0) {\newline    C[axis] = minP[axis];\newline    N[axis]=1;\newline  }\newline  Point3f vpc = viewPos-C;\newline//  qDebug(&quotFaceCenter %f %f %f - %f %f %f&quot,C[0],C[1],C[2],N[0],N[1],N[2]);\newline//  qDebug(&quotVPC        %f %f %f&quot,vpc[0],vpc[1],vpc[2]);\newline  return vpc*N &gt 0;\newline}\newline","return true if the side of a box is front facing with respet of the give viewpoint.\newlineside 0, axis i == min on than i-th axis\newlineside 1, axis i == min on than i-th axis\newlinequesto capita se il prodotto scalare tra il vettore normale entro della faccia\newline \newline","2741554","xfs_format.h","static inline uint xfs_dinode_size(int version)\newline{\newline	if (version == 3)\newline		return sizeof(struct xfs_dinode);\newline	return offsetof(struct xfs_dinode, di_crc);\newline}\newline","\newline Size of the core inode on disk. Version 1 and 2 inodes have\newline the same size, but version 3 has grown a few additional fields.\newline \newline","2059881","fluid_synth.c","void\newlinefluid_synth_tuning_iteration_start(fluid_synth_t* synth)\newline{\newline  fluid_return_if_fail (synth != NULL);\newline  fluid_synth_api_enter(synth);\newline  fluid_private_set (synth-&gttuning_iter, FLUID_INT_TO_POINTER (0), NULL);\newline  fluid_synth_api_exit(synth);\newline}\newline","\newline Start tuning iteration.\newline @param synth FluidSynth instance\newline \newline","1827703","qcustomplot.cpp","void QCPAxis::setSelectedLabelFont(const QFont &ampfont)\newline{\newline  mSelectedLabelFont = font;\newline}\newline","!\newlineSets the font that is used for the axis label when it is selected.\newline\newline\\see setLabelFont, setSelectable, setSelected, QCustomPlot::setInteractions\newline \newline","3591538","features_cpu.c","uint64_t cpu_features_get(void)\newline{\newline   int flags[4];\newline   int vendor_shuffle[3];\newline   char vendor[13]     = {0};\newline   size_t len          = 0;\newline   uint64_t cpu_flags  = 0;\newline   uint64_t cpu        = 0;\newline   unsigned max_flag   = 0;\newline#if defined(CPU_X86) &amp&amp !defined(__MACH__)\newline   int vendor_is_intel = 0;\newline   const int avx_flags = (1 &lt&lt 27) | (1 &lt&lt 28);\newline#endif\newline\newline   char buf[sizeof(&quot MMX MMXEXT SSE SSE2 SSE3 SSSE3 SS4 SSE4.2 AES AVX AVX2 NEON VMX VMX128 VFPU PS&quot)];\newline\newline   memset(buf, 0, sizeof(buf));\newline\newline   (void)len;\newline   (void)cpu_flags;\newline   (void)flags;\newline   (void)max_flag;\newline   (void)vendor;\newline   (void)vendor_shuffle;\newline\newline#if defined(__MACH__)\newline   len     = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.mmx&quot, NULL, &amplen, NULL, 0) == 0)\newline   {\newline      cpu |= RETRO_SIMD_MMX;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.supplementalsse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_1&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.aes&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AES;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx1_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx2_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.altivec&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_VMX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.neon&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_NEON;\newline\newline#elif defined(CPU_X86)\newline   (void)avx_flags;\newline\newline   x86_cpuid(0, flags);\newline   vendor_shuffle[0] = flags[1];\newline   vendor_shuffle[1] = flags[3];\newline   vendor_shuffle[2] = flags[2];\newline   memcpy(vendor, vendor_shuffle, sizeof(vendor_shuffle));\newline\newline   /* printf(&quot[CPUID]: Vendor: %s\\n&quot, vendor); */\newline\newline   vendor_is_intel = (\newline         flags[1] == VENDOR_INTEL_b &amp&amp\newline         flags[2] == VENDOR_INTEL_c &amp&amp\newline         flags[3] == VENDOR_INTEL_d);\newline\newline   max_flag = flags[0];\newline   if (max_flag &lt 1) /* Does CPUID not support func = 1? (unlikely ...) */\newline      return 0;\newline\newline   x86_cpuid(1, flags);\newline\newline   if (flags[3] &amp (1 &lt&lt 23))\newline      cpu |= RETRO_SIMD_MMX;\newline\newline   if (flags[3] &amp (1 &lt&lt 25))\newline   {\newline      /* SSE also implies MMXEXT (according to FFmpeg source). */\newline      cpu |= RETRO_SIMD_SSE;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline\newline   if (flags[3] &amp (1 &lt&lt 26))\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   if (flags[2] &amp (1 &lt&lt 0))\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 9))\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 19))\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   if (flags[2] &amp (1 &lt&lt 20))\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   if ((flags[2] &amp (1 &lt&lt 23)))\newline      cpu |= RETRO_SIMD_POPCNT;\newline\newline   if (vendor_is_intel &amp&amp (flags[2] &amp (1 &lt&lt 22)))\newline      cpu |= RETRO_SIMD_MOVBE;\newline\newline   if (flags[2] &amp (1 &lt&lt 25))\newline      cpu |= RETRO_SIMD_AES;\newline\newline\newline   /* Must only perform xgetbv check if we have\newline    * AVX CPU support (guaranteed to have at least i686). */\newline   if (((flags[2] &amp avx_flags) == avx_flags)\newline         &amp&amp ((xgetbv_x86(0) &amp 0x6) == 0x6))\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   if (max_flag &gt= 7)\newline   {\newline      x86_cpuid(7, flags);\newline      if (flags[1] &amp (1 &lt&lt 5))\newline         cpu |= RETRO_SIMD_AVX2;\newline   }\newline\newline   x86_cpuid(0x80000000, flags);\newline   max_flag = flags[0];\newline   if (max_flag &gt= 0x80000001u)\newline   {\newline      x86_cpuid(0x80000001, flags);\newline      if (flags[3] &amp (1 &lt&lt 23))\newline         cpu |= RETRO_SIMD_MMX;\newline      if (flags[3] &amp (1 &lt&lt 22))\newline         cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline#elif defined(__linux__)\newline   if (check_arm_cpu_feature(&quotneon&quot))\newline   {\newline      cpu |= RETRO_SIMD_NEON;\newline#ifdef __ARM_NEON__\newline      arm_enable_runfast_mode();\newline#endif\newline   }\newline\newline   if (check_arm_cpu_feature(&quotvfpv3&quot))\newline      cpu |= RETRO_SIMD_VFPV3;\newline\newline   if (check_arm_cpu_feature(&quotvfpv4&quot))\newline      cpu |= RETRO_SIMD_VFPV4;\newline\newline#if 0\newline    check_arm_cpu_feature(&quotswp&quot);\newline    check_arm_cpu_feature(&quothalf&quot);\newline    check_arm_cpu_feature(&quotthumb&quot);\newline    check_arm_cpu_feature(&quotfastmult&quot);\newline    check_arm_cpu_feature(&quotvfp&quot);\newline    check_arm_cpu_feature(&quotedsp&quot);\newline    check_arm_cpu_feature(&quotthumbee&quot);\newline    check_arm_cpu_feature(&quottls&quot);\newline    check_arm_cpu_feature(&quotidiva&quot);\newline    check_arm_cpu_feature(&quotidivt&quot);\newline#endif\newline\newline#elif defined(__ARM_NEON__)\newline   cpu |= RETRO_SIMD_NEON;\newline   arm_enable_runfast_mode();\newline#elif defined(__ALTIVEC__)\newline   cpu |= RETRO_SIMD_VMX;\newline#elif defined(XBOX360)\newline   cpu |= RETRO_SIMD_VMX128;\newline#elif defined(PSP)\newline   cpu |= RETRO_SIMD_VFPU;\newline#elif defined(GEKKO)\newline   cpu |= RETRO_SIMD_PS;\newline#endif\newline\newline   if (cpu &amp RETRO_SIMD_MMX)    strlcat(buf, &quot MMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_MMXEXT) strlcat(buf, &quot MMXEXT&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE)    strlcat(buf, &quot SSE&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE2)   strlcat(buf, &quot SSE2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE3)   strlcat(buf, &quot SSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSSE3)  strlcat(buf, &quot SSSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE4)   strlcat(buf, &quot SSE4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE42)  strlcat(buf, &quot SSE4.2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AES)    strlcat(buf, &quot AES&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX)    strlcat(buf, &quot AVX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX2)   strlcat(buf, &quot AVX2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_NEON)   strlcat(buf, &quot NEON&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV3)  strlcat(buf, &quot VFPv3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV4)  strlcat(buf, &quot VFPv4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX)    strlcat(buf, &quot VMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX128) strlcat(buf, &quot VMX128&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPU)   strlcat(buf, &quot VFPU&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_PS)     strlcat(buf, &quot PS&quot, sizeof(buf));\newline\newline   return cpu;\newline}\newline","\newline cpu_features_get:\newline \newline Gets CPU features..\newline \newline Returns: bitmask of all CPU features available.\newline \newline","3989953","3dsplay.c","void *convert_to_RGB_Surface(SDL_Surface *bitmap)\newline{\newline  unsigned char *pixel = (unsigned char *)malloc(sizeof(char) * 4 * bitmap-&gth * bitmap-&gtw); \newline  int soff = 0;   \newline  int doff = 0;   \newline  int x, y;\newline  unsigned char *spixels = (unsigned char *)bitmap-&gtpixels;\newline  SDL_Palette *pal = bitmap-&gtformat-&gtpalette; \newline\newline  for (y = 0; y &lt bitmap-&gth; y++)\newline    for (x = 0; x &lt bitmap-&gtw; x++)\newline    {\newline      SDL_Color* col = &amppal-&gtcolors[spixels[soff]];\newline\newline      pixel[doff] = col-&gtr; \newline      pixel[doff+1] = col-&gtg; \newline      pixel[doff+2] = col-&gtb; \newline      pixel[doff+3] = 255; \newline      doff += 4; \newline      soff++;\newline    }\newline\newline    return (void *)pixel; \newline}\newline","\newline Convert an SDL bitmap for use with OpenGL.\newline \newline Written by Gernot &lt gz@lysator.liu.se &gt\newline \newline","1778844","config.c","int config_parse_args(int argc, const char **argv, abl_args *args, log_context *logContext) {\newline    int argn;\newline    int err;\newline\newline    config_clear(args);\newline\newline    for (argn = 0; argn &lt argc; argn++) {\newline        err = parse_arg(argv[argn], args, logContext);\newline        if (err) {\newline            return err;\newline        }\newline    }\newline\newline    if (logContext-&gtdebug)\newline        dump_args(args, logContext);\newline\newline    return 0;\newline}\newline","Parse our argments and populate an abl_args structure accordingly.\newline \newline","6010187","rsim.c","private int setpowtrace()\newline  {\newline    apply(xpowtrace, vpowtrace, plus_minus);\newline    set_vec_nodes( POWWATCHVECTOR );\newline    return( 0 );\newline  }\newline","\newline mark nodes and vectors for cap tracing\newline \newline","2744494","apr_dbd_odbc.c","static int odbc_pvbquery(apr_pool_t *pool, apr_dbd_t *handle, int *nrows,\newline                         apr_dbd_prepared_t *statement, va_list args)\newline{\newline    const char **values;\newline    int i;\newline\newline    values = apr_palloc(pool, sizeof(*values) * statement-&gtnvals);\newline    for (i = 0; i &lt statement-&gtnvals; i++)\newline        values[i] = va_arg(args, const char *);\newline    return odbc_pbquery(pool, handle, nrows, statement, (const void **)values);\newline}\newline","pvbquery: query using a prepared statement + binary args \newline","3923291","mincmorph.c","char    *get_real_from_string(char *string, double *value)\newline{\newline   char    *ptr;\newline\newline   /* skip a [ or : else we probably don&#039t belong here */\newline   if(string[0] == &#039[&#039 || string[0] == &#039:&#039){\newline      string++;\newline      }\newline\newline   /* get a double */\newline   *value = strtod(&ampstring[0], &ampptr);\newline\newline   /* if nothing found return a default value */\newline   if(&ampstring[0] == ptr){\newline      *value = DEF_DOUBLE;\newline      }\newline\newline   /* skip over a possible &#039]&#039 */\newline   if(ptr[0] == &#039]&#039){\newline      ptr++;\newline      }\newline\newline   return ptr;\newline   }\newline","as it was input if nothing found \newline","6419704","commands.c","static int cmd_load(const char *filename)\newline{\newline    int slotnum =\newline	load_file(expand_filename_tilde(filename),\newline		  LOADFILE_READifPRESENT);\newline\newline    if (slotnum &gt= 0)\newline    {\newline	lookup.slot = lookup.slot_info[slotnum];\newline	return COMMAND_RUNS_OK;\newline    }\newline    return COMMAND_HAS_ERROR;\newline}\newline","\newline Given a filename, load it.\newline \newline","on","","","","","","","","","","","on","on","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","{}","Verifies a promised package operation as defined by a and pp","return true if the side of a box is front facing","Size of the core inode on disk.","Start tuning iteration.","Sets the font that is used for the axis label","Gets CPU features..","Convert an SDL bitmap for use with OpenGL.","Parse our argments and populate an abl_args structure accordingly.","mark nodes and vectors for cap tracing","query using a prepared statement + binary args","{}","{}","Given a filename, load it.","This syscall is required by Android's properties handling in system_properties.c","Reads Dimensions for an icon box from the config file","Initialize a geographic point","For determining velocity at a given time","{}","listens to incoming_wdp list and then routs messages to proper wapbox","Construct an EL_INFO structure for the master element"
"3EGKVCRQFWS5683HUMYP28HOC5OBYH","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3TXD01ZLD4H6RKVWV8WEGS1UMCJ4UV","A2MX5YW3DSQ61W","Approved","Wed Apr 17 12:22:03 PDT 2019","Wed Apr 17 12:32:57 PDT 2019","Fri Apr 19 12:32:57 PDT 2019","2019-04-19 19:33:21 UTC","","","654","100% (5/5)","100% (5/5)","100% (5/5)","5964550","im.c","faim_export int aim_im_sendch2_sendfile_cancel(aim_session_t *sess, struct aim_oft_info *oft_info)\newline{\newline	aim_conn_t *conn;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline\newline	if (!sess || !(conn = aim_conn_findbygroup(sess, 0x0004)) || !oft_info)\newline		return -EINVAL;\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 10 + 11+strlen(oft_info-&gtsn) + 4+2+8+16)))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0004, 0x0006, 0x0000, NULL, 0);\newline	aim_putsnac(&ampfr-&gtdata, 0x0004, 0x0006, 0x0000, snacid);\newline\newline	/* ICBM header */\newline	aim_im_puticbm(&ampfr-&gtdata, oft_info-&gtcookie, 0x0002, oft_info-&gtsn);\newline\newline	aimbs_put16(&ampfr-&gtdata, 0x0005);\newline	aimbs_put16(&ampfr-&gtdata, 0x001a);\newline	aimbs_put16(&ampfr-&gtdata, AIM_RENDEZVOUS_CANCEL);\newline	aimbs_putraw(&ampfr-&gtdata, oft_info-&gtcookie, 8);\newline	aim_putcap(&ampfr-&gtdata, AIM_CAPS_SENDFILE);\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Subtype 0x0006 - Send a &quotcancel this file transfer&quot message?\newline \newline \newline","2300406","pre.c","int DoSetExternalAttr(UBYTE *s)\newline{\newline#ifdef WITHEXTERNALCHANNEL\newline	int lnam,lval;\newline	UBYTE *nam,*val;\newline#else\newline	DUMMYUSE(s);\newline#endif\newline	if ( AP.PreSwitchModes[AP.PreSwitchLevel] != EXECUTINGPRESWITCH ) return(0);\newline	if ( AP.PreIfStack[AP.PreIfLevel] != EXECUTINGIF ) return(0);\newline\newline#ifdef WITHEXTERNALCHANNEL\newline	do{\newline		/*Read the name:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		s=pickupword(nam=s);\newline		lnam=s-nam;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		if(*s++!=&#039=&#039){\newline			MesPrint(&quot@External channel:&#039=&#039 expected instead of %s&quot,s-1);\newline			return(-1);\newline		}\newline		/*Read the value:*/\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline		val=s;\newline\newline		for(;;){\newline			UBYTE *m;\newline			s=pickupword(s);\newline			m=s;\newline			while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline         if( (*s == &#039,&#039)||(*s == &#039\\n&#039)||(*s == &#039;&#039)||(*s == &#039\\0&#039) ){\newline				s=m;\newline				break;\newline			}\newline		}/*for(;;)*/\newline\newline		lval=s-val;\newline		while ( *s == &#039 &#039 || *s == &#039\\t&#039 ) s++;\newline\newline		if(strINCmp((UBYTE *)SHELL,nam,lnam)==0){\newline			if(AX.shellname!=NULL)\newline				M_free(AX.shellname,&quotexternal channel shellname&quot);\newline			if(strINCmp((UBYTE *)NOSHELL,val,lval)==0)\newline				AX.shellname=NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.shellname=Malloc1(lval+1,&quotexternal channel shellname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else if(strINCmp((UBYTE *)DAEMON,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.daemonize = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.daemonize = 0;\newline			else{\newline				MesPrint(&quot@External channel:true or false expected for %s&quot,DAEMON);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILLALL,nam,lnam)==0){\newline			if(strINCmp((UBYTE *)TRUE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 1;\newline			else if(strINCmp((UBYTE *)FALSE_EXPR,val,lval)==0)\newline				AX.killWholeGroup = 0;\newline			else{\newline				MesPrint(&quot@External channel: true or false expected for %s&quot,KILLALL);\newline				return(-1);\newline			}\newline		}else	if(strINCmp((UBYTE *)KILL,nam,lnam)==0){\newline			int i,n=0;\newline			for(i=0;i&ltlval;i++)\newline				if( *val&gt=&#0390&#039 &amp&amp *val&lt= &#0399&#039 )\newline					n = 10*n + *val++  - &#0390&#039;\newline				else{\newline					MesPrint(&quot@External channel: number expected for %s&quot,KILL);\newline					return(-1);\newline				}\newline				AX.killSignal=n;\newline		}else	if(strINCmp((UBYTE *)STDERR,nam,lnam)==0){\newline			if( AX.stderrname != NULL ) {\newline				M_free(AX.stderrname,&quotexternal channel stderrname&quot);\newline			}\newline			if(strINCmp((UBYTE *)TERMINAL,val,lval)==0)\newline				AX.stderrname = NULL;\newline			else{\newline				UBYTE *ch,*b;\newline				b=ch=AX.stderrname=Malloc1(lval+1,&quotexternal channel stderrname&quot);\newline				while(ch-b&ltlval)\newline					*ch++=*val++;\newline				*ch=&#039\\0&#039;\newline			}\newline		}else{\newline			nam[lnam+1]=&#039\\0&#039;\newline			MesPrint(&quot@External channel: unrecognized attribute&quot,nam);\newline			return(-1);\newline		}\newline	}while(*s++ == &#039,&#039);\newline	if(  (*(s-1)&gt&#039 &#039)&amp&amp(*(s-1)!=&#039;&#039)  ){\newline		MesPrint(&quot@External channel: syntax error: %s&quot,s-1);\newline		return(-1);\newline	}\newline   return(0);\newline#else /*ifdef WITHEXTERNALCHANNEL*/\newline	Error0(&quotExternal channel: not implemented on this computer/system&quot);\newline	return(-1);\newline#endif /*ifdef WITHEXTERNALCHANNEL ... else*/\newline}\newline","\newline Expects comma-separated list of pairs name=value\newline \newline","4045357","androresolvd.c","int __futex_wait(volatile void *ftx, int val, const struct timespec *timeout)\newline{\newline	return syscall(SYS_futex, ftx, FUTEX_WAIT, val, (void *)timeout, NULL, NULL);\newline}\newline","\newline This syscall is required by Android&#039s properties handling in system_properties.c\newline \newline","3213244","configure.c","void SetBox(char *text, FILE *fd, char **arg,int *junk)\newline{\newline  int num;\newline\newline  if(Scr.NumBoxes &lt MAX_BOXES)\newline    {\newline      /* Standard X11 geometry string */\newline      num = sscanf(text,&quot%d%d%d%d&quot,&ampScr.IconBoxes[Scr.NumBoxes][0],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][1],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][2],\newline	     &ampScr.IconBoxes[Scr.NumBoxes][3]);\newline\newline      /* check for negative locations */\newline      if(Scr.IconBoxes[Scr.NumBoxes][0] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][0] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][1] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][1] += Scr.MyDisplayHeight;\newline\newline      if(Scr.IconBoxes[Scr.NumBoxes][2] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][2] += Scr.MyDisplayWidth;\newline      if(Scr.IconBoxes[Scr.NumBoxes][3] &lt 0)\newline	Scr.IconBoxes[Scr.NumBoxes][3] += Scr.MyDisplayHeight;\newline\newline      if(num == 4)\newline	Scr.NumBoxes++;\newline    }\newline}\newline","\newline \newline Reads Dimensions for an icon box from the config file\newline \newline \newline","2787820","lwgeodetic.c","void geographic_point_init(double lon, double lat, GEOGRAPHIC_POINT *g)\newline{\newline	g-&gtlat = latitude_radians_normalize(deg2rad(lat));\newline	g-&gtlon = longitude_radians_normalize(deg2rad(lon));\newline}\newline","\newline Initialize a geographic point\newline @param lon longitude in degrees\newline @param lat latitude in degrees\newline \newline","4487750","bg_misc.c","void BG_EvaluateTrajectoryDelta( const trajectory_t *tr, int atTime, vec3_t result ) {\newline	float	deltaTime;\newline	float	phase;\newline\newline	switch( tr-&gttrType ) {\newline	case TR_STATIONARY:\newline	case TR_INTERPOLATE:\newline		VectorClear( result );\newline		break;\newline	case TR_LINEAR:\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_SINE:\newline		deltaTime = ( atTime - tr-&gttrTime ) / (float) tr-&gttrDuration;\newline		phase = cos( deltaTime * M_PI * 2 );	// derivative of sin = cos\newline		phase *= 0.5;\newline		VectorScale( tr-&gttrDelta, phase, result );\newline		break;\newline	case TR_LINEAR_STOP:\newline		if ( atTime &gt tr-&gttrTime + tr-&gttrDuration ) {\newline			VectorClear( result );\newline			return;\newline		}\newline		VectorCopy( tr-&gttrDelta, result );\newline		break;\newline	case TR_GRAVITY:\newline		deltaTime = ( atTime - tr-&gttrTime ) * 0.001;	// milliseconds to seconds\newline		VectorCopy( tr-&gttrDelta, result );\newline		result[2] -= DEFAULT_GRAVITY * deltaTime;		// FIXME: local gravity...\newline		break;\newline	default:\newline		Com_Error( ERR_DROP, &quotBG_EvaluateTrajectoryDelta: unknown trType: %i&quot, tr-&gttrTime );\newline		break;\newline	}\newline}\newline","\newline================\newlineBG_EvaluateTrajectoryDelta\newlineFor determining velocity at a given time\newline================\newline \newline","5357659","file.c","int CDECL MSVCRT__vfwprintf_l(MSVCRT_FILE* file, const MSVCRT_wchar_t *format,\newline        MSVCRT__locale_t locale, __ms_va_list valist)\newline{\newline    BOOL tmp_buf;\newline    int ret;\newline\newline    if (!MSVCRT_CHECK_PMT( file != NULL )) return -1;\newline\newline    MSVCRT__lock_file(file);\newline    tmp_buf = add_std_buffer(file);\newline    ret = pf_printf_w(puts_clbk_file_w, file, format, locale, 0, arg_clbk_valist, NULL, &ampvalist);\newline    if(tmp_buf) remove_std_buffer(file);\newline    MSVCRT__unlock_file(file);\newline\newline    return ret;\newline}\newline","\newline _vfwprintf_l (MSVCRT.@)\newline \newline","4515228","bb_boxc.c","static void wdp_to_wapboxes(void *arg)\newline{\newline    List *route_info;\newline    AddrPar *ap;\newline    Boxc *conn;\newline    Msg *msg;\newline    int i;\newline\newline    gwlist_add_producer(flow_threads);\newline    gwlist_add_producer(wapbox_list);\newline\newline    route_info = gwlist_create();\newline\newline\newline    while(bb_status != BB_DEAD) {\newline\newline	    gwlist_consume(suspended);	/* block here if suspended */\newline\newline	    if ((msg = gwlist_consume(incoming_wdp)) == NULL)\newline	         break;\newline\newline	    gw_assert(msg_type(msg) == wdp_datagram);\newline\newline	    conn = route_msg(route_info, msg);\newline	    if (conn == NULL) {\newline	        warning(0, &quotCannot route message, discard it&quot);\newline	        msg_destroy(msg);\newline	        continue;\newline	    }\newline	    gwlist_produce(conn-&gtincoming, msg);\newline    }\newline    debug(&quotbb&quot, 0, &quotwdp_to_wapboxes: destroying lists&quot);\newline    while((ap = gwlist_extract_first(route_info)) != NULL)\newline	ap_destroy(ap);\newline\newline    gw_assert(gwlist_len(route_info) == 0);\newline    gwlist_destroy(route_info, NULL);\newline\newline    gwlist_lock(wapbox_list);\newline    for(i=0; i &lt gwlist_len(wapbox_list); i++) {\newline	    conn = gwlist_get(wapbox_list, i);\newline	    gwlist_remove_producer(conn-&gtincoming);\newline	    conn-&gtalive = 0;\newline    }\newline    gwlist_unlock(wapbox_list);\newline\newline    gwlist_remove_producer(wapbox_list);\newline    gwlist_remove_producer(flow_threads);\newline}\newline","\newline this thread listens to incoming_wdp list\newline and then routs messages to proper wapbox\newline \newline","5892597","submesh.c","void fill_master_el_info(EL_INFO *mst_el_info,\newline			 const EL_INFO *el_info,\newline			 FLAGS fill_flags)\newline{\newline  FUNCNAME(&quotfill_master_el_info&quot);\newline  int dim = el_info-&gtmesh-&gtdim;\newline  int mst_ov, mst_t = 0, mst_o = 0;\newline\newline  DEBUG_TEST_EXIT(el_info-&gtfill_flag &amp FILL_MASTER_INFO,\newline		  &quotMaster element link not present in &quot\newline		  &quotslave element descriptor.\\n&quot);\newline\newline  memset(mst_el_info, 0, sizeof(*mst_el_info));\newline\newline  mst_el_info-&gtfill_flag = FILL_NOTHING;\newline  mst_el_info-&gtmesh      = get_master(el_info-&gtmesh);\newline\newline  mst_el_info-&gtmacro_el  = el_info-&gtmacro_el-&gtmaster.macro_el;\newline  mst_el_info-&gtel        = el_info-&gtmaster.el;\newline  mst_el_info-&gtparent    = NULL /* could do better here */;\newline\newline  mst_el_info-&gtel_geom_cache.fill_flag  = 0U;\newline  mst_el_info-&gtel_geom_cache.current_el = mst_el_info-&gtel;\newline  \newline  mst_ov = el_info-&gtmaster.opp_vertex;\newline\newline#if DIM_MAX &gt 2\newline  if (dim == 2) {\newline    mst_t = el_info-&gtmaster.el_type;\newline    mst_o = el_info-&gtmaster.orientation;\newline    \newline    mst_el_info-&gtfill_flag |= FILL_ORIENTATION;\newline\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  COPY_DOW(el_info-&gtcoord[sv], mst_el_info-&gtcoord[v]);\newline	}\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v, e;\newline      for (v = 0; v &lt N_VERTICES_3D; v++) {\newline	int sv = slave_numbering_3d[!!mst_t][mst_o &lt 0][mst_ov][v];\newline	if (sv &gt= 0) {\newline	  BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[v],\newline			  el_info-&gtvertex_bound[sv]);\newline	} else {\newline	  BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[v]);\newline	}\newline      }\newline      for (e = 0; e &lt N_EDGES_3D; e++) {\newline	BNDRY_FLAGS_INIT(mst_el_info-&gtedge_bound[e]);\newline      }\newline      for (e = 0; e &lt N_EDGES_2D; e++) {\newline	int mst_edge = master_edge_3d[!!mst_t][mst_o &lt 0][mst_ov][e];\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_edge],\newline			el_info-&gtedge_bound[e]);\newline      }\newline      mst_el_info-&gtface_bound[mst_ov] = el_info-&gtface_bound[0];\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  } else\newline#endif\newline  {\newline    if (fill_flags &amp FILL_COORDS) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	COPY_DOW(el_info-&gtcoord[v], mst_el_info-&gtcoord[mv]);\newline      }\newline    }\newline    if (fill_flags &amp FILL_BOUND) {\newline      int v;\newline      for (v = 0; v &lt N_VERTICES(dim); v++) {\newline	int mv = (mst_ov + v + 1) % N_VERTICES(dim+1);\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtvertex_bound[mv],\newline			el_info-&gtvertex_bound[v]);\newline      }\newline      BNDRY_FLAGS_INIT(mst_el_info-&gtvertex_bound[mst_ov]);\newline      if (dim == 1) {\newline	BNDRY_FLAGS_CPY(mst_el_info-&gtedge_bound[mst_ov],\newline			el_info-&gtedge_bound[0]);\newline      }\newline      mst_el_info-&gtwall_bound[mst_ov] =\newline	el_info-&gtmacro_el-&gtmaster.macro_el-&gtwall_bound[\newline	  el_info-&gtmacro_el-&gtmaster.opp_vertex];\newline      mst_el_info-&gtfill_flag |= FILL_BOUND; /* not quite correct, but so what */\newline    }\newline  }\newline\newline  if (fill_flags &amp FILL_NEIGH) {\newline    mst_el_info-&gtneigh[mst_ov] = el_info-&gtmst_neigh.el;\newline    mst_el_info-&gtopp_vertex[mst_ov] = el_info-&gtmst_neigh.opp_vertex;\newline    mst_el_info-&gtfill_flag |= FILL_NEIGH;\newline    if (fill_flags &amp FILL_OPP_COORDS) {\newline      COPY_DOW(el_info-&gtmst_neigh.opp_coord, mst_el_info-&gtopp_coord[mst_ov]);\newline      mst_el_info-&gtfill_flag |= FILL_OPP_COORDS;\newline    }\newline  }\newline\newline  mst_el_info-&gtel_type      = mst_t;\newline  mst_el_info-&gtorientation  = mst_o;\newline\newline  if (fill_flags &amp FILL_COORDS) {\newline    mst_el_info-&gtfill_flag |= FILL_COORDS;\newline    COPY_DOW(el_info-&gtmaster.opp_coord, mst_el_info-&gtcoord[mst_ov]);\newline  }\newline}\newline","Construct an EL_INFO structure for the master element attached to\newline the given slave element. This requires FILL_MASTER_INFO to be set\newline in the fill-flags of el_info.\newline \newline The master element will have its el_type and orientation set. If\newline the slave EL_INFO has co-ordinate information, then also the master\newline EL_INFO will be equipped with co-ordinate information.\newline \newline","1345392","verify_packages.c","static PromiseResult VerifyPromisedPackage(EvalContext *ctx, Attributes a, const Promise *pp)\newline{\newline    const char *package = pp-&gtpromiser;\newline\newline    PromiseResult result = PROMISE_RESULT_NOOP;\newline    if (a.packages.package_version)\newline    {\newline        /* The version is specified separately */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified explicitly in promise body&quot, a.packages.package_version);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, a.packages.package_version, &quot*&quot, false));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result,\newline                                             CheckPackageState(ctx, a, pp, package, a.packages.package_version,\newline                                                               RlistScalarValue(rp), false));\newline            }\newline        }\newline    }\newline    else if (a.packages.package_version_regex)\newline    {\newline        /* The name, version and arch are to be extracted from the promiser */\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version %s specified implicitly in promiser&#039s name&quot, a.packages.package_version_regex);\newline\newline        char version[CF_MAXVARSIZE];\newline        char name[CF_MAXVARSIZE];\newline        char arch[CF_MAXVARSIZE];\newline        strlcpy(version, ExtractFirstReference(a.packages.package_version_regex, package), CF_MAXVARSIZE);\newline        strlcpy(name, ExtractFirstReference(a.packages.package_name_regex, package), CF_MAXVARSIZE);\newline        strlcpy(arch, ExtractFirstReference(a.packages.package_arch_regex, package), CF_MAXVARSIZE);\newline\newline        if (!arch[0])\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        if (strcmp(arch, &quotCF_NOMATCH&quot) == 0)    // no match on arch regex, use any arch\newline        {\newline            strlcpy(arch, &quot*&quot, CF_MAXVARSIZE);\newline        }\newline\newline        Log(LOG_LEVEL_VERBOSE, &quot ... trying arch &#039%s&#039 and version &#039%s&#039&quot, arch, version);\newline        result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, name, version, arch, false));\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_VERBOSE, &quotPackage version was not specified&quot);\newline\newline        if (a.packages.package_architectures == NULL)\newline        {\newline            Log(LOG_LEVEL_VERBOSE, &quot ... trying any arch &#039*&#039 and any version &#039*&#039&quot);\newline            result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, &quot*&quot, true));\newline        }\newline        else\newline        {\newline            for (Rlist *rp = a.packages.package_architectures; rp != NULL; rp = rp-&gtnext)\newline            {\newline                Log(LOG_LEVEL_VERBOSE, &quot ... trying listed arch &#039%s&#039 and any version &#039*&#039&quot, RlistScalarValue(rp));\newline                result = PromiseResultUpdate_HELPER(pp, result, CheckPackageState(ctx, a, pp, package, &quot*&quot, RlistScalarValue(rp), true));\newline            }\newline        }\newline    }\newline\newline    return result;\newline}\newline","\newline@brief Verifies a promised package operation as defined by a and pp\newlineCalled by VerifyPackagesPromise for any non-patch operation.\newline package name is pp-&gtpromiser\newline promise result starts as NOOP\newline if package version is given\newline if no architecture given, the promise result comes from CheckPackageState with name, version, any architecture &#039 &#039, no_version=false\newline else if architectures were given, the promise result comes from CheckPackageState with name, version, arch, no_version=false FOR EACH ARCHITECTURE\newline else if package_version_regex is given\newline assume that package_name_regex and package_arch_regex are also given and use the 3 regexes to extract name, version, arch\newline if the arch extraction failed, use any architecture &#039 &#039\newline the promise result comes from CheckPackageState with name, version, arch, no_version=false)\newline else (no explicit version is given) (SAME LOOP AS EXPLICIT VERSION LOOP ABOVE)\newline if no architecture given, the promise result comes from CheckPackageState with name, any version &quot &quot, any architecture &#039 &#039, no_version=true\newline else if architectures were given, the promise result comes from CheckPackageState with name, any version &quot &quot, arch, no_version=true FOR EACH ARCHITECTURE\newline@param ctx [in] The evaluation context\newline@param a [in] the Attributes specifying how to compare\newline@param pp [in] the Promise for this operation\newline@returns the promise result as set by CheckPackageState\newline \newline","6366566","decorate_background.cpp","bool FrontFacing(Point3f viewPos,\newline                 int axis, int side,\newline                 Point3f minP, Point3f maxP)\newline{\newline  assert (side==0 || side ==1);\newline  assert (axis&gt=0 &amp&amp axis &lt 3);\newline  Point3f N(0,0,0);\newline  Point3f C = (minP+maxP)/2.0;\newline\newline  if(side == 1) {\newline      C[axis] = maxP[axis];\newline      N[axis]=-1;\newline  }\newline\newline  if(side == 0) {\newline    C[axis] = minP[axis];\newline    N[axis]=1;\newline  }\newline  Point3f vpc = viewPos-C;\newline//  qDebug(&quotFaceCenter %f %f %f - %f %f %f&quot,C[0],C[1],C[2],N[0],N[1],N[2]);\newline//  qDebug(&quotVPC        %f %f %f&quot,vpc[0],vpc[1],vpc[2]);\newline  return vpc*N &gt 0;\newline}\newline","return true if the side of a box is front facing with respet of the give viewpoint.\newlineside 0, axis i == min on than i-th axis\newlineside 1, axis i == min on than i-th axis\newlinequesto capita se il prodotto scalare tra il vettore normale entro della faccia\newline \newline","2741554","xfs_format.h","static inline uint xfs_dinode_size(int version)\newline{\newline	if (version == 3)\newline		return sizeof(struct xfs_dinode);\newline	return offsetof(struct xfs_dinode, di_crc);\newline}\newline","\newline Size of the core inode on disk. Version 1 and 2 inodes have\newline the same size, but version 3 has grown a few additional fields.\newline \newline","2059881","fluid_synth.c","void\newlinefluid_synth_tuning_iteration_start(fluid_synth_t* synth)\newline{\newline  fluid_return_if_fail (synth != NULL);\newline  fluid_synth_api_enter(synth);\newline  fluid_private_set (synth-&gttuning_iter, FLUID_INT_TO_POINTER (0), NULL);\newline  fluid_synth_api_exit(synth);\newline}\newline","\newline Start tuning iteration.\newline @param synth FluidSynth instance\newline \newline","1827703","qcustomplot.cpp","void QCPAxis::setSelectedLabelFont(const QFont &ampfont)\newline{\newline  mSelectedLabelFont = font;\newline}\newline","!\newlineSets the font that is used for the axis label when it is selected.\newline\newline\\see setLabelFont, setSelectable, setSelected, QCustomPlot::setInteractions\newline \newline","3591538","features_cpu.c","uint64_t cpu_features_get(void)\newline{\newline   int flags[4];\newline   int vendor_shuffle[3];\newline   char vendor[13]     = {0};\newline   size_t len          = 0;\newline   uint64_t cpu_flags  = 0;\newline   uint64_t cpu        = 0;\newline   unsigned max_flag   = 0;\newline#if defined(CPU_X86) &amp&amp !defined(__MACH__)\newline   int vendor_is_intel = 0;\newline   const int avx_flags = (1 &lt&lt 27) | (1 &lt&lt 28);\newline#endif\newline\newline   char buf[sizeof(&quot MMX MMXEXT SSE SSE2 SSE3 SSSE3 SS4 SSE4.2 AES AVX AVX2 NEON VMX VMX128 VFPU PS&quot)];\newline\newline   memset(buf, 0, sizeof(buf));\newline\newline   (void)len;\newline   (void)cpu_flags;\newline   (void)flags;\newline   (void)max_flag;\newline   (void)vendor;\newline   (void)vendor_shuffle;\newline\newline#if defined(__MACH__)\newline   len     = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.mmx&quot, NULL, &amplen, NULL, 0) == 0)\newline   {\newline      cpu |= RETRO_SIMD_MMX;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.supplementalsse3&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_1&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.sse4_2&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.aes&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AES;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx1_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.avx2_0&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_AVX2;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.altivec&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_VMX;\newline\newline   len            = sizeof(size_t);\newline   if (sysctlbyname(&quothw.optional.neon&quot, NULL, &amplen, NULL, 0) == 0)\newline      cpu |= RETRO_SIMD_NEON;\newline\newline#elif defined(CPU_X86)\newline   (void)avx_flags;\newline\newline   x86_cpuid(0, flags);\newline   vendor_shuffle[0] = flags[1];\newline   vendor_shuffle[1] = flags[3];\newline   vendor_shuffle[2] = flags[2];\newline   memcpy(vendor, vendor_shuffle, sizeof(vendor_shuffle));\newline\newline   /* printf(&quot[CPUID]: Vendor: %s\\n&quot, vendor); */\newline\newline   vendor_is_intel = (\newline         flags[1] == VENDOR_INTEL_b &amp&amp\newline         flags[2] == VENDOR_INTEL_c &amp&amp\newline         flags[3] == VENDOR_INTEL_d);\newline\newline   max_flag = flags[0];\newline   if (max_flag &lt 1) /* Does CPUID not support func = 1? (unlikely ...) */\newline      return 0;\newline\newline   x86_cpuid(1, flags);\newline\newline   if (flags[3] &amp (1 &lt&lt 23))\newline      cpu |= RETRO_SIMD_MMX;\newline\newline   if (flags[3] &amp (1 &lt&lt 25))\newline   {\newline      /* SSE also implies MMXEXT (according to FFmpeg source). */\newline      cpu |= RETRO_SIMD_SSE;\newline      cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline\newline\newline   if (flags[3] &amp (1 &lt&lt 26))\newline      cpu |= RETRO_SIMD_SSE2;\newline\newline   if (flags[2] &amp (1 &lt&lt 0))\newline      cpu |= RETRO_SIMD_SSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 9))\newline      cpu |= RETRO_SIMD_SSSE3;\newline\newline   if (flags[2] &amp (1 &lt&lt 19))\newline      cpu |= RETRO_SIMD_SSE4;\newline\newline   if (flags[2] &amp (1 &lt&lt 20))\newline      cpu |= RETRO_SIMD_SSE42;\newline\newline   if ((flags[2] &amp (1 &lt&lt 23)))\newline      cpu |= RETRO_SIMD_POPCNT;\newline\newline   if (vendor_is_intel &amp&amp (flags[2] &amp (1 &lt&lt 22)))\newline      cpu |= RETRO_SIMD_MOVBE;\newline\newline   if (flags[2] &amp (1 &lt&lt 25))\newline      cpu |= RETRO_SIMD_AES;\newline\newline\newline   /* Must only perform xgetbv check if we have\newline    * AVX CPU support (guaranteed to have at least i686). */\newline   if (((flags[2] &amp avx_flags) == avx_flags)\newline         &amp&amp ((xgetbv_x86(0) &amp 0x6) == 0x6))\newline      cpu |= RETRO_SIMD_AVX;\newline\newline   if (max_flag &gt= 7)\newline   {\newline      x86_cpuid(7, flags);\newline      if (flags[1] &amp (1 &lt&lt 5))\newline         cpu |= RETRO_SIMD_AVX2;\newline   }\newline\newline   x86_cpuid(0x80000000, flags);\newline   max_flag = flags[0];\newline   if (max_flag &gt= 0x80000001u)\newline   {\newline      x86_cpuid(0x80000001, flags);\newline      if (flags[3] &amp (1 &lt&lt 23))\newline         cpu |= RETRO_SIMD_MMX;\newline      if (flags[3] &amp (1 &lt&lt 22))\newline         cpu |= RETRO_SIMD_MMXEXT;\newline   }\newline#elif defined(__linux__)\newline   if (check_arm_cpu_feature(&quotneon&quot))\newline   {\newline      cpu |= RETRO_SIMD_NEON;\newline#ifdef __ARM_NEON__\newline      arm_enable_runfast_mode();\newline#endif\newline   }\newline\newline   if (check_arm_cpu_feature(&quotvfpv3&quot))\newline      cpu |= RETRO_SIMD_VFPV3;\newline\newline   if (check_arm_cpu_feature(&quotvfpv4&quot))\newline      cpu |= RETRO_SIMD_VFPV4;\newline\newline#if 0\newline    check_arm_cpu_feature(&quotswp&quot);\newline    check_arm_cpu_feature(&quothalf&quot);\newline    check_arm_cpu_feature(&quotthumb&quot);\newline    check_arm_cpu_feature(&quotfastmult&quot);\newline    check_arm_cpu_feature(&quotvfp&quot);\newline    check_arm_cpu_feature(&quotedsp&quot);\newline    check_arm_cpu_feature(&quotthumbee&quot);\newline    check_arm_cpu_feature(&quottls&quot);\newline    check_arm_cpu_feature(&quotidiva&quot);\newline    check_arm_cpu_feature(&quotidivt&quot);\newline#endif\newline\newline#elif defined(__ARM_NEON__)\newline   cpu |= RETRO_SIMD_NEON;\newline   arm_enable_runfast_mode();\newline#elif defined(__ALTIVEC__)\newline   cpu |= RETRO_SIMD_VMX;\newline#elif defined(XBOX360)\newline   cpu |= RETRO_SIMD_VMX128;\newline#elif defined(PSP)\newline   cpu |= RETRO_SIMD_VFPU;\newline#elif defined(GEKKO)\newline   cpu |= RETRO_SIMD_PS;\newline#endif\newline\newline   if (cpu &amp RETRO_SIMD_MMX)    strlcat(buf, &quot MMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_MMXEXT) strlcat(buf, &quot MMXEXT&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE)    strlcat(buf, &quot SSE&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE2)   strlcat(buf, &quot SSE2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE3)   strlcat(buf, &quot SSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSSE3)  strlcat(buf, &quot SSSE3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE4)   strlcat(buf, &quot SSE4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_SSE42)  strlcat(buf, &quot SSE4.2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AES)    strlcat(buf, &quot AES&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX)    strlcat(buf, &quot AVX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_AVX2)   strlcat(buf, &quot AVX2&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_NEON)   strlcat(buf, &quot NEON&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV3)  strlcat(buf, &quot VFPv3&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPV4)  strlcat(buf, &quot VFPv4&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX)    strlcat(buf, &quot VMX&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VMX128) strlcat(buf, &quot VMX128&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_VFPU)   strlcat(buf, &quot VFPU&quot, sizeof(buf));\newline   if (cpu &amp RETRO_SIMD_PS)     strlcat(buf, &quot PS&quot, sizeof(buf));\newline\newline   return cpu;\newline}\newline","\newline cpu_features_get:\newline \newline Gets CPU features..\newline \newline Returns: bitmask of all CPU features available.\newline \newline","3989953","3dsplay.c","void *convert_to_RGB_Surface(SDL_Surface *bitmap)\newline{\newline  unsigned char *pixel = (unsigned char *)malloc(sizeof(char) * 4 * bitmap-&gth * bitmap-&gtw); \newline  int soff = 0;   \newline  int doff = 0;   \newline  int x, y;\newline  unsigned char *spixels = (unsigned char *)bitmap-&gtpixels;\newline  SDL_Palette *pal = bitmap-&gtformat-&gtpalette; \newline\newline  for (y = 0; y &lt bitmap-&gth; y++)\newline    for (x = 0; x &lt bitmap-&gtw; x++)\newline    {\newline      SDL_Color* col = &amppal-&gtcolors[spixels[soff]];\newline\newline      pixel[doff] = col-&gtr; \newline      pixel[doff+1] = col-&gtg; \newline      pixel[doff+2] = col-&gtb; \newline      pixel[doff+3] = 255; \newline      doff += 4; \newline      soff++;\newline    }\newline\newline    return (void *)pixel; \newline}\newline","\newline Convert an SDL bitmap for use with OpenGL.\newline \newline Written by Gernot &lt gz@lysator.liu.se &gt\newline \newline","1778844","config.c","int config_parse_args(int argc, const char **argv, abl_args *args, log_context *logContext) {\newline    int argn;\newline    int err;\newline\newline    config_clear(args);\newline\newline    for (argn = 0; argn &lt argc; argn++) {\newline        err = parse_arg(argv[argn], args, logContext);\newline        if (err) {\newline            return err;\newline        }\newline    }\newline\newline    if (logContext-&gtdebug)\newline        dump_args(args, logContext);\newline\newline    return 0;\newline}\newline","Parse our argments and populate an abl_args structure accordingly.\newline \newline","6010187","rsim.c","private int setpowtrace()\newline  {\newline    apply(xpowtrace, vpowtrace, plus_minus);\newline    set_vec_nodes( POWWATCHVECTOR );\newline    return( 0 );\newline  }\newline","\newline mark nodes and vectors for cap tracing\newline \newline","2744494","apr_dbd_odbc.c","static int odbc_pvbquery(apr_pool_t *pool, apr_dbd_t *handle, int *nrows,\newline                         apr_dbd_prepared_t *statement, va_list args)\newline{\newline    const char **values;\newline    int i;\newline\newline    values = apr_palloc(pool, sizeof(*values) * statement-&gtnvals);\newline    for (i = 0; i &lt statement-&gtnvals; i++)\newline        values[i] = va_arg(args, const char *);\newline    return odbc_pbquery(pool, handle, nrows, statement, (const void **)values);\newline}\newline","pvbquery: query using a prepared statement + binary args \newline","3923291","mincmorph.c","char    *get_real_from_string(char *string, double *value)\newline{\newline   char    *ptr;\newline\newline   /* skip a [ or : else we probably don&#039t belong here */\newline   if(string[0] == &#039[&#039 || string[0] == &#039:&#039){\newline      string++;\newline      }\newline\newline   /* get a double */\newline   *value = strtod(&ampstring[0], &ampptr);\newline\newline   /* if nothing found return a default value */\newline   if(&ampstring[0] == ptr){\newline      *value = DEF_DOUBLE;\newline      }\newline\newline   /* skip over a possible &#039]&#039 */\newline   if(ptr[0] == &#039]&#039){\newline      ptr++;\newline      }\newline\newline   return ptr;\newline   }\newline","as it was input if nothing found \newline","6419704","commands.c","static int cmd_load(const char *filename)\newline{\newline    int slotnum =\newline	load_file(expand_filename_tilde(filename),\newline		  LOADFILE_READifPRESENT);\newline\newline    if (slotnum &gt= 0)\newline    {\newline	lookup.slot = lookup.slot_info[slotnum];\newline	return COMMAND_RUNS_OK;\newline    }\newline    return COMMAND_HAS_ERROR;\newline}\newline","\newline Given a filename, load it.\newline \newline","","","","","","","","","","","","","on","","on","","","","on","","","","","","","","","","","","","","","","","","","","","","","","Send a ""cancel this file transfer"" message?","Verifies a promised package operation as defined by a and pp","return true if the side of a box is front facing","Size of the core inode on disk.","Start tuning iteration.","Sets the font that is used for the axis label","Gets CPU features..","Convert an SDL bitmap for use with OpenGL.","Parse our argments and populate an abl_args structure","mark nodes and vectors for cap tracing","query using a prepared statement + binary args","comma-separated list of pairs name=value","{}","Given a filename, load it.","{}","Reads Dimensions for an icon box from the config file","Initialize a geographic point","determining velocity at a given time","{}","listens to incoming_wdp listand then routs messages to proper wapbox","Construct an EL_INFO structure for the master element attached"
"3IVEC1GSLPZEYLQQ6P4XM9PRDPO1JU","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3907X2AHF05JW18DA8EWD7HXUID2PL","AMD1LYNQAH3R8","Approved","Wed Apr 17 13:42:43 PDT 2019","Wed Apr 17 13:47:54 PDT 2019","Fri Apr 19 13:47:54 PDT 2019","2019-04-19 20:48:21 UTC","","","311","100% (27/27)","100% (27/27)","100% (27/27)","258116","tls1.c","int finished_digest(SSL *ssl, const char *label, uint8_t *digest)\newline{\newline    uint8_t mac_buf[SHA1_SIZE+MD5_SIZE+15]; \newline    uint8_t *q = mac_buf;\newline    int dgst_len;\newline\newline    if (label)\newline    {\newline        strcpy((char *)q, label);\newline        q += strlen(label);\newline    }\newline\newline    if (ssl-&gtversion &gt= SSL_PROTOCOL_VERSION_TLS1_2) // TLS1.2+\newline    {\newline        SHA256_CTX sha256_ctx = ssl-&gtdc-&gtsha256_ctx; // interim copy\newline        SHA256_Final(q, &ampsha256_ctx);\newline        q += SHA256_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline    else // TLS1.0/1.1\newline    {\newline        MD5_CTX md5_ctx = ssl-&gtdc-&gtmd5_ctx; // interim copy\newline        SHA1_CTX sha1_ctx = ssl-&gtdc-&gtsha1_ctx;\newline\newline        MD5_Final(q, &ampmd5_ctx);\newline        q += MD5_SIZE;\newline        \newline        SHA1_Final(q, &ampsha1_ctx);\newline        q += SHA1_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline\newline    if (label)\newline    {\newline        prf(ssl, ssl-&gtdc-&gtmaster_secret, SSL_SECRET_SIZE, \newline                mac_buf, dgst_len, digest, SSL_FINISHED_HASH_SIZE);\newline    }\newline    else    /* for use in a certificate verify */\newline    {\newline        memcpy(digest, mac_buf, dgst_len);\newline    }\newline\newline#if 0\newline    printf(&quotlabel: %s\\n&quot, label);\newline    print_blob(&quotmac_buf&quot, mac_buf, dgst_len);\newline    print_blob(&quotfinished digest&quot, digest, SSL_FINISHED_HASH_SIZE);\newline#endif\newline\newline    return dgst_len;\newline}   \newline","\newline Calculate the digest used in the finished message. This function also\newline doubles up as a certificate verify function.\newline \newline","3469015","metro.c","static void set_volume_cb(metro_t* metro)\newline{\newline  double* volume = (double*) g_malloc(sizeof(double));\newline\newline  *volume = GTK_ADJUSTMENT(metro-&gtvolume_adjustment)-&gtvalue / 100.0;\newline  comm_client_query(metro-&gtinter_thread_comm, MESSAGE_TYPE_SET_VOLUME,\newline      volume);\newline}\newline","\newline GUI volume change callback\newline \newline","3107006","cvalues.c","int numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname)\newline{\newline    int_t ai, bi;\newline    numerictype_t ta, tb;\newline    void *aptr, *bptr;\newline\newline    if (bothfixnums(a,b)) {\newline        if (a==b) return 0;\newline        if (numval(a) &lt numval(b)) return -1;\newline        return 1;\newline    }\newline    if (!num_to_ptr(a, &ampai, &ampta, &ampaptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, a); else return 2;\newline    }\newline    if (!num_to_ptr(b, &ampbi, &amptb, &ampbptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, b); else return 2;\newline    }\newline    if (eq &amp&amp eqnans &amp&amp ((ta &gt= T_FLOAT) != (tb &gt= T_FLOAT)))\newline        return 1;\newline    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\newline        return 0;\newline    if (eq) return 1;\newline    if (cmp_lt(aptr, ta, bptr, tb))\newline        return -1;\newline    return 1;\newline}\newline","\newlinereturns -1, 0, or 1 based on ordering of a and b\newlineeq: consider equality only, returning 0 or nonzero\newlineeqnans: NaNs considered equal to each other\newline-0.0 not considered equal to 0.0\newlineinexact not considered equal to exact\newlinefname: if not NULL, throws type errors, else returns 2 for type errors\newline \newline","4996949","vid21394_base.c","int vid21394_wait_buffer( vid21394handle_t vid21394handle, void **buffer )\newline{\newline   int retval = STATUS_SUCCESS;\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtis_receiving )\newline   {\newline      return STATUS_IS_STOPPED;\newline   }\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtdevice_present )\newline   {\newline      return STATUS_NO_DEVICE;\newline   }\newline	\newline   if( vid21394handle-&gtready_buffers.next )\newline   {\newline      unicap_queue_t *first_entry;\newline      // return immediately if a buffer is already in the ready queue\newline      first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline      *buffer = first_entry-&gtdata;\newline      free( first_entry );\newline   }\newline   else\newline   {\newline      if( vid21394handle-&gtqueued_buffers.next )\newline      {\newline	 //block until a buffer got filled by the device\newline	 unicap_queue_t *first_entry;\newline	 struct timeval timeout_time, cur_time;\newline			\newline	 if( gettimeofday( &amptimeout_time, NULL ) &lt 0 )\newline	 {\newline	    return STATUS_FAILURE;\newline	 }\newline			\newline	 timeout_time.tv_sec += 1; // 1 second timeout\newline	 while( !vid21394handle-&gtready_buffers.next )\newline	 {\newline	    // raw1394_loop_iterate is waked regularly by a seperate thread ( every 500ms )\newline	    if( gettimeofday( &ampcur_time, NULL ) &lt 0 )\newline	    {\newline	       return STATUS_FAILURE;\newline	    }\newline				\newline	    if( timercmp( &ampcur_time, &amptimeout_time, &gt ) )\newline	    {	\newline	       return STATUS_TIMEOUT;\newline	    }\newline/*\newline            // dcm: don&#039t enter into loop_iterate since, it can block even if a frame arrives\newline	    raw1394_loop_iterate( vid21394handle-&gtraw1394handle );\newline*/\newline            // 1 millisecond\newline            struct timespec delay = {0, 1000000};\newline	    nanosleep(&ampdelay, NULL);\newline	 }\newline	 first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline	 *buffer = first_entry-&gtdata;\newline			\newline	 free( first_entry );\newline      }\newline      else\newline      {\newline	 // no buffers queued -&gt no buffers to return\newline	 return STATUS_NO_BUFFERS;\newline      }\newline   }\newline	\newline\newline   return retval;\newline}\newline","\newlineWait until one buffer got filled by the device. \newlineMay return immediately ( if a buffer already was filled by the device ) \newlineor block until the buffer got filled.\newline \newline","5832055","litl_split.c","static void __litl_split_extract_traces(const char *dir) {\newline  int trace_out, res __attribute__ ((__unused__));\newline  char* trace_name;\newline  litl_size_t buffer_size;\newline  litl_med_size_t general_header_size, process_header_size;\newline\newline  general_header_size = sizeof(litl_general_header_t);\newline  process_header_size = sizeof(litl_process_header_t);\newline\newline  while (__arch-&gtnb_processes-- != 0) {\newline    // get a process header\newline    __arch-&gtprocess_header = (litl_process_header_t *) __arch-&gtheader_buffer;\newline    __arch-&gtheader_buffer += process_header_size;\newline\newline    res = asprintf(&amptrace_name, &quot%s/%s&quot, dir,\newline                   __arch-&gtprocess_header-&gtprocess_name);\newline\newline    // create and open a new trace file\newline    if ((trace_out = open(trace_name, O_WRONLY | O_CREAT, 0644)) &lt 0) {\newline      fprintf(stderr, &quotCannot create and open %s\\n&quot,\newline              __arch-&gtprocess_header-&gtprocess_name);\newline      exit(EXIT_FAILURE);\newline    }\newline\newline    // write a general trace header\newline    res = write(trace_out, __arch-&gttrace_header, general_header_size);\newline\newline    // write a process header\newline    buffer_size = __arch-&gtprocess_header-&gtoffset;\newline    __arch-&gtprocess_header-&gtoffset = general_header_size + process_header_size;\newline    res = write(trace_out, __arch-&gtprocess_header, process_header_size);\newline\newline    // set a file pointer to the position of the current process\newline    lseek(__arch-&gtf_handle, buffer_size, SEEK_SET);\newline\newline    // read data and write to a separate trace\newline    while (__arch-&gtprocess_header-&gttrace_size) {\newline      buffer_size =\newline          __arch-&gtprocess_header-&gttrace_size &gt __arch-&gtbuffer_size ?\newline            __arch-&gtbuffer_size : __arch-&gtprocess_header-&gttrace_size;\newline\newline      res = read(__arch-&gtf_handle, __arch-&gtbuffer, buffer_size);\newline\newline      res = write(trace_out, __arch-&gtbuffer, buffer_size);\newline\newline      __arch-&gtprocess_header-&gttrace_size -= buffer_size;\newline    }\newline\newline    free(trace_name);\newline    close(trace_out);\newline  }\newline}\newline","\newline Writes each trace from an archive into a separate trace file\newline \newline","5007086","oggread~.c","static void oggread_start(t_oggread *x)\newline{\newline    if(x-&gtx_fd &gt 0)\newline    {\newline		if(ov_time_seek(&ampx-&gtx_ov, 0) &lt 0)\newline		{\newline			post(&quotoggread~: could not rewind file to beginning&quot);\newline		}\newline		post(&quotoggread~: START&quot);\newline		x-&gtx_eos = 0;\newline		x-&gtx_outreadposition = 0;\newline		x-&gtx_outwriteposition = 0;\newline		x-&gtx_outunread = 0;\newline		x-&gtx_position = 0;\newline		clock_delay(x-&gtx_clock, 0);\newline		x-&gtx_stream = 1;\newline    }\newline	else post(&quotoggread~: no file open (ignored)&quot);\newline}\newline","start playing \newline","3370572","qdocdatabase.cpp","NodeMultiMap&amp QDocDatabase::getClassesWithObsoleteMembers()\newline{\newline    if (obsoleteClasses_.isEmpty() &amp&amp obsoleteQmlTypes_.isEmpty())\newline        processForest(&ampQDocDatabase::findAllObsoleteThings);\newline    return classesWithObsoleteMembers_;\newline}\newline","!\newlineConstruct the data structures for obsolete things, if they\newlinehave not already been constructed. Returns a reference to\newlinethe map of C++ classes with obsolete members.\newline \newline","6305983","gnutls_tpm.c","int gtls2_tpm_sign_cb(gnutls_session_t sess, void *_vpninfo,\newline		      gnutls_certificate_type_t cert_type,\newline		      const gnutls_datum_t *cert, const gnutls_datum_t *data,\newline		      gnutls_datum_t *sig)\newline{\newline	struct openconnect_info *vpninfo = _vpninfo;\newline\newline	if (cert_type != GNUTLS_CRT_X509)\newline		return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;\newline\newline	return tpm_sign_fn(NULL, vpninfo, data, sig);\newline}\newline","We want to use gnutls_privkey_import_ext() to create a privkey with our\newlineown signing function tpm_sign_fn(). But GnuTLS 2.12 doesn&#039t support that,\newlineso instead we have to register this sign_callback function with the\newline session \newline","5898142","kmclipm_priv_splines.c","double **bicubicspline_irreg_irreg(\newline        int nxi, double *xi,\newline        int nyi, double *yi,\newline        double **vi,\newline        int nxo, double *xo,\newline        int nyo, double *yo,\newline        enum boundary_mode mode)\newline{\newline    double **vo = matrix(nxo, nyo);\newline    double **v2 = blank_matrix(nxi);\newline    double *vtmp = NULL;\newline    double *vvtmp = NULL;\newline    double y1start = 0.0;  /* not used for bicubicsplines */\newline    double y1end = 0.0;    /* not used for bicubicsplines */\newline    int ix = 0, iy = 0, k = 0;\newline\newline    for (ix=0; ix&ltnxi; ix++) {\newline        v2[ix] = spline_irreg_init(nyi, yi, vi[ix], mode, y1start, y1end);\newline    }\newline\newline    for (ix=0; ix&ltnxo; ix++) {\newline        for (iy=0; iy&ltnyo; iy++) {\newline            vvtmp = vector(nxi);\newline            for (k=0; k&ltnxi; k++) {\newline                vvtmp[k] = spline_irreg_interpolate(nyi, yi, vi[k], v2[k], yo[iy]);\newline            }\newline            vtmp = spline_irreg_init(nxi, xi, vvtmp, mode, y1start, y1end);\newline            vo[ix][iy] = spline_irreg_interpolate(nxi, xi, vvtmp, vtmp, xo[ix]);\newline            free_vector(vtmp);\newline            free_vector(vvtmp);\newline        }\newline    }\newline    free_matrix(v2,nxi);\newline\newline    return vo;\newline}\newline","\newline@brief Bicubic splines interpolation with a irregular arrays as input and output\newline@param nxi number of points along the input x axis\newline@param xi values on the input x axis\newline@param nyi number of points along the input y axis\newline@param yi values on the input y axis\newline@param vi values for the two dimensional input array\newline@param nxo number of points along the output x axis\newline@param xo values on the output x axis\newline@param nyo number of points along the output y axis\newline@param yo values on the output y axis\newline@param mode mode for boundary estimate (NATURAL, ESTIMATED1 or ESTIMATED2)\newline@return vo values for the two dimensional output array\newline@warning The memory for the output array vo is allocated by this function. To free the memory again please use\newlinea call to free_matrix(vo, nyo)\newline \newline","3185402","list.c","static int qdb_list__extendarray(qdbint_t db, long amount)\newline{\newline	long origlen, origalloced;\newline	void *ptr;\newline\newline	origlen = db-&gtarray_len;\newline\newline	db-&gtarray_len += amount;\newline	if (db-&gtarray_len &lt db-&gtarray_alloced)\newline		return 0;\newline\newline	origalloced = db-&gtarray_alloced;\newline\newline	while (db-&gtarray_alloced &lt db-&gtarray_len) {\newline		db-&gtarray_alloced += ML_INCSIZE;\newline	}\newline\newline	if (db-&gtarray == NULL) {\newline		ptr =\newline		    calloc(db-&gtarray_alloced, sizeof(struct mh_record_s));\newline	} else {\newline		ptr = realloc(db-&gtarray,    /* RATS: ignore (OK) */\newline			      db-&gtarray_alloced *\newline			      sizeof(struct mh_record_s));\newline	}\newline\newline	if (ptr == NULL) {\newline		mh_lasterror = strerror(errno);\newline		db-&gtarray_len = origlen;\newline		db-&gtarray_alloced = origalloced;\newline		return 1;\newline	}\newline\newline	db-&gtarray = ptr;\newline\newline	return 0;\newline}\newline","\newline Extend the array by &quotamount&quot items. Returns nonzero on error.\newline \newline","1528436","volinfo.c","int savevolinfo(const struct vol *vol, const char *Cnid_srv, const char *Cnid_port)\newline{\newline    uid_t process_uid;\newline    char buf[16348];\newline    char item[MAXPATHLEN];\newline    int fd;\newline    int ret = 0;\newline    struct flock lock;\newline    const vol_opt_name_t *op = &ampvol_opt_names[0];\newline    const vol_opt_name_t *cf = &ampvol_opt_casefold[0];\newline\newline    strlcpy (item, vol-&gtv_path, sizeof(item));\newline    strlcat (item, &quot/.AppleDesktop/&quot, sizeof(item));\newline    strlcat (item, VOLINFOFILE, sizeof(item));\newline\newline    process_uid = geteuid();\newline    if (process_uid) {\newline        if (seteuid(0) == -1) {\newline            process_uid = 0;\newline        }\newline    }\newline\newline    if ((fd = open(item, O_RDWR | O_CREAT , 0666)) &lt0 ) {\newline        LOG(log_debug, logtype_default,&quotError opening %s: %s&quot, item, strerror(errno));\newline        if (process_uid) {\newline            if (seteuid(process_uid) == -1) {\newline                LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline                exit(EXITERR_SYS);\newline            }\newline        }\newline        return (-1);\newline    }\newline\newline    if (process_uid) {\newline        if (seteuid(process_uid) == -1) {\newline            LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline            exit(EXITERR_SYS);\newline        }\newline    }\newline\newline    /* try to get a lock */\newline    lock.l_start  = 0;\newline    lock.l_whence = SEEK_SET;\newline    lock.l_len    = 0;\newline    lock.l_type   = F_WRLCK;\newline\newline    if (fcntl(fd, F_SETLK, &amplock) &lt 0) {\newline        close(fd);\newline        if (errno == EACCES || errno == EAGAIN) {\newline            /* ignore, other process already writing the file */\newline            return 0;\newline        } else {\newline            LOG(log_error, logtype_default, &quotsavevoloptions: cannot get lock: %s&quot, strerror(errno));\newline            return (-1);\newline        }\newline    }\newline\newline    /* write volume options */\newline    snprintf(buf, sizeof(buf), &quotMAC_CHARSET:%s\\n&quot, vol-&gtv_maccodepage);\newline    snprintf(item, sizeof(item), &quotVOL_CHARSET:%s\\n&quot, vol-&gtv_volcodepage);\newline    strlcat(buf, item, sizeof(buf));\newline\newline    switch (vol-&gtv_adouble) {\newline        case AD_VERSION1:\newline            strlcat(buf, &quotADOUBLE_VER:v1\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2:\newline            strlcat(buf, &quotADOUBLE_VER:v2\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2_OSX:\newline            strlcat(buf, &quotADOUBLE_VER:osx\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION1_SFM:\newline            strlcat(buf, &quotADOUBLE_VER:sfm\\n&quot, sizeof(buf));\newline            break;\newline    }\newline\newline    strlcat(buf, &quotCNIDBACKEND:&quot, sizeof(buf));\newline    strlcat(buf, vol-&gtv_cnidscheme, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDHOST:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_srv, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDPORT:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_port, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strcpy(item, &quotCNID_DBPATH:&quot);\newline    if (vol-&gtv_dbpath)\newline        strlcat(item, vol-&gtv_dbpath, sizeof(item));\newline    else\newline        strlcat(item, vol-&gtv_path, sizeof(item));\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* volume flags */\newline    strcpy(item, &quotVOLUME_OPTS:&quot);\newline    for (;op-&gtname; op++) {\newline	if ( (vol-&gtv_flags &amp op-&gtoption) ) {\newline            strlcat(item, op-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* casefold flags */\newline    strcpy(item, &quotVOLCASEFOLD:&quot);\newline    for (;cf-&gtname; cf++) {\newline        if ( (vol-&gtv_casefold &amp cf-&gtoption) ) {\newline            strlcat(item, cf-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* ExtendedAttributes */\newline    strcpy(item, &quotEXTATTRTYPE:&quot);\newline    switch (vol-&gtv_vfs_ea) {\newline    case AFPVOL_EA_SYS:\newline        strlcat(item, &quotAFPVOL_EA_SYS\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_AD:\newline        strlcat(item, &quotAFPVOL_EA_AD\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_NONE:\newline        strlcat(item, &quotAFPVOL_EA_NONE\\n&quot, sizeof(item));\newline        break;\newline    default:\newline        strlcat(item, &quotAFPVOL_EA_UNKNOWN\\n&quot, sizeof(item));\newline    }\newline\newline    strlcat(buf, item, sizeof(buf));\newline\newline    if (strlen(buf) &gt= sizeof(buf)-1)\newline        LOG(log_debug, logtype_default, &quotError writing .volinfo file: buffer too small, %s&quot, buf);\newline   if (write( fd, buf, strlen(buf)) &lt 0 || ftruncate(fd, strlen(buf)) &lt 0 ) {\newline       LOG(log_debug, logtype_default, &quotError writing .volinfo file: %s&quot, strerror(errno));\newline   }\newline\newline   lock.l_type = F_UNLCK;\newline   fcntl(fd, F_SETLK, &amplock);\newline   close (fd);\newline   return ret;\newline}\newline","\newline Save the volume options to a file, used by shell utilities. Writing the file\newline everytime a volume is opened is unnecessary, but it shouldn&#039t hurt much.\newline \newline","2944956","ccd_frame.c","int fits_get_string(struct ccd_frame *fr, char *kwd, char *v, int n)\newline{\newline	char *row;\newline	int i, j;\newline\newline	row = (char *)fits_keyword_lookup(fr, kwd);\newline	if (row == NULL)\newline		return 0;\newline	for (i=9; i &lt FITS_HCOLS; i++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039)\newline			break;\newline	}\newline	if (i++ &gt= FITS_HCOLS)\newline		return -1;\newline//	d3_printf(&quotfirst quote at %d\\n&quot, i);\newline	for (j=0; i &lt FITS_HCOLS &amp&amp j &lt n-1; i++, j++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039) {\newline			break;\newline		}\newline		v[j] = row[i];\newline	}\newline//	d3_printf(&quotsecond quote at %d\\n&quot, i);\newline	v[j] = 0;\newline	if (i == FITS_HCOLS)\newline		return -1;\newline	return j;\newline}\newline","get a string field containing at most n characters\newline return the number of chars read, 0 if the field was not found,\newline or -1 for an error \newline","5206131","pi_controller.c","static void dma_pi_write(struct pi_controller *pi)\newline{\newline   uint32_t length, i;\newline   uint32_t dram_address;\newline   uint32_t rom_address;\newline   uint8_t* dram;\newline   const uint8_t* rom;\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &lt 0x10000000 &amp&amp !(pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000))\newline   {\newline      if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x08000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08010000)\newline      {\newline         if (pi-&gtuse_flashram != 1)\newline         {\newline            dma_read_sram(pi);\newline            pi-&gtuse_flashram = -1;\newline         }\newline         else\newline         {\newline            dma_read_flashram(pi);\newline         }\newline      }\newline      else if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x05000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x06000000)\newline      {\newline         //64DD REG/BUFFER\newline         length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline         i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x1FFFFFF;\newline\newline         if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000400)\newline         {\newline            //SECTOR BUFFER\newline            i -= 0x400;\newline            length = (i + length) &gt 0x100 ? (0x100 - i) : length;\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000400) &amp 0x3fffff;\newline            rom = (uint8_t*)g_dd.sec_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x14000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x10000000;\newline         }\newline         else if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000000)\newline         {\newline            //C2 BUFFER\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x3fffff;\newline            length      = (i + length) &gt 0x400 ? (0x400 - i) : length;\newline            rom         = (uint8_t*)g_dd.c2_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x44000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x40000000;\newline         }\newline         else\newline         {\newline            pi-&gtregs[PI_STATUS_REG] |= 3;\newline            cp0_update_count();\newline            add_interupt_event(PI_INT, length / 8);\newline\newline            return;\newline         }\newline\newline         length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline            (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline         dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline         dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline\newline         for (i = 0; i &lt length; ++i)\newline            dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline         invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline         invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline#if 0\newline         dd_update_bm(&ampg_dd);\newline#endif\newline      }\newline      else\newline      {\newline#if 0\newline         DebugMessage(M64MSG_WARNING, &quotUnknown dma write 0x%&quot PRIX32 &quot in dma_pi_write()&quot, pi-&gtregs[PI_CART_ADDR_REG]);\newline#endif\newline      }\newline\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, /*pi-&gtregs[PI_WR_LEN_REG]*/0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x1fc00000) // for paper mario\newline   {\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, 0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000)\newline   {\newline      /* 64DD IPL */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x1FFFFFF;\newline      length = (i + length) &gt pi-&gtdd_rom.rom_size ?\newline         (pi-&gtdd_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtdd_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x3fffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtdd_rom.rom;\newline   }\newline   else\newline   {\newline      /* CART ROM */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3FFFFFF;\newline      length = (i + length) &gt pi-&gtcart_rom.rom_size ?\newline         (pi-&gtcart_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtcart_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3ffffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtcart_rom.rom;\newline   }\newline\newline   for (i = 0; i &lt length; ++i)\newline      dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline   invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline   invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline   /* HACK: monitor PI DMA to trigger RDRAM size detection\newline    * hack just before initial cart ROM loading. */\newline   if (pi-&gtregs[PI_CART_ADDR_REG] == 0x10001000 || pi-&gtregs[PI_CART_ADDR_REG] == 0x06001000)\newline   {\newline      force_detected_rdram_size_hack();\newline   }\newline   pi-&gtregs[PI_STATUS_REG] |= 3;\newline   cp0_update_count();\newline   add_interupt_event(PI_INT, length / 8);\newline}\newline","Copies data from the PI into RDRAM. \newline","3587173","log.c","void dief(char *format, ...) {\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	if (to_stdout) {\newline		vfprintf(stderr, format, ap);\newline	} else vsyslog(LOG_CONS | LOG_PID | LOG_DAEMON, format, ap);\newline	va_end(ap);\newline\newline	exit(1);\newline}\newline","\newline Print the given message string (like printf) to stdout/syslog and exit(1)\newline \newline \newline","4476940","destination.c","int ospCheckOrigDestination(void)\newline{\newline    struct usr_avp* destavp = NULL;\newline    int_str destval;\newline    osp_dest* dest = NULL;\newline    int result = -1;\newline\newline    for (destavp = search_first_avp(AVP_VAL_STR, _osp_origdest_avpid, NULL, 0);\newline        destavp != NULL;\newline        destavp = search_next_avp(destavp, NULL))\newline    {\newline        get_avp_val(destavp, &ampdestval);\newline\newline        /* OSP destintaion is wrapped in a string */\newline        dest = (osp_dest*)destval.s.s;\newline\newline        if (dest-&gtused == 0) {\newline            if (dest-&gtsupported == 1) {\newline                LM_DBG(&quotorig dest exist\\n&quot);\newline                result = 0;\newline                break;\newline            } else {\newline                /* Make it looks like used */\newline                dest-&gtused = 1;\newline                /* 111 means wrong protocol */\newline                dest-&gtlastcode = 111;\newline                LM_DBG(&quotdestination does not been supported\\n&quot);\newline            }\newline        } else {\newline            LM_DBG(&quotdestination has already been used\\n&quot);\newline        }\newline    }\newline\newline    if (result == -1) {\newline        LM_DBG(&quotthere is not unused destination\\n&quot);\newline        ospReportOrigSetupUsage();\newline    }\newline\newline    return result;\newline}\newline","\newline Check if there is an unused and supported originate destination from an AVP\newline avpid - osp_origdest_avpid\newline value - osp_dest wrapped in a string\newline search unused (used==0) &amp supported (support==1)\newline return 0 success, -1 failure\newline \newline","3249130","xtreewidget.cpp","void XTreeWidget::sortItems(int column, Qt::SortOrder order)\newline{\newline  int previd = id();\newline\newline  // if old style then maintain backwards compatibility\newline  if (_roles.size() &lt= 0)\newline  {\newline    QTreeWidget::sortItems(column, order);\newline    return;\newline  }\newline\newline  if (column &lt 0 || column &gt= columnCount() ||\newline      headerItem()-&gtdata(column, Qt::UserRole).toString() == &quotxtrunningrole&quot)\newline    return;\newline\newline  header()-&gtsetSortIndicator(column, order);\newline\newline  // simple insertion sort using binary search to find the right insertion pt\newline  QString totalrole(&quottotalrole&quot);\newline  int     itemcount      = topLevelItemCount();\newline  XTreeWidgetItem *prev  = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(0));\newline  for (int i = 1; i &lt itemcount; i++)\newline  {\newline    XTreeWidgetItem *item = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline    if (!item)\newline    {\newline      qWarning(&quotremoving a non-XTreWidgetItem from an XTreeWidget&quot);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (item-&gtdata(0, Qt::UserRole).toString() == totalrole)\newline    {\newline      if (DEBUG)\newline        qDebug(&quotsortItems() removing row %d because it&#039s a totalrole&quot, i);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (*item &lt *prev &amp&amp order == Qt::AscendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (*test &lt *item)\newline        {\newline          if (*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (*item &lt *test || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    else if (*item == *prev)\newline    {\newline      ; // nothing to do - make the &gt case easier to write\newline    }\newline    else if (!(*item &lt *prev) &amp&amp order == Qt::DescendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (!(*test &lt *item))\newline        {\newline          if (!(*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1)))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (!(*item &lt *test) || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    // can&#039t reuse item because the thing in position i may have changed\newline    prev = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline  }\newline\newline  populateCalculatedColumns();\newline\newline  setId(previd);\newline  emit resorted();\newline}\newline","don&#039t need this yet\newlinebool XTreeWidgetItem::operator&gt(const XTreeWidgetItem &ampother) const\newline{\newlinereturn !(this &lt other || this == other);\newline}\newline \newline","5595033","util.h","static inline ssize_t a_strlen(const char *s)\newline{\newline    return s ? strlen(s) : 0;\newline}\newline","\\brief \\c NULL resistant strlen.\newline \newline Unlike it&#039s libc sibling, a_strlen returns a ssize_t, and supports its\newline argument being NULL.\newline \newline \\param[in] s the string.\newline \\return the string length (or 0 if \\c s is \\c NULL).\newline \newline","5071508","draw.c","void DrawTitle(button_info *b,Window win,GC gc, XEvent *pev)\newline{\newline	int BH;\newline	int ix,iy,iw,ih;\newline	FlocaleFont *Ffont=buttonFont(b);\newline	int justify=buttonJustify(b);\newline	int l,i,xpos;\newline	char *s = NULL;\newline	int just=justify&ampb_TitleHoriz; /* Left, center, right */\newline	XGCValues gcv;\newline	XRectangle clip;\newline	Region region = None;\newline	FvwmPicture *pic;\newline	unsigned short bIconFlagSet;\newline\newline	BH = buttonHeight(b);\newline\newline	GetInternalSize(b,&ampix,&ampiy,&ampiw,&ampih);\newline\newline	/* ------------------------------------------------------------------ */\newline\newline	s = buttonTitle(b);\newline\newline	if (!s || !Ffont)\newline		return;\newline\newline	if (Ffont-&gtfont)\newline	{\newline		gcv.font = Ffont-&gtfont-&gtfid;\newline		XChangeGC(Dpy, gc, GCFont, &ampgcv);\newline	}\newline\newline	pic = buttonIcon(b);\newline	bIconFlagSet = iconFlagSet(b);\newline\newline	/* If a title is to be shown, truncate it until it fits */\newline	if(justify&ampb_Horizontal &amp&amp !b-&gtflags.b_Right)\newline	{\newline		if (bIconFlagSet)\newline		{\newline			ix += pic-&gtwidth+buttonXPad(b);\newline			iw -= pic-&gtwidth+buttonXPad(b);\newline		}\newline		else if (b-&gtflags.b_Swallow &amp&amp buttonSwallowCount(b)==3)\newline		{\newline			ix += b-&gticon_w+buttonXPad(b);\newline			iw -= b-&gticon_w+buttonXPad(b);\newline		}\newline	}\newline\newline	l = strlen(s);\newline	i = FlocaleTextWidth(Ffont,s,l);\newline\newline	if(i&gtiw)\newline	{\newline		if(just==2)\newline		{\newline			while(i&gtiw &amp&amp *s)\newline			{\newline				i=FlocaleTextWidth(Ffont,++s,--l);\newline			}\newline		}\newline		else /* Left or center - cut off its tail */\newline		{\newline			while(i&gtiw &amp&amp l&gt0)\newline			{\newline				i=FlocaleTextWidth(Ffont,s,--l);\newline			}\newline		}\newline	}\newline	if(just==0 || ((justify&ampb_Horizontal) &amp&amp b-&gtflags.b_Right)) /* Left */\newline	{\newline		xpos=ix;\newline	}\newline	else if(just==2) /* Right */\newline	{\newline		xpos=max(ix,ix+iw-i);\newline	}\newline	else /* Centered, I guess */\newline	{\newline		xpos=ix+(iw-i)/2;\newline	}\newline\newline	if(*s &amp&amp l&gt0 &amp&amp BH&gt=Ffont-&gtheight) /* Clip it somehow? */\newline	{\newline		FlocaleWinString FwinString;\newline		int cset;\newline\newline		memset(&ampFwinString, 0, sizeof(FwinString));\newline		FwinString.str = s;\newline		FwinString.win = win;\newline		FwinString.gc = gc;\newline		cset = buttonColorset(b);\newline		if (cset &gt= 0)\newline		{\newline			FwinString.colorset = &ampColorset[cset];\newline			FwinString.flags.has_colorset = 1;\newline		}\newline		FwinString.x = xpos;\newline		/* If there is more than the title, put it at the bottom */\newline		/* Unless stack flag is set, put it to the right of icon */\newline		if ((bIconFlagSet ||\newline		    ((buttonSwallowCount(b)==3) &amp&amp b-&gtflags.b_Swallow)) &amp&amp\newline		   !(justify&ampb_Horizontal))\newline		{\newline			FwinString.y = iy+ih-Ffont-&gtdescent;\newline			/* Shrink the space available for icon/window */\newline			ih-=Ffont-&gtheight;\newline		}\newline		/* Or else center vertically */\newline		else\newline		{\newline			FwinString.y =\newline				iy + (ih+ Ffont-&gtascent - Ffont-&gtdescent)/2;\newline		}\newline\newline		clip.x = FwinString.x;\newline		clip.y = FwinString.y - Ffont-&gtascent;\newline		clip.width = i;\newline		clip.height = Ffont-&gtheight;\newline		if (pev)\newline		{\newline			if (!frect_get_intersection(\newline				FwinString.x, FwinString.y - Ffont-&gtascent,\newline				i, Ffont-&gtheight,\newline				pev-&gtxexpose.x, pev-&gtxexpose.y,\newline				pev-&gtxexpose.width, pev-&gtxexpose.height,\newline				&ampclip))\newline			{\newline				return;\newline			}\newline		}\newline		XSetClipRectangles(\newline			Dpy, FwinString.gc, 0, 0, &ampclip, 1, Unsorted);\newline		region = XCreateRegion();\newline		XUnionRectWithRegion (&ampclip, region, region);\newline		FwinString.flags.has_clip_region = True;\newline		FwinString.clip_region = region;\newline		if (0 &amp&amp Ffont-&gtfftf.fftfont != NULL)\newline		{\newline			XClearArea(\newline				Dpy, win,\newline				clip.x, clip.y, clip.width, clip.height,\newline				False);\newline		}\newline		FlocaleDrawString(Dpy, Ffont, &ampFwinString, 0);\newline		XSetClipMask(Dpy, FwinString.gc, None);\newline		if (region)\newline		{\newline			XDestroyRegion(region);\newline		}\newline	}\newline}\newline","\newline Writes out title.\newline \newline","2691568","time.c","static s64 __init init_tsc(struct platform_timesource *pts)\newline{\newline    u64 ret = pts-&gtfrequency;\newline\newline    if ( nr_cpu_ids != num_present_cpus() )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: CPU Hotplug intended\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( nr_sockets &gt 1 &amp&amp !(tsc_flags &amp TSC_RELIABLE_SOCKET) )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: Not invariant across sockets\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( !ret )\newline        printk(XENLOG_DEBUG &quotTSC: Not setting it as clocksource\\n&quot);\newline\newline    return ret;\newline}\newline","\newline Called in verify_tsc_reliability() under reliable TSC conditions\newline thus reusing all the checks already performed there.\newline \newline","4709216","testpalette.c","static SDL_Surface *hflip(SDL_Surface *s)\newline{\newline    int i;\newline    SDL_Surface *z = SDL_CreateRGBSurface(SDL_SWSURFACE, s-&gtw, s-&gth, 8,\newline					  0, 0, 0, 0);\newline    /* copy palette */\newline    SDL_SetColors(z, s-&gtformat-&gtpalette-&gtcolors,\newline		  0, s-&gtformat-&gtpalette-&gtncolors);\newline    if(SDL_LockSurface(s) &lt 0 || SDL_LockSurface(z) &lt 0)\newline	sdlerr(&quotlocking flip images&quot);\newline\newline    for(i = 0; i &lt s-&gth; i++) {\newline	int j;\newline	Uint8 *from = (Uint8 *)s-&gtpixels + i * s-&gtpitch;\newline	Uint8 *to = (Uint8 *)z-&gtpixels + i * z-&gtpitch + s-&gtw - 1;\newline	for(j = 0; j &lt s-&gtw; j++)\newline	    to[-j] = from[j];\newline    }\newline\newline    SDL_UnlockSurface(z);\newline    SDL_UnlockSurface(s);\newline    return z;\newline}\newline","\newline Return a surface flipped horisontally. Only works for 8bpp;\newline extension to arbitrary bitness is left as an exercise for the reader.\newline \newline","1426157","pkt.c","void pkt_delay(pkt_t pkt, time_t t, const char *from) {\newline    char timestamp[21];\newline    int ns, elem;\newline\newline#ifdef ENABLE_SUPERSEDED\newline    datetime_out(t, dt_LEGACY, timestamp, 18);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotx&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0091 delay stamp %s&quot, timestamp);\newline#endif\newline    datetime_out(t, dt_DATETIME, timestamp, 21);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_URN_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotdelay&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0203 delay stamp %s&quot, timestamp);\newline}\newline","add an x:delay stamp \newline","","","","","","","","on","","","on","","","","on","","","","","","","on","","","","","","","","","","","","","","","","","","","","","Calculate the digest used in the finished message.","Extend the array by ""amount"" items.","Save the volume options to a file, used by shell utilities.","get a string field containing at most n characters","Copies data from the PI into RDRAM.","Print the given message string","Check if there is an unused and supported originate destination","{}","NULL resistant strlen.","Writes out title.","{}","GUI volume change callback","Return a surface flipped horisontally.","add an x:delay stamp","{}","Wait until one buffer got filled by the device.","Writes each trace from an archive into a separate trace file","start playing","Construct the data structures for obsolete things,","create a privkey","Bicubic splines interpolation with a irregular arrays as input and output"
"3IVEC1GSLPZEYLQQ6P4XM9PRDPO1JU","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3PJ71Z61R42RFTAAAFILMY7DX8Z91Y","A2MF174E19LY8D","Approved","Wed Apr 17 15:02:58 PDT 2019","Wed Apr 17 15:04:55 PDT 2019","Fri Apr 19 15:04:55 PDT 2019","2019-04-19 22:05:21 UTC","","","117","100% (4/4)","100% (4/4)","100% (4/4)","258116","tls1.c","int finished_digest(SSL *ssl, const char *label, uint8_t *digest)\newline{\newline    uint8_t mac_buf[SHA1_SIZE+MD5_SIZE+15]; \newline    uint8_t *q = mac_buf;\newline    int dgst_len;\newline\newline    if (label)\newline    {\newline        strcpy((char *)q, label);\newline        q += strlen(label);\newline    }\newline\newline    if (ssl-&gtversion &gt= SSL_PROTOCOL_VERSION_TLS1_2) // TLS1.2+\newline    {\newline        SHA256_CTX sha256_ctx = ssl-&gtdc-&gtsha256_ctx; // interim copy\newline        SHA256_Final(q, &ampsha256_ctx);\newline        q += SHA256_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline    else // TLS1.0/1.1\newline    {\newline        MD5_CTX md5_ctx = ssl-&gtdc-&gtmd5_ctx; // interim copy\newline        SHA1_CTX sha1_ctx = ssl-&gtdc-&gtsha1_ctx;\newline\newline        MD5_Final(q, &ampmd5_ctx);\newline        q += MD5_SIZE;\newline        \newline        SHA1_Final(q, &ampsha1_ctx);\newline        q += SHA1_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline\newline    if (label)\newline    {\newline        prf(ssl, ssl-&gtdc-&gtmaster_secret, SSL_SECRET_SIZE, \newline                mac_buf, dgst_len, digest, SSL_FINISHED_HASH_SIZE);\newline    }\newline    else    /* for use in a certificate verify */\newline    {\newline        memcpy(digest, mac_buf, dgst_len);\newline    }\newline\newline#if 0\newline    printf(&quotlabel: %s\\n&quot, label);\newline    print_blob(&quotmac_buf&quot, mac_buf, dgst_len);\newline    print_blob(&quotfinished digest&quot, digest, SSL_FINISHED_HASH_SIZE);\newline#endif\newline\newline    return dgst_len;\newline}   \newline","\newline Calculate the digest used in the finished message. This function also\newline doubles up as a certificate verify function.\newline \newline","3469015","metro.c","static void set_volume_cb(metro_t* metro)\newline{\newline  double* volume = (double*) g_malloc(sizeof(double));\newline\newline  *volume = GTK_ADJUSTMENT(metro-&gtvolume_adjustment)-&gtvalue / 100.0;\newline  comm_client_query(metro-&gtinter_thread_comm, MESSAGE_TYPE_SET_VOLUME,\newline      volume);\newline}\newline","\newline GUI volume change callback\newline \newline","3107006","cvalues.c","int numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname)\newline{\newline    int_t ai, bi;\newline    numerictype_t ta, tb;\newline    void *aptr, *bptr;\newline\newline    if (bothfixnums(a,b)) {\newline        if (a==b) return 0;\newline        if (numval(a) &lt numval(b)) return -1;\newline        return 1;\newline    }\newline    if (!num_to_ptr(a, &ampai, &ampta, &ampaptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, a); else return 2;\newline    }\newline    if (!num_to_ptr(b, &ampbi, &amptb, &ampbptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, b); else return 2;\newline    }\newline    if (eq &amp&amp eqnans &amp&amp ((ta &gt= T_FLOAT) != (tb &gt= T_FLOAT)))\newline        return 1;\newline    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\newline        return 0;\newline    if (eq) return 1;\newline    if (cmp_lt(aptr, ta, bptr, tb))\newline        return -1;\newline    return 1;\newline}\newline","\newlinereturns -1, 0, or 1 based on ordering of a and b\newlineeq: consider equality only, returning 0 or nonzero\newlineeqnans: NaNs considered equal to each other\newline-0.0 not considered equal to 0.0\newlineinexact not considered equal to exact\newlinefname: if not NULL, throws type errors, else returns 2 for type errors\newline \newline","4996949","vid21394_base.c","int vid21394_wait_buffer( vid21394handle_t vid21394handle, void **buffer )\newline{\newline   int retval = STATUS_SUCCESS;\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtis_receiving )\newline   {\newline      return STATUS_IS_STOPPED;\newline   }\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtdevice_present )\newline   {\newline      return STATUS_NO_DEVICE;\newline   }\newline	\newline   if( vid21394handle-&gtready_buffers.next )\newline   {\newline      unicap_queue_t *first_entry;\newline      // return immediately if a buffer is already in the ready queue\newline      first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline      *buffer = first_entry-&gtdata;\newline      free( first_entry );\newline   }\newline   else\newline   {\newline      if( vid21394handle-&gtqueued_buffers.next )\newline      {\newline	 //block until a buffer got filled by the device\newline	 unicap_queue_t *first_entry;\newline	 struct timeval timeout_time, cur_time;\newline			\newline	 if( gettimeofday( &amptimeout_time, NULL ) &lt 0 )\newline	 {\newline	    return STATUS_FAILURE;\newline	 }\newline			\newline	 timeout_time.tv_sec += 1; // 1 second timeout\newline	 while( !vid21394handle-&gtready_buffers.next )\newline	 {\newline	    // raw1394_loop_iterate is waked regularly by a seperate thread ( every 500ms )\newline	    if( gettimeofday( &ampcur_time, NULL ) &lt 0 )\newline	    {\newline	       return STATUS_FAILURE;\newline	    }\newline				\newline	    if( timercmp( &ampcur_time, &amptimeout_time, &gt ) )\newline	    {	\newline	       return STATUS_TIMEOUT;\newline	    }\newline/*\newline            // dcm: don&#039t enter into loop_iterate since, it can block even if a frame arrives\newline	    raw1394_loop_iterate( vid21394handle-&gtraw1394handle );\newline*/\newline            // 1 millisecond\newline            struct timespec delay = {0, 1000000};\newline	    nanosleep(&ampdelay, NULL);\newline	 }\newline	 first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline	 *buffer = first_entry-&gtdata;\newline			\newline	 free( first_entry );\newline      }\newline      else\newline      {\newline	 // no buffers queued -&gt no buffers to return\newline	 return STATUS_NO_BUFFERS;\newline      }\newline   }\newline	\newline\newline   return retval;\newline}\newline","\newlineWait until one buffer got filled by the device. \newlineMay return immediately ( if a buffer already was filled by the device ) \newlineor block until the buffer got filled.\newline \newline","5832055","litl_split.c","static void __litl_split_extract_traces(const char *dir) {\newline  int trace_out, res __attribute__ ((__unused__));\newline  char* trace_name;\newline  litl_size_t buffer_size;\newline  litl_med_size_t general_header_size, process_header_size;\newline\newline  general_header_size = sizeof(litl_general_header_t);\newline  process_header_size = sizeof(litl_process_header_t);\newline\newline  while (__arch-&gtnb_processes-- != 0) {\newline    // get a process header\newline    __arch-&gtprocess_header = (litl_process_header_t *) __arch-&gtheader_buffer;\newline    __arch-&gtheader_buffer += process_header_size;\newline\newline    res = asprintf(&amptrace_name, &quot%s/%s&quot, dir,\newline                   __arch-&gtprocess_header-&gtprocess_name);\newline\newline    // create and open a new trace file\newline    if ((trace_out = open(trace_name, O_WRONLY | O_CREAT, 0644)) &lt 0) {\newline      fprintf(stderr, &quotCannot create and open %s\\n&quot,\newline              __arch-&gtprocess_header-&gtprocess_name);\newline      exit(EXIT_FAILURE);\newline    }\newline\newline    // write a general trace header\newline    res = write(trace_out, __arch-&gttrace_header, general_header_size);\newline\newline    // write a process header\newline    buffer_size = __arch-&gtprocess_header-&gtoffset;\newline    __arch-&gtprocess_header-&gtoffset = general_header_size + process_header_size;\newline    res = write(trace_out, __arch-&gtprocess_header, process_header_size);\newline\newline    // set a file pointer to the position of the current process\newline    lseek(__arch-&gtf_handle, buffer_size, SEEK_SET);\newline\newline    // read data and write to a separate trace\newline    while (__arch-&gtprocess_header-&gttrace_size) {\newline      buffer_size =\newline          __arch-&gtprocess_header-&gttrace_size &gt __arch-&gtbuffer_size ?\newline            __arch-&gtbuffer_size : __arch-&gtprocess_header-&gttrace_size;\newline\newline      res = read(__arch-&gtf_handle, __arch-&gtbuffer, buffer_size);\newline\newline      res = write(trace_out, __arch-&gtbuffer, buffer_size);\newline\newline      __arch-&gtprocess_header-&gttrace_size -= buffer_size;\newline    }\newline\newline    free(trace_name);\newline    close(trace_out);\newline  }\newline}\newline","\newline Writes each trace from an archive into a separate trace file\newline \newline","5007086","oggread~.c","static void oggread_start(t_oggread *x)\newline{\newline    if(x-&gtx_fd &gt 0)\newline    {\newline		if(ov_time_seek(&ampx-&gtx_ov, 0) &lt 0)\newline		{\newline			post(&quotoggread~: could not rewind file to beginning&quot);\newline		}\newline		post(&quotoggread~: START&quot);\newline		x-&gtx_eos = 0;\newline		x-&gtx_outreadposition = 0;\newline		x-&gtx_outwriteposition = 0;\newline		x-&gtx_outunread = 0;\newline		x-&gtx_position = 0;\newline		clock_delay(x-&gtx_clock, 0);\newline		x-&gtx_stream = 1;\newline    }\newline	else post(&quotoggread~: no file open (ignored)&quot);\newline}\newline","start playing \newline","3370572","qdocdatabase.cpp","NodeMultiMap&amp QDocDatabase::getClassesWithObsoleteMembers()\newline{\newline    if (obsoleteClasses_.isEmpty() &amp&amp obsoleteQmlTypes_.isEmpty())\newline        processForest(&ampQDocDatabase::findAllObsoleteThings);\newline    return classesWithObsoleteMembers_;\newline}\newline","!\newlineConstruct the data structures for obsolete things, if they\newlinehave not already been constructed. Returns a reference to\newlinethe map of C++ classes with obsolete members.\newline \newline","6305983","gnutls_tpm.c","int gtls2_tpm_sign_cb(gnutls_session_t sess, void *_vpninfo,\newline		      gnutls_certificate_type_t cert_type,\newline		      const gnutls_datum_t *cert, const gnutls_datum_t *data,\newline		      gnutls_datum_t *sig)\newline{\newline	struct openconnect_info *vpninfo = _vpninfo;\newline\newline	if (cert_type != GNUTLS_CRT_X509)\newline		return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;\newline\newline	return tpm_sign_fn(NULL, vpninfo, data, sig);\newline}\newline","We want to use gnutls_privkey_import_ext() to create a privkey with our\newlineown signing function tpm_sign_fn(). But GnuTLS 2.12 doesn&#039t support that,\newlineso instead we have to register this sign_callback function with the\newline session \newline","5898142","kmclipm_priv_splines.c","double **bicubicspline_irreg_irreg(\newline        int nxi, double *xi,\newline        int nyi, double *yi,\newline        double **vi,\newline        int nxo, double *xo,\newline        int nyo, double *yo,\newline        enum boundary_mode mode)\newline{\newline    double **vo = matrix(nxo, nyo);\newline    double **v2 = blank_matrix(nxi);\newline    double *vtmp = NULL;\newline    double *vvtmp = NULL;\newline    double y1start = 0.0;  /* not used for bicubicsplines */\newline    double y1end = 0.0;    /* not used for bicubicsplines */\newline    int ix = 0, iy = 0, k = 0;\newline\newline    for (ix=0; ix&ltnxi; ix++) {\newline        v2[ix] = spline_irreg_init(nyi, yi, vi[ix], mode, y1start, y1end);\newline    }\newline\newline    for (ix=0; ix&ltnxo; ix++) {\newline        for (iy=0; iy&ltnyo; iy++) {\newline            vvtmp = vector(nxi);\newline            for (k=0; k&ltnxi; k++) {\newline                vvtmp[k] = spline_irreg_interpolate(nyi, yi, vi[k], v2[k], yo[iy]);\newline            }\newline            vtmp = spline_irreg_init(nxi, xi, vvtmp, mode, y1start, y1end);\newline            vo[ix][iy] = spline_irreg_interpolate(nxi, xi, vvtmp, vtmp, xo[ix]);\newline            free_vector(vtmp);\newline            free_vector(vvtmp);\newline        }\newline    }\newline    free_matrix(v2,nxi);\newline\newline    return vo;\newline}\newline","\newline@brief Bicubic splines interpolation with a irregular arrays as input and output\newline@param nxi number of points along the input x axis\newline@param xi values on the input x axis\newline@param nyi number of points along the input y axis\newline@param yi values on the input y axis\newline@param vi values for the two dimensional input array\newline@param nxo number of points along the output x axis\newline@param xo values on the output x axis\newline@param nyo number of points along the output y axis\newline@param yo values on the output y axis\newline@param mode mode for boundary estimate (NATURAL, ESTIMATED1 or ESTIMATED2)\newline@return vo values for the two dimensional output array\newline@warning The memory for the output array vo is allocated by this function. To free the memory again please use\newlinea call to free_matrix(vo, nyo)\newline \newline","3185402","list.c","static int qdb_list__extendarray(qdbint_t db, long amount)\newline{\newline	long origlen, origalloced;\newline	void *ptr;\newline\newline	origlen = db-&gtarray_len;\newline\newline	db-&gtarray_len += amount;\newline	if (db-&gtarray_len &lt db-&gtarray_alloced)\newline		return 0;\newline\newline	origalloced = db-&gtarray_alloced;\newline\newline	while (db-&gtarray_alloced &lt db-&gtarray_len) {\newline		db-&gtarray_alloced += ML_INCSIZE;\newline	}\newline\newline	if (db-&gtarray == NULL) {\newline		ptr =\newline		    calloc(db-&gtarray_alloced, sizeof(struct mh_record_s));\newline	} else {\newline		ptr = realloc(db-&gtarray,    /* RATS: ignore (OK) */\newline			      db-&gtarray_alloced *\newline			      sizeof(struct mh_record_s));\newline	}\newline\newline	if (ptr == NULL) {\newline		mh_lasterror = strerror(errno);\newline		db-&gtarray_len = origlen;\newline		db-&gtarray_alloced = origalloced;\newline		return 1;\newline	}\newline\newline	db-&gtarray = ptr;\newline\newline	return 0;\newline}\newline","\newline Extend the array by &quotamount&quot items. Returns nonzero on error.\newline \newline","1528436","volinfo.c","int savevolinfo(const struct vol *vol, const char *Cnid_srv, const char *Cnid_port)\newline{\newline    uid_t process_uid;\newline    char buf[16348];\newline    char item[MAXPATHLEN];\newline    int fd;\newline    int ret = 0;\newline    struct flock lock;\newline    const vol_opt_name_t *op = &ampvol_opt_names[0];\newline    const vol_opt_name_t *cf = &ampvol_opt_casefold[0];\newline\newline    strlcpy (item, vol-&gtv_path, sizeof(item));\newline    strlcat (item, &quot/.AppleDesktop/&quot, sizeof(item));\newline    strlcat (item, VOLINFOFILE, sizeof(item));\newline\newline    process_uid = geteuid();\newline    if (process_uid) {\newline        if (seteuid(0) == -1) {\newline            process_uid = 0;\newline        }\newline    }\newline\newline    if ((fd = open(item, O_RDWR | O_CREAT , 0666)) &lt0 ) {\newline        LOG(log_debug, logtype_default,&quotError opening %s: %s&quot, item, strerror(errno));\newline        if (process_uid) {\newline            if (seteuid(process_uid) == -1) {\newline                LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline                exit(EXITERR_SYS);\newline            }\newline        }\newline        return (-1);\newline    }\newline\newline    if (process_uid) {\newline        if (seteuid(process_uid) == -1) {\newline            LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline            exit(EXITERR_SYS);\newline        }\newline    }\newline\newline    /* try to get a lock */\newline    lock.l_start  = 0;\newline    lock.l_whence = SEEK_SET;\newline    lock.l_len    = 0;\newline    lock.l_type   = F_WRLCK;\newline\newline    if (fcntl(fd, F_SETLK, &amplock) &lt 0) {\newline        close(fd);\newline        if (errno == EACCES || errno == EAGAIN) {\newline            /* ignore, other process already writing the file */\newline            return 0;\newline        } else {\newline            LOG(log_error, logtype_default, &quotsavevoloptions: cannot get lock: %s&quot, strerror(errno));\newline            return (-1);\newline        }\newline    }\newline\newline    /* write volume options */\newline    snprintf(buf, sizeof(buf), &quotMAC_CHARSET:%s\\n&quot, vol-&gtv_maccodepage);\newline    snprintf(item, sizeof(item), &quotVOL_CHARSET:%s\\n&quot, vol-&gtv_volcodepage);\newline    strlcat(buf, item, sizeof(buf));\newline\newline    switch (vol-&gtv_adouble) {\newline        case AD_VERSION1:\newline            strlcat(buf, &quotADOUBLE_VER:v1\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2:\newline            strlcat(buf, &quotADOUBLE_VER:v2\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2_OSX:\newline            strlcat(buf, &quotADOUBLE_VER:osx\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION1_SFM:\newline            strlcat(buf, &quotADOUBLE_VER:sfm\\n&quot, sizeof(buf));\newline            break;\newline    }\newline\newline    strlcat(buf, &quotCNIDBACKEND:&quot, sizeof(buf));\newline    strlcat(buf, vol-&gtv_cnidscheme, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDHOST:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_srv, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDPORT:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_port, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strcpy(item, &quotCNID_DBPATH:&quot);\newline    if (vol-&gtv_dbpath)\newline        strlcat(item, vol-&gtv_dbpath, sizeof(item));\newline    else\newline        strlcat(item, vol-&gtv_path, sizeof(item));\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* volume flags */\newline    strcpy(item, &quotVOLUME_OPTS:&quot);\newline    for (;op-&gtname; op++) {\newline	if ( (vol-&gtv_flags &amp op-&gtoption) ) {\newline            strlcat(item, op-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* casefold flags */\newline    strcpy(item, &quotVOLCASEFOLD:&quot);\newline    for (;cf-&gtname; cf++) {\newline        if ( (vol-&gtv_casefold &amp cf-&gtoption) ) {\newline            strlcat(item, cf-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* ExtendedAttributes */\newline    strcpy(item, &quotEXTATTRTYPE:&quot);\newline    switch (vol-&gtv_vfs_ea) {\newline    case AFPVOL_EA_SYS:\newline        strlcat(item, &quotAFPVOL_EA_SYS\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_AD:\newline        strlcat(item, &quotAFPVOL_EA_AD\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_NONE:\newline        strlcat(item, &quotAFPVOL_EA_NONE\\n&quot, sizeof(item));\newline        break;\newline    default:\newline        strlcat(item, &quotAFPVOL_EA_UNKNOWN\\n&quot, sizeof(item));\newline    }\newline\newline    strlcat(buf, item, sizeof(buf));\newline\newline    if (strlen(buf) &gt= sizeof(buf)-1)\newline        LOG(log_debug, logtype_default, &quotError writing .volinfo file: buffer too small, %s&quot, buf);\newline   if (write( fd, buf, strlen(buf)) &lt 0 || ftruncate(fd, strlen(buf)) &lt 0 ) {\newline       LOG(log_debug, logtype_default, &quotError writing .volinfo file: %s&quot, strerror(errno));\newline   }\newline\newline   lock.l_type = F_UNLCK;\newline   fcntl(fd, F_SETLK, &amplock);\newline   close (fd);\newline   return ret;\newline}\newline","\newline Save the volume options to a file, used by shell utilities. Writing the file\newline everytime a volume is opened is unnecessary, but it shouldn&#039t hurt much.\newline \newline","2944956","ccd_frame.c","int fits_get_string(struct ccd_frame *fr, char *kwd, char *v, int n)\newline{\newline	char *row;\newline	int i, j;\newline\newline	row = (char *)fits_keyword_lookup(fr, kwd);\newline	if (row == NULL)\newline		return 0;\newline	for (i=9; i &lt FITS_HCOLS; i++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039)\newline			break;\newline	}\newline	if (i++ &gt= FITS_HCOLS)\newline		return -1;\newline//	d3_printf(&quotfirst quote at %d\\n&quot, i);\newline	for (j=0; i &lt FITS_HCOLS &amp&amp j &lt n-1; i++, j++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039) {\newline			break;\newline		}\newline		v[j] = row[i];\newline	}\newline//	d3_printf(&quotsecond quote at %d\\n&quot, i);\newline	v[j] = 0;\newline	if (i == FITS_HCOLS)\newline		return -1;\newline	return j;\newline}\newline","get a string field containing at most n characters\newline return the number of chars read, 0 if the field was not found,\newline or -1 for an error \newline","5206131","pi_controller.c","static void dma_pi_write(struct pi_controller *pi)\newline{\newline   uint32_t length, i;\newline   uint32_t dram_address;\newline   uint32_t rom_address;\newline   uint8_t* dram;\newline   const uint8_t* rom;\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &lt 0x10000000 &amp&amp !(pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000))\newline   {\newline      if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x08000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08010000)\newline      {\newline         if (pi-&gtuse_flashram != 1)\newline         {\newline            dma_read_sram(pi);\newline            pi-&gtuse_flashram = -1;\newline         }\newline         else\newline         {\newline            dma_read_flashram(pi);\newline         }\newline      }\newline      else if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x05000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x06000000)\newline      {\newline         //64DD REG/BUFFER\newline         length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline         i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x1FFFFFF;\newline\newline         if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000400)\newline         {\newline            //SECTOR BUFFER\newline            i -= 0x400;\newline            length = (i + length) &gt 0x100 ? (0x100 - i) : length;\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000400) &amp 0x3fffff;\newline            rom = (uint8_t*)g_dd.sec_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x14000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x10000000;\newline         }\newline         else if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000000)\newline         {\newline            //C2 BUFFER\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x3fffff;\newline            length      = (i + length) &gt 0x400 ? (0x400 - i) : length;\newline            rom         = (uint8_t*)g_dd.c2_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x44000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x40000000;\newline         }\newline         else\newline         {\newline            pi-&gtregs[PI_STATUS_REG] |= 3;\newline            cp0_update_count();\newline            add_interupt_event(PI_INT, length / 8);\newline\newline            return;\newline         }\newline\newline         length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline            (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline         dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline         dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline\newline         for (i = 0; i &lt length; ++i)\newline            dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline         invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline         invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline#if 0\newline         dd_update_bm(&ampg_dd);\newline#endif\newline      }\newline      else\newline      {\newline#if 0\newline         DebugMessage(M64MSG_WARNING, &quotUnknown dma write 0x%&quot PRIX32 &quot in dma_pi_write()&quot, pi-&gtregs[PI_CART_ADDR_REG]);\newline#endif\newline      }\newline\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, /*pi-&gtregs[PI_WR_LEN_REG]*/0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x1fc00000) // for paper mario\newline   {\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, 0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000)\newline   {\newline      /* 64DD IPL */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x1FFFFFF;\newline      length = (i + length) &gt pi-&gtdd_rom.rom_size ?\newline         (pi-&gtdd_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtdd_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x3fffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtdd_rom.rom;\newline   }\newline   else\newline   {\newline      /* CART ROM */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3FFFFFF;\newline      length = (i + length) &gt pi-&gtcart_rom.rom_size ?\newline         (pi-&gtcart_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtcart_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3ffffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtcart_rom.rom;\newline   }\newline\newline   for (i = 0; i &lt length; ++i)\newline      dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline   invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline   invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline   /* HACK: monitor PI DMA to trigger RDRAM size detection\newline    * hack just before initial cart ROM loading. */\newline   if (pi-&gtregs[PI_CART_ADDR_REG] == 0x10001000 || pi-&gtregs[PI_CART_ADDR_REG] == 0x06001000)\newline   {\newline      force_detected_rdram_size_hack();\newline   }\newline   pi-&gtregs[PI_STATUS_REG] |= 3;\newline   cp0_update_count();\newline   add_interupt_event(PI_INT, length / 8);\newline}\newline","Copies data from the PI into RDRAM. \newline","3587173","log.c","void dief(char *format, ...) {\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	if (to_stdout) {\newline		vfprintf(stderr, format, ap);\newline	} else vsyslog(LOG_CONS | LOG_PID | LOG_DAEMON, format, ap);\newline	va_end(ap);\newline\newline	exit(1);\newline}\newline","\newline Print the given message string (like printf) to stdout/syslog and exit(1)\newline \newline \newline","4476940","destination.c","int ospCheckOrigDestination(void)\newline{\newline    struct usr_avp* destavp = NULL;\newline    int_str destval;\newline    osp_dest* dest = NULL;\newline    int result = -1;\newline\newline    for (destavp = search_first_avp(AVP_VAL_STR, _osp_origdest_avpid, NULL, 0);\newline        destavp != NULL;\newline        destavp = search_next_avp(destavp, NULL))\newline    {\newline        get_avp_val(destavp, &ampdestval);\newline\newline        /* OSP destintaion is wrapped in a string */\newline        dest = (osp_dest*)destval.s.s;\newline\newline        if (dest-&gtused == 0) {\newline            if (dest-&gtsupported == 1) {\newline                LM_DBG(&quotorig dest exist\\n&quot);\newline                result = 0;\newline                break;\newline            } else {\newline                /* Make it looks like used */\newline                dest-&gtused = 1;\newline                /* 111 means wrong protocol */\newline                dest-&gtlastcode = 111;\newline                LM_DBG(&quotdestination does not been supported\\n&quot);\newline            }\newline        } else {\newline            LM_DBG(&quotdestination has already been used\\n&quot);\newline        }\newline    }\newline\newline    if (result == -1) {\newline        LM_DBG(&quotthere is not unused destination\\n&quot);\newline        ospReportOrigSetupUsage();\newline    }\newline\newline    return result;\newline}\newline","\newline Check if there is an unused and supported originate destination from an AVP\newline avpid - osp_origdest_avpid\newline value - osp_dest wrapped in a string\newline search unused (used==0) &amp supported (support==1)\newline return 0 success, -1 failure\newline \newline","3249130","xtreewidget.cpp","void XTreeWidget::sortItems(int column, Qt::SortOrder order)\newline{\newline  int previd = id();\newline\newline  // if old style then maintain backwards compatibility\newline  if (_roles.size() &lt= 0)\newline  {\newline    QTreeWidget::sortItems(column, order);\newline    return;\newline  }\newline\newline  if (column &lt 0 || column &gt= columnCount() ||\newline      headerItem()-&gtdata(column, Qt::UserRole).toString() == &quotxtrunningrole&quot)\newline    return;\newline\newline  header()-&gtsetSortIndicator(column, order);\newline\newline  // simple insertion sort using binary search to find the right insertion pt\newline  QString totalrole(&quottotalrole&quot);\newline  int     itemcount      = topLevelItemCount();\newline  XTreeWidgetItem *prev  = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(0));\newline  for (int i = 1; i &lt itemcount; i++)\newline  {\newline    XTreeWidgetItem *item = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline    if (!item)\newline    {\newline      qWarning(&quotremoving a non-XTreWidgetItem from an XTreeWidget&quot);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (item-&gtdata(0, Qt::UserRole).toString() == totalrole)\newline    {\newline      if (DEBUG)\newline        qDebug(&quotsortItems() removing row %d because it&#039s a totalrole&quot, i);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (*item &lt *prev &amp&amp order == Qt::AscendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (*test &lt *item)\newline        {\newline          if (*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (*item &lt *test || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    else if (*item == *prev)\newline    {\newline      ; // nothing to do - make the &gt case easier to write\newline    }\newline    else if (!(*item &lt *prev) &amp&amp order == Qt::DescendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (!(*test &lt *item))\newline        {\newline          if (!(*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1)))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (!(*item &lt *test) || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    // can&#039t reuse item because the thing in position i may have changed\newline    prev = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline  }\newline\newline  populateCalculatedColumns();\newline\newline  setId(previd);\newline  emit resorted();\newline}\newline","don&#039t need this yet\newlinebool XTreeWidgetItem::operator&gt(const XTreeWidgetItem &ampother) const\newline{\newlinereturn !(this &lt other || this == other);\newline}\newline \newline","5595033","util.h","static inline ssize_t a_strlen(const char *s)\newline{\newline    return s ? strlen(s) : 0;\newline}\newline","\\brief \\c NULL resistant strlen.\newline \newline Unlike it&#039s libc sibling, a_strlen returns a ssize_t, and supports its\newline argument being NULL.\newline \newline \\param[in] s the string.\newline \\return the string length (or 0 if \\c s is \\c NULL).\newline \newline","5071508","draw.c","void DrawTitle(button_info *b,Window win,GC gc, XEvent *pev)\newline{\newline	int BH;\newline	int ix,iy,iw,ih;\newline	FlocaleFont *Ffont=buttonFont(b);\newline	int justify=buttonJustify(b);\newline	int l,i,xpos;\newline	char *s = NULL;\newline	int just=justify&ampb_TitleHoriz; /* Left, center, right */\newline	XGCValues gcv;\newline	XRectangle clip;\newline	Region region = None;\newline	FvwmPicture *pic;\newline	unsigned short bIconFlagSet;\newline\newline	BH = buttonHeight(b);\newline\newline	GetInternalSize(b,&ampix,&ampiy,&ampiw,&ampih);\newline\newline	/* ------------------------------------------------------------------ */\newline\newline	s = buttonTitle(b);\newline\newline	if (!s || !Ffont)\newline		return;\newline\newline	if (Ffont-&gtfont)\newline	{\newline		gcv.font = Ffont-&gtfont-&gtfid;\newline		XChangeGC(Dpy, gc, GCFont, &ampgcv);\newline	}\newline\newline	pic = buttonIcon(b);\newline	bIconFlagSet = iconFlagSet(b);\newline\newline	/* If a title is to be shown, truncate it until it fits */\newline	if(justify&ampb_Horizontal &amp&amp !b-&gtflags.b_Right)\newline	{\newline		if (bIconFlagSet)\newline		{\newline			ix += pic-&gtwidth+buttonXPad(b);\newline			iw -= pic-&gtwidth+buttonXPad(b);\newline		}\newline		else if (b-&gtflags.b_Swallow &amp&amp buttonSwallowCount(b)==3)\newline		{\newline			ix += b-&gticon_w+buttonXPad(b);\newline			iw -= b-&gticon_w+buttonXPad(b);\newline		}\newline	}\newline\newline	l = strlen(s);\newline	i = FlocaleTextWidth(Ffont,s,l);\newline\newline	if(i&gtiw)\newline	{\newline		if(just==2)\newline		{\newline			while(i&gtiw &amp&amp *s)\newline			{\newline				i=FlocaleTextWidth(Ffont,++s,--l);\newline			}\newline		}\newline		else /* Left or center - cut off its tail */\newline		{\newline			while(i&gtiw &amp&amp l&gt0)\newline			{\newline				i=FlocaleTextWidth(Ffont,s,--l);\newline			}\newline		}\newline	}\newline	if(just==0 || ((justify&ampb_Horizontal) &amp&amp b-&gtflags.b_Right)) /* Left */\newline	{\newline		xpos=ix;\newline	}\newline	else if(just==2) /* Right */\newline	{\newline		xpos=max(ix,ix+iw-i);\newline	}\newline	else /* Centered, I guess */\newline	{\newline		xpos=ix+(iw-i)/2;\newline	}\newline\newline	if(*s &amp&amp l&gt0 &amp&amp BH&gt=Ffont-&gtheight) /* Clip it somehow? */\newline	{\newline		FlocaleWinString FwinString;\newline		int cset;\newline\newline		memset(&ampFwinString, 0, sizeof(FwinString));\newline		FwinString.str = s;\newline		FwinString.win = win;\newline		FwinString.gc = gc;\newline		cset = buttonColorset(b);\newline		if (cset &gt= 0)\newline		{\newline			FwinString.colorset = &ampColorset[cset];\newline			FwinString.flags.has_colorset = 1;\newline		}\newline		FwinString.x = xpos;\newline		/* If there is more than the title, put it at the bottom */\newline		/* Unless stack flag is set, put it to the right of icon */\newline		if ((bIconFlagSet ||\newline		    ((buttonSwallowCount(b)==3) &amp&amp b-&gtflags.b_Swallow)) &amp&amp\newline		   !(justify&ampb_Horizontal))\newline		{\newline			FwinString.y = iy+ih-Ffont-&gtdescent;\newline			/* Shrink the space available for icon/window */\newline			ih-=Ffont-&gtheight;\newline		}\newline		/* Or else center vertically */\newline		else\newline		{\newline			FwinString.y =\newline				iy + (ih+ Ffont-&gtascent - Ffont-&gtdescent)/2;\newline		}\newline\newline		clip.x = FwinString.x;\newline		clip.y = FwinString.y - Ffont-&gtascent;\newline		clip.width = i;\newline		clip.height = Ffont-&gtheight;\newline		if (pev)\newline		{\newline			if (!frect_get_intersection(\newline				FwinString.x, FwinString.y - Ffont-&gtascent,\newline				i, Ffont-&gtheight,\newline				pev-&gtxexpose.x, pev-&gtxexpose.y,\newline				pev-&gtxexpose.width, pev-&gtxexpose.height,\newline				&ampclip))\newline			{\newline				return;\newline			}\newline		}\newline		XSetClipRectangles(\newline			Dpy, FwinString.gc, 0, 0, &ampclip, 1, Unsorted);\newline		region = XCreateRegion();\newline		XUnionRectWithRegion (&ampclip, region, region);\newline		FwinString.flags.has_clip_region = True;\newline		FwinString.clip_region = region;\newline		if (0 &amp&amp Ffont-&gtfftf.fftfont != NULL)\newline		{\newline			XClearArea(\newline				Dpy, win,\newline				clip.x, clip.y, clip.width, clip.height,\newline				False);\newline		}\newline		FlocaleDrawString(Dpy, Ffont, &ampFwinString, 0);\newline		XSetClipMask(Dpy, FwinString.gc, None);\newline		if (region)\newline		{\newline			XDestroyRegion(region);\newline		}\newline	}\newline}\newline","\newline Writes out title.\newline \newline","2691568","time.c","static s64 __init init_tsc(struct platform_timesource *pts)\newline{\newline    u64 ret = pts-&gtfrequency;\newline\newline    if ( nr_cpu_ids != num_present_cpus() )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: CPU Hotplug intended\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( nr_sockets &gt 1 &amp&amp !(tsc_flags &amp TSC_RELIABLE_SOCKET) )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: Not invariant across sockets\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( !ret )\newline        printk(XENLOG_DEBUG &quotTSC: Not setting it as clocksource\\n&quot);\newline\newline    return ret;\newline}\newline","\newline Called in verify_tsc_reliability() under reliable TSC conditions\newline thus reusing all the checks already performed there.\newline \newline","4709216","testpalette.c","static SDL_Surface *hflip(SDL_Surface *s)\newline{\newline    int i;\newline    SDL_Surface *z = SDL_CreateRGBSurface(SDL_SWSURFACE, s-&gtw, s-&gth, 8,\newline					  0, 0, 0, 0);\newline    /* copy palette */\newline    SDL_SetColors(z, s-&gtformat-&gtpalette-&gtcolors,\newline		  0, s-&gtformat-&gtpalette-&gtncolors);\newline    if(SDL_LockSurface(s) &lt 0 || SDL_LockSurface(z) &lt 0)\newline	sdlerr(&quotlocking flip images&quot);\newline\newline    for(i = 0; i &lt s-&gth; i++) {\newline	int j;\newline	Uint8 *from = (Uint8 *)s-&gtpixels + i * s-&gtpitch;\newline	Uint8 *to = (Uint8 *)z-&gtpixels + i * z-&gtpitch + s-&gtw - 1;\newline	for(j = 0; j &lt s-&gtw; j++)\newline	    to[-j] = from[j];\newline    }\newline\newline    SDL_UnlockSurface(z);\newline    SDL_UnlockSurface(s);\newline    return z;\newline}\newline","\newline Return a surface flipped horisontally. Only works for 8bpp;\newline extension to arbitrary bitness is left as an exercise for the reader.\newline \newline","1426157","pkt.c","void pkt_delay(pkt_t pkt, time_t t, const char *from) {\newline    char timestamp[21];\newline    int ns, elem;\newline\newline#ifdef ENABLE_SUPERSEDED\newline    datetime_out(t, dt_LEGACY, timestamp, 18);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotx&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0091 delay stamp %s&quot, timestamp);\newline#endif\newline    datetime_out(t, dt_DATETIME, timestamp, 21);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_URN_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotdelay&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0203 delay stamp %s&quot, timestamp);\newline}\newline","add an x:delay stamp \newline","","","","","","","on","on","","","","","","","on","on","","","","","","on","","","","","","","","","","","","","","","","","","","","","Calculate the digest used in the finished message.","Extend the array by ""amount"" items.","Save the volume options to a file,","get a string field containing at most n characters","Copies data from the PI into RDRAM.","Print the given message string","{}","{}","supports itsargument being NULL.","Writes out title.","reusing all the checks already performed there.","volume change callback","Return a surface flipped horisontally.","add an x:delay stamp","{}","{}","Writes each trace from an archive into a separate trace file","start playing","Construct the data structures for obsolete things,","create a privkey with ourown signing function","splines interpolation with a irregular arrays as input and output"
"3IVEC1GSLPZEYLQQ6P4XM9PRDPO1JU","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3R5F3LQFV2KRHCZOKFAVBIME5KSZOH","AUIIA81DC08ZO","Approved","Wed Apr 17 09:53:47 PDT 2019","Wed Apr 17 10:18:49 PDT 2019","Fri Apr 19 10:18:49 PDT 2019","2019-04-19 17:19:21 UTC","","","1502","100% (1/1)","100% (1/1)","100% (1/1)","258116","tls1.c","int finished_digest(SSL *ssl, const char *label, uint8_t *digest)\newline{\newline    uint8_t mac_buf[SHA1_SIZE+MD5_SIZE+15]; \newline    uint8_t *q = mac_buf;\newline    int dgst_len;\newline\newline    if (label)\newline    {\newline        strcpy((char *)q, label);\newline        q += strlen(label);\newline    }\newline\newline    if (ssl-&gtversion &gt= SSL_PROTOCOL_VERSION_TLS1_2) // TLS1.2+\newline    {\newline        SHA256_CTX sha256_ctx = ssl-&gtdc-&gtsha256_ctx; // interim copy\newline        SHA256_Final(q, &ampsha256_ctx);\newline        q += SHA256_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline    else // TLS1.0/1.1\newline    {\newline        MD5_CTX md5_ctx = ssl-&gtdc-&gtmd5_ctx; // interim copy\newline        SHA1_CTX sha1_ctx = ssl-&gtdc-&gtsha1_ctx;\newline\newline        MD5_Final(q, &ampmd5_ctx);\newline        q += MD5_SIZE;\newline        \newline        SHA1_Final(q, &ampsha1_ctx);\newline        q += SHA1_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline\newline    if (label)\newline    {\newline        prf(ssl, ssl-&gtdc-&gtmaster_secret, SSL_SECRET_SIZE, \newline                mac_buf, dgst_len, digest, SSL_FINISHED_HASH_SIZE);\newline    }\newline    else    /* for use in a certificate verify */\newline    {\newline        memcpy(digest, mac_buf, dgst_len);\newline    }\newline\newline#if 0\newline    printf(&quotlabel: %s\\n&quot, label);\newline    print_blob(&quotmac_buf&quot, mac_buf, dgst_len);\newline    print_blob(&quotfinished digest&quot, digest, SSL_FINISHED_HASH_SIZE);\newline#endif\newline\newline    return dgst_len;\newline}   \newline","\newline Calculate the digest used in the finished message. This function also\newline doubles up as a certificate verify function.\newline \newline","3469015","metro.c","static void set_volume_cb(metro_t* metro)\newline{\newline  double* volume = (double*) g_malloc(sizeof(double));\newline\newline  *volume = GTK_ADJUSTMENT(metro-&gtvolume_adjustment)-&gtvalue / 100.0;\newline  comm_client_query(metro-&gtinter_thread_comm, MESSAGE_TYPE_SET_VOLUME,\newline      volume);\newline}\newline","\newline GUI volume change callback\newline \newline","3107006","cvalues.c","int numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname)\newline{\newline    int_t ai, bi;\newline    numerictype_t ta, tb;\newline    void *aptr, *bptr;\newline\newline    if (bothfixnums(a,b)) {\newline        if (a==b) return 0;\newline        if (numval(a) &lt numval(b)) return -1;\newline        return 1;\newline    }\newline    if (!num_to_ptr(a, &ampai, &ampta, &ampaptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, a); else return 2;\newline    }\newline    if (!num_to_ptr(b, &ampbi, &amptb, &ampbptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, b); else return 2;\newline    }\newline    if (eq &amp&amp eqnans &amp&amp ((ta &gt= T_FLOAT) != (tb &gt= T_FLOAT)))\newline        return 1;\newline    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\newline        return 0;\newline    if (eq) return 1;\newline    if (cmp_lt(aptr, ta, bptr, tb))\newline        return -1;\newline    return 1;\newline}\newline","\newlinereturns -1, 0, or 1 based on ordering of a and b\newlineeq: consider equality only, returning 0 or nonzero\newlineeqnans: NaNs considered equal to each other\newline-0.0 not considered equal to 0.0\newlineinexact not considered equal to exact\newlinefname: if not NULL, throws type errors, else returns 2 for type errors\newline \newline","4996949","vid21394_base.c","int vid21394_wait_buffer( vid21394handle_t vid21394handle, void **buffer )\newline{\newline   int retval = STATUS_SUCCESS;\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtis_receiving )\newline   {\newline      return STATUS_IS_STOPPED;\newline   }\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtdevice_present )\newline   {\newline      return STATUS_NO_DEVICE;\newline   }\newline	\newline   if( vid21394handle-&gtready_buffers.next )\newline   {\newline      unicap_queue_t *first_entry;\newline      // return immediately if a buffer is already in the ready queue\newline      first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline      *buffer = first_entry-&gtdata;\newline      free( first_entry );\newline   }\newline   else\newline   {\newline      if( vid21394handle-&gtqueued_buffers.next )\newline      {\newline	 //block until a buffer got filled by the device\newline	 unicap_queue_t *first_entry;\newline	 struct timeval timeout_time, cur_time;\newline			\newline	 if( gettimeofday( &amptimeout_time, NULL ) &lt 0 )\newline	 {\newline	    return STATUS_FAILURE;\newline	 }\newline			\newline	 timeout_time.tv_sec += 1; // 1 second timeout\newline	 while( !vid21394handle-&gtready_buffers.next )\newline	 {\newline	    // raw1394_loop_iterate is waked regularly by a seperate thread ( every 500ms )\newline	    if( gettimeofday( &ampcur_time, NULL ) &lt 0 )\newline	    {\newline	       return STATUS_FAILURE;\newline	    }\newline				\newline	    if( timercmp( &ampcur_time, &amptimeout_time, &gt ) )\newline	    {	\newline	       return STATUS_TIMEOUT;\newline	    }\newline/*\newline            // dcm: don&#039t enter into loop_iterate since, it can block even if a frame arrives\newline	    raw1394_loop_iterate( vid21394handle-&gtraw1394handle );\newline*/\newline            // 1 millisecond\newline            struct timespec delay = {0, 1000000};\newline	    nanosleep(&ampdelay, NULL);\newline	 }\newline	 first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline	 *buffer = first_entry-&gtdata;\newline			\newline	 free( first_entry );\newline      }\newline      else\newline      {\newline	 // no buffers queued -&gt no buffers to return\newline	 return STATUS_NO_BUFFERS;\newline      }\newline   }\newline	\newline\newline   return retval;\newline}\newline","\newlineWait until one buffer got filled by the device. \newlineMay return immediately ( if a buffer already was filled by the device ) \newlineor block until the buffer got filled.\newline \newline","5832055","litl_split.c","static void __litl_split_extract_traces(const char *dir) {\newline  int trace_out, res __attribute__ ((__unused__));\newline  char* trace_name;\newline  litl_size_t buffer_size;\newline  litl_med_size_t general_header_size, process_header_size;\newline\newline  general_header_size = sizeof(litl_general_header_t);\newline  process_header_size = sizeof(litl_process_header_t);\newline\newline  while (__arch-&gtnb_processes-- != 0) {\newline    // get a process header\newline    __arch-&gtprocess_header = (litl_process_header_t *) __arch-&gtheader_buffer;\newline    __arch-&gtheader_buffer += process_header_size;\newline\newline    res = asprintf(&amptrace_name, &quot%s/%s&quot, dir,\newline                   __arch-&gtprocess_header-&gtprocess_name);\newline\newline    // create and open a new trace file\newline    if ((trace_out = open(trace_name, O_WRONLY | O_CREAT, 0644)) &lt 0) {\newline      fprintf(stderr, &quotCannot create and open %s\\n&quot,\newline              __arch-&gtprocess_header-&gtprocess_name);\newline      exit(EXIT_FAILURE);\newline    }\newline\newline    // write a general trace header\newline    res = write(trace_out, __arch-&gttrace_header, general_header_size);\newline\newline    // write a process header\newline    buffer_size = __arch-&gtprocess_header-&gtoffset;\newline    __arch-&gtprocess_header-&gtoffset = general_header_size + process_header_size;\newline    res = write(trace_out, __arch-&gtprocess_header, process_header_size);\newline\newline    // set a file pointer to the position of the current process\newline    lseek(__arch-&gtf_handle, buffer_size, SEEK_SET);\newline\newline    // read data and write to a separate trace\newline    while (__arch-&gtprocess_header-&gttrace_size) {\newline      buffer_size =\newline          __arch-&gtprocess_header-&gttrace_size &gt __arch-&gtbuffer_size ?\newline            __arch-&gtbuffer_size : __arch-&gtprocess_header-&gttrace_size;\newline\newline      res = read(__arch-&gtf_handle, __arch-&gtbuffer, buffer_size);\newline\newline      res = write(trace_out, __arch-&gtbuffer, buffer_size);\newline\newline      __arch-&gtprocess_header-&gttrace_size -= buffer_size;\newline    }\newline\newline    free(trace_name);\newline    close(trace_out);\newline  }\newline}\newline","\newline Writes each trace from an archive into a separate trace file\newline \newline","5007086","oggread~.c","static void oggread_start(t_oggread *x)\newline{\newline    if(x-&gtx_fd &gt 0)\newline    {\newline		if(ov_time_seek(&ampx-&gtx_ov, 0) &lt 0)\newline		{\newline			post(&quotoggread~: could not rewind file to beginning&quot);\newline		}\newline		post(&quotoggread~: START&quot);\newline		x-&gtx_eos = 0;\newline		x-&gtx_outreadposition = 0;\newline		x-&gtx_outwriteposition = 0;\newline		x-&gtx_outunread = 0;\newline		x-&gtx_position = 0;\newline		clock_delay(x-&gtx_clock, 0);\newline		x-&gtx_stream = 1;\newline    }\newline	else post(&quotoggread~: no file open (ignored)&quot);\newline}\newline","start playing \newline","3370572","qdocdatabase.cpp","NodeMultiMap&amp QDocDatabase::getClassesWithObsoleteMembers()\newline{\newline    if (obsoleteClasses_.isEmpty() &amp&amp obsoleteQmlTypes_.isEmpty())\newline        processForest(&ampQDocDatabase::findAllObsoleteThings);\newline    return classesWithObsoleteMembers_;\newline}\newline","!\newlineConstruct the data structures for obsolete things, if they\newlinehave not already been constructed. Returns a reference to\newlinethe map of C++ classes with obsolete members.\newline \newline","6305983","gnutls_tpm.c","int gtls2_tpm_sign_cb(gnutls_session_t sess, void *_vpninfo,\newline		      gnutls_certificate_type_t cert_type,\newline		      const gnutls_datum_t *cert, const gnutls_datum_t *data,\newline		      gnutls_datum_t *sig)\newline{\newline	struct openconnect_info *vpninfo = _vpninfo;\newline\newline	if (cert_type != GNUTLS_CRT_X509)\newline		return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;\newline\newline	return tpm_sign_fn(NULL, vpninfo, data, sig);\newline}\newline","We want to use gnutls_privkey_import_ext() to create a privkey with our\newlineown signing function tpm_sign_fn(). But GnuTLS 2.12 doesn&#039t support that,\newlineso instead we have to register this sign_callback function with the\newline session \newline","5898142","kmclipm_priv_splines.c","double **bicubicspline_irreg_irreg(\newline        int nxi, double *xi,\newline        int nyi, double *yi,\newline        double **vi,\newline        int nxo, double *xo,\newline        int nyo, double *yo,\newline        enum boundary_mode mode)\newline{\newline    double **vo = matrix(nxo, nyo);\newline    double **v2 = blank_matrix(nxi);\newline    double *vtmp = NULL;\newline    double *vvtmp = NULL;\newline    double y1start = 0.0;  /* not used for bicubicsplines */\newline    double y1end = 0.0;    /* not used for bicubicsplines */\newline    int ix = 0, iy = 0, k = 0;\newline\newline    for (ix=0; ix&ltnxi; ix++) {\newline        v2[ix] = spline_irreg_init(nyi, yi, vi[ix], mode, y1start, y1end);\newline    }\newline\newline    for (ix=0; ix&ltnxo; ix++) {\newline        for (iy=0; iy&ltnyo; iy++) {\newline            vvtmp = vector(nxi);\newline            for (k=0; k&ltnxi; k++) {\newline                vvtmp[k] = spline_irreg_interpolate(nyi, yi, vi[k], v2[k], yo[iy]);\newline            }\newline            vtmp = spline_irreg_init(nxi, xi, vvtmp, mode, y1start, y1end);\newline            vo[ix][iy] = spline_irreg_interpolate(nxi, xi, vvtmp, vtmp, xo[ix]);\newline            free_vector(vtmp);\newline            free_vector(vvtmp);\newline        }\newline    }\newline    free_matrix(v2,nxi);\newline\newline    return vo;\newline}\newline","\newline@brief Bicubic splines interpolation with a irregular arrays as input and output\newline@param nxi number of points along the input x axis\newline@param xi values on the input x axis\newline@param nyi number of points along the input y axis\newline@param yi values on the input y axis\newline@param vi values for the two dimensional input array\newline@param nxo number of points along the output x axis\newline@param xo values on the output x axis\newline@param nyo number of points along the output y axis\newline@param yo values on the output y axis\newline@param mode mode for boundary estimate (NATURAL, ESTIMATED1 or ESTIMATED2)\newline@return vo values for the two dimensional output array\newline@warning The memory for the output array vo is allocated by this function. To free the memory again please use\newlinea call to free_matrix(vo, nyo)\newline \newline","3185402","list.c","static int qdb_list__extendarray(qdbint_t db, long amount)\newline{\newline	long origlen, origalloced;\newline	void *ptr;\newline\newline	origlen = db-&gtarray_len;\newline\newline	db-&gtarray_len += amount;\newline	if (db-&gtarray_len &lt db-&gtarray_alloced)\newline		return 0;\newline\newline	origalloced = db-&gtarray_alloced;\newline\newline	while (db-&gtarray_alloced &lt db-&gtarray_len) {\newline		db-&gtarray_alloced += ML_INCSIZE;\newline	}\newline\newline	if (db-&gtarray == NULL) {\newline		ptr =\newline		    calloc(db-&gtarray_alloced, sizeof(struct mh_record_s));\newline	} else {\newline		ptr = realloc(db-&gtarray,    /* RATS: ignore (OK) */\newline			      db-&gtarray_alloced *\newline			      sizeof(struct mh_record_s));\newline	}\newline\newline	if (ptr == NULL) {\newline		mh_lasterror = strerror(errno);\newline		db-&gtarray_len = origlen;\newline		db-&gtarray_alloced = origalloced;\newline		return 1;\newline	}\newline\newline	db-&gtarray = ptr;\newline\newline	return 0;\newline}\newline","\newline Extend the array by &quotamount&quot items. Returns nonzero on error.\newline \newline","1528436","volinfo.c","int savevolinfo(const struct vol *vol, const char *Cnid_srv, const char *Cnid_port)\newline{\newline    uid_t process_uid;\newline    char buf[16348];\newline    char item[MAXPATHLEN];\newline    int fd;\newline    int ret = 0;\newline    struct flock lock;\newline    const vol_opt_name_t *op = &ampvol_opt_names[0];\newline    const vol_opt_name_t *cf = &ampvol_opt_casefold[0];\newline\newline    strlcpy (item, vol-&gtv_path, sizeof(item));\newline    strlcat (item, &quot/.AppleDesktop/&quot, sizeof(item));\newline    strlcat (item, VOLINFOFILE, sizeof(item));\newline\newline    process_uid = geteuid();\newline    if (process_uid) {\newline        if (seteuid(0) == -1) {\newline            process_uid = 0;\newline        }\newline    }\newline\newline    if ((fd = open(item, O_RDWR | O_CREAT , 0666)) &lt0 ) {\newline        LOG(log_debug, logtype_default,&quotError opening %s: %s&quot, item, strerror(errno));\newline        if (process_uid) {\newline            if (seteuid(process_uid) == -1) {\newline                LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline                exit(EXITERR_SYS);\newline            }\newline        }\newline        return (-1);\newline    }\newline\newline    if (process_uid) {\newline        if (seteuid(process_uid) == -1) {\newline            LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline            exit(EXITERR_SYS);\newline        }\newline    }\newline\newline    /* try to get a lock */\newline    lock.l_start  = 0;\newline    lock.l_whence = SEEK_SET;\newline    lock.l_len    = 0;\newline    lock.l_type   = F_WRLCK;\newline\newline    if (fcntl(fd, F_SETLK, &amplock) &lt 0) {\newline        close(fd);\newline        if (errno == EACCES || errno == EAGAIN) {\newline            /* ignore, other process already writing the file */\newline            return 0;\newline        } else {\newline            LOG(log_error, logtype_default, &quotsavevoloptions: cannot get lock: %s&quot, strerror(errno));\newline            return (-1);\newline        }\newline    }\newline\newline    /* write volume options */\newline    snprintf(buf, sizeof(buf), &quotMAC_CHARSET:%s\\n&quot, vol-&gtv_maccodepage);\newline    snprintf(item, sizeof(item), &quotVOL_CHARSET:%s\\n&quot, vol-&gtv_volcodepage);\newline    strlcat(buf, item, sizeof(buf));\newline\newline    switch (vol-&gtv_adouble) {\newline        case AD_VERSION1:\newline            strlcat(buf, &quotADOUBLE_VER:v1\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2:\newline            strlcat(buf, &quotADOUBLE_VER:v2\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2_OSX:\newline            strlcat(buf, &quotADOUBLE_VER:osx\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION1_SFM:\newline            strlcat(buf, &quotADOUBLE_VER:sfm\\n&quot, sizeof(buf));\newline            break;\newline    }\newline\newline    strlcat(buf, &quotCNIDBACKEND:&quot, sizeof(buf));\newline    strlcat(buf, vol-&gtv_cnidscheme, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDHOST:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_srv, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDPORT:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_port, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strcpy(item, &quotCNID_DBPATH:&quot);\newline    if (vol-&gtv_dbpath)\newline        strlcat(item, vol-&gtv_dbpath, sizeof(item));\newline    else\newline        strlcat(item, vol-&gtv_path, sizeof(item));\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* volume flags */\newline    strcpy(item, &quotVOLUME_OPTS:&quot);\newline    for (;op-&gtname; op++) {\newline	if ( (vol-&gtv_flags &amp op-&gtoption) ) {\newline            strlcat(item, op-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* casefold flags */\newline    strcpy(item, &quotVOLCASEFOLD:&quot);\newline    for (;cf-&gtname; cf++) {\newline        if ( (vol-&gtv_casefold &amp cf-&gtoption) ) {\newline            strlcat(item, cf-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* ExtendedAttributes */\newline    strcpy(item, &quotEXTATTRTYPE:&quot);\newline    switch (vol-&gtv_vfs_ea) {\newline    case AFPVOL_EA_SYS:\newline        strlcat(item, &quotAFPVOL_EA_SYS\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_AD:\newline        strlcat(item, &quotAFPVOL_EA_AD\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_NONE:\newline        strlcat(item, &quotAFPVOL_EA_NONE\\n&quot, sizeof(item));\newline        break;\newline    default:\newline        strlcat(item, &quotAFPVOL_EA_UNKNOWN\\n&quot, sizeof(item));\newline    }\newline\newline    strlcat(buf, item, sizeof(buf));\newline\newline    if (strlen(buf) &gt= sizeof(buf)-1)\newline        LOG(log_debug, logtype_default, &quotError writing .volinfo file: buffer too small, %s&quot, buf);\newline   if (write( fd, buf, strlen(buf)) &lt 0 || ftruncate(fd, strlen(buf)) &lt 0 ) {\newline       LOG(log_debug, logtype_default, &quotError writing .volinfo file: %s&quot, strerror(errno));\newline   }\newline\newline   lock.l_type = F_UNLCK;\newline   fcntl(fd, F_SETLK, &amplock);\newline   close (fd);\newline   return ret;\newline}\newline","\newline Save the volume options to a file, used by shell utilities. Writing the file\newline everytime a volume is opened is unnecessary, but it shouldn&#039t hurt much.\newline \newline","2944956","ccd_frame.c","int fits_get_string(struct ccd_frame *fr, char *kwd, char *v, int n)\newline{\newline	char *row;\newline	int i, j;\newline\newline	row = (char *)fits_keyword_lookup(fr, kwd);\newline	if (row == NULL)\newline		return 0;\newline	for (i=9; i &lt FITS_HCOLS; i++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039)\newline			break;\newline	}\newline	if (i++ &gt= FITS_HCOLS)\newline		return -1;\newline//	d3_printf(&quotfirst quote at %d\\n&quot, i);\newline	for (j=0; i &lt FITS_HCOLS &amp&amp j &lt n-1; i++, j++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039) {\newline			break;\newline		}\newline		v[j] = row[i];\newline	}\newline//	d3_printf(&quotsecond quote at %d\\n&quot, i);\newline	v[j] = 0;\newline	if (i == FITS_HCOLS)\newline		return -1;\newline	return j;\newline}\newline","get a string field containing at most n characters\newline return the number of chars read, 0 if the field was not found,\newline or -1 for an error \newline","5206131","pi_controller.c","static void dma_pi_write(struct pi_controller *pi)\newline{\newline   uint32_t length, i;\newline   uint32_t dram_address;\newline   uint32_t rom_address;\newline   uint8_t* dram;\newline   const uint8_t* rom;\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &lt 0x10000000 &amp&amp !(pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000))\newline   {\newline      if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x08000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08010000)\newline      {\newline         if (pi-&gtuse_flashram != 1)\newline         {\newline            dma_read_sram(pi);\newline            pi-&gtuse_flashram = -1;\newline         }\newline         else\newline         {\newline            dma_read_flashram(pi);\newline         }\newline      }\newline      else if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x05000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x06000000)\newline      {\newline         //64DD REG/BUFFER\newline         length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline         i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x1FFFFFF;\newline\newline         if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000400)\newline         {\newline            //SECTOR BUFFER\newline            i -= 0x400;\newline            length = (i + length) &gt 0x100 ? (0x100 - i) : length;\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000400) &amp 0x3fffff;\newline            rom = (uint8_t*)g_dd.sec_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x14000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x10000000;\newline         }\newline         else if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000000)\newline         {\newline            //C2 BUFFER\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x3fffff;\newline            length      = (i + length) &gt 0x400 ? (0x400 - i) : length;\newline            rom         = (uint8_t*)g_dd.c2_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x44000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x40000000;\newline         }\newline         else\newline         {\newline            pi-&gtregs[PI_STATUS_REG] |= 3;\newline            cp0_update_count();\newline            add_interupt_event(PI_INT, length / 8);\newline\newline            return;\newline         }\newline\newline         length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline            (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline         dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline         dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline\newline         for (i = 0; i &lt length; ++i)\newline            dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline         invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline         invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline#if 0\newline         dd_update_bm(&ampg_dd);\newline#endif\newline      }\newline      else\newline      {\newline#if 0\newline         DebugMessage(M64MSG_WARNING, &quotUnknown dma write 0x%&quot PRIX32 &quot in dma_pi_write()&quot, pi-&gtregs[PI_CART_ADDR_REG]);\newline#endif\newline      }\newline\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, /*pi-&gtregs[PI_WR_LEN_REG]*/0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x1fc00000) // for paper mario\newline   {\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, 0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000)\newline   {\newline      /* 64DD IPL */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x1FFFFFF;\newline      length = (i + length) &gt pi-&gtdd_rom.rom_size ?\newline         (pi-&gtdd_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtdd_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x3fffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtdd_rom.rom;\newline   }\newline   else\newline   {\newline      /* CART ROM */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3FFFFFF;\newline      length = (i + length) &gt pi-&gtcart_rom.rom_size ?\newline         (pi-&gtcart_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtcart_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3ffffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtcart_rom.rom;\newline   }\newline\newline   for (i = 0; i &lt length; ++i)\newline      dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline   invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline   invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline   /* HACK: monitor PI DMA to trigger RDRAM size detection\newline    * hack just before initial cart ROM loading. */\newline   if (pi-&gtregs[PI_CART_ADDR_REG] == 0x10001000 || pi-&gtregs[PI_CART_ADDR_REG] == 0x06001000)\newline   {\newline      force_detected_rdram_size_hack();\newline   }\newline   pi-&gtregs[PI_STATUS_REG] |= 3;\newline   cp0_update_count();\newline   add_interupt_event(PI_INT, length / 8);\newline}\newline","Copies data from the PI into RDRAM. \newline","3587173","log.c","void dief(char *format, ...) {\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	if (to_stdout) {\newline		vfprintf(stderr, format, ap);\newline	} else vsyslog(LOG_CONS | LOG_PID | LOG_DAEMON, format, ap);\newline	va_end(ap);\newline\newline	exit(1);\newline}\newline","\newline Print the given message string (like printf) to stdout/syslog and exit(1)\newline \newline \newline","4476940","destination.c","int ospCheckOrigDestination(void)\newline{\newline    struct usr_avp* destavp = NULL;\newline    int_str destval;\newline    osp_dest* dest = NULL;\newline    int result = -1;\newline\newline    for (destavp = search_first_avp(AVP_VAL_STR, _osp_origdest_avpid, NULL, 0);\newline        destavp != NULL;\newline        destavp = search_next_avp(destavp, NULL))\newline    {\newline        get_avp_val(destavp, &ampdestval);\newline\newline        /* OSP destintaion is wrapped in a string */\newline        dest = (osp_dest*)destval.s.s;\newline\newline        if (dest-&gtused == 0) {\newline            if (dest-&gtsupported == 1) {\newline                LM_DBG(&quotorig dest exist\\n&quot);\newline                result = 0;\newline                break;\newline            } else {\newline                /* Make it looks like used */\newline                dest-&gtused = 1;\newline                /* 111 means wrong protocol */\newline                dest-&gtlastcode = 111;\newline                LM_DBG(&quotdestination does not been supported\\n&quot);\newline            }\newline        } else {\newline            LM_DBG(&quotdestination has already been used\\n&quot);\newline        }\newline    }\newline\newline    if (result == -1) {\newline        LM_DBG(&quotthere is not unused destination\\n&quot);\newline        ospReportOrigSetupUsage();\newline    }\newline\newline    return result;\newline}\newline","\newline Check if there is an unused and supported originate destination from an AVP\newline avpid - osp_origdest_avpid\newline value - osp_dest wrapped in a string\newline search unused (used==0) &amp supported (support==1)\newline return 0 success, -1 failure\newline \newline","3249130","xtreewidget.cpp","void XTreeWidget::sortItems(int column, Qt::SortOrder order)\newline{\newline  int previd = id();\newline\newline  // if old style then maintain backwards compatibility\newline  if (_roles.size() &lt= 0)\newline  {\newline    QTreeWidget::sortItems(column, order);\newline    return;\newline  }\newline\newline  if (column &lt 0 || column &gt= columnCount() ||\newline      headerItem()-&gtdata(column, Qt::UserRole).toString() == &quotxtrunningrole&quot)\newline    return;\newline\newline  header()-&gtsetSortIndicator(column, order);\newline\newline  // simple insertion sort using binary search to find the right insertion pt\newline  QString totalrole(&quottotalrole&quot);\newline  int     itemcount      = topLevelItemCount();\newline  XTreeWidgetItem *prev  = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(0));\newline  for (int i = 1; i &lt itemcount; i++)\newline  {\newline    XTreeWidgetItem *item = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline    if (!item)\newline    {\newline      qWarning(&quotremoving a non-XTreWidgetItem from an XTreeWidget&quot);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (item-&gtdata(0, Qt::UserRole).toString() == totalrole)\newline    {\newline      if (DEBUG)\newline        qDebug(&quotsortItems() removing row %d because it&#039s a totalrole&quot, i);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (*item &lt *prev &amp&amp order == Qt::AscendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (*test &lt *item)\newline        {\newline          if (*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (*item &lt *test || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    else if (*item == *prev)\newline    {\newline      ; // nothing to do - make the &gt case easier to write\newline    }\newline    else if (!(*item &lt *prev) &amp&amp order == Qt::DescendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (!(*test &lt *item))\newline        {\newline          if (!(*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1)))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (!(*item &lt *test) || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    // can&#039t reuse item because the thing in position i may have changed\newline    prev = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline  }\newline\newline  populateCalculatedColumns();\newline\newline  setId(previd);\newline  emit resorted();\newline}\newline","don&#039t need this yet\newlinebool XTreeWidgetItem::operator&gt(const XTreeWidgetItem &ampother) const\newline{\newlinereturn !(this &lt other || this == other);\newline}\newline \newline","5595033","util.h","static inline ssize_t a_strlen(const char *s)\newline{\newline    return s ? strlen(s) : 0;\newline}\newline","\\brief \\c NULL resistant strlen.\newline \newline Unlike it&#039s libc sibling, a_strlen returns a ssize_t, and supports its\newline argument being NULL.\newline \newline \\param[in] s the string.\newline \\return the string length (or 0 if \\c s is \\c NULL).\newline \newline","5071508","draw.c","void DrawTitle(button_info *b,Window win,GC gc, XEvent *pev)\newline{\newline	int BH;\newline	int ix,iy,iw,ih;\newline	FlocaleFont *Ffont=buttonFont(b);\newline	int justify=buttonJustify(b);\newline	int l,i,xpos;\newline	char *s = NULL;\newline	int just=justify&ampb_TitleHoriz; /* Left, center, right */\newline	XGCValues gcv;\newline	XRectangle clip;\newline	Region region = None;\newline	FvwmPicture *pic;\newline	unsigned short bIconFlagSet;\newline\newline	BH = buttonHeight(b);\newline\newline	GetInternalSize(b,&ampix,&ampiy,&ampiw,&ampih);\newline\newline	/* ------------------------------------------------------------------ */\newline\newline	s = buttonTitle(b);\newline\newline	if (!s || !Ffont)\newline		return;\newline\newline	if (Ffont-&gtfont)\newline	{\newline		gcv.font = Ffont-&gtfont-&gtfid;\newline		XChangeGC(Dpy, gc, GCFont, &ampgcv);\newline	}\newline\newline	pic = buttonIcon(b);\newline	bIconFlagSet = iconFlagSet(b);\newline\newline	/* If a title is to be shown, truncate it until it fits */\newline	if(justify&ampb_Horizontal &amp&amp !b-&gtflags.b_Right)\newline	{\newline		if (bIconFlagSet)\newline		{\newline			ix += pic-&gtwidth+buttonXPad(b);\newline			iw -= pic-&gtwidth+buttonXPad(b);\newline		}\newline		else if (b-&gtflags.b_Swallow &amp&amp buttonSwallowCount(b)==3)\newline		{\newline			ix += b-&gticon_w+buttonXPad(b);\newline			iw -= b-&gticon_w+buttonXPad(b);\newline		}\newline	}\newline\newline	l = strlen(s);\newline	i = FlocaleTextWidth(Ffont,s,l);\newline\newline	if(i&gtiw)\newline	{\newline		if(just==2)\newline		{\newline			while(i&gtiw &amp&amp *s)\newline			{\newline				i=FlocaleTextWidth(Ffont,++s,--l);\newline			}\newline		}\newline		else /* Left or center - cut off its tail */\newline		{\newline			while(i&gtiw &amp&amp l&gt0)\newline			{\newline				i=FlocaleTextWidth(Ffont,s,--l);\newline			}\newline		}\newline	}\newline	if(just==0 || ((justify&ampb_Horizontal) &amp&amp b-&gtflags.b_Right)) /* Left */\newline	{\newline		xpos=ix;\newline	}\newline	else if(just==2) /* Right */\newline	{\newline		xpos=max(ix,ix+iw-i);\newline	}\newline	else /* Centered, I guess */\newline	{\newline		xpos=ix+(iw-i)/2;\newline	}\newline\newline	if(*s &amp&amp l&gt0 &amp&amp BH&gt=Ffont-&gtheight) /* Clip it somehow? */\newline	{\newline		FlocaleWinString FwinString;\newline		int cset;\newline\newline		memset(&ampFwinString, 0, sizeof(FwinString));\newline		FwinString.str = s;\newline		FwinString.win = win;\newline		FwinString.gc = gc;\newline		cset = buttonColorset(b);\newline		if (cset &gt= 0)\newline		{\newline			FwinString.colorset = &ampColorset[cset];\newline			FwinString.flags.has_colorset = 1;\newline		}\newline		FwinString.x = xpos;\newline		/* If there is more than the title, put it at the bottom */\newline		/* Unless stack flag is set, put it to the right of icon */\newline		if ((bIconFlagSet ||\newline		    ((buttonSwallowCount(b)==3) &amp&amp b-&gtflags.b_Swallow)) &amp&amp\newline		   !(justify&ampb_Horizontal))\newline		{\newline			FwinString.y = iy+ih-Ffont-&gtdescent;\newline			/* Shrink the space available for icon/window */\newline			ih-=Ffont-&gtheight;\newline		}\newline		/* Or else center vertically */\newline		else\newline		{\newline			FwinString.y =\newline				iy + (ih+ Ffont-&gtascent - Ffont-&gtdescent)/2;\newline		}\newline\newline		clip.x = FwinString.x;\newline		clip.y = FwinString.y - Ffont-&gtascent;\newline		clip.width = i;\newline		clip.height = Ffont-&gtheight;\newline		if (pev)\newline		{\newline			if (!frect_get_intersection(\newline				FwinString.x, FwinString.y - Ffont-&gtascent,\newline				i, Ffont-&gtheight,\newline				pev-&gtxexpose.x, pev-&gtxexpose.y,\newline				pev-&gtxexpose.width, pev-&gtxexpose.height,\newline				&ampclip))\newline			{\newline				return;\newline			}\newline		}\newline		XSetClipRectangles(\newline			Dpy, FwinString.gc, 0, 0, &ampclip, 1, Unsorted);\newline		region = XCreateRegion();\newline		XUnionRectWithRegion (&ampclip, region, region);\newline		FwinString.flags.has_clip_region = True;\newline		FwinString.clip_region = region;\newline		if (0 &amp&amp Ffont-&gtfftf.fftfont != NULL)\newline		{\newline			XClearArea(\newline				Dpy, win,\newline				clip.x, clip.y, clip.width, clip.height,\newline				False);\newline		}\newline		FlocaleDrawString(Dpy, Ffont, &ampFwinString, 0);\newline		XSetClipMask(Dpy, FwinString.gc, None);\newline		if (region)\newline		{\newline			XDestroyRegion(region);\newline		}\newline	}\newline}\newline","\newline Writes out title.\newline \newline","2691568","time.c","static s64 __init init_tsc(struct platform_timesource *pts)\newline{\newline    u64 ret = pts-&gtfrequency;\newline\newline    if ( nr_cpu_ids != num_present_cpus() )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: CPU Hotplug intended\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( nr_sockets &gt 1 &amp&amp !(tsc_flags &amp TSC_RELIABLE_SOCKET) )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: Not invariant across sockets\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( !ret )\newline        printk(XENLOG_DEBUG &quotTSC: Not setting it as clocksource\\n&quot);\newline\newline    return ret;\newline}\newline","\newline Called in verify_tsc_reliability() under reliable TSC conditions\newline thus reusing all the checks already performed there.\newline \newline","4709216","testpalette.c","static SDL_Surface *hflip(SDL_Surface *s)\newline{\newline    int i;\newline    SDL_Surface *z = SDL_CreateRGBSurface(SDL_SWSURFACE, s-&gtw, s-&gth, 8,\newline					  0, 0, 0, 0);\newline    /* copy palette */\newline    SDL_SetColors(z, s-&gtformat-&gtpalette-&gtcolors,\newline		  0, s-&gtformat-&gtpalette-&gtncolors);\newline    if(SDL_LockSurface(s) &lt 0 || SDL_LockSurface(z) &lt 0)\newline	sdlerr(&quotlocking flip images&quot);\newline\newline    for(i = 0; i &lt s-&gth; i++) {\newline	int j;\newline	Uint8 *from = (Uint8 *)s-&gtpixels + i * s-&gtpitch;\newline	Uint8 *to = (Uint8 *)z-&gtpixels + i * z-&gtpitch + s-&gtw - 1;\newline	for(j = 0; j &lt s-&gtw; j++)\newline	    to[-j] = from[j];\newline    }\newline\newline    SDL_UnlockSurface(z);\newline    SDL_UnlockSurface(s);\newline    return z;\newline}\newline","\newline Return a surface flipped horisontally. Only works for 8bpp;\newline extension to arbitrary bitness is left as an exercise for the reader.\newline \newline","1426157","pkt.c","void pkt_delay(pkt_t pkt, time_t t, const char *from) {\newline    char timestamp[21];\newline    int ns, elem;\newline\newline#ifdef ENABLE_SUPERSEDED\newline    datetime_out(t, dt_LEGACY, timestamp, 18);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotx&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0091 delay stamp %s&quot, timestamp);\newline#endif\newline    datetime_out(t, dt_DATETIME, timestamp, 21);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_URN_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotdelay&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0203 delay stamp %s&quot, timestamp);\newline}\newline","add an x:delay stamp \newline","","","","","","","","","","","","","","","","","","","","","","","on","","","","on","on","on","on","","on","","on","","","on","","","","","","This function alsodoubles up as a certificate verify function.","""amount""","Save the volume options to a file,","if the field was not found,or -1 for an error","Copies data from the PI into RDRAM.","(like printf) to stdout/syslog and exit(1)","(used==0) & supported (support==1)","return !(this < other || this == other);","(or 0 if \c s is \c NULL).","Writes out title.","Called in verify_tsc_reliability()","GUI volume change callback","Only works for 8bpp;","x:delay stamp","if not NULL, throws type errors,","( if a buffer already was filled by the device )","Writes each trace from an archive into a separate trace file","start playing","Construct the data structures for obsolete things,","signing function tpm_sign_fn().","free_matrix(vo, nyo)"
"3IVEC1GSLPZEYLQQ6P4XM9PRDPO1JU","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:51 PDT 2019","","","3WQ3B2KGE8GA3MP78ZWHD423L6X1BR","A3G991Y0PG5BIC","Approved","Wed Apr 17 09:54:08 PDT 2019","Wed Apr 17 10:22:08 PDT 2019","Fri Apr 19 10:22:08 PDT 2019","2019-04-19 17:22:21 UTC","","","1680","100% (1/1)","100% (1/1)","100% (1/1)","258116","tls1.c","int finished_digest(SSL *ssl, const char *label, uint8_t *digest)\newline{\newline    uint8_t mac_buf[SHA1_SIZE+MD5_SIZE+15]; \newline    uint8_t *q = mac_buf;\newline    int dgst_len;\newline\newline    if (label)\newline    {\newline        strcpy((char *)q, label);\newline        q += strlen(label);\newline    }\newline\newline    if (ssl-&gtversion &gt= SSL_PROTOCOL_VERSION_TLS1_2) // TLS1.2+\newline    {\newline        SHA256_CTX sha256_ctx = ssl-&gtdc-&gtsha256_ctx; // interim copy\newline        SHA256_Final(q, &ampsha256_ctx);\newline        q += SHA256_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline    else // TLS1.0/1.1\newline    {\newline        MD5_CTX md5_ctx = ssl-&gtdc-&gtmd5_ctx; // interim copy\newline        SHA1_CTX sha1_ctx = ssl-&gtdc-&gtsha1_ctx;\newline\newline        MD5_Final(q, &ampmd5_ctx);\newline        q += MD5_SIZE;\newline        \newline        SHA1_Final(q, &ampsha1_ctx);\newline        q += SHA1_SIZE;\newline        dgst_len = (int)(q-mac_buf);\newline    }\newline\newline    if (label)\newline    {\newline        prf(ssl, ssl-&gtdc-&gtmaster_secret, SSL_SECRET_SIZE, \newline                mac_buf, dgst_len, digest, SSL_FINISHED_HASH_SIZE);\newline    }\newline    else    /* for use in a certificate verify */\newline    {\newline        memcpy(digest, mac_buf, dgst_len);\newline    }\newline\newline#if 0\newline    printf(&quotlabel: %s\\n&quot, label);\newline    print_blob(&quotmac_buf&quot, mac_buf, dgst_len);\newline    print_blob(&quotfinished digest&quot, digest, SSL_FINISHED_HASH_SIZE);\newline#endif\newline\newline    return dgst_len;\newline}   \newline","\newline Calculate the digest used in the finished message. This function also\newline doubles up as a certificate verify function.\newline \newline","3469015","metro.c","static void set_volume_cb(metro_t* metro)\newline{\newline  double* volume = (double*) g_malloc(sizeof(double));\newline\newline  *volume = GTK_ADJUSTMENT(metro-&gtvolume_adjustment)-&gtvalue / 100.0;\newline  comm_client_query(metro-&gtinter_thread_comm, MESSAGE_TYPE_SET_VOLUME,\newline      volume);\newline}\newline","\newline GUI volume change callback\newline \newline","3107006","cvalues.c","int numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname)\newline{\newline    int_t ai, bi;\newline    numerictype_t ta, tb;\newline    void *aptr, *bptr;\newline\newline    if (bothfixnums(a,b)) {\newline        if (a==b) return 0;\newline        if (numval(a) &lt numval(b)) return -1;\newline        return 1;\newline    }\newline    if (!num_to_ptr(a, &ampai, &ampta, &ampaptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, a); else return 2;\newline    }\newline    if (!num_to_ptr(b, &ampbi, &amptb, &ampbptr)) {\newline        if (fname) type_error(fname, &quotnumber&quot, b); else return 2;\newline    }\newline    if (eq &amp&amp eqnans &amp&amp ((ta &gt= T_FLOAT) != (tb &gt= T_FLOAT)))\newline        return 1;\newline    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\newline        return 0;\newline    if (eq) return 1;\newline    if (cmp_lt(aptr, ta, bptr, tb))\newline        return -1;\newline    return 1;\newline}\newline","\newlinereturns -1, 0, or 1 based on ordering of a and b\newlineeq: consider equality only, returning 0 or nonzero\newlineeqnans: NaNs considered equal to each other\newline-0.0 not considered equal to 0.0\newlineinexact not considered equal to exact\newlinefname: if not NULL, throws type errors, else returns 2 for type errors\newline \newline","4996949","vid21394_base.c","int vid21394_wait_buffer( vid21394handle_t vid21394handle, void **buffer )\newline{\newline   int retval = STATUS_SUCCESS;\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtis_receiving )\newline   {\newline      return STATUS_IS_STOPPED;\newline   }\newline	\newline   if( !vid21394handle-&gtready_buffers.next &amp&amp !vid21394handle-&gtdevice_present )\newline   {\newline      return STATUS_NO_DEVICE;\newline   }\newline	\newline   if( vid21394handle-&gtready_buffers.next )\newline   {\newline      unicap_queue_t *first_entry;\newline      // return immediately if a buffer is already in the ready queue\newline      first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline      *buffer = first_entry-&gtdata;\newline      free( first_entry );\newline   }\newline   else\newline   {\newline      if( vid21394handle-&gtqueued_buffers.next )\newline      {\newline	 //block until a buffer got filled by the device\newline	 unicap_queue_t *first_entry;\newline	 struct timeval timeout_time, cur_time;\newline			\newline	 if( gettimeofday( &amptimeout_time, NULL ) &lt 0 )\newline	 {\newline	    return STATUS_FAILURE;\newline	 }\newline			\newline	 timeout_time.tv_sec += 1; // 1 second timeout\newline	 while( !vid21394handle-&gtready_buffers.next )\newline	 {\newline	    // raw1394_loop_iterate is waked regularly by a seperate thread ( every 500ms )\newline	    if( gettimeofday( &ampcur_time, NULL ) &lt 0 )\newline	    {\newline	       return STATUS_FAILURE;\newline	    }\newline				\newline	    if( timercmp( &ampcur_time, &amptimeout_time, &gt ) )\newline	    {	\newline	       return STATUS_TIMEOUT;\newline	    }\newline/*\newline            // dcm: don&#039t enter into loop_iterate since, it can block even if a frame arrives\newline	    raw1394_loop_iterate( vid21394handle-&gtraw1394handle );\newline*/\newline            // 1 millisecond\newline            struct timespec delay = {0, 1000000};\newline	    nanosleep(&ampdelay, NULL);\newline	 }\newline	 first_entry = ucutil_get_front_queue( &ampvid21394handle-&gtready_buffers );\newline	 *buffer = first_entry-&gtdata;\newline			\newline	 free( first_entry );\newline      }\newline      else\newline      {\newline	 // no buffers queued -&gt no buffers to return\newline	 return STATUS_NO_BUFFERS;\newline      }\newline   }\newline	\newline\newline   return retval;\newline}\newline","\newlineWait until one buffer got filled by the device. \newlineMay return immediately ( if a buffer already was filled by the device ) \newlineor block until the buffer got filled.\newline \newline","5832055","litl_split.c","static void __litl_split_extract_traces(const char *dir) {\newline  int trace_out, res __attribute__ ((__unused__));\newline  char* trace_name;\newline  litl_size_t buffer_size;\newline  litl_med_size_t general_header_size, process_header_size;\newline\newline  general_header_size = sizeof(litl_general_header_t);\newline  process_header_size = sizeof(litl_process_header_t);\newline\newline  while (__arch-&gtnb_processes-- != 0) {\newline    // get a process header\newline    __arch-&gtprocess_header = (litl_process_header_t *) __arch-&gtheader_buffer;\newline    __arch-&gtheader_buffer += process_header_size;\newline\newline    res = asprintf(&amptrace_name, &quot%s/%s&quot, dir,\newline                   __arch-&gtprocess_header-&gtprocess_name);\newline\newline    // create and open a new trace file\newline    if ((trace_out = open(trace_name, O_WRONLY | O_CREAT, 0644)) &lt 0) {\newline      fprintf(stderr, &quotCannot create and open %s\\n&quot,\newline              __arch-&gtprocess_header-&gtprocess_name);\newline      exit(EXIT_FAILURE);\newline    }\newline\newline    // write a general trace header\newline    res = write(trace_out, __arch-&gttrace_header, general_header_size);\newline\newline    // write a process header\newline    buffer_size = __arch-&gtprocess_header-&gtoffset;\newline    __arch-&gtprocess_header-&gtoffset = general_header_size + process_header_size;\newline    res = write(trace_out, __arch-&gtprocess_header, process_header_size);\newline\newline    // set a file pointer to the position of the current process\newline    lseek(__arch-&gtf_handle, buffer_size, SEEK_SET);\newline\newline    // read data and write to a separate trace\newline    while (__arch-&gtprocess_header-&gttrace_size) {\newline      buffer_size =\newline          __arch-&gtprocess_header-&gttrace_size &gt __arch-&gtbuffer_size ?\newline            __arch-&gtbuffer_size : __arch-&gtprocess_header-&gttrace_size;\newline\newline      res = read(__arch-&gtf_handle, __arch-&gtbuffer, buffer_size);\newline\newline      res = write(trace_out, __arch-&gtbuffer, buffer_size);\newline\newline      __arch-&gtprocess_header-&gttrace_size -= buffer_size;\newline    }\newline\newline    free(trace_name);\newline    close(trace_out);\newline  }\newline}\newline","\newline Writes each trace from an archive into a separate trace file\newline \newline","5007086","oggread~.c","static void oggread_start(t_oggread *x)\newline{\newline    if(x-&gtx_fd &gt 0)\newline    {\newline		if(ov_time_seek(&ampx-&gtx_ov, 0) &lt 0)\newline		{\newline			post(&quotoggread~: could not rewind file to beginning&quot);\newline		}\newline		post(&quotoggread~: START&quot);\newline		x-&gtx_eos = 0;\newline		x-&gtx_outreadposition = 0;\newline		x-&gtx_outwriteposition = 0;\newline		x-&gtx_outunread = 0;\newline		x-&gtx_position = 0;\newline		clock_delay(x-&gtx_clock, 0);\newline		x-&gtx_stream = 1;\newline    }\newline	else post(&quotoggread~: no file open (ignored)&quot);\newline}\newline","start playing \newline","3370572","qdocdatabase.cpp","NodeMultiMap&amp QDocDatabase::getClassesWithObsoleteMembers()\newline{\newline    if (obsoleteClasses_.isEmpty() &amp&amp obsoleteQmlTypes_.isEmpty())\newline        processForest(&ampQDocDatabase::findAllObsoleteThings);\newline    return classesWithObsoleteMembers_;\newline}\newline","!\newlineConstruct the data structures for obsolete things, if they\newlinehave not already been constructed. Returns a reference to\newlinethe map of C++ classes with obsolete members.\newline \newline","6305983","gnutls_tpm.c","int gtls2_tpm_sign_cb(gnutls_session_t sess, void *_vpninfo,\newline		      gnutls_certificate_type_t cert_type,\newline		      const gnutls_datum_t *cert, const gnutls_datum_t *data,\newline		      gnutls_datum_t *sig)\newline{\newline	struct openconnect_info *vpninfo = _vpninfo;\newline\newline	if (cert_type != GNUTLS_CRT_X509)\newline		return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;\newline\newline	return tpm_sign_fn(NULL, vpninfo, data, sig);\newline}\newline","We want to use gnutls_privkey_import_ext() to create a privkey with our\newlineown signing function tpm_sign_fn(). But GnuTLS 2.12 doesn&#039t support that,\newlineso instead we have to register this sign_callback function with the\newline session \newline","5898142","kmclipm_priv_splines.c","double **bicubicspline_irreg_irreg(\newline        int nxi, double *xi,\newline        int nyi, double *yi,\newline        double **vi,\newline        int nxo, double *xo,\newline        int nyo, double *yo,\newline        enum boundary_mode mode)\newline{\newline    double **vo = matrix(nxo, nyo);\newline    double **v2 = blank_matrix(nxi);\newline    double *vtmp = NULL;\newline    double *vvtmp = NULL;\newline    double y1start = 0.0;  /* not used for bicubicsplines */\newline    double y1end = 0.0;    /* not used for bicubicsplines */\newline    int ix = 0, iy = 0, k = 0;\newline\newline    for (ix=0; ix&ltnxi; ix++) {\newline        v2[ix] = spline_irreg_init(nyi, yi, vi[ix], mode, y1start, y1end);\newline    }\newline\newline    for (ix=0; ix&ltnxo; ix++) {\newline        for (iy=0; iy&ltnyo; iy++) {\newline            vvtmp = vector(nxi);\newline            for (k=0; k&ltnxi; k++) {\newline                vvtmp[k] = spline_irreg_interpolate(nyi, yi, vi[k], v2[k], yo[iy]);\newline            }\newline            vtmp = spline_irreg_init(nxi, xi, vvtmp, mode, y1start, y1end);\newline            vo[ix][iy] = spline_irreg_interpolate(nxi, xi, vvtmp, vtmp, xo[ix]);\newline            free_vector(vtmp);\newline            free_vector(vvtmp);\newline        }\newline    }\newline    free_matrix(v2,nxi);\newline\newline    return vo;\newline}\newline","\newline@brief Bicubic splines interpolation with a irregular arrays as input and output\newline@param nxi number of points along the input x axis\newline@param xi values on the input x axis\newline@param nyi number of points along the input y axis\newline@param yi values on the input y axis\newline@param vi values for the two dimensional input array\newline@param nxo number of points along the output x axis\newline@param xo values on the output x axis\newline@param nyo number of points along the output y axis\newline@param yo values on the output y axis\newline@param mode mode for boundary estimate (NATURAL, ESTIMATED1 or ESTIMATED2)\newline@return vo values for the two dimensional output array\newline@warning The memory for the output array vo is allocated by this function. To free the memory again please use\newlinea call to free_matrix(vo, nyo)\newline \newline","3185402","list.c","static int qdb_list__extendarray(qdbint_t db, long amount)\newline{\newline	long origlen, origalloced;\newline	void *ptr;\newline\newline	origlen = db-&gtarray_len;\newline\newline	db-&gtarray_len += amount;\newline	if (db-&gtarray_len &lt db-&gtarray_alloced)\newline		return 0;\newline\newline	origalloced = db-&gtarray_alloced;\newline\newline	while (db-&gtarray_alloced &lt db-&gtarray_len) {\newline		db-&gtarray_alloced += ML_INCSIZE;\newline	}\newline\newline	if (db-&gtarray == NULL) {\newline		ptr =\newline		    calloc(db-&gtarray_alloced, sizeof(struct mh_record_s));\newline	} else {\newline		ptr = realloc(db-&gtarray,    /* RATS: ignore (OK) */\newline			      db-&gtarray_alloced *\newline			      sizeof(struct mh_record_s));\newline	}\newline\newline	if (ptr == NULL) {\newline		mh_lasterror = strerror(errno);\newline		db-&gtarray_len = origlen;\newline		db-&gtarray_alloced = origalloced;\newline		return 1;\newline	}\newline\newline	db-&gtarray = ptr;\newline\newline	return 0;\newline}\newline","\newline Extend the array by &quotamount&quot items. Returns nonzero on error.\newline \newline","1528436","volinfo.c","int savevolinfo(const struct vol *vol, const char *Cnid_srv, const char *Cnid_port)\newline{\newline    uid_t process_uid;\newline    char buf[16348];\newline    char item[MAXPATHLEN];\newline    int fd;\newline    int ret = 0;\newline    struct flock lock;\newline    const vol_opt_name_t *op = &ampvol_opt_names[0];\newline    const vol_opt_name_t *cf = &ampvol_opt_casefold[0];\newline\newline    strlcpy (item, vol-&gtv_path, sizeof(item));\newline    strlcat (item, &quot/.AppleDesktop/&quot, sizeof(item));\newline    strlcat (item, VOLINFOFILE, sizeof(item));\newline\newline    process_uid = geteuid();\newline    if (process_uid) {\newline        if (seteuid(0) == -1) {\newline            process_uid = 0;\newline        }\newline    }\newline\newline    if ((fd = open(item, O_RDWR | O_CREAT , 0666)) &lt0 ) {\newline        LOG(log_debug, logtype_default,&quotError opening %s: %s&quot, item, strerror(errno));\newline        if (process_uid) {\newline            if (seteuid(process_uid) == -1) {\newline                LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline                exit(EXITERR_SYS);\newline            }\newline        }\newline        return (-1);\newline    }\newline\newline    if (process_uid) {\newline        if (seteuid(process_uid) == -1) {\newline            LOG(log_error, logtype_default, &quotcan&#039t seteuid back %s&quot, strerror(errno));\newline            exit(EXITERR_SYS);\newline        }\newline    }\newline\newline    /* try to get a lock */\newline    lock.l_start  = 0;\newline    lock.l_whence = SEEK_SET;\newline    lock.l_len    = 0;\newline    lock.l_type   = F_WRLCK;\newline\newline    if (fcntl(fd, F_SETLK, &amplock) &lt 0) {\newline        close(fd);\newline        if (errno == EACCES || errno == EAGAIN) {\newline            /* ignore, other process already writing the file */\newline            return 0;\newline        } else {\newline            LOG(log_error, logtype_default, &quotsavevoloptions: cannot get lock: %s&quot, strerror(errno));\newline            return (-1);\newline        }\newline    }\newline\newline    /* write volume options */\newline    snprintf(buf, sizeof(buf), &quotMAC_CHARSET:%s\\n&quot, vol-&gtv_maccodepage);\newline    snprintf(item, sizeof(item), &quotVOL_CHARSET:%s\\n&quot, vol-&gtv_volcodepage);\newline    strlcat(buf, item, sizeof(buf));\newline\newline    switch (vol-&gtv_adouble) {\newline        case AD_VERSION1:\newline            strlcat(buf, &quotADOUBLE_VER:v1\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2:\newline            strlcat(buf, &quotADOUBLE_VER:v2\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION2_OSX:\newline            strlcat(buf, &quotADOUBLE_VER:osx\\n&quot, sizeof(buf));\newline            break;\newline        case AD_VERSION1_SFM:\newline            strlcat(buf, &quotADOUBLE_VER:sfm\\n&quot, sizeof(buf));\newline            break;\newline    }\newline\newline    strlcat(buf, &quotCNIDBACKEND:&quot, sizeof(buf));\newline    strlcat(buf, vol-&gtv_cnidscheme, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDHOST:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_srv, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strlcat(buf, &quotCNIDDBDPORT:&quot, sizeof(buf));\newline    strlcat(buf, Cnid_port, sizeof(buf));\newline    strlcat(buf, &quot\\n&quot, sizeof(buf));\newline\newline    strcpy(item, &quotCNID_DBPATH:&quot);\newline    if (vol-&gtv_dbpath)\newline        strlcat(item, vol-&gtv_dbpath, sizeof(item));\newline    else\newline        strlcat(item, vol-&gtv_path, sizeof(item));\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* volume flags */\newline    strcpy(item, &quotVOLUME_OPTS:&quot);\newline    for (;op-&gtname; op++) {\newline	if ( (vol-&gtv_flags &amp op-&gtoption) ) {\newline            strlcat(item, op-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* casefold flags */\newline    strcpy(item, &quotVOLCASEFOLD:&quot);\newline    for (;cf-&gtname; cf++) {\newline        if ( (vol-&gtv_casefold &amp cf-&gtoption) ) {\newline            strlcat(item, cf-&gtname, sizeof(item));\newline            strlcat(item, &quot &quot, sizeof(item));\newline        }\newline    }\newline    strlcat(item, &quot\\n&quot, sizeof(item));\newline    strlcat(buf, item, sizeof(buf));\newline\newline    /* ExtendedAttributes */\newline    strcpy(item, &quotEXTATTRTYPE:&quot);\newline    switch (vol-&gtv_vfs_ea) {\newline    case AFPVOL_EA_SYS:\newline        strlcat(item, &quotAFPVOL_EA_SYS\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_AD:\newline        strlcat(item, &quotAFPVOL_EA_AD\\n&quot, sizeof(item));\newline        break;\newline    case AFPVOL_EA_NONE:\newline        strlcat(item, &quotAFPVOL_EA_NONE\\n&quot, sizeof(item));\newline        break;\newline    default:\newline        strlcat(item, &quotAFPVOL_EA_UNKNOWN\\n&quot, sizeof(item));\newline    }\newline\newline    strlcat(buf, item, sizeof(buf));\newline\newline    if (strlen(buf) &gt= sizeof(buf)-1)\newline        LOG(log_debug, logtype_default, &quotError writing .volinfo file: buffer too small, %s&quot, buf);\newline   if (write( fd, buf, strlen(buf)) &lt 0 || ftruncate(fd, strlen(buf)) &lt 0 ) {\newline       LOG(log_debug, logtype_default, &quotError writing .volinfo file: %s&quot, strerror(errno));\newline   }\newline\newline   lock.l_type = F_UNLCK;\newline   fcntl(fd, F_SETLK, &amplock);\newline   close (fd);\newline   return ret;\newline}\newline","\newline Save the volume options to a file, used by shell utilities. Writing the file\newline everytime a volume is opened is unnecessary, but it shouldn&#039t hurt much.\newline \newline","2944956","ccd_frame.c","int fits_get_string(struct ccd_frame *fr, char *kwd, char *v, int n)\newline{\newline	char *row;\newline	int i, j;\newline\newline	row = (char *)fits_keyword_lookup(fr, kwd);\newline	if (row == NULL)\newline		return 0;\newline	for (i=9; i &lt FITS_HCOLS; i++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039)\newline			break;\newline	}\newline	if (i++ &gt= FITS_HCOLS)\newline		return -1;\newline//	d3_printf(&quotfirst quote at %d\\n&quot, i);\newline	for (j=0; i &lt FITS_HCOLS &amp&amp j &lt n-1; i++, j++) {\newline		if (row[i] == &#039&quot&#039 || row[i] == &#039\\&#039&#039) {\newline			break;\newline		}\newline		v[j] = row[i];\newline	}\newline//	d3_printf(&quotsecond quote at %d\\n&quot, i);\newline	v[j] = 0;\newline	if (i == FITS_HCOLS)\newline		return -1;\newline	return j;\newline}\newline","get a string field containing at most n characters\newline return the number of chars read, 0 if the field was not found,\newline or -1 for an error \newline","5206131","pi_controller.c","static void dma_pi_write(struct pi_controller *pi)\newline{\newline   uint32_t length, i;\newline   uint32_t dram_address;\newline   uint32_t rom_address;\newline   uint8_t* dram;\newline   const uint8_t* rom;\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &lt 0x10000000 &amp&amp !(pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000))\newline   {\newline      if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x08000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08010000)\newline      {\newline         if (pi-&gtuse_flashram != 1)\newline         {\newline            dma_read_sram(pi);\newline            pi-&gtuse_flashram = -1;\newline         }\newline         else\newline         {\newline            dma_read_flashram(pi);\newline         }\newline      }\newline      else if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x05000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x06000000)\newline      {\newline         //64DD REG/BUFFER\newline         length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline         i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x1FFFFFF;\newline\newline         if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000400)\newline         {\newline            //SECTOR BUFFER\newline            i -= 0x400;\newline            length = (i + length) &gt 0x100 ? (0x100 - i) : length;\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000400) &amp 0x3fffff;\newline            rom = (uint8_t*)g_dd.sec_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x14000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x10000000;\newline         }\newline         else if (pi-&gtregs[PI_CART_ADDR_REG] == 0x05000000)\newline         {\newline            //C2 BUFFER\newline            rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x05000000) &amp 0x3fffff;\newline            length      = (i + length) &gt 0x400 ? (0x400 - i) : length;\newline            rom         = (uint8_t*)g_dd.c2_buf;\newline            //g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x44000000;\newline            g_dd.regs[ASIC_CMD_STATUS] &amp= ~0x40000000;\newline         }\newline         else\newline         {\newline            pi-&gtregs[PI_STATUS_REG] |= 3;\newline            cp0_update_count();\newline            add_interupt_event(PI_INT, length / 8);\newline\newline            return;\newline         }\newline\newline         length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline            (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline         dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline         dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline\newline         for (i = 0; i &lt length; ++i)\newline            dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline         invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline         invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline#if 0\newline         dd_update_bm(&ampg_dd);\newline#endif\newline      }\newline      else\newline      {\newline#if 0\newline         DebugMessage(M64MSG_WARNING, &quotUnknown dma write 0x%&quot PRIX32 &quot in dma_pi_write()&quot, pi-&gtregs[PI_CART_ADDR_REG]);\newline#endif\newline      }\newline\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, /*pi-&gtregs[PI_WR_LEN_REG]*/0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x1fc00000) // for paper mario\newline   {\newline      pi-&gtregs[PI_STATUS_REG] |= 1;\newline      cp0_update_count();\newline      add_interupt_event(PI_INT, 0x1000);\newline\newline      return;\newline   }\newline\newline   if (pi-&gtregs[PI_CART_ADDR_REG] &gt= 0x06000000 &amp&amp pi-&gtregs[PI_CART_ADDR_REG] &lt 0x08000000)\newline   {\newline      /* 64DD IPL */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x1FFFFFF;\newline      length = (i + length) &gt pi-&gtdd_rom.rom_size ?\newline         (pi-&gtdd_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtdd_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x06000000) &amp 0x3fffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtdd_rom.rom;\newline   }\newline   else\newline   {\newline      /* CART ROM */\newline      length = (pi-&gtregs[PI_WR_LEN_REG] &amp 0xFFFFFF) + 1;\newline      i = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3FFFFFF;\newline      length = (i + length) &gt pi-&gtcart_rom.rom_size ?\newline         (pi-&gtcart_rom.rom_size - i) : length;\newline      length = (pi-&gtregs[PI_DRAM_ADDR_REG] + length) &gt 0x7FFFFF ?\newline         (0x7FFFFF - pi-&gtregs[PI_DRAM_ADDR_REG]) : length;\newline\newline      if (i &gt pi-&gtcart_rom.rom_size || pi-&gtregs[PI_DRAM_ADDR_REG] &gt 0x7FFFFF)\newline      {\newline         pi-&gtregs[PI_STATUS_REG] |= 3;\newline         cp0_update_count();\newline         add_interupt_event(PI_INT, length / 8);\newline\newline         return;\newline      }\newline\newline      dram_address = pi-&gtregs[PI_DRAM_ADDR_REG];\newline      rom_address = (pi-&gtregs[PI_CART_ADDR_REG] - 0x10000000) &amp 0x3ffffff;\newline      dram = (uint8_t*)pi-&gtri-&gtrdram.dram;\newline      rom = pi-&gtcart_rom.rom;\newline   }\newline\newline   for (i = 0; i &lt length; ++i)\newline      dram[(dram_address + i) ^ S8] = rom[(rom_address + i) ^ S8];\newline\newline   invalidate_r4300_cached_code(0x80000000 + dram_address, length);\newline   invalidate_r4300_cached_code(0xa0000000 + dram_address, length);\newline\newline   /* HACK: monitor PI DMA to trigger RDRAM size detection\newline    * hack just before initial cart ROM loading. */\newline   if (pi-&gtregs[PI_CART_ADDR_REG] == 0x10001000 || pi-&gtregs[PI_CART_ADDR_REG] == 0x06001000)\newline   {\newline      force_detected_rdram_size_hack();\newline   }\newline   pi-&gtregs[PI_STATUS_REG] |= 3;\newline   cp0_update_count();\newline   add_interupt_event(PI_INT, length / 8);\newline}\newline","Copies data from the PI into RDRAM. \newline","3587173","log.c","void dief(char *format, ...) {\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	if (to_stdout) {\newline		vfprintf(stderr, format, ap);\newline	} else vsyslog(LOG_CONS | LOG_PID | LOG_DAEMON, format, ap);\newline	va_end(ap);\newline\newline	exit(1);\newline}\newline","\newline Print the given message string (like printf) to stdout/syslog and exit(1)\newline \newline \newline","4476940","destination.c","int ospCheckOrigDestination(void)\newline{\newline    struct usr_avp* destavp = NULL;\newline    int_str destval;\newline    osp_dest* dest = NULL;\newline    int result = -1;\newline\newline    for (destavp = search_first_avp(AVP_VAL_STR, _osp_origdest_avpid, NULL, 0);\newline        destavp != NULL;\newline        destavp = search_next_avp(destavp, NULL))\newline    {\newline        get_avp_val(destavp, &ampdestval);\newline\newline        /* OSP destintaion is wrapped in a string */\newline        dest = (osp_dest*)destval.s.s;\newline\newline        if (dest-&gtused == 0) {\newline            if (dest-&gtsupported == 1) {\newline                LM_DBG(&quotorig dest exist\\n&quot);\newline                result = 0;\newline                break;\newline            } else {\newline                /* Make it looks like used */\newline                dest-&gtused = 1;\newline                /* 111 means wrong protocol */\newline                dest-&gtlastcode = 111;\newline                LM_DBG(&quotdestination does not been supported\\n&quot);\newline            }\newline        } else {\newline            LM_DBG(&quotdestination has already been used\\n&quot);\newline        }\newline    }\newline\newline    if (result == -1) {\newline        LM_DBG(&quotthere is not unused destination\\n&quot);\newline        ospReportOrigSetupUsage();\newline    }\newline\newline    return result;\newline}\newline","\newline Check if there is an unused and supported originate destination from an AVP\newline avpid - osp_origdest_avpid\newline value - osp_dest wrapped in a string\newline search unused (used==0) &amp supported (support==1)\newline return 0 success, -1 failure\newline \newline","3249130","xtreewidget.cpp","void XTreeWidget::sortItems(int column, Qt::SortOrder order)\newline{\newline  int previd = id();\newline\newline  // if old style then maintain backwards compatibility\newline  if (_roles.size() &lt= 0)\newline  {\newline    QTreeWidget::sortItems(column, order);\newline    return;\newline  }\newline\newline  if (column &lt 0 || column &gt= columnCount() ||\newline      headerItem()-&gtdata(column, Qt::UserRole).toString() == &quotxtrunningrole&quot)\newline    return;\newline\newline  header()-&gtsetSortIndicator(column, order);\newline\newline  // simple insertion sort using binary search to find the right insertion pt\newline  QString totalrole(&quottotalrole&quot);\newline  int     itemcount      = topLevelItemCount();\newline  XTreeWidgetItem *prev  = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(0));\newline  for (int i = 1; i &lt itemcount; i++)\newline  {\newline    XTreeWidgetItem *item = dynamic_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline    if (!item)\newline    {\newline      qWarning(&quotremoving a non-XTreWidgetItem from an XTreeWidget&quot);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (item-&gtdata(0, Qt::UserRole).toString() == totalrole)\newline    {\newline      if (DEBUG)\newline        qDebug(&quotsortItems() removing row %d because it&#039s a totalrole&quot, i);\newline      takeTopLevelItem(i);\newline      itemcount--;\newline      i--;\newline    }\newline    else if (*item &lt *prev &amp&amp order == Qt::AscendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (*test &lt *item)\newline        {\newline          if (*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (*item &lt *test || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    else if (*item == *prev)\newline    {\newline      ; // nothing to do - make the &gt case easier to write\newline    }\newline    else if (!(*item &lt *prev) &amp&amp order == Qt::DescendingOrder)\newline    {\newline      int left   = 0;\newline      int right  = i;\newline      int middle = 0;\newline      XTreeWidgetItem *test = 0;\newline      while (left &lt= right)\newline      {\newline        middle = (left + right) / 2;\newline        test   = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle));\newline        if (*test == *item)\newline          break;\newline        else if (!(*test &lt *item))\newline        {\newline          if (!(*item &lt *(static_cast&ltXTreeWidgetItem *&gt(topLevelItem(middle + 1)))))\newline            break;\newline          else\newline            left = middle + 1;\newline        }\newline        else\newline          right = middle - 1;\newline      }\newline      // can&#039t call takeTopLevelItem() until after &lt and == are done\newline      if (!(*item &lt *test) || *item == *test)\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&gt= so moving %d to %d&quot, i, middle);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle, item);\newline      }\newline      else\newline      {\newline        if (DEBUG)\newline          qDebug(&quot&lt so moving %d to %d&quot, i, middle + 1);\newline        takeTopLevelItem(i);\newline        insertTopLevelItem(middle + 1, item);\newline      }\newline    }\newline    // can&#039t reuse item because the thing in position i may have changed\newline    prev = static_cast&ltXTreeWidgetItem *&gt(topLevelItem(i));\newline  }\newline\newline  populateCalculatedColumns();\newline\newline  setId(previd);\newline  emit resorted();\newline}\newline","don&#039t need this yet\newlinebool XTreeWidgetItem::operator&gt(const XTreeWidgetItem &ampother) const\newline{\newlinereturn !(this &lt other || this == other);\newline}\newline \newline","5595033","util.h","static inline ssize_t a_strlen(const char *s)\newline{\newline    return s ? strlen(s) : 0;\newline}\newline","\\brief \\c NULL resistant strlen.\newline \newline Unlike it&#039s libc sibling, a_strlen returns a ssize_t, and supports its\newline argument being NULL.\newline \newline \\param[in] s the string.\newline \\return the string length (or 0 if \\c s is \\c NULL).\newline \newline","5071508","draw.c","void DrawTitle(button_info *b,Window win,GC gc, XEvent *pev)\newline{\newline	int BH;\newline	int ix,iy,iw,ih;\newline	FlocaleFont *Ffont=buttonFont(b);\newline	int justify=buttonJustify(b);\newline	int l,i,xpos;\newline	char *s = NULL;\newline	int just=justify&ampb_TitleHoriz; /* Left, center, right */\newline	XGCValues gcv;\newline	XRectangle clip;\newline	Region region = None;\newline	FvwmPicture *pic;\newline	unsigned short bIconFlagSet;\newline\newline	BH = buttonHeight(b);\newline\newline	GetInternalSize(b,&ampix,&ampiy,&ampiw,&ampih);\newline\newline	/* ------------------------------------------------------------------ */\newline\newline	s = buttonTitle(b);\newline\newline	if (!s || !Ffont)\newline		return;\newline\newline	if (Ffont-&gtfont)\newline	{\newline		gcv.font = Ffont-&gtfont-&gtfid;\newline		XChangeGC(Dpy, gc, GCFont, &ampgcv);\newline	}\newline\newline	pic = buttonIcon(b);\newline	bIconFlagSet = iconFlagSet(b);\newline\newline	/* If a title is to be shown, truncate it until it fits */\newline	if(justify&ampb_Horizontal &amp&amp !b-&gtflags.b_Right)\newline	{\newline		if (bIconFlagSet)\newline		{\newline			ix += pic-&gtwidth+buttonXPad(b);\newline			iw -= pic-&gtwidth+buttonXPad(b);\newline		}\newline		else if (b-&gtflags.b_Swallow &amp&amp buttonSwallowCount(b)==3)\newline		{\newline			ix += b-&gticon_w+buttonXPad(b);\newline			iw -= b-&gticon_w+buttonXPad(b);\newline		}\newline	}\newline\newline	l = strlen(s);\newline	i = FlocaleTextWidth(Ffont,s,l);\newline\newline	if(i&gtiw)\newline	{\newline		if(just==2)\newline		{\newline			while(i&gtiw &amp&amp *s)\newline			{\newline				i=FlocaleTextWidth(Ffont,++s,--l);\newline			}\newline		}\newline		else /* Left or center - cut off its tail */\newline		{\newline			while(i&gtiw &amp&amp l&gt0)\newline			{\newline				i=FlocaleTextWidth(Ffont,s,--l);\newline			}\newline		}\newline	}\newline	if(just==0 || ((justify&ampb_Horizontal) &amp&amp b-&gtflags.b_Right)) /* Left */\newline	{\newline		xpos=ix;\newline	}\newline	else if(just==2) /* Right */\newline	{\newline		xpos=max(ix,ix+iw-i);\newline	}\newline	else /* Centered, I guess */\newline	{\newline		xpos=ix+(iw-i)/2;\newline	}\newline\newline	if(*s &amp&amp l&gt0 &amp&amp BH&gt=Ffont-&gtheight) /* Clip it somehow? */\newline	{\newline		FlocaleWinString FwinString;\newline		int cset;\newline\newline		memset(&ampFwinString, 0, sizeof(FwinString));\newline		FwinString.str = s;\newline		FwinString.win = win;\newline		FwinString.gc = gc;\newline		cset = buttonColorset(b);\newline		if (cset &gt= 0)\newline		{\newline			FwinString.colorset = &ampColorset[cset];\newline			FwinString.flags.has_colorset = 1;\newline		}\newline		FwinString.x = xpos;\newline		/* If there is more than the title, put it at the bottom */\newline		/* Unless stack flag is set, put it to the right of icon */\newline		if ((bIconFlagSet ||\newline		    ((buttonSwallowCount(b)==3) &amp&amp b-&gtflags.b_Swallow)) &amp&amp\newline		   !(justify&ampb_Horizontal))\newline		{\newline			FwinString.y = iy+ih-Ffont-&gtdescent;\newline			/* Shrink the space available for icon/window */\newline			ih-=Ffont-&gtheight;\newline		}\newline		/* Or else center vertically */\newline		else\newline		{\newline			FwinString.y =\newline				iy + (ih+ Ffont-&gtascent - Ffont-&gtdescent)/2;\newline		}\newline\newline		clip.x = FwinString.x;\newline		clip.y = FwinString.y - Ffont-&gtascent;\newline		clip.width = i;\newline		clip.height = Ffont-&gtheight;\newline		if (pev)\newline		{\newline			if (!frect_get_intersection(\newline				FwinString.x, FwinString.y - Ffont-&gtascent,\newline				i, Ffont-&gtheight,\newline				pev-&gtxexpose.x, pev-&gtxexpose.y,\newline				pev-&gtxexpose.width, pev-&gtxexpose.height,\newline				&ampclip))\newline			{\newline				return;\newline			}\newline		}\newline		XSetClipRectangles(\newline			Dpy, FwinString.gc, 0, 0, &ampclip, 1, Unsorted);\newline		region = XCreateRegion();\newline		XUnionRectWithRegion (&ampclip, region, region);\newline		FwinString.flags.has_clip_region = True;\newline		FwinString.clip_region = region;\newline		if (0 &amp&amp Ffont-&gtfftf.fftfont != NULL)\newline		{\newline			XClearArea(\newline				Dpy, win,\newline				clip.x, clip.y, clip.width, clip.height,\newline				False);\newline		}\newline		FlocaleDrawString(Dpy, Ffont, &ampFwinString, 0);\newline		XSetClipMask(Dpy, FwinString.gc, None);\newline		if (region)\newline		{\newline			XDestroyRegion(region);\newline		}\newline	}\newline}\newline","\newline Writes out title.\newline \newline","2691568","time.c","static s64 __init init_tsc(struct platform_timesource *pts)\newline{\newline    u64 ret = pts-&gtfrequency;\newline\newline    if ( nr_cpu_ids != num_present_cpus() )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: CPU Hotplug intended\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( nr_sockets &gt 1 &amp&amp !(tsc_flags &amp TSC_RELIABLE_SOCKET) )\newline    {\newline        printk(XENLOG_WARNING &quotTSC: Not invariant across sockets\\n&quot);\newline        ret = 0;\newline    }\newline\newline    if ( !ret )\newline        printk(XENLOG_DEBUG &quotTSC: Not setting it as clocksource\\n&quot);\newline\newline    return ret;\newline}\newline","\newline Called in verify_tsc_reliability() under reliable TSC conditions\newline thus reusing all the checks already performed there.\newline \newline","4709216","testpalette.c","static SDL_Surface *hflip(SDL_Surface *s)\newline{\newline    int i;\newline    SDL_Surface *z = SDL_CreateRGBSurface(SDL_SWSURFACE, s-&gtw, s-&gth, 8,\newline					  0, 0, 0, 0);\newline    /* copy palette */\newline    SDL_SetColors(z, s-&gtformat-&gtpalette-&gtcolors,\newline		  0, s-&gtformat-&gtpalette-&gtncolors);\newline    if(SDL_LockSurface(s) &lt 0 || SDL_LockSurface(z) &lt 0)\newline	sdlerr(&quotlocking flip images&quot);\newline\newline    for(i = 0; i &lt s-&gth; i++) {\newline	int j;\newline	Uint8 *from = (Uint8 *)s-&gtpixels + i * s-&gtpitch;\newline	Uint8 *to = (Uint8 *)z-&gtpixels + i * z-&gtpitch + s-&gtw - 1;\newline	for(j = 0; j &lt s-&gtw; j++)\newline	    to[-j] = from[j];\newline    }\newline\newline    SDL_UnlockSurface(z);\newline    SDL_UnlockSurface(s);\newline    return z;\newline}\newline","\newline Return a surface flipped horisontally. Only works for 8bpp;\newline extension to arbitrary bitness is left as an exercise for the reader.\newline \newline","1426157","pkt.c","void pkt_delay(pkt_t pkt, time_t t, const char *from) {\newline    char timestamp[21];\newline    int ns, elem;\newline\newline#ifdef ENABLE_SUPERSEDED\newline    datetime_out(t, dt_LEGACY, timestamp, 18);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotx&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0091 delay stamp %s&quot, timestamp);\newline#endif\newline    datetime_out(t, dt_DATETIME, timestamp, 21);\newline    ns = nad_add_namespace(pkt-&gtnad, uri_URN_DELAY, NULL);\newline    elem = nad_insert_elem(pkt-&gtnad, 1, ns, &quotdelay&quot, NULL);\newline    nad_set_attr(pkt-&gtnad, elem, -1, &quotstamp&quot, timestamp, 0);\newline    if(from != NULL)\newline        nad_set_attr(pkt-&gtnad, elem, -1, &quotfrom&quot, from, 0);\newline    log_debug(ZONE, &quotadded pkt XEP-0203 delay stamp %s&quot, timestamp);\newline}\newline","add an x:delay stamp \newline","","","on","on","","","","on","on","on","on","","","on","","on","","on","","on","on","","","","","","","","","","","","","","","","","","","on","","","This function alsodoubles up as a certificate verify function.","Extend the array by ""amount"" items. Returns nonzero on error.","{}","{}","Copies data from the PI into RDRAM.","Print the given message string (like printf) to stdout/syslog and exit(1)","Check if there is an unused and supported originate destination","{}","{}","{}","{}","GUI volume change callback","Return a surface flipped horisontally.","{}","if not NULL, throws type errors, else returns 2 for type errors","{}","Writes each trace from an archive into a separate trace file","{}","Returns a reference tothe map of C++ classes with obsolete members.","{}","{}"
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3483FV8BEEJBMVQ8VCFN77QGZD426W","A2MF174E19LY8D","Approved","Wed Apr 17 15:00:41 PDT 2019","Wed Apr 17 15:02:54 PDT 2019","Fri Apr 19 15:02:54 PDT 2019","2019-04-19 22:03:21 UTC","","","133","100% (4/4)","100% (4/4)","100% (4/4)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","","","","","","","","","","","on","on","","","","","","on","","","","","","on","","","","on","","","","","","","","","","","","","","","Create the internal subset of a document.","Create an OFT packet based on the given information,","returns the tag bytes from a file","finds alive client which probably known for server","computes the table","Show notifier test window","Returns the clipboard manager instance.","Checks for all seq's used by the (base) commands","Initialize parent","memory region being zero'd by the kernelon memory allocation.","{}","{}","Find the desired tag on a device.","Walks through the signedpacket_list looking","can be used in CHMM & DHMM","Delete a network address.","Brent's modifications to Pollard's Rho.","{}","unframed open request","an fread without changing the file pointer","press on one of the image's scrollbars."
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3G5F9DBFOPX0GB8RF5Q263CH5QHHVQ","AIYR9PFOUASAR","Rejected","Wed Apr 17 17:41:46 PDT 2019","Wed Apr 17 17:45:28 PDT 2019","Fri Apr 19 17:45:28 PDT 2019","","Thu Apr 18 10:46:45 PDT 2019","This appears to be spam, an unfortunate glitch, or a miscommunication of the goals of the project.","222","0% (0/1)","0% (0/1)","0% (0/1)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","","on","","on","","on","on","on","","on","on","","on","","on","","","on","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}"
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3MMN5BL1WZ42WG7JMS09FDSUVQL3MI","A27AK750Y9M9KH","Approved","Wed Apr 17 12:29:43 PDT 2019","Wed Apr 17 12:40:44 PDT 2019","Fri Apr 19 12:40:44 PDT 2019","2019-04-19 19:41:21 UTC","","","661","100% (5/5)","100% (5/5)","100% (5/5)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","","","","","","","","","","","","on","","","on","","on","on","on","on","on","","","","","","","on","","","","","","on","","","","","","","","","Create the internal subset of a document.","Create an OFT packet","returns the tag bytes from a file","finds alive client","computes the table containing the constant parts of the likelihood function","Show notifier test window","Returns the clipboard manager instance.","Checks for all seq's used by the (base) commands","Initialize parent","Returns a void pointer to the memory region on success,","returns 'TRUE'","{}","Find the desired tag on a device.","Gets a signed packet from a list.","{}","Delete a network address.","{}","{}","{}","{}","{}"
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3OVR4I9USPJEZROFEZC96R45J12Q4L","AOY0S460FQI1T","Approved","Thu Apr 18 13:27:53 PDT 2019","Thu Apr 18 13:39:46 PDT 2019","Sat Apr 20 13:39:46 PDT 2019","2019-04-20 20:40:21 UTC","","","713","100% (1/1)","100% (1/1)","100% (1/1)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","","","","","","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","Create the internal subset of a document.","Create an OFT packet based on the given information,","returns the tag bytes from a file","finds alive client which probably known for server pp","computes the table containing the constant parts of the likelihood function","Show notifier test window","Returns the clipboard manager instance.","Checks for all seq's used by the (base) commands","Initialize parent","Returns a void pointer to the memory region on success, otherwise NULL","'start_blockif' returns 'TRUE' if the line starting at 'tp' marks","ONLY WORKS FOR EVEN %REAL_BITS%","Find the desired tag on a device.","Walks through the signedpacket_list looking for the supplied packet","can be used in CHMM & DHMM","Delete a network address.","Pollard / Brent. Brent's modifications to Pollard's Rho.","{}","should the unframed open request include a file header?","Do an fread without changing the file pointer","button press on one of the image's scrollbars."
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3RANCT1ZVFHQCJG5AN61O670W45UBW","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:39:54 PDT 2019","Wed Apr 17 12:45:31 PDT 2019","Fri Apr 19 12:45:31 PDT 2019","2019-04-19 19:46:21 UTC","","","337","100% (27/27)","100% (27/27)","100% (27/27)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","","","","","","","","","","","on","on","","","on","","on","on","on","","","","","","","","","","","","","","","","","","","","","","","","Create the internal subset of a document.","Create an OFT packet based on the given information,","returns the tag bytes from a file","finds alive client","computes the table","Show notifier test window","Returns the clipboard manager instance.","Checks for all seq's used by the (base) commands","Initialize parent","Returns a void pointer to the memory region","{}","{}","Find the desired tag on a device.","Gets a signed packet from a list.","{}","Delete a network address.","{}","{}","{}","Do an fread without changing the file pointer","button press on one of the image's scrollbars."
"3PUOXASB573MN5YPSOMCP9V0UZP9ZW","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","6","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:46:45 PDT 2019","","","3WMINLGALB3P7FUDIIL5ZP1O7L3CAX","A3FIRNADV3DR7G","Rejected","Wed Apr 17 11:48:17 PDT 2019","Wed Apr 17 11:57:18 PDT 2019","Fri Apr 19 11:57:18 PDT 2019","","Wed Apr 17 13:10:15 PDT 2019","These results appear to be spam, or represent a misunderstanding of the task","541","0% (0/1)","0% (0/1)","0% (0/1)","5179121","xml_node.c","static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\newline{\newline  xmlNodePtr node;\newline  xmlDocPtr doc;\newline  xmlDtdPtr dtd;\newline\newline  Data_Get_Struct(self, xmlNode, node);\newline\newline  doc = node-&gtdoc;\newline\newline  if(xmlGetIntSubset(doc))\newline    rb_raise(rb_eRuntimeError, &quotDocument already has an internal subset&quot);\newline\newline  dtd = xmlCreateIntSubset(\newline      doc,\newline      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\newline      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\newline      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\newline  );\newline\newline  if(!dtd) return Qnil;\newline\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);\newline}\newline","\newline call-seq:\newline create_internal_subset(name, external_id, system_id)\newline \newline Create the internal subset of a document.\newline \newline doc.create_internal_subset(&quotchapter&quot, &quot-//OASIS//DTD DocBook XML//EN&quot, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter PUBLIC &quot-//OASIS//DTD DocBook XML//EN&quot &quotchapter.dtd&quot&gt\newline \newline doc.create_internal_subset(&quotchapter&quot, nil, &quotchapter.dtd&quot)\newline # =&gt &lt!DOCTYPE chapter SYSTEM &quotchapter.dtd&quot&gt\newline \newline","1085639","pns.c","real_t fp_sqrt(real_t value)\newline{\newline    real_t root = 0;\newline\newline    step( 0); step( 2); step( 4); step( 6);\newline    step( 8); step(10); step(12); step(14);\newline    step(16); step(18); step(20); step(22);\newline    step(24); step(26); step(28); step(30);\newline\newline    if (root &lt value)\newline        ++root;\newline\newline    root &lt&lt= (REAL_BITS/2);\newline\newline    return root;\newline}\newline","!!!! ONLY WORKS FOR EVEN %REAL_BITS% !!!! \newline","2090033","hmm1d.cpp","CvStatus icvUniform1DSegm( Cv1DObsInfo* obs_info, CvEHMM* hmm )\newline{\newline    /* implementation is very bad */\newline    int  i;\newline    CvEHMMState* first_state;\newline\newline    /* check arguments */\newline    if ( !obs_info || !hmm ) return CV_NULLPTR_ERR;\newline\newline    first_state = hmm-&gtu.state;\newline\newline    for (i = 0; i &lt obs_info-&gtobs_x; i++)\newline    {\newline        //bad line (division )\newline        int state = (i * hmm-&gtnum_states)/obs_info-&gtobs_x;\newline        obs_info-&gtstate[i] = state;\newline    }\newline    return CV_NO_ERR;\newline}\newline","can be used in CHMM &amp DHMM \newline","5172979","unixlib.c","int lwip_del_addr(struct netif *netif,struct ip_addr *ipaddr, struct ip_addr *netmask)\newline{\newline	return netif_del_addr(netif,ipaddr,netmask);\newline}\newline","\newline Delete a network address.\newline \newline @param netif a pre-allocated netif structure\newline @param ipaddr IP address for the new netif\newline @param netmask network mask for the new netif\newline \newline @return 0 on success, &lt 0 on failure.\newline \newline","6670142","factor.c","int pbrent_factor(UV n, UV *factors, UV rounds, UV a)\newline{\newline  UV f, m, r, Xi, Xm;\newline  const UV inner = (n &lt= 4000000000UL) ? 32 : 160;\newline  int fails = 6;\newline  const uint64_t npi = mont_inverse(n),  mont1 = mont_get1(n);\newline  Xi = Xm = mont_get2(n);\newline  a = mont_geta(a,n);\newline  MPUassert( (n &gt= 3) &amp&amp ((n%2) != 0) , &quotbad n in pbrent_factor&quot);\newline\newline  r = 1;\newline  f = 1;\newline  while (rounds &gt 0) {\newline    UV rleft = (r &gt rounds) ? rounds : r;\newline    UV saveXi = Xi;\newline    /* Do rleft rounds, inner at a time */\newline    while (rleft &gt 0) {\newline      UV dorounds = (rleft &gt inner) ? inner : rleft;\newline      saveXi = Xi;\newline      rleft -= dorounds;\newline      rounds -= dorounds;\newline      Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline      m = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline      while (--dorounds &gt 0) {         /* Now do inner-1=63 more iterations */\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = (Xi&gtXm) ? Xi-Xm : Xm-Xi;\newline        m = mont_mulmod(m, f, n);\newline      }\newline      f = gcd_ui(m, n);\newline      if (f != 1)\newline        break;\newline    }\newline    /* If f == 1, then we didn&#039t find a factor.  Move on. */\newline    if (f == 1) {\newline      r *= 2;\newline      Xm = Xi;\newline      continue;\newline    }\newline    if (f == n) {  /* back up, with safety */\newline      Xi = saveXi;\newline      do {\newline        Xi = mont_sqrmod(Xi,n);  Xi = addmod(Xi,a,n);\newline        f = gcd_ui( (Xi&gtXm) ? Xi-Xm : Xm-Xi, n);\newline      } while (f == 1 &amp&amp r-- != 0);\newline    }\newline    if (f == 0 || f == n) {\newline      if (fails-- &lt= 0) break;\newline      Xm = addmod(Xm, 2, n);\newline      Xi = Xm;\newline      a++;\newline      continue;\newline    }\newline    return found_factor(n, f, factors);\newline  }\newline  factors[0] = n;\newline  return 1;\newline}\newline","Pollard / Brent. Brent&#039s modifications to Pollard&#039s Rho. Maybe faster. \newline","4515115","wap_push_ppg.c","static void push_machine_destroy(void *p)\newline{\newline    PPGPushMachine *pm;\newline\newline    if (p == NULL)\newline        return;\newline\newline    pm = p;\newline\newline    debug(&quotwap.push.ppg&quot, 0, &quotPPG: destroying push machine %ld&quot, \newline          pm-&gtpush_id); \newline    #define OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define OPTIONAL_OCTSTR(name) octstr_destroy(pm-&gtname);\newline    #define INTEGER(name)\newline    #define ADDRTUPLE(name) wap_addr_tuple_destroy(pm-&gtname);\newline    #define CAPABILITIES(name) wap_cap_destroy_list(pm-&gtname);\newline    #define HTTPHEADER(name) http_destroy_headers(pm-&gtname);\newline    #define MACHINE(fields) fields\newline    #include &quotwap_ppg_push_machine.def&quot\newline\newline    gw_free(p);\newline}\newline","\newline Contrary to the normal Kannel style, we do not remove from a list here. \newline That is because we now have two different push lists.\newline \newline","6512779","swi-update.c","static inline size_t hdrlen(__u8 type)\newline{\newline    switch (type) {\newline    case QDL_IMAGE_CWE:\newline        return 400;\newline    default:\newline        return 0;\newline    }\newline}\newline","should the unframed open request include a file header? \newline","2668573","big.c","size_t fread_peek_big(void *ptr, size_t size, size_t num, FILE *stream)\newline{\newline  long curr_pos;\newline  curr_pos = ftell(stream);\newline  fread_big(ptr, size, num, stream);\newline  fseek(stream, curr_pos, SEEK_SET);\newline}\newline","Do an fread without changing the file pointer \newline","5257566","main.c","gint viewer_sb_button_press(GtkWidget *widget,GdkEventButton *event)\newline{\newline/* doesn&#039t have to do anything */\newlinereturn(TRUE);\newline}\newline","button press on one of the image&#039s scrollbars. Needed to override\newline the above, as bringing up the menu by right-clicking on a scrollbar\newline causes all mouse stuff to hang for some reason...!\newline \newline","5964355","ft.c","faim_export int aim_oft_sendheader(aim_session_t *sess, fu16_t type, struct aim_oft_info *oft_info)\newline{\newline	aim_frame_t *fr;\newline\newline	if (!sess || !oft_info || !oft_info-&gtconn || (oft_info-&gtconn-&gttype != AIM_CONN_TYPE_RENDEZVOUS))\newline		return -EINVAL;\newline\newline#if 0\newline	/*\newline	 * If you are receiving a file, the cookie should be null, if you are sending a \newline	 * file, the cookie should be the same as the one used in the ICBM negotiation \newline	 * SNACs.\newline	 */\newline	fh-&gtlnameoffset = 0x1a;\newline	fh-&gtlsizeoffset = 0x10;\newline\newline	/* These should be the same as charset and charsubset in ICBMs */\newline	fh-&gtnencode = 0x0000;\newline	fh-&gtnlanguage = 0x0000;\newline#endif\newline\newline	aim_oft_dirconvert_tostupid(oft_info-&gtfh.name);\newline\newline	if (!(fr = aim_tx_new(sess, oft_info-&gtconn, AIM_FRAMETYPE_OFT, type, 0)))\newline		return -ENOMEM;\newline\newline	if (aim_oft_buildheader(&ampfr-&gtdata, &ampoft_info-&gtfh) == -1) {\newline		aim_frame_destroy(fr);\newline		return -ENOMEM;\newline	}\newline\newline	memcpy(fr-&gthdr.rend.magic, &quotOFT2&quot, 4);\newline	fr-&gthdr.rend.hdrlen = aim_bstream_curpos(&ampfr-&gtdata) + 8;\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline","\newline Create an OFT packet based on the given information, and send it on its merry way.\newline \newline @param sess The session.\newline @param type The subtype of the OFT packet we&#039re sending.\newline @param oft_info The aim_oft_info struct with the connection and OFT \newline info we&#039re sending.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","5412119","mp3.c","static tag_bytes_and_size *splt_mp3_get_id3_tag_bytes(splt_state *state, const char *filename, \newline    int *error)\newline{\newline  id3_length_t length = 0;\newline  int tags_version = 0;\newline  id3_byte_t *bytes = NULL;\newline  tag_bytes_and_size *bytes_and_size = NULL;\newline\newline  FILE *file = splt_io_fopen(filename, &quotrb&quot);\newline  if (!file)\newline  {\newline    splt_e_set_strerror_msg_with_data(state, filename);\newline    *error = SPLT_ERROR_CANNOT_OPEN_FILE;\newline    goto end;\newline  }\newline\newline  bytes_and_size = splt_mp3_new_bytes_and_size();\newline  if (bytes_and_size == NULL)\newline  {\newline    *error = SPLT_ERROR_CANNOT_ALLOCATE_MEMORY;\newline    goto end;\newline  }\newline\newline  id3_length_t id3v1_length = 0;\newline  id3_byte_t *id3v1_bytes = splt_mp3_get_id3v1_tag_bytes(file, &ampid3v1_length);\newline\newline  id3_length_t id3v2_length = 0;\newline  id3_byte_t *id3v2_bytes = splt_mp3_get_id3v2_tag_bytes(file, &ampid3v2_length);\newline\newline  if (id3v2_bytes)\newline  {\newline    bytes = id3v2_bytes;\newline    length = id3v2_length;\newline    tags_version = 2;\newline\newline    if (id3v1_bytes)\newline    {\newline      bytes_and_size-&gttag_bytes_v1 = id3v1_bytes;\newline      bytes_and_size-&gttag_length_v1 = id3v1_length;\newline      tags_version = 12;\newline    }\newline  }\newline  else if (id3v1_bytes)\newline  {\newline    bytes = id3v1_bytes;\newline    length = id3v1_length;\newline    tags_version = 1;\newline  }\newline\newline  bytes_and_size-&gttag_bytes = bytes;\newline  bytes_and_size-&gttag_length = length;\newline  bytes_and_size-&gtversion = tags_version;\newline\newline  if (tags_version == 12)\newline  {\newline    bytes_and_size-&gtbytes_tags_version = 2;\newline  }\newline  else\newline  {\newline    bytes_and_size-&gtbytes_tags_version = tags_version;\newline  }\newline\newlineend:\newline  if (file)\newline  {\newline    fclose(file);\newline  }\newline\newline  return bytes_and_size;\newline}\newline","! returns the tag bytes from a file\newline\\param filename the name of the file to search for tags\newline\\param state The central structure libmp3splt keeps all of its data in\newline\\param error Contains the error number if an error has occoured\newline\\param Is filled with the length of the id3 structure\newline\\param tags_version Is filled with the version of the tag by this function.\newline\\return The string containing the tags\newline \newline","6420205","ircd.c","CLIENT *ircd_find_client (const char *name, peer_priv *via)\newline{\newline  register CLIENT *c;\newline\newline  if (!name)\newline    return &ampME;\newline  c = _ircd_find_client (name);\newline  if (c == NULL || (c-&gthold_upto == 0)) {\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p&quot, name, c);\newline    return (c);\newline  } else\newline    dprint(5, &quotircd:ircd.c:ircd_find_client: %s: %p (phantom)&quot, name, c);\newline  if (via == NULL)\newline    return (NULL);\newline  c = _ircd_find_phantom(c, via);\newline  while (c != NULL &amp&amp c-&gthold_upto != 0)\newline    c = c-&gtx.rto;\newline  return (c);\newline}\newline","finds alive client which probably known for server pp \newline","1194503","derivatives.c","PLL_EXPORT int pll_update_sumtable(pll_partition_t * partition,\newline                                      unsigned int parent_clv_index,\newline                                      unsigned int child_clv_index,\newline                                      int parent_scaler_index,\newline                                      int child_scaler_index,\newline                                      const unsigned int * params_indices,\newline                                      double *sumtable)\newline{\newline  int retval;\newline\newline  unsigned int * parent_scaler;\newline  unsigned int * child_scaler;\newline\newline  /* get parent scaler */\newline  if (parent_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    parent_scaler = NULL;\newline  else\newline    parent_scaler = partition-&gtscale_buffer[parent_scaler_index];\newline\newline  if (child_scaler_index == PLL_SCALE_BUFFER_NONE)\newline    child_scaler = NULL;\newline  else\newline    child_scaler = partition-&gtscale_buffer[child_scaler_index];\newline\newline\newline  if (partition-&gtattributes &amp PLL_ATTRIB_PATTERN_TIP)\newline  {\newline    if ((parent_clv_index &lt partition-&gttips) &amp&amp\newline        (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-tip case */\newline      assert(0);\newline    }\newline    else if ((parent_clv_index &lt partition-&gttips) ||\newline             (child_clv_index &lt partition-&gttips))\newline    {\newline      /* tip-inner */\newline      retval = sumtable_tipinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline    }\newline    else\newline    {\newline      /* inner-inner */\newline      retval = sumtable_innerinner(partition,\newline                                   parent_clv_index,\newline                                   child_clv_index,\newline                                   parent_scaler,\newline                                   child_scaler,\newline                                   params_indices,\newline                                   sumtable);\newline    }\newline  }\newline  else\newline  {\newline    /* inner-inner */\newline    retval = sumtable_innerinner(partition,\newline                                 parent_clv_index,\newline                                 child_clv_index,\newline                                 parent_scaler,\newline                                 child_scaler,\newline                                 params_indices,\newline                                 sumtable);\newline  }\newline\newline  return retval;\newline}\newline","computes the table containing the constant parts of the likelihood function\newline partial derivatives on the branch lengths.\newline sumtable: [output] must be allocated for storing (rates x states_padded) values \newline","4961915","optionsdialog.cpp","void OptionsDialog::showNotification()\newline{\newline  if (notificationWidget_) delete notificationWidget_;\newline  QList&ltint&gt idFeedList;\newline  QList&ltint&gt cntNewNewsList;\newline  QList&ltint&gt idColorList;\newline  QStringList colorList;\newline  notificationWidget_ = new NotificationWidget(idFeedList, cntNewNewsList,\newline                                               idColorList, colorList,\newline                                               this, this);\newline\newline  connect(notificationWidget_, SIGNAL(signalClose()),\newline          this, SLOT(deleteNotification()));\newline\newline  notificationWidget_-&gtshow();\newline}\newline","@brief Show notifier test window\newline ---------------------------------------------------------------------------- \newline","3979582","clipboardmanager.cpp","ClipboardManager *ClipboardManager::instance()\newline{\newline    if (!mInstance)\newline        mInstance = new ClipboardManager;\newline    return mInstance;\newline}\newline","\newline Returns the clipboard manager instance. Creates the instance when it\newline doesn&#039t exist yet.\newline \newline","6369201","dinkvar.c","void check_sprite_status_full(int sprite_no)\newline{\newline  //is sprite in memory?\newline  check_seq_status(spr[sprite_no].pseq);\newline\newline  if (spr[sprite_no].base_walk &gt -1)\newline    check_base(spr[sprite_no].base_walk);\newline}\newline","\newline Checks for all seq&#039s used by the (base) commands\newline \newline","4475936","reg_mod.c","static int mod_init(void)\newline{\newline	pv_spec_t avp_spec;\newline	str s;\newline	bind_usrloc_t bind_usrloc;\newline\newline	LM_INFO(&quotinitializing...\\n&quot);\newline\newline	/* load SIGNALING API */\newline	if(load_sig_api(&ampsigb)&lt 0) {\newline		LM_ERR(&quotcan&#039t load signaling functions\\n&quot);\newline		return -1;\newline	}\newline\newline	/* load TM API */\newline	memset(&amptmb, 0, sizeof(struct tm_binds));\newline	load_tm_api(&amptmb);\newline\newline	realm_prefix.s = realm_pref;\newline	realm_prefix.len = strlen(realm_pref);\newline\newline	rcv_param.len = strlen(rcv_param.s);\newline\newline	if (rcv_avp_param &amp&amp *rcv_avp_param) {\newline		s.s = rcv_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &amprcv_avp_name, &amprcv_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, rcv_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		rcv_avp_name = -1;\newline		rcv_avp_type = 0;\newline	}\newline\newline	if (mct_avp_param &amp&amp *mct_avp_param) {\newline		s.s = mct_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampmct_avp_name, &ampmct_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, mct_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		mct_avp_name = -1;\newline		mct_avp_type = 0;\newline	}\newline\newline	if (attr_avp_param &amp&amp *attr_avp_param) {\newline		s.s = attr_avp_param; s.len = strlen(s.s);\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0\newline				|| avp_spec.type!=PVT_AVP) {\newline			LM_ERR(&quotmalformed or non AVP %s AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline\newline		if(pv_get_avp_name(0, &ampavp_spec.pvp, &ampattr_avp_name, &ampattr_avp_type)!=0)\newline		{\newline			LM_ERR(&quot[%s]- invalid AVP definition\\n&quot, attr_avp_param);\newline			return -1;\newline		}\newline	} else {\newline		attr_avp_name = -1;\newline		attr_avp_type = 0;\newline	}\newline\newline	bind_usrloc = (bind_usrloc_t)find_export(&quotul_bind_usrloc&quot, 1, 0);\newline	if (!bind_usrloc) {\newline		LM_ERR(&quotcan&#039t bind usrloc\\n&quot);\newline		return -1;\newline	}\newline\newline	/* Normalize default_q parameter */\newline	if (default_q != Q_UNSPECIFIED) {\newline		if (default_q &gt MAX_Q) {\newline			LM_DBG(&quotdefault_q = %d, lowering to MAX_Q: %d\\n&quot, default_q, MAX_Q);\newline			default_q = MAX_Q;\newline		} else if (default_q &lt MIN_Q) {\newline			LM_DBG(&quotdefault_q = %d, raising to MIN_Q: %d\\n&quot, default_q, MIN_Q);\newline			default_q = MIN_Q;\newline		}\newline	}\newline\newline\newline	if (bind_usrloc(&ampul) &lt 0) {\newline		return -1;\newline	}\newline\newline	/*\newline	 * Import use_domain parameter from usrloc\newline	 */\newline	reg_use_domain = ul.use_domain;\newline\newline	if (sock_hdr_name.s)\newline		sock_hdr_name.len = strlen(sock_hdr_name.s);\newline\newline	if (gruu_secret.s)\newline		gruu_secret.len = strlen(gruu_secret.s);\newline\newline	/* fix the flags */\newline	fix_flag_name(tcp_persistent_flag_s, tcp_persistent_flag);\newline	tcp_persistent_flag = get_flag_id_by_name(FLAG_TYPE_MSG, tcp_persistent_flag_s);\newline	tcp_persistent_flag = (tcp_persistent_flag!=-1)?(1&lt&lttcp_persistent_flag):0;\newline\newline	return 0;\newline}\newline","! \\brief\newline Initialize parent\newline \newline","4153518","eurephia_nullsafe.c","__malloc__ void *_malloc_nullsafe(eurephiaCTX *ctx, size_t sz, const char *file, int line) {\newline        void *buf = NULL;\newline\newline        buf = calloc(1, sz);    /* Using calloc, also gives a zero&#039d memory region */\newline        if( !buf ) {\newline                if( ctx ) {\newline                        eurephia_log(ctx, LOG_FATAL, 40,\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline                                     sz, file, line);\newline                } else {\newline                        fprintf(stderr, &quot** FATAL ERROR ** &quot\newline                                     &quotCould not allocate memory region for %ld bytes (File %s, line %i)&quot,\newline				(unsigned long int) sz, file, line);\newline                }\newline        }\newline#ifdef DEBUG\newline        else {\newline                // Don&#039t use DEBUG macro, to catch the right file and line number for the log\newline                _eurephia_log_func(ctx, LOG_DEBUG, 40, file, line,\newline                                   &quotAllocated %ld bytes of memory on address %p&quot,\newline                                   sz, buf);\newline        }\newline#endif\newline        return buf;\newline}\newline","\newline Internal function, should be called via the malloc_nullsafe() macro.\newline This replaces the use of malloc() and memset(). This function uses calloc\newline internally, which results in the memory region being zero&#039d by the kernel\newline on memory allocation.\newline \newline @param ctx eurephiaCTX, used for logging\newline @param sz size of the memory region being allocated\newline @param file debug info, which file is doing this call\newline @param line debug info, which line in the file\newline \newline @return Returns a void pointer to the memory region on success, otherwise NULL\newline \newline","5108107","mainstate.c","static boolean start_blockif(byte *tp) {\newline  while (*tp != NUL) {\newline    if (*tp == TOKEN_THEN &amp&amp *(tp+1) == NUL) return TRUE;\newline    tp = skip_token(tp);\newline  }\newline  return FALSE;\newline}\newline","\newline &#039start_blockif&#039 returns &#039TRUE&#039 if the line starting at &#039tp&#039 marks the\newline start of a block &#039IF&#039 statement\newline \newline","1254518","tag.c","blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)\newline{\newline	struct list_head *p;\newline\newline	if (!dev || !type)\newline		return NULL;\newline\newline	list_for_each(p, &ampdev-&gtbid_tags) {\newline		blkid_tag tmp = list_entry(p, struct blkid_struct_tag,\newline					   bit_tags);\newline\newline		if (!strcmp(tmp-&gtbit_name, type))\newline			return tmp;\newline	}\newline	return NULL;\newline}\newline","\newline Find the desired tag on a device. If value is NULL, then the\newline first such tag is returned, otherwise return only exact tag if found.\newline \newline","1195009","merge.c","struct openpgp_signedpacket_list *find_signed_packet(\newline		struct openpgp_signedpacket_list *packet_list,\newline		struct openpgp_packet *packet)\newline{\newline	struct openpgp_signedpacket_list *found = NULL;\newline\newline	while (found == NULL &amp&amp packet_list != NULL) {\newline		if (compare_packets(packet_list-&gtpacket, packet) == 0) {\newline			found = packet_list;\newline		}\newline		packet_list = packet_list -&gt next;\newline	}\newline\newline	return found;\newline}\newline","\newline get_signed_packet - Gets a signed packet from a list.\newline @packet_list: The list of packets to look in.\newline @packet: The packet to look for.\newline \newline Walks through the signedpacket_list looking for the supplied packet and\newline returns it if found. Otherwise returns NULL.\newline \newline","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","on","","","on","on","","","","","","","","","","","","on","","","","","","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}","{}"
"3QXFBUZ4ZKGKGGRN07TE0Y28WU4UGI","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3A9AA95ATWMBVYR0SRGUBEK9ERY5PH","AP9WIQ4P78XLH","Approved","Wed Apr 17 10:50:56 PDT 2019","Wed Apr 17 11:00:07 PDT 2019","Fri Apr 19 11:00:07 PDT 2019","2019-04-19 18:00:21 UTC","","","551","100% (1/1)","100% (1/1)","100% (1/1)","1526179","vbcontrast.cpp","void VBContrastParamScalingWidget::WriteContrastInfo( string stemname )\newline{\newline  ofstream output;\newline  \newline//  output.open((stemname + &quot.contrasts&quot).c_str());\newline  int pos = stemname.rfind(&quot/&quot);\newline  stemname = stemname.substr(0, ++pos);\newline  output.open((stemname + &quotcontrasts.txt&quot).c_str());\newline  if (output.good())\newline  {\newline    VBContrast* contrast;\newline    Q3ListViewItemIterator iter(mContrastList);\newline    while (iter.current())\newline    {\newline      contrast = mContrastList-&gtcontrastAt(*iter);\newline      output &lt&lt contrast-&gtname &lt&lt &quot &quot\newline             &lt&lt contrast-&gtscale &lt&lt &quot vec &quot;\newline      \newline      for (uint32 i=0; i&ltcontrast-&gtcontrast.size(); ++i)\newline        // only write out covariates of interest...\newline        if (mGLMInfo-&gtcnames[i][0] == &#039I&#039) output &lt&lt contrast-&gtcontrast[i] &lt&lt &quot &quot;\newline      \newline      output &lt&lt endl;\newline      ++iter;\newline    }\newline  }\newline}\newline","\newline WriteContrastInfo writes information in the widget out to a contrast.txt file\newline in the glm directory.\newline \newline","4366568","test_packet_vlen.c","static int test_H5PTis_varlen(void)\newline{\newline    hid_t   fid=H5I_INVALID_HID;	/* Test file identifier */\newline    hid_t   ptable=H5I_INVALID_HID;	/* Packet table identifier */\newline    herr_t  ret;		/* Returned status from a callee */\newline\newline    TESTING(&quotH5PTis_varlen&quot);\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Create a new table */\newline    ptable = H5PTcreate(fid, PT_FIXED_LEN, H5T_STD_I32BE, (hsize_t)100, H5P_DEFAULT);\newline\newline    /* Ensure that PT is created successfully */\newline    if (ptable == H5I_INVALID_HID)\newline	goto error;\newline\newline    /* Close the packet table */\newline    ret = H5PTclose(ptable);\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Open each packet table, and verify that H5PTis_varlen returns correct\newline       type for each table */\newline    ret = verify_ptlengthtype(fid, PT_VLEN_ATOMIC, 1); /* vlen of atomic */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_COMP, 1); /* vlen of compound */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_COMP_VLEN, 0); /* compound of vlen, no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_VLEN, 1); /* vlen of vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_FIXED_LEN, 0); /* no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    PASSED();\newline    return SUCCEED;\newline\newlineerror: /* An error has occurred.  Clean up and exit. */\newline    if (fid &gt 0) H5Fclose(fid);\newline    H5_FAILED();\newline    return FAIL;\newline} /* test_H5PTis_varlen */\newline","-------------------------------------------------------------------------\newline test_H5PTis_varlen(): Test that H5PTis_varlen works correctly on both\newline fixed- and variable-length packet tables.\newline \newline Description:\newline - Added a fixed-length packet table to the file for variety\newline - Use the helper funtion verify_ptlengthtype to test H5PTis_varlen\newline on each packet table.\newline \newline 2016/01/27 -BMR\newline -------------------------------------------------------------------------\newline \newline","4396668","yp.c","void yp_touch (const char *mount)\newline{\newline    struct yp_server *server = (struct yp_server *)active_yps;\newline    ypdata_t *search_list = NULL;\newline\newline    thread_rwlock_rlock (&ampyp_lock);\newline    if (server)\newline        search_list = server-&gtmounts;\newline\newline    while (server)\newline    {\newline        ypdata_t *yp = find_yp_mount (search_list, mount);\newline        if (yp)\newline        {\newline            /* we may of found old entries not purged yet, so skip them */\newline            if (yp-&gtrelease != 0 || yp-&gtremove != 0)\newline            {\newline                search_list = yp-&gtnext;\newline                continue;\newline            }\newline            /* don&#039t update the directory if there is a touch scheduled soon */\newline            if (yp-&gtprocess == do_yp_touch &amp&amp now + yp-&gttouch_interval - yp-&gtnext_update &gt 60)\newline                yp-&gtnext_update = now + 3;\newline        }\newline        server = server-&gtnext;\newline        if (server)\newline            search_list = server-&gtmounts;\newline    }\newline    thread_rwlock_unlock (&ampyp_lock);\newline}\newline","This is similar to yp_remove, but we force a touch\newline attempt \newline","1679443","drv_dpf.c","static void drv_set_pixel(int x, int y, RGBA pix)\newline{\newline    int changed = 0;\newline\newline    int sx = DCOLS;\newline    int sy = DROWS;\newline    int lx = x % sx;\newline    int ly = y % sy;\newline\newline    if (dpf.flip) {\newline	// upside down orientation\newline	lx = DCOLS - 1 - lx;\newline	ly = DROWS - 1 - ly;\newline    }\newline\newline    if (dpf.rotate90) {\newline	// wrong Orientation, rotate\newline	int i = ly;\newline	ly = dpf.pheight - 1 - lx;\newline	lx = i;\newline    }\newline\newline    if (lx &lt 0 || lx &gt= (int) dpf.pwidth || ly &lt 0 || ly &gt= (int) dpf.pheight) {\newline	error(&quotdpf: x/y out of bounds (x=%d, y=%d, rot=%d, flip=%d, lx=%d, ly=%d)\\n&quot, x, y, dpf.rotate90, dpf.flip, lx,\newline	      ly);\newline	return;\newline    }\newline\newline    unsigned char c1 = _RGB565_0(pix);\newline    unsigned char c2 = _RGB565_1(pix);\newline    unsigned int i = (ly * dpf.pwidth + lx) * DPF_BPP;\newline    if (dpf.lcdBuf[i] != c1 || dpf.lcdBuf[i + 1] != c2) {\newline	dpf.lcdBuf[i] = c1;\newline	dpf.lcdBuf[i + 1] = c2;\newline	changed = 1;\newline    }\newline\newline    if (changed) {\newline	if (lx &lt dpf.minx)\newline	    dpf.minx = lx;\newline	if (lx &gt dpf.maxx)\newline	    dpf.maxx = lx;\newline	if (ly &lt dpf.miny)\newline	    dpf.miny = ly;\newline	if (ly &gt dpf.maxy)\newline	    dpf.maxy = ly;\newline    }\newline}\newline","\newline Set one pixel in lcdBuf.\newline \newline Respects orientation and updates dirty rectangle.\newline \newline in: x, y - pixel coordinates\newline pix - RGBA pixel value\newline out: -\newline \newline","6659902","cdw_dropdown.c","int cdw_dropdown_expanded_driver(CDW_DROPDOWN *dropdown)\newline{\newline	cdw_assert (dropdown, &quotERROR: cannot control NULL dropdown\\n&quot);\newline\newline	/* a bit customized, but otherwise standard ncurses menu driver code */\newline	int key = &#039a&#039;\newline	while ((key = wgetch(dropdown-&gtparent)) != ERR) {\newline		switch (key) {\newline		        case CDW_KEY_ESCAPE:\newline			/* including &#039q&#039 and &#039Q&#039, as suggested by RogerX */\newline		        case &#039q&#039:\newline		        case &#039Q&#039:\newline				return CDW_KEY_ESCAPE;\newline			case KEY_HOME:\newline				menu_driver(dropdown-&gtmenu, REQ_FIRST_ITEM);\newline				break;\newline			case KEY_END:\newline				menu_driver(dropdown-&gtmenu, REQ_LAST_ITEM);\newline				break;\newline			case KEY_DOWN:\newline				menu_driver(dropdown-&gtmenu, REQ_DOWN_ITEM);\newline				break;\newline			case KEY_UP:\newline				menu_driver(dropdown-&gtmenu, REQ_UP_ITEM);\newline				break;\newline			case CDW_KEY_ENTER:\newline			{\newline				ITEM *item = current_item(dropdown-&gtmenu);\newline				cdw_assert (item, &quotERROR: current item is NULL\\n&quot);\newline				/* remember index of selected item */\newline				dropdown-&gtcurrent_item_ind = item_index(item);\newline\newline				return CDW_KEY_ENTER;\newline			}\newline\newline			default: /* other (meaningless in this context) keys */\newline				break;\newline		}\newline\newline		redrawwin(dropdown-&gtmenu_window_sub);\newline		wrefresh(dropdown-&gtmenu_window_sub);\newline	}\newline\newline	return CDW_KEY_ESCAPE;\newline}\newline","\newline\\brief React to keys pressed by user when given dropdown is expanded (active)\newline\\date Function&#039s top-level comment reviewed on 2012-01-07\newline\\date Function&#039s body reviewed on 2012-01-07\newlineReact to following keys: HOME, END, DOWN, UP, ENTER, ESCAPE, Q, q, when\newlinegiven dropdown is active/focused.\newlineCaller of this function must make sure that \\p dropdown is valid.\newline\\param dropdown - active dropdown, on which user operates\newline\\return CDW_KEY_ENTER if user pressed ENTER,\newline\\return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q\newline \newline","2161427","message.c","static void message_write_searchaddr(struct buf *buf,\newline				     const struct address *addrlist)\newline{\newline    int prevaddr = 0;\newline    char* tmp;\newline\newline    while (addrlist) {\newline\newline	/* Handle RFC-822 group addresses */\newline	if (!addrlist-&gtdomain) {\newline	    if (addrlist-&gtmailbox) {\newline		if (prevaddr) buf_putc(buf, &#039,&#039);\newline		\newline		tmp = charset_parse_mimeheader(addrlist-&gtmailbox);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp);\newline		tmp = NULL;\newline		buf_putc(buf, &#039:&#039);\newline	\newline		/* Suppress a trailing comma */\newline		prevaddr = 0;\newline	    }\newline	    else {\newline		buf_putc(buf, &#039;&#039);\newline		prevaddr = 1;\newline	    }\newline	}\newline	else {\newline	    if (prevaddr) buf_putc(buf, &#039,&#039);\newline\newline	    if (addrlist-&gtname) {\newline		tmp = charset_parse_mimeheader(addrlist-&gtname);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp); tmp = NULL;\newline		buf_putc(buf, &#039 &#039);\newline	    }\newline\newline	    buf_putc(buf, &#039&lt&#039);\newline	    if (addrlist-&gtroute) {\newline		message_write_text_lcase(buf, addrlist-&gtroute);\newline		buf_putc(buf, &#039:&#039);\newline	    }\newline\newline	    message_write_text_lcase(buf, addrlist-&gtmailbox);\newline	    buf_putc(buf, &#039@&#039);\newline\newline	    message_write_text_lcase(buf, addrlist-&gtdomain);\newline	    buf_putc(buf, &#039&gt&#039);\newline	    prevaddr = 1;\newline	}\newline\newline	addrlist = addrlist-&gtnext;\newline    }\newline}\newline","\newline Unparse the address list &#039addrlist&#039 to &#039buf&#039\newline \newline","5857624","distopt.c","extern char *getdistoptlist()\newline{\newline	int i;\newline	static char buf[1024];\newline\newline	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {\newline		if (buf[0] == CNULL)\newline			(void) strcpy(buf, distoptinfo[i].do_name);\newline		else {\newline			(void) strcat(buf, &quot,&quot);\newline			(void) strcat(buf, distoptinfo[i].do_name);\newline		}\newline	}\newline\newline	return(buf);\newline}\newline","\newline Get a list of the Distfile Option Entries.\newline \newline","5202631","gsm-statemachine.c","static gn_error __sm_block_timeout(int waitfor, int t, gn_data *data, struct gn_statemachine *state)\newline{\newline	int retry;\newline	gn_state s;\newline	gn_error err;\newline	struct timeval now, next, timeout;\newline\newline	s = state-&gtcurrent_state;\newline	timeout.tv_sec = 3;\newline	timeout.tv_usec = 0;\newline	gettimeofday(&ampnow, NULL);\newline	for (retry = 0; retry &lt 2; retry++) {\newline		err = sm_wait_for(waitfor, data, state);\newline		if (err != GN_ERR_NONE) return err;\newline\newline		timeradd(&ampnow, &amptimeout, &ampnext);\newline		do {\newline			s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline			gettimeofday(&ampnow, NULL);\newline		} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s == GN_SM_MessageSent));\newline		if (s == GN_SM_WaitingForResponse || s == GN_SM_ResponseReceived) break;\newline\newline		if (state-&gtconfig.sm_retry) {\newline			dprintf(&quotSM_Block Retry - %d\\n&quot, retry);\newline			sm_reset(state);\newline			sm_message_send(state-&gtlast_msg_size, state-&gtlast_msg_type, state-&gtlast_msg, state);\newline		} else {\newline			/* If we don&#039t want retry, we should exit the loop */\newline			dprintf(&quotSM_Block: exiting the retry loop\\n&quot);\newline			break;\newline		}\newline	}\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	timeout.tv_sec = t / 10;\newline	timeout.tv_usec = (t % 10) * 100000;\newline	timeradd(&ampnow, &amptimeout, &ampnext);\newline	do {\newline		s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline		gettimeofday(&ampnow, NULL);\newline	} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s != GN_SM_ResponseReceived));\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	sm_reset(state);\newline\newline	return GN_ERR_TIMEOUT;\newline}\newline","This function is for convinience only.\newlineIt is called after SM_SendMessage and blocks until a response is received.\newlinet is in tenths of second.\newline \newline","4199543","qdocument.cpp","void QDocument::setLanguageDefinition(QLanguageDefinition *f)\newline{\newline	if ( m_impl )\newline		m_impl-&gtm_language = f;\newline}\newline","!\newline \\brief Set the language definition\newline \newline","4228286","ass_render.c","static double x2scr(ASS_Renderer *render_priv, double x)\newline{\newline    return x * render_priv-&gtorig_width_nocrop / render_priv-&gtfont_scale_x /\newline        render_priv-&gttrack-&gtPlayResX +\newline        FFMAX(render_priv-&gtsettings.left_margin, 0);\newline}\newline","\newline \\brief Mapping between script and screen coordinates\newline \newline","3514685","blas1.cpp","int main()\newline{\newline  //Change this type definition to double if your gpu supports that\newline  typedef float       ScalarType;\newline\newline  viennacl::tools::uniform_random_numbers&ltScalarType&gt randomNumber;\newline\newline  /**\newline  * &lth2&gt Scalar Operations &lt/h2&gt\newline  *\newline  * Although usually not very efficient because of PCI-Express latency, ViennaCL enables you to directly manipulate individual scalar values.\newline  * As such, a viennacl::scalar&ltdouble&gt behaves very similar to a normal `double`.\newline  *\newline  * Let us define a few CPU and ViennaCL scalars:\newline  *\newline  **/\newline  ScalarType s1 = ScalarType(3.1415926);   //note: writing ScalarType s1 = 3.1415926; leads to warnings with some compilers if ScalarType is &#039float&#039.\newline  ScalarType s2 = ScalarType(2.71763);\newline  ScalarType s3 = ScalarType(42.0);\newline\newline  viennacl::scalar&ltScalarType&gt vcl_s1;\newline  viennacl::scalar&ltScalarType&gt vcl_s2 = ScalarType(1.0);\newline  viennacl::scalar&ltScalarType&gt vcl_s3 = ScalarType(1.0);\newline\newline  /**\newline  * CPU scalars can be transparently assigned to GPU scalars and vice versa:\newline  **/\newline  std::cout &lt&lt &quotCopying a few scalars...&quot &lt&lt std::endl;\newline  vcl_s1 = s1;\newline  s2 = vcl_s2;\newline  vcl_s3 = s3;\newline\newline  /**\newline  * Operations between GPU scalars work just as for CPU scalars:\newline  * (Note that such single compute kernels on the GPU are considerably slower than on the CPU)\newline  **/\newline\newline  std::cout &lt&lt &quotManipulating a few scalars...&quot &lt&lt std::endl;\newline  std::cout &lt&lt &quotoperator +=&quot &lt&lt std::endl;\newline  s1 += s2;\newline  vcl_s1 += vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator *=&quot &lt&lt std::endl;\newline  s1 *= s2;\newline  vcl_s1 *= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator -=&quot &lt&lt std::endl;\newline  s1 -= s2;\newline  vcl_s1 -= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator /=&quot &lt&lt std::endl;\newline  s1 /= s2;\newline  vcl_s1 /= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator +&quot &lt&lt std::endl;\newline  s1 = s2 + s3;\newline  vcl_s1 = vcl_s2 + vcl_s3;\newline\newline  std::cout &lt&lt &quotmultiple operators&quot &lt&lt std::endl;\newline  s1 = s2 + s3 * s2 - s3 / s1;\newline  vcl_s1 = vcl_s2 + vcl_s3 * vcl_s2 - vcl_s3 / vcl_s1;\newline\newline\newline  /**\newline  * Operations can also be mixed:\newline  **/\newline  std::cout &lt&lt &quotmixed operations&quot &lt&lt std::endl;\newline  vcl_s1 = s1 * vcl_s2 + s3 - vcl_s3;\newline\newline\newline  /**\newline  * The output stream is overloaded as well for direct printing to e.g. a terminal:\newline  **/\newline\newline  std::cout &lt&lt &quotCPU scalar s3: &quot &lt&lt s3 &lt&lt std::endl;\newline  std::cout &lt&lt &quotGPU scalar vcl_s3: &quot &lt&lt vcl_s3 &lt&lt std::endl;\newline\newline\newline  /**\newline  *  &lth2&gtVector Operations&lt/h2&gt\newline  *\newline  * Define a few vectors (from STL and plain C) and viennacl::vectors\newline  **/\newline  std::vector&ltScalarType&gt      std_vec1(10);\newline  std::vector&ltScalarType&gt      std_vec2(10);\newline  ScalarType                   plain_vec3[10];  //plain C array\newline\newline  viennacl::vector&ltScalarType&gt vcl_vec1(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec2(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec3(10);\newline\newline  /**\newline  * Let us fill the CPU vectors with random values:\newline  **/\newline\newline  for (unsigned int i = 0; i &lt 10; ++i)\newline  {\newline    std_vec1[i] = randomNumber();\newline    vcl_vec2(i) = randomNumber();  //also works for GPU vectors, but is MUCH slower (approx. factor 10.000) than the CPU analogue\newline    plain_vec3[i] = randomNumber();\newline  }\newline\newline  /**\newline  * Copy the CPU vectors to the GPU vectors and vice versa\newline  **/\newline  viennacl::copy(std_vec1.begin(), std_vec1.end(), vcl_vec1.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), std_vec2.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2, std_vec2);                                 //using the short hand notation for objects that provide .begin() and .end() members\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), plain_vec3);       //copy to plain C vector\newline\newline  /**\newline  * Also partial copies by providing the corresponding iterators are possible:\newline  **/\newline  viennacl::copy(std_vec1.begin() + 4, std_vec1.begin() + 8, vcl_vec1.begin() + 4);   //cpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, vcl_vec2.begin() + 1);   //gpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, std_vec1.begin() + 1);   //gpu to cpu\newline\newline  /**\newline  * Compute the inner product of two GPU vectors and write the result to either CPU or GPU\newline  **/\newline  vcl_s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s2 = viennacl::linalg::inner_prod(std_vec1, std_vec2); //inner prod can also be used with std::vector (computations are carried out on CPU then)\newline\newline  /**\newline  * Compute norms:\newline  **/\newline  s1 = viennacl::linalg::norm_1(vcl_vec1);\newline  vcl_s2 = viennacl::linalg::norm_2(vcl_vec2);\newline  s3 = viennacl::linalg::norm_inf(vcl_vec3);\newline\newline\newline  /**\newline  * Plane rotation of two vectors:\newline  **/\newline  viennacl::linalg::plane_rotation(vcl_vec1, vcl_vec2, 1.1f, 2.3f);\newline\newline  /**\newline  * Use viennacl::vector via the overloaded operators just as you would write it on paper:\newline  **/\newline\newline  //simple expression:\newline  vcl_vec1 = vcl_s1 * vcl_vec2 / vcl_s3;\newline\newline  //more complicated expression:\newline  vcl_vec1 = vcl_vec2 / vcl_s3 + vcl_s2 * (vcl_vec1 - vcl_s2 * vcl_vec2);\newline\newline\newline  /**\newline  * Swap the content of two vectors without a temporary vector:\newline  **/\newline  viennacl::swap(vcl_vec1, vcl_vec2);  //swaps all entries in memory\newline  viennacl::fast_swap(vcl_vec1, vcl_vec2); //swaps OpenCL memory handles only\newline\newline  /**\newline  * The vectors can also be cleared directly:\newline  **/\newline  vcl_vec1.clear();\newline  vcl_vec2.clear();\newline\newline  /**\newline  *  That&#039s it, the tutorial is completed.\newline  **/\newline  std::cout &lt&lt &quot!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot &lt&lt std::endl;\newline\newline  return EXIT_SUCCESS;\newline}\newline","\newline In this tutorial we do not need additional auxiliary functions, allowing us to start right with main():\newline \newline","1559409","gzlib.c","unsigned ZLIB_INTERNAL gz_intmax()\newline{\newline    unsigned p, q;\newline\newline    p = 1;\newline    do {\newline        q = p;\newline        p &lt&lt= 1;\newline        p++;\newline    } while (p &gt q);\newline    return q &gt&gt 1;\newline}\newline","portably return maximum value for an int (when limits.h presumed not\newlineavailable) -- we need to do this to cover cases where 2&#039s complement not\newlineused, since C standard permits 1&#039s complement and sign-bit representations,\newlineotherwise we could just use ((unsigned)-1) &gt&gt 1 \newline","2795766","libfdata_tree_node.c","int libfdata_tree_node_set_parent_node(\newline     libfdata_tree_node_t *node,\newline     libfdata_tree_node_t *parent_node,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_parent_node&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	internal_tree_node-&gtparent_node = parent_node;\newline\newline	return( 1 );\newline}\newline","Sets the parent node\newline Returns 1 if successful or -1 on error\newline \newline","1480622","uuid.c","char *xmpp_uuid_gen(xmpp_ctx_t *ctx)\newline{\newline    char *uuid;\newline\newline    uuid = xmpp_alloc(ctx, XMPP_UUID_LEN + 1);\newline    if (uuid != NULL) {\newline        crypto_uuid_gen(ctx, uuid);\newline    }\newline    return uuid;\newline}\newline","Generate UUID version 4.\newline This function allocates memory for the resulting string and must be freed\newline with xmpp_free().\newline \newline @param ctx a Strophe context object\newline \newline @return ASCIIZ string\newline \newline","3279849","lm_ssl.c","value lm_ssl_get_addr(value v_info)\newline{\newline    SslInfo *info;\newline    struct sockaddr_in sin;\newline    socklen_t size;\newline    value a, addr;\newline\newline    /* Get the address */\newline    info = SslInfo_val(v_info);\newline    size = sizeof(sin);\newline    if(getsockname(info-&gtfd, (struct sockaddr *) &ampsin, &ampsize) &lt 0 || sin.sin_family != AF_INET) {\newline        uerr(&quotlm_ssl_get_addr: getsockname&quot);\newline    }\newline\newline    /* Allocate the address */\newline    a = alloc_inet_addr(sin.sin_addr.s_addr);\newline    Begin_root(a);\newline    addr = alloc_small(2, 0);\newline    Field(addr, 0) = a;\newline    Field(addr, 1) = Val_int(ntohs(sin.sin_port));\newline    End_roots();\newline    return addr;\newline}\newline","\newline Get the address of the socket.\newline \newline","1785305","net_udp.c","char *NET_ErrorString (void)\newline{\newline	int		code;\newline\newline	code = errno;\newline	return strerror (code);\newline}\newline","\newline====================\newlineNET_ErrorString\newline====================\newline \newline","12431","rexxapi.c","APIRET APIENTRY RexxRegisterFunctionExe(\newline   PCSZ name,\newline   RexxFunctionHandler *EntryPoint )\newline{\newline   APIRET rc=RXFUNC_NOTREG;\newline\newline   if ( InterpreterIdx == -1 )\newline      LoadInterpreter();\newline\newline   if (Trace)\newline   {\newline      TraceString( &quot%s: Name \\&quot%s\\&quot Entrypoint %x &quot,\newline         &quotRexxRegisterFunctionExe()&quot,\newline         name,\newline         EntryPoint );\newline\newline   }\newline   if (ORexxRegisterFunctionExe)\newline      rc = (*ORexxRegisterFunctionExe)(\newline         (PSZ)       name,\newline         (PFN)       EntryPoint );\newline   if (Trace)\newline   {\newline      TraceString( &quot&lt=&gt Result: %d\\n&quot, rc );\newline   }\newline   return rc;\newline}\newline","\newline External functions\newline \newline","4912373","presence.c","void setPluginID(void * pluginID) \newline{\newline	_PluginID=pluginID;\newline}\newline","\newline Plugin identity mgmt\newline \newline","5793875","eng_main.c","void eng_pic_set_x(eng_obj *o, guint16 x)  {\newline\newline	if(!o)  return;\newline\newline	if(x != o-&gtx) {\newline\newline		o-&gtx = x;\newline		o-&gtchange = 1;\newline	}\newline}\newline","---- set X pos of pic \newline","5531993","isl_schedule_tree.c","__isl_give isl_schedule_tree *isl_schedule_tree_append_to_leaves(\newline	__isl_take isl_schedule_tree *tree1,\newline	__isl_take isl_schedule_tree *tree2)\newline{\newline	int i, n;\newline\newline	if (!tree1 || !tree2)\newline		goto error;\newline	n = isl_schedule_tree_n_children(tree1);\newline	if (n == 0) {\newline		isl_schedule_tree_list *list;\newline		list = isl_schedule_tree_list_from_schedule_tree(tree2);\newline		tree1 = isl_schedule_tree_set_children(tree1, list);\newline		return tree1;\newline	}\newline	for (i = 0; i &lt n; ++i) {\newline		isl_schedule_tree *child;\newline\newline		child = isl_schedule_tree_get_child(tree1, i);\newline		child = isl_schedule_tree_append_to_leaves(child,\newline					isl_schedule_tree_copy(tree2));\newline		tree1 = isl_schedule_tree_replace_child(tree1, i, child);\newline	}\newline\newline	isl_schedule_tree_free(tree2);\newline	return tree1;\newlineerror:\newline	isl_schedule_tree_free(tree1);\newline	isl_schedule_tree_free(tree2);\newline	return NULL;\newline}\newline","Attach &quottree2&quot at each of the leaves of &quottree1&quot.\newline \newline If &quottree1&quot does not have any explicit children, then make &quottree2&quot\newline its single child. Otherwise, attach &quottree2&quot to the leaves of\newline each of the children of &quottree1&quot.\newline \newline","1260019","attrs.c","AttVal* TY_(AttrGetById)( Node* node, TidyAttrId id )\newline{\newline   AttVal* av;\newline   for ( av = node-&gtattributes; av; av = av-&gtnext )\newline   {\newline     if ( AttrIsId(av, id) )\newline         return av;\newline   }\newline   return NULL;\newline}\newline","Locate attributes by type \newline","","","on","","","","","on","on","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","on","","","on","","writes information in the widget out to a contrast.txt file","Mapping between script and screen coordinates","{}","portably return maximum value for an int","Sets the parent node","allocates memory for the resulting string and must be freed with xmpp_free().","Get the address of the socket.","{}","{}","Plugin identity mgmt","set X pos of pic","Test that H5PTis_varlen works correctly on both fixed- and variable-length packet tables.","Attach ""tree2"" at each of the leaves of ""tree1"".","Locate attributes by type","similar to yp_remove, but we force a touch attempt","Set one pixel in lcdBuf.","React to keys pressed by user when given dropdown is expanded","Unparse the address list 'addrlist' to 'buf'","Get a list of the Distfile Option Entries.","called after SM_SendMessage and blocks until a response is received.","Set the language definition"
"3QXFBUZ4ZKGKGGRN07TE0Y28WU4UGI","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3GLB5JMZFXV0MYDU4E8QFHU9QITDGF","A1NV81QEC0GDG7","Approved","Wed Apr 17 14:49:20 PDT 2019","Wed Apr 17 14:58:45 PDT 2019","Fri Apr 19 14:58:45 PDT 2019","2019-04-19 21:59:21 UTC","","","565","100% (5/5)","100% (5/5)","100% (5/5)","1526179","vbcontrast.cpp","void VBContrastParamScalingWidget::WriteContrastInfo( string stemname )\newline{\newline  ofstream output;\newline  \newline//  output.open((stemname + &quot.contrasts&quot).c_str());\newline  int pos = stemname.rfind(&quot/&quot);\newline  stemname = stemname.substr(0, ++pos);\newline  output.open((stemname + &quotcontrasts.txt&quot).c_str());\newline  if (output.good())\newline  {\newline    VBContrast* contrast;\newline    Q3ListViewItemIterator iter(mContrastList);\newline    while (iter.current())\newline    {\newline      contrast = mContrastList-&gtcontrastAt(*iter);\newline      output &lt&lt contrast-&gtname &lt&lt &quot &quot\newline             &lt&lt contrast-&gtscale &lt&lt &quot vec &quot;\newline      \newline      for (uint32 i=0; i&ltcontrast-&gtcontrast.size(); ++i)\newline        // only write out covariates of interest...\newline        if (mGLMInfo-&gtcnames[i][0] == &#039I&#039) output &lt&lt contrast-&gtcontrast[i] &lt&lt &quot &quot;\newline      \newline      output &lt&lt endl;\newline      ++iter;\newline    }\newline  }\newline}\newline","\newline WriteContrastInfo writes information in the widget out to a contrast.txt file\newline in the glm directory.\newline \newline","4366568","test_packet_vlen.c","static int test_H5PTis_varlen(void)\newline{\newline    hid_t   fid=H5I_INVALID_HID;	/* Test file identifier */\newline    hid_t   ptable=H5I_INVALID_HID;	/* Packet table identifier */\newline    herr_t  ret;		/* Returned status from a callee */\newline\newline    TESTING(&quotH5PTis_varlen&quot);\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Create a new table */\newline    ptable = H5PTcreate(fid, PT_FIXED_LEN, H5T_STD_I32BE, (hsize_t)100, H5P_DEFAULT);\newline\newline    /* Ensure that PT is created successfully */\newline    if (ptable == H5I_INVALID_HID)\newline	goto error;\newline\newline    /* Close the packet table */\newline    ret = H5PTclose(ptable);\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Open each packet table, and verify that H5PTis_varlen returns correct\newline       type for each table */\newline    ret = verify_ptlengthtype(fid, PT_VLEN_ATOMIC, 1); /* vlen of atomic */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_COMP, 1); /* vlen of compound */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_COMP_VLEN, 0); /* compound of vlen, no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_VLEN, 1); /* vlen of vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_FIXED_LEN, 0); /* no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    PASSED();\newline    return SUCCEED;\newline\newlineerror: /* An error has occurred.  Clean up and exit. */\newline    if (fid &gt 0) H5Fclose(fid);\newline    H5_FAILED();\newline    return FAIL;\newline} /* test_H5PTis_varlen */\newline","-------------------------------------------------------------------------\newline test_H5PTis_varlen(): Test that H5PTis_varlen works correctly on both\newline fixed- and variable-length packet tables.\newline \newline Description:\newline - Added a fixed-length packet table to the file for variety\newline - Use the helper funtion verify_ptlengthtype to test H5PTis_varlen\newline on each packet table.\newline \newline 2016/01/27 -BMR\newline -------------------------------------------------------------------------\newline \newline","4396668","yp.c","void yp_touch (const char *mount)\newline{\newline    struct yp_server *server = (struct yp_server *)active_yps;\newline    ypdata_t *search_list = NULL;\newline\newline    thread_rwlock_rlock (&ampyp_lock);\newline    if (server)\newline        search_list = server-&gtmounts;\newline\newline    while (server)\newline    {\newline        ypdata_t *yp = find_yp_mount (search_list, mount);\newline        if (yp)\newline        {\newline            /* we may of found old entries not purged yet, so skip them */\newline            if (yp-&gtrelease != 0 || yp-&gtremove != 0)\newline            {\newline                search_list = yp-&gtnext;\newline                continue;\newline            }\newline            /* don&#039t update the directory if there is a touch scheduled soon */\newline            if (yp-&gtprocess == do_yp_touch &amp&amp now + yp-&gttouch_interval - yp-&gtnext_update &gt 60)\newline                yp-&gtnext_update = now + 3;\newline        }\newline        server = server-&gtnext;\newline        if (server)\newline            search_list = server-&gtmounts;\newline    }\newline    thread_rwlock_unlock (&ampyp_lock);\newline}\newline","This is similar to yp_remove, but we force a touch\newline attempt \newline","1679443","drv_dpf.c","static void drv_set_pixel(int x, int y, RGBA pix)\newline{\newline    int changed = 0;\newline\newline    int sx = DCOLS;\newline    int sy = DROWS;\newline    int lx = x % sx;\newline    int ly = y % sy;\newline\newline    if (dpf.flip) {\newline	// upside down orientation\newline	lx = DCOLS - 1 - lx;\newline	ly = DROWS - 1 - ly;\newline    }\newline\newline    if (dpf.rotate90) {\newline	// wrong Orientation, rotate\newline	int i = ly;\newline	ly = dpf.pheight - 1 - lx;\newline	lx = i;\newline    }\newline\newline    if (lx &lt 0 || lx &gt= (int) dpf.pwidth || ly &lt 0 || ly &gt= (int) dpf.pheight) {\newline	error(&quotdpf: x/y out of bounds (x=%d, y=%d, rot=%d, flip=%d, lx=%d, ly=%d)\\n&quot, x, y, dpf.rotate90, dpf.flip, lx,\newline	      ly);\newline	return;\newline    }\newline\newline    unsigned char c1 = _RGB565_0(pix);\newline    unsigned char c2 = _RGB565_1(pix);\newline    unsigned int i = (ly * dpf.pwidth + lx) * DPF_BPP;\newline    if (dpf.lcdBuf[i] != c1 || dpf.lcdBuf[i + 1] != c2) {\newline	dpf.lcdBuf[i] = c1;\newline	dpf.lcdBuf[i + 1] = c2;\newline	changed = 1;\newline    }\newline\newline    if (changed) {\newline	if (lx &lt dpf.minx)\newline	    dpf.minx = lx;\newline	if (lx &gt dpf.maxx)\newline	    dpf.maxx = lx;\newline	if (ly &lt dpf.miny)\newline	    dpf.miny = ly;\newline	if (ly &gt dpf.maxy)\newline	    dpf.maxy = ly;\newline    }\newline}\newline","\newline Set one pixel in lcdBuf.\newline \newline Respects orientation and updates dirty rectangle.\newline \newline in: x, y - pixel coordinates\newline pix - RGBA pixel value\newline out: -\newline \newline","6659902","cdw_dropdown.c","int cdw_dropdown_expanded_driver(CDW_DROPDOWN *dropdown)\newline{\newline	cdw_assert (dropdown, &quotERROR: cannot control NULL dropdown\\n&quot);\newline\newline	/* a bit customized, but otherwise standard ncurses menu driver code */\newline	int key = &#039a&#039;\newline	while ((key = wgetch(dropdown-&gtparent)) != ERR) {\newline		switch (key) {\newline		        case CDW_KEY_ESCAPE:\newline			/* including &#039q&#039 and &#039Q&#039, as suggested by RogerX */\newline		        case &#039q&#039:\newline		        case &#039Q&#039:\newline				return CDW_KEY_ESCAPE;\newline			case KEY_HOME:\newline				menu_driver(dropdown-&gtmenu, REQ_FIRST_ITEM);\newline				break;\newline			case KEY_END:\newline				menu_driver(dropdown-&gtmenu, REQ_LAST_ITEM);\newline				break;\newline			case KEY_DOWN:\newline				menu_driver(dropdown-&gtmenu, REQ_DOWN_ITEM);\newline				break;\newline			case KEY_UP:\newline				menu_driver(dropdown-&gtmenu, REQ_UP_ITEM);\newline				break;\newline			case CDW_KEY_ENTER:\newline			{\newline				ITEM *item = current_item(dropdown-&gtmenu);\newline				cdw_assert (item, &quotERROR: current item is NULL\\n&quot);\newline				/* remember index of selected item */\newline				dropdown-&gtcurrent_item_ind = item_index(item);\newline\newline				return CDW_KEY_ENTER;\newline			}\newline\newline			default: /* other (meaningless in this context) keys */\newline				break;\newline		}\newline\newline		redrawwin(dropdown-&gtmenu_window_sub);\newline		wrefresh(dropdown-&gtmenu_window_sub);\newline	}\newline\newline	return CDW_KEY_ESCAPE;\newline}\newline","\newline\\brief React to keys pressed by user when given dropdown is expanded (active)\newline\\date Function&#039s top-level comment reviewed on 2012-01-07\newline\\date Function&#039s body reviewed on 2012-01-07\newlineReact to following keys: HOME, END, DOWN, UP, ENTER, ESCAPE, Q, q, when\newlinegiven dropdown is active/focused.\newlineCaller of this function must make sure that \\p dropdown is valid.\newline\\param dropdown - active dropdown, on which user operates\newline\\return CDW_KEY_ENTER if user pressed ENTER,\newline\\return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q\newline \newline","2161427","message.c","static void message_write_searchaddr(struct buf *buf,\newline				     const struct address *addrlist)\newline{\newline    int prevaddr = 0;\newline    char* tmp;\newline\newline    while (addrlist) {\newline\newline	/* Handle RFC-822 group addresses */\newline	if (!addrlist-&gtdomain) {\newline	    if (addrlist-&gtmailbox) {\newline		if (prevaddr) buf_putc(buf, &#039,&#039);\newline		\newline		tmp = charset_parse_mimeheader(addrlist-&gtmailbox);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp);\newline		tmp = NULL;\newline		buf_putc(buf, &#039:&#039);\newline	\newline		/* Suppress a trailing comma */\newline		prevaddr = 0;\newline	    }\newline	    else {\newline		buf_putc(buf, &#039;&#039);\newline		prevaddr = 1;\newline	    }\newline	}\newline	else {\newline	    if (prevaddr) buf_putc(buf, &#039,&#039);\newline\newline	    if (addrlist-&gtname) {\newline		tmp = charset_parse_mimeheader(addrlist-&gtname);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp); tmp = NULL;\newline		buf_putc(buf, &#039 &#039);\newline	    }\newline\newline	    buf_putc(buf, &#039&lt&#039);\newline	    if (addrlist-&gtroute) {\newline		message_write_text_lcase(buf, addrlist-&gtroute);\newline		buf_putc(buf, &#039:&#039);\newline	    }\newline\newline	    message_write_text_lcase(buf, addrlist-&gtmailbox);\newline	    buf_putc(buf, &#039@&#039);\newline\newline	    message_write_text_lcase(buf, addrlist-&gtdomain);\newline	    buf_putc(buf, &#039&gt&#039);\newline	    prevaddr = 1;\newline	}\newline\newline	addrlist = addrlist-&gtnext;\newline    }\newline}\newline","\newline Unparse the address list &#039addrlist&#039 to &#039buf&#039\newline \newline","5857624","distopt.c","extern char *getdistoptlist()\newline{\newline	int i;\newline	static char buf[1024];\newline\newline	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {\newline		if (buf[0] == CNULL)\newline			(void) strcpy(buf, distoptinfo[i].do_name);\newline		else {\newline			(void) strcat(buf, &quot,&quot);\newline			(void) strcat(buf, distoptinfo[i].do_name);\newline		}\newline	}\newline\newline	return(buf);\newline}\newline","\newline Get a list of the Distfile Option Entries.\newline \newline","5202631","gsm-statemachine.c","static gn_error __sm_block_timeout(int waitfor, int t, gn_data *data, struct gn_statemachine *state)\newline{\newline	int retry;\newline	gn_state s;\newline	gn_error err;\newline	struct timeval now, next, timeout;\newline\newline	s = state-&gtcurrent_state;\newline	timeout.tv_sec = 3;\newline	timeout.tv_usec = 0;\newline	gettimeofday(&ampnow, NULL);\newline	for (retry = 0; retry &lt 2; retry++) {\newline		err = sm_wait_for(waitfor, data, state);\newline		if (err != GN_ERR_NONE) return err;\newline\newline		timeradd(&ampnow, &amptimeout, &ampnext);\newline		do {\newline			s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline			gettimeofday(&ampnow, NULL);\newline		} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s == GN_SM_MessageSent));\newline		if (s == GN_SM_WaitingForResponse || s == GN_SM_ResponseReceived) break;\newline\newline		if (state-&gtconfig.sm_retry) {\newline			dprintf(&quotSM_Block Retry - %d\\n&quot, retry);\newline			sm_reset(state);\newline			sm_message_send(state-&gtlast_msg_size, state-&gtlast_msg_type, state-&gtlast_msg, state);\newline		} else {\newline			/* If we don&#039t want retry, we should exit the loop */\newline			dprintf(&quotSM_Block: exiting the retry loop\\n&quot);\newline			break;\newline		}\newline	}\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	timeout.tv_sec = t / 10;\newline	timeout.tv_usec = (t % 10) * 100000;\newline	timeradd(&ampnow, &amptimeout, &ampnext);\newline	do {\newline		s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline		gettimeofday(&ampnow, NULL);\newline	} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s != GN_SM_ResponseReceived));\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	sm_reset(state);\newline\newline	return GN_ERR_TIMEOUT;\newline}\newline","This function is for convinience only.\newlineIt is called after SM_SendMessage and blocks until a response is received.\newlinet is in tenths of second.\newline \newline","4199543","qdocument.cpp","void QDocument::setLanguageDefinition(QLanguageDefinition *f)\newline{\newline	if ( m_impl )\newline		m_impl-&gtm_language = f;\newline}\newline","!\newline \\brief Set the language definition\newline \newline","4228286","ass_render.c","static double x2scr(ASS_Renderer *render_priv, double x)\newline{\newline    return x * render_priv-&gtorig_width_nocrop / render_priv-&gtfont_scale_x /\newline        render_priv-&gttrack-&gtPlayResX +\newline        FFMAX(render_priv-&gtsettings.left_margin, 0);\newline}\newline","\newline \\brief Mapping between script and screen coordinates\newline \newline","3514685","blas1.cpp","int main()\newline{\newline  //Change this type definition to double if your gpu supports that\newline  typedef float       ScalarType;\newline\newline  viennacl::tools::uniform_random_numbers&ltScalarType&gt randomNumber;\newline\newline  /**\newline  * &lth2&gt Scalar Operations &lt/h2&gt\newline  *\newline  * Although usually not very efficient because of PCI-Express latency, ViennaCL enables you to directly manipulate individual scalar values.\newline  * As such, a viennacl::scalar&ltdouble&gt behaves very similar to a normal `double`.\newline  *\newline  * Let us define a few CPU and ViennaCL scalars:\newline  *\newline  **/\newline  ScalarType s1 = ScalarType(3.1415926);   //note: writing ScalarType s1 = 3.1415926; leads to warnings with some compilers if ScalarType is &#039float&#039.\newline  ScalarType s2 = ScalarType(2.71763);\newline  ScalarType s3 = ScalarType(42.0);\newline\newline  viennacl::scalar&ltScalarType&gt vcl_s1;\newline  viennacl::scalar&ltScalarType&gt vcl_s2 = ScalarType(1.0);\newline  viennacl::scalar&ltScalarType&gt vcl_s3 = ScalarType(1.0);\newline\newline  /**\newline  * CPU scalars can be transparently assigned to GPU scalars and vice versa:\newline  **/\newline  std::cout &lt&lt &quotCopying a few scalars...&quot &lt&lt std::endl;\newline  vcl_s1 = s1;\newline  s2 = vcl_s2;\newline  vcl_s3 = s3;\newline\newline  /**\newline  * Operations between GPU scalars work just as for CPU scalars:\newline  * (Note that such single compute kernels on the GPU are considerably slower than on the CPU)\newline  **/\newline\newline  std::cout &lt&lt &quotManipulating a few scalars...&quot &lt&lt std::endl;\newline  std::cout &lt&lt &quotoperator +=&quot &lt&lt std::endl;\newline  s1 += s2;\newline  vcl_s1 += vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator *=&quot &lt&lt std::endl;\newline  s1 *= s2;\newline  vcl_s1 *= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator -=&quot &lt&lt std::endl;\newline  s1 -= s2;\newline  vcl_s1 -= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator /=&quot &lt&lt std::endl;\newline  s1 /= s2;\newline  vcl_s1 /= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator +&quot &lt&lt std::endl;\newline  s1 = s2 + s3;\newline  vcl_s1 = vcl_s2 + vcl_s3;\newline\newline  std::cout &lt&lt &quotmultiple operators&quot &lt&lt std::endl;\newline  s1 = s2 + s3 * s2 - s3 / s1;\newline  vcl_s1 = vcl_s2 + vcl_s3 * vcl_s2 - vcl_s3 / vcl_s1;\newline\newline\newline  /**\newline  * Operations can also be mixed:\newline  **/\newline  std::cout &lt&lt &quotmixed operations&quot &lt&lt std::endl;\newline  vcl_s1 = s1 * vcl_s2 + s3 - vcl_s3;\newline\newline\newline  /**\newline  * The output stream is overloaded as well for direct printing to e.g. a terminal:\newline  **/\newline\newline  std::cout &lt&lt &quotCPU scalar s3: &quot &lt&lt s3 &lt&lt std::endl;\newline  std::cout &lt&lt &quotGPU scalar vcl_s3: &quot &lt&lt vcl_s3 &lt&lt std::endl;\newline\newline\newline  /**\newline  *  &lth2&gtVector Operations&lt/h2&gt\newline  *\newline  * Define a few vectors (from STL and plain C) and viennacl::vectors\newline  **/\newline  std::vector&ltScalarType&gt      std_vec1(10);\newline  std::vector&ltScalarType&gt      std_vec2(10);\newline  ScalarType                   plain_vec3[10];  //plain C array\newline\newline  viennacl::vector&ltScalarType&gt vcl_vec1(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec2(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec3(10);\newline\newline  /**\newline  * Let us fill the CPU vectors with random values:\newline  **/\newline\newline  for (unsigned int i = 0; i &lt 10; ++i)\newline  {\newline    std_vec1[i] = randomNumber();\newline    vcl_vec2(i) = randomNumber();  //also works for GPU vectors, but is MUCH slower (approx. factor 10.000) than the CPU analogue\newline    plain_vec3[i] = randomNumber();\newline  }\newline\newline  /**\newline  * Copy the CPU vectors to the GPU vectors and vice versa\newline  **/\newline  viennacl::copy(std_vec1.begin(), std_vec1.end(), vcl_vec1.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), std_vec2.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2, std_vec2);                                 //using the short hand notation for objects that provide .begin() and .end() members\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), plain_vec3);       //copy to plain C vector\newline\newline  /**\newline  * Also partial copies by providing the corresponding iterators are possible:\newline  **/\newline  viennacl::copy(std_vec1.begin() + 4, std_vec1.begin() + 8, vcl_vec1.begin() + 4);   //cpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, vcl_vec2.begin() + 1);   //gpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, std_vec1.begin() + 1);   //gpu to cpu\newline\newline  /**\newline  * Compute the inner product of two GPU vectors and write the result to either CPU or GPU\newline  **/\newline  vcl_s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s2 = viennacl::linalg::inner_prod(std_vec1, std_vec2); //inner prod can also be used with std::vector (computations are carried out on CPU then)\newline\newline  /**\newline  * Compute norms:\newline  **/\newline  s1 = viennacl::linalg::norm_1(vcl_vec1);\newline  vcl_s2 = viennacl::linalg::norm_2(vcl_vec2);\newline  s3 = viennacl::linalg::norm_inf(vcl_vec3);\newline\newline\newline  /**\newline  * Plane rotation of two vectors:\newline  **/\newline  viennacl::linalg::plane_rotation(vcl_vec1, vcl_vec2, 1.1f, 2.3f);\newline\newline  /**\newline  * Use viennacl::vector via the overloaded operators just as you would write it on paper:\newline  **/\newline\newline  //simple expression:\newline  vcl_vec1 = vcl_s1 * vcl_vec2 / vcl_s3;\newline\newline  //more complicated expression:\newline  vcl_vec1 = vcl_vec2 / vcl_s3 + vcl_s2 * (vcl_vec1 - vcl_s2 * vcl_vec2);\newline\newline\newline  /**\newline  * Swap the content of two vectors without a temporary vector:\newline  **/\newline  viennacl::swap(vcl_vec1, vcl_vec2);  //swaps all entries in memory\newline  viennacl::fast_swap(vcl_vec1, vcl_vec2); //swaps OpenCL memory handles only\newline\newline  /**\newline  * The vectors can also be cleared directly:\newline  **/\newline  vcl_vec1.clear();\newline  vcl_vec2.clear();\newline\newline  /**\newline  *  That&#039s it, the tutorial is completed.\newline  **/\newline  std::cout &lt&lt &quot!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot &lt&lt std::endl;\newline\newline  return EXIT_SUCCESS;\newline}\newline","\newline In this tutorial we do not need additional auxiliary functions, allowing us to start right with main():\newline \newline","1559409","gzlib.c","unsigned ZLIB_INTERNAL gz_intmax()\newline{\newline    unsigned p, q;\newline\newline    p = 1;\newline    do {\newline        q = p;\newline        p &lt&lt= 1;\newline        p++;\newline    } while (p &gt q);\newline    return q &gt&gt 1;\newline}\newline","portably return maximum value for an int (when limits.h presumed not\newlineavailable) -- we need to do this to cover cases where 2&#039s complement not\newlineused, since C standard permits 1&#039s complement and sign-bit representations,\newlineotherwise we could just use ((unsigned)-1) &gt&gt 1 \newline","2795766","libfdata_tree_node.c","int libfdata_tree_node_set_parent_node(\newline     libfdata_tree_node_t *node,\newline     libfdata_tree_node_t *parent_node,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_parent_node&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	internal_tree_node-&gtparent_node = parent_node;\newline\newline	return( 1 );\newline}\newline","Sets the parent node\newline Returns 1 if successful or -1 on error\newline \newline","1480622","uuid.c","char *xmpp_uuid_gen(xmpp_ctx_t *ctx)\newline{\newline    char *uuid;\newline\newline    uuid = xmpp_alloc(ctx, XMPP_UUID_LEN + 1);\newline    if (uuid != NULL) {\newline        crypto_uuid_gen(ctx, uuid);\newline    }\newline    return uuid;\newline}\newline","Generate UUID version 4.\newline This function allocates memory for the resulting string and must be freed\newline with xmpp_free().\newline \newline @param ctx a Strophe context object\newline \newline @return ASCIIZ string\newline \newline","3279849","lm_ssl.c","value lm_ssl_get_addr(value v_info)\newline{\newline    SslInfo *info;\newline    struct sockaddr_in sin;\newline    socklen_t size;\newline    value a, addr;\newline\newline    /* Get the address */\newline    info = SslInfo_val(v_info);\newline    size = sizeof(sin);\newline    if(getsockname(info-&gtfd, (struct sockaddr *) &ampsin, &ampsize) &lt 0 || sin.sin_family != AF_INET) {\newline        uerr(&quotlm_ssl_get_addr: getsockname&quot);\newline    }\newline\newline    /* Allocate the address */\newline    a = alloc_inet_addr(sin.sin_addr.s_addr);\newline    Begin_root(a);\newline    addr = alloc_small(2, 0);\newline    Field(addr, 0) = a;\newline    Field(addr, 1) = Val_int(ntohs(sin.sin_port));\newline    End_roots();\newline    return addr;\newline}\newline","\newline Get the address of the socket.\newline \newline","1785305","net_udp.c","char *NET_ErrorString (void)\newline{\newline	int		code;\newline\newline	code = errno;\newline	return strerror (code);\newline}\newline","\newline====================\newlineNET_ErrorString\newline====================\newline \newline","12431","rexxapi.c","APIRET APIENTRY RexxRegisterFunctionExe(\newline   PCSZ name,\newline   RexxFunctionHandler *EntryPoint )\newline{\newline   APIRET rc=RXFUNC_NOTREG;\newline\newline   if ( InterpreterIdx == -1 )\newline      LoadInterpreter();\newline\newline   if (Trace)\newline   {\newline      TraceString( &quot%s: Name \\&quot%s\\&quot Entrypoint %x &quot,\newline         &quotRexxRegisterFunctionExe()&quot,\newline         name,\newline         EntryPoint );\newline\newline   }\newline   if (ORexxRegisterFunctionExe)\newline      rc = (*ORexxRegisterFunctionExe)(\newline         (PSZ)       name,\newline         (PFN)       EntryPoint );\newline   if (Trace)\newline   {\newline      TraceString( &quot&lt=&gt Result: %d\\n&quot, rc );\newline   }\newline   return rc;\newline}\newline","\newline External functions\newline \newline","4912373","presence.c","void setPluginID(void * pluginID) \newline{\newline	_PluginID=pluginID;\newline}\newline","\newline Plugin identity mgmt\newline \newline","5793875","eng_main.c","void eng_pic_set_x(eng_obj *o, guint16 x)  {\newline\newline	if(!o)  return;\newline\newline	if(x != o-&gtx) {\newline\newline		o-&gtx = x;\newline		o-&gtchange = 1;\newline	}\newline}\newline","---- set X pos of pic \newline","5531993","isl_schedule_tree.c","__isl_give isl_schedule_tree *isl_schedule_tree_append_to_leaves(\newline	__isl_take isl_schedule_tree *tree1,\newline	__isl_take isl_schedule_tree *tree2)\newline{\newline	int i, n;\newline\newline	if (!tree1 || !tree2)\newline		goto error;\newline	n = isl_schedule_tree_n_children(tree1);\newline	if (n == 0) {\newline		isl_schedule_tree_list *list;\newline		list = isl_schedule_tree_list_from_schedule_tree(tree2);\newline		tree1 = isl_schedule_tree_set_children(tree1, list);\newline		return tree1;\newline	}\newline	for (i = 0; i &lt n; ++i) {\newline		isl_schedule_tree *child;\newline\newline		child = isl_schedule_tree_get_child(tree1, i);\newline		child = isl_schedule_tree_append_to_leaves(child,\newline					isl_schedule_tree_copy(tree2));\newline		tree1 = isl_schedule_tree_replace_child(tree1, i, child);\newline	}\newline\newline	isl_schedule_tree_free(tree2);\newline	return tree1;\newlineerror:\newline	isl_schedule_tree_free(tree1);\newline	isl_schedule_tree_free(tree2);\newline	return NULL;\newline}\newline","Attach &quottree2&quot at each of the leaves of &quottree1&quot.\newline \newline If &quottree1&quot does not have any explicit children, then make &quottree2&quot\newline its single child. Otherwise, attach &quottree2&quot to the leaves of\newline each of the children of &quottree1&quot.\newline \newline","1260019","attrs.c","AttVal* TY_(AttrGetById)( Node* node, TidyAttrId id )\newline{\newline   AttVal* av;\newline   for ( av = node-&gtattributes; av; av = av-&gtnext )\newline   {\newline     if ( AttrIsId(av, id) )\newline         return av;\newline   }\newline   return NULL;\newline}\newline","Locate attributes by type \newline","","","on","","","","","on","on","","","","","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","","writes information in the widget out to a contrast.txt file","Mapping between script and screen coordinates","{}","return maximum value for an int","Sets the parent node","Generate UUID version 4.","Get the address of the socket.","{}","{}","Plugin identity mgmt","set X pos of pic","Test that H5PTis_varlen works correctly on bothfixed- and variable-length packet tables.","Attach ""tree2"" at each of the leaves of ""tree1"".","Locate attributes by type","{}","Set one pixel in lcdBuf.","React to keys pressed by user when given dropdown is expanded","Unparse the address list","Get a list of the Distfile Option Entries.","{}","Set the language definition"
"3QXFBUZ4ZKGKGGRN07TE0Y28WU4UGI","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3HL8HNGX451I584IHEX6B0B7YI29FJ","A1FI71PFT1MZ4T","Approved","Wed Apr 17 13:50:55 PDT 2019","Wed Apr 17 13:56:00 PDT 2019","Fri Apr 19 13:56:00 PDT 2019","2019-04-19 20:56:21 UTC","","","305","100% (1/1)","100% (1/1)","100% (1/1)","1526179","vbcontrast.cpp","void VBContrastParamScalingWidget::WriteContrastInfo( string stemname )\newline{\newline  ofstream output;\newline  \newline//  output.open((stemname + &quot.contrasts&quot).c_str());\newline  int pos = stemname.rfind(&quot/&quot);\newline  stemname = stemname.substr(0, ++pos);\newline  output.open((stemname + &quotcontrasts.txt&quot).c_str());\newline  if (output.good())\newline  {\newline    VBContrast* contrast;\newline    Q3ListViewItemIterator iter(mContrastList);\newline    while (iter.current())\newline    {\newline      contrast = mContrastList-&gtcontrastAt(*iter);\newline      output &lt&lt contrast-&gtname &lt&lt &quot &quot\newline             &lt&lt contrast-&gtscale &lt&lt &quot vec &quot;\newline      \newline      for (uint32 i=0; i&ltcontrast-&gtcontrast.size(); ++i)\newline        // only write out covariates of interest...\newline        if (mGLMInfo-&gtcnames[i][0] == &#039I&#039) output &lt&lt contrast-&gtcontrast[i] &lt&lt &quot &quot;\newline      \newline      output &lt&lt endl;\newline      ++iter;\newline    }\newline  }\newline}\newline","\newline WriteContrastInfo writes information in the widget out to a contrast.txt file\newline in the glm directory.\newline \newline","4366568","test_packet_vlen.c","static int test_H5PTis_varlen(void)\newline{\newline    hid_t   fid=H5I_INVALID_HID;	/* Test file identifier */\newline    hid_t   ptable=H5I_INVALID_HID;	/* Packet table identifier */\newline    herr_t  ret;		/* Returned status from a callee */\newline\newline    TESTING(&quotH5PTis_varlen&quot);\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Create a new table */\newline    ptable = H5PTcreate(fid, PT_FIXED_LEN, H5T_STD_I32BE, (hsize_t)100, H5P_DEFAULT);\newline\newline    /* Ensure that PT is created successfully */\newline    if (ptable == H5I_INVALID_HID)\newline	goto error;\newline\newline    /* Close the packet table */\newline    ret = H5PTclose(ptable);\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Open each packet table, and verify that H5PTis_varlen returns correct\newline       type for each table */\newline    ret = verify_ptlengthtype(fid, PT_VLEN_ATOMIC, 1); /* vlen of atomic */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_COMP, 1); /* vlen of compound */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_COMP_VLEN, 0); /* compound of vlen, no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_VLEN, 1); /* vlen of vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_FIXED_LEN, 0); /* no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    PASSED();\newline    return SUCCEED;\newline\newlineerror: /* An error has occurred.  Clean up and exit. */\newline    if (fid &gt 0) H5Fclose(fid);\newline    H5_FAILED();\newline    return FAIL;\newline} /* test_H5PTis_varlen */\newline","-------------------------------------------------------------------------\newline test_H5PTis_varlen(): Test that H5PTis_varlen works correctly on both\newline fixed- and variable-length packet tables.\newline \newline Description:\newline - Added a fixed-length packet table to the file for variety\newline - Use the helper funtion verify_ptlengthtype to test H5PTis_varlen\newline on each packet table.\newline \newline 2016/01/27 -BMR\newline -------------------------------------------------------------------------\newline \newline","4396668","yp.c","void yp_touch (const char *mount)\newline{\newline    struct yp_server *server = (struct yp_server *)active_yps;\newline    ypdata_t *search_list = NULL;\newline\newline    thread_rwlock_rlock (&ampyp_lock);\newline    if (server)\newline        search_list = server-&gtmounts;\newline\newline    while (server)\newline    {\newline        ypdata_t *yp = find_yp_mount (search_list, mount);\newline        if (yp)\newline        {\newline            /* we may of found old entries not purged yet, so skip them */\newline            if (yp-&gtrelease != 0 || yp-&gtremove != 0)\newline            {\newline                search_list = yp-&gtnext;\newline                continue;\newline            }\newline            /* don&#039t update the directory if there is a touch scheduled soon */\newline            if (yp-&gtprocess == do_yp_touch &amp&amp now + yp-&gttouch_interval - yp-&gtnext_update &gt 60)\newline                yp-&gtnext_update = now + 3;\newline        }\newline        server = server-&gtnext;\newline        if (server)\newline            search_list = server-&gtmounts;\newline    }\newline    thread_rwlock_unlock (&ampyp_lock);\newline}\newline","This is similar to yp_remove, but we force a touch\newline attempt \newline","1679443","drv_dpf.c","static void drv_set_pixel(int x, int y, RGBA pix)\newline{\newline    int changed = 0;\newline\newline    int sx = DCOLS;\newline    int sy = DROWS;\newline    int lx = x % sx;\newline    int ly = y % sy;\newline\newline    if (dpf.flip) {\newline	// upside down orientation\newline	lx = DCOLS - 1 - lx;\newline	ly = DROWS - 1 - ly;\newline    }\newline\newline    if (dpf.rotate90) {\newline	// wrong Orientation, rotate\newline	int i = ly;\newline	ly = dpf.pheight - 1 - lx;\newline	lx = i;\newline    }\newline\newline    if (lx &lt 0 || lx &gt= (int) dpf.pwidth || ly &lt 0 || ly &gt= (int) dpf.pheight) {\newline	error(&quotdpf: x/y out of bounds (x=%d, y=%d, rot=%d, flip=%d, lx=%d, ly=%d)\\n&quot, x, y, dpf.rotate90, dpf.flip, lx,\newline	      ly);\newline	return;\newline    }\newline\newline    unsigned char c1 = _RGB565_0(pix);\newline    unsigned char c2 = _RGB565_1(pix);\newline    unsigned int i = (ly * dpf.pwidth + lx) * DPF_BPP;\newline    if (dpf.lcdBuf[i] != c1 || dpf.lcdBuf[i + 1] != c2) {\newline	dpf.lcdBuf[i] = c1;\newline	dpf.lcdBuf[i + 1] = c2;\newline	changed = 1;\newline    }\newline\newline    if (changed) {\newline	if (lx &lt dpf.minx)\newline	    dpf.minx = lx;\newline	if (lx &gt dpf.maxx)\newline	    dpf.maxx = lx;\newline	if (ly &lt dpf.miny)\newline	    dpf.miny = ly;\newline	if (ly &gt dpf.maxy)\newline	    dpf.maxy = ly;\newline    }\newline}\newline","\newline Set one pixel in lcdBuf.\newline \newline Respects orientation and updates dirty rectangle.\newline \newline in: x, y - pixel coordinates\newline pix - RGBA pixel value\newline out: -\newline \newline","6659902","cdw_dropdown.c","int cdw_dropdown_expanded_driver(CDW_DROPDOWN *dropdown)\newline{\newline	cdw_assert (dropdown, &quotERROR: cannot control NULL dropdown\\n&quot);\newline\newline	/* a bit customized, but otherwise standard ncurses menu driver code */\newline	int key = &#039a&#039;\newline	while ((key = wgetch(dropdown-&gtparent)) != ERR) {\newline		switch (key) {\newline		        case CDW_KEY_ESCAPE:\newline			/* including &#039q&#039 and &#039Q&#039, as suggested by RogerX */\newline		        case &#039q&#039:\newline		        case &#039Q&#039:\newline				return CDW_KEY_ESCAPE;\newline			case KEY_HOME:\newline				menu_driver(dropdown-&gtmenu, REQ_FIRST_ITEM);\newline				break;\newline			case KEY_END:\newline				menu_driver(dropdown-&gtmenu, REQ_LAST_ITEM);\newline				break;\newline			case KEY_DOWN:\newline				menu_driver(dropdown-&gtmenu, REQ_DOWN_ITEM);\newline				break;\newline			case KEY_UP:\newline				menu_driver(dropdown-&gtmenu, REQ_UP_ITEM);\newline				break;\newline			case CDW_KEY_ENTER:\newline			{\newline				ITEM *item = current_item(dropdown-&gtmenu);\newline				cdw_assert (item, &quotERROR: current item is NULL\\n&quot);\newline				/* remember index of selected item */\newline				dropdown-&gtcurrent_item_ind = item_index(item);\newline\newline				return CDW_KEY_ENTER;\newline			}\newline\newline			default: /* other (meaningless in this context) keys */\newline				break;\newline		}\newline\newline		redrawwin(dropdown-&gtmenu_window_sub);\newline		wrefresh(dropdown-&gtmenu_window_sub);\newline	}\newline\newline	return CDW_KEY_ESCAPE;\newline}\newline","\newline\\brief React to keys pressed by user when given dropdown is expanded (active)\newline\\date Function&#039s top-level comment reviewed on 2012-01-07\newline\\date Function&#039s body reviewed on 2012-01-07\newlineReact to following keys: HOME, END, DOWN, UP, ENTER, ESCAPE, Q, q, when\newlinegiven dropdown is active/focused.\newlineCaller of this function must make sure that \\p dropdown is valid.\newline\\param dropdown - active dropdown, on which user operates\newline\\return CDW_KEY_ENTER if user pressed ENTER,\newline\\return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q\newline \newline","2161427","message.c","static void message_write_searchaddr(struct buf *buf,\newline				     const struct address *addrlist)\newline{\newline    int prevaddr = 0;\newline    char* tmp;\newline\newline    while (addrlist) {\newline\newline	/* Handle RFC-822 group addresses */\newline	if (!addrlist-&gtdomain) {\newline	    if (addrlist-&gtmailbox) {\newline		if (prevaddr) buf_putc(buf, &#039,&#039);\newline		\newline		tmp = charset_parse_mimeheader(addrlist-&gtmailbox);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp);\newline		tmp = NULL;\newline		buf_putc(buf, &#039:&#039);\newline	\newline		/* Suppress a trailing comma */\newline		prevaddr = 0;\newline	    }\newline	    else {\newline		buf_putc(buf, &#039;&#039);\newline		prevaddr = 1;\newline	    }\newline	}\newline	else {\newline	    if (prevaddr) buf_putc(buf, &#039,&#039);\newline\newline	    if (addrlist-&gtname) {\newline		tmp = charset_parse_mimeheader(addrlist-&gtname);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp); tmp = NULL;\newline		buf_putc(buf, &#039 &#039);\newline	    }\newline\newline	    buf_putc(buf, &#039&lt&#039);\newline	    if (addrlist-&gtroute) {\newline		message_write_text_lcase(buf, addrlist-&gtroute);\newline		buf_putc(buf, &#039:&#039);\newline	    }\newline\newline	    message_write_text_lcase(buf, addrlist-&gtmailbox);\newline	    buf_putc(buf, &#039@&#039);\newline\newline	    message_write_text_lcase(buf, addrlist-&gtdomain);\newline	    buf_putc(buf, &#039&gt&#039);\newline	    prevaddr = 1;\newline	}\newline\newline	addrlist = addrlist-&gtnext;\newline    }\newline}\newline","\newline Unparse the address list &#039addrlist&#039 to &#039buf&#039\newline \newline","5857624","distopt.c","extern char *getdistoptlist()\newline{\newline	int i;\newline	static char buf[1024];\newline\newline	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {\newline		if (buf[0] == CNULL)\newline			(void) strcpy(buf, distoptinfo[i].do_name);\newline		else {\newline			(void) strcat(buf, &quot,&quot);\newline			(void) strcat(buf, distoptinfo[i].do_name);\newline		}\newline	}\newline\newline	return(buf);\newline}\newline","\newline Get a list of the Distfile Option Entries.\newline \newline","5202631","gsm-statemachine.c","static gn_error __sm_block_timeout(int waitfor, int t, gn_data *data, struct gn_statemachine *state)\newline{\newline	int retry;\newline	gn_state s;\newline	gn_error err;\newline	struct timeval now, next, timeout;\newline\newline	s = state-&gtcurrent_state;\newline	timeout.tv_sec = 3;\newline	timeout.tv_usec = 0;\newline	gettimeofday(&ampnow, NULL);\newline	for (retry = 0; retry &lt 2; retry++) {\newline		err = sm_wait_for(waitfor, data, state);\newline		if (err != GN_ERR_NONE) return err;\newline\newline		timeradd(&ampnow, &amptimeout, &ampnext);\newline		do {\newline			s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline			gettimeofday(&ampnow, NULL);\newline		} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s == GN_SM_MessageSent));\newline		if (s == GN_SM_WaitingForResponse || s == GN_SM_ResponseReceived) break;\newline\newline		if (state-&gtconfig.sm_retry) {\newline			dprintf(&quotSM_Block Retry - %d\\n&quot, retry);\newline			sm_reset(state);\newline			sm_message_send(state-&gtlast_msg_size, state-&gtlast_msg_type, state-&gtlast_msg, state);\newline		} else {\newline			/* If we don&#039t want retry, we should exit the loop */\newline			dprintf(&quotSM_Block: exiting the retry loop\\n&quot);\newline			break;\newline		}\newline	}\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	timeout.tv_sec = t / 10;\newline	timeout.tv_usec = (t % 10) * 100000;\newline	timeradd(&ampnow, &amptimeout, &ampnext);\newline	do {\newline		s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline		gettimeofday(&ampnow, NULL);\newline	} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s != GN_SM_ResponseReceived));\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	sm_reset(state);\newline\newline	return GN_ERR_TIMEOUT;\newline}\newline","This function is for convinience only.\newlineIt is called after SM_SendMessage and blocks until a response is received.\newlinet is in tenths of second.\newline \newline","4199543","qdocument.cpp","void QDocument::setLanguageDefinition(QLanguageDefinition *f)\newline{\newline	if ( m_impl )\newline		m_impl-&gtm_language = f;\newline}\newline","!\newline \\brief Set the language definition\newline \newline","4228286","ass_render.c","static double x2scr(ASS_Renderer *render_priv, double x)\newline{\newline    return x * render_priv-&gtorig_width_nocrop / render_priv-&gtfont_scale_x /\newline        render_priv-&gttrack-&gtPlayResX +\newline        FFMAX(render_priv-&gtsettings.left_margin, 0);\newline}\newline","\newline \\brief Mapping between script and screen coordinates\newline \newline","3514685","blas1.cpp","int main()\newline{\newline  //Change this type definition to double if your gpu supports that\newline  typedef float       ScalarType;\newline\newline  viennacl::tools::uniform_random_numbers&ltScalarType&gt randomNumber;\newline\newline  /**\newline  * &lth2&gt Scalar Operations &lt/h2&gt\newline  *\newline  * Although usually not very efficient because of PCI-Express latency, ViennaCL enables you to directly manipulate individual scalar values.\newline  * As such, a viennacl::scalar&ltdouble&gt behaves very similar to a normal `double`.\newline  *\newline  * Let us define a few CPU and ViennaCL scalars:\newline  *\newline  **/\newline  ScalarType s1 = ScalarType(3.1415926);   //note: writing ScalarType s1 = 3.1415926; leads to warnings with some compilers if ScalarType is &#039float&#039.\newline  ScalarType s2 = ScalarType(2.71763);\newline  ScalarType s3 = ScalarType(42.0);\newline\newline  viennacl::scalar&ltScalarType&gt vcl_s1;\newline  viennacl::scalar&ltScalarType&gt vcl_s2 = ScalarType(1.0);\newline  viennacl::scalar&ltScalarType&gt vcl_s3 = ScalarType(1.0);\newline\newline  /**\newline  * CPU scalars can be transparently assigned to GPU scalars and vice versa:\newline  **/\newline  std::cout &lt&lt &quotCopying a few scalars...&quot &lt&lt std::endl;\newline  vcl_s1 = s1;\newline  s2 = vcl_s2;\newline  vcl_s3 = s3;\newline\newline  /**\newline  * Operations between GPU scalars work just as for CPU scalars:\newline  * (Note that such single compute kernels on the GPU are considerably slower than on the CPU)\newline  **/\newline\newline  std::cout &lt&lt &quotManipulating a few scalars...&quot &lt&lt std::endl;\newline  std::cout &lt&lt &quotoperator +=&quot &lt&lt std::endl;\newline  s1 += s2;\newline  vcl_s1 += vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator *=&quot &lt&lt std::endl;\newline  s1 *= s2;\newline  vcl_s1 *= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator -=&quot &lt&lt std::endl;\newline  s1 -= s2;\newline  vcl_s1 -= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator /=&quot &lt&lt std::endl;\newline  s1 /= s2;\newline  vcl_s1 /= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator +&quot &lt&lt std::endl;\newline  s1 = s2 + s3;\newline  vcl_s1 = vcl_s2 + vcl_s3;\newline\newline  std::cout &lt&lt &quotmultiple operators&quot &lt&lt std::endl;\newline  s1 = s2 + s3 * s2 - s3 / s1;\newline  vcl_s1 = vcl_s2 + vcl_s3 * vcl_s2 - vcl_s3 / vcl_s1;\newline\newline\newline  /**\newline  * Operations can also be mixed:\newline  **/\newline  std::cout &lt&lt &quotmixed operations&quot &lt&lt std::endl;\newline  vcl_s1 = s1 * vcl_s2 + s3 - vcl_s3;\newline\newline\newline  /**\newline  * The output stream is overloaded as well for direct printing to e.g. a terminal:\newline  **/\newline\newline  std::cout &lt&lt &quotCPU scalar s3: &quot &lt&lt s3 &lt&lt std::endl;\newline  std::cout &lt&lt &quotGPU scalar vcl_s3: &quot &lt&lt vcl_s3 &lt&lt std::endl;\newline\newline\newline  /**\newline  *  &lth2&gtVector Operations&lt/h2&gt\newline  *\newline  * Define a few vectors (from STL and plain C) and viennacl::vectors\newline  **/\newline  std::vector&ltScalarType&gt      std_vec1(10);\newline  std::vector&ltScalarType&gt      std_vec2(10);\newline  ScalarType                   plain_vec3[10];  //plain C array\newline\newline  viennacl::vector&ltScalarType&gt vcl_vec1(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec2(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec3(10);\newline\newline  /**\newline  * Let us fill the CPU vectors with random values:\newline  **/\newline\newline  for (unsigned int i = 0; i &lt 10; ++i)\newline  {\newline    std_vec1[i] = randomNumber();\newline    vcl_vec2(i) = randomNumber();  //also works for GPU vectors, but is MUCH slower (approx. factor 10.000) than the CPU analogue\newline    plain_vec3[i] = randomNumber();\newline  }\newline\newline  /**\newline  * Copy the CPU vectors to the GPU vectors and vice versa\newline  **/\newline  viennacl::copy(std_vec1.begin(), std_vec1.end(), vcl_vec1.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), std_vec2.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2, std_vec2);                                 //using the short hand notation for objects that provide .begin() and .end() members\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), plain_vec3);       //copy to plain C vector\newline\newline  /**\newline  * Also partial copies by providing the corresponding iterators are possible:\newline  **/\newline  viennacl::copy(std_vec1.begin() + 4, std_vec1.begin() + 8, vcl_vec1.begin() + 4);   //cpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, vcl_vec2.begin() + 1);   //gpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, std_vec1.begin() + 1);   //gpu to cpu\newline\newline  /**\newline  * Compute the inner product of two GPU vectors and write the result to either CPU or GPU\newline  **/\newline  vcl_s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s2 = viennacl::linalg::inner_prod(std_vec1, std_vec2); //inner prod can also be used with std::vector (computations are carried out on CPU then)\newline\newline  /**\newline  * Compute norms:\newline  **/\newline  s1 = viennacl::linalg::norm_1(vcl_vec1);\newline  vcl_s2 = viennacl::linalg::norm_2(vcl_vec2);\newline  s3 = viennacl::linalg::norm_inf(vcl_vec3);\newline\newline\newline  /**\newline  * Plane rotation of two vectors:\newline  **/\newline  viennacl::linalg::plane_rotation(vcl_vec1, vcl_vec2, 1.1f, 2.3f);\newline\newline  /**\newline  * Use viennacl::vector via the overloaded operators just as you would write it on paper:\newline  **/\newline\newline  //simple expression:\newline  vcl_vec1 = vcl_s1 * vcl_vec2 / vcl_s3;\newline\newline  //more complicated expression:\newline  vcl_vec1 = vcl_vec2 / vcl_s3 + vcl_s2 * (vcl_vec1 - vcl_s2 * vcl_vec2);\newline\newline\newline  /**\newline  * Swap the content of two vectors without a temporary vector:\newline  **/\newline  viennacl::swap(vcl_vec1, vcl_vec2);  //swaps all entries in memory\newline  viennacl::fast_swap(vcl_vec1, vcl_vec2); //swaps OpenCL memory handles only\newline\newline  /**\newline  * The vectors can also be cleared directly:\newline  **/\newline  vcl_vec1.clear();\newline  vcl_vec2.clear();\newline\newline  /**\newline  *  That&#039s it, the tutorial is completed.\newline  **/\newline  std::cout &lt&lt &quot!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot &lt&lt std::endl;\newline\newline  return EXIT_SUCCESS;\newline}\newline","\newline In this tutorial we do not need additional auxiliary functions, allowing us to start right with main():\newline \newline","1559409","gzlib.c","unsigned ZLIB_INTERNAL gz_intmax()\newline{\newline    unsigned p, q;\newline\newline    p = 1;\newline    do {\newline        q = p;\newline        p &lt&lt= 1;\newline        p++;\newline    } while (p &gt q);\newline    return q &gt&gt 1;\newline}\newline","portably return maximum value for an int (when limits.h presumed not\newlineavailable) -- we need to do this to cover cases where 2&#039s complement not\newlineused, since C standard permits 1&#039s complement and sign-bit representations,\newlineotherwise we could just use ((unsigned)-1) &gt&gt 1 \newline","2795766","libfdata_tree_node.c","int libfdata_tree_node_set_parent_node(\newline     libfdata_tree_node_t *node,\newline     libfdata_tree_node_t *parent_node,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_parent_node&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	internal_tree_node-&gtparent_node = parent_node;\newline\newline	return( 1 );\newline}\newline","Sets the parent node\newline Returns 1 if successful or -1 on error\newline \newline","1480622","uuid.c","char *xmpp_uuid_gen(xmpp_ctx_t *ctx)\newline{\newline    char *uuid;\newline\newline    uuid = xmpp_alloc(ctx, XMPP_UUID_LEN + 1);\newline    if (uuid != NULL) {\newline        crypto_uuid_gen(ctx, uuid);\newline    }\newline    return uuid;\newline}\newline","Generate UUID version 4.\newline This function allocates memory for the resulting string and must be freed\newline with xmpp_free().\newline \newline @param ctx a Strophe context object\newline \newline @return ASCIIZ string\newline \newline","3279849","lm_ssl.c","value lm_ssl_get_addr(value v_info)\newline{\newline    SslInfo *info;\newline    struct sockaddr_in sin;\newline    socklen_t size;\newline    value a, addr;\newline\newline    /* Get the address */\newline    info = SslInfo_val(v_info);\newline    size = sizeof(sin);\newline    if(getsockname(info-&gtfd, (struct sockaddr *) &ampsin, &ampsize) &lt 0 || sin.sin_family != AF_INET) {\newline        uerr(&quotlm_ssl_get_addr: getsockname&quot);\newline    }\newline\newline    /* Allocate the address */\newline    a = alloc_inet_addr(sin.sin_addr.s_addr);\newline    Begin_root(a);\newline    addr = alloc_small(2, 0);\newline    Field(addr, 0) = a;\newline    Field(addr, 1) = Val_int(ntohs(sin.sin_port));\newline    End_roots();\newline    return addr;\newline}\newline","\newline Get the address of the socket.\newline \newline","1785305","net_udp.c","char *NET_ErrorString (void)\newline{\newline	int		code;\newline\newline	code = errno;\newline	return strerror (code);\newline}\newline","\newline====================\newlineNET_ErrorString\newline====================\newline \newline","12431","rexxapi.c","APIRET APIENTRY RexxRegisterFunctionExe(\newline   PCSZ name,\newline   RexxFunctionHandler *EntryPoint )\newline{\newline   APIRET rc=RXFUNC_NOTREG;\newline\newline   if ( InterpreterIdx == -1 )\newline      LoadInterpreter();\newline\newline   if (Trace)\newline   {\newline      TraceString( &quot%s: Name \\&quot%s\\&quot Entrypoint %x &quot,\newline         &quotRexxRegisterFunctionExe()&quot,\newline         name,\newline         EntryPoint );\newline\newline   }\newline   if (ORexxRegisterFunctionExe)\newline      rc = (*ORexxRegisterFunctionExe)(\newline         (PSZ)       name,\newline         (PFN)       EntryPoint );\newline   if (Trace)\newline   {\newline      TraceString( &quot&lt=&gt Result: %d\\n&quot, rc );\newline   }\newline   return rc;\newline}\newline","\newline External functions\newline \newline","4912373","presence.c","void setPluginID(void * pluginID) \newline{\newline	_PluginID=pluginID;\newline}\newline","\newline Plugin identity mgmt\newline \newline","5793875","eng_main.c","void eng_pic_set_x(eng_obj *o, guint16 x)  {\newline\newline	if(!o)  return;\newline\newline	if(x != o-&gtx) {\newline\newline		o-&gtx = x;\newline		o-&gtchange = 1;\newline	}\newline}\newline","---- set X pos of pic \newline","5531993","isl_schedule_tree.c","__isl_give isl_schedule_tree *isl_schedule_tree_append_to_leaves(\newline	__isl_take isl_schedule_tree *tree1,\newline	__isl_take isl_schedule_tree *tree2)\newline{\newline	int i, n;\newline\newline	if (!tree1 || !tree2)\newline		goto error;\newline	n = isl_schedule_tree_n_children(tree1);\newline	if (n == 0) {\newline		isl_schedule_tree_list *list;\newline		list = isl_schedule_tree_list_from_schedule_tree(tree2);\newline		tree1 = isl_schedule_tree_set_children(tree1, list);\newline		return tree1;\newline	}\newline	for (i = 0; i &lt n; ++i) {\newline		isl_schedule_tree *child;\newline\newline		child = isl_schedule_tree_get_child(tree1, i);\newline		child = isl_schedule_tree_append_to_leaves(child,\newline					isl_schedule_tree_copy(tree2));\newline		tree1 = isl_schedule_tree_replace_child(tree1, i, child);\newline	}\newline\newline	isl_schedule_tree_free(tree2);\newline	return tree1;\newlineerror:\newline	isl_schedule_tree_free(tree1);\newline	isl_schedule_tree_free(tree2);\newline	return NULL;\newline}\newline","Attach &quottree2&quot at each of the leaves of &quottree1&quot.\newline \newline If &quottree1&quot does not have any explicit children, then make &quottree2&quot\newline its single child. Otherwise, attach &quottree2&quot to the leaves of\newline each of the children of &quottree1&quot.\newline \newline","1260019","attrs.c","AttVal* TY_(AttrGetById)( Node* node, TidyAttrId id )\newline{\newline   AttVal* av;\newline   for ( av = node-&gtattributes; av; av = av-&gtnext )\newline   {\newline     if ( AttrIsId(av, id) )\newline         return av;\newline   }\newline   return NULL;\newline}\newline","Locate attributes by type \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","writes information in the widget out to a contrast.txt file","Mapping between script and screen coordinates","not need additional auxiliary functions, allowing us to start right with main():","portably return maximum value for an int","Sets the parent node","This function allocates memory for the resulting string","Get the address of the socket.","NET_ErrorString","External functions","Plugin identity mgmt","set X pos of pic","Test that H5PTis_varlen works correctly","Attach ""tree2"" at each of the leaves of ""tree1"".","Locate attributes by type","similar to yp_remove, but we force a touchattempt","Set one pixel in lcdBuf.","React to following keys: HOME, END, DOWN, UP, ENTER, ESCAPE, Q, q,","Unparse the address list 'addrlist' to 'buf'","Get a list of the Distfile Option Entries.","blocks until a response is received.","Set the language definition"
"3QXFBUZ4ZKGKGGRN07TE0Y28WU4UGI","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3NGI5ARFTT5C7GQHR4EI8O7S2BF1PH","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:09:35 PDT 2019","Wed Apr 17 12:15:22 PDT 2019","Fri Apr 19 12:15:22 PDT 2019","2019-04-19 19:16:21 UTC","","","347","100% (27/27)","100% (27/27)","100% (27/27)","1526179","vbcontrast.cpp","void VBContrastParamScalingWidget::WriteContrastInfo( string stemname )\newline{\newline  ofstream output;\newline  \newline//  output.open((stemname + &quot.contrasts&quot).c_str());\newline  int pos = stemname.rfind(&quot/&quot);\newline  stemname = stemname.substr(0, ++pos);\newline  output.open((stemname + &quotcontrasts.txt&quot).c_str());\newline  if (output.good())\newline  {\newline    VBContrast* contrast;\newline    Q3ListViewItemIterator iter(mContrastList);\newline    while (iter.current())\newline    {\newline      contrast = mContrastList-&gtcontrastAt(*iter);\newline      output &lt&lt contrast-&gtname &lt&lt &quot &quot\newline             &lt&lt contrast-&gtscale &lt&lt &quot vec &quot;\newline      \newline      for (uint32 i=0; i&ltcontrast-&gtcontrast.size(); ++i)\newline        // only write out covariates of interest...\newline        if (mGLMInfo-&gtcnames[i][0] == &#039I&#039) output &lt&lt contrast-&gtcontrast[i] &lt&lt &quot &quot;\newline      \newline      output &lt&lt endl;\newline      ++iter;\newline    }\newline  }\newline}\newline","\newline WriteContrastInfo writes information in the widget out to a contrast.txt file\newline in the glm directory.\newline \newline","4366568","test_packet_vlen.c","static int test_H5PTis_varlen(void)\newline{\newline    hid_t   fid=H5I_INVALID_HID;	/* Test file identifier */\newline    hid_t   ptable=H5I_INVALID_HID;	/* Packet table identifier */\newline    herr_t  ret;		/* Returned status from a callee */\newline\newline    TESTING(&quotH5PTis_varlen&quot);\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Create a new table */\newline    ptable = H5PTcreate(fid, PT_FIXED_LEN, H5T_STD_I32BE, (hsize_t)100, H5P_DEFAULT);\newline\newline    /* Ensure that PT is created successfully */\newline    if (ptable == H5I_INVALID_HID)\newline	goto error;\newline\newline    /* Close the packet table */\newline    ret = H5PTclose(ptable);\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    /* Open the file */\newline    fid = H5Fopen(TEST_FILE_NAME, H5F_ACC_RDWR, H5P_DEFAULT);\newline    if (fid &lt 0)\newline	goto error;\newline\newline    /* Open each packet table, and verify that H5PTis_varlen returns correct\newline       type for each table */\newline    ret = verify_ptlengthtype(fid, PT_VLEN_ATOMIC, 1); /* vlen of atomic */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_COMP, 1); /* vlen of compound */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_COMP_VLEN, 0); /* compound of vlen, no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_VLEN_VLEN, 1); /* vlen of vlen */\newline    if (ret &lt 0)\newline	goto error;\newline    ret = verify_ptlengthtype(fid, PT_FIXED_LEN, 0); /* no vlen */\newline    if (ret &lt 0)\newline	goto error;\newline\newline    /* Close the file */\newline    if (H5Fclose(fid) &lt 0)\newline	goto error;\newline\newline    PASSED();\newline    return SUCCEED;\newline\newlineerror: /* An error has occurred.  Clean up and exit. */\newline    if (fid &gt 0) H5Fclose(fid);\newline    H5_FAILED();\newline    return FAIL;\newline} /* test_H5PTis_varlen */\newline","-------------------------------------------------------------------------\newline test_H5PTis_varlen(): Test that H5PTis_varlen works correctly on both\newline fixed- and variable-length packet tables.\newline \newline Description:\newline - Added a fixed-length packet table to the file for variety\newline - Use the helper funtion verify_ptlengthtype to test H5PTis_varlen\newline on each packet table.\newline \newline 2016/01/27 -BMR\newline -------------------------------------------------------------------------\newline \newline","4396668","yp.c","void yp_touch (const char *mount)\newline{\newline    struct yp_server *server = (struct yp_server *)active_yps;\newline    ypdata_t *search_list = NULL;\newline\newline    thread_rwlock_rlock (&ampyp_lock);\newline    if (server)\newline        search_list = server-&gtmounts;\newline\newline    while (server)\newline    {\newline        ypdata_t *yp = find_yp_mount (search_list, mount);\newline        if (yp)\newline        {\newline            /* we may of found old entries not purged yet, so skip them */\newline            if (yp-&gtrelease != 0 || yp-&gtremove != 0)\newline            {\newline                search_list = yp-&gtnext;\newline                continue;\newline            }\newline            /* don&#039t update the directory if there is a touch scheduled soon */\newline            if (yp-&gtprocess == do_yp_touch &amp&amp now + yp-&gttouch_interval - yp-&gtnext_update &gt 60)\newline                yp-&gtnext_update = now + 3;\newline        }\newline        server = server-&gtnext;\newline        if (server)\newline            search_list = server-&gtmounts;\newline    }\newline    thread_rwlock_unlock (&ampyp_lock);\newline}\newline","This is similar to yp_remove, but we force a touch\newline attempt \newline","1679443","drv_dpf.c","static void drv_set_pixel(int x, int y, RGBA pix)\newline{\newline    int changed = 0;\newline\newline    int sx = DCOLS;\newline    int sy = DROWS;\newline    int lx = x % sx;\newline    int ly = y % sy;\newline\newline    if (dpf.flip) {\newline	// upside down orientation\newline	lx = DCOLS - 1 - lx;\newline	ly = DROWS - 1 - ly;\newline    }\newline\newline    if (dpf.rotate90) {\newline	// wrong Orientation, rotate\newline	int i = ly;\newline	ly = dpf.pheight - 1 - lx;\newline	lx = i;\newline    }\newline\newline    if (lx &lt 0 || lx &gt= (int) dpf.pwidth || ly &lt 0 || ly &gt= (int) dpf.pheight) {\newline	error(&quotdpf: x/y out of bounds (x=%d, y=%d, rot=%d, flip=%d, lx=%d, ly=%d)\\n&quot, x, y, dpf.rotate90, dpf.flip, lx,\newline	      ly);\newline	return;\newline    }\newline\newline    unsigned char c1 = _RGB565_0(pix);\newline    unsigned char c2 = _RGB565_1(pix);\newline    unsigned int i = (ly * dpf.pwidth + lx) * DPF_BPP;\newline    if (dpf.lcdBuf[i] != c1 || dpf.lcdBuf[i + 1] != c2) {\newline	dpf.lcdBuf[i] = c1;\newline	dpf.lcdBuf[i + 1] = c2;\newline	changed = 1;\newline    }\newline\newline    if (changed) {\newline	if (lx &lt dpf.minx)\newline	    dpf.minx = lx;\newline	if (lx &gt dpf.maxx)\newline	    dpf.maxx = lx;\newline	if (ly &lt dpf.miny)\newline	    dpf.miny = ly;\newline	if (ly &gt dpf.maxy)\newline	    dpf.maxy = ly;\newline    }\newline}\newline","\newline Set one pixel in lcdBuf.\newline \newline Respects orientation and updates dirty rectangle.\newline \newline in: x, y - pixel coordinates\newline pix - RGBA pixel value\newline out: -\newline \newline","6659902","cdw_dropdown.c","int cdw_dropdown_expanded_driver(CDW_DROPDOWN *dropdown)\newline{\newline	cdw_assert (dropdown, &quotERROR: cannot control NULL dropdown\\n&quot);\newline\newline	/* a bit customized, but otherwise standard ncurses menu driver code */\newline	int key = &#039a&#039;\newline	while ((key = wgetch(dropdown-&gtparent)) != ERR) {\newline		switch (key) {\newline		        case CDW_KEY_ESCAPE:\newline			/* including &#039q&#039 and &#039Q&#039, as suggested by RogerX */\newline		        case &#039q&#039:\newline		        case &#039Q&#039:\newline				return CDW_KEY_ESCAPE;\newline			case KEY_HOME:\newline				menu_driver(dropdown-&gtmenu, REQ_FIRST_ITEM);\newline				break;\newline			case KEY_END:\newline				menu_driver(dropdown-&gtmenu, REQ_LAST_ITEM);\newline				break;\newline			case KEY_DOWN:\newline				menu_driver(dropdown-&gtmenu, REQ_DOWN_ITEM);\newline				break;\newline			case KEY_UP:\newline				menu_driver(dropdown-&gtmenu, REQ_UP_ITEM);\newline				break;\newline			case CDW_KEY_ENTER:\newline			{\newline				ITEM *item = current_item(dropdown-&gtmenu);\newline				cdw_assert (item, &quotERROR: current item is NULL\\n&quot);\newline				/* remember index of selected item */\newline				dropdown-&gtcurrent_item_ind = item_index(item);\newline\newline				return CDW_KEY_ENTER;\newline			}\newline\newline			default: /* other (meaningless in this context) keys */\newline				break;\newline		}\newline\newline		redrawwin(dropdown-&gtmenu_window_sub);\newline		wrefresh(dropdown-&gtmenu_window_sub);\newline	}\newline\newline	return CDW_KEY_ESCAPE;\newline}\newline","\newline\\brief React to keys pressed by user when given dropdown is expanded (active)\newline\\date Function&#039s top-level comment reviewed on 2012-01-07\newline\\date Function&#039s body reviewed on 2012-01-07\newlineReact to following keys: HOME, END, DOWN, UP, ENTER, ESCAPE, Q, q, when\newlinegiven dropdown is active/focused.\newlineCaller of this function must make sure that \\p dropdown is valid.\newline\\param dropdown - active dropdown, on which user operates\newline\\return CDW_KEY_ENTER if user pressed ENTER,\newline\\return CDW_KEY_ESCAPE if user pressed ESCAPE, Q or q\newline \newline","2161427","message.c","static void message_write_searchaddr(struct buf *buf,\newline				     const struct address *addrlist)\newline{\newline    int prevaddr = 0;\newline    char* tmp;\newline\newline    while (addrlist) {\newline\newline	/* Handle RFC-822 group addresses */\newline	if (!addrlist-&gtdomain) {\newline	    if (addrlist-&gtmailbox) {\newline		if (prevaddr) buf_putc(buf, &#039,&#039);\newline		\newline		tmp = charset_parse_mimeheader(addrlist-&gtmailbox);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp);\newline		tmp = NULL;\newline		buf_putc(buf, &#039:&#039);\newline	\newline		/* Suppress a trailing comma */\newline		prevaddr = 0;\newline	    }\newline	    else {\newline		buf_putc(buf, &#039;&#039);\newline		prevaddr = 1;\newline	    }\newline	}\newline	else {\newline	    if (prevaddr) buf_putc(buf, &#039,&#039);\newline\newline	    if (addrlist-&gtname) {\newline		tmp = charset_parse_mimeheader(addrlist-&gtname);\newline		buf_appendcstr(buf, tmp);\newline		free(tmp); tmp = NULL;\newline		buf_putc(buf, &#039 &#039);\newline	    }\newline\newline	    buf_putc(buf, &#039&lt&#039);\newline	    if (addrlist-&gtroute) {\newline		message_write_text_lcase(buf, addrlist-&gtroute);\newline		buf_putc(buf, &#039:&#039);\newline	    }\newline\newline	    message_write_text_lcase(buf, addrlist-&gtmailbox);\newline	    buf_putc(buf, &#039@&#039);\newline\newline	    message_write_text_lcase(buf, addrlist-&gtdomain);\newline	    buf_putc(buf, &#039&gt&#039);\newline	    prevaddr = 1;\newline	}\newline\newline	addrlist = addrlist-&gtnext;\newline    }\newline}\newline","\newline Unparse the address list &#039addrlist&#039 to &#039buf&#039\newline \newline","5857624","distopt.c","extern char *getdistoptlist()\newline{\newline	int i;\newline	static char buf[1024];\newline\newline	for (i = 0, buf[0] = CNULL; distoptinfo[i].do_name; ++i) {\newline		if (buf[0] == CNULL)\newline			(void) strcpy(buf, distoptinfo[i].do_name);\newline		else {\newline			(void) strcat(buf, &quot,&quot);\newline			(void) strcat(buf, distoptinfo[i].do_name);\newline		}\newline	}\newline\newline	return(buf);\newline}\newline","\newline Get a list of the Distfile Option Entries.\newline \newline","5202631","gsm-statemachine.c","static gn_error __sm_block_timeout(int waitfor, int t, gn_data *data, struct gn_statemachine *state)\newline{\newline	int retry;\newline	gn_state s;\newline	gn_error err;\newline	struct timeval now, next, timeout;\newline\newline	s = state-&gtcurrent_state;\newline	timeout.tv_sec = 3;\newline	timeout.tv_usec = 0;\newline	gettimeofday(&ampnow, NULL);\newline	for (retry = 0; retry &lt 2; retry++) {\newline		err = sm_wait_for(waitfor, data, state);\newline		if (err != GN_ERR_NONE) return err;\newline\newline		timeradd(&ampnow, &amptimeout, &ampnext);\newline		do {\newline			s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline			gettimeofday(&ampnow, NULL);\newline		} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s == GN_SM_MessageSent));\newline		if (s == GN_SM_WaitingForResponse || s == GN_SM_ResponseReceived) break;\newline\newline		if (state-&gtconfig.sm_retry) {\newline			dprintf(&quotSM_Block Retry - %d\\n&quot, retry);\newline			sm_reset(state);\newline			sm_message_send(state-&gtlast_msg_size, state-&gtlast_msg_type, state-&gtlast_msg, state);\newline		} else {\newline			/* If we don&#039t want retry, we should exit the loop */\newline			dprintf(&quotSM_Block: exiting the retry loop\\n&quot);\newline			break;\newline		}\newline	}\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	timeout.tv_sec = t / 10;\newline	timeout.tv_usec = (t % 10) * 100000;\newline	timeradd(&ampnow, &amptimeout, &ampnext);\newline	do {\newline		s = gn_sm_loop(1, state);  /* Timeout=100ms */\newline		gettimeofday(&ampnow, NULL);\newline	} while (timercmp(&ampnext, &ampnow, &gt) &amp&amp (s != GN_SM_ResponseReceived));\newline\newline	if (s == GN_SM_ResponseReceived)\newline		return sm_error_get(waitfor, state);\newline\newline	sm_reset(state);\newline\newline	return GN_ERR_TIMEOUT;\newline}\newline","This function is for convinience only.\newlineIt is called after SM_SendMessage and blocks until a response is received.\newlinet is in tenths of second.\newline \newline","4199543","qdocument.cpp","void QDocument::setLanguageDefinition(QLanguageDefinition *f)\newline{\newline	if ( m_impl )\newline		m_impl-&gtm_language = f;\newline}\newline","!\newline \\brief Set the language definition\newline \newline","4228286","ass_render.c","static double x2scr(ASS_Renderer *render_priv, double x)\newline{\newline    return x * render_priv-&gtorig_width_nocrop / render_priv-&gtfont_scale_x /\newline        render_priv-&gttrack-&gtPlayResX +\newline        FFMAX(render_priv-&gtsettings.left_margin, 0);\newline}\newline","\newline \\brief Mapping between script and screen coordinates\newline \newline","3514685","blas1.cpp","int main()\newline{\newline  //Change this type definition to double if your gpu supports that\newline  typedef float       ScalarType;\newline\newline  viennacl::tools::uniform_random_numbers&ltScalarType&gt randomNumber;\newline\newline  /**\newline  * &lth2&gt Scalar Operations &lt/h2&gt\newline  *\newline  * Although usually not very efficient because of PCI-Express latency, ViennaCL enables you to directly manipulate individual scalar values.\newline  * As such, a viennacl::scalar&ltdouble&gt behaves very similar to a normal `double`.\newline  *\newline  * Let us define a few CPU and ViennaCL scalars:\newline  *\newline  **/\newline  ScalarType s1 = ScalarType(3.1415926);   //note: writing ScalarType s1 = 3.1415926; leads to warnings with some compilers if ScalarType is &#039float&#039.\newline  ScalarType s2 = ScalarType(2.71763);\newline  ScalarType s3 = ScalarType(42.0);\newline\newline  viennacl::scalar&ltScalarType&gt vcl_s1;\newline  viennacl::scalar&ltScalarType&gt vcl_s2 = ScalarType(1.0);\newline  viennacl::scalar&ltScalarType&gt vcl_s3 = ScalarType(1.0);\newline\newline  /**\newline  * CPU scalars can be transparently assigned to GPU scalars and vice versa:\newline  **/\newline  std::cout &lt&lt &quotCopying a few scalars...&quot &lt&lt std::endl;\newline  vcl_s1 = s1;\newline  s2 = vcl_s2;\newline  vcl_s3 = s3;\newline\newline  /**\newline  * Operations between GPU scalars work just as for CPU scalars:\newline  * (Note that such single compute kernels on the GPU are considerably slower than on the CPU)\newline  **/\newline\newline  std::cout &lt&lt &quotManipulating a few scalars...&quot &lt&lt std::endl;\newline  std::cout &lt&lt &quotoperator +=&quot &lt&lt std::endl;\newline  s1 += s2;\newline  vcl_s1 += vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator *=&quot &lt&lt std::endl;\newline  s1 *= s2;\newline  vcl_s1 *= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator -=&quot &lt&lt std::endl;\newline  s1 -= s2;\newline  vcl_s1 -= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator /=&quot &lt&lt std::endl;\newline  s1 /= s2;\newline  vcl_s1 /= vcl_s2;\newline\newline  std::cout &lt&lt &quotoperator +&quot &lt&lt std::endl;\newline  s1 = s2 + s3;\newline  vcl_s1 = vcl_s2 + vcl_s3;\newline\newline  std::cout &lt&lt &quotmultiple operators&quot &lt&lt std::endl;\newline  s1 = s2 + s3 * s2 - s3 / s1;\newline  vcl_s1 = vcl_s2 + vcl_s3 * vcl_s2 - vcl_s3 / vcl_s1;\newline\newline\newline  /**\newline  * Operations can also be mixed:\newline  **/\newline  std::cout &lt&lt &quotmixed operations&quot &lt&lt std::endl;\newline  vcl_s1 = s1 * vcl_s2 + s3 - vcl_s3;\newline\newline\newline  /**\newline  * The output stream is overloaded as well for direct printing to e.g. a terminal:\newline  **/\newline\newline  std::cout &lt&lt &quotCPU scalar s3: &quot &lt&lt s3 &lt&lt std::endl;\newline  std::cout &lt&lt &quotGPU scalar vcl_s3: &quot &lt&lt vcl_s3 &lt&lt std::endl;\newline\newline\newline  /**\newline  *  &lth2&gtVector Operations&lt/h2&gt\newline  *\newline  * Define a few vectors (from STL and plain C) and viennacl::vectors\newline  **/\newline  std::vector&ltScalarType&gt      std_vec1(10);\newline  std::vector&ltScalarType&gt      std_vec2(10);\newline  ScalarType                   plain_vec3[10];  //plain C array\newline\newline  viennacl::vector&ltScalarType&gt vcl_vec1(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec2(10);\newline  viennacl::vector&ltScalarType&gt vcl_vec3(10);\newline\newline  /**\newline  * Let us fill the CPU vectors with random values:\newline  **/\newline\newline  for (unsigned int i = 0; i &lt 10; ++i)\newline  {\newline    std_vec1[i] = randomNumber();\newline    vcl_vec2(i) = randomNumber();  //also works for GPU vectors, but is MUCH slower (approx. factor 10.000) than the CPU analogue\newline    plain_vec3[i] = randomNumber();\newline  }\newline\newline  /**\newline  * Copy the CPU vectors to the GPU vectors and vice versa\newline  **/\newline  viennacl::copy(std_vec1.begin(), std_vec1.end(), vcl_vec1.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), std_vec2.begin()); //either the STL way\newline  viennacl::copy(vcl_vec2, std_vec2);                                 //using the short hand notation for objects that provide .begin() and .end() members\newline  viennacl::copy(vcl_vec2.begin(), vcl_vec2.end(), plain_vec3);       //copy to plain C vector\newline\newline  /**\newline  * Also partial copies by providing the corresponding iterators are possible:\newline  **/\newline  viennacl::copy(std_vec1.begin() + 4, std_vec1.begin() + 8, vcl_vec1.begin() + 4);   //cpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, vcl_vec2.begin() + 1);   //gpu to gpu\newline  viennacl::copy(vcl_vec1.begin() + 4, vcl_vec1.begin() + 8, std_vec1.begin() + 1);   //gpu to cpu\newline\newline  /**\newline  * Compute the inner product of two GPU vectors and write the result to either CPU or GPU\newline  **/\newline  vcl_s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s1 = viennacl::linalg::inner_prod(vcl_vec1, vcl_vec2);\newline  s2 = viennacl::linalg::inner_prod(std_vec1, std_vec2); //inner prod can also be used with std::vector (computations are carried out on CPU then)\newline\newline  /**\newline  * Compute norms:\newline  **/\newline  s1 = viennacl::linalg::norm_1(vcl_vec1);\newline  vcl_s2 = viennacl::linalg::norm_2(vcl_vec2);\newline  s3 = viennacl::linalg::norm_inf(vcl_vec3);\newline\newline\newline  /**\newline  * Plane rotation of two vectors:\newline  **/\newline  viennacl::linalg::plane_rotation(vcl_vec1, vcl_vec2, 1.1f, 2.3f);\newline\newline  /**\newline  * Use viennacl::vector via the overloaded operators just as you would write it on paper:\newline  **/\newline\newline  //simple expression:\newline  vcl_vec1 = vcl_s1 * vcl_vec2 / vcl_s3;\newline\newline  //more complicated expression:\newline  vcl_vec1 = vcl_vec2 / vcl_s3 + vcl_s2 * (vcl_vec1 - vcl_s2 * vcl_vec2);\newline\newline\newline  /**\newline  * Swap the content of two vectors without a temporary vector:\newline  **/\newline  viennacl::swap(vcl_vec1, vcl_vec2);  //swaps all entries in memory\newline  viennacl::fast_swap(vcl_vec1, vcl_vec2); //swaps OpenCL memory handles only\newline\newline  /**\newline  * The vectors can also be cleared directly:\newline  **/\newline  vcl_vec1.clear();\newline  vcl_vec2.clear();\newline\newline  /**\newline  *  That&#039s it, the tutorial is completed.\newline  **/\newline  std::cout &lt&lt &quot!!!! TUTORIAL COMPLETED SUCCESSFULLY !!!!&quot &lt&lt std::endl;\newline\newline  return EXIT_SUCCESS;\newline}\newline","\newline In this tutorial we do not need additional auxiliary functions, allowing us to start right with main():\newline \newline","1559409","gzlib.c","unsigned ZLIB_INTERNAL gz_intmax()\newline{\newline    unsigned p, q;\newline\newline    p = 1;\newline    do {\newline        q = p;\newline        p &lt&lt= 1;\newline        p++;\newline    } while (p &gt q);\newline    return q &gt&gt 1;\newline}\newline","portably return maximum value for an int (when limits.h presumed not\newlineavailable) -- we need to do this to cover cases where 2&#039s complement not\newlineused, since C standard permits 1&#039s complement and sign-bit representations,\newlineotherwise we could just use ((unsigned)-1) &gt&gt 1 \newline","2795766","libfdata_tree_node.c","int libfdata_tree_node_set_parent_node(\newline     libfdata_tree_node_t *node,\newline     libfdata_tree_node_t *parent_node,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_parent_node&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	internal_tree_node-&gtparent_node = parent_node;\newline\newline	return( 1 );\newline}\newline","Sets the parent node\newline Returns 1 if successful or -1 on error\newline \newline","1480622","uuid.c","char *xmpp_uuid_gen(xmpp_ctx_t *ctx)\newline{\newline    char *uuid;\newline\newline    uuid = xmpp_alloc(ctx, XMPP_UUID_LEN + 1);\newline    if (uuid != NULL) {\newline        crypto_uuid_gen(ctx, uuid);\newline    }\newline    return uuid;\newline}\newline","Generate UUID version 4.\newline This function allocates memory for the resulting string and must be freed\newline with xmpp_free().\newline \newline @param ctx a Strophe context object\newline \newline @return ASCIIZ string\newline \newline","3279849","lm_ssl.c","value lm_ssl_get_addr(value v_info)\newline{\newline    SslInfo *info;\newline    struct sockaddr_in sin;\newline    socklen_t size;\newline    value a, addr;\newline\newline    /* Get the address */\newline    info = SslInfo_val(v_info);\newline    size = sizeof(sin);\newline    if(getsockname(info-&gtfd, (struct sockaddr *) &ampsin, &ampsize) &lt 0 || sin.sin_family != AF_INET) {\newline        uerr(&quotlm_ssl_get_addr: getsockname&quot);\newline    }\newline\newline    /* Allocate the address */\newline    a = alloc_inet_addr(sin.sin_addr.s_addr);\newline    Begin_root(a);\newline    addr = alloc_small(2, 0);\newline    Field(addr, 0) = a;\newline    Field(addr, 1) = Val_int(ntohs(sin.sin_port));\newline    End_roots();\newline    return addr;\newline}\newline","\newline Get the address of the socket.\newline \newline","1785305","net_udp.c","char *NET_ErrorString (void)\newline{\newline	int		code;\newline\newline	code = errno;\newline	return strerror (code);\newline}\newline","\newline====================\newlineNET_ErrorString\newline====================\newline \newline","12431","rexxapi.c","APIRET APIENTRY RexxRegisterFunctionExe(\newline   PCSZ name,\newline   RexxFunctionHandler *EntryPoint )\newline{\newline   APIRET rc=RXFUNC_NOTREG;\newline\newline   if ( InterpreterIdx == -1 )\newline      LoadInterpreter();\newline\newline   if (Trace)\newline   {\newline      TraceString( &quot%s: Name \\&quot%s\\&quot Entrypoint %x &quot,\newline         &quotRexxRegisterFunctionExe()&quot,\newline         name,\newline         EntryPoint );\newline\newline   }\newline   if (ORexxRegisterFunctionExe)\newline      rc = (*ORexxRegisterFunctionExe)(\newline         (PSZ)       name,\newline         (PFN)       EntryPoint );\newline   if (Trace)\newline   {\newline      TraceString( &quot&lt=&gt Result: %d\\n&quot, rc );\newline   }\newline   return rc;\newline}\newline","\newline External functions\newline \newline","4912373","presence.c","void setPluginID(void * pluginID) \newline{\newline	_PluginID=pluginID;\newline}\newline","\newline Plugin identity mgmt\newline \newline","5793875","eng_main.c","void eng_pic_set_x(eng_obj *o, guint16 x)  {\newline\newline	if(!o)  return;\newline\newline	if(x != o-&gtx) {\newline\newline		o-&gtx = x;\newline		o-&gtchange = 1;\newline	}\newline}\newline","---- set X pos of pic \newline","5531993","isl_schedule_tree.c","__isl_give isl_schedule_tree *isl_schedule_tree_append_to_leaves(\newline	__isl_take isl_schedule_tree *tree1,\newline	__isl_take isl_schedule_tree *tree2)\newline{\newline	int i, n;\newline\newline	if (!tree1 || !tree2)\newline		goto error;\newline	n = isl_schedule_tree_n_children(tree1);\newline	if (n == 0) {\newline		isl_schedule_tree_list *list;\newline		list = isl_schedule_tree_list_from_schedule_tree(tree2);\newline		tree1 = isl_schedule_tree_set_children(tree1, list);\newline		return tree1;\newline	}\newline	for (i = 0; i &lt n; ++i) {\newline		isl_schedule_tree *child;\newline\newline		child = isl_schedule_tree_get_child(tree1, i);\newline		child = isl_schedule_tree_append_to_leaves(child,\newline					isl_schedule_tree_copy(tree2));\newline		tree1 = isl_schedule_tree_replace_child(tree1, i, child);\newline	}\newline\newline	isl_schedule_tree_free(tree2);\newline	return tree1;\newlineerror:\newline	isl_schedule_tree_free(tree1);\newline	isl_schedule_tree_free(tree2);\newline	return NULL;\newline}\newline","Attach &quottree2&quot at each of the leaves of &quottree1&quot.\newline \newline If &quottree1&quot does not have any explicit children, then make &quottree2&quot\newline its single child. Otherwise, attach &quottree2&quot to the leaves of\newline each of the children of &quottree1&quot.\newline \newline","1260019","attrs.c","AttVal* TY_(AttrGetById)( Node* node, TidyAttrId id )\newline{\newline   AttVal* av;\newline   for ( av = node-&gtattributes; av; av = av-&gtnext )\newline   {\newline     if ( AttrIsId(av, id) )\newline         return av;\newline   }\newline   return NULL;\newline}\newline","Locate attributes by type \newline","","","on","","","","","on","on","on","","on","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","writes information in the widget out","Mapping between script and screen coordinates","{}","return maximum value","Sets the parent node","allocates memory for the resulting string","Get the address of the socket.","{}","{}","{}","set X pos of pic","{}","Attach ""tree2"" at each of the leaves of ""tree1"".","Locate attributes by type","{}","Respects orientation and updates dirty rectangle.","React to keys pressed by user when given dropdown is expanded","Unparse the address list","Get a list of the Distfile Option Entries.","blocks until a response is received.","Set the language definition"
"3W0XM68YZPV995W8OA49NOP4SEO1KT","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","31EUONYN2V3A8SUEJILSQC9IHECVOD","A1GRLZL4F72RBJ","Approved","Wed Apr 17 20:50:04 PDT 2019","Wed Apr 17 21:06:03 PDT 2019","Fri Apr 19 21:06:03 PDT 2019","2019-04-20 04:06:21 UTC","","","959","100% (1/1)","100% (1/1)","100% (1/1)","2205218","expfit.c","void expfunc(double *p, double *x, int m, int n, void *data)\newline{\newlineregister int i;\newline\newline  for(i=0; i&ltn; ++i){\newline    x[i]=p[0]*exp(-p[1]*i) + p[2];\newline  }\newline}\newline","model to be fitted to measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1 \newline","3371969","hdb.h","static inline void hdb_database_unlock (pthread_mutex_t *mutex)\newline{\newline	pthread_mutex_unlock (mutex);\newline}\newline","\newline @brief hdb_database_unlock\newline @param mutex\newline \newline","3922945","acr_io.c","Acr_Status acr_read_buffer(Acr_File *afp, unsigned char buffer[],\newline                           long nbytes_to_read, long *nbytes_read)\newline{\newline   long i;\newline   int ch;\newline\newline   for (i=0; i &lt nbytes_to_read; i++) {\newline      ch = acr_getc(afp);\newline      if (ch == EOF) {\newline         break;\newline      }\newline      buffer[i] = (unsigned char) ch;\newline   }\newline\newline   /* Save the number of bytes read */\newline   if (nbytes_read != NULL) {\newline      *nbytes_read = i;\newline   }\newline\newline   /* Return the status */\newline   if (i &gt= nbytes_to_read) {\newline      return ACR_OK;\newline   }\newline   else if (acr_get_io_watchpoint(afp) &lt= 0) {\newline      return ACR_REACHED_WATCHPOINT;\newline   }\newline   else if (i == 0) {\newline      return ACR_END_OF_INPUT;\newline   }\newline   else {\newline      return ACR_ABNORMAL_END_OF_INPUT;\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_read_buffer\newline@INPUT : afp\newlinenbytes_to_read\newline@OUTPUT : buffer\newlinenbytes_read - if NULL, then this value is ignored, otherwise\newlinethe number of bytes actually read in is returned.\newline@RETURNS : Input status. If an error occurs on the first byte, then\newlineACR_END_OF_INPUT is returned, if an error occurs elsewhere,\newlinethen ACR_ABNORMAL_END_OF_INPUT is returned, otherwise ACR_OK\newlineis returned.\newline@DESCRIPTION: Reads in a buffer of data and optionally returns the number \newlineof bytes read\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 12, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4675486","pygts.cpp","static FILE* streamFromPyFile(PyObject* file, const char* mode)\newline{\newline  int fd;\newline  FILE* fs;\newline\newline  fd = PyObject_AsFileDescriptor(file);\newline  if (fd &lt 0) return NULL;\newline\newline  fd = dup(fd);\newline  if (fd &lt 0) return NULL;\newline\newline  fs = fdopen(fd, mode);\newline  if (fs == NULL) {\newline    close(fd);\newline    return NULL;\newline  }\newline  return fs;\newline}\newline","Translate Python&#039s built-in file object to FILE \newline","895558","cabin.c","char *cblistpop(CBLIST *list, int *sp){\newline  int index;\newline  assert(list);\newline  if(list-&gtnum &lt 1) return NULL;\newline  index = list-&gtstart + list-&gtnum - 1;\newline  list-&gtnum--;\newline  if(sp) *sp = list-&gtarray[index].dsize;\newline  return list-&gtarray[index].dptr;\newline}\newline","Remove an element of the end of a list. \newline","4157091","instance.c","int send_http_header(int code, unsigned long long int size,char* headers,bool content,time_t timestamp,connection_t* connection_prop) {\newline    int sock=connection_prop-&gtsock;\newline    int len_head,wrote;\newline    char *head=malloc(HEADBUF);\newline    char* h_ptr=head;\newline    int left_head=HEADBUF;\newline\newline    connection_prop-&gtstatus_code=code; //Sets status code, for the logs\newline\newline    if (head==NULL) {\newline#ifdef SERVERDBG\newline        syslog(LOG_CRIT,&quotNot enough memory to allocate buffers&quot);\newline#endif\newline        return ERR_NOMEM;\newline    }\newline    if (headers==NULL) headers=&quot&quot;\newline\newline    /*Defines the Connection header\newline    It will send the connection header if the setting is non-default\newline    Ie: will send keep alive if keep-alive is enabled and protocol is not 1.1\newline    And will send close if keep-alive isn&#039t enabled and protocol is 1.1\newline    */\newline    char *connection_header;\newline    if (connection_prop-&gtprotocol_version!=HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==true) {\newline        connection_header=&quotConnection: Keep-Alive\\r\\n&quot;\newline    } else if (connection_prop-&gtprotocol_version==HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==false) {\newline        connection_header=&quotConnection: close\\r\\n&quot;\newline    } else {\newline        connection_header=&quot&quot;\newline    }\newline\newline    len_head=snprintf(head,HEADBUF,&quotHTTP/1.1 %d %s\\r\\nServer: &quot SIGNATURE &quot\\r\\n%s&quot,code,reason_phrase(code),connection_header);\newline\newline    //This stuff moves the pointer to the buffer forward, and reduces the left space in the buffer itself\newline    //Next snprintf will append their strings to the buffer, without overwriting.\newline    head+=len_head;\newline    left_head-=len_head;\newline\newline    //Creating ETag and date from timestamp\newline    if (timestamp!=-1) {\newline        //Sends ETag, if a timestamp is set\newline        len_head = snprintf(head,left_head,&quotETag: \\&quot%d\\&quot\\r\\n&quot,(int)timestamp);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#ifdef SEND_LAST_MODIFIED_HEADER\newline    else {//timestamp with now, to be eventually used by Last-Modified\newline        timestamp=time(NULL);\newline    }\newline\newline    {\newline        //Sends Date\newline        struct tm  ts;\newline        localtime_r((time_t)&amptimestamp,&ampts);\newline        len_head = strftime(head,left_head, &quotLast-Modified: %a, %d %b %Y %H:%M:%S GMT\\r\\n&quot, &ampts);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#endif\newline\newline    if (size&gt0 || (connection_prop-&gtkeep_alive==true)) {\newline        //Content length (or entity lenght) and extra headers\newline        if (content) {\newline            len_head=snprintf(head,left_head,&quotContent-Length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        } else {\newline            len_head=snprintf(head,left_head,&quotentity-length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        }\newline\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline\newline    len_head=snprintf(head,left_head,&quot%s\\r\\n&quot,headers);\newline    //head+=len_head; Not necessary because the snprintf was the last one\newline    left_head-=len_head;\newline\newline    wrote=write (sock,h_ptr,HEADBUF-left_head);\newline    free(h_ptr);\newline    if (wrote!=HEADBUF-left_head) return ERR_BRKPIPE;\newline    return 0;\newline}\newline","\newlineThis function sends a code header to the specified socket\newlinesize is the Content-Length field.\newlineheaders can be NULL or some extra headers to add. Headers must be\newlineseparated by \\r\\n and must have an \\r\\n at the end.\newlineContent says if the size is for content-lenght or for entity-length\newlineTimestamp is the timestamp for the content. Set to -1 to use the current\newlinetimestamp for Last-Modified and to omit ETag.\newlineThis function will automatically take care of generating Connection header when\newlineneeded, according to keep_alive and protocol_version of connection_prop\newline \newline","4963676","loader.c","static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,\newline                                            FLAC__byte buffer[],\newline                                            size_t *bytes,\newline                                            void *client_data){\newline  flac_callback_arg *flac = (flac_callback_arg *)client_data;\newline  pcm_t *pcm = flac-&gtpcm;\newline\newline  if(feof(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\newline  }else if(ferror(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\newline  }\newline\newline  if(sb_verbose)\newline    fprintf(stderr,&quot\\rLoading %s: %ld to go...       &quot,flac-&gtpcm-&gtname,(long)(pcm-&gtsize-flac-&gtfill));\newline  *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, flac-&gtin);\newline\newline  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\newline}\newline","glorified fread wrapper \newline","3840244","blazer.c","static double blazer_packs(const char *ptr, char **endptr)\newline{\newline	const double packs[] = {\newline		120, 100, 80, 60, 48, 36, 30, 24, 18, 12, 8, 6, 4, 3, 2, 1, 0.5, -1\newline	};\newline\newline	const char	*val;\newline	int		i;\newline\newline	val = dstate_getinfo(&quotbattery.voltage.nominal&quot);\newline\newline	batt.volt.nom = strtod(val ? val : ptr, endptr);\newline\newline	for (i = 0; packs[i] &gt 0; i++) {\newline\newline		if (packs[i] * batt.volt.act &gt 1.2 * batt.volt.nom) {\newline			continue;\newline		}\newline\newline		if (packs[i] * batt.volt.act &lt 0.8 * batt.volt.nom) {\newline			upslogx(LOG_INFO, &quotCan&#039t autodetect number of battery packs [%.0f/%.2f]&quot, batt.volt.nom, batt.volt.act);\newline			break;\newline		}\newline\newline		batt.packs = packs[i];\newline		break;\newline	}\newline\newline	return batt.volt.nom;\newline}\newline","\newline The battery voltage will quickly return to at least the nominal value after\newline discharging them. For overlapping battery.voltage.low/high ranges therefor\newline choose the one with the highest multiplier.\newline \newline","3502162","decode.c","static void x86emu_intr_handle(void)\newline{\newline	u8	intno;\newline\newline	if (M.x86.intr &amp INTR_SYNCH) {\newline		intno = M.x86.intno;\newline		if (_X86EMU_intrTab[intno]) {\newline			(*_X86EMU_intrTab[intno])(intno);\newline		} else {\newline			push_word((u16)M.x86.R_FLG);\newline			CLEAR_FLAG(F_IF);\newline			CLEAR_FLAG(F_TF);\newline			push_word(M.x86.R_CS);\newline			M.x86.R_CS = mem_access_word(intno * 4 + 2);\newline			push_word(M.x86.R_IP);\newline			M.x86.R_IP = mem_access_word(intno * 4);\newline			M.x86.intr = 0;\newline		}\newline	}\newline}\newline","\newlineREMARKS:\newlineHandles any pending asychronous interrupts.\newline \newline","2747698","rofi.c","int main ( int argc, char *argv[] )\newline{\newline    TIMINGS_START ();\newline\newline    cmd_set_arguments ( argc, argv );\newline\newline    // Version\newline    if ( find_arg (  &quot-v&quot ) &gt= 0 || find_arg (  &quot-version&quot ) &gt= 0 ) {\newline#ifdef GIT_VERSION\newline        fprintf ( stdout, &quotVersion: &quotGIT_VERSION &quot\\n&quot );\newline#else\newline        fprintf ( stdout, &quotVersion: &quotVERSION &quot\\n&quot );\newline#endif\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    // Detect if we are in dmenu mode.\newline    // This has two possible causes.\newline    // 1 the user specifies it on the command-line.\newline    if ( find_arg (  &quot-dmenu&quot ) &gt= 0 ) {\newline        dmenu_mode = TRUE;\newline    }\newline    // 2 the binary that executed is called dmenu (e.g. symlink to rofi)\newline    else{\newline        // Get the base name of the executable called.\newline        char               *base_name = g_path_get_basename ( argv[0] );\newline        const char * const dmenu_str  = &quotdmenu&quot;\newline        dmenu_mode = ( strcmp ( base_name, dmenu_str ) == 0 );\newline        // Free the basename for dmenu detection.\newline        g_free ( base_name );\newline    }\newline    TICK ();\newline    // Get the path to the cache dir.\newline    cache_dir = g_get_user_cache_dir ();\newline\newline    if ( g_mkdir_with_parents ( cache_dir, 0700 ) &lt 0 ) {\newline        fprintf ( stderr, &quotFailed to create cache directory: %s\\n&quot, strerror ( errno ) );\newline        return EXIT_FAILURE;\newline    }\newline\newline    // Create pid file path.\newline    const char *path = g_get_user_runtime_dir ();\newline    if ( path ) {\newline        if ( g_mkdir_with_parents ( path, 0700 ) &lt 0 ) {\newline            fprintf ( stderr, &quotFailed to create user runtime directory: %s\\n&quot, strerror ( errno ) );\newline            return EXIT_FAILURE;\newline        }\newline        pidfile = g_build_filename ( path, &quotrofi.pid&quot, NULL );\newline    }\newline    config_parser_add_option ( xrm_String, &quotpid&quot, (void * *) &amppidfile, &quotPidfile location&quot );\newline\newline    if ( find_arg ( &quot-config&quot ) &lt 0 ) {\newline        const char *cpath = g_get_user_config_dir ();\newline        if ( cpath ) {\newline            config_path = g_build_filename ( cpath, &quotrofi&quot, &quotconfig&quot, NULL );\newline        }\newline    }\newline    else {\newline        char *c = NULL;\newline        find_arg_str ( &quot-config&quot, &ampc );\newline        config_path = rofi_expand_path ( c );\newline    }\newline\newline    TICK ();\newline    // Register cleanup function.\newline    atexit ( cleanup );\newline\newline    TICK ();\newline    // Get DISPLAY, first env, then argument.\newline    char *display_str = getenv ( &quotDISPLAY&quot );\newline    find_arg_str (  &quot-display&quot, &ampdisplay_str );\newline\newline    if ( setlocale ( LC_ALL, &quot&quot ) == NULL ) {\newline        fprintf ( stderr, &quotFailed to set locale.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xcb-&gtconnection = xcb_connect ( display_str, &ampxcb-&gtscreen_nbr );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotFailed to open display: %s&quot, display_str );\newline        return EXIT_FAILURE;\newline    }\newline    TICK_N ( &quotOpen Display&quot );\newline\newline    xcb-&gtscreen = xcb_aux_get_screen ( xcb-&gtconnection, xcb-&gtscreen_nbr );\newline\newline    x11_build_monitor_layout ();\newline\newline    xcb_intern_atom_cookie_t *ac     = xcb_ewmh_init_atoms ( xcb-&gtconnection, &ampxcb-&gtewmh );\newline    xcb_generic_error_t      *errors = NULL;\newline    xcb_ewmh_init_atoms_replies ( &ampxcb-&gtewmh, ac, &amperrors );\newline    if ( errors ) {\newline        fprintf ( stderr, &quotFailed to create EWMH atoms\\n&quot );\newline        free ( errors );\newline    }\newline\newline    if ( xkb_x11_setup_xkb_extension ( xcb-&gtconnection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION,\newline                                       XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, NULL, NULL, &ampxkb.first_event, NULL ) &lt 0 ) {\newline        fprintf ( stderr, &quotcannot setup XKB extension!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.context = xkb_context_new ( XKB_CONTEXT_NO_FLAGS );\newline    if ( xkb.context == NULL ) {\newline        fprintf ( stderr, &quotcannot create XKB context!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.xcb_connection = xcb-&gtconnection;\newline\newline    xkb.device_id = xkb_x11_get_core_keyboard_device_id ( xcb-&gtconnection );\newline\newline    enum\newline    {\newline        required_events =\newline            ( XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_MAP_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_STATE_NOTIFY ),\newline\newline        required_nkn_details =\newline            ( XCB_XKB_NKN_DETAIL_KEYCODES ),\newline\newline        required_map_parts   =\newline            ( XCB_XKB_MAP_PART_KEY_TYPES |\newline              XCB_XKB_MAP_PART_KEY_SYMS |\newline              XCB_XKB_MAP_PART_MODIFIER_MAP |\newline              XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |\newline              XCB_XKB_MAP_PART_KEY_ACTIONS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MODS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP ),\newline\newline        required_state_details =\newline            ( XCB_XKB_STATE_PART_MODIFIER_BASE |\newline              XCB_XKB_STATE_PART_MODIFIER_LATCH |\newline              XCB_XKB_STATE_PART_MODIFIER_LOCK |\newline              XCB_XKB_STATE_PART_GROUP_BASE |\newline              XCB_XKB_STATE_PART_GROUP_LATCH |\newline              XCB_XKB_STATE_PART_GROUP_LOCK ),\newline    };\newline\newline    static const xcb_xkb_select_events_details_t details = {\newline        .affectNewKeyboard  = required_nkn_details,\newline        .newKeyboardDetails = required_nkn_details,\newline        .affectState        = required_state_details,\newline        .stateDetails       = required_state_details,\newline    };\newline    xcb_xkb_select_events ( xcb-&gtconnection, xkb.device_id, required_events, /* affectWhich */\newline                            0,                                               /* clear */\newline                            required_events,                                 /* selectAll */\newline                            required_map_parts,                              /* affectMap */\newline                            required_map_parts,                              /* map */\newline                            &ampdetails );\newline\newline    xkb.keymap = xkb_x11_keymap_new_from_device ( xkb.context, xcb-&gtconnection, xkb.device_id, XKB_KEYMAP_COMPILE_NO_FLAGS );\newline    if ( xkb.keymap == NULL ) {\newline        fprintf ( stderr, &quotFailed to get Keymap for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.state = xkb_x11_state_new_from_device ( xkb.keymap, xcb-&gtconnection, xkb.device_id );\newline    if ( xkb.state == NULL ) {\newline        fprintf ( stderr, &quotFailed to get state object for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.compose.table = xkb_compose_table_new_from_locale ( xkb.context, setlocale ( LC_CTYPE, NULL ), 0 );\newline    if ( xkb.compose.table != NULL ) {\newline        xkb.compose.state = xkb_compose_state_new ( xkb.compose.table, 0 );\newline    }\newline    else {\newline        fprintf ( stderr, &quotFailed to get keyboard compose table. Trying to limp on.\\n&quot );\newline    }\newline\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    x11_setup ( &ampxkb );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    main_loop = g_main_loop_new ( NULL, FALSE );\newline\newline    TICK_N ( &quotSetup mainloop&quot );\newline    // startup not.\newline    xcb-&gtsndisplay = sn_xcb_display_new ( xcb-&gtconnection, error_trap_push, error_trap_pop );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline\newline    if ( xcb-&gtsndisplay != NULL ) {\newline        xcb-&gtsncontext = sn_launchee_context_new_from_environment ( xcb-&gtsndisplay, xcb-&gtscreen_nbr );\newline    }\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    TICK_N ( &quotStartup Notification&quot );\newline    // Setup keybinding\newline    setup_abe ();\newline    TICK_N ( &quotSetup abe&quot );\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        load_configuration ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options ( );\newline\newline    if ( !dmenu_mode ) {\newline        // setup_modi\newline        setup_modi ();\newline    }\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        // Reload for dynamic part.\newline        load_configuration_dynamic ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options_dynamic (  );\newline\newline    // Dump.\newline    // catch help request\newline    if ( find_arg (  &quot-h&quot ) &gt= 0 || find_arg (  &quot-help&quot ) &gt= 0 || find_arg (  &quot--help&quot ) &gt= 0 ) {\newline        help ( argc, argv );\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources&quot ) &gt= 0 ) {\newline        config_parse_xresource_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources-theme&quot ) &gt= 0 ) {\newline        config_parse_xresources_theme_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    main_loop_source = g_water_xcb_source_new_for_connection ( NULL, xcb-&gtconnection, main_loop_x11_event_handler, NULL, NULL );\newline\newline    TICK_N ( &quotX11 Setup &quot );\newline\newline    rofi_view_workers_initialize ();\newline\newline    // Setup signal handling sources.\newline    // SIGINT\newline    g_unix_signal_add ( SIGINT, main_loop_signal_handler_int, NULL );\newline\newline    g_idle_add ( startup, NULL );\newline\newline    // Pidfile + visuals\newline    int pfd = setup ();\newline    if ( pfd &lt 0 ) {\newline        return EXIT_FAILURE;\newline    }\newline    // Start mainloop.\newline    g_main_loop_run ( main_loop );\newline    teardown ( pfd );\newline    return return_code;\newline}\newline","\newline @param argc number of input arguments.\newline @param argv array of the input arguments.\newline \newline Main application entry point.\newline \newline @returns return code of rofi.\newline \newline","1306481","email.c","static void copy_type_list(type_list_t *l1, type_list_t *l2) {\newline  type_t *last = NULL;\newline\newline  for (type_t *ptr1 = l1-&gthead, *ptr2 = l2-&gthead; NULL != ptr1;\newline       ptr1 = ptr1-&gtnext, last = ptr2, ptr2 = ptr2-&gtnext) {\newline    if (NULL == ptr2) {\newline      ptr2 = smalloc(sizeof(*ptr2));\newline      ptr2-&gtname = NULL;\newline      ptr2-&gtnext = NULL;\newline\newline      if (NULL == last) {\newline        l2-&gthead = ptr2;\newline      } else {\newline        last-&gtnext = ptr2;\newline      }\newline\newline      l2-&gttail = ptr2;\newline    }\newline\newline    if (NULL == ptr2-&gtname) {\newline      ptr2-&gtname = sstrdup(ptr1-&gtname);\newline    }\newline\newline    ptr2-&gtvalue = ptr1-&gtvalue;\newline    ptr1-&gtvalue = 0;\newline  }\newline  return;\newline}\newline","Copy list l1 to list l2. l2 may partly exist already, but it is assumed\newline that neither the order nor the name of any element of either list is\newline changed and no elements are deleted. The values of l1 are reset to zero\newline after they have been copied to l2. \newline","4226559","cfg-old.c","static const gchar *cfg_old_filename_from_utf8(const gchar *fname)\newline{\newline#if defined(CFG_OLD_PLAYLIST) || defined(CFG_OLD_FILESELECT)\newline    static gchar *name;\newline\newline    if (g_utf8_validate(fname, -1, NULL)) {\newline        free(name);\newline        name = g_filename_from_utf8(fname, -1, NULL, NULL, NULL);\newline\newline        return name;\newline    }\newline#endif\newline    return fname;\newline}\newline","\newline @brief Convert a filename into the original byte sequence\newline according to the encoding specified in G_FILENAME_ENCODING,\newline if it&#039s currently in UTF-8.\newline \newline @param fname filename\newline \newline @return converted filename\newline \newline","311765","commands.c","void stop_executing_host_checks(void) {\newline	unsigned long attr = MODATTR_ACTIVE_CHECKS_ENABLED;\newline\newline	/* bail out if we&#039re already not executing hosts */\newline	if (execute_host_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	modified_host_process_attributes |= attr;\newline\newline	/* set the host check execution flag */\newline	execute_host_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_program_data(NEBTYPE_ADAPTIVEPROGRAM_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, CMD_NONE, attr, modified_host_process_attributes, MODATTR_NONE, modified_service_process_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the program info */\newline	update_program_status(FALSE);\newline\newline	return;\newline}\newline","stops executing host checks \newline","4713048","ximalpha.cpp","void CxImage::AlphaSetMax(BYTE nAlphaMax)\newline{\newline	info.nAlphaMax=nAlphaMax;\newline}\newline","\newline Sets global Alpha (opacity) value applied to the whole image,\newline valid only for painting functions.\newline \\param nAlphaMax: can be from 0 to 255\newline \newline","6430477","cmds.c","void indent_to(int n)\newline{\newline   int m;\newline   \newline   get_current_indent(&ampm);\newline   \newline   if (n != m)\newline     {\newline	bol ();\newline	jed_trim_whitespace();\newline	if (n &gt= 0) insert_whitespace(&ampn);\newline     }\newline}\newline","indent line to column n \newline","3068732","basiccmdline.cpp","BASICCMDLINE::~BASICCMDLINE()\newline	{\newline	NCL_ASSERT(next_command != NULL);\newline	delete [] next_command;\newline\newline	if (logf_open)\newline		logf.close();\newline	}\newline","----------------------------------------------------------------------------------------------------------------------\newline Closes `logf&#039 if it is open and deletes memory allocated to `next_command&#039.\newline \newline","3404448","scheme.c","pointer scheme_call(scheme *sc, pointer func, pointer args)\newline{\newline  int old_repl = sc-&gtinteractive_repl;\newline  sc-&gtinteractive_repl = 0;\newline  save_from_C_call(sc);\newline  sc-&gtenvir = sc-&gtglobal_env;\newline  sc-&gtargs = args;\newline  sc-&gtcode = func;\newline  sc-&gtretcode = 0;\newline  Eval_Cycle(sc, OP_APPLY);\newline  sc-&gtinteractive_repl = old_repl;\newline  restore_from_C_call(sc);\newline  return sc-&gtvalue;\newline}\newline","&quotfunc&quot and &quotargs&quot are assumed to be already eval&#039ed. \newline","4879587","parser.c","static void InsertNodeAsParent(Node *element, Node *node)\newline{\newline    node-&gtcontent = element;\newline    node-&gtlast = element;\newline    node-&gtparent = element-&gtparent;\newline    element-&gtparent = node;\newline\newline    if (node-&gtparent-&gtcontent == element)\newline        node-&gtparent-&gtcontent = node;\newline\newline    if (node-&gtparent-&gtlast == element)\newline        node-&gtparent-&gtlast = node;\newline\newline    node-&gtprev = element-&gtprev;\newline    element-&gtprev = null;\newline\newline    if (node-&gtprev)\newline        node-&gtprev-&gtnext = node;\newline\newline    node-&gtnext = element-&gtnext;\newline    element-&gtnext = null;\newline\newline    if (node-&gtnext)\newline        node-&gtnext-&gtprev = node;\newline}\newline","\newlineinsert node into markup tree in pace of element\newlinewhich is moved to become the child of the node\newline \newline","1328599","memaslap.c","static int64_t ms_parse_size()\newline{\newline  int64_t ret= -1;\newline  char unit= optarg[strlen(optarg) - 1];\newline\newline  optarg[strlen(optarg) - 1]= &#039\\0&#039;\newline  errno= 0;\newline  ret= strtoll(optarg, (char **)NULL, 10);\newline  if (errno != 0)\newline  {\newline    fprintf(stderr, &quotstrtoll(optarg,..): %s\\n&quot, strerror(errno));\newline    exit(1);\newline  }\newline\newline  switch (unit)\newline  {\newline  case &#039k&#039:\newline  case &#039K&#039:\newline    ret*= 1024;\newline    break;\newline\newline  case &#039m&#039:\newline  case &#039M&#039:\newline    ret*= 1024 * 1024;\newline    break;\newline\newline  case &#039g&#039:\newline  case &#039G&#039:\newline    ret*= 1024 * 1024 * 1024;\newline    break;\newline\newline  default:\newline    ret= -1;\newline    break;\newline  } /* switch */\newline\newline  return ret;\newline} /* ms_parse_size */\newline","used to parse the size string \newline","1560807","expression.c","int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\newline{\newline    //printf(&quotmodifyFieldVar(var = %s)\\n&quot, var-&gttoChars());\newline    Dsymbol *s = sc-&gtfunc;\newline    while (1)\newline    {\newline        FuncDeclaration *fd = NULL;\newline        if (s)\newline            fd = s-&gtisFuncDeclaration();\newline        if (fd &amp&amp\newline            ((fd-&gtisCtorDeclaration() &amp&amp var-&gtisField()) ||\newline             (fd-&gtisStaticCtorDeclaration() &amp&amp !var-&gtisField())) &amp&amp\newline            fd-&gttoParent2() == var-&gttoParent2() &amp&amp\newline            (!e1 || e1-&gtop == TOKthis)\newline           )\newline        {\newline            var-&gtctorinit = 1;\newline            //printf(&quotsetting ctorinit\\n&quot);\newline            int result = true;\newline            if (var-&gtisField() &amp&amp sc-&gtfieldinit &amp&amp !sc-&gtintypeof)\newline            {\newline                assert(e1);\newline                bool mustInit = (var-&gtstorage_class &amp STCnodefaultctor ||\newline                                 var-&gttype-&gtneedsNested());\newline\newline                size_t dim = sc-&gtfieldinit_dim;\newline                AggregateDeclaration *ad = fd-&gtisAggregateMember2();\newline                assert(ad);\newline                size_t i;\newline                for (i = 0; i &lt dim; i++)   // same as findFieldIndexByName in ctfeexp.c ?\newline                {\newline                    if (ad-&gtfields[i] == var)\newline                        break;\newline                }\newline                assert(i &lt dim);\newline                unsigned fi = sc-&gtfieldinit[i];\newline                if (fi &amp CSXthis_ctor)\newline                {\newline                    if (var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialized multiple times&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                else if (sc-&gtnoctor || fi &amp CSXlabel)\newline                {\newline                    if (!mustInit &amp&amp var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialization is not allowed in loops or after labels&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                sc-&gtfieldinit[i] |= CSXthis_ctor;\newline            }\newline            else if (fd != sc-&gtfunc)\newline            {\newline                if (var-&gttype-&gtisMutable())\newline                    result = false;\newline                else if (sc-&gtfunc-&gtfes)\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in foreach loop&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars());\newline                }\newline                else\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in nested function &#039%s&#039&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars(), sc-&gtfunc-&gttoChars());\newline                }\newline            }\newline            return result;\newline        }\newline        else\newline        {\newline            if (s)\newline            {\newline                s = s-&gttoParent2();\newline                continue;\newline            }\newline        }\newline        break;\newline    }\newline    return false;\newline}\newline","\newline Mark variable v as modified if it is inside a constructor that var\newline is a field in.\newline \newline","1480421","mainwindow.cpp","void MainWindow::mountWebDav() {\newline#ifdef Q_OS_WIN\newline  char dst[20] = {0};\newline  NETRESOURCEA netres;\newline  memset(&ampnetres, 0, sizeof(netres));\newline  netres.dwType = RESOURCETYPE_DISK;\newline  netres.lpLocalName = 0;\newline  netres.lpRemoteName = webDavUrl.toUtf8().data();\newline  DWORD size = sizeof(dst);\newline  DWORD r = WNetUseConnectionA(\newline      reinterpret_cast&ltHWND&gt(effectiveWinId()), &ampnetres,\newline      webDavPassword.toUtf8().constData(), webDavUser.toUtf8().constData(),\newline      CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_REDIRECT, dst, &ampsize,\newline      0);\newline  if (r == NO_ERROR) {\newline    passStore = dst;\newline  } else {\newline    char message[256] = {0};\newline    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, r, 0, message,\newline                   sizeof(message), 0);\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(tr(&quotFailed to connect WebDAV:\\n&quot) + message +\newline                             &quot (0x&quot + QString::number(r, 16) + &quot)&quot);\newline  }\newline#else\newline  fusedav.start(&quotfusedav -o nonempty -u \\&quot&quot + webDavUser + &quot\\&quot &quot + webDavUrl +\newline                &quot \\&quot&quot + passStore + &#039&quot&#039);\newline  fusedav.waitForStarted();\newline  if (fusedav.state() == QProcess::Running) {\newline    QString pwd = webDavPassword;\newline    bool ok = true;\newline    if (pwd.isEmpty()) {\newline      pwd = QInputDialog::getText(this, tr(&quotQtPass WebDAV password&quot),\newline                                  tr(&quotEnter password to connect to WebDAV:&quot),\newline                                  QLineEdit::Password, &quot&quot, &ampok);\newline    }\newline    if (ok &amp&amp !pwd.isEmpty()) {\newline      fusedav.write(pwd.toUtf8() + &#039\\n&#039);\newline      fusedav.closeWriteChannel();\newline      fusedav.waitForFinished(2000);\newline    } else {\newline      fusedav.terminate();\newline    }\newline  }\newline  QString error = fusedav.readAllStandardError();\newline  int prompt = error.indexOf(&quotPassword:&quot);\newline  if (prompt &gt= 0)\newline    error.remove(0, prompt + 10);\newline  if (fusedav.state() != QProcess::Running)\newline    error = tr(&quotfusedav exited unexpectedly\\n&quot) + error;\newline  if (error.size() &gt 0) {\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(\newline        tr(&quotFailed to start fusedav to connect WebDAV:\\n&quot) + error);\newline  }\newline#endif\newline}\newline","\newline @brief MainWindow::mountWebDav is some scary voodoo magic\newline \newline","","","","","","","","","on","","","on","","on","","","","","","on","","","","","","","","","","","","","","","","on","","","","","","","measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1","return code of rofi.","Copy list l1 to list l2.","Convert a filename into the original byte sequence","stops executing host checks","Sets global Alpha (opacity) value applied to the whole image,","indent line to column n","Closes `logf' if it is open and deletes memory allocated to `next_command'.","{}","insert node into markup tree in pace of element","used to parse the size string","{}","Mark variable v as modified","{}","returns the number of bytes read","Translate Python's built-in file object to FILE","Remove an element of the end of a list.","sends a code header to the specified socket","fread wrapper","{}","Handles any pending asychronous interrupts."
"3W0XM68YZPV995W8OA49NOP4SEO1KT","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","32AT8R96GL9PT5X7L9SWEVH00S0US6","A3O7G449PI0774","Rejected","Wed Apr 17 10:57:40 PDT 2019","Wed Apr 17 10:59:34 PDT 2019","Fri Apr 19 10:59:34 PDT 2019","","Wed Apr 17 13:10:15 PDT 2019","These results appear to be spam, or represent a misunderstanding of the task","114","67% (2/3)","67% (2/3)","67% (2/3)","2205218","expfit.c","void expfunc(double *p, double *x, int m, int n, void *data)\newline{\newlineregister int i;\newline\newline  for(i=0; i&ltn; ++i){\newline    x[i]=p[0]*exp(-p[1]*i) + p[2];\newline  }\newline}\newline","model to be fitted to measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1 \newline","3371969","hdb.h","static inline void hdb_database_unlock (pthread_mutex_t *mutex)\newline{\newline	pthread_mutex_unlock (mutex);\newline}\newline","\newline @brief hdb_database_unlock\newline @param mutex\newline \newline","3922945","acr_io.c","Acr_Status acr_read_buffer(Acr_File *afp, unsigned char buffer[],\newline                           long nbytes_to_read, long *nbytes_read)\newline{\newline   long i;\newline   int ch;\newline\newline   for (i=0; i &lt nbytes_to_read; i++) {\newline      ch = acr_getc(afp);\newline      if (ch == EOF) {\newline         break;\newline      }\newline      buffer[i] = (unsigned char) ch;\newline   }\newline\newline   /* Save the number of bytes read */\newline   if (nbytes_read != NULL) {\newline      *nbytes_read = i;\newline   }\newline\newline   /* Return the status */\newline   if (i &gt= nbytes_to_read) {\newline      return ACR_OK;\newline   }\newline   else if (acr_get_io_watchpoint(afp) &lt= 0) {\newline      return ACR_REACHED_WATCHPOINT;\newline   }\newline   else if (i == 0) {\newline      return ACR_END_OF_INPUT;\newline   }\newline   else {\newline      return ACR_ABNORMAL_END_OF_INPUT;\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_read_buffer\newline@INPUT : afp\newlinenbytes_to_read\newline@OUTPUT : buffer\newlinenbytes_read - if NULL, then this value is ignored, otherwise\newlinethe number of bytes actually read in is returned.\newline@RETURNS : Input status. If an error occurs on the first byte, then\newlineACR_END_OF_INPUT is returned, if an error occurs elsewhere,\newlinethen ACR_ABNORMAL_END_OF_INPUT is returned, otherwise ACR_OK\newlineis returned.\newline@DESCRIPTION: Reads in a buffer of data and optionally returns the number \newlineof bytes read\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 12, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4675486","pygts.cpp","static FILE* streamFromPyFile(PyObject* file, const char* mode)\newline{\newline  int fd;\newline  FILE* fs;\newline\newline  fd = PyObject_AsFileDescriptor(file);\newline  if (fd &lt 0) return NULL;\newline\newline  fd = dup(fd);\newline  if (fd &lt 0) return NULL;\newline\newline  fs = fdopen(fd, mode);\newline  if (fs == NULL) {\newline    close(fd);\newline    return NULL;\newline  }\newline  return fs;\newline}\newline","Translate Python&#039s built-in file object to FILE \newline","895558","cabin.c","char *cblistpop(CBLIST *list, int *sp){\newline  int index;\newline  assert(list);\newline  if(list-&gtnum &lt 1) return NULL;\newline  index = list-&gtstart + list-&gtnum - 1;\newline  list-&gtnum--;\newline  if(sp) *sp = list-&gtarray[index].dsize;\newline  return list-&gtarray[index].dptr;\newline}\newline","Remove an element of the end of a list. \newline","4157091","instance.c","int send_http_header(int code, unsigned long long int size,char* headers,bool content,time_t timestamp,connection_t* connection_prop) {\newline    int sock=connection_prop-&gtsock;\newline    int len_head,wrote;\newline    char *head=malloc(HEADBUF);\newline    char* h_ptr=head;\newline    int left_head=HEADBUF;\newline\newline    connection_prop-&gtstatus_code=code; //Sets status code, for the logs\newline\newline    if (head==NULL) {\newline#ifdef SERVERDBG\newline        syslog(LOG_CRIT,&quotNot enough memory to allocate buffers&quot);\newline#endif\newline        return ERR_NOMEM;\newline    }\newline    if (headers==NULL) headers=&quot&quot;\newline\newline    /*Defines the Connection header\newline    It will send the connection header if the setting is non-default\newline    Ie: will send keep alive if keep-alive is enabled and protocol is not 1.1\newline    And will send close if keep-alive isn&#039t enabled and protocol is 1.1\newline    */\newline    char *connection_header;\newline    if (connection_prop-&gtprotocol_version!=HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==true) {\newline        connection_header=&quotConnection: Keep-Alive\\r\\n&quot;\newline    } else if (connection_prop-&gtprotocol_version==HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==false) {\newline        connection_header=&quotConnection: close\\r\\n&quot;\newline    } else {\newline        connection_header=&quot&quot;\newline    }\newline\newline    len_head=snprintf(head,HEADBUF,&quotHTTP/1.1 %d %s\\r\\nServer: &quot SIGNATURE &quot\\r\\n%s&quot,code,reason_phrase(code),connection_header);\newline\newline    //This stuff moves the pointer to the buffer forward, and reduces the left space in the buffer itself\newline    //Next snprintf will append their strings to the buffer, without overwriting.\newline    head+=len_head;\newline    left_head-=len_head;\newline\newline    //Creating ETag and date from timestamp\newline    if (timestamp!=-1) {\newline        //Sends ETag, if a timestamp is set\newline        len_head = snprintf(head,left_head,&quotETag: \\&quot%d\\&quot\\r\\n&quot,(int)timestamp);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#ifdef SEND_LAST_MODIFIED_HEADER\newline    else {//timestamp with now, to be eventually used by Last-Modified\newline        timestamp=time(NULL);\newline    }\newline\newline    {\newline        //Sends Date\newline        struct tm  ts;\newline        localtime_r((time_t)&amptimestamp,&ampts);\newline        len_head = strftime(head,left_head, &quotLast-Modified: %a, %d %b %Y %H:%M:%S GMT\\r\\n&quot, &ampts);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#endif\newline\newline    if (size&gt0 || (connection_prop-&gtkeep_alive==true)) {\newline        //Content length (or entity lenght) and extra headers\newline        if (content) {\newline            len_head=snprintf(head,left_head,&quotContent-Length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        } else {\newline            len_head=snprintf(head,left_head,&quotentity-length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        }\newline\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline\newline    len_head=snprintf(head,left_head,&quot%s\\r\\n&quot,headers);\newline    //head+=len_head; Not necessary because the snprintf was the last one\newline    left_head-=len_head;\newline\newline    wrote=write (sock,h_ptr,HEADBUF-left_head);\newline    free(h_ptr);\newline    if (wrote!=HEADBUF-left_head) return ERR_BRKPIPE;\newline    return 0;\newline}\newline","\newlineThis function sends a code header to the specified socket\newlinesize is the Content-Length field.\newlineheaders can be NULL or some extra headers to add. Headers must be\newlineseparated by \\r\\n and must have an \\r\\n at the end.\newlineContent says if the size is for content-lenght or for entity-length\newlineTimestamp is the timestamp for the content. Set to -1 to use the current\newlinetimestamp for Last-Modified and to omit ETag.\newlineThis function will automatically take care of generating Connection header when\newlineneeded, according to keep_alive and protocol_version of connection_prop\newline \newline","4963676","loader.c","static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,\newline                                            FLAC__byte buffer[],\newline                                            size_t *bytes,\newline                                            void *client_data){\newline  flac_callback_arg *flac = (flac_callback_arg *)client_data;\newline  pcm_t *pcm = flac-&gtpcm;\newline\newline  if(feof(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\newline  }else if(ferror(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\newline  }\newline\newline  if(sb_verbose)\newline    fprintf(stderr,&quot\\rLoading %s: %ld to go...       &quot,flac-&gtpcm-&gtname,(long)(pcm-&gtsize-flac-&gtfill));\newline  *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, flac-&gtin);\newline\newline  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\newline}\newline","glorified fread wrapper \newline","3840244","blazer.c","static double blazer_packs(const char *ptr, char **endptr)\newline{\newline	const double packs[] = {\newline		120, 100, 80, 60, 48, 36, 30, 24, 18, 12, 8, 6, 4, 3, 2, 1, 0.5, -1\newline	};\newline\newline	const char	*val;\newline	int		i;\newline\newline	val = dstate_getinfo(&quotbattery.voltage.nominal&quot);\newline\newline	batt.volt.nom = strtod(val ? val : ptr, endptr);\newline\newline	for (i = 0; packs[i] &gt 0; i++) {\newline\newline		if (packs[i] * batt.volt.act &gt 1.2 * batt.volt.nom) {\newline			continue;\newline		}\newline\newline		if (packs[i] * batt.volt.act &lt 0.8 * batt.volt.nom) {\newline			upslogx(LOG_INFO, &quotCan&#039t autodetect number of battery packs [%.0f/%.2f]&quot, batt.volt.nom, batt.volt.act);\newline			break;\newline		}\newline\newline		batt.packs = packs[i];\newline		break;\newline	}\newline\newline	return batt.volt.nom;\newline}\newline","\newline The battery voltage will quickly return to at least the nominal value after\newline discharging them. For overlapping battery.voltage.low/high ranges therefor\newline choose the one with the highest multiplier.\newline \newline","3502162","decode.c","static void x86emu_intr_handle(void)\newline{\newline	u8	intno;\newline\newline	if (M.x86.intr &amp INTR_SYNCH) {\newline		intno = M.x86.intno;\newline		if (_X86EMU_intrTab[intno]) {\newline			(*_X86EMU_intrTab[intno])(intno);\newline		} else {\newline			push_word((u16)M.x86.R_FLG);\newline			CLEAR_FLAG(F_IF);\newline			CLEAR_FLAG(F_TF);\newline			push_word(M.x86.R_CS);\newline			M.x86.R_CS = mem_access_word(intno * 4 + 2);\newline			push_word(M.x86.R_IP);\newline			M.x86.R_IP = mem_access_word(intno * 4);\newline			M.x86.intr = 0;\newline		}\newline	}\newline}\newline","\newlineREMARKS:\newlineHandles any pending asychronous interrupts.\newline \newline","2747698","rofi.c","int main ( int argc, char *argv[] )\newline{\newline    TIMINGS_START ();\newline\newline    cmd_set_arguments ( argc, argv );\newline\newline    // Version\newline    if ( find_arg (  &quot-v&quot ) &gt= 0 || find_arg (  &quot-version&quot ) &gt= 0 ) {\newline#ifdef GIT_VERSION\newline        fprintf ( stdout, &quotVersion: &quotGIT_VERSION &quot\\n&quot );\newline#else\newline        fprintf ( stdout, &quotVersion: &quotVERSION &quot\\n&quot );\newline#endif\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    // Detect if we are in dmenu mode.\newline    // This has two possible causes.\newline    // 1 the user specifies it on the command-line.\newline    if ( find_arg (  &quot-dmenu&quot ) &gt= 0 ) {\newline        dmenu_mode = TRUE;\newline    }\newline    // 2 the binary that executed is called dmenu (e.g. symlink to rofi)\newline    else{\newline        // Get the base name of the executable called.\newline        char               *base_name = g_path_get_basename ( argv[0] );\newline        const char * const dmenu_str  = &quotdmenu&quot;\newline        dmenu_mode = ( strcmp ( base_name, dmenu_str ) == 0 );\newline        // Free the basename for dmenu detection.\newline        g_free ( base_name );\newline    }\newline    TICK ();\newline    // Get the path to the cache dir.\newline    cache_dir = g_get_user_cache_dir ();\newline\newline    if ( g_mkdir_with_parents ( cache_dir, 0700 ) &lt 0 ) {\newline        fprintf ( stderr, &quotFailed to create cache directory: %s\\n&quot, strerror ( errno ) );\newline        return EXIT_FAILURE;\newline    }\newline\newline    // Create pid file path.\newline    const char *path = g_get_user_runtime_dir ();\newline    if ( path ) {\newline        if ( g_mkdir_with_parents ( path, 0700 ) &lt 0 ) {\newline            fprintf ( stderr, &quotFailed to create user runtime directory: %s\\n&quot, strerror ( errno ) );\newline            return EXIT_FAILURE;\newline        }\newline        pidfile = g_build_filename ( path, &quotrofi.pid&quot, NULL );\newline    }\newline    config_parser_add_option ( xrm_String, &quotpid&quot, (void * *) &amppidfile, &quotPidfile location&quot );\newline\newline    if ( find_arg ( &quot-config&quot ) &lt 0 ) {\newline        const char *cpath = g_get_user_config_dir ();\newline        if ( cpath ) {\newline            config_path = g_build_filename ( cpath, &quotrofi&quot, &quotconfig&quot, NULL );\newline        }\newline    }\newline    else {\newline        char *c = NULL;\newline        find_arg_str ( &quot-config&quot, &ampc );\newline        config_path = rofi_expand_path ( c );\newline    }\newline\newline    TICK ();\newline    // Register cleanup function.\newline    atexit ( cleanup );\newline\newline    TICK ();\newline    // Get DISPLAY, first env, then argument.\newline    char *display_str = getenv ( &quotDISPLAY&quot );\newline    find_arg_str (  &quot-display&quot, &ampdisplay_str );\newline\newline    if ( setlocale ( LC_ALL, &quot&quot ) == NULL ) {\newline        fprintf ( stderr, &quotFailed to set locale.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xcb-&gtconnection = xcb_connect ( display_str, &ampxcb-&gtscreen_nbr );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotFailed to open display: %s&quot, display_str );\newline        return EXIT_FAILURE;\newline    }\newline    TICK_N ( &quotOpen Display&quot );\newline\newline    xcb-&gtscreen = xcb_aux_get_screen ( xcb-&gtconnection, xcb-&gtscreen_nbr );\newline\newline    x11_build_monitor_layout ();\newline\newline    xcb_intern_atom_cookie_t *ac     = xcb_ewmh_init_atoms ( xcb-&gtconnection, &ampxcb-&gtewmh );\newline    xcb_generic_error_t      *errors = NULL;\newline    xcb_ewmh_init_atoms_replies ( &ampxcb-&gtewmh, ac, &amperrors );\newline    if ( errors ) {\newline        fprintf ( stderr, &quotFailed to create EWMH atoms\\n&quot );\newline        free ( errors );\newline    }\newline\newline    if ( xkb_x11_setup_xkb_extension ( xcb-&gtconnection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION,\newline                                       XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, NULL, NULL, &ampxkb.first_event, NULL ) &lt 0 ) {\newline        fprintf ( stderr, &quotcannot setup XKB extension!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.context = xkb_context_new ( XKB_CONTEXT_NO_FLAGS );\newline    if ( xkb.context == NULL ) {\newline        fprintf ( stderr, &quotcannot create XKB context!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.xcb_connection = xcb-&gtconnection;\newline\newline    xkb.device_id = xkb_x11_get_core_keyboard_device_id ( xcb-&gtconnection );\newline\newline    enum\newline    {\newline        required_events =\newline            ( XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_MAP_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_STATE_NOTIFY ),\newline\newline        required_nkn_details =\newline            ( XCB_XKB_NKN_DETAIL_KEYCODES ),\newline\newline        required_map_parts   =\newline            ( XCB_XKB_MAP_PART_KEY_TYPES |\newline              XCB_XKB_MAP_PART_KEY_SYMS |\newline              XCB_XKB_MAP_PART_MODIFIER_MAP |\newline              XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |\newline              XCB_XKB_MAP_PART_KEY_ACTIONS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MODS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP ),\newline\newline        required_state_details =\newline            ( XCB_XKB_STATE_PART_MODIFIER_BASE |\newline              XCB_XKB_STATE_PART_MODIFIER_LATCH |\newline              XCB_XKB_STATE_PART_MODIFIER_LOCK |\newline              XCB_XKB_STATE_PART_GROUP_BASE |\newline              XCB_XKB_STATE_PART_GROUP_LATCH |\newline              XCB_XKB_STATE_PART_GROUP_LOCK ),\newline    };\newline\newline    static const xcb_xkb_select_events_details_t details = {\newline        .affectNewKeyboard  = required_nkn_details,\newline        .newKeyboardDetails = required_nkn_details,\newline        .affectState        = required_state_details,\newline        .stateDetails       = required_state_details,\newline    };\newline    xcb_xkb_select_events ( xcb-&gtconnection, xkb.device_id, required_events, /* affectWhich */\newline                            0,                                               /* clear */\newline                            required_events,                                 /* selectAll */\newline                            required_map_parts,                              /* affectMap */\newline                            required_map_parts,                              /* map */\newline                            &ampdetails );\newline\newline    xkb.keymap = xkb_x11_keymap_new_from_device ( xkb.context, xcb-&gtconnection, xkb.device_id, XKB_KEYMAP_COMPILE_NO_FLAGS );\newline    if ( xkb.keymap == NULL ) {\newline        fprintf ( stderr, &quotFailed to get Keymap for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.state = xkb_x11_state_new_from_device ( xkb.keymap, xcb-&gtconnection, xkb.device_id );\newline    if ( xkb.state == NULL ) {\newline        fprintf ( stderr, &quotFailed to get state object for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.compose.table = xkb_compose_table_new_from_locale ( xkb.context, setlocale ( LC_CTYPE, NULL ), 0 );\newline    if ( xkb.compose.table != NULL ) {\newline        xkb.compose.state = xkb_compose_state_new ( xkb.compose.table, 0 );\newline    }\newline    else {\newline        fprintf ( stderr, &quotFailed to get keyboard compose table. Trying to limp on.\\n&quot );\newline    }\newline\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    x11_setup ( &ampxkb );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    main_loop = g_main_loop_new ( NULL, FALSE );\newline\newline    TICK_N ( &quotSetup mainloop&quot );\newline    // startup not.\newline    xcb-&gtsndisplay = sn_xcb_display_new ( xcb-&gtconnection, error_trap_push, error_trap_pop );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline\newline    if ( xcb-&gtsndisplay != NULL ) {\newline        xcb-&gtsncontext = sn_launchee_context_new_from_environment ( xcb-&gtsndisplay, xcb-&gtscreen_nbr );\newline    }\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    TICK_N ( &quotStartup Notification&quot );\newline    // Setup keybinding\newline    setup_abe ();\newline    TICK_N ( &quotSetup abe&quot );\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        load_configuration ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options ( );\newline\newline    if ( !dmenu_mode ) {\newline        // setup_modi\newline        setup_modi ();\newline    }\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        // Reload for dynamic part.\newline        load_configuration_dynamic ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options_dynamic (  );\newline\newline    // Dump.\newline    // catch help request\newline    if ( find_arg (  &quot-h&quot ) &gt= 0 || find_arg (  &quot-help&quot ) &gt= 0 || find_arg (  &quot--help&quot ) &gt= 0 ) {\newline        help ( argc, argv );\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources&quot ) &gt= 0 ) {\newline        config_parse_xresource_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources-theme&quot ) &gt= 0 ) {\newline        config_parse_xresources_theme_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    main_loop_source = g_water_xcb_source_new_for_connection ( NULL, xcb-&gtconnection, main_loop_x11_event_handler, NULL, NULL );\newline\newline    TICK_N ( &quotX11 Setup &quot );\newline\newline    rofi_view_workers_initialize ();\newline\newline    // Setup signal handling sources.\newline    // SIGINT\newline    g_unix_signal_add ( SIGINT, main_loop_signal_handler_int, NULL );\newline\newline    g_idle_add ( startup, NULL );\newline\newline    // Pidfile + visuals\newline    int pfd = setup ();\newline    if ( pfd &lt 0 ) {\newline        return EXIT_FAILURE;\newline    }\newline    // Start mainloop.\newline    g_main_loop_run ( main_loop );\newline    teardown ( pfd );\newline    return return_code;\newline}\newline","\newline @param argc number of input arguments.\newline @param argv array of the input arguments.\newline \newline Main application entry point.\newline \newline @returns return code of rofi.\newline \newline","1306481","email.c","static void copy_type_list(type_list_t *l1, type_list_t *l2) {\newline  type_t *last = NULL;\newline\newline  for (type_t *ptr1 = l1-&gthead, *ptr2 = l2-&gthead; NULL != ptr1;\newline       ptr1 = ptr1-&gtnext, last = ptr2, ptr2 = ptr2-&gtnext) {\newline    if (NULL == ptr2) {\newline      ptr2 = smalloc(sizeof(*ptr2));\newline      ptr2-&gtname = NULL;\newline      ptr2-&gtnext = NULL;\newline\newline      if (NULL == last) {\newline        l2-&gthead = ptr2;\newline      } else {\newline        last-&gtnext = ptr2;\newline      }\newline\newline      l2-&gttail = ptr2;\newline    }\newline\newline    if (NULL == ptr2-&gtname) {\newline      ptr2-&gtname = sstrdup(ptr1-&gtname);\newline    }\newline\newline    ptr2-&gtvalue = ptr1-&gtvalue;\newline    ptr1-&gtvalue = 0;\newline  }\newline  return;\newline}\newline","Copy list l1 to list l2. l2 may partly exist already, but it is assumed\newline that neither the order nor the name of any element of either list is\newline changed and no elements are deleted. The values of l1 are reset to zero\newline after they have been copied to l2. \newline","4226559","cfg-old.c","static const gchar *cfg_old_filename_from_utf8(const gchar *fname)\newline{\newline#if defined(CFG_OLD_PLAYLIST) || defined(CFG_OLD_FILESELECT)\newline    static gchar *name;\newline\newline    if (g_utf8_validate(fname, -1, NULL)) {\newline        free(name);\newline        name = g_filename_from_utf8(fname, -1, NULL, NULL, NULL);\newline\newline        return name;\newline    }\newline#endif\newline    return fname;\newline}\newline","\newline @brief Convert a filename into the original byte sequence\newline according to the encoding specified in G_FILENAME_ENCODING,\newline if it&#039s currently in UTF-8.\newline \newline @param fname filename\newline \newline @return converted filename\newline \newline","311765","commands.c","void stop_executing_host_checks(void) {\newline	unsigned long attr = MODATTR_ACTIVE_CHECKS_ENABLED;\newline\newline	/* bail out if we&#039re already not executing hosts */\newline	if (execute_host_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	modified_host_process_attributes |= attr;\newline\newline	/* set the host check execution flag */\newline	execute_host_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_program_data(NEBTYPE_ADAPTIVEPROGRAM_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, CMD_NONE, attr, modified_host_process_attributes, MODATTR_NONE, modified_service_process_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the program info */\newline	update_program_status(FALSE);\newline\newline	return;\newline}\newline","stops executing host checks \newline","4713048","ximalpha.cpp","void CxImage::AlphaSetMax(BYTE nAlphaMax)\newline{\newline	info.nAlphaMax=nAlphaMax;\newline}\newline","\newline Sets global Alpha (opacity) value applied to the whole image,\newline valid only for painting functions.\newline \\param nAlphaMax: can be from 0 to 255\newline \newline","6430477","cmds.c","void indent_to(int n)\newline{\newline   int m;\newline   \newline   get_current_indent(&ampm);\newline   \newline   if (n != m)\newline     {\newline	bol ();\newline	jed_trim_whitespace();\newline	if (n &gt= 0) insert_whitespace(&ampn);\newline     }\newline}\newline","indent line to column n \newline","3068732","basiccmdline.cpp","BASICCMDLINE::~BASICCMDLINE()\newline	{\newline	NCL_ASSERT(next_command != NULL);\newline	delete [] next_command;\newline\newline	if (logf_open)\newline		logf.close();\newline	}\newline","----------------------------------------------------------------------------------------------------------------------\newline Closes `logf&#039 if it is open and deletes memory allocated to `next_command&#039.\newline \newline","3404448","scheme.c","pointer scheme_call(scheme *sc, pointer func, pointer args)\newline{\newline  int old_repl = sc-&gtinteractive_repl;\newline  sc-&gtinteractive_repl = 0;\newline  save_from_C_call(sc);\newline  sc-&gtenvir = sc-&gtglobal_env;\newline  sc-&gtargs = args;\newline  sc-&gtcode = func;\newline  sc-&gtretcode = 0;\newline  Eval_Cycle(sc, OP_APPLY);\newline  sc-&gtinteractive_repl = old_repl;\newline  restore_from_C_call(sc);\newline  return sc-&gtvalue;\newline}\newline","&quotfunc&quot and &quotargs&quot are assumed to be already eval&#039ed. \newline","4879587","parser.c","static void InsertNodeAsParent(Node *element, Node *node)\newline{\newline    node-&gtcontent = element;\newline    node-&gtlast = element;\newline    node-&gtparent = element-&gtparent;\newline    element-&gtparent = node;\newline\newline    if (node-&gtparent-&gtcontent == element)\newline        node-&gtparent-&gtcontent = node;\newline\newline    if (node-&gtparent-&gtlast == element)\newline        node-&gtparent-&gtlast = node;\newline\newline    node-&gtprev = element-&gtprev;\newline    element-&gtprev = null;\newline\newline    if (node-&gtprev)\newline        node-&gtprev-&gtnext = node;\newline\newline    node-&gtnext = element-&gtnext;\newline    element-&gtnext = null;\newline\newline    if (node-&gtnext)\newline        node-&gtnext-&gtprev = node;\newline}\newline","\newlineinsert node into markup tree in pace of element\newlinewhich is moved to become the child of the node\newline \newline","1328599","memaslap.c","static int64_t ms_parse_size()\newline{\newline  int64_t ret= -1;\newline  char unit= optarg[strlen(optarg) - 1];\newline\newline  optarg[strlen(optarg) - 1]= &#039\\0&#039;\newline  errno= 0;\newline  ret= strtoll(optarg, (char **)NULL, 10);\newline  if (errno != 0)\newline  {\newline    fprintf(stderr, &quotstrtoll(optarg,..): %s\\n&quot, strerror(errno));\newline    exit(1);\newline  }\newline\newline  switch (unit)\newline  {\newline  case &#039k&#039:\newline  case &#039K&#039:\newline    ret*= 1024;\newline    break;\newline\newline  case &#039m&#039:\newline  case &#039M&#039:\newline    ret*= 1024 * 1024;\newline    break;\newline\newline  case &#039g&#039:\newline  case &#039G&#039:\newline    ret*= 1024 * 1024 * 1024;\newline    break;\newline\newline  default:\newline    ret= -1;\newline    break;\newline  } /* switch */\newline\newline  return ret;\newline} /* ms_parse_size */\newline","used to parse the size string \newline","1560807","expression.c","int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\newline{\newline    //printf(&quotmodifyFieldVar(var = %s)\\n&quot, var-&gttoChars());\newline    Dsymbol *s = sc-&gtfunc;\newline    while (1)\newline    {\newline        FuncDeclaration *fd = NULL;\newline        if (s)\newline            fd = s-&gtisFuncDeclaration();\newline        if (fd &amp&amp\newline            ((fd-&gtisCtorDeclaration() &amp&amp var-&gtisField()) ||\newline             (fd-&gtisStaticCtorDeclaration() &amp&amp !var-&gtisField())) &amp&amp\newline            fd-&gttoParent2() == var-&gttoParent2() &amp&amp\newline            (!e1 || e1-&gtop == TOKthis)\newline           )\newline        {\newline            var-&gtctorinit = 1;\newline            //printf(&quotsetting ctorinit\\n&quot);\newline            int result = true;\newline            if (var-&gtisField() &amp&amp sc-&gtfieldinit &amp&amp !sc-&gtintypeof)\newline            {\newline                assert(e1);\newline                bool mustInit = (var-&gtstorage_class &amp STCnodefaultctor ||\newline                                 var-&gttype-&gtneedsNested());\newline\newline                size_t dim = sc-&gtfieldinit_dim;\newline                AggregateDeclaration *ad = fd-&gtisAggregateMember2();\newline                assert(ad);\newline                size_t i;\newline                for (i = 0; i &lt dim; i++)   // same as findFieldIndexByName in ctfeexp.c ?\newline                {\newline                    if (ad-&gtfields[i] == var)\newline                        break;\newline                }\newline                assert(i &lt dim);\newline                unsigned fi = sc-&gtfieldinit[i];\newline                if (fi &amp CSXthis_ctor)\newline                {\newline                    if (var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialized multiple times&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                else if (sc-&gtnoctor || fi &amp CSXlabel)\newline                {\newline                    if (!mustInit &amp&amp var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialization is not allowed in loops or after labels&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                sc-&gtfieldinit[i] |= CSXthis_ctor;\newline            }\newline            else if (fd != sc-&gtfunc)\newline            {\newline                if (var-&gttype-&gtisMutable())\newline                    result = false;\newline                else if (sc-&gtfunc-&gtfes)\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in foreach loop&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars());\newline                }\newline                else\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in nested function &#039%s&#039&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars(), sc-&gtfunc-&gttoChars());\newline                }\newline            }\newline            return result;\newline        }\newline        else\newline        {\newline            if (s)\newline            {\newline                s = s-&gttoParent2();\newline                continue;\newline            }\newline        }\newline        break;\newline    }\newline    return false;\newline}\newline","\newline Mark variable v as modified if it is inside a constructor that var\newline is a field in.\newline \newline","1480421","mainwindow.cpp","void MainWindow::mountWebDav() {\newline#ifdef Q_OS_WIN\newline  char dst[20] = {0};\newline  NETRESOURCEA netres;\newline  memset(&ampnetres, 0, sizeof(netres));\newline  netres.dwType = RESOURCETYPE_DISK;\newline  netres.lpLocalName = 0;\newline  netres.lpRemoteName = webDavUrl.toUtf8().data();\newline  DWORD size = sizeof(dst);\newline  DWORD r = WNetUseConnectionA(\newline      reinterpret_cast&ltHWND&gt(effectiveWinId()), &ampnetres,\newline      webDavPassword.toUtf8().constData(), webDavUser.toUtf8().constData(),\newline      CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_REDIRECT, dst, &ampsize,\newline      0);\newline  if (r == NO_ERROR) {\newline    passStore = dst;\newline  } else {\newline    char message[256] = {0};\newline    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, r, 0, message,\newline                   sizeof(message), 0);\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(tr(&quotFailed to connect WebDAV:\\n&quot) + message +\newline                             &quot (0x&quot + QString::number(r, 16) + &quot)&quot);\newline  }\newline#else\newline  fusedav.start(&quotfusedav -o nonempty -u \\&quot&quot + webDavUser + &quot\\&quot &quot + webDavUrl +\newline                &quot \\&quot&quot + passStore + &#039&quot&#039);\newline  fusedav.waitForStarted();\newline  if (fusedav.state() == QProcess::Running) {\newline    QString pwd = webDavPassword;\newline    bool ok = true;\newline    if (pwd.isEmpty()) {\newline      pwd = QInputDialog::getText(this, tr(&quotQtPass WebDAV password&quot),\newline                                  tr(&quotEnter password to connect to WebDAV:&quot),\newline                                  QLineEdit::Password, &quot&quot, &ampok);\newline    }\newline    if (ok &amp&amp !pwd.isEmpty()) {\newline      fusedav.write(pwd.toUtf8() + &#039\\n&#039);\newline      fusedav.closeWriteChannel();\newline      fusedav.waitForFinished(2000);\newline    } else {\newline      fusedav.terminate();\newline    }\newline  }\newline  QString error = fusedav.readAllStandardError();\newline  int prompt = error.indexOf(&quotPassword:&quot);\newline  if (prompt &gt= 0)\newline    error.remove(0, prompt + 10);\newline  if (fusedav.state() != QProcess::Running)\newline    error = tr(&quotfusedav exited unexpectedly\\n&quot) + error;\newline  if (error.size() &gt 0) {\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(\newline        tr(&quotFailed to start fusedav to connect WebDAV:\\n&quot) + error);\newline  }\newline#endif\newline}\newline","\newline @brief MainWindow::mountWebDav is some scary voodoo magic\newline \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","be fitted to measurements:","input arguments.","after they have","converted filename","executing","Sets","to column n","`next_command'.","assumed","become","the","hdb_database_unlock","modified","MainWindow::mountWebDav","if NULL, then this","Python's","element","the timestamp for","fread","highest multiplier.","interrupts."
"3W0XM68YZPV995W8OA49NOP4SEO1KT","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","32KTQ2V7RDFOBIWZ311J6QVGVITM9G","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:21:51 PDT 2019","Wed Apr 17 12:29:23 PDT 2019","Fri Apr 19 12:29:23 PDT 2019","2019-04-19 19:30:21 UTC","","","452","100% (27/27)","100% (27/27)","100% (27/27)","2205218","expfit.c","void expfunc(double *p, double *x, int m, int n, void *data)\newline{\newlineregister int i;\newline\newline  for(i=0; i&ltn; ++i){\newline    x[i]=p[0]*exp(-p[1]*i) + p[2];\newline  }\newline}\newline","model to be fitted to measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1 \newline","3371969","hdb.h","static inline void hdb_database_unlock (pthread_mutex_t *mutex)\newline{\newline	pthread_mutex_unlock (mutex);\newline}\newline","\newline @brief hdb_database_unlock\newline @param mutex\newline \newline","3922945","acr_io.c","Acr_Status acr_read_buffer(Acr_File *afp, unsigned char buffer[],\newline                           long nbytes_to_read, long *nbytes_read)\newline{\newline   long i;\newline   int ch;\newline\newline   for (i=0; i &lt nbytes_to_read; i++) {\newline      ch = acr_getc(afp);\newline      if (ch == EOF) {\newline         break;\newline      }\newline      buffer[i] = (unsigned char) ch;\newline   }\newline\newline   /* Save the number of bytes read */\newline   if (nbytes_read != NULL) {\newline      *nbytes_read = i;\newline   }\newline\newline   /* Return the status */\newline   if (i &gt= nbytes_to_read) {\newline      return ACR_OK;\newline   }\newline   else if (acr_get_io_watchpoint(afp) &lt= 0) {\newline      return ACR_REACHED_WATCHPOINT;\newline   }\newline   else if (i == 0) {\newline      return ACR_END_OF_INPUT;\newline   }\newline   else {\newline      return ACR_ABNORMAL_END_OF_INPUT;\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_read_buffer\newline@INPUT : afp\newlinenbytes_to_read\newline@OUTPUT : buffer\newlinenbytes_read - if NULL, then this value is ignored, otherwise\newlinethe number of bytes actually read in is returned.\newline@RETURNS : Input status. If an error occurs on the first byte, then\newlineACR_END_OF_INPUT is returned, if an error occurs elsewhere,\newlinethen ACR_ABNORMAL_END_OF_INPUT is returned, otherwise ACR_OK\newlineis returned.\newline@DESCRIPTION: Reads in a buffer of data and optionally returns the number \newlineof bytes read\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 12, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4675486","pygts.cpp","static FILE* streamFromPyFile(PyObject* file, const char* mode)\newline{\newline  int fd;\newline  FILE* fs;\newline\newline  fd = PyObject_AsFileDescriptor(file);\newline  if (fd &lt 0) return NULL;\newline\newline  fd = dup(fd);\newline  if (fd &lt 0) return NULL;\newline\newline  fs = fdopen(fd, mode);\newline  if (fs == NULL) {\newline    close(fd);\newline    return NULL;\newline  }\newline  return fs;\newline}\newline","Translate Python&#039s built-in file object to FILE \newline","895558","cabin.c","char *cblistpop(CBLIST *list, int *sp){\newline  int index;\newline  assert(list);\newline  if(list-&gtnum &lt 1) return NULL;\newline  index = list-&gtstart + list-&gtnum - 1;\newline  list-&gtnum--;\newline  if(sp) *sp = list-&gtarray[index].dsize;\newline  return list-&gtarray[index].dptr;\newline}\newline","Remove an element of the end of a list. \newline","4157091","instance.c","int send_http_header(int code, unsigned long long int size,char* headers,bool content,time_t timestamp,connection_t* connection_prop) {\newline    int sock=connection_prop-&gtsock;\newline    int len_head,wrote;\newline    char *head=malloc(HEADBUF);\newline    char* h_ptr=head;\newline    int left_head=HEADBUF;\newline\newline    connection_prop-&gtstatus_code=code; //Sets status code, for the logs\newline\newline    if (head==NULL) {\newline#ifdef SERVERDBG\newline        syslog(LOG_CRIT,&quotNot enough memory to allocate buffers&quot);\newline#endif\newline        return ERR_NOMEM;\newline    }\newline    if (headers==NULL) headers=&quot&quot;\newline\newline    /*Defines the Connection header\newline    It will send the connection header if the setting is non-default\newline    Ie: will send keep alive if keep-alive is enabled and protocol is not 1.1\newline    And will send close if keep-alive isn&#039t enabled and protocol is 1.1\newline    */\newline    char *connection_header;\newline    if (connection_prop-&gtprotocol_version!=HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==true) {\newline        connection_header=&quotConnection: Keep-Alive\\r\\n&quot;\newline    } else if (connection_prop-&gtprotocol_version==HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==false) {\newline        connection_header=&quotConnection: close\\r\\n&quot;\newline    } else {\newline        connection_header=&quot&quot;\newline    }\newline\newline    len_head=snprintf(head,HEADBUF,&quotHTTP/1.1 %d %s\\r\\nServer: &quot SIGNATURE &quot\\r\\n%s&quot,code,reason_phrase(code),connection_header);\newline\newline    //This stuff moves the pointer to the buffer forward, and reduces the left space in the buffer itself\newline    //Next snprintf will append their strings to the buffer, without overwriting.\newline    head+=len_head;\newline    left_head-=len_head;\newline\newline    //Creating ETag and date from timestamp\newline    if (timestamp!=-1) {\newline        //Sends ETag, if a timestamp is set\newline        len_head = snprintf(head,left_head,&quotETag: \\&quot%d\\&quot\\r\\n&quot,(int)timestamp);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#ifdef SEND_LAST_MODIFIED_HEADER\newline    else {//timestamp with now, to be eventually used by Last-Modified\newline        timestamp=time(NULL);\newline    }\newline\newline    {\newline        //Sends Date\newline        struct tm  ts;\newline        localtime_r((time_t)&amptimestamp,&ampts);\newline        len_head = strftime(head,left_head, &quotLast-Modified: %a, %d %b %Y %H:%M:%S GMT\\r\\n&quot, &ampts);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#endif\newline\newline    if (size&gt0 || (connection_prop-&gtkeep_alive==true)) {\newline        //Content length (or entity lenght) and extra headers\newline        if (content) {\newline            len_head=snprintf(head,left_head,&quotContent-Length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        } else {\newline            len_head=snprintf(head,left_head,&quotentity-length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        }\newline\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline\newline    len_head=snprintf(head,left_head,&quot%s\\r\\n&quot,headers);\newline    //head+=len_head; Not necessary because the snprintf was the last one\newline    left_head-=len_head;\newline\newline    wrote=write (sock,h_ptr,HEADBUF-left_head);\newline    free(h_ptr);\newline    if (wrote!=HEADBUF-left_head) return ERR_BRKPIPE;\newline    return 0;\newline}\newline","\newlineThis function sends a code header to the specified socket\newlinesize is the Content-Length field.\newlineheaders can be NULL or some extra headers to add. Headers must be\newlineseparated by \\r\\n and must have an \\r\\n at the end.\newlineContent says if the size is for content-lenght or for entity-length\newlineTimestamp is the timestamp for the content. Set to -1 to use the current\newlinetimestamp for Last-Modified and to omit ETag.\newlineThis function will automatically take care of generating Connection header when\newlineneeded, according to keep_alive and protocol_version of connection_prop\newline \newline","4963676","loader.c","static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,\newline                                            FLAC__byte buffer[],\newline                                            size_t *bytes,\newline                                            void *client_data){\newline  flac_callback_arg *flac = (flac_callback_arg *)client_data;\newline  pcm_t *pcm = flac-&gtpcm;\newline\newline  if(feof(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\newline  }else if(ferror(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\newline  }\newline\newline  if(sb_verbose)\newline    fprintf(stderr,&quot\\rLoading %s: %ld to go...       &quot,flac-&gtpcm-&gtname,(long)(pcm-&gtsize-flac-&gtfill));\newline  *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, flac-&gtin);\newline\newline  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\newline}\newline","glorified fread wrapper \newline","3840244","blazer.c","static double blazer_packs(const char *ptr, char **endptr)\newline{\newline	const double packs[] = {\newline		120, 100, 80, 60, 48, 36, 30, 24, 18, 12, 8, 6, 4, 3, 2, 1, 0.5, -1\newline	};\newline\newline	const char	*val;\newline	int		i;\newline\newline	val = dstate_getinfo(&quotbattery.voltage.nominal&quot);\newline\newline	batt.volt.nom = strtod(val ? val : ptr, endptr);\newline\newline	for (i = 0; packs[i] &gt 0; i++) {\newline\newline		if (packs[i] * batt.volt.act &gt 1.2 * batt.volt.nom) {\newline			continue;\newline		}\newline\newline		if (packs[i] * batt.volt.act &lt 0.8 * batt.volt.nom) {\newline			upslogx(LOG_INFO, &quotCan&#039t autodetect number of battery packs [%.0f/%.2f]&quot, batt.volt.nom, batt.volt.act);\newline			break;\newline		}\newline\newline		batt.packs = packs[i];\newline		break;\newline	}\newline\newline	return batt.volt.nom;\newline}\newline","\newline The battery voltage will quickly return to at least the nominal value after\newline discharging them. For overlapping battery.voltage.low/high ranges therefor\newline choose the one with the highest multiplier.\newline \newline","3502162","decode.c","static void x86emu_intr_handle(void)\newline{\newline	u8	intno;\newline\newline	if (M.x86.intr &amp INTR_SYNCH) {\newline		intno = M.x86.intno;\newline		if (_X86EMU_intrTab[intno]) {\newline			(*_X86EMU_intrTab[intno])(intno);\newline		} else {\newline			push_word((u16)M.x86.R_FLG);\newline			CLEAR_FLAG(F_IF);\newline			CLEAR_FLAG(F_TF);\newline			push_word(M.x86.R_CS);\newline			M.x86.R_CS = mem_access_word(intno * 4 + 2);\newline			push_word(M.x86.R_IP);\newline			M.x86.R_IP = mem_access_word(intno * 4);\newline			M.x86.intr = 0;\newline		}\newline	}\newline}\newline","\newlineREMARKS:\newlineHandles any pending asychronous interrupts.\newline \newline","2747698","rofi.c","int main ( int argc, char *argv[] )\newline{\newline    TIMINGS_START ();\newline\newline    cmd_set_arguments ( argc, argv );\newline\newline    // Version\newline    if ( find_arg (  &quot-v&quot ) &gt= 0 || find_arg (  &quot-version&quot ) &gt= 0 ) {\newline#ifdef GIT_VERSION\newline        fprintf ( stdout, &quotVersion: &quotGIT_VERSION &quot\\n&quot );\newline#else\newline        fprintf ( stdout, &quotVersion: &quotVERSION &quot\\n&quot );\newline#endif\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    // Detect if we are in dmenu mode.\newline    // This has two possible causes.\newline    // 1 the user specifies it on the command-line.\newline    if ( find_arg (  &quot-dmenu&quot ) &gt= 0 ) {\newline        dmenu_mode = TRUE;\newline    }\newline    // 2 the binary that executed is called dmenu (e.g. symlink to rofi)\newline    else{\newline        // Get the base name of the executable called.\newline        char               *base_name = g_path_get_basename ( argv[0] );\newline        const char * const dmenu_str  = &quotdmenu&quot;\newline        dmenu_mode = ( strcmp ( base_name, dmenu_str ) == 0 );\newline        // Free the basename for dmenu detection.\newline        g_free ( base_name );\newline    }\newline    TICK ();\newline    // Get the path to the cache dir.\newline    cache_dir = g_get_user_cache_dir ();\newline\newline    if ( g_mkdir_with_parents ( cache_dir, 0700 ) &lt 0 ) {\newline        fprintf ( stderr, &quotFailed to create cache directory: %s\\n&quot, strerror ( errno ) );\newline        return EXIT_FAILURE;\newline    }\newline\newline    // Create pid file path.\newline    const char *path = g_get_user_runtime_dir ();\newline    if ( path ) {\newline        if ( g_mkdir_with_parents ( path, 0700 ) &lt 0 ) {\newline            fprintf ( stderr, &quotFailed to create user runtime directory: %s\\n&quot, strerror ( errno ) );\newline            return EXIT_FAILURE;\newline        }\newline        pidfile = g_build_filename ( path, &quotrofi.pid&quot, NULL );\newline    }\newline    config_parser_add_option ( xrm_String, &quotpid&quot, (void * *) &amppidfile, &quotPidfile location&quot );\newline\newline    if ( find_arg ( &quot-config&quot ) &lt 0 ) {\newline        const char *cpath = g_get_user_config_dir ();\newline        if ( cpath ) {\newline            config_path = g_build_filename ( cpath, &quotrofi&quot, &quotconfig&quot, NULL );\newline        }\newline    }\newline    else {\newline        char *c = NULL;\newline        find_arg_str ( &quot-config&quot, &ampc );\newline        config_path = rofi_expand_path ( c );\newline    }\newline\newline    TICK ();\newline    // Register cleanup function.\newline    atexit ( cleanup );\newline\newline    TICK ();\newline    // Get DISPLAY, first env, then argument.\newline    char *display_str = getenv ( &quotDISPLAY&quot );\newline    find_arg_str (  &quot-display&quot, &ampdisplay_str );\newline\newline    if ( setlocale ( LC_ALL, &quot&quot ) == NULL ) {\newline        fprintf ( stderr, &quotFailed to set locale.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xcb-&gtconnection = xcb_connect ( display_str, &ampxcb-&gtscreen_nbr );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotFailed to open display: %s&quot, display_str );\newline        return EXIT_FAILURE;\newline    }\newline    TICK_N ( &quotOpen Display&quot );\newline\newline    xcb-&gtscreen = xcb_aux_get_screen ( xcb-&gtconnection, xcb-&gtscreen_nbr );\newline\newline    x11_build_monitor_layout ();\newline\newline    xcb_intern_atom_cookie_t *ac     = xcb_ewmh_init_atoms ( xcb-&gtconnection, &ampxcb-&gtewmh );\newline    xcb_generic_error_t      *errors = NULL;\newline    xcb_ewmh_init_atoms_replies ( &ampxcb-&gtewmh, ac, &amperrors );\newline    if ( errors ) {\newline        fprintf ( stderr, &quotFailed to create EWMH atoms\\n&quot );\newline        free ( errors );\newline    }\newline\newline    if ( xkb_x11_setup_xkb_extension ( xcb-&gtconnection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION,\newline                                       XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, NULL, NULL, &ampxkb.first_event, NULL ) &lt 0 ) {\newline        fprintf ( stderr, &quotcannot setup XKB extension!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.context = xkb_context_new ( XKB_CONTEXT_NO_FLAGS );\newline    if ( xkb.context == NULL ) {\newline        fprintf ( stderr, &quotcannot create XKB context!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.xcb_connection = xcb-&gtconnection;\newline\newline    xkb.device_id = xkb_x11_get_core_keyboard_device_id ( xcb-&gtconnection );\newline\newline    enum\newline    {\newline        required_events =\newline            ( XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_MAP_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_STATE_NOTIFY ),\newline\newline        required_nkn_details =\newline            ( XCB_XKB_NKN_DETAIL_KEYCODES ),\newline\newline        required_map_parts   =\newline            ( XCB_XKB_MAP_PART_KEY_TYPES |\newline              XCB_XKB_MAP_PART_KEY_SYMS |\newline              XCB_XKB_MAP_PART_MODIFIER_MAP |\newline              XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |\newline              XCB_XKB_MAP_PART_KEY_ACTIONS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MODS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP ),\newline\newline        required_state_details =\newline            ( XCB_XKB_STATE_PART_MODIFIER_BASE |\newline              XCB_XKB_STATE_PART_MODIFIER_LATCH |\newline              XCB_XKB_STATE_PART_MODIFIER_LOCK |\newline              XCB_XKB_STATE_PART_GROUP_BASE |\newline              XCB_XKB_STATE_PART_GROUP_LATCH |\newline              XCB_XKB_STATE_PART_GROUP_LOCK ),\newline    };\newline\newline    static const xcb_xkb_select_events_details_t details = {\newline        .affectNewKeyboard  = required_nkn_details,\newline        .newKeyboardDetails = required_nkn_details,\newline        .affectState        = required_state_details,\newline        .stateDetails       = required_state_details,\newline    };\newline    xcb_xkb_select_events ( xcb-&gtconnection, xkb.device_id, required_events, /* affectWhich */\newline                            0,                                               /* clear */\newline                            required_events,                                 /* selectAll */\newline                            required_map_parts,                              /* affectMap */\newline                            required_map_parts,                              /* map */\newline                            &ampdetails );\newline\newline    xkb.keymap = xkb_x11_keymap_new_from_device ( xkb.context, xcb-&gtconnection, xkb.device_id, XKB_KEYMAP_COMPILE_NO_FLAGS );\newline    if ( xkb.keymap == NULL ) {\newline        fprintf ( stderr, &quotFailed to get Keymap for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.state = xkb_x11_state_new_from_device ( xkb.keymap, xcb-&gtconnection, xkb.device_id );\newline    if ( xkb.state == NULL ) {\newline        fprintf ( stderr, &quotFailed to get state object for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.compose.table = xkb_compose_table_new_from_locale ( xkb.context, setlocale ( LC_CTYPE, NULL ), 0 );\newline    if ( xkb.compose.table != NULL ) {\newline        xkb.compose.state = xkb_compose_state_new ( xkb.compose.table, 0 );\newline    }\newline    else {\newline        fprintf ( stderr, &quotFailed to get keyboard compose table. Trying to limp on.\\n&quot );\newline    }\newline\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    x11_setup ( &ampxkb );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    main_loop = g_main_loop_new ( NULL, FALSE );\newline\newline    TICK_N ( &quotSetup mainloop&quot );\newline    // startup not.\newline    xcb-&gtsndisplay = sn_xcb_display_new ( xcb-&gtconnection, error_trap_push, error_trap_pop );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline\newline    if ( xcb-&gtsndisplay != NULL ) {\newline        xcb-&gtsncontext = sn_launchee_context_new_from_environment ( xcb-&gtsndisplay, xcb-&gtscreen_nbr );\newline    }\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    TICK_N ( &quotStartup Notification&quot );\newline    // Setup keybinding\newline    setup_abe ();\newline    TICK_N ( &quotSetup abe&quot );\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        load_configuration ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options ( );\newline\newline    if ( !dmenu_mode ) {\newline        // setup_modi\newline        setup_modi ();\newline    }\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        // Reload for dynamic part.\newline        load_configuration_dynamic ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options_dynamic (  );\newline\newline    // Dump.\newline    // catch help request\newline    if ( find_arg (  &quot-h&quot ) &gt= 0 || find_arg (  &quot-help&quot ) &gt= 0 || find_arg (  &quot--help&quot ) &gt= 0 ) {\newline        help ( argc, argv );\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources&quot ) &gt= 0 ) {\newline        config_parse_xresource_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources-theme&quot ) &gt= 0 ) {\newline        config_parse_xresources_theme_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    main_loop_source = g_water_xcb_source_new_for_connection ( NULL, xcb-&gtconnection, main_loop_x11_event_handler, NULL, NULL );\newline\newline    TICK_N ( &quotX11 Setup &quot );\newline\newline    rofi_view_workers_initialize ();\newline\newline    // Setup signal handling sources.\newline    // SIGINT\newline    g_unix_signal_add ( SIGINT, main_loop_signal_handler_int, NULL );\newline\newline    g_idle_add ( startup, NULL );\newline\newline    // Pidfile + visuals\newline    int pfd = setup ();\newline    if ( pfd &lt 0 ) {\newline        return EXIT_FAILURE;\newline    }\newline    // Start mainloop.\newline    g_main_loop_run ( main_loop );\newline    teardown ( pfd );\newline    return return_code;\newline}\newline","\newline @param argc number of input arguments.\newline @param argv array of the input arguments.\newline \newline Main application entry point.\newline \newline @returns return code of rofi.\newline \newline","1306481","email.c","static void copy_type_list(type_list_t *l1, type_list_t *l2) {\newline  type_t *last = NULL;\newline\newline  for (type_t *ptr1 = l1-&gthead, *ptr2 = l2-&gthead; NULL != ptr1;\newline       ptr1 = ptr1-&gtnext, last = ptr2, ptr2 = ptr2-&gtnext) {\newline    if (NULL == ptr2) {\newline      ptr2 = smalloc(sizeof(*ptr2));\newline      ptr2-&gtname = NULL;\newline      ptr2-&gtnext = NULL;\newline\newline      if (NULL == last) {\newline        l2-&gthead = ptr2;\newline      } else {\newline        last-&gtnext = ptr2;\newline      }\newline\newline      l2-&gttail = ptr2;\newline    }\newline\newline    if (NULL == ptr2-&gtname) {\newline      ptr2-&gtname = sstrdup(ptr1-&gtname);\newline    }\newline\newline    ptr2-&gtvalue = ptr1-&gtvalue;\newline    ptr1-&gtvalue = 0;\newline  }\newline  return;\newline}\newline","Copy list l1 to list l2. l2 may partly exist already, but it is assumed\newline that neither the order nor the name of any element of either list is\newline changed and no elements are deleted. The values of l1 are reset to zero\newline after they have been copied to l2. \newline","4226559","cfg-old.c","static const gchar *cfg_old_filename_from_utf8(const gchar *fname)\newline{\newline#if defined(CFG_OLD_PLAYLIST) || defined(CFG_OLD_FILESELECT)\newline    static gchar *name;\newline\newline    if (g_utf8_validate(fname, -1, NULL)) {\newline        free(name);\newline        name = g_filename_from_utf8(fname, -1, NULL, NULL, NULL);\newline\newline        return name;\newline    }\newline#endif\newline    return fname;\newline}\newline","\newline @brief Convert a filename into the original byte sequence\newline according to the encoding specified in G_FILENAME_ENCODING,\newline if it&#039s currently in UTF-8.\newline \newline @param fname filename\newline \newline @return converted filename\newline \newline","311765","commands.c","void stop_executing_host_checks(void) {\newline	unsigned long attr = MODATTR_ACTIVE_CHECKS_ENABLED;\newline\newline	/* bail out if we&#039re already not executing hosts */\newline	if (execute_host_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	modified_host_process_attributes |= attr;\newline\newline	/* set the host check execution flag */\newline	execute_host_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_program_data(NEBTYPE_ADAPTIVEPROGRAM_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, CMD_NONE, attr, modified_host_process_attributes, MODATTR_NONE, modified_service_process_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the program info */\newline	update_program_status(FALSE);\newline\newline	return;\newline}\newline","stops executing host checks \newline","4713048","ximalpha.cpp","void CxImage::AlphaSetMax(BYTE nAlphaMax)\newline{\newline	info.nAlphaMax=nAlphaMax;\newline}\newline","\newline Sets global Alpha (opacity) value applied to the whole image,\newline valid only for painting functions.\newline \\param nAlphaMax: can be from 0 to 255\newline \newline","6430477","cmds.c","void indent_to(int n)\newline{\newline   int m;\newline   \newline   get_current_indent(&ampm);\newline   \newline   if (n != m)\newline     {\newline	bol ();\newline	jed_trim_whitespace();\newline	if (n &gt= 0) insert_whitespace(&ampn);\newline     }\newline}\newline","indent line to column n \newline","3068732","basiccmdline.cpp","BASICCMDLINE::~BASICCMDLINE()\newline	{\newline	NCL_ASSERT(next_command != NULL);\newline	delete [] next_command;\newline\newline	if (logf_open)\newline		logf.close();\newline	}\newline","----------------------------------------------------------------------------------------------------------------------\newline Closes `logf&#039 if it is open and deletes memory allocated to `next_command&#039.\newline \newline","3404448","scheme.c","pointer scheme_call(scheme *sc, pointer func, pointer args)\newline{\newline  int old_repl = sc-&gtinteractive_repl;\newline  sc-&gtinteractive_repl = 0;\newline  save_from_C_call(sc);\newline  sc-&gtenvir = sc-&gtglobal_env;\newline  sc-&gtargs = args;\newline  sc-&gtcode = func;\newline  sc-&gtretcode = 0;\newline  Eval_Cycle(sc, OP_APPLY);\newline  sc-&gtinteractive_repl = old_repl;\newline  restore_from_C_call(sc);\newline  return sc-&gtvalue;\newline}\newline","&quotfunc&quot and &quotargs&quot are assumed to be already eval&#039ed. \newline","4879587","parser.c","static void InsertNodeAsParent(Node *element, Node *node)\newline{\newline    node-&gtcontent = element;\newline    node-&gtlast = element;\newline    node-&gtparent = element-&gtparent;\newline    element-&gtparent = node;\newline\newline    if (node-&gtparent-&gtcontent == element)\newline        node-&gtparent-&gtcontent = node;\newline\newline    if (node-&gtparent-&gtlast == element)\newline        node-&gtparent-&gtlast = node;\newline\newline    node-&gtprev = element-&gtprev;\newline    element-&gtprev = null;\newline\newline    if (node-&gtprev)\newline        node-&gtprev-&gtnext = node;\newline\newline    node-&gtnext = element-&gtnext;\newline    element-&gtnext = null;\newline\newline    if (node-&gtnext)\newline        node-&gtnext-&gtprev = node;\newline}\newline","\newlineinsert node into markup tree in pace of element\newlinewhich is moved to become the child of the node\newline \newline","1328599","memaslap.c","static int64_t ms_parse_size()\newline{\newline  int64_t ret= -1;\newline  char unit= optarg[strlen(optarg) - 1];\newline\newline  optarg[strlen(optarg) - 1]= &#039\\0&#039;\newline  errno= 0;\newline  ret= strtoll(optarg, (char **)NULL, 10);\newline  if (errno != 0)\newline  {\newline    fprintf(stderr, &quotstrtoll(optarg,..): %s\\n&quot, strerror(errno));\newline    exit(1);\newline  }\newline\newline  switch (unit)\newline  {\newline  case &#039k&#039:\newline  case &#039K&#039:\newline    ret*= 1024;\newline    break;\newline\newline  case &#039m&#039:\newline  case &#039M&#039:\newline    ret*= 1024 * 1024;\newline    break;\newline\newline  case &#039g&#039:\newline  case &#039G&#039:\newline    ret*= 1024 * 1024 * 1024;\newline    break;\newline\newline  default:\newline    ret= -1;\newline    break;\newline  } /* switch */\newline\newline  return ret;\newline} /* ms_parse_size */\newline","used to parse the size string \newline","1560807","expression.c","int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\newline{\newline    //printf(&quotmodifyFieldVar(var = %s)\\n&quot, var-&gttoChars());\newline    Dsymbol *s = sc-&gtfunc;\newline    while (1)\newline    {\newline        FuncDeclaration *fd = NULL;\newline        if (s)\newline            fd = s-&gtisFuncDeclaration();\newline        if (fd &amp&amp\newline            ((fd-&gtisCtorDeclaration() &amp&amp var-&gtisField()) ||\newline             (fd-&gtisStaticCtorDeclaration() &amp&amp !var-&gtisField())) &amp&amp\newline            fd-&gttoParent2() == var-&gttoParent2() &amp&amp\newline            (!e1 || e1-&gtop == TOKthis)\newline           )\newline        {\newline            var-&gtctorinit = 1;\newline            //printf(&quotsetting ctorinit\\n&quot);\newline            int result = true;\newline            if (var-&gtisField() &amp&amp sc-&gtfieldinit &amp&amp !sc-&gtintypeof)\newline            {\newline                assert(e1);\newline                bool mustInit = (var-&gtstorage_class &amp STCnodefaultctor ||\newline                                 var-&gttype-&gtneedsNested());\newline\newline                size_t dim = sc-&gtfieldinit_dim;\newline                AggregateDeclaration *ad = fd-&gtisAggregateMember2();\newline                assert(ad);\newline                size_t i;\newline                for (i = 0; i &lt dim; i++)   // same as findFieldIndexByName in ctfeexp.c ?\newline                {\newline                    if (ad-&gtfields[i] == var)\newline                        break;\newline                }\newline                assert(i &lt dim);\newline                unsigned fi = sc-&gtfieldinit[i];\newline                if (fi &amp CSXthis_ctor)\newline                {\newline                    if (var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialized multiple times&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                else if (sc-&gtnoctor || fi &amp CSXlabel)\newline                {\newline                    if (!mustInit &amp&amp var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialization is not allowed in loops or after labels&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                sc-&gtfieldinit[i] |= CSXthis_ctor;\newline            }\newline            else if (fd != sc-&gtfunc)\newline            {\newline                if (var-&gttype-&gtisMutable())\newline                    result = false;\newline                else if (sc-&gtfunc-&gtfes)\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in foreach loop&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars());\newline                }\newline                else\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in nested function &#039%s&#039&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars(), sc-&gtfunc-&gttoChars());\newline                }\newline            }\newline            return result;\newline        }\newline        else\newline        {\newline            if (s)\newline            {\newline                s = s-&gttoParent2();\newline                continue;\newline            }\newline        }\newline        break;\newline    }\newline    return false;\newline}\newline","\newline Mark variable v as modified if it is inside a constructor that var\newline is a field in.\newline \newline","1480421","mainwindow.cpp","void MainWindow::mountWebDav() {\newline#ifdef Q_OS_WIN\newline  char dst[20] = {0};\newline  NETRESOURCEA netres;\newline  memset(&ampnetres, 0, sizeof(netres));\newline  netres.dwType = RESOURCETYPE_DISK;\newline  netres.lpLocalName = 0;\newline  netres.lpRemoteName = webDavUrl.toUtf8().data();\newline  DWORD size = sizeof(dst);\newline  DWORD r = WNetUseConnectionA(\newline      reinterpret_cast&ltHWND&gt(effectiveWinId()), &ampnetres,\newline      webDavPassword.toUtf8().constData(), webDavUser.toUtf8().constData(),\newline      CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_REDIRECT, dst, &ampsize,\newline      0);\newline  if (r == NO_ERROR) {\newline    passStore = dst;\newline  } else {\newline    char message[256] = {0};\newline    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, r, 0, message,\newline                   sizeof(message), 0);\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(tr(&quotFailed to connect WebDAV:\\n&quot) + message +\newline                             &quot (0x&quot + QString::number(r, 16) + &quot)&quot);\newline  }\newline#else\newline  fusedav.start(&quotfusedav -o nonempty -u \\&quot&quot + webDavUser + &quot\\&quot &quot + webDavUrl +\newline                &quot \\&quot&quot + passStore + &#039&quot&#039);\newline  fusedav.waitForStarted();\newline  if (fusedav.state() == QProcess::Running) {\newline    QString pwd = webDavPassword;\newline    bool ok = true;\newline    if (pwd.isEmpty()) {\newline      pwd = QInputDialog::getText(this, tr(&quotQtPass WebDAV password&quot),\newline                                  tr(&quotEnter password to connect to WebDAV:&quot),\newline                                  QLineEdit::Password, &quot&quot, &ampok);\newline    }\newline    if (ok &amp&amp !pwd.isEmpty()) {\newline      fusedav.write(pwd.toUtf8() + &#039\\n&#039);\newline      fusedav.closeWriteChannel();\newline      fusedav.waitForFinished(2000);\newline    } else {\newline      fusedav.terminate();\newline    }\newline  }\newline  QString error = fusedav.readAllStandardError();\newline  int prompt = error.indexOf(&quotPassword:&quot);\newline  if (prompt &gt= 0)\newline    error.remove(0, prompt + 10);\newline  if (fusedav.state() != QProcess::Running)\newline    error = tr(&quotfusedav exited unexpectedly\\n&quot) + error;\newline  if (error.size() &gt 0) {\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(\newline        tr(&quotFailed to start fusedav to connect WebDAV:\\n&quot) + error);\newline  }\newline#endif\newline}\newline","\newline @brief MainWindow::mountWebDav is some scary voodoo magic\newline \newline","on","on","","","","","","","on","","","on","","on","","","","","on","","","","","","","","","","","","","","","","","on","","","","","","","{}","{}","Copy list","Convert a filename into the original byte sequence","stops executing host checks","Sets global Alpha (opacity) value applied to the whole image,","indent line to column","Closes `logf' if it is open and deletes memory allocated to `next_command'.","{}","insert node into markup tree","parse the size string","{}","Mark variable v as modified","{}","Reads in a buffer of data","Translate Python's built-in file object to FILE","Remove an element of the end of a list.","sends a code header to the specified socketsize","{}","battery voltage will quickly return to at least the nominal value","Handles any pending asychronous interrupts."
"3W0XM68YZPV995W8OA49NOP4SEO1KT","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","39RP059MEHT7ZBBW1LFFXWQ6JMCMBE","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 20:31:35 PDT 2019","Wed Apr 17 20:47:05 PDT 2019","Fri Apr 19 20:47:05 PDT 2019","2019-04-20 03:47:21 UTC","","","930","100% (10/10)","100% (10/10)","100% (10/10)","2205218","expfit.c","void expfunc(double *p, double *x, int m, int n, void *data)\newline{\newlineregister int i;\newline\newline  for(i=0; i&ltn; ++i){\newline    x[i]=p[0]*exp(-p[1]*i) + p[2];\newline  }\newline}\newline","model to be fitted to measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1 \newline","3371969","hdb.h","static inline void hdb_database_unlock (pthread_mutex_t *mutex)\newline{\newline	pthread_mutex_unlock (mutex);\newline}\newline","\newline @brief hdb_database_unlock\newline @param mutex\newline \newline","3922945","acr_io.c","Acr_Status acr_read_buffer(Acr_File *afp, unsigned char buffer[],\newline                           long nbytes_to_read, long *nbytes_read)\newline{\newline   long i;\newline   int ch;\newline\newline   for (i=0; i &lt nbytes_to_read; i++) {\newline      ch = acr_getc(afp);\newline      if (ch == EOF) {\newline         break;\newline      }\newline      buffer[i] = (unsigned char) ch;\newline   }\newline\newline   /* Save the number of bytes read */\newline   if (nbytes_read != NULL) {\newline      *nbytes_read = i;\newline   }\newline\newline   /* Return the status */\newline   if (i &gt= nbytes_to_read) {\newline      return ACR_OK;\newline   }\newline   else if (acr_get_io_watchpoint(afp) &lt= 0) {\newline      return ACR_REACHED_WATCHPOINT;\newline   }\newline   else if (i == 0) {\newline      return ACR_END_OF_INPUT;\newline   }\newline   else {\newline      return ACR_ABNORMAL_END_OF_INPUT;\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_read_buffer\newline@INPUT : afp\newlinenbytes_to_read\newline@OUTPUT : buffer\newlinenbytes_read - if NULL, then this value is ignored, otherwise\newlinethe number of bytes actually read in is returned.\newline@RETURNS : Input status. If an error occurs on the first byte, then\newlineACR_END_OF_INPUT is returned, if an error occurs elsewhere,\newlinethen ACR_ABNORMAL_END_OF_INPUT is returned, otherwise ACR_OK\newlineis returned.\newline@DESCRIPTION: Reads in a buffer of data and optionally returns the number \newlineof bytes read\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 12, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4675486","pygts.cpp","static FILE* streamFromPyFile(PyObject* file, const char* mode)\newline{\newline  int fd;\newline  FILE* fs;\newline\newline  fd = PyObject_AsFileDescriptor(file);\newline  if (fd &lt 0) return NULL;\newline\newline  fd = dup(fd);\newline  if (fd &lt 0) return NULL;\newline\newline  fs = fdopen(fd, mode);\newline  if (fs == NULL) {\newline    close(fd);\newline    return NULL;\newline  }\newline  return fs;\newline}\newline","Translate Python&#039s built-in file object to FILE \newline","895558","cabin.c","char *cblistpop(CBLIST *list, int *sp){\newline  int index;\newline  assert(list);\newline  if(list-&gtnum &lt 1) return NULL;\newline  index = list-&gtstart + list-&gtnum - 1;\newline  list-&gtnum--;\newline  if(sp) *sp = list-&gtarray[index].dsize;\newline  return list-&gtarray[index].dptr;\newline}\newline","Remove an element of the end of a list. \newline","4157091","instance.c","int send_http_header(int code, unsigned long long int size,char* headers,bool content,time_t timestamp,connection_t* connection_prop) {\newline    int sock=connection_prop-&gtsock;\newline    int len_head,wrote;\newline    char *head=malloc(HEADBUF);\newline    char* h_ptr=head;\newline    int left_head=HEADBUF;\newline\newline    connection_prop-&gtstatus_code=code; //Sets status code, for the logs\newline\newline    if (head==NULL) {\newline#ifdef SERVERDBG\newline        syslog(LOG_CRIT,&quotNot enough memory to allocate buffers&quot);\newline#endif\newline        return ERR_NOMEM;\newline    }\newline    if (headers==NULL) headers=&quot&quot;\newline\newline    /*Defines the Connection header\newline    It will send the connection header if the setting is non-default\newline    Ie: will send keep alive if keep-alive is enabled and protocol is not 1.1\newline    And will send close if keep-alive isn&#039t enabled and protocol is 1.1\newline    */\newline    char *connection_header;\newline    if (connection_prop-&gtprotocol_version!=HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==true) {\newline        connection_header=&quotConnection: Keep-Alive\\r\\n&quot;\newline    } else if (connection_prop-&gtprotocol_version==HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==false) {\newline        connection_header=&quotConnection: close\\r\\n&quot;\newline    } else {\newline        connection_header=&quot&quot;\newline    }\newline\newline    len_head=snprintf(head,HEADBUF,&quotHTTP/1.1 %d %s\\r\\nServer: &quot SIGNATURE &quot\\r\\n%s&quot,code,reason_phrase(code),connection_header);\newline\newline    //This stuff moves the pointer to the buffer forward, and reduces the left space in the buffer itself\newline    //Next snprintf will append their strings to the buffer, without overwriting.\newline    head+=len_head;\newline    left_head-=len_head;\newline\newline    //Creating ETag and date from timestamp\newline    if (timestamp!=-1) {\newline        //Sends ETag, if a timestamp is set\newline        len_head = snprintf(head,left_head,&quotETag: \\&quot%d\\&quot\\r\\n&quot,(int)timestamp);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#ifdef SEND_LAST_MODIFIED_HEADER\newline    else {//timestamp with now, to be eventually used by Last-Modified\newline        timestamp=time(NULL);\newline    }\newline\newline    {\newline        //Sends Date\newline        struct tm  ts;\newline        localtime_r((time_t)&amptimestamp,&ampts);\newline        len_head = strftime(head,left_head, &quotLast-Modified: %a, %d %b %Y %H:%M:%S GMT\\r\\n&quot, &ampts);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#endif\newline\newline    if (size&gt0 || (connection_prop-&gtkeep_alive==true)) {\newline        //Content length (or entity lenght) and extra headers\newline        if (content) {\newline            len_head=snprintf(head,left_head,&quotContent-Length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        } else {\newline            len_head=snprintf(head,left_head,&quotentity-length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        }\newline\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline\newline    len_head=snprintf(head,left_head,&quot%s\\r\\n&quot,headers);\newline    //head+=len_head; Not necessary because the snprintf was the last one\newline    left_head-=len_head;\newline\newline    wrote=write (sock,h_ptr,HEADBUF-left_head);\newline    free(h_ptr);\newline    if (wrote!=HEADBUF-left_head) return ERR_BRKPIPE;\newline    return 0;\newline}\newline","\newlineThis function sends a code header to the specified socket\newlinesize is the Content-Length field.\newlineheaders can be NULL or some extra headers to add. Headers must be\newlineseparated by \\r\\n and must have an \\r\\n at the end.\newlineContent says if the size is for content-lenght or for entity-length\newlineTimestamp is the timestamp for the content. Set to -1 to use the current\newlinetimestamp for Last-Modified and to omit ETag.\newlineThis function will automatically take care of generating Connection header when\newlineneeded, according to keep_alive and protocol_version of connection_prop\newline \newline","4963676","loader.c","static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,\newline                                            FLAC__byte buffer[],\newline                                            size_t *bytes,\newline                                            void *client_data){\newline  flac_callback_arg *flac = (flac_callback_arg *)client_data;\newline  pcm_t *pcm = flac-&gtpcm;\newline\newline  if(feof(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\newline  }else if(ferror(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\newline  }\newline\newline  if(sb_verbose)\newline    fprintf(stderr,&quot\\rLoading %s: %ld to go...       &quot,flac-&gtpcm-&gtname,(long)(pcm-&gtsize-flac-&gtfill));\newline  *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, flac-&gtin);\newline\newline  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\newline}\newline","glorified fread wrapper \newline","3840244","blazer.c","static double blazer_packs(const char *ptr, char **endptr)\newline{\newline	const double packs[] = {\newline		120, 100, 80, 60, 48, 36, 30, 24, 18, 12, 8, 6, 4, 3, 2, 1, 0.5, -1\newline	};\newline\newline	const char	*val;\newline	int		i;\newline\newline	val = dstate_getinfo(&quotbattery.voltage.nominal&quot);\newline\newline	batt.volt.nom = strtod(val ? val : ptr, endptr);\newline\newline	for (i = 0; packs[i] &gt 0; i++) {\newline\newline		if (packs[i] * batt.volt.act &gt 1.2 * batt.volt.nom) {\newline			continue;\newline		}\newline\newline		if (packs[i] * batt.volt.act &lt 0.8 * batt.volt.nom) {\newline			upslogx(LOG_INFO, &quotCan&#039t autodetect number of battery packs [%.0f/%.2f]&quot, batt.volt.nom, batt.volt.act);\newline			break;\newline		}\newline\newline		batt.packs = packs[i];\newline		break;\newline	}\newline\newline	return batt.volt.nom;\newline}\newline","\newline The battery voltage will quickly return to at least the nominal value after\newline discharging them. For overlapping battery.voltage.low/high ranges therefor\newline choose the one with the highest multiplier.\newline \newline","3502162","decode.c","static void x86emu_intr_handle(void)\newline{\newline	u8	intno;\newline\newline	if (M.x86.intr &amp INTR_SYNCH) {\newline		intno = M.x86.intno;\newline		if (_X86EMU_intrTab[intno]) {\newline			(*_X86EMU_intrTab[intno])(intno);\newline		} else {\newline			push_word((u16)M.x86.R_FLG);\newline			CLEAR_FLAG(F_IF);\newline			CLEAR_FLAG(F_TF);\newline			push_word(M.x86.R_CS);\newline			M.x86.R_CS = mem_access_word(intno * 4 + 2);\newline			push_word(M.x86.R_IP);\newline			M.x86.R_IP = mem_access_word(intno * 4);\newline			M.x86.intr = 0;\newline		}\newline	}\newline}\newline","\newlineREMARKS:\newlineHandles any pending asychronous interrupts.\newline \newline","2747698","rofi.c","int main ( int argc, char *argv[] )\newline{\newline    TIMINGS_START ();\newline\newline    cmd_set_arguments ( argc, argv );\newline\newline    // Version\newline    if ( find_arg (  &quot-v&quot ) &gt= 0 || find_arg (  &quot-version&quot ) &gt= 0 ) {\newline#ifdef GIT_VERSION\newline        fprintf ( stdout, &quotVersion: &quotGIT_VERSION &quot\\n&quot );\newline#else\newline        fprintf ( stdout, &quotVersion: &quotVERSION &quot\\n&quot );\newline#endif\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    // Detect if we are in dmenu mode.\newline    // This has two possible causes.\newline    // 1 the user specifies it on the command-line.\newline    if ( find_arg (  &quot-dmenu&quot ) &gt= 0 ) {\newline        dmenu_mode = TRUE;\newline    }\newline    // 2 the binary that executed is called dmenu (e.g. symlink to rofi)\newline    else{\newline        // Get the base name of the executable called.\newline        char               *base_name = g_path_get_basename ( argv[0] );\newline        const char * const dmenu_str  = &quotdmenu&quot;\newline        dmenu_mode = ( strcmp ( base_name, dmenu_str ) == 0 );\newline        // Free the basename for dmenu detection.\newline        g_free ( base_name );\newline    }\newline    TICK ();\newline    // Get the path to the cache dir.\newline    cache_dir = g_get_user_cache_dir ();\newline\newline    if ( g_mkdir_with_parents ( cache_dir, 0700 ) &lt 0 ) {\newline        fprintf ( stderr, &quotFailed to create cache directory: %s\\n&quot, strerror ( errno ) );\newline        return EXIT_FAILURE;\newline    }\newline\newline    // Create pid file path.\newline    const char *path = g_get_user_runtime_dir ();\newline    if ( path ) {\newline        if ( g_mkdir_with_parents ( path, 0700 ) &lt 0 ) {\newline            fprintf ( stderr, &quotFailed to create user runtime directory: %s\\n&quot, strerror ( errno ) );\newline            return EXIT_FAILURE;\newline        }\newline        pidfile = g_build_filename ( path, &quotrofi.pid&quot, NULL );\newline    }\newline    config_parser_add_option ( xrm_String, &quotpid&quot, (void * *) &amppidfile, &quotPidfile location&quot );\newline\newline    if ( find_arg ( &quot-config&quot ) &lt 0 ) {\newline        const char *cpath = g_get_user_config_dir ();\newline        if ( cpath ) {\newline            config_path = g_build_filename ( cpath, &quotrofi&quot, &quotconfig&quot, NULL );\newline        }\newline    }\newline    else {\newline        char *c = NULL;\newline        find_arg_str ( &quot-config&quot, &ampc );\newline        config_path = rofi_expand_path ( c );\newline    }\newline\newline    TICK ();\newline    // Register cleanup function.\newline    atexit ( cleanup );\newline\newline    TICK ();\newline    // Get DISPLAY, first env, then argument.\newline    char *display_str = getenv ( &quotDISPLAY&quot );\newline    find_arg_str (  &quot-display&quot, &ampdisplay_str );\newline\newline    if ( setlocale ( LC_ALL, &quot&quot ) == NULL ) {\newline        fprintf ( stderr, &quotFailed to set locale.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xcb-&gtconnection = xcb_connect ( display_str, &ampxcb-&gtscreen_nbr );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotFailed to open display: %s&quot, display_str );\newline        return EXIT_FAILURE;\newline    }\newline    TICK_N ( &quotOpen Display&quot );\newline\newline    xcb-&gtscreen = xcb_aux_get_screen ( xcb-&gtconnection, xcb-&gtscreen_nbr );\newline\newline    x11_build_monitor_layout ();\newline\newline    xcb_intern_atom_cookie_t *ac     = xcb_ewmh_init_atoms ( xcb-&gtconnection, &ampxcb-&gtewmh );\newline    xcb_generic_error_t      *errors = NULL;\newline    xcb_ewmh_init_atoms_replies ( &ampxcb-&gtewmh, ac, &amperrors );\newline    if ( errors ) {\newline        fprintf ( stderr, &quotFailed to create EWMH atoms\\n&quot );\newline        free ( errors );\newline    }\newline\newline    if ( xkb_x11_setup_xkb_extension ( xcb-&gtconnection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION,\newline                                       XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, NULL, NULL, &ampxkb.first_event, NULL ) &lt 0 ) {\newline        fprintf ( stderr, &quotcannot setup XKB extension!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.context = xkb_context_new ( XKB_CONTEXT_NO_FLAGS );\newline    if ( xkb.context == NULL ) {\newline        fprintf ( stderr, &quotcannot create XKB context!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.xcb_connection = xcb-&gtconnection;\newline\newline    xkb.device_id = xkb_x11_get_core_keyboard_device_id ( xcb-&gtconnection );\newline\newline    enum\newline    {\newline        required_events =\newline            ( XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_MAP_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_STATE_NOTIFY ),\newline\newline        required_nkn_details =\newline            ( XCB_XKB_NKN_DETAIL_KEYCODES ),\newline\newline        required_map_parts   =\newline            ( XCB_XKB_MAP_PART_KEY_TYPES |\newline              XCB_XKB_MAP_PART_KEY_SYMS |\newline              XCB_XKB_MAP_PART_MODIFIER_MAP |\newline              XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |\newline              XCB_XKB_MAP_PART_KEY_ACTIONS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MODS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP ),\newline\newline        required_state_details =\newline            ( XCB_XKB_STATE_PART_MODIFIER_BASE |\newline              XCB_XKB_STATE_PART_MODIFIER_LATCH |\newline              XCB_XKB_STATE_PART_MODIFIER_LOCK |\newline              XCB_XKB_STATE_PART_GROUP_BASE |\newline              XCB_XKB_STATE_PART_GROUP_LATCH |\newline              XCB_XKB_STATE_PART_GROUP_LOCK ),\newline    };\newline\newline    static const xcb_xkb_select_events_details_t details = {\newline        .affectNewKeyboard  = required_nkn_details,\newline        .newKeyboardDetails = required_nkn_details,\newline        .affectState        = required_state_details,\newline        .stateDetails       = required_state_details,\newline    };\newline    xcb_xkb_select_events ( xcb-&gtconnection, xkb.device_id, required_events, /* affectWhich */\newline                            0,                                               /* clear */\newline                            required_events,                                 /* selectAll */\newline                            required_map_parts,                              /* affectMap */\newline                            required_map_parts,                              /* map */\newline                            &ampdetails );\newline\newline    xkb.keymap = xkb_x11_keymap_new_from_device ( xkb.context, xcb-&gtconnection, xkb.device_id, XKB_KEYMAP_COMPILE_NO_FLAGS );\newline    if ( xkb.keymap == NULL ) {\newline        fprintf ( stderr, &quotFailed to get Keymap for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.state = xkb_x11_state_new_from_device ( xkb.keymap, xcb-&gtconnection, xkb.device_id );\newline    if ( xkb.state == NULL ) {\newline        fprintf ( stderr, &quotFailed to get state object for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.compose.table = xkb_compose_table_new_from_locale ( xkb.context, setlocale ( LC_CTYPE, NULL ), 0 );\newline    if ( xkb.compose.table != NULL ) {\newline        xkb.compose.state = xkb_compose_state_new ( xkb.compose.table, 0 );\newline    }\newline    else {\newline        fprintf ( stderr, &quotFailed to get keyboard compose table. Trying to limp on.\\n&quot );\newline    }\newline\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    x11_setup ( &ampxkb );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    main_loop = g_main_loop_new ( NULL, FALSE );\newline\newline    TICK_N ( &quotSetup mainloop&quot );\newline    // startup not.\newline    xcb-&gtsndisplay = sn_xcb_display_new ( xcb-&gtconnection, error_trap_push, error_trap_pop );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline\newline    if ( xcb-&gtsndisplay != NULL ) {\newline        xcb-&gtsncontext = sn_launchee_context_new_from_environment ( xcb-&gtsndisplay, xcb-&gtscreen_nbr );\newline    }\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    TICK_N ( &quotStartup Notification&quot );\newline    // Setup keybinding\newline    setup_abe ();\newline    TICK_N ( &quotSetup abe&quot );\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        load_configuration ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options ( );\newline\newline    if ( !dmenu_mode ) {\newline        // setup_modi\newline        setup_modi ();\newline    }\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        // Reload for dynamic part.\newline        load_configuration_dynamic ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options_dynamic (  );\newline\newline    // Dump.\newline    // catch help request\newline    if ( find_arg (  &quot-h&quot ) &gt= 0 || find_arg (  &quot-help&quot ) &gt= 0 || find_arg (  &quot--help&quot ) &gt= 0 ) {\newline        help ( argc, argv );\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources&quot ) &gt= 0 ) {\newline        config_parse_xresource_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources-theme&quot ) &gt= 0 ) {\newline        config_parse_xresources_theme_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    main_loop_source = g_water_xcb_source_new_for_connection ( NULL, xcb-&gtconnection, main_loop_x11_event_handler, NULL, NULL );\newline\newline    TICK_N ( &quotX11 Setup &quot );\newline\newline    rofi_view_workers_initialize ();\newline\newline    // Setup signal handling sources.\newline    // SIGINT\newline    g_unix_signal_add ( SIGINT, main_loop_signal_handler_int, NULL );\newline\newline    g_idle_add ( startup, NULL );\newline\newline    // Pidfile + visuals\newline    int pfd = setup ();\newline    if ( pfd &lt 0 ) {\newline        return EXIT_FAILURE;\newline    }\newline    // Start mainloop.\newline    g_main_loop_run ( main_loop );\newline    teardown ( pfd );\newline    return return_code;\newline}\newline","\newline @param argc number of input arguments.\newline @param argv array of the input arguments.\newline \newline Main application entry point.\newline \newline @returns return code of rofi.\newline \newline","1306481","email.c","static void copy_type_list(type_list_t *l1, type_list_t *l2) {\newline  type_t *last = NULL;\newline\newline  for (type_t *ptr1 = l1-&gthead, *ptr2 = l2-&gthead; NULL != ptr1;\newline       ptr1 = ptr1-&gtnext, last = ptr2, ptr2 = ptr2-&gtnext) {\newline    if (NULL == ptr2) {\newline      ptr2 = smalloc(sizeof(*ptr2));\newline      ptr2-&gtname = NULL;\newline      ptr2-&gtnext = NULL;\newline\newline      if (NULL == last) {\newline        l2-&gthead = ptr2;\newline      } else {\newline        last-&gtnext = ptr2;\newline      }\newline\newline      l2-&gttail = ptr2;\newline    }\newline\newline    if (NULL == ptr2-&gtname) {\newline      ptr2-&gtname = sstrdup(ptr1-&gtname);\newline    }\newline\newline    ptr2-&gtvalue = ptr1-&gtvalue;\newline    ptr1-&gtvalue = 0;\newline  }\newline  return;\newline}\newline","Copy list l1 to list l2. l2 may partly exist already, but it is assumed\newline that neither the order nor the name of any element of either list is\newline changed and no elements are deleted. The values of l1 are reset to zero\newline after they have been copied to l2. \newline","4226559","cfg-old.c","static const gchar *cfg_old_filename_from_utf8(const gchar *fname)\newline{\newline#if defined(CFG_OLD_PLAYLIST) || defined(CFG_OLD_FILESELECT)\newline    static gchar *name;\newline\newline    if (g_utf8_validate(fname, -1, NULL)) {\newline        free(name);\newline        name = g_filename_from_utf8(fname, -1, NULL, NULL, NULL);\newline\newline        return name;\newline    }\newline#endif\newline    return fname;\newline}\newline","\newline @brief Convert a filename into the original byte sequence\newline according to the encoding specified in G_FILENAME_ENCODING,\newline if it&#039s currently in UTF-8.\newline \newline @param fname filename\newline \newline @return converted filename\newline \newline","311765","commands.c","void stop_executing_host_checks(void) {\newline	unsigned long attr = MODATTR_ACTIVE_CHECKS_ENABLED;\newline\newline	/* bail out if we&#039re already not executing hosts */\newline	if (execute_host_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	modified_host_process_attributes |= attr;\newline\newline	/* set the host check execution flag */\newline	execute_host_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_program_data(NEBTYPE_ADAPTIVEPROGRAM_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, CMD_NONE, attr, modified_host_process_attributes, MODATTR_NONE, modified_service_process_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the program info */\newline	update_program_status(FALSE);\newline\newline	return;\newline}\newline","stops executing host checks \newline","4713048","ximalpha.cpp","void CxImage::AlphaSetMax(BYTE nAlphaMax)\newline{\newline	info.nAlphaMax=nAlphaMax;\newline}\newline","\newline Sets global Alpha (opacity) value applied to the whole image,\newline valid only for painting functions.\newline \\param nAlphaMax: can be from 0 to 255\newline \newline","6430477","cmds.c","void indent_to(int n)\newline{\newline   int m;\newline   \newline   get_current_indent(&ampm);\newline   \newline   if (n != m)\newline     {\newline	bol ();\newline	jed_trim_whitespace();\newline	if (n &gt= 0) insert_whitespace(&ampn);\newline     }\newline}\newline","indent line to column n \newline","3068732","basiccmdline.cpp","BASICCMDLINE::~BASICCMDLINE()\newline	{\newline	NCL_ASSERT(next_command != NULL);\newline	delete [] next_command;\newline\newline	if (logf_open)\newline		logf.close();\newline	}\newline","----------------------------------------------------------------------------------------------------------------------\newline Closes `logf&#039 if it is open and deletes memory allocated to `next_command&#039.\newline \newline","3404448","scheme.c","pointer scheme_call(scheme *sc, pointer func, pointer args)\newline{\newline  int old_repl = sc-&gtinteractive_repl;\newline  sc-&gtinteractive_repl = 0;\newline  save_from_C_call(sc);\newline  sc-&gtenvir = sc-&gtglobal_env;\newline  sc-&gtargs = args;\newline  sc-&gtcode = func;\newline  sc-&gtretcode = 0;\newline  Eval_Cycle(sc, OP_APPLY);\newline  sc-&gtinteractive_repl = old_repl;\newline  restore_from_C_call(sc);\newline  return sc-&gtvalue;\newline}\newline","&quotfunc&quot and &quotargs&quot are assumed to be already eval&#039ed. \newline","4879587","parser.c","static void InsertNodeAsParent(Node *element, Node *node)\newline{\newline    node-&gtcontent = element;\newline    node-&gtlast = element;\newline    node-&gtparent = element-&gtparent;\newline    element-&gtparent = node;\newline\newline    if (node-&gtparent-&gtcontent == element)\newline        node-&gtparent-&gtcontent = node;\newline\newline    if (node-&gtparent-&gtlast == element)\newline        node-&gtparent-&gtlast = node;\newline\newline    node-&gtprev = element-&gtprev;\newline    element-&gtprev = null;\newline\newline    if (node-&gtprev)\newline        node-&gtprev-&gtnext = node;\newline\newline    node-&gtnext = element-&gtnext;\newline    element-&gtnext = null;\newline\newline    if (node-&gtnext)\newline        node-&gtnext-&gtprev = node;\newline}\newline","\newlineinsert node into markup tree in pace of element\newlinewhich is moved to become the child of the node\newline \newline","1328599","memaslap.c","static int64_t ms_parse_size()\newline{\newline  int64_t ret= -1;\newline  char unit= optarg[strlen(optarg) - 1];\newline\newline  optarg[strlen(optarg) - 1]= &#039\\0&#039;\newline  errno= 0;\newline  ret= strtoll(optarg, (char **)NULL, 10);\newline  if (errno != 0)\newline  {\newline    fprintf(stderr, &quotstrtoll(optarg,..): %s\\n&quot, strerror(errno));\newline    exit(1);\newline  }\newline\newline  switch (unit)\newline  {\newline  case &#039k&#039:\newline  case &#039K&#039:\newline    ret*= 1024;\newline    break;\newline\newline  case &#039m&#039:\newline  case &#039M&#039:\newline    ret*= 1024 * 1024;\newline    break;\newline\newline  case &#039g&#039:\newline  case &#039G&#039:\newline    ret*= 1024 * 1024 * 1024;\newline    break;\newline\newline  default:\newline    ret= -1;\newline    break;\newline  } /* switch */\newline\newline  return ret;\newline} /* ms_parse_size */\newline","used to parse the size string \newline","1560807","expression.c","int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\newline{\newline    //printf(&quotmodifyFieldVar(var = %s)\\n&quot, var-&gttoChars());\newline    Dsymbol *s = sc-&gtfunc;\newline    while (1)\newline    {\newline        FuncDeclaration *fd = NULL;\newline        if (s)\newline            fd = s-&gtisFuncDeclaration();\newline        if (fd &amp&amp\newline            ((fd-&gtisCtorDeclaration() &amp&amp var-&gtisField()) ||\newline             (fd-&gtisStaticCtorDeclaration() &amp&amp !var-&gtisField())) &amp&amp\newline            fd-&gttoParent2() == var-&gttoParent2() &amp&amp\newline            (!e1 || e1-&gtop == TOKthis)\newline           )\newline        {\newline            var-&gtctorinit = 1;\newline            //printf(&quotsetting ctorinit\\n&quot);\newline            int result = true;\newline            if (var-&gtisField() &amp&amp sc-&gtfieldinit &amp&amp !sc-&gtintypeof)\newline            {\newline                assert(e1);\newline                bool mustInit = (var-&gtstorage_class &amp STCnodefaultctor ||\newline                                 var-&gttype-&gtneedsNested());\newline\newline                size_t dim = sc-&gtfieldinit_dim;\newline                AggregateDeclaration *ad = fd-&gtisAggregateMember2();\newline                assert(ad);\newline                size_t i;\newline                for (i = 0; i &lt dim; i++)   // same as findFieldIndexByName in ctfeexp.c ?\newline                {\newline                    if (ad-&gtfields[i] == var)\newline                        break;\newline                }\newline                assert(i &lt dim);\newline                unsigned fi = sc-&gtfieldinit[i];\newline                if (fi &amp CSXthis_ctor)\newline                {\newline                    if (var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialized multiple times&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                else if (sc-&gtnoctor || fi &amp CSXlabel)\newline                {\newline                    if (!mustInit &amp&amp var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialization is not allowed in loops or after labels&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                sc-&gtfieldinit[i] |= CSXthis_ctor;\newline            }\newline            else if (fd != sc-&gtfunc)\newline            {\newline                if (var-&gttype-&gtisMutable())\newline                    result = false;\newline                else if (sc-&gtfunc-&gtfes)\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in foreach loop&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars());\newline                }\newline                else\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in nested function &#039%s&#039&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars(), sc-&gtfunc-&gttoChars());\newline                }\newline            }\newline            return result;\newline        }\newline        else\newline        {\newline            if (s)\newline            {\newline                s = s-&gttoParent2();\newline                continue;\newline            }\newline        }\newline        break;\newline    }\newline    return false;\newline}\newline","\newline Mark variable v as modified if it is inside a constructor that var\newline is a field in.\newline \newline","1480421","mainwindow.cpp","void MainWindow::mountWebDav() {\newline#ifdef Q_OS_WIN\newline  char dst[20] = {0};\newline  NETRESOURCEA netres;\newline  memset(&ampnetres, 0, sizeof(netres));\newline  netres.dwType = RESOURCETYPE_DISK;\newline  netres.lpLocalName = 0;\newline  netres.lpRemoteName = webDavUrl.toUtf8().data();\newline  DWORD size = sizeof(dst);\newline  DWORD r = WNetUseConnectionA(\newline      reinterpret_cast&ltHWND&gt(effectiveWinId()), &ampnetres,\newline      webDavPassword.toUtf8().constData(), webDavUser.toUtf8().constData(),\newline      CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_REDIRECT, dst, &ampsize,\newline      0);\newline  if (r == NO_ERROR) {\newline    passStore = dst;\newline  } else {\newline    char message[256] = {0};\newline    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, r, 0, message,\newline                   sizeof(message), 0);\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(tr(&quotFailed to connect WebDAV:\\n&quot) + message +\newline                             &quot (0x&quot + QString::number(r, 16) + &quot)&quot);\newline  }\newline#else\newline  fusedav.start(&quotfusedav -o nonempty -u \\&quot&quot + webDavUser + &quot\\&quot &quot + webDavUrl +\newline                &quot \\&quot&quot + passStore + &#039&quot&#039);\newline  fusedav.waitForStarted();\newline  if (fusedav.state() == QProcess::Running) {\newline    QString pwd = webDavPassword;\newline    bool ok = true;\newline    if (pwd.isEmpty()) {\newline      pwd = QInputDialog::getText(this, tr(&quotQtPass WebDAV password&quot),\newline                                  tr(&quotEnter password to connect to WebDAV:&quot),\newline                                  QLineEdit::Password, &quot&quot, &ampok);\newline    }\newline    if (ok &amp&amp !pwd.isEmpty()) {\newline      fusedav.write(pwd.toUtf8() + &#039\\n&#039);\newline      fusedav.closeWriteChannel();\newline      fusedav.waitForFinished(2000);\newline    } else {\newline      fusedav.terminate();\newline    }\newline  }\newline  QString error = fusedav.readAllStandardError();\newline  int prompt = error.indexOf(&quotPassword:&quot);\newline  if (prompt &gt= 0)\newline    error.remove(0, prompt + 10);\newline  if (fusedav.state() != QProcess::Running)\newline    error = tr(&quotfusedav exited unexpectedly\\n&quot) + error;\newline  if (error.size() &gt 0) {\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(\newline        tr(&quotFailed to start fusedav to connect WebDAV:\\n&quot) + error);\newline  }\newline#endif\newline}\newline","\newline @brief MainWindow::mountWebDav is some scary voodoo magic\newline \newline","on","on","","","","","","","","","","on","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","{}","{}","The values of l1 are reset to zero","Convert a filename into the original byte sequence","stops executing host checks","Sets global Alpha (opacity) value applied to the whole image,","indent line to column n","Closes `logf' if it is open and deletes memory allocated","""func"" and ""args"" are assumed to be already eval'ed.","insert node into markup tree in pace of element","used to parse the size string","{}","Mark variable v as modified","{}","the number of bytes actually read","Translate Python's built-in file object to FILE","Remove an element of the end of a list.","Timestamp is the timestamp for the content.","glorified fread wrapper","choose the one with the highest multiplier.","Handles any pending asychronous interrupts."
"3W0XM68YZPV995W8OA49NOP4SEO1KT","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:51 PDT 2019","5","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:10:15 PDT 2019","","","3OVHNO1VE610DF8ZU6WF0OAF18QDZ7","A1NV81QEC0GDG7","Approved","Wed Apr 17 14:58:51 PDT 2019","Wed Apr 17 15:02:02 PDT 2019","Fri Apr 19 15:02:02 PDT 2019","2019-04-19 22:02:21 UTC","","","191","100% (5/5)","100% (5/5)","100% (5/5)","2205218","expfit.c","void expfunc(double *p, double *x, int m, int n, void *data)\newline{\newlineregister int i;\newline\newline  for(i=0; i&ltn; ++i){\newline    x[i]=p[0]*exp(-p[1]*i) + p[2];\newline  }\newline}\newline","model to be fitted to measurements: x_i = p[0] exp(-p[1] i) + p[2], i=0...n-1 \newline","3371969","hdb.h","static inline void hdb_database_unlock (pthread_mutex_t *mutex)\newline{\newline	pthread_mutex_unlock (mutex);\newline}\newline","\newline @brief hdb_database_unlock\newline @param mutex\newline \newline","3922945","acr_io.c","Acr_Status acr_read_buffer(Acr_File *afp, unsigned char buffer[],\newline                           long nbytes_to_read, long *nbytes_read)\newline{\newline   long i;\newline   int ch;\newline\newline   for (i=0; i &lt nbytes_to_read; i++) {\newline      ch = acr_getc(afp);\newline      if (ch == EOF) {\newline         break;\newline      }\newline      buffer[i] = (unsigned char) ch;\newline   }\newline\newline   /* Save the number of bytes read */\newline   if (nbytes_read != NULL) {\newline      *nbytes_read = i;\newline   }\newline\newline   /* Return the status */\newline   if (i &gt= nbytes_to_read) {\newline      return ACR_OK;\newline   }\newline   else if (acr_get_io_watchpoint(afp) &lt= 0) {\newline      return ACR_REACHED_WATCHPOINT;\newline   }\newline   else if (i == 0) {\newline      return ACR_END_OF_INPUT;\newline   }\newline   else {\newline      return ACR_ABNORMAL_END_OF_INPUT;\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_read_buffer\newline@INPUT : afp\newlinenbytes_to_read\newline@OUTPUT : buffer\newlinenbytes_read - if NULL, then this value is ignored, otherwise\newlinethe number of bytes actually read in is returned.\newline@RETURNS : Input status. If an error occurs on the first byte, then\newlineACR_END_OF_INPUT is returned, if an error occurs elsewhere,\newlinethen ACR_ABNORMAL_END_OF_INPUT is returned, otherwise ACR_OK\newlineis returned.\newline@DESCRIPTION: Reads in a buffer of data and optionally returns the number \newlineof bytes read\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 12, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4675486","pygts.cpp","static FILE* streamFromPyFile(PyObject* file, const char* mode)\newline{\newline  int fd;\newline  FILE* fs;\newline\newline  fd = PyObject_AsFileDescriptor(file);\newline  if (fd &lt 0) return NULL;\newline\newline  fd = dup(fd);\newline  if (fd &lt 0) return NULL;\newline\newline  fs = fdopen(fd, mode);\newline  if (fs == NULL) {\newline    close(fd);\newline    return NULL;\newline  }\newline  return fs;\newline}\newline","Translate Python&#039s built-in file object to FILE \newline","895558","cabin.c","char *cblistpop(CBLIST *list, int *sp){\newline  int index;\newline  assert(list);\newline  if(list-&gtnum &lt 1) return NULL;\newline  index = list-&gtstart + list-&gtnum - 1;\newline  list-&gtnum--;\newline  if(sp) *sp = list-&gtarray[index].dsize;\newline  return list-&gtarray[index].dptr;\newline}\newline","Remove an element of the end of a list. \newline","4157091","instance.c","int send_http_header(int code, unsigned long long int size,char* headers,bool content,time_t timestamp,connection_t* connection_prop) {\newline    int sock=connection_prop-&gtsock;\newline    int len_head,wrote;\newline    char *head=malloc(HEADBUF);\newline    char* h_ptr=head;\newline    int left_head=HEADBUF;\newline\newline    connection_prop-&gtstatus_code=code; //Sets status code, for the logs\newline\newline    if (head==NULL) {\newline#ifdef SERVERDBG\newline        syslog(LOG_CRIT,&quotNot enough memory to allocate buffers&quot);\newline#endif\newline        return ERR_NOMEM;\newline    }\newline    if (headers==NULL) headers=&quot&quot;\newline\newline    /*Defines the Connection header\newline    It will send the connection header if the setting is non-default\newline    Ie: will send keep alive if keep-alive is enabled and protocol is not 1.1\newline    And will send close if keep-alive isn&#039t enabled and protocol is 1.1\newline    */\newline    char *connection_header;\newline    if (connection_prop-&gtprotocol_version!=HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==true) {\newline        connection_header=&quotConnection: Keep-Alive\\r\\n&quot;\newline    } else if (connection_prop-&gtprotocol_version==HTTP_1_1 &amp&amp connection_prop-&gtkeep_alive==false) {\newline        connection_header=&quotConnection: close\\r\\n&quot;\newline    } else {\newline        connection_header=&quot&quot;\newline    }\newline\newline    len_head=snprintf(head,HEADBUF,&quotHTTP/1.1 %d %s\\r\\nServer: &quot SIGNATURE &quot\\r\\n%s&quot,code,reason_phrase(code),connection_header);\newline\newline    //This stuff moves the pointer to the buffer forward, and reduces the left space in the buffer itself\newline    //Next snprintf will append their strings to the buffer, without overwriting.\newline    head+=len_head;\newline    left_head-=len_head;\newline\newline    //Creating ETag and date from timestamp\newline    if (timestamp!=-1) {\newline        //Sends ETag, if a timestamp is set\newline        len_head = snprintf(head,left_head,&quotETag: \\&quot%d\\&quot\\r\\n&quot,(int)timestamp);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#ifdef SEND_LAST_MODIFIED_HEADER\newline    else {//timestamp with now, to be eventually used by Last-Modified\newline        timestamp=time(NULL);\newline    }\newline\newline    {\newline        //Sends Date\newline        struct tm  ts;\newline        localtime_r((time_t)&amptimestamp,&ampts);\newline        len_head = strftime(head,left_head, &quotLast-Modified: %a, %d %b %Y %H:%M:%S GMT\\r\\n&quot, &ampts);\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline#endif\newline\newline    if (size&gt0 || (connection_prop-&gtkeep_alive==true)) {\newline        //Content length (or entity lenght) and extra headers\newline        if (content) {\newline            len_head=snprintf(head,left_head,&quotContent-Length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        } else {\newline            len_head=snprintf(head,left_head,&quotentity-length: %llu\\r\\n&quot,(unsigned long long int)size);\newline        }\newline\newline        head+=len_head;\newline        left_head-=len_head;\newline    }\newline\newline    len_head=snprintf(head,left_head,&quot%s\\r\\n&quot,headers);\newline    //head+=len_head; Not necessary because the snprintf was the last one\newline    left_head-=len_head;\newline\newline    wrote=write (sock,h_ptr,HEADBUF-left_head);\newline    free(h_ptr);\newline    if (wrote!=HEADBUF-left_head) return ERR_BRKPIPE;\newline    return 0;\newline}\newline","\newlineThis function sends a code header to the specified socket\newlinesize is the Content-Length field.\newlineheaders can be NULL or some extra headers to add. Headers must be\newlineseparated by \\r\\n and must have an \\r\\n at the end.\newlineContent says if the size is for content-lenght or for entity-length\newlineTimestamp is the timestamp for the content. Set to -1 to use the current\newlinetimestamp for Last-Modified and to omit ETag.\newlineThis function will automatically take care of generating Connection header when\newlineneeded, according to keep_alive and protocol_version of connection_prop\newline \newline","4963676","loader.c","static FLAC__StreamDecoderReadStatus read_callback(const FLAC__StreamDecoder *decoder,\newline                                            FLAC__byte buffer[],\newline                                            size_t *bytes,\newline                                            void *client_data){\newline  flac_callback_arg *flac = (flac_callback_arg *)client_data;\newline  pcm_t *pcm = flac-&gtpcm;\newline\newline  if(feof(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\newline  }else if(ferror(flac-&gtin)){\newline    *bytes = 0;\newline    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\newline  }\newline\newline  if(sb_verbose)\newline    fprintf(stderr,&quot\\rLoading %s: %ld to go...       &quot,flac-&gtpcm-&gtname,(long)(pcm-&gtsize-flac-&gtfill));\newline  *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, flac-&gtin);\newline\newline  return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\newline}\newline","glorified fread wrapper \newline","3840244","blazer.c","static double blazer_packs(const char *ptr, char **endptr)\newline{\newline	const double packs[] = {\newline		120, 100, 80, 60, 48, 36, 30, 24, 18, 12, 8, 6, 4, 3, 2, 1, 0.5, -1\newline	};\newline\newline	const char	*val;\newline	int		i;\newline\newline	val = dstate_getinfo(&quotbattery.voltage.nominal&quot);\newline\newline	batt.volt.nom = strtod(val ? val : ptr, endptr);\newline\newline	for (i = 0; packs[i] &gt 0; i++) {\newline\newline		if (packs[i] * batt.volt.act &gt 1.2 * batt.volt.nom) {\newline			continue;\newline		}\newline\newline		if (packs[i] * batt.volt.act &lt 0.8 * batt.volt.nom) {\newline			upslogx(LOG_INFO, &quotCan&#039t autodetect number of battery packs [%.0f/%.2f]&quot, batt.volt.nom, batt.volt.act);\newline			break;\newline		}\newline\newline		batt.packs = packs[i];\newline		break;\newline	}\newline\newline	return batt.volt.nom;\newline}\newline","\newline The battery voltage will quickly return to at least the nominal value after\newline discharging them. For overlapping battery.voltage.low/high ranges therefor\newline choose the one with the highest multiplier.\newline \newline","3502162","decode.c","static void x86emu_intr_handle(void)\newline{\newline	u8	intno;\newline\newline	if (M.x86.intr &amp INTR_SYNCH) {\newline		intno = M.x86.intno;\newline		if (_X86EMU_intrTab[intno]) {\newline			(*_X86EMU_intrTab[intno])(intno);\newline		} else {\newline			push_word((u16)M.x86.R_FLG);\newline			CLEAR_FLAG(F_IF);\newline			CLEAR_FLAG(F_TF);\newline			push_word(M.x86.R_CS);\newline			M.x86.R_CS = mem_access_word(intno * 4 + 2);\newline			push_word(M.x86.R_IP);\newline			M.x86.R_IP = mem_access_word(intno * 4);\newline			M.x86.intr = 0;\newline		}\newline	}\newline}\newline","\newlineREMARKS:\newlineHandles any pending asychronous interrupts.\newline \newline","2747698","rofi.c","int main ( int argc, char *argv[] )\newline{\newline    TIMINGS_START ();\newline\newline    cmd_set_arguments ( argc, argv );\newline\newline    // Version\newline    if ( find_arg (  &quot-v&quot ) &gt= 0 || find_arg (  &quot-version&quot ) &gt= 0 ) {\newline#ifdef GIT_VERSION\newline        fprintf ( stdout, &quotVersion: &quotGIT_VERSION &quot\\n&quot );\newline#else\newline        fprintf ( stdout, &quotVersion: &quotVERSION &quot\\n&quot );\newline#endif\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    // Detect if we are in dmenu mode.\newline    // This has two possible causes.\newline    // 1 the user specifies it on the command-line.\newline    if ( find_arg (  &quot-dmenu&quot ) &gt= 0 ) {\newline        dmenu_mode = TRUE;\newline    }\newline    // 2 the binary that executed is called dmenu (e.g. symlink to rofi)\newline    else{\newline        // Get the base name of the executable called.\newline        char               *base_name = g_path_get_basename ( argv[0] );\newline        const char * const dmenu_str  = &quotdmenu&quot;\newline        dmenu_mode = ( strcmp ( base_name, dmenu_str ) == 0 );\newline        // Free the basename for dmenu detection.\newline        g_free ( base_name );\newline    }\newline    TICK ();\newline    // Get the path to the cache dir.\newline    cache_dir = g_get_user_cache_dir ();\newline\newline    if ( g_mkdir_with_parents ( cache_dir, 0700 ) &lt 0 ) {\newline        fprintf ( stderr, &quotFailed to create cache directory: %s\\n&quot, strerror ( errno ) );\newline        return EXIT_FAILURE;\newline    }\newline\newline    // Create pid file path.\newline    const char *path = g_get_user_runtime_dir ();\newline    if ( path ) {\newline        if ( g_mkdir_with_parents ( path, 0700 ) &lt 0 ) {\newline            fprintf ( stderr, &quotFailed to create user runtime directory: %s\\n&quot, strerror ( errno ) );\newline            return EXIT_FAILURE;\newline        }\newline        pidfile = g_build_filename ( path, &quotrofi.pid&quot, NULL );\newline    }\newline    config_parser_add_option ( xrm_String, &quotpid&quot, (void * *) &amppidfile, &quotPidfile location&quot );\newline\newline    if ( find_arg ( &quot-config&quot ) &lt 0 ) {\newline        const char *cpath = g_get_user_config_dir ();\newline        if ( cpath ) {\newline            config_path = g_build_filename ( cpath, &quotrofi&quot, &quotconfig&quot, NULL );\newline        }\newline    }\newline    else {\newline        char *c = NULL;\newline        find_arg_str ( &quot-config&quot, &ampc );\newline        config_path = rofi_expand_path ( c );\newline    }\newline\newline    TICK ();\newline    // Register cleanup function.\newline    atexit ( cleanup );\newline\newline    TICK ();\newline    // Get DISPLAY, first env, then argument.\newline    char *display_str = getenv ( &quotDISPLAY&quot );\newline    find_arg_str (  &quot-display&quot, &ampdisplay_str );\newline\newline    if ( setlocale ( LC_ALL, &quot&quot ) == NULL ) {\newline        fprintf ( stderr, &quotFailed to set locale.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xcb-&gtconnection = xcb_connect ( display_str, &ampxcb-&gtscreen_nbr );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotFailed to open display: %s&quot, display_str );\newline        return EXIT_FAILURE;\newline    }\newline    TICK_N ( &quotOpen Display&quot );\newline\newline    xcb-&gtscreen = xcb_aux_get_screen ( xcb-&gtconnection, xcb-&gtscreen_nbr );\newline\newline    x11_build_monitor_layout ();\newline\newline    xcb_intern_atom_cookie_t *ac     = xcb_ewmh_init_atoms ( xcb-&gtconnection, &ampxcb-&gtewmh );\newline    xcb_generic_error_t      *errors = NULL;\newline    xcb_ewmh_init_atoms_replies ( &ampxcb-&gtewmh, ac, &amperrors );\newline    if ( errors ) {\newline        fprintf ( stderr, &quotFailed to create EWMH atoms\\n&quot );\newline        free ( errors );\newline    }\newline\newline    if ( xkb_x11_setup_xkb_extension ( xcb-&gtconnection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION,\newline                                       XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, NULL, NULL, &ampxkb.first_event, NULL ) &lt 0 ) {\newline        fprintf ( stderr, &quotcannot setup XKB extension!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.context = xkb_context_new ( XKB_CONTEXT_NO_FLAGS );\newline    if ( xkb.context == NULL ) {\newline        fprintf ( stderr, &quotcannot create XKB context!\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.xcb_connection = xcb-&gtconnection;\newline\newline    xkb.device_id = xkb_x11_get_core_keyboard_device_id ( xcb-&gtconnection );\newline\newline    enum\newline    {\newline        required_events =\newline            ( XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_MAP_NOTIFY |\newline              XCB_XKB_EVENT_TYPE_STATE_NOTIFY ),\newline\newline        required_nkn_details =\newline            ( XCB_XKB_NKN_DETAIL_KEYCODES ),\newline\newline        required_map_parts   =\newline            ( XCB_XKB_MAP_PART_KEY_TYPES |\newline              XCB_XKB_MAP_PART_KEY_SYMS |\newline              XCB_XKB_MAP_PART_MODIFIER_MAP |\newline              XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |\newline              XCB_XKB_MAP_PART_KEY_ACTIONS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MODS |\newline              XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP ),\newline\newline        required_state_details =\newline            ( XCB_XKB_STATE_PART_MODIFIER_BASE |\newline              XCB_XKB_STATE_PART_MODIFIER_LATCH |\newline              XCB_XKB_STATE_PART_MODIFIER_LOCK |\newline              XCB_XKB_STATE_PART_GROUP_BASE |\newline              XCB_XKB_STATE_PART_GROUP_LATCH |\newline              XCB_XKB_STATE_PART_GROUP_LOCK ),\newline    };\newline\newline    static const xcb_xkb_select_events_details_t details = {\newline        .affectNewKeyboard  = required_nkn_details,\newline        .newKeyboardDetails = required_nkn_details,\newline        .affectState        = required_state_details,\newline        .stateDetails       = required_state_details,\newline    };\newline    xcb_xkb_select_events ( xcb-&gtconnection, xkb.device_id, required_events, /* affectWhich */\newline                            0,                                               /* clear */\newline                            required_events,                                 /* selectAll */\newline                            required_map_parts,                              /* affectMap */\newline                            required_map_parts,                              /* map */\newline                            &ampdetails );\newline\newline    xkb.keymap = xkb_x11_keymap_new_from_device ( xkb.context, xcb-&gtconnection, xkb.device_id, XKB_KEYMAP_COMPILE_NO_FLAGS );\newline    if ( xkb.keymap == NULL ) {\newline        fprintf ( stderr, &quotFailed to get Keymap for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline    xkb.state = xkb_x11_state_new_from_device ( xkb.keymap, xcb-&gtconnection, xkb.device_id );\newline    if ( xkb.state == NULL ) {\newline        fprintf ( stderr, &quotFailed to get state object for current keyboard device.\\n&quot );\newline        return EXIT_FAILURE;\newline    }\newline\newline    xkb.compose.table = xkb_compose_table_new_from_locale ( xkb.context, setlocale ( LC_CTYPE, NULL ), 0 );\newline    if ( xkb.compose.table != NULL ) {\newline        xkb.compose.state = xkb_compose_state_new ( xkb.compose.table, 0 );\newline    }\newline    else {\newline        fprintf ( stderr, &quotFailed to get keyboard compose table. Trying to limp on.\\n&quot );\newline    }\newline\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    x11_setup ( &ampxkb );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    main_loop = g_main_loop_new ( NULL, FALSE );\newline\newline    TICK_N ( &quotSetup mainloop&quot );\newline    // startup not.\newline    xcb-&gtsndisplay = sn_xcb_display_new ( xcb-&gtconnection, error_trap_push, error_trap_pop );\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline\newline    if ( xcb-&gtsndisplay != NULL ) {\newline        xcb-&gtsncontext = sn_launchee_context_new_from_environment ( xcb-&gtsndisplay, xcb-&gtscreen_nbr );\newline    }\newline    if ( xcb_connection_has_error ( xcb-&gtconnection ) ) {\newline        fprintf ( stderr, &quotConnection has error\\n&quot );\newline        exit ( EXIT_FAILURE );\newline    }\newline    TICK_N ( &quotStartup Notification&quot );\newline    // Setup keybinding\newline    setup_abe ();\newline    TICK_N ( &quotSetup abe&quot );\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        load_configuration ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options ( );\newline\newline    if ( !dmenu_mode ) {\newline        // setup_modi\newline        setup_modi ();\newline    }\newline\newline    if ( find_arg ( &quot-no-config&quot ) &lt 0 ) {\newline        // Reload for dynamic part.\newline        load_configuration_dynamic ( );\newline    }\newline    // Parse command line for settings, independent of other -no-config.\newline    config_parse_cmd_options_dynamic (  );\newline\newline    // Dump.\newline    // catch help request\newline    if ( find_arg (  &quot-h&quot ) &gt= 0 || find_arg (  &quot-help&quot ) &gt= 0 || find_arg (  &quot--help&quot ) &gt= 0 ) {\newline        help ( argc, argv );\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources&quot ) &gt= 0 ) {\newline        config_parse_xresource_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline    if ( find_arg (  &quot-dump-xresources-theme&quot ) &gt= 0 ) {\newline        config_parse_xresources_theme_dump ();\newline        exit ( EXIT_SUCCESS );\newline    }\newline\newline    main_loop_source = g_water_xcb_source_new_for_connection ( NULL, xcb-&gtconnection, main_loop_x11_event_handler, NULL, NULL );\newline\newline    TICK_N ( &quotX11 Setup &quot );\newline\newline    rofi_view_workers_initialize ();\newline\newline    // Setup signal handling sources.\newline    // SIGINT\newline    g_unix_signal_add ( SIGINT, main_loop_signal_handler_int, NULL );\newline\newline    g_idle_add ( startup, NULL );\newline\newline    // Pidfile + visuals\newline    int pfd = setup ();\newline    if ( pfd &lt 0 ) {\newline        return EXIT_FAILURE;\newline    }\newline    // Start mainloop.\newline    g_main_loop_run ( main_loop );\newline    teardown ( pfd );\newline    return return_code;\newline}\newline","\newline @param argc number of input arguments.\newline @param argv array of the input arguments.\newline \newline Main application entry point.\newline \newline @returns return code of rofi.\newline \newline","1306481","email.c","static void copy_type_list(type_list_t *l1, type_list_t *l2) {\newline  type_t *last = NULL;\newline\newline  for (type_t *ptr1 = l1-&gthead, *ptr2 = l2-&gthead; NULL != ptr1;\newline       ptr1 = ptr1-&gtnext, last = ptr2, ptr2 = ptr2-&gtnext) {\newline    if (NULL == ptr2) {\newline      ptr2 = smalloc(sizeof(*ptr2));\newline      ptr2-&gtname = NULL;\newline      ptr2-&gtnext = NULL;\newline\newline      if (NULL == last) {\newline        l2-&gthead = ptr2;\newline      } else {\newline        last-&gtnext = ptr2;\newline      }\newline\newline      l2-&gttail = ptr2;\newline    }\newline\newline    if (NULL == ptr2-&gtname) {\newline      ptr2-&gtname = sstrdup(ptr1-&gtname);\newline    }\newline\newline    ptr2-&gtvalue = ptr1-&gtvalue;\newline    ptr1-&gtvalue = 0;\newline  }\newline  return;\newline}\newline","Copy list l1 to list l2. l2 may partly exist already, but it is assumed\newline that neither the order nor the name of any element of either list is\newline changed and no elements are deleted. The values of l1 are reset to zero\newline after they have been copied to l2. \newline","4226559","cfg-old.c","static const gchar *cfg_old_filename_from_utf8(const gchar *fname)\newline{\newline#if defined(CFG_OLD_PLAYLIST) || defined(CFG_OLD_FILESELECT)\newline    static gchar *name;\newline\newline    if (g_utf8_validate(fname, -1, NULL)) {\newline        free(name);\newline        name = g_filename_from_utf8(fname, -1, NULL, NULL, NULL);\newline\newline        return name;\newline    }\newline#endif\newline    return fname;\newline}\newline","\newline @brief Convert a filename into the original byte sequence\newline according to the encoding specified in G_FILENAME_ENCODING,\newline if it&#039s currently in UTF-8.\newline \newline @param fname filename\newline \newline @return converted filename\newline \newline","311765","commands.c","void stop_executing_host_checks(void) {\newline	unsigned long attr = MODATTR_ACTIVE_CHECKS_ENABLED;\newline\newline	/* bail out if we&#039re already not executing hosts */\newline	if (execute_host_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	modified_host_process_attributes |= attr;\newline\newline	/* set the host check execution flag */\newline	execute_host_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_program_data(NEBTYPE_ADAPTIVEPROGRAM_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, CMD_NONE, attr, modified_host_process_attributes, MODATTR_NONE, modified_service_process_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the program info */\newline	update_program_status(FALSE);\newline\newline	return;\newline}\newline","stops executing host checks \newline","4713048","ximalpha.cpp","void CxImage::AlphaSetMax(BYTE nAlphaMax)\newline{\newline	info.nAlphaMax=nAlphaMax;\newline}\newline","\newline Sets global Alpha (opacity) value applied to the whole image,\newline valid only for painting functions.\newline \\param nAlphaMax: can be from 0 to 255\newline \newline","6430477","cmds.c","void indent_to(int n)\newline{\newline   int m;\newline   \newline   get_current_indent(&ampm);\newline   \newline   if (n != m)\newline     {\newline	bol ();\newline	jed_trim_whitespace();\newline	if (n &gt= 0) insert_whitespace(&ampn);\newline     }\newline}\newline","indent line to column n \newline","3068732","basiccmdline.cpp","BASICCMDLINE::~BASICCMDLINE()\newline	{\newline	NCL_ASSERT(next_command != NULL);\newline	delete [] next_command;\newline\newline	if (logf_open)\newline		logf.close();\newline	}\newline","----------------------------------------------------------------------------------------------------------------------\newline Closes `logf&#039 if it is open and deletes memory allocated to `next_command&#039.\newline \newline","3404448","scheme.c","pointer scheme_call(scheme *sc, pointer func, pointer args)\newline{\newline  int old_repl = sc-&gtinteractive_repl;\newline  sc-&gtinteractive_repl = 0;\newline  save_from_C_call(sc);\newline  sc-&gtenvir = sc-&gtglobal_env;\newline  sc-&gtargs = args;\newline  sc-&gtcode = func;\newline  sc-&gtretcode = 0;\newline  Eval_Cycle(sc, OP_APPLY);\newline  sc-&gtinteractive_repl = old_repl;\newline  restore_from_C_call(sc);\newline  return sc-&gtvalue;\newline}\newline","&quotfunc&quot and &quotargs&quot are assumed to be already eval&#039ed. \newline","4879587","parser.c","static void InsertNodeAsParent(Node *element, Node *node)\newline{\newline    node-&gtcontent = element;\newline    node-&gtlast = element;\newline    node-&gtparent = element-&gtparent;\newline    element-&gtparent = node;\newline\newline    if (node-&gtparent-&gtcontent == element)\newline        node-&gtparent-&gtcontent = node;\newline\newline    if (node-&gtparent-&gtlast == element)\newline        node-&gtparent-&gtlast = node;\newline\newline    node-&gtprev = element-&gtprev;\newline    element-&gtprev = null;\newline\newline    if (node-&gtprev)\newline        node-&gtprev-&gtnext = node;\newline\newline    node-&gtnext = element-&gtnext;\newline    element-&gtnext = null;\newline\newline    if (node-&gtnext)\newline        node-&gtnext-&gtprev = node;\newline}\newline","\newlineinsert node into markup tree in pace of element\newlinewhich is moved to become the child of the node\newline \newline","1328599","memaslap.c","static int64_t ms_parse_size()\newline{\newline  int64_t ret= -1;\newline  char unit= optarg[strlen(optarg) - 1];\newline\newline  optarg[strlen(optarg) - 1]= &#039\\0&#039;\newline  errno= 0;\newline  ret= strtoll(optarg, (char **)NULL, 10);\newline  if (errno != 0)\newline  {\newline    fprintf(stderr, &quotstrtoll(optarg,..): %s\\n&quot, strerror(errno));\newline    exit(1);\newline  }\newline\newline  switch (unit)\newline  {\newline  case &#039k&#039:\newline  case &#039K&#039:\newline    ret*= 1024;\newline    break;\newline\newline  case &#039m&#039:\newline  case &#039M&#039:\newline    ret*= 1024 * 1024;\newline    break;\newline\newline  case &#039g&#039:\newline  case &#039G&#039:\newline    ret*= 1024 * 1024 * 1024;\newline    break;\newline\newline  default:\newline    ret= -1;\newline    break;\newline  } /* switch */\newline\newline  return ret;\newline} /* ms_parse_size */\newline","used to parse the size string \newline","1560807","expression.c","int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\newline{\newline    //printf(&quotmodifyFieldVar(var = %s)\\n&quot, var-&gttoChars());\newline    Dsymbol *s = sc-&gtfunc;\newline    while (1)\newline    {\newline        FuncDeclaration *fd = NULL;\newline        if (s)\newline            fd = s-&gtisFuncDeclaration();\newline        if (fd &amp&amp\newline            ((fd-&gtisCtorDeclaration() &amp&amp var-&gtisField()) ||\newline             (fd-&gtisStaticCtorDeclaration() &amp&amp !var-&gtisField())) &amp&amp\newline            fd-&gttoParent2() == var-&gttoParent2() &amp&amp\newline            (!e1 || e1-&gtop == TOKthis)\newline           )\newline        {\newline            var-&gtctorinit = 1;\newline            //printf(&quotsetting ctorinit\\n&quot);\newline            int result = true;\newline            if (var-&gtisField() &amp&amp sc-&gtfieldinit &amp&amp !sc-&gtintypeof)\newline            {\newline                assert(e1);\newline                bool mustInit = (var-&gtstorage_class &amp STCnodefaultctor ||\newline                                 var-&gttype-&gtneedsNested());\newline\newline                size_t dim = sc-&gtfieldinit_dim;\newline                AggregateDeclaration *ad = fd-&gtisAggregateMember2();\newline                assert(ad);\newline                size_t i;\newline                for (i = 0; i &lt dim; i++)   // same as findFieldIndexByName in ctfeexp.c ?\newline                {\newline                    if (ad-&gtfields[i] == var)\newline                        break;\newline                }\newline                assert(i &lt dim);\newline                unsigned fi = sc-&gtfieldinit[i];\newline                if (fi &amp CSXthis_ctor)\newline                {\newline                    if (var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialized multiple times&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                else if (sc-&gtnoctor || fi &amp CSXlabel)\newline                {\newline                    if (!mustInit &amp&amp var-&gttype-&gtisMutable() &amp&amp e1-&gttype-&gtisMutable())\newline                        result = false;\newline                    else\newline                    {\newline                        const char *modStr = !var-&gttype-&gtisMutable() ? MODtoChars(var-&gttype-&gtmod) : MODtoChars(e1-&gttype-&gtmod);\newline                        ::error(loc, &quot%s field &#039%s&#039 initialization is not allowed in loops or after labels&quot, modStr, var-&gttoChars());\newline                    }\newline                }\newline                sc-&gtfieldinit[i] |= CSXthis_ctor;\newline            }\newline            else if (fd != sc-&gtfunc)\newline            {\newline                if (var-&gttype-&gtisMutable())\newline                    result = false;\newline                else if (sc-&gtfunc-&gtfes)\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in foreach loop&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars());\newline                }\newline                else\newline                {\newline                    const char *p = var-&gtisField() ? &quotfield&quot : var-&gtkind();\newline                    ::error(loc, &quot%s %s &#039%s&#039 initialization is not allowed in nested function &#039%s&#039&quot,\newline                        MODtoChars(var-&gttype-&gtmod), p, var-&gttoChars(), sc-&gtfunc-&gttoChars());\newline                }\newline            }\newline            return result;\newline        }\newline        else\newline        {\newline            if (s)\newline            {\newline                s = s-&gttoParent2();\newline                continue;\newline            }\newline        }\newline        break;\newline    }\newline    return false;\newline}\newline","\newline Mark variable v as modified if it is inside a constructor that var\newline is a field in.\newline \newline","1480421","mainwindow.cpp","void MainWindow::mountWebDav() {\newline#ifdef Q_OS_WIN\newline  char dst[20] = {0};\newline  NETRESOURCEA netres;\newline  memset(&ampnetres, 0, sizeof(netres));\newline  netres.dwType = RESOURCETYPE_DISK;\newline  netres.lpLocalName = 0;\newline  netres.lpRemoteName = webDavUrl.toUtf8().data();\newline  DWORD size = sizeof(dst);\newline  DWORD r = WNetUseConnectionA(\newline      reinterpret_cast&ltHWND&gt(effectiveWinId()), &ampnetres,\newline      webDavPassword.toUtf8().constData(), webDavUser.toUtf8().constData(),\newline      CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_REDIRECT, dst, &ampsize,\newline      0);\newline  if (r == NO_ERROR) {\newline    passStore = dst;\newline  } else {\newline    char message[256] = {0};\newline    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, 0, r, 0, message,\newline                   sizeof(message), 0);\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(tr(&quotFailed to connect WebDAV:\\n&quot) + message +\newline                             &quot (0x&quot + QString::number(r, 16) + &quot)&quot);\newline  }\newline#else\newline  fusedav.start(&quotfusedav -o nonempty -u \\&quot&quot + webDavUser + &quot\\&quot &quot + webDavUrl +\newline                &quot \\&quot&quot + passStore + &#039&quot&#039);\newline  fusedav.waitForStarted();\newline  if (fusedav.state() == QProcess::Running) {\newline    QString pwd = webDavPassword;\newline    bool ok = true;\newline    if (pwd.isEmpty()) {\newline      pwd = QInputDialog::getText(this, tr(&quotQtPass WebDAV password&quot),\newline                                  tr(&quotEnter password to connect to WebDAV:&quot),\newline                                  QLineEdit::Password, &quot&quot, &ampok);\newline    }\newline    if (ok &amp&amp !pwd.isEmpty()) {\newline      fusedav.write(pwd.toUtf8() + &#039\\n&#039);\newline      fusedav.closeWriteChannel();\newline      fusedav.waitForFinished(2000);\newline    } else {\newline      fusedav.terminate();\newline    }\newline  }\newline  QString error = fusedav.readAllStandardError();\newline  int prompt = error.indexOf(&quotPassword:&quot);\newline  if (prompt &gt= 0)\newline    error.remove(0, prompt + 10);\newline  if (fusedav.state() != QProcess::Running)\newline    error = tr(&quotfusedav exited unexpectedly\\n&quot) + error;\newline  if (error.size() &gt 0) {\newline    ui-&gttextBrowser-&gtsetTextColor(Qt::red);\newline    ui-&gttextBrowser-&gtsetText(\newline        tr(&quotFailed to start fusedav to connect WebDAV:\\n&quot) + error);\newline  }\newline#endif\newline}\newline","\newline @brief MainWindow::mountWebDav is some scary voodoo magic\newline \newline","on","","","","","","on","","on","","","","","on","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","","{}","Main application entry point.","Copy list l1 to list l2.","Convert a filename into the original byte sequence","stops executing host checks","Sets global Alpha (opacity) value","{}","Closes `logf' if it is open","{}","insert node into markup tree","parse the size string","hdb_database_unlock","Mark variable","{}","Reads in a buffer of data","Translate Python's built-in file object to FILE","Remove an element of the end of a list.","This function sends a code header to the specified socketsize","{}","{}","Handles any pending asychronous interrupts."
"3WYZV0QBFJDG63D7PQCNJUAFAZUBXB","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","35H6S234SA03LS9VDVHL5ETSJMX651","AMD1LYNQAH3R8","Approved","Wed Apr 17 12:29:28 PDT 2019","Wed Apr 17 12:35:24 PDT 2019","Fri Apr 19 12:35:24 PDT 2019","2019-04-19 19:36:21 UTC","","","356","100% (27/27)","100% (27/27)","100% (27/27)","3580134","image.c","GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline","\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline","5108090","evaluate.c","static void eval_fveor(void) {\newline  stackitem lhitem;\newline  int32 rhint = TOINT(pop_float());\newline  lhitem = GET_TOPITEM;\newline  if (lhitem == STACK_INT)\newline    EOR_INT(rhint);\newline  else if (lhitem == STACK_FLOAT)\newline    push_int(TOINT(pop_float()) ^ rhint);\newline  else {\newline    want_number();\newline  }\newline}\newline","\newline &#039eval_fveor&#039 deals with the exclusive or operator when right-hand\newline operand is a floating point value\newline \newline","4350475","numrgts.cpp","void NumberFormatRegressionTest::TestJ691(void) {\newline    UErrorCode status = U_ZERO_ERROR;\newline    Locale loc(&quotfr&quot, &quotCH&quot);\newline\newline    // set up the input date string &amp expected output\newline    UnicodeString udt(&quot11.10.2000&quot, &quot&quot);\newline    UnicodeString exp(&quot11.10.00&quot, &quot&quot);\newline\newline    // create a Calendar for this locale\newline    Calendar *cal = Calendar::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: Calendar::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // create a NumberFormat for this locale\newline    NumberFormat *nf = NumberFormat::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: NumberFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // *** Here&#039s the key: We don&#039t want to have to do THIS:\newline    // nf-&gtsetParseIntegerOnly(TRUE);\newline\newline    // create the DateFormat\newline    DateFormat *df = DateFormat::createDateInstance(DateFormat::kShort, loc);\newline    if (U_FAILURE(status)) {\newline        errln(&quotFAIL: DateFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    df-&gtadoptCalendar(cal);\newline    df-&gtadoptNumberFormat(nf);\newline\newline    // set parsing to lenient &amp parse\newline    df-&gtsetLenient(TRUE);\newline    UDate ulocdat = df-&gtparse(udt, status);\newline\newline    // format back to a string\newline    UnicodeString outString;\newline    df-&gtformat(ulocdat, outString);\newline\newline    if (outString != exp) {\newline        errln(&quotFAIL: &quot + udt + &quot =&gt &quot + outString);\newline    }\newline\newline    delete df;\newline}\newline","\newline DateFormat should call setIntegerParseOnly(TRUE) on adopted\newline NumberFormat objects.\newline \newline","1226709","poly_simplifier_plugin.cpp","void poly_simplifier_plugin::process_monomial(unsigned num_args, expr * const * args, numeral &amp k, ptr_buffer&ltexpr&gt &amp result) {\newline    rational v;\newline    for (unsigned i = 0; i &lt num_args; i++) {\newline        expr * arg = args[i];\newline        if (is_numeral(arg, v))\newline            k *= v;\newline        else\newline            result.push_back(arg);\newline    }\newline}\newline","\newline\\brief Traverse args, and copy the non-numeral exprs to result, and accumulate the \newlinevalue of the numerals in k.\newline \newline","5137164","dnssec.c","static int explore_rrset(struct dns_header *header, size_t plen, int class, int type, \newline			 char *name, char *keyname, int *sigcnt, int *rrcnt)\newline{\newline  static int rrset_sz = 0, sig_sz = 0; \newline  unsigned char *p;\newline  int rrsetidx, sigidx, j, rdlen, res;\newline  int gotkey = 0;\newline\newline  if (!(p = skip_questions(header, plen)))\newline    return STAT_BOGUS;\newline\newline   /* look for RRSIGs for this RRset and get pointers to each RR in the set. */\newline  for (rrsetidx = 0, sigidx = 0, j = ntohs(header-&gtancount) + ntohs(header-&gtnscount); \newline       j != 0; j--) \newline    {\newline      unsigned char *pstart, *pdata;\newline      int stype, sclass, type_covered;\newline\newline      pstart = p;\newline      \newline      if (!(res = extract_name(header, plen, &ampp, name, 0, 10)))\newline	return STAT_BOGUS; /* bad packet */\newline      \newline      GETSHORT(stype, p);\newline      GETSHORT(sclass, p);\newline      p += 4; /* TTL */\newline      \newline      pdata = p;\newline\newline      GETSHORT(rdlen, p);\newline      \newline      if (!CHECK_LEN(header, p, plen, rdlen))\newline	return 0; \newline      \newline      if (res == 1 &amp&amp sclass == class)\newline	{\newline	  if (stype == type)\newline	    {\newline	      if (!expand_workspace(&amprrset, &amprrset_sz, rrsetidx))\newline		return 0; \newline	      \newline	      rrset[rrsetidx++] = pstart;\newline	    }\newline	  \newline	  if (stype == T_RRSIG)\newline	    {\newline	      if (rdlen &lt 18)\newline		return 0; /* bad packet */ \newline	      \newline	      GETSHORT(type_covered, p);\newline	      p += 16; /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */\newline	      \newline	      if (gotkey)\newline		{\newline		  /* If there&#039s more than one SIG, ensure they all have same keyname */\newline		  if (extract_name(header, plen, &ampp, keyname, 0, 0) != 1)\newline		    return 0;\newline		}\newline	      else\newline		{\newline		  gotkey = 1;\newline		  \newline		  if (!extract_name(header, plen, &ampp, keyname, 1, 0))\newline		    return 0;\newline		  \newline		  /* RFC 4035 5.3.1 says that the Signer&#039s Name field MUST equal\newline		     the name of the zone containing the RRset. We can&#039t tell that\newline		     for certain, but we can check that  the RRset name is equal to\newline		     or encloses the signers name, which should be enough to stop \newline		     an attacker using signatures made with the key of an unrelated \newline		     zone he controls. Note that the root key is always allowed. */\newline		  if (*keyname != 0)\newline		    {\newline		      char *name_start;\newline		      for (name_start = name; !hostname_isequal(name_start, keyname); )\newline			if ((name_start = strchr(name_start, &#039.&#039)))\newline			  name_start++; /* chop a label off and try again */\newline			else\newline			  return 0;\newline		    }\newline		}\newline		  \newline	      \newline	      if (type_covered == type)\newline		{\newline		  if (!expand_workspace(&ampsigs, &ampsig_sz, sigidx))\newline		    return 0; \newline		  \newline		  sigs[sigidx++] = pdata;\newline		} \newline	      \newline	      p = pdata + 2; /* restore for ADD_RDLEN */\newline	    }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, plen, rdlen))\newline	return 0;\newline    }\newline  \newline  *sigcnt = sigidx;\newline  *rrcnt = rrsetidx;\newline\newline  return 1;\newline}\newline","Get pointers to RRset members and signature(s) for same.\newlineCheck signatures, and return keyname associated in keyname. \newline","4515373","sms.c","int dcs_to_fields(Msg **msg, int dcs) \newline{\newline    /* Non-MWI Mode 1 */\newline    if ((dcs &amp 0xF0) == 0xF0) { \newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.coding = (dcs &amp 0x04) ? DC_8BIT : DC_7BIT; /* grab bit 2 */\newline        (*msg)-&gtsms.mclass = dcs &amp 0x03; /* grab bits 1,0 */\newline        (*msg)-&gtsms.alt_dcs = 1; /* set 0xFX data coding */\newline    }\newline    \newline    /* Non-MWI Mode 0 */\newline    else if ((dcs &amp 0xC0) == 0x00) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.compress = ((dcs &amp 0x20) == 0x20) ? 1 : 0; /* grab bit 5 */\newline        (*msg)-&gtsms.mclass = ((dcs &amp 0x10) == 0x10) ? dcs &amp 0x03 : MC_UNDEF; \newline						/* grab bit 0,1 if bit 4 is on */\newline        (*msg)-&gtsms.coding = (dcs &amp 0x0C) &gt&gt 2; /* grab bit 3,2 */\newline    }\newline\newline    /* MWI */\newline    else if ((dcs &amp 0xC0) == 0xC0) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.coding = ((dcs &amp 0x30) == 0x30) ? DC_UCS2 : DC_7BIT;\newline        if (!(dcs &amp 0x08))\newline            dcs |= 0x04; /* if bit 3 is active, have mwi += 4 */\newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.mwi = dcs ; /* grab bits 1,0 */\newline    } \newline    \newline    else {\newline        return 0;\newline    }\newline\newline    return 1;\newline}\newline","\newline Decode DCS to sms fields\newline \newline","6581533","ptstream.c","PTSTREAM *stream_open(int incoming_fd, int outgoing_fd) {\newline	PTSTREAM *pts;\newline\newline	/* Initialise the structure and store the file descriptor */\newline	pts = malloc(sizeof(PTSTREAM));\newline	pts-&gtincoming_fd = incoming_fd;\newline	pts-&gtoutgoing_fd = outgoing_fd;\newline	pts-&gtssl = NULL;\newline	pts-&gtctx = NULL;\newline\newline	/* Return a pointer to the structure */\newline	return pts;\newline}\newline","Open a stream for incoming and outgoing data with the specified fds \newline","5150506","rovclock.c","int find_card(struct rovclock_data *rovclock)\newline{\newline	FILE *proc;\newline	char temp;\newline	u32 id;\newline	\newline	/* Check /proc/bus/pci/devices first */\newline	if ((proc = fopen(&quot/proc/bus/pci/devices&quot, &quotr&quot)) != NULL) {\newline		while (fscanf(proc, &quot%x\\t%x&quot, &amprovclock-&gtpci_bus, &ampid) == 2) {\newline			if ((id &gt&gt 16) == PCI_VENDOR_ID_ATI) {\newline				rovclock-&gtpci_dev = (rovclock-&gtpci_bus &amp 0xff) &gt&gt 3;\newline				rovclock-&gtpci_bus = rovclock-&gtpci_bus &gt&gt 8;\newline				rovclock-&gtpci_id = (id &lt&lt 16) | (id &gt&gt 16);\newline				\newline				/* Check for display device */\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY) {\newline					fclose(proc);\newline					return 0;\newline				}\newline			}\newline			while ((temp = fgetc(proc)) != EOF)\newline				if (temp == &#039\\n&#039)\newline					break;\newline		}\newline	}\newline	if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline		fprintf(stderr, &quotSearch in /proc/bus/pci/devices failed, scanning the PCI bus.\\n&quot);\newline\newline		/* Find card by scanning the PCI devices, check from bus 1 to 9 for ATI device */\newline		rovclock-&gtpci_dev = 0;\newline		for (rovclock-&gtpci_bus = 1; rovclock-&gtpci_bus &lt 10; rovclock-&gtpci_bus++) {\newline			if (((rovclock-&gtpci_id = pci_read(rovclock-&gtpci_bus, 0, 0, 0)) &amp 0xffff) == PCI_VENDOR_ID_ATI) {\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY)\newline					break;\newline			}\newline		}\newline	\newline		if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline			fprintf(stderr, &quotNo ATI card found.\\n&quot);\newline			return -1;\newline		}\newline	}\newline	\newline	return 0;\newline}\newline","Search for ATI card on PCI bus \newline","286635","ust-registry.c","struct ust_registry_event *ust_registry_find_event(\newline		struct ust_registry_channel *chan, char *name, char *sig)\newline{\newline	struct lttng_ht_node_u64 *node;\newline	struct lttng_ht_iter iter;\newline	struct ust_registry_event *event = NULL;\newline	struct ust_registry_event key;\newline\newline	assert(chan);\newline	assert(name);\newline	assert(sig);\newline\newline	/* Setup key for the match function. */\newline	strncpy(key.name, name, sizeof(key.name));\newline	key.name[sizeof(key.name) - 1] = &#039\\0&#039;\newline	key.signature = sig;\newline\newline	cds_lfht_lookup(chan-&gtht-&gtht, chan-&gtht-&gthash_fct(&ampkey, lttng_ht_seed),\newline			chan-&gtht-&gtmatch_fct, &ampkey, &ampiter.iter);\newline	node = lttng_ht_iter_get_node_u64(&ampiter);\newline	if (!node) {\newline		goto end;\newline	}\newline	event = caa_container_of(node, struct ust_registry_event, node);\newline\newlineend:\newline	return event;\newline}\newline","\newline Find an event using the name and signature in the given registry. RCU read\newline side lock MUST be acquired before calling this function and as long as the\newline event reference is kept by the caller.\newline \newline On success, the event pointer is returned else NULL.\newline \newline","5208573","incomplete.c","int main(int argc, char **argv)\newline{\newline  /* scheduling parameters */\newline  double communication_amount1 = 1e9;\newline  double no_cost = 0.0;\newline\newline  /* initialization of SD */\newline  SD_init(&ampargc, argv);\newline\newline  /* creation of the environment */\newline  SD_create_environment(argv[1]);\newline\newline  /* creation of the tasks and their dependencies */\newline  SD_task_t taskInit = SD_task_create(&quotInit&quot, NULL, 1.0);\newline  SD_task_t taskA = SD_task_create(&quotTask A&quot, NULL, 1.0);\newline  SD_task_t taskB = SD_task_create(&quotTask B&quot, NULL, 1.0);\newline  SD_task_t taskC = SD_task_create(&quotTask C&quot, NULL, 1.0);\newline  SD_task_t taskD = SD_task_create(&quotTask D&quot, NULL, 1.0);\newline\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskA);\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskB);\newline  SD_task_dependency_add(NULL, NULL, taskC, taskD);\newline\newline  sg_host_t *hosts = sg_host_list();\newline  SD_task_schedule(taskInit, 1, hosts, &ampno_cost, &ampno_cost, -1.0);\newline  SD_task_schedule(taskA, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  SD_task_schedule(taskD, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  xbt_free(hosts);\newline\newline  /* let&#039s launch the simulation! */\newline  SD_simulate(-1.);\newline\newline  SD_task_destroy(taskA);\newline  SD_task_destroy(taskB);\newline  SD_task_destroy(taskC);\newline  SD_task_destroy(taskD);\newline  SD_task_destroy(taskInit);\newline\newline  XBT_INFO(&quotSimulation time: %f&quot, SD_get_clock());\newline\newline  SD_exit();\newline  return 0;\newline}\newline","SimDag Incomplete Test\newline Scenario:\newline - Create a bunch of tasks\newline - schedule only a subset of them (init, A and D)\newline - run the simulation\newline - Verify that we detect which tasks are not scheduled and show their state.\newline The scheduled task A sends 1GB. Simulation time should be\newline 1e9/1.25e8 + 1e-4 = 8.0001 seconds\newline Task D is scheduled but depends on unscheduled task C.\newline \newline","3008491","collision.c","static void recalculate_ball_trajectory(Game *game, Ball *ball, Side side) {\newline\newline	add_bounce_entropy(game, ball);\newline\newline	/* Recalculate the trajectory */\newline	switch(side) {\newline		case SIDE_RIGHT :\newline			ball-&gtdirection += (RAD90 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_LEFT :\newline			ball-&gtdirection += (RAD270 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_BOTTOM :\newline			ball-&gtdirection += (RAD180 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_TOP :\newline			/*if(ball-&gtdirection &gt RAD180)\newline				ball-&gtdirection -= ball-&gtdirection * 2.0;\newline			else*/\newline				ball-&gtdirection += (RAD360 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_DIAGONAL :\newline			ball-&gtdirection += RAD180;\newline			break;\newline		default :\newline			g_assert_not_reached();\newline	}\newline\newline	/* Make sure the ball hasn&#039t been bounced the wrong way */\newline	while(ball-&gtdirection &gt RAD360)\newline		ball-&gtdirection -= RAD360;\newline\newline	while(ball-&gtdirection &lt 0)\newline		ball-&gtdirection += RAD360;\newline\newline	/* And move it an extra step, so that the ball doesn&#039t appear inside\newline	 * the block when we refresh */\newline	move_ball(ball);\newline}\newline","Changes a balls trajectory depending on which side of an object it hit. \newline","2010218","esolver.c","static void usage (char *s)\newline{\newline	fprintf (stderr, &quotUsage: %s [- below -] prob_file\\n&quot, s);\newline	fprintf (stderr, &quot   -b f  write basis to file f\\n&quot);\newline	fprintf (stderr, &quot   -B f  read initial basis from file f\\n&quot);\newline#if 0\newline	fprintf (stderr, &quot   -I    solve the MIP using BestBound\\n&quot);\newline	fprintf (stderr, &quot   -E    edit problem after solving initial version\\n&quot);\newline#endif\newline	fprintf (stderr, &quot   -L    input file is in lp format (default: mps)\\n&quot);\newline	fprintf (stderr, &quot   -O    write the final solution to the given file\\n&quot);\newline	fprintf (stderr, &quot         append .gz/.bz2 to the .sol extension to compress the file\\n&quot);\newline	fprintf (stderr, &quot   -p #  run primal simplex with pricing rule #\\n&quot);\newline	fprintf (stderr,\newline					 &quot         (%d-Dantzig, %d-Devex, %d-Steep (default), %d-Partial\\n&quot,\newline					 QS_PRICE_PDANTZIG, QS_PRICE_PDEVEX, QS_PRICE_PSTEEP,\newline					 QS_PRICE_PMULTPARTIAL);\newline	fprintf (stderr,\newline					 &quot   -P #  number of bits to use for the float representation (default: 128)\\n&quot);\newline	fprintf (stderr, &quot   -d #  run dual simplex with pricing rule #\\n&quot);\newline	fprintf (stderr, &quot         (%d-Dantzig, %d-Steep, %d-Partial, %d-Devex)\\n&quot,\newline					 QS_PRICE_DDANTZIG, QS_PRICE_DSTEEP, QS_PRICE_DMULTPARTIAL,\newline					 QS_PRICE_DDEVEX);\newline	fprintf (stderr, &quot   -S    do NOT scale the initial LP\\n&quot);\newline	fprintf (stderr, &quot   -v    print QSopt version number\\n&quot);\newline	fprintf (stderr, &quot   -R n  maximum running time allowed, default %lf\\n&quot,\newline						max_rtime);\newline	fprintf (stderr, &quot   -m n  maximum memory usage allowed, default %lu\\n&quot, \newline						memlimit);\newline}\newline","@brief Display options to the screen \newline","5583825","statement.c","static int statement_columns(lua_State *L) {\newline    statement_t *statement = (statement_t *)luaL_checkudata(L, 1, DBD_POSTGRESQL_STATEMENT);\newline\newline    int i;\newline    int num_columns;\newline    int d = 1;\newline\newline    if (!statement-&gtresult) {\newline        luaL_error(L, DBI_ERR_INVALID_STATEMENT);\newline        return 0;\newline    }\newline\newline    num_columns = PQnfields(statement-&gtresult);\newline    lua_newtable(L);\newline    for (i = 0; i &lt num_columns; i++) {\newline        const char *name = PQfname(statement-&gtresult, i);\newline\newline	LUA_PUSH_ARRAY_STRING(d, name);\newline    }\newline\newline    return 1;\newline}\newline","\newline column_names = statement:columns()\newline \newline","3964212","dgif_lib.c","static int DGifBufferedInput(FILE *File, GifByteType *Buf,\newline						      GifByteType *NextByte)\newline{\newline    if (Buf[0] == 0) {\newline	/* Needs to read the next buffer - this one is empty: */\newline	if (fread(Buf, 1, 1, File) != 1)\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	if (fread(&ampBuf[1], 1, Buf[0], File) != Buf[0])\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	*NextByte = Buf[1];\newline	Buf[1] = 2;	   /* We use now the second place as last char read! */\newline	Buf[0]--;\newline    }\newline    else {\newline	*NextByte = Buf[Buf[1]++];\newline	Buf[0]--;\newline    }\newline\newline    return GIF_OK;\newline}\newline","\newline This routines read one gif data block at a time and buffers it internally \newline so that the decompression routine could access it. \newline The routine returns the next byte from its internal buffer (or read next \newline block in if buffer empty) and returns GIF_OK if succesful. \newline \newline","4152762","btreplay.c","static inline void wait_iter_start(void)\newline{\newline	pthread_mutex_lock(&ampiter_start_mutex);\newline	while (iter_start == 0)\newline		pthread_cond_wait(&ampiter_start_cond, &ampiter_start_mutex);\newline	assert(1 &lt= iter_start &amp&amp iter_start &lt= nfiles);\newline	iter_start--;\newline	pthread_mutex_unlock(&ampiter_start_mutex);\newline}\newline","\newline wait_iter_start - Wait for an iteration to start \newline \newline This is /slightly/ different: we are waiting for a value to become\newline non-zero, and then we decrement it and go on. \newline \newline","201946","program.c","static int parseDrawbarRegistration (const char * drw,\newline				     unsigned int bar[],\newline				     const int    lineNumber,\newline				     const char * fileName) {\newline\newline  char msg[MESSAGEBUFFERSIZE];\newline  int bus = 0;\newline  const char * t = drw;\newline\newline  while (bus &lt 9) {\newline    if (*t == &#039\\0&#039) {\newline      sprintf (msg, &quotDrawbar registration incomplete &#039%s&#039&quot, drw);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline    if ((isspace (*t)) || (*t == &#039-&#039) || (*t == &#039_&#039)) {\newline      t++;\newline      continue;\newline    }\newline    if ((&#0390&#039 &lt= *t) &amp&amp (*t &lt= &#0398&#039)) {\newline      bar[bus] = *t - &#0390&#039;\newline      t++;\newline      bus++;\newline      continue;\newline    }\newline    else {\newline      sprintf (msg, &quotIllegal char in drawbar registration &#039%c&#039&quot, *t);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","\newline Parses a drawbar registration.\newline @param drw The drawbar registration string.\newline @param bar Array of intergers where the registration is stored.\newline @param lineNumber The linenumber in the input file.\newline @param fileName The name of the current input file.\newline \newline","6073226","rundiff.c","DiffInfo *blank_diff_info (void)\newline{\newline    Block *b;\newline    DiffInfo *di;\newline\newline    di = (DiffInfo *) calloc (1, sizeof (DiffInfo));\newline    di-&gtlongline = &quot  &quot;\newline    di-&gtmaxcols = strlen (di-&gtlongline);\newline    di-&gtstatus = 2;\newline\newline    b = (Block *) calloc (1, sizeof (Block));\newline    b-&gtselected = NEITHER;\newline    b-&gtarr[LEFT].type = b-&gtarr[RIGHT].type = SAME;\newline    b-&gtsline = 0;\newline    b-&gtssize = 1;\newline    b-&gtarr[LEFT].fline = b-&gtarr[RIGHT].fline = 0;\newline    b-&gtarr[LEFT].fsize = b-&gtarr[RIGHT].fsize = 1;\newline    b-&gtarr[LEFT].text = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].wtext = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].tlen = (short *) calloc (1, sizeof (short));\newline    b-&gtarr[LEFT].text[0] = strdup (&quot  &quot);\newline    b-&gtarr[LEFT].tlen[0] = strlen (b-&gtarr[LEFT].text[0]);\newline\newline    b-&gtarr[RIGHT].text = NULL;\newline    b-&gtarr[RIGHT].wtext = NULL;\newline    b-&gtarr[RIGHT].tlen = NULL;\newline    di-&gtfirst = di-&gtlast = b;\newline    di-&gtlines = b-&gtsline + b-&gtssize;\newline    di-&gtflines[LEFT] = b-&gtarr[LEFT].fline + b-&gtarr[LEFT].fsize;\newline    di-&gtflines[RIGHT] = b-&gtarr[RIGHT].fline + b-&gtarr[RIGHT].fsize;\newline\newline    return (di);\newline}\newline","\newline build just enough of a DiffInfo structure so that routines that use \newline the data won&#039t be shocked. this is used to show a blank display \newline (no files loaded).\newline \newline","5921779","os2.c","static void cvt_path_to_correct_case(char *buf)\newline{\newline    char *fname = buf + 3;            /* point to first element. */\newline    char *ptr = strchr(fname, &#039\\\\&#039);  /* find end of first element. */\newline\newline    buf[0] = toupper(buf[0]);  /* capitalize drive letter. */\newline\newline    /*\newline     * Go through each path element, and enumerate its parent dir until\newline     *  a case-insensitive match is found. If one is (and it SHOULD be)\newline     *  then overwrite the original element with the correct case.\newline     * If there&#039s an error, or the path has vanished for some reason, it\newline     *  won&#039t hurt to have the original case, so we just keep going.\newline     */\newline    while (fname != NULL)\newline    {\newline        char spec[CCHMAXPATH];\newline        FILEFINDBUF3 fb;\newline        HDIR hdir = HDIR_CREATE;\newline        ULONG count = 1;\newline        APIRET rc;\newline\newline        *(fname - 1) = &#039\\0&#039;  /* isolate parent dir string. */\newline\newline        strcpy(spec, buf);      /* copy isolated parent dir... */\newline        strcat(spec, &quot\\\\*.*&quot);  /*  ...and add wildcard search spec. */\newline\newline        if (ptr != NULL)  /* isolate element to find (fname is the start). */\newline            *ptr = &#039\\0&#039;\newline\newline        rc = DosFindFirst(spec, &amphdir, FILE_DIRECTORY,\newline                          &ampfb, sizeof (fb), &ampcount, FIL_STANDARD);\newline        if (rc == NO_ERROR)\newline        {\newline            while (count == 1)  /* while still entries to enumerate... */\newline            {\newline                if (__PHYSFS_stricmpASCII(fb.achName, fname) == 0)\newline                {\newline                    strcpy(fname, fb.achName);\newline                    break;  /* there it is. Overwrite and stop searching. */\newline                } /* if */\newline\newline                DosFindNext(hdir, &ampfb, sizeof (fb), &ampcount);\newline            } /* while */\newline            DosFindClose(hdir);\newline        } /* if */\newline\newline        *(fname - 1) = &#039\\\\&#039;   /* unisolate parent dir. */\newline        fname = ptr;           /* point to next element. */\newline        if (ptr != NULL)\newline        {\newline            *ptr = &#039\\\\&#039;       /* unisolate element. */\newline            ptr = strchr(++fname, &#039\\\\&#039);  /* find next element. */\newline        } /* if */\newline    } /* while */\newline} /* cvt_file_to_correct_case */\newline","(be gentle, this function isn&#039t very robust.) \newline","4586590","rnn_util.cpp","void rnn_predict_bonding_state(const string&amp config, \newline			       const string&amp model,\newline			       const string&amp input,\newline			       const string&amp output) {\newline  // get RNN option (unique) instance\newline  Options* rnn_option = Options::instance();\newline\newline  // set BRNN parameters from bonding state config file\newline  rnn_option-&gtparse_config(config);\newline  rnn_option-&gtsetParameter(&quotnetname&quot, model);\newline  \newline  // Create test set with only the given input \newline  DataSet *testset = new DataSet(input.c_str());\newline  if(!testset) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: failed dataset creation.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // initialize BRNN\newline  RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt* \newline    rnn = new RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt(model.c_str());\newline  if(!rnn) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable &quot\newline      &quotto read brnn file &quot &lt&lt model &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // predict\newline  DataSet::iterator it=testset-&gtbegin(); // only one input chain\newline  vector&ltNode*&gt *nodes = it.currenTONodes();\newline  std::pair&ltDPAG, DPAG&gt *dpags = it.currentDPAGs();\newline  rnn-&gtpropagateStructuredInput(*nodes, *dpags);\newline\newline  // write predictions to output file\newline  ofstream ofs(output.c_str());\newline  if(!ofs) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable to open file &quot\newline	 &lt&lt output &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  for(std::vector&ltNode*&gt::iterator nit=nodes-&gtbegin(); \newline      nit!=nodes-&gtend(); ++nit) {\newline    float py1 = (*nit)-&gt_h_layers_activations[(*nit)-&gt_s-1][0];\newline    ofs &lt&lt (1-py1) &lt&lt &#039 &#039 &lt&lt py1 &lt&lt endl;\newline  }\newline  \newline  // deallocate Recursive Network structure\newline  delete rnn; rnn = 0;\newline  // deallocate dataset\newline  if(testset) { delete testset; testset = 0; }\newline}\newline","\newlinePredict bonding state with BRNN model.\newline \newline","286520","trace-kernel.c","struct ltt_kernel_event *trace_kernel_create_event(struct lttng_event *ev,\newline		char *filter_expression, struct lttng_filter_bytecode *filter)\newline{\newline	struct ltt_kernel_event *lke;\newline	struct lttng_kernel_event *attr;\newline\newline	assert(ev);\newline\newline	lke = zmalloc(sizeof(struct ltt_kernel_event));\newline	attr = zmalloc(sizeof(struct lttng_kernel_event));\newline	if (lke == NULL || attr == NULL) {\newline		PERROR(&quotkernel event zmalloc&quot);\newline		goto error;\newline	}\newline\newline	switch (ev-&gttype) {\newline	case LTTNG_EVENT_PROBE:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KPROBE;\newline		attr-&gtu.kprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KRETPROBE;\newline		attr-&gtu.kretprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kretprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kretprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kretprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION_ENTRY:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_FUNCTION;\newline		strncpy(attr-&gtu.ftrace.symbol_name,\newline				ev-&gtattr.ftrace.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.ftrace.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_TRACEPOINT:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_TRACEPOINT;\newline		break;\newline	case LTTNG_EVENT_SYSCALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_SYSCALL;\newline		break;\newline	case LTTNG_EVENT_ALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_ALL;\newline		break;\newline	default:\newline		ERR(&quotUnknown kernel instrumentation type (%d)&quot, ev-&gttype);\newline		goto error;\newline	}\newline\newline	/* Copy event name */\newline	strncpy(attr-&gtname, ev-&gtname, LTTNG_KERNEL_SYM_NAME_LEN);\newline	attr-&gtname[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline\newline	/* Setting up a kernel event */\newline	lke-&gtfd = -1;\newline	lke-&gtevent = attr;\newline	lke-&gtenabled = 1;\newline	lke-&gtfilter_expression = filter_expression;\newline	lke-&gtfilter = filter;\newline\newline	return lke;\newline\newlineerror:\newline	free(filter_expression);\newline	free(filter);\newline	free(lke);\newline	free(attr);\newline	return NULL;\newline}\newline","\newline Allocate and initialize a kernel event. Set name and event type.\newline We own filter_expression, and filter.\newline \newline Return pointer to structure or NULL.\newline \newline","2083110","output.c","static unsigned count_move_list_ply(Move *move_list, Boolean count_variations)\newline{\newline    unsigned count = 0;\newline    while(move_list != NULL) {\newline        count += count_single_move_ply(move_list, count_variations);\newline	move_list = move_list-&gtnext;\newline    }\newline    return count;\newline}\newline","\newline Count how many plies in the game in total.\newline Include variations if count_variations.\newline \newline","","on","","","on","","","","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","on","","","","","","Load an image from the named file.","{}","Changes a balls trajectory","Display options to the screen","{}","read one gif data block at a time and buffers it internally","Wait for an iteration to start","Parses a drawbar registration.","used to show a blank display","{}","Predict bonding state with BRNN model.","deals with the exclusive or operator","Allocate and initialize a kernel event.","Count how many plies in the game in total.","{}","copy the non-numeral exprs to result,","Get pointers to RRset members and signature(s) for same.","Decode DCS to sms fields","Open a stream for incoming and outgoing data","Search for ATI card on PCI bus","Find an event using the name and signature"
"3WYZV0QBFJDG63D7PQCNJUAFAZUBXB","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3FTOP5WARFOGEG21085YXN26OL4J0Z","A1NV81QEC0GDG7","Approved","Wed Apr 17 15:02:03 PDT 2019","Wed Apr 17 15:05:00 PDT 2019","Fri Apr 19 15:05:00 PDT 2019","2019-04-19 22:05:21 UTC","","","177","100% (5/5)","100% (5/5)","100% (5/5)","3580134","image.c","GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline","\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline","5108090","evaluate.c","static void eval_fveor(void) {\newline  stackitem lhitem;\newline  int32 rhint = TOINT(pop_float());\newline  lhitem = GET_TOPITEM;\newline  if (lhitem == STACK_INT)\newline    EOR_INT(rhint);\newline  else if (lhitem == STACK_FLOAT)\newline    push_int(TOINT(pop_float()) ^ rhint);\newline  else {\newline    want_number();\newline  }\newline}\newline","\newline &#039eval_fveor&#039 deals with the exclusive or operator when right-hand\newline operand is a floating point value\newline \newline","4350475","numrgts.cpp","void NumberFormatRegressionTest::TestJ691(void) {\newline    UErrorCode status = U_ZERO_ERROR;\newline    Locale loc(&quotfr&quot, &quotCH&quot);\newline\newline    // set up the input date string &amp expected output\newline    UnicodeString udt(&quot11.10.2000&quot, &quot&quot);\newline    UnicodeString exp(&quot11.10.00&quot, &quot&quot);\newline\newline    // create a Calendar for this locale\newline    Calendar *cal = Calendar::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: Calendar::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // create a NumberFormat for this locale\newline    NumberFormat *nf = NumberFormat::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: NumberFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // *** Here&#039s the key: We don&#039t want to have to do THIS:\newline    // nf-&gtsetParseIntegerOnly(TRUE);\newline\newline    // create the DateFormat\newline    DateFormat *df = DateFormat::createDateInstance(DateFormat::kShort, loc);\newline    if (U_FAILURE(status)) {\newline        errln(&quotFAIL: DateFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    df-&gtadoptCalendar(cal);\newline    df-&gtadoptNumberFormat(nf);\newline\newline    // set parsing to lenient &amp parse\newline    df-&gtsetLenient(TRUE);\newline    UDate ulocdat = df-&gtparse(udt, status);\newline\newline    // format back to a string\newline    UnicodeString outString;\newline    df-&gtformat(ulocdat, outString);\newline\newline    if (outString != exp) {\newline        errln(&quotFAIL: &quot + udt + &quot =&gt &quot + outString);\newline    }\newline\newline    delete df;\newline}\newline","\newline DateFormat should call setIntegerParseOnly(TRUE) on adopted\newline NumberFormat objects.\newline \newline","1226709","poly_simplifier_plugin.cpp","void poly_simplifier_plugin::process_monomial(unsigned num_args, expr * const * args, numeral &amp k, ptr_buffer&ltexpr&gt &amp result) {\newline    rational v;\newline    for (unsigned i = 0; i &lt num_args; i++) {\newline        expr * arg = args[i];\newline        if (is_numeral(arg, v))\newline            k *= v;\newline        else\newline            result.push_back(arg);\newline    }\newline}\newline","\newline\\brief Traverse args, and copy the non-numeral exprs to result, and accumulate the \newlinevalue of the numerals in k.\newline \newline","5137164","dnssec.c","static int explore_rrset(struct dns_header *header, size_t plen, int class, int type, \newline			 char *name, char *keyname, int *sigcnt, int *rrcnt)\newline{\newline  static int rrset_sz = 0, sig_sz = 0; \newline  unsigned char *p;\newline  int rrsetidx, sigidx, j, rdlen, res;\newline  int gotkey = 0;\newline\newline  if (!(p = skip_questions(header, plen)))\newline    return STAT_BOGUS;\newline\newline   /* look for RRSIGs for this RRset and get pointers to each RR in the set. */\newline  for (rrsetidx = 0, sigidx = 0, j = ntohs(header-&gtancount) + ntohs(header-&gtnscount); \newline       j != 0; j--) \newline    {\newline      unsigned char *pstart, *pdata;\newline      int stype, sclass, type_covered;\newline\newline      pstart = p;\newline      \newline      if (!(res = extract_name(header, plen, &ampp, name, 0, 10)))\newline	return STAT_BOGUS; /* bad packet */\newline      \newline      GETSHORT(stype, p);\newline      GETSHORT(sclass, p);\newline      p += 4; /* TTL */\newline      \newline      pdata = p;\newline\newline      GETSHORT(rdlen, p);\newline      \newline      if (!CHECK_LEN(header, p, plen, rdlen))\newline	return 0; \newline      \newline      if (res == 1 &amp&amp sclass == class)\newline	{\newline	  if (stype == type)\newline	    {\newline	      if (!expand_workspace(&amprrset, &amprrset_sz, rrsetidx))\newline		return 0; \newline	      \newline	      rrset[rrsetidx++] = pstart;\newline	    }\newline	  \newline	  if (stype == T_RRSIG)\newline	    {\newline	      if (rdlen &lt 18)\newline		return 0; /* bad packet */ \newline	      \newline	      GETSHORT(type_covered, p);\newline	      p += 16; /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */\newline	      \newline	      if (gotkey)\newline		{\newline		  /* If there&#039s more than one SIG, ensure they all have same keyname */\newline		  if (extract_name(header, plen, &ampp, keyname, 0, 0) != 1)\newline		    return 0;\newline		}\newline	      else\newline		{\newline		  gotkey = 1;\newline		  \newline		  if (!extract_name(header, plen, &ampp, keyname, 1, 0))\newline		    return 0;\newline		  \newline		  /* RFC 4035 5.3.1 says that the Signer&#039s Name field MUST equal\newline		     the name of the zone containing the RRset. We can&#039t tell that\newline		     for certain, but we can check that  the RRset name is equal to\newline		     or encloses the signers name, which should be enough to stop \newline		     an attacker using signatures made with the key of an unrelated \newline		     zone he controls. Note that the root key is always allowed. */\newline		  if (*keyname != 0)\newline		    {\newline		      char *name_start;\newline		      for (name_start = name; !hostname_isequal(name_start, keyname); )\newline			if ((name_start = strchr(name_start, &#039.&#039)))\newline			  name_start++; /* chop a label off and try again */\newline			else\newline			  return 0;\newline		    }\newline		}\newline		  \newline	      \newline	      if (type_covered == type)\newline		{\newline		  if (!expand_workspace(&ampsigs, &ampsig_sz, sigidx))\newline		    return 0; \newline		  \newline		  sigs[sigidx++] = pdata;\newline		} \newline	      \newline	      p = pdata + 2; /* restore for ADD_RDLEN */\newline	    }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, plen, rdlen))\newline	return 0;\newline    }\newline  \newline  *sigcnt = sigidx;\newline  *rrcnt = rrsetidx;\newline\newline  return 1;\newline}\newline","Get pointers to RRset members and signature(s) for same.\newlineCheck signatures, and return keyname associated in keyname. \newline","4515373","sms.c","int dcs_to_fields(Msg **msg, int dcs) \newline{\newline    /* Non-MWI Mode 1 */\newline    if ((dcs &amp 0xF0) == 0xF0) { \newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.coding = (dcs &amp 0x04) ? DC_8BIT : DC_7BIT; /* grab bit 2 */\newline        (*msg)-&gtsms.mclass = dcs &amp 0x03; /* grab bits 1,0 */\newline        (*msg)-&gtsms.alt_dcs = 1; /* set 0xFX data coding */\newline    }\newline    \newline    /* Non-MWI Mode 0 */\newline    else if ((dcs &amp 0xC0) == 0x00) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.compress = ((dcs &amp 0x20) == 0x20) ? 1 : 0; /* grab bit 5 */\newline        (*msg)-&gtsms.mclass = ((dcs &amp 0x10) == 0x10) ? dcs &amp 0x03 : MC_UNDEF; \newline						/* grab bit 0,1 if bit 4 is on */\newline        (*msg)-&gtsms.coding = (dcs &amp 0x0C) &gt&gt 2; /* grab bit 3,2 */\newline    }\newline\newline    /* MWI */\newline    else if ((dcs &amp 0xC0) == 0xC0) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.coding = ((dcs &amp 0x30) == 0x30) ? DC_UCS2 : DC_7BIT;\newline        if (!(dcs &amp 0x08))\newline            dcs |= 0x04; /* if bit 3 is active, have mwi += 4 */\newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.mwi = dcs ; /* grab bits 1,0 */\newline    } \newline    \newline    else {\newline        return 0;\newline    }\newline\newline    return 1;\newline}\newline","\newline Decode DCS to sms fields\newline \newline","6581533","ptstream.c","PTSTREAM *stream_open(int incoming_fd, int outgoing_fd) {\newline	PTSTREAM *pts;\newline\newline	/* Initialise the structure and store the file descriptor */\newline	pts = malloc(sizeof(PTSTREAM));\newline	pts-&gtincoming_fd = incoming_fd;\newline	pts-&gtoutgoing_fd = outgoing_fd;\newline	pts-&gtssl = NULL;\newline	pts-&gtctx = NULL;\newline\newline	/* Return a pointer to the structure */\newline	return pts;\newline}\newline","Open a stream for incoming and outgoing data with the specified fds \newline","5150506","rovclock.c","int find_card(struct rovclock_data *rovclock)\newline{\newline	FILE *proc;\newline	char temp;\newline	u32 id;\newline	\newline	/* Check /proc/bus/pci/devices first */\newline	if ((proc = fopen(&quot/proc/bus/pci/devices&quot, &quotr&quot)) != NULL) {\newline		while (fscanf(proc, &quot%x\\t%x&quot, &amprovclock-&gtpci_bus, &ampid) == 2) {\newline			if ((id &gt&gt 16) == PCI_VENDOR_ID_ATI) {\newline				rovclock-&gtpci_dev = (rovclock-&gtpci_bus &amp 0xff) &gt&gt 3;\newline				rovclock-&gtpci_bus = rovclock-&gtpci_bus &gt&gt 8;\newline				rovclock-&gtpci_id = (id &lt&lt 16) | (id &gt&gt 16);\newline				\newline				/* Check for display device */\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY) {\newline					fclose(proc);\newline					return 0;\newline				}\newline			}\newline			while ((temp = fgetc(proc)) != EOF)\newline				if (temp == &#039\\n&#039)\newline					break;\newline		}\newline	}\newline	if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline		fprintf(stderr, &quotSearch in /proc/bus/pci/devices failed, scanning the PCI bus.\\n&quot);\newline\newline		/* Find card by scanning the PCI devices, check from bus 1 to 9 for ATI device */\newline		rovclock-&gtpci_dev = 0;\newline		for (rovclock-&gtpci_bus = 1; rovclock-&gtpci_bus &lt 10; rovclock-&gtpci_bus++) {\newline			if (((rovclock-&gtpci_id = pci_read(rovclock-&gtpci_bus, 0, 0, 0)) &amp 0xffff) == PCI_VENDOR_ID_ATI) {\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY)\newline					break;\newline			}\newline		}\newline	\newline		if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline			fprintf(stderr, &quotNo ATI card found.\\n&quot);\newline			return -1;\newline		}\newline	}\newline	\newline	return 0;\newline}\newline","Search for ATI card on PCI bus \newline","286635","ust-registry.c","struct ust_registry_event *ust_registry_find_event(\newline		struct ust_registry_channel *chan, char *name, char *sig)\newline{\newline	struct lttng_ht_node_u64 *node;\newline	struct lttng_ht_iter iter;\newline	struct ust_registry_event *event = NULL;\newline	struct ust_registry_event key;\newline\newline	assert(chan);\newline	assert(name);\newline	assert(sig);\newline\newline	/* Setup key for the match function. */\newline	strncpy(key.name, name, sizeof(key.name));\newline	key.name[sizeof(key.name) - 1] = &#039\\0&#039;\newline	key.signature = sig;\newline\newline	cds_lfht_lookup(chan-&gtht-&gtht, chan-&gtht-&gthash_fct(&ampkey, lttng_ht_seed),\newline			chan-&gtht-&gtmatch_fct, &ampkey, &ampiter.iter);\newline	node = lttng_ht_iter_get_node_u64(&ampiter);\newline	if (!node) {\newline		goto end;\newline	}\newline	event = caa_container_of(node, struct ust_registry_event, node);\newline\newlineend:\newline	return event;\newline}\newline","\newline Find an event using the name and signature in the given registry. RCU read\newline side lock MUST be acquired before calling this function and as long as the\newline event reference is kept by the caller.\newline \newline On success, the event pointer is returned else NULL.\newline \newline","5208573","incomplete.c","int main(int argc, char **argv)\newline{\newline  /* scheduling parameters */\newline  double communication_amount1 = 1e9;\newline  double no_cost = 0.0;\newline\newline  /* initialization of SD */\newline  SD_init(&ampargc, argv);\newline\newline  /* creation of the environment */\newline  SD_create_environment(argv[1]);\newline\newline  /* creation of the tasks and their dependencies */\newline  SD_task_t taskInit = SD_task_create(&quotInit&quot, NULL, 1.0);\newline  SD_task_t taskA = SD_task_create(&quotTask A&quot, NULL, 1.0);\newline  SD_task_t taskB = SD_task_create(&quotTask B&quot, NULL, 1.0);\newline  SD_task_t taskC = SD_task_create(&quotTask C&quot, NULL, 1.0);\newline  SD_task_t taskD = SD_task_create(&quotTask D&quot, NULL, 1.0);\newline\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskA);\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskB);\newline  SD_task_dependency_add(NULL, NULL, taskC, taskD);\newline\newline  sg_host_t *hosts = sg_host_list();\newline  SD_task_schedule(taskInit, 1, hosts, &ampno_cost, &ampno_cost, -1.0);\newline  SD_task_schedule(taskA, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  SD_task_schedule(taskD, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  xbt_free(hosts);\newline\newline  /* let&#039s launch the simulation! */\newline  SD_simulate(-1.);\newline\newline  SD_task_destroy(taskA);\newline  SD_task_destroy(taskB);\newline  SD_task_destroy(taskC);\newline  SD_task_destroy(taskD);\newline  SD_task_destroy(taskInit);\newline\newline  XBT_INFO(&quotSimulation time: %f&quot, SD_get_clock());\newline\newline  SD_exit();\newline  return 0;\newline}\newline","SimDag Incomplete Test\newline Scenario:\newline - Create a bunch of tasks\newline - schedule only a subset of them (init, A and D)\newline - run the simulation\newline - Verify that we detect which tasks are not scheduled and show their state.\newline The scheduled task A sends 1GB. Simulation time should be\newline 1e9/1.25e8 + 1e-4 = 8.0001 seconds\newline Task D is scheduled but depends on unscheduled task C.\newline \newline","3008491","collision.c","static void recalculate_ball_trajectory(Game *game, Ball *ball, Side side) {\newline\newline	add_bounce_entropy(game, ball);\newline\newline	/* Recalculate the trajectory */\newline	switch(side) {\newline		case SIDE_RIGHT :\newline			ball-&gtdirection += (RAD90 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_LEFT :\newline			ball-&gtdirection += (RAD270 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_BOTTOM :\newline			ball-&gtdirection += (RAD180 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_TOP :\newline			/*if(ball-&gtdirection &gt RAD180)\newline				ball-&gtdirection -= ball-&gtdirection * 2.0;\newline			else*/\newline				ball-&gtdirection += (RAD360 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_DIAGONAL :\newline			ball-&gtdirection += RAD180;\newline			break;\newline		default :\newline			g_assert_not_reached();\newline	}\newline\newline	/* Make sure the ball hasn&#039t been bounced the wrong way */\newline	while(ball-&gtdirection &gt RAD360)\newline		ball-&gtdirection -= RAD360;\newline\newline	while(ball-&gtdirection &lt 0)\newline		ball-&gtdirection += RAD360;\newline\newline	/* And move it an extra step, so that the ball doesn&#039t appear inside\newline	 * the block when we refresh */\newline	move_ball(ball);\newline}\newline","Changes a balls trajectory depending on which side of an object it hit. \newline","2010218","esolver.c","static void usage (char *s)\newline{\newline	fprintf (stderr, &quotUsage: %s [- below -] prob_file\\n&quot, s);\newline	fprintf (stderr, &quot   -b f  write basis to file f\\n&quot);\newline	fprintf (stderr, &quot   -B f  read initial basis from file f\\n&quot);\newline#if 0\newline	fprintf (stderr, &quot   -I    solve the MIP using BestBound\\n&quot);\newline	fprintf (stderr, &quot   -E    edit problem after solving initial version\\n&quot);\newline#endif\newline	fprintf (stderr, &quot   -L    input file is in lp format (default: mps)\\n&quot);\newline	fprintf (stderr, &quot   -O    write the final solution to the given file\\n&quot);\newline	fprintf (stderr, &quot         append .gz/.bz2 to the .sol extension to compress the file\\n&quot);\newline	fprintf (stderr, &quot   -p #  run primal simplex with pricing rule #\\n&quot);\newline	fprintf (stderr,\newline					 &quot         (%d-Dantzig, %d-Devex, %d-Steep (default), %d-Partial\\n&quot,\newline					 QS_PRICE_PDANTZIG, QS_PRICE_PDEVEX, QS_PRICE_PSTEEP,\newline					 QS_PRICE_PMULTPARTIAL);\newline	fprintf (stderr,\newline					 &quot   -P #  number of bits to use for the float representation (default: 128)\\n&quot);\newline	fprintf (stderr, &quot   -d #  run dual simplex with pricing rule #\\n&quot);\newline	fprintf (stderr, &quot         (%d-Dantzig, %d-Steep, %d-Partial, %d-Devex)\\n&quot,\newline					 QS_PRICE_DDANTZIG, QS_PRICE_DSTEEP, QS_PRICE_DMULTPARTIAL,\newline					 QS_PRICE_DDEVEX);\newline	fprintf (stderr, &quot   -S    do NOT scale the initial LP\\n&quot);\newline	fprintf (stderr, &quot   -v    print QSopt version number\\n&quot);\newline	fprintf (stderr, &quot   -R n  maximum running time allowed, default %lf\\n&quot,\newline						max_rtime);\newline	fprintf (stderr, &quot   -m n  maximum memory usage allowed, default %lu\\n&quot, \newline						memlimit);\newline}\newline","@brief Display options to the screen \newline","5583825","statement.c","static int statement_columns(lua_State *L) {\newline    statement_t *statement = (statement_t *)luaL_checkudata(L, 1, DBD_POSTGRESQL_STATEMENT);\newline\newline    int i;\newline    int num_columns;\newline    int d = 1;\newline\newline    if (!statement-&gtresult) {\newline        luaL_error(L, DBI_ERR_INVALID_STATEMENT);\newline        return 0;\newline    }\newline\newline    num_columns = PQnfields(statement-&gtresult);\newline    lua_newtable(L);\newline    for (i = 0; i &lt num_columns; i++) {\newline        const char *name = PQfname(statement-&gtresult, i);\newline\newline	LUA_PUSH_ARRAY_STRING(d, name);\newline    }\newline\newline    return 1;\newline}\newline","\newline column_names = statement:columns()\newline \newline","3964212","dgif_lib.c","static int DGifBufferedInput(FILE *File, GifByteType *Buf,\newline						      GifByteType *NextByte)\newline{\newline    if (Buf[0] == 0) {\newline	/* Needs to read the next buffer - this one is empty: */\newline	if (fread(Buf, 1, 1, File) != 1)\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	if (fread(&ampBuf[1], 1, Buf[0], File) != Buf[0])\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	*NextByte = Buf[1];\newline	Buf[1] = 2;	   /* We use now the second place as last char read! */\newline	Buf[0]--;\newline    }\newline    else {\newline	*NextByte = Buf[Buf[1]++];\newline	Buf[0]--;\newline    }\newline\newline    return GIF_OK;\newline}\newline","\newline This routines read one gif data block at a time and buffers it internally \newline so that the decompression routine could access it. \newline The routine returns the next byte from its internal buffer (or read next \newline block in if buffer empty) and returns GIF_OK if succesful. \newline \newline","4152762","btreplay.c","static inline void wait_iter_start(void)\newline{\newline	pthread_mutex_lock(&ampiter_start_mutex);\newline	while (iter_start == 0)\newline		pthread_cond_wait(&ampiter_start_cond, &ampiter_start_mutex);\newline	assert(1 &lt= iter_start &amp&amp iter_start &lt= nfiles);\newline	iter_start--;\newline	pthread_mutex_unlock(&ampiter_start_mutex);\newline}\newline","\newline wait_iter_start - Wait for an iteration to start \newline \newline This is /slightly/ different: we are waiting for a value to become\newline non-zero, and then we decrement it and go on. \newline \newline","201946","program.c","static int parseDrawbarRegistration (const char * drw,\newline				     unsigned int bar[],\newline				     const int    lineNumber,\newline				     const char * fileName) {\newline\newline  char msg[MESSAGEBUFFERSIZE];\newline  int bus = 0;\newline  const char * t = drw;\newline\newline  while (bus &lt 9) {\newline    if (*t == &#039\\0&#039) {\newline      sprintf (msg, &quotDrawbar registration incomplete &#039%s&#039&quot, drw);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline    if ((isspace (*t)) || (*t == &#039-&#039) || (*t == &#039_&#039)) {\newline      t++;\newline      continue;\newline    }\newline    if ((&#0390&#039 &lt= *t) &amp&amp (*t &lt= &#0398&#039)) {\newline      bar[bus] = *t - &#0390&#039;\newline      t++;\newline      bus++;\newline      continue;\newline    }\newline    else {\newline      sprintf (msg, &quotIllegal char in drawbar registration &#039%c&#039&quot, *t);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","\newline Parses a drawbar registration.\newline @param drw The drawbar registration string.\newline @param bar Array of intergers where the registration is stored.\newline @param lineNumber The linenumber in the input file.\newline @param fileName The name of the current input file.\newline \newline","6073226","rundiff.c","DiffInfo *blank_diff_info (void)\newline{\newline    Block *b;\newline    DiffInfo *di;\newline\newline    di = (DiffInfo *) calloc (1, sizeof (DiffInfo));\newline    di-&gtlongline = &quot  &quot;\newline    di-&gtmaxcols = strlen (di-&gtlongline);\newline    di-&gtstatus = 2;\newline\newline    b = (Block *) calloc (1, sizeof (Block));\newline    b-&gtselected = NEITHER;\newline    b-&gtarr[LEFT].type = b-&gtarr[RIGHT].type = SAME;\newline    b-&gtsline = 0;\newline    b-&gtssize = 1;\newline    b-&gtarr[LEFT].fline = b-&gtarr[RIGHT].fline = 0;\newline    b-&gtarr[LEFT].fsize = b-&gtarr[RIGHT].fsize = 1;\newline    b-&gtarr[LEFT].text = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].wtext = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].tlen = (short *) calloc (1, sizeof (short));\newline    b-&gtarr[LEFT].text[0] = strdup (&quot  &quot);\newline    b-&gtarr[LEFT].tlen[0] = strlen (b-&gtarr[LEFT].text[0]);\newline\newline    b-&gtarr[RIGHT].text = NULL;\newline    b-&gtarr[RIGHT].wtext = NULL;\newline    b-&gtarr[RIGHT].tlen = NULL;\newline    di-&gtfirst = di-&gtlast = b;\newline    di-&gtlines = b-&gtsline + b-&gtssize;\newline    di-&gtflines[LEFT] = b-&gtarr[LEFT].fline + b-&gtarr[LEFT].fsize;\newline    di-&gtflines[RIGHT] = b-&gtarr[RIGHT].fline + b-&gtarr[RIGHT].fsize;\newline\newline    return (di);\newline}\newline","\newline build just enough of a DiffInfo structure so that routines that use \newline the data won&#039t be shocked. this is used to show a blank display \newline (no files loaded).\newline \newline","5921779","os2.c","static void cvt_path_to_correct_case(char *buf)\newline{\newline    char *fname = buf + 3;            /* point to first element. */\newline    char *ptr = strchr(fname, &#039\\\\&#039);  /* find end of first element. */\newline\newline    buf[0] = toupper(buf[0]);  /* capitalize drive letter. */\newline\newline    /*\newline     * Go through each path element, and enumerate its parent dir until\newline     *  a case-insensitive match is found. If one is (and it SHOULD be)\newline     *  then overwrite the original element with the correct case.\newline     * If there&#039s an error, or the path has vanished for some reason, it\newline     *  won&#039t hurt to have the original case, so we just keep going.\newline     */\newline    while (fname != NULL)\newline    {\newline        char spec[CCHMAXPATH];\newline        FILEFINDBUF3 fb;\newline        HDIR hdir = HDIR_CREATE;\newline        ULONG count = 1;\newline        APIRET rc;\newline\newline        *(fname - 1) = &#039\\0&#039;  /* isolate parent dir string. */\newline\newline        strcpy(spec, buf);      /* copy isolated parent dir... */\newline        strcat(spec, &quot\\\\*.*&quot);  /*  ...and add wildcard search spec. */\newline\newline        if (ptr != NULL)  /* isolate element to find (fname is the start). */\newline            *ptr = &#039\\0&#039;\newline\newline        rc = DosFindFirst(spec, &amphdir, FILE_DIRECTORY,\newline                          &ampfb, sizeof (fb), &ampcount, FIL_STANDARD);\newline        if (rc == NO_ERROR)\newline        {\newline            while (count == 1)  /* while still entries to enumerate... */\newline            {\newline                if (__PHYSFS_stricmpASCII(fb.achName, fname) == 0)\newline                {\newline                    strcpy(fname, fb.achName);\newline                    break;  /* there it is. Overwrite and stop searching. */\newline                } /* if */\newline\newline                DosFindNext(hdir, &ampfb, sizeof (fb), &ampcount);\newline            } /* while */\newline            DosFindClose(hdir);\newline        } /* if */\newline\newline        *(fname - 1) = &#039\\\\&#039;   /* unisolate parent dir. */\newline        fname = ptr;           /* point to next element. */\newline        if (ptr != NULL)\newline        {\newline            *ptr = &#039\\\\&#039;       /* unisolate element. */\newline            ptr = strchr(++fname, &#039\\\\&#039);  /* find next element. */\newline        } /* if */\newline    } /* while */\newline} /* cvt_file_to_correct_case */\newline","(be gentle, this function isn&#039t very robust.) \newline","4586590","rnn_util.cpp","void rnn_predict_bonding_state(const string&amp config, \newline			       const string&amp model,\newline			       const string&amp input,\newline			       const string&amp output) {\newline  // get RNN option (unique) instance\newline  Options* rnn_option = Options::instance();\newline\newline  // set BRNN parameters from bonding state config file\newline  rnn_option-&gtparse_config(config);\newline  rnn_option-&gtsetParameter(&quotnetname&quot, model);\newline  \newline  // Create test set with only the given input \newline  DataSet *testset = new DataSet(input.c_str());\newline  if(!testset) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: failed dataset creation.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // initialize BRNN\newline  RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt* \newline    rnn = new RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt(model.c_str());\newline  if(!rnn) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable &quot\newline      &quotto read brnn file &quot &lt&lt model &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // predict\newline  DataSet::iterator it=testset-&gtbegin(); // only one input chain\newline  vector&ltNode*&gt *nodes = it.currenTONodes();\newline  std::pair&ltDPAG, DPAG&gt *dpags = it.currentDPAGs();\newline  rnn-&gtpropagateStructuredInput(*nodes, *dpags);\newline\newline  // write predictions to output file\newline  ofstream ofs(output.c_str());\newline  if(!ofs) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable to open file &quot\newline	 &lt&lt output &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  for(std::vector&ltNode*&gt::iterator nit=nodes-&gtbegin(); \newline      nit!=nodes-&gtend(); ++nit) {\newline    float py1 = (*nit)-&gt_h_layers_activations[(*nit)-&gt_s-1][0];\newline    ofs &lt&lt (1-py1) &lt&lt &#039 &#039 &lt&lt py1 &lt&lt endl;\newline  }\newline  \newline  // deallocate Recursive Network structure\newline  delete rnn; rnn = 0;\newline  // deallocate dataset\newline  if(testset) { delete testset; testset = 0; }\newline}\newline","\newlinePredict bonding state with BRNN model.\newline \newline","286520","trace-kernel.c","struct ltt_kernel_event *trace_kernel_create_event(struct lttng_event *ev,\newline		char *filter_expression, struct lttng_filter_bytecode *filter)\newline{\newline	struct ltt_kernel_event *lke;\newline	struct lttng_kernel_event *attr;\newline\newline	assert(ev);\newline\newline	lke = zmalloc(sizeof(struct ltt_kernel_event));\newline	attr = zmalloc(sizeof(struct lttng_kernel_event));\newline	if (lke == NULL || attr == NULL) {\newline		PERROR(&quotkernel event zmalloc&quot);\newline		goto error;\newline	}\newline\newline	switch (ev-&gttype) {\newline	case LTTNG_EVENT_PROBE:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KPROBE;\newline		attr-&gtu.kprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KRETPROBE;\newline		attr-&gtu.kretprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kretprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kretprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kretprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION_ENTRY:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_FUNCTION;\newline		strncpy(attr-&gtu.ftrace.symbol_name,\newline				ev-&gtattr.ftrace.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.ftrace.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_TRACEPOINT:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_TRACEPOINT;\newline		break;\newline	case LTTNG_EVENT_SYSCALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_SYSCALL;\newline		break;\newline	case LTTNG_EVENT_ALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_ALL;\newline		break;\newline	default:\newline		ERR(&quotUnknown kernel instrumentation type (%d)&quot, ev-&gttype);\newline		goto error;\newline	}\newline\newline	/* Copy event name */\newline	strncpy(attr-&gtname, ev-&gtname, LTTNG_KERNEL_SYM_NAME_LEN);\newline	attr-&gtname[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline\newline	/* Setting up a kernel event */\newline	lke-&gtfd = -1;\newline	lke-&gtevent = attr;\newline	lke-&gtenabled = 1;\newline	lke-&gtfilter_expression = filter_expression;\newline	lke-&gtfilter = filter;\newline\newline	return lke;\newline\newlineerror:\newline	free(filter_expression);\newline	free(filter);\newline	free(lke);\newline	free(attr);\newline	return NULL;\newline}\newline","\newline Allocate and initialize a kernel event. Set name and event type.\newline We own filter_expression, and filter.\newline \newline Return pointer to structure or NULL.\newline \newline","2083110","output.c","static unsigned count_move_list_ply(Move *move_list, Boolean count_variations)\newline{\newline    unsigned count = 0;\newline    while(move_list != NULL) {\newline        count += count_single_move_ply(move_list, count_variations);\newline	move_list = move_list-&gtnext;\newline    }\newline    return count;\newline}\newline","\newline Count how many plies in the game in total.\newline Include variations if count_variations.\newline \newline","","on","","","on","","","","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","Load an image from the named file.","{}","Changes a balls trajectory","Display options to the screen","{}","This routines read one gif data block at a time","Wait for an iteration to start","Parses a drawbar registration.","used to show a blank display","{}","Predict bonding state with BRNN model.","deals with the exclusive or operator","Allocate and initialize a kernel event.","Count how many plies in the game","{}","Traverse args,","Get pointers to RRset members and signature(s)","Decode DCS to sms fields","Open a stream for incoming and outgoing data","Search for ATI card on PCI bus","Find an event using the name and signature in the given registry."
"3WYZV0QBFJDG63D7PQCNJUAFAZUBXB","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3R9WASFE2ZGXBZMVLCR5OOD0DL0ZFY","A2MF174E19LY8D","Approved","Wed Apr 17 14:34:39 PDT 2019","Wed Apr 17 14:38:30 PDT 2019","Fri Apr 19 14:38:30 PDT 2019","2019-04-19 21:39:21 UTC","","","231","100% (4/4)","100% (4/4)","100% (4/4)","3580134","image.c","GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline","\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline","5108090","evaluate.c","static void eval_fveor(void) {\newline  stackitem lhitem;\newline  int32 rhint = TOINT(pop_float());\newline  lhitem = GET_TOPITEM;\newline  if (lhitem == STACK_INT)\newline    EOR_INT(rhint);\newline  else if (lhitem == STACK_FLOAT)\newline    push_int(TOINT(pop_float()) ^ rhint);\newline  else {\newline    want_number();\newline  }\newline}\newline","\newline &#039eval_fveor&#039 deals with the exclusive or operator when right-hand\newline operand is a floating point value\newline \newline","4350475","numrgts.cpp","void NumberFormatRegressionTest::TestJ691(void) {\newline    UErrorCode status = U_ZERO_ERROR;\newline    Locale loc(&quotfr&quot, &quotCH&quot);\newline\newline    // set up the input date string &amp expected output\newline    UnicodeString udt(&quot11.10.2000&quot, &quot&quot);\newline    UnicodeString exp(&quot11.10.00&quot, &quot&quot);\newline\newline    // create a Calendar for this locale\newline    Calendar *cal = Calendar::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: Calendar::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // create a NumberFormat for this locale\newline    NumberFormat *nf = NumberFormat::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: NumberFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // *** Here&#039s the key: We don&#039t want to have to do THIS:\newline    // nf-&gtsetParseIntegerOnly(TRUE);\newline\newline    // create the DateFormat\newline    DateFormat *df = DateFormat::createDateInstance(DateFormat::kShort, loc);\newline    if (U_FAILURE(status)) {\newline        errln(&quotFAIL: DateFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    df-&gtadoptCalendar(cal);\newline    df-&gtadoptNumberFormat(nf);\newline\newline    // set parsing to lenient &amp parse\newline    df-&gtsetLenient(TRUE);\newline    UDate ulocdat = df-&gtparse(udt, status);\newline\newline    // format back to a string\newline    UnicodeString outString;\newline    df-&gtformat(ulocdat, outString);\newline\newline    if (outString != exp) {\newline        errln(&quotFAIL: &quot + udt + &quot =&gt &quot + outString);\newline    }\newline\newline    delete df;\newline}\newline","\newline DateFormat should call setIntegerParseOnly(TRUE) on adopted\newline NumberFormat objects.\newline \newline","1226709","poly_simplifier_plugin.cpp","void poly_simplifier_plugin::process_monomial(unsigned num_args, expr * const * args, numeral &amp k, ptr_buffer&ltexpr&gt &amp result) {\newline    rational v;\newline    for (unsigned i = 0; i &lt num_args; i++) {\newline        expr * arg = args[i];\newline        if (is_numeral(arg, v))\newline            k *= v;\newline        else\newline            result.push_back(arg);\newline    }\newline}\newline","\newline\\brief Traverse args, and copy the non-numeral exprs to result, and accumulate the \newlinevalue of the numerals in k.\newline \newline","5137164","dnssec.c","static int explore_rrset(struct dns_header *header, size_t plen, int class, int type, \newline			 char *name, char *keyname, int *sigcnt, int *rrcnt)\newline{\newline  static int rrset_sz = 0, sig_sz = 0; \newline  unsigned char *p;\newline  int rrsetidx, sigidx, j, rdlen, res;\newline  int gotkey = 0;\newline\newline  if (!(p = skip_questions(header, plen)))\newline    return STAT_BOGUS;\newline\newline   /* look for RRSIGs for this RRset and get pointers to each RR in the set. */\newline  for (rrsetidx = 0, sigidx = 0, j = ntohs(header-&gtancount) + ntohs(header-&gtnscount); \newline       j != 0; j--) \newline    {\newline      unsigned char *pstart, *pdata;\newline      int stype, sclass, type_covered;\newline\newline      pstart = p;\newline      \newline      if (!(res = extract_name(header, plen, &ampp, name, 0, 10)))\newline	return STAT_BOGUS; /* bad packet */\newline      \newline      GETSHORT(stype, p);\newline      GETSHORT(sclass, p);\newline      p += 4; /* TTL */\newline      \newline      pdata = p;\newline\newline      GETSHORT(rdlen, p);\newline      \newline      if (!CHECK_LEN(header, p, plen, rdlen))\newline	return 0; \newline      \newline      if (res == 1 &amp&amp sclass == class)\newline	{\newline	  if (stype == type)\newline	    {\newline	      if (!expand_workspace(&amprrset, &amprrset_sz, rrsetidx))\newline		return 0; \newline	      \newline	      rrset[rrsetidx++] = pstart;\newline	    }\newline	  \newline	  if (stype == T_RRSIG)\newline	    {\newline	      if (rdlen &lt 18)\newline		return 0; /* bad packet */ \newline	      \newline	      GETSHORT(type_covered, p);\newline	      p += 16; /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */\newline	      \newline	      if (gotkey)\newline		{\newline		  /* If there&#039s more than one SIG, ensure they all have same keyname */\newline		  if (extract_name(header, plen, &ampp, keyname, 0, 0) != 1)\newline		    return 0;\newline		}\newline	      else\newline		{\newline		  gotkey = 1;\newline		  \newline		  if (!extract_name(header, plen, &ampp, keyname, 1, 0))\newline		    return 0;\newline		  \newline		  /* RFC 4035 5.3.1 says that the Signer&#039s Name field MUST equal\newline		     the name of the zone containing the RRset. We can&#039t tell that\newline		     for certain, but we can check that  the RRset name is equal to\newline		     or encloses the signers name, which should be enough to stop \newline		     an attacker using signatures made with the key of an unrelated \newline		     zone he controls. Note that the root key is always allowed. */\newline		  if (*keyname != 0)\newline		    {\newline		      char *name_start;\newline		      for (name_start = name; !hostname_isequal(name_start, keyname); )\newline			if ((name_start = strchr(name_start, &#039.&#039)))\newline			  name_start++; /* chop a label off and try again */\newline			else\newline			  return 0;\newline		    }\newline		}\newline		  \newline	      \newline	      if (type_covered == type)\newline		{\newline		  if (!expand_workspace(&ampsigs, &ampsig_sz, sigidx))\newline		    return 0; \newline		  \newline		  sigs[sigidx++] = pdata;\newline		} \newline	      \newline	      p = pdata + 2; /* restore for ADD_RDLEN */\newline	    }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, plen, rdlen))\newline	return 0;\newline    }\newline  \newline  *sigcnt = sigidx;\newline  *rrcnt = rrsetidx;\newline\newline  return 1;\newline}\newline","Get pointers to RRset members and signature(s) for same.\newlineCheck signatures, and return keyname associated in keyname. \newline","4515373","sms.c","int dcs_to_fields(Msg **msg, int dcs) \newline{\newline    /* Non-MWI Mode 1 */\newline    if ((dcs &amp 0xF0) == 0xF0) { \newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.coding = (dcs &amp 0x04) ? DC_8BIT : DC_7BIT; /* grab bit 2 */\newline        (*msg)-&gtsms.mclass = dcs &amp 0x03; /* grab bits 1,0 */\newline        (*msg)-&gtsms.alt_dcs = 1; /* set 0xFX data coding */\newline    }\newline    \newline    /* Non-MWI Mode 0 */\newline    else if ((dcs &amp 0xC0) == 0x00) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.compress = ((dcs &amp 0x20) == 0x20) ? 1 : 0; /* grab bit 5 */\newline        (*msg)-&gtsms.mclass = ((dcs &amp 0x10) == 0x10) ? dcs &amp 0x03 : MC_UNDEF; \newline						/* grab bit 0,1 if bit 4 is on */\newline        (*msg)-&gtsms.coding = (dcs &amp 0x0C) &gt&gt 2; /* grab bit 3,2 */\newline    }\newline\newline    /* MWI */\newline    else if ((dcs &amp 0xC0) == 0xC0) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.coding = ((dcs &amp 0x30) == 0x30) ? DC_UCS2 : DC_7BIT;\newline        if (!(dcs &amp 0x08))\newline            dcs |= 0x04; /* if bit 3 is active, have mwi += 4 */\newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.mwi = dcs ; /* grab bits 1,0 */\newline    } \newline    \newline    else {\newline        return 0;\newline    }\newline\newline    return 1;\newline}\newline","\newline Decode DCS to sms fields\newline \newline","6581533","ptstream.c","PTSTREAM *stream_open(int incoming_fd, int outgoing_fd) {\newline	PTSTREAM *pts;\newline\newline	/* Initialise the structure and store the file descriptor */\newline	pts = malloc(sizeof(PTSTREAM));\newline	pts-&gtincoming_fd = incoming_fd;\newline	pts-&gtoutgoing_fd = outgoing_fd;\newline	pts-&gtssl = NULL;\newline	pts-&gtctx = NULL;\newline\newline	/* Return a pointer to the structure */\newline	return pts;\newline}\newline","Open a stream for incoming and outgoing data with the specified fds \newline","5150506","rovclock.c","int find_card(struct rovclock_data *rovclock)\newline{\newline	FILE *proc;\newline	char temp;\newline	u32 id;\newline	\newline	/* Check /proc/bus/pci/devices first */\newline	if ((proc = fopen(&quot/proc/bus/pci/devices&quot, &quotr&quot)) != NULL) {\newline		while (fscanf(proc, &quot%x\\t%x&quot, &amprovclock-&gtpci_bus, &ampid) == 2) {\newline			if ((id &gt&gt 16) == PCI_VENDOR_ID_ATI) {\newline				rovclock-&gtpci_dev = (rovclock-&gtpci_bus &amp 0xff) &gt&gt 3;\newline				rovclock-&gtpci_bus = rovclock-&gtpci_bus &gt&gt 8;\newline				rovclock-&gtpci_id = (id &lt&lt 16) | (id &gt&gt 16);\newline				\newline				/* Check for display device */\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY) {\newline					fclose(proc);\newline					return 0;\newline				}\newline			}\newline			while ((temp = fgetc(proc)) != EOF)\newline				if (temp == &#039\\n&#039)\newline					break;\newline		}\newline	}\newline	if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline		fprintf(stderr, &quotSearch in /proc/bus/pci/devices failed, scanning the PCI bus.\\n&quot);\newline\newline		/* Find card by scanning the PCI devices, check from bus 1 to 9 for ATI device */\newline		rovclock-&gtpci_dev = 0;\newline		for (rovclock-&gtpci_bus = 1; rovclock-&gtpci_bus &lt 10; rovclock-&gtpci_bus++) {\newline			if (((rovclock-&gtpci_id = pci_read(rovclock-&gtpci_bus, 0, 0, 0)) &amp 0xffff) == PCI_VENDOR_ID_ATI) {\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY)\newline					break;\newline			}\newline		}\newline	\newline		if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline			fprintf(stderr, &quotNo ATI card found.\\n&quot);\newline			return -1;\newline		}\newline	}\newline	\newline	return 0;\newline}\newline","Search for ATI card on PCI bus \newline","286635","ust-registry.c","struct ust_registry_event *ust_registry_find_event(\newline		struct ust_registry_channel *chan, char *name, char *sig)\newline{\newline	struct lttng_ht_node_u64 *node;\newline	struct lttng_ht_iter iter;\newline	struct ust_registry_event *event = NULL;\newline	struct ust_registry_event key;\newline\newline	assert(chan);\newline	assert(name);\newline	assert(sig);\newline\newline	/* Setup key for the match function. */\newline	strncpy(key.name, name, sizeof(key.name));\newline	key.name[sizeof(key.name) - 1] = &#039\\0&#039;\newline	key.signature = sig;\newline\newline	cds_lfht_lookup(chan-&gtht-&gtht, chan-&gtht-&gthash_fct(&ampkey, lttng_ht_seed),\newline			chan-&gtht-&gtmatch_fct, &ampkey, &ampiter.iter);\newline	node = lttng_ht_iter_get_node_u64(&ampiter);\newline	if (!node) {\newline		goto end;\newline	}\newline	event = caa_container_of(node, struct ust_registry_event, node);\newline\newlineend:\newline	return event;\newline}\newline","\newline Find an event using the name and signature in the given registry. RCU read\newline side lock MUST be acquired before calling this function and as long as the\newline event reference is kept by the caller.\newline \newline On success, the event pointer is returned else NULL.\newline \newline","5208573","incomplete.c","int main(int argc, char **argv)\newline{\newline  /* scheduling parameters */\newline  double communication_amount1 = 1e9;\newline  double no_cost = 0.0;\newline\newline  /* initialization of SD */\newline  SD_init(&ampargc, argv);\newline\newline  /* creation of the environment */\newline  SD_create_environment(argv[1]);\newline\newline  /* creation of the tasks and their dependencies */\newline  SD_task_t taskInit = SD_task_create(&quotInit&quot, NULL, 1.0);\newline  SD_task_t taskA = SD_task_create(&quotTask A&quot, NULL, 1.0);\newline  SD_task_t taskB = SD_task_create(&quotTask B&quot, NULL, 1.0);\newline  SD_task_t taskC = SD_task_create(&quotTask C&quot, NULL, 1.0);\newline  SD_task_t taskD = SD_task_create(&quotTask D&quot, NULL, 1.0);\newline\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskA);\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskB);\newline  SD_task_dependency_add(NULL, NULL, taskC, taskD);\newline\newline  sg_host_t *hosts = sg_host_list();\newline  SD_task_schedule(taskInit, 1, hosts, &ampno_cost, &ampno_cost, -1.0);\newline  SD_task_schedule(taskA, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  SD_task_schedule(taskD, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  xbt_free(hosts);\newline\newline  /* let&#039s launch the simulation! */\newline  SD_simulate(-1.);\newline\newline  SD_task_destroy(taskA);\newline  SD_task_destroy(taskB);\newline  SD_task_destroy(taskC);\newline  SD_task_destroy(taskD);\newline  SD_task_destroy(taskInit);\newline\newline  XBT_INFO(&quotSimulation time: %f&quot, SD_get_clock());\newline\newline  SD_exit();\newline  return 0;\newline}\newline","SimDag Incomplete Test\newline Scenario:\newline - Create a bunch of tasks\newline - schedule only a subset of them (init, A and D)\newline - run the simulation\newline - Verify that we detect which tasks are not scheduled and show their state.\newline The scheduled task A sends 1GB. Simulation time should be\newline 1e9/1.25e8 + 1e-4 = 8.0001 seconds\newline Task D is scheduled but depends on unscheduled task C.\newline \newline","3008491","collision.c","static void recalculate_ball_trajectory(Game *game, Ball *ball, Side side) {\newline\newline	add_bounce_entropy(game, ball);\newline\newline	/* Recalculate the trajectory */\newline	switch(side) {\newline		case SIDE_RIGHT :\newline			ball-&gtdirection += (RAD90 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_LEFT :\newline			ball-&gtdirection += (RAD270 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_BOTTOM :\newline			ball-&gtdirection += (RAD180 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_TOP :\newline			/*if(ball-&gtdirection &gt RAD180)\newline				ball-&gtdirection -= ball-&gtdirection * 2.0;\newline			else*/\newline				ball-&gtdirection += (RAD360 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_DIAGONAL :\newline			ball-&gtdirection += RAD180;\newline			break;\newline		default :\newline			g_assert_not_reached();\newline	}\newline\newline	/* Make sure the ball hasn&#039t been bounced the wrong way */\newline	while(ball-&gtdirection &gt RAD360)\newline		ball-&gtdirection -= RAD360;\newline\newline	while(ball-&gtdirection &lt 0)\newline		ball-&gtdirection += RAD360;\newline\newline	/* And move it an extra step, so that the ball doesn&#039t appear inside\newline	 * the block when we refresh */\newline	move_ball(ball);\newline}\newline","Changes a balls trajectory depending on which side of an object it hit. \newline","2010218","esolver.c","static void usage (char *s)\newline{\newline	fprintf (stderr, &quotUsage: %s [- below -] prob_file\\n&quot, s);\newline	fprintf (stderr, &quot   -b f  write basis to file f\\n&quot);\newline	fprintf (stderr, &quot   -B f  read initial basis from file f\\n&quot);\newline#if 0\newline	fprintf (stderr, &quot   -I    solve the MIP using BestBound\\n&quot);\newline	fprintf (stderr, &quot   -E    edit problem after solving initial version\\n&quot);\newline#endif\newline	fprintf (stderr, &quot   -L    input file is in lp format (default: mps)\\n&quot);\newline	fprintf (stderr, &quot   -O    write the final solution to the given file\\n&quot);\newline	fprintf (stderr, &quot         append .gz/.bz2 to the .sol extension to compress the file\\n&quot);\newline	fprintf (stderr, &quot   -p #  run primal simplex with pricing rule #\\n&quot);\newline	fprintf (stderr,\newline					 &quot         (%d-Dantzig, %d-Devex, %d-Steep (default), %d-Partial\\n&quot,\newline					 QS_PRICE_PDANTZIG, QS_PRICE_PDEVEX, QS_PRICE_PSTEEP,\newline					 QS_PRICE_PMULTPARTIAL);\newline	fprintf (stderr,\newline					 &quot   -P #  number of bits to use for the float representation (default: 128)\\n&quot);\newline	fprintf (stderr, &quot   -d #  run dual simplex with pricing rule #\\n&quot);\newline	fprintf (stderr, &quot         (%d-Dantzig, %d-Steep, %d-Partial, %d-Devex)\\n&quot,\newline					 QS_PRICE_DDANTZIG, QS_PRICE_DSTEEP, QS_PRICE_DMULTPARTIAL,\newline					 QS_PRICE_DDEVEX);\newline	fprintf (stderr, &quot   -S    do NOT scale the initial LP\\n&quot);\newline	fprintf (stderr, &quot   -v    print QSopt version number\\n&quot);\newline	fprintf (stderr, &quot   -R n  maximum running time allowed, default %lf\\n&quot,\newline						max_rtime);\newline	fprintf (stderr, &quot   -m n  maximum memory usage allowed, default %lu\\n&quot, \newline						memlimit);\newline}\newline","@brief Display options to the screen \newline","5583825","statement.c","static int statement_columns(lua_State *L) {\newline    statement_t *statement = (statement_t *)luaL_checkudata(L, 1, DBD_POSTGRESQL_STATEMENT);\newline\newline    int i;\newline    int num_columns;\newline    int d = 1;\newline\newline    if (!statement-&gtresult) {\newline        luaL_error(L, DBI_ERR_INVALID_STATEMENT);\newline        return 0;\newline    }\newline\newline    num_columns = PQnfields(statement-&gtresult);\newline    lua_newtable(L);\newline    for (i = 0; i &lt num_columns; i++) {\newline        const char *name = PQfname(statement-&gtresult, i);\newline\newline	LUA_PUSH_ARRAY_STRING(d, name);\newline    }\newline\newline    return 1;\newline}\newline","\newline column_names = statement:columns()\newline \newline","3964212","dgif_lib.c","static int DGifBufferedInput(FILE *File, GifByteType *Buf,\newline						      GifByteType *NextByte)\newline{\newline    if (Buf[0] == 0) {\newline	/* Needs to read the next buffer - this one is empty: */\newline	if (fread(Buf, 1, 1, File) != 1)\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	if (fread(&ampBuf[1], 1, Buf[0], File) != Buf[0])\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	*NextByte = Buf[1];\newline	Buf[1] = 2;	   /* We use now the second place as last char read! */\newline	Buf[0]--;\newline    }\newline    else {\newline	*NextByte = Buf[Buf[1]++];\newline	Buf[0]--;\newline    }\newline\newline    return GIF_OK;\newline}\newline","\newline This routines read one gif data block at a time and buffers it internally \newline so that the decompression routine could access it. \newline The routine returns the next byte from its internal buffer (or read next \newline block in if buffer empty) and returns GIF_OK if succesful. \newline \newline","4152762","btreplay.c","static inline void wait_iter_start(void)\newline{\newline	pthread_mutex_lock(&ampiter_start_mutex);\newline	while (iter_start == 0)\newline		pthread_cond_wait(&ampiter_start_cond, &ampiter_start_mutex);\newline	assert(1 &lt= iter_start &amp&amp iter_start &lt= nfiles);\newline	iter_start--;\newline	pthread_mutex_unlock(&ampiter_start_mutex);\newline}\newline","\newline wait_iter_start - Wait for an iteration to start \newline \newline This is /slightly/ different: we are waiting for a value to become\newline non-zero, and then we decrement it and go on. \newline \newline","201946","program.c","static int parseDrawbarRegistration (const char * drw,\newline				     unsigned int bar[],\newline				     const int    lineNumber,\newline				     const char * fileName) {\newline\newline  char msg[MESSAGEBUFFERSIZE];\newline  int bus = 0;\newline  const char * t = drw;\newline\newline  while (bus &lt 9) {\newline    if (*t == &#039\\0&#039) {\newline      sprintf (msg, &quotDrawbar registration incomplete &#039%s&#039&quot, drw);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline    if ((isspace (*t)) || (*t == &#039-&#039) || (*t == &#039_&#039)) {\newline      t++;\newline      continue;\newline    }\newline    if ((&#0390&#039 &lt= *t) &amp&amp (*t &lt= &#0398&#039)) {\newline      bar[bus] = *t - &#0390&#039;\newline      t++;\newline      bus++;\newline      continue;\newline    }\newline    else {\newline      sprintf (msg, &quotIllegal char in drawbar registration &#039%c&#039&quot, *t);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","\newline Parses a drawbar registration.\newline @param drw The drawbar registration string.\newline @param bar Array of intergers where the registration is stored.\newline @param lineNumber The linenumber in the input file.\newline @param fileName The name of the current input file.\newline \newline","6073226","rundiff.c","DiffInfo *blank_diff_info (void)\newline{\newline    Block *b;\newline    DiffInfo *di;\newline\newline    di = (DiffInfo *) calloc (1, sizeof (DiffInfo));\newline    di-&gtlongline = &quot  &quot;\newline    di-&gtmaxcols = strlen (di-&gtlongline);\newline    di-&gtstatus = 2;\newline\newline    b = (Block *) calloc (1, sizeof (Block));\newline    b-&gtselected = NEITHER;\newline    b-&gtarr[LEFT].type = b-&gtarr[RIGHT].type = SAME;\newline    b-&gtsline = 0;\newline    b-&gtssize = 1;\newline    b-&gtarr[LEFT].fline = b-&gtarr[RIGHT].fline = 0;\newline    b-&gtarr[LEFT].fsize = b-&gtarr[RIGHT].fsize = 1;\newline    b-&gtarr[LEFT].text = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].wtext = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].tlen = (short *) calloc (1, sizeof (short));\newline    b-&gtarr[LEFT].text[0] = strdup (&quot  &quot);\newline    b-&gtarr[LEFT].tlen[0] = strlen (b-&gtarr[LEFT].text[0]);\newline\newline    b-&gtarr[RIGHT].text = NULL;\newline    b-&gtarr[RIGHT].wtext = NULL;\newline    b-&gtarr[RIGHT].tlen = NULL;\newline    di-&gtfirst = di-&gtlast = b;\newline    di-&gtlines = b-&gtsline + b-&gtssize;\newline    di-&gtflines[LEFT] = b-&gtarr[LEFT].fline + b-&gtarr[LEFT].fsize;\newline    di-&gtflines[RIGHT] = b-&gtarr[RIGHT].fline + b-&gtarr[RIGHT].fsize;\newline\newline    return (di);\newline}\newline","\newline build just enough of a DiffInfo structure so that routines that use \newline the data won&#039t be shocked. this is used to show a blank display \newline (no files loaded).\newline \newline","5921779","os2.c","static void cvt_path_to_correct_case(char *buf)\newline{\newline    char *fname = buf + 3;            /* point to first element. */\newline    char *ptr = strchr(fname, &#039\\\\&#039);  /* find end of first element. */\newline\newline    buf[0] = toupper(buf[0]);  /* capitalize drive letter. */\newline\newline    /*\newline     * Go through each path element, and enumerate its parent dir until\newline     *  a case-insensitive match is found. If one is (and it SHOULD be)\newline     *  then overwrite the original element with the correct case.\newline     * If there&#039s an error, or the path has vanished for some reason, it\newline     *  won&#039t hurt to have the original case, so we just keep going.\newline     */\newline    while (fname != NULL)\newline    {\newline        char spec[CCHMAXPATH];\newline        FILEFINDBUF3 fb;\newline        HDIR hdir = HDIR_CREATE;\newline        ULONG count = 1;\newline        APIRET rc;\newline\newline        *(fname - 1) = &#039\\0&#039;  /* isolate parent dir string. */\newline\newline        strcpy(spec, buf);      /* copy isolated parent dir... */\newline        strcat(spec, &quot\\\\*.*&quot);  /*  ...and add wildcard search spec. */\newline\newline        if (ptr != NULL)  /* isolate element to find (fname is the start). */\newline            *ptr = &#039\\0&#039;\newline\newline        rc = DosFindFirst(spec, &amphdir, FILE_DIRECTORY,\newline                          &ampfb, sizeof (fb), &ampcount, FIL_STANDARD);\newline        if (rc == NO_ERROR)\newline        {\newline            while (count == 1)  /* while still entries to enumerate... */\newline            {\newline                if (__PHYSFS_stricmpASCII(fb.achName, fname) == 0)\newline                {\newline                    strcpy(fname, fb.achName);\newline                    break;  /* there it is. Overwrite and stop searching. */\newline                } /* if */\newline\newline                DosFindNext(hdir, &ampfb, sizeof (fb), &ampcount);\newline            } /* while */\newline            DosFindClose(hdir);\newline        } /* if */\newline\newline        *(fname - 1) = &#039\\\\&#039;   /* unisolate parent dir. */\newline        fname = ptr;           /* point to next element. */\newline        if (ptr != NULL)\newline        {\newline            *ptr = &#039\\\\&#039;       /* unisolate element. */\newline            ptr = strchr(++fname, &#039\\\\&#039);  /* find next element. */\newline        } /* if */\newline    } /* while */\newline} /* cvt_file_to_correct_case */\newline","(be gentle, this function isn&#039t very robust.) \newline","4586590","rnn_util.cpp","void rnn_predict_bonding_state(const string&amp config, \newline			       const string&amp model,\newline			       const string&amp input,\newline			       const string&amp output) {\newline  // get RNN option (unique) instance\newline  Options* rnn_option = Options::instance();\newline\newline  // set BRNN parameters from bonding state config file\newline  rnn_option-&gtparse_config(config);\newline  rnn_option-&gtsetParameter(&quotnetname&quot, model);\newline  \newline  // Create test set with only the given input \newline  DataSet *testset = new DataSet(input.c_str());\newline  if(!testset) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: failed dataset creation.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // initialize BRNN\newline  RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt* \newline    rnn = new RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt(model.c_str());\newline  if(!rnn) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable &quot\newline      &quotto read brnn file &quot &lt&lt model &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // predict\newline  DataSet::iterator it=testset-&gtbegin(); // only one input chain\newline  vector&ltNode*&gt *nodes = it.currenTONodes();\newline  std::pair&ltDPAG, DPAG&gt *dpags = it.currentDPAGs();\newline  rnn-&gtpropagateStructuredInput(*nodes, *dpags);\newline\newline  // write predictions to output file\newline  ofstream ofs(output.c_str());\newline  if(!ofs) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable to open file &quot\newline	 &lt&lt output &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  for(std::vector&ltNode*&gt::iterator nit=nodes-&gtbegin(); \newline      nit!=nodes-&gtend(); ++nit) {\newline    float py1 = (*nit)-&gt_h_layers_activations[(*nit)-&gt_s-1][0];\newline    ofs &lt&lt (1-py1) &lt&lt &#039 &#039 &lt&lt py1 &lt&lt endl;\newline  }\newline  \newline  // deallocate Recursive Network structure\newline  delete rnn; rnn = 0;\newline  // deallocate dataset\newline  if(testset) { delete testset; testset = 0; }\newline}\newline","\newlinePredict bonding state with BRNN model.\newline \newline","286520","trace-kernel.c","struct ltt_kernel_event *trace_kernel_create_event(struct lttng_event *ev,\newline		char *filter_expression, struct lttng_filter_bytecode *filter)\newline{\newline	struct ltt_kernel_event *lke;\newline	struct lttng_kernel_event *attr;\newline\newline	assert(ev);\newline\newline	lke = zmalloc(sizeof(struct ltt_kernel_event));\newline	attr = zmalloc(sizeof(struct lttng_kernel_event));\newline	if (lke == NULL || attr == NULL) {\newline		PERROR(&quotkernel event zmalloc&quot);\newline		goto error;\newline	}\newline\newline	switch (ev-&gttype) {\newline	case LTTNG_EVENT_PROBE:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KPROBE;\newline		attr-&gtu.kprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KRETPROBE;\newline		attr-&gtu.kretprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kretprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kretprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kretprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION_ENTRY:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_FUNCTION;\newline		strncpy(attr-&gtu.ftrace.symbol_name,\newline				ev-&gtattr.ftrace.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.ftrace.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_TRACEPOINT:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_TRACEPOINT;\newline		break;\newline	case LTTNG_EVENT_SYSCALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_SYSCALL;\newline		break;\newline	case LTTNG_EVENT_ALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_ALL;\newline		break;\newline	default:\newline		ERR(&quotUnknown kernel instrumentation type (%d)&quot, ev-&gttype);\newline		goto error;\newline	}\newline\newline	/* Copy event name */\newline	strncpy(attr-&gtname, ev-&gtname, LTTNG_KERNEL_SYM_NAME_LEN);\newline	attr-&gtname[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline\newline	/* Setting up a kernel event */\newline	lke-&gtfd = -1;\newline	lke-&gtevent = attr;\newline	lke-&gtenabled = 1;\newline	lke-&gtfilter_expression = filter_expression;\newline	lke-&gtfilter = filter;\newline\newline	return lke;\newline\newlineerror:\newline	free(filter_expression);\newline	free(filter);\newline	free(lke);\newline	free(attr);\newline	return NULL;\newline}\newline","\newline Allocate and initialize a kernel event. Set name and event type.\newline We own filter_expression, and filter.\newline \newline Return pointer to structure or NULL.\newline \newline","2083110","output.c","static unsigned count_move_list_ply(Move *move_list, Boolean count_variations)\newline{\newline    unsigned count = 0;\newline    while(move_list != NULL) {\newline        count += count_single_move_ply(move_list, count_variations);\newline	move_list = move_list-&gtnext;\newline    }\newline    return count;\newline}\newline","\newline Count how many plies in the game in total.\newline Include variations if count_variations.\newline \newline","","","on","","on","on","","","","on","","","","","","","","","","","","","on","","","","","","","","","","","on","","","on","","","","","","Load an image from the named file.","Create a bunch of tasks","{}","Display options to the screen","{}","{}","Wait for an iteration to start","Parses a drawbar registration.","build just enough of a DiffInfo structure","{}","Predict bonding state with BRNN model.","the exclusive or operator","Allocate and initialize a kernel event.","Count how many plies in the game in total.","call setIntegerParseOnly(TRUE) on adoptedNumberFormat objects.","\brief Traverse args, and copy the non-numeral exprs to result,","Check signatures, and return keyname associated in keyname.","Decode DCS to sms fields","Open a stream for incoming and outgoing data","Search for ATI card on PCI bus","Find an event using the name and signature in the given registry."
"3WYZV0QBFJDG63D7PQCNJUAFAZUBXB","3D8T3D6PQEJ8FT08SJ8RS7AD13ZYOB","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function. (Presently only open to those who have not completed this task in the past)","programming code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 09:44:50 PDT 2019","4","BatchId:3610864;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 09:44:50 PDT 2019","","","3RANCT1ZVFHQCJG5AN61O670W5IBUS","A2U1OCHJOOLVMB","Approved","Wed Apr 17 13:44:05 PDT 2019","Wed Apr 17 13:47:11 PDT 2019","Fri Apr 19 13:47:11 PDT 2019","2019-04-19 20:47:21 UTC","","","186","100% (6/6)","100% (6/6)","100% (6/6)","3580134","image.c","GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline","\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline","5108090","evaluate.c","static void eval_fveor(void) {\newline  stackitem lhitem;\newline  int32 rhint = TOINT(pop_float());\newline  lhitem = GET_TOPITEM;\newline  if (lhitem == STACK_INT)\newline    EOR_INT(rhint);\newline  else if (lhitem == STACK_FLOAT)\newline    push_int(TOINT(pop_float()) ^ rhint);\newline  else {\newline    want_number();\newline  }\newline}\newline","\newline &#039eval_fveor&#039 deals with the exclusive or operator when right-hand\newline operand is a floating point value\newline \newline","4350475","numrgts.cpp","void NumberFormatRegressionTest::TestJ691(void) {\newline    UErrorCode status = U_ZERO_ERROR;\newline    Locale loc(&quotfr&quot, &quotCH&quot);\newline\newline    // set up the input date string &amp expected output\newline    UnicodeString udt(&quot11.10.2000&quot, &quot&quot);\newline    UnicodeString exp(&quot11.10.00&quot, &quot&quot);\newline\newline    // create a Calendar for this locale\newline    Calendar *cal = Calendar::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: Calendar::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // create a NumberFormat for this locale\newline    NumberFormat *nf = NumberFormat::createInstance(loc, status);\newline    if (U_FAILURE(status)) {\newline        dataerrln(&quotFAIL: NumberFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    // *** Here&#039s the key: We don&#039t want to have to do THIS:\newline    // nf-&gtsetParseIntegerOnly(TRUE);\newline\newline    // create the DateFormat\newline    DateFormat *df = DateFormat::createDateInstance(DateFormat::kShort, loc);\newline    if (U_FAILURE(status)) {\newline        errln(&quotFAIL: DateFormat::createInstance() returned &quot + (UnicodeString)u_errorName(status));\newline        return;\newline    }\newline\newline    df-&gtadoptCalendar(cal);\newline    df-&gtadoptNumberFormat(nf);\newline\newline    // set parsing to lenient &amp parse\newline    df-&gtsetLenient(TRUE);\newline    UDate ulocdat = df-&gtparse(udt, status);\newline\newline    // format back to a string\newline    UnicodeString outString;\newline    df-&gtformat(ulocdat, outString);\newline\newline    if (outString != exp) {\newline        errln(&quotFAIL: &quot + udt + &quot =&gt &quot + outString);\newline    }\newline\newline    delete df;\newline}\newline","\newline DateFormat should call setIntegerParseOnly(TRUE) on adopted\newline NumberFormat objects.\newline \newline","1226709","poly_simplifier_plugin.cpp","void poly_simplifier_plugin::process_monomial(unsigned num_args, expr * const * args, numeral &amp k, ptr_buffer&ltexpr&gt &amp result) {\newline    rational v;\newline    for (unsigned i = 0; i &lt num_args; i++) {\newline        expr * arg = args[i];\newline        if (is_numeral(arg, v))\newline            k *= v;\newline        else\newline            result.push_back(arg);\newline    }\newline}\newline","\newline\\brief Traverse args, and copy the non-numeral exprs to result, and accumulate the \newlinevalue of the numerals in k.\newline \newline","5137164","dnssec.c","static int explore_rrset(struct dns_header *header, size_t plen, int class, int type, \newline			 char *name, char *keyname, int *sigcnt, int *rrcnt)\newline{\newline  static int rrset_sz = 0, sig_sz = 0; \newline  unsigned char *p;\newline  int rrsetidx, sigidx, j, rdlen, res;\newline  int gotkey = 0;\newline\newline  if (!(p = skip_questions(header, plen)))\newline    return STAT_BOGUS;\newline\newline   /* look for RRSIGs for this RRset and get pointers to each RR in the set. */\newline  for (rrsetidx = 0, sigidx = 0, j = ntohs(header-&gtancount) + ntohs(header-&gtnscount); \newline       j != 0; j--) \newline    {\newline      unsigned char *pstart, *pdata;\newline      int stype, sclass, type_covered;\newline\newline      pstart = p;\newline      \newline      if (!(res = extract_name(header, plen, &ampp, name, 0, 10)))\newline	return STAT_BOGUS; /* bad packet */\newline      \newline      GETSHORT(stype, p);\newline      GETSHORT(sclass, p);\newline      p += 4; /* TTL */\newline      \newline      pdata = p;\newline\newline      GETSHORT(rdlen, p);\newline      \newline      if (!CHECK_LEN(header, p, plen, rdlen))\newline	return 0; \newline      \newline      if (res == 1 &amp&amp sclass == class)\newline	{\newline	  if (stype == type)\newline	    {\newline	      if (!expand_workspace(&amprrset, &amprrset_sz, rrsetidx))\newline		return 0; \newline	      \newline	      rrset[rrsetidx++] = pstart;\newline	    }\newline	  \newline	  if (stype == T_RRSIG)\newline	    {\newline	      if (rdlen &lt 18)\newline		return 0; /* bad packet */ \newline	      \newline	      GETSHORT(type_covered, p);\newline	      p += 16; /* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */\newline	      \newline	      if (gotkey)\newline		{\newline		  /* If there&#039s more than one SIG, ensure they all have same keyname */\newline		  if (extract_name(header, plen, &ampp, keyname, 0, 0) != 1)\newline		    return 0;\newline		}\newline	      else\newline		{\newline		  gotkey = 1;\newline		  \newline		  if (!extract_name(header, plen, &ampp, keyname, 1, 0))\newline		    return 0;\newline		  \newline		  /* RFC 4035 5.3.1 says that the Signer&#039s Name field MUST equal\newline		     the name of the zone containing the RRset. We can&#039t tell that\newline		     for certain, but we can check that  the RRset name is equal to\newline		     or encloses the signers name, which should be enough to stop \newline		     an attacker using signatures made with the key of an unrelated \newline		     zone he controls. Note that the root key is always allowed. */\newline		  if (*keyname != 0)\newline		    {\newline		      char *name_start;\newline		      for (name_start = name; !hostname_isequal(name_start, keyname); )\newline			if ((name_start = strchr(name_start, &#039.&#039)))\newline			  name_start++; /* chop a label off and try again */\newline			else\newline			  return 0;\newline		    }\newline		}\newline		  \newline	      \newline	      if (type_covered == type)\newline		{\newline		  if (!expand_workspace(&ampsigs, &ampsig_sz, sigidx))\newline		    return 0; \newline		  \newline		  sigs[sigidx++] = pdata;\newline		} \newline	      \newline	      p = pdata + 2; /* restore for ADD_RDLEN */\newline	    }\newline	}\newline      \newline      if (!ADD_RDLEN(header, p, plen, rdlen))\newline	return 0;\newline    }\newline  \newline  *sigcnt = sigidx;\newline  *rrcnt = rrsetidx;\newline\newline  return 1;\newline}\newline","Get pointers to RRset members and signature(s) for same.\newlineCheck signatures, and return keyname associated in keyname. \newline","4515373","sms.c","int dcs_to_fields(Msg **msg, int dcs) \newline{\newline    /* Non-MWI Mode 1 */\newline    if ((dcs &amp 0xF0) == 0xF0) { \newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.coding = (dcs &amp 0x04) ? DC_8BIT : DC_7BIT; /* grab bit 2 */\newline        (*msg)-&gtsms.mclass = dcs &amp 0x03; /* grab bits 1,0 */\newline        (*msg)-&gtsms.alt_dcs = 1; /* set 0xFX data coding */\newline    }\newline    \newline    /* Non-MWI Mode 0 */\newline    else if ((dcs &amp 0xC0) == 0x00) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.compress = ((dcs &amp 0x20) == 0x20) ? 1 : 0; /* grab bit 5 */\newline        (*msg)-&gtsms.mclass = ((dcs &amp 0x10) == 0x10) ? dcs &amp 0x03 : MC_UNDEF; \newline						/* grab bit 0,1 if bit 4 is on */\newline        (*msg)-&gtsms.coding = (dcs &amp 0x0C) &gt&gt 2; /* grab bit 3,2 */\newline    }\newline\newline    /* MWI */\newline    else if ((dcs &amp 0xC0) == 0xC0) { \newline        (*msg)-&gtsms.alt_dcs = 0;\newline        (*msg)-&gtsms.coding = ((dcs &amp 0x30) == 0x30) ? DC_UCS2 : DC_7BIT;\newline        if (!(dcs &amp 0x08))\newline            dcs |= 0x04; /* if bit 3 is active, have mwi += 4 */\newline        dcs &amp= 0x07;\newline        (*msg)-&gtsms.mwi = dcs ; /* grab bits 1,0 */\newline    } \newline    \newline    else {\newline        return 0;\newline    }\newline\newline    return 1;\newline}\newline","\newline Decode DCS to sms fields\newline \newline","6581533","ptstream.c","PTSTREAM *stream_open(int incoming_fd, int outgoing_fd) {\newline	PTSTREAM *pts;\newline\newline	/* Initialise the structure and store the file descriptor */\newline	pts = malloc(sizeof(PTSTREAM));\newline	pts-&gtincoming_fd = incoming_fd;\newline	pts-&gtoutgoing_fd = outgoing_fd;\newline	pts-&gtssl = NULL;\newline	pts-&gtctx = NULL;\newline\newline	/* Return a pointer to the structure */\newline	return pts;\newline}\newline","Open a stream for incoming and outgoing data with the specified fds \newline","5150506","rovclock.c","int find_card(struct rovclock_data *rovclock)\newline{\newline	FILE *proc;\newline	char temp;\newline	u32 id;\newline	\newline	/* Check /proc/bus/pci/devices first */\newline	if ((proc = fopen(&quot/proc/bus/pci/devices&quot, &quotr&quot)) != NULL) {\newline		while (fscanf(proc, &quot%x\\t%x&quot, &amprovclock-&gtpci_bus, &ampid) == 2) {\newline			if ((id &gt&gt 16) == PCI_VENDOR_ID_ATI) {\newline				rovclock-&gtpci_dev = (rovclock-&gtpci_bus &amp 0xff) &gt&gt 3;\newline				rovclock-&gtpci_bus = rovclock-&gtpci_bus &gt&gt 8;\newline				rovclock-&gtpci_id = (id &lt&lt 16) | (id &gt&gt 16);\newline				\newline				/* Check for display device */\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY) {\newline					fclose(proc);\newline					return 0;\newline				}\newline			}\newline			while ((temp = fgetc(proc)) != EOF)\newline				if (temp == &#039\\n&#039)\newline					break;\newline		}\newline	}\newline	if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline		fprintf(stderr, &quotSearch in /proc/bus/pci/devices failed, scanning the PCI bus.\\n&quot);\newline\newline		/* Find card by scanning the PCI devices, check from bus 1 to 9 for ATI device */\newline		rovclock-&gtpci_dev = 0;\newline		for (rovclock-&gtpci_bus = 1; rovclock-&gtpci_bus &lt 10; rovclock-&gtpci_bus++) {\newline			if (((rovclock-&gtpci_id = pci_read(rovclock-&gtpci_bus, 0, 0, 0)) &amp 0xffff) == PCI_VENDOR_ID_ATI) {\newline				id = pci_read(rovclock-&gtpci_bus, rovclock-&gtpci_dev, 0, PCI_CLASS_REVISION) &gt&gt 24;\newline				if (id == PCI_BASE_CLASS_DISPLAY)\newline					break;\newline			}\newline		}\newline	\newline		if ((rovclock-&gtpci_id &amp 0xffff) != PCI_VENDOR_ID_ATI) {\newline			fprintf(stderr, &quotNo ATI card found.\\n&quot);\newline			return -1;\newline		}\newline	}\newline	\newline	return 0;\newline}\newline","Search for ATI card on PCI bus \newline","286635","ust-registry.c","struct ust_registry_event *ust_registry_find_event(\newline		struct ust_registry_channel *chan, char *name, char *sig)\newline{\newline	struct lttng_ht_node_u64 *node;\newline	struct lttng_ht_iter iter;\newline	struct ust_registry_event *event = NULL;\newline	struct ust_registry_event key;\newline\newline	assert(chan);\newline	assert(name);\newline	assert(sig);\newline\newline	/* Setup key for the match function. */\newline	strncpy(key.name, name, sizeof(key.name));\newline	key.name[sizeof(key.name) - 1] = &#039\\0&#039;\newline	key.signature = sig;\newline\newline	cds_lfht_lookup(chan-&gtht-&gtht, chan-&gtht-&gthash_fct(&ampkey, lttng_ht_seed),\newline			chan-&gtht-&gtmatch_fct, &ampkey, &ampiter.iter);\newline	node = lttng_ht_iter_get_node_u64(&ampiter);\newline	if (!node) {\newline		goto end;\newline	}\newline	event = caa_container_of(node, struct ust_registry_event, node);\newline\newlineend:\newline	return event;\newline}\newline","\newline Find an event using the name and signature in the given registry. RCU read\newline side lock MUST be acquired before calling this function and as long as the\newline event reference is kept by the caller.\newline \newline On success, the event pointer is returned else NULL.\newline \newline","5208573","incomplete.c","int main(int argc, char **argv)\newline{\newline  /* scheduling parameters */\newline  double communication_amount1 = 1e9;\newline  double no_cost = 0.0;\newline\newline  /* initialization of SD */\newline  SD_init(&ampargc, argv);\newline\newline  /* creation of the environment */\newline  SD_create_environment(argv[1]);\newline\newline  /* creation of the tasks and their dependencies */\newline  SD_task_t taskInit = SD_task_create(&quotInit&quot, NULL, 1.0);\newline  SD_task_t taskA = SD_task_create(&quotTask A&quot, NULL, 1.0);\newline  SD_task_t taskB = SD_task_create(&quotTask B&quot, NULL, 1.0);\newline  SD_task_t taskC = SD_task_create(&quotTask C&quot, NULL, 1.0);\newline  SD_task_t taskD = SD_task_create(&quotTask D&quot, NULL, 1.0);\newline\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskA);\newline  SD_task_dependency_add(NULL, NULL, taskInit, taskB);\newline  SD_task_dependency_add(NULL, NULL, taskC, taskD);\newline\newline  sg_host_t *hosts = sg_host_list();\newline  SD_task_schedule(taskInit, 1, hosts, &ampno_cost, &ampno_cost, -1.0);\newline  SD_task_schedule(taskA, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  SD_task_schedule(taskD, 1, &amphosts[0], &ampno_cost, &ampcommunication_amount1, -1.0);\newline  xbt_free(hosts);\newline\newline  /* let&#039s launch the simulation! */\newline  SD_simulate(-1.);\newline\newline  SD_task_destroy(taskA);\newline  SD_task_destroy(taskB);\newline  SD_task_destroy(taskC);\newline  SD_task_destroy(taskD);\newline  SD_task_destroy(taskInit);\newline\newline  XBT_INFO(&quotSimulation time: %f&quot, SD_get_clock());\newline\newline  SD_exit();\newline  return 0;\newline}\newline","SimDag Incomplete Test\newline Scenario:\newline - Create a bunch of tasks\newline - schedule only a subset of them (init, A and D)\newline - run the simulation\newline - Verify that we detect which tasks are not scheduled and show their state.\newline The scheduled task A sends 1GB. Simulation time should be\newline 1e9/1.25e8 + 1e-4 = 8.0001 seconds\newline Task D is scheduled but depends on unscheduled task C.\newline \newline","3008491","collision.c","static void recalculate_ball_trajectory(Game *game, Ball *ball, Side side) {\newline\newline	add_bounce_entropy(game, ball);\newline\newline	/* Recalculate the trajectory */\newline	switch(side) {\newline		case SIDE_RIGHT :\newline			ball-&gtdirection += (RAD90 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_LEFT :\newline			ball-&gtdirection += (RAD270 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_BOTTOM :\newline			ball-&gtdirection += (RAD180 - ball-&gtdirection) * 2.0; \newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_TOP :\newline			/*if(ball-&gtdirection &gt RAD180)\newline				ball-&gtdirection -= ball-&gtdirection * 2.0;\newline			else*/\newline				ball-&gtdirection += (RAD360 - ball-&gtdirection) * 2.0;\newline			ball-&gtdirection += RAD180;\newline			break;\newline		case SIDE_DIAGONAL :\newline			ball-&gtdirection += RAD180;\newline			break;\newline		default :\newline			g_assert_not_reached();\newline	}\newline\newline	/* Make sure the ball hasn&#039t been bounced the wrong way */\newline	while(ball-&gtdirection &gt RAD360)\newline		ball-&gtdirection -= RAD360;\newline\newline	while(ball-&gtdirection &lt 0)\newline		ball-&gtdirection += RAD360;\newline\newline	/* And move it an extra step, so that the ball doesn&#039t appear inside\newline	 * the block when we refresh */\newline	move_ball(ball);\newline}\newline","Changes a balls trajectory depending on which side of an object it hit. \newline","2010218","esolver.c","static void usage (char *s)\newline{\newline	fprintf (stderr, &quotUsage: %s [- below -] prob_file\\n&quot, s);\newline	fprintf (stderr, &quot   -b f  write basis to file f\\n&quot);\newline	fprintf (stderr, &quot   -B f  read initial basis from file f\\n&quot);\newline#if 0\newline	fprintf (stderr, &quot   -I    solve the MIP using BestBound\\n&quot);\newline	fprintf (stderr, &quot   -E    edit problem after solving initial version\\n&quot);\newline#endif\newline	fprintf (stderr, &quot   -L    input file is in lp format (default: mps)\\n&quot);\newline	fprintf (stderr, &quot   -O    write the final solution to the given file\\n&quot);\newline	fprintf (stderr, &quot         append .gz/.bz2 to the .sol extension to compress the file\\n&quot);\newline	fprintf (stderr, &quot   -p #  run primal simplex with pricing rule #\\n&quot);\newline	fprintf (stderr,\newline					 &quot         (%d-Dantzig, %d-Devex, %d-Steep (default), %d-Partial\\n&quot,\newline					 QS_PRICE_PDANTZIG, QS_PRICE_PDEVEX, QS_PRICE_PSTEEP,\newline					 QS_PRICE_PMULTPARTIAL);\newline	fprintf (stderr,\newline					 &quot   -P #  number of bits to use for the float representation (default: 128)\\n&quot);\newline	fprintf (stderr, &quot   -d #  run dual simplex with pricing rule #\\n&quot);\newline	fprintf (stderr, &quot         (%d-Dantzig, %d-Steep, %d-Partial, %d-Devex)\\n&quot,\newline					 QS_PRICE_DDANTZIG, QS_PRICE_DSTEEP, QS_PRICE_DMULTPARTIAL,\newline					 QS_PRICE_DDEVEX);\newline	fprintf (stderr, &quot   -S    do NOT scale the initial LP\\n&quot);\newline	fprintf (stderr, &quot   -v    print QSopt version number\\n&quot);\newline	fprintf (stderr, &quot   -R n  maximum running time allowed, default %lf\\n&quot,\newline						max_rtime);\newline	fprintf (stderr, &quot   -m n  maximum memory usage allowed, default %lu\\n&quot, \newline						memlimit);\newline}\newline","@brief Display options to the screen \newline","5583825","statement.c","static int statement_columns(lua_State *L) {\newline    statement_t *statement = (statement_t *)luaL_checkudata(L, 1, DBD_POSTGRESQL_STATEMENT);\newline\newline    int i;\newline    int num_columns;\newline    int d = 1;\newline\newline    if (!statement-&gtresult) {\newline        luaL_error(L, DBI_ERR_INVALID_STATEMENT);\newline        return 0;\newline    }\newline\newline    num_columns = PQnfields(statement-&gtresult);\newline    lua_newtable(L);\newline    for (i = 0; i &lt num_columns; i++) {\newline        const char *name = PQfname(statement-&gtresult, i);\newline\newline	LUA_PUSH_ARRAY_STRING(d, name);\newline    }\newline\newline    return 1;\newline}\newline","\newline column_names = statement:columns()\newline \newline","3964212","dgif_lib.c","static int DGifBufferedInput(FILE *File, GifByteType *Buf,\newline						      GifByteType *NextByte)\newline{\newline    if (Buf[0] == 0) {\newline	/* Needs to read the next buffer - this one is empty: */\newline	if (fread(Buf, 1, 1, File) != 1)\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	if (fread(&ampBuf[1], 1, Buf[0], File) != Buf[0])\newline	{\newline	    _GifError = D_GIF_ERR_READ_FAILED;\newline	    return GIF_ERROR;\newline	}\newline	*NextByte = Buf[1];\newline	Buf[1] = 2;	   /* We use now the second place as last char read! */\newline	Buf[0]--;\newline    }\newline    else {\newline	*NextByte = Buf[Buf[1]++];\newline	Buf[0]--;\newline    }\newline\newline    return GIF_OK;\newline}\newline","\newline This routines read one gif data block at a time and buffers it internally \newline so that the decompression routine could access it. \newline The routine returns the next byte from its internal buffer (or read next \newline block in if buffer empty) and returns GIF_OK if succesful. \newline \newline","4152762","btreplay.c","static inline void wait_iter_start(void)\newline{\newline	pthread_mutex_lock(&ampiter_start_mutex);\newline	while (iter_start == 0)\newline		pthread_cond_wait(&ampiter_start_cond, &ampiter_start_mutex);\newline	assert(1 &lt= iter_start &amp&amp iter_start &lt= nfiles);\newline	iter_start--;\newline	pthread_mutex_unlock(&ampiter_start_mutex);\newline}\newline","\newline wait_iter_start - Wait for an iteration to start \newline \newline This is /slightly/ different: we are waiting for a value to become\newline non-zero, and then we decrement it and go on. \newline \newline","201946","program.c","static int parseDrawbarRegistration (const char * drw,\newline				     unsigned int bar[],\newline				     const int    lineNumber,\newline				     const char * fileName) {\newline\newline  char msg[MESSAGEBUFFERSIZE];\newline  int bus = 0;\newline  const char * t = drw;\newline\newline  while (bus &lt 9) {\newline    if (*t == &#039\\0&#039) {\newline      sprintf (msg, &quotDrawbar registration incomplete &#039%s&#039&quot, drw);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline    if ((isspace (*t)) || (*t == &#039-&#039) || (*t == &#039_&#039)) {\newline      t++;\newline      continue;\newline    }\newline    if ((&#0390&#039 &lt= *t) &amp&amp (*t &lt= &#0398&#039)) {\newline      bar[bus] = *t - &#0390&#039;\newline      t++;\newline      bus++;\newline      continue;\newline    }\newline    else {\newline      sprintf (msg, &quotIllegal char in drawbar registration &#039%c&#039&quot, *t);\newline      return stateMessage (fileName, lineNumber, msg, -1);\newline    }\newline  }\newline\newline  return 0;\newline}\newline","\newline Parses a drawbar registration.\newline @param drw The drawbar registration string.\newline @param bar Array of intergers where the registration is stored.\newline @param lineNumber The linenumber in the input file.\newline @param fileName The name of the current input file.\newline \newline","6073226","rundiff.c","DiffInfo *blank_diff_info (void)\newline{\newline    Block *b;\newline    DiffInfo *di;\newline\newline    di = (DiffInfo *) calloc (1, sizeof (DiffInfo));\newline    di-&gtlongline = &quot  &quot;\newline    di-&gtmaxcols = strlen (di-&gtlongline);\newline    di-&gtstatus = 2;\newline\newline    b = (Block *) calloc (1, sizeof (Block));\newline    b-&gtselected = NEITHER;\newline    b-&gtarr[LEFT].type = b-&gtarr[RIGHT].type = SAME;\newline    b-&gtsline = 0;\newline    b-&gtssize = 1;\newline    b-&gtarr[LEFT].fline = b-&gtarr[RIGHT].fline = 0;\newline    b-&gtarr[LEFT].fsize = b-&gtarr[RIGHT].fsize = 1;\newline    b-&gtarr[LEFT].text = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].wtext = (char **) calloc (1, sizeof (char *));\newline    b-&gtarr[LEFT].tlen = (short *) calloc (1, sizeof (short));\newline    b-&gtarr[LEFT].text[0] = strdup (&quot  &quot);\newline    b-&gtarr[LEFT].tlen[0] = strlen (b-&gtarr[LEFT].text[0]);\newline\newline    b-&gtarr[RIGHT].text = NULL;\newline    b-&gtarr[RIGHT].wtext = NULL;\newline    b-&gtarr[RIGHT].tlen = NULL;\newline    di-&gtfirst = di-&gtlast = b;\newline    di-&gtlines = b-&gtsline + b-&gtssize;\newline    di-&gtflines[LEFT] = b-&gtarr[LEFT].fline + b-&gtarr[LEFT].fsize;\newline    di-&gtflines[RIGHT] = b-&gtarr[RIGHT].fline + b-&gtarr[RIGHT].fsize;\newline\newline    return (di);\newline}\newline","\newline build just enough of a DiffInfo structure so that routines that use \newline the data won&#039t be shocked. this is used to show a blank display \newline (no files loaded).\newline \newline","5921779","os2.c","static void cvt_path_to_correct_case(char *buf)\newline{\newline    char *fname = buf + 3;            /* point to first element. */\newline    char *ptr = strchr(fname, &#039\\\\&#039);  /* find end of first element. */\newline\newline    buf[0] = toupper(buf[0]);  /* capitalize drive letter. */\newline\newline    /*\newline     * Go through each path element, and enumerate its parent dir until\newline     *  a case-insensitive match is found. If one is (and it SHOULD be)\newline     *  then overwrite the original element with the correct case.\newline     * If there&#039s an error, or the path has vanished for some reason, it\newline     *  won&#039t hurt to have the original case, so we just keep going.\newline     */\newline    while (fname != NULL)\newline    {\newline        char spec[CCHMAXPATH];\newline        FILEFINDBUF3 fb;\newline        HDIR hdir = HDIR_CREATE;\newline        ULONG count = 1;\newline        APIRET rc;\newline\newline        *(fname - 1) = &#039\\0&#039;  /* isolate parent dir string. */\newline\newline        strcpy(spec, buf);      /* copy isolated parent dir... */\newline        strcat(spec, &quot\\\\*.*&quot);  /*  ...and add wildcard search spec. */\newline\newline        if (ptr != NULL)  /* isolate element to find (fname is the start). */\newline            *ptr = &#039\\0&#039;\newline\newline        rc = DosFindFirst(spec, &amphdir, FILE_DIRECTORY,\newline                          &ampfb, sizeof (fb), &ampcount, FIL_STANDARD);\newline        if (rc == NO_ERROR)\newline        {\newline            while (count == 1)  /* while still entries to enumerate... */\newline            {\newline                if (__PHYSFS_stricmpASCII(fb.achName, fname) == 0)\newline                {\newline                    strcpy(fname, fb.achName);\newline                    break;  /* there it is. Overwrite and stop searching. */\newline                } /* if */\newline\newline                DosFindNext(hdir, &ampfb, sizeof (fb), &ampcount);\newline            } /* while */\newline            DosFindClose(hdir);\newline        } /* if */\newline\newline        *(fname - 1) = &#039\\\\&#039;   /* unisolate parent dir. */\newline        fname = ptr;           /* point to next element. */\newline        if (ptr != NULL)\newline        {\newline            *ptr = &#039\\\\&#039;       /* unisolate element. */\newline            ptr = strchr(++fname, &#039\\\\&#039);  /* find next element. */\newline        } /* if */\newline    } /* while */\newline} /* cvt_file_to_correct_case */\newline","(be gentle, this function isn&#039t very robust.) \newline","4586590","rnn_util.cpp","void rnn_predict_bonding_state(const string&amp config, \newline			       const string&amp model,\newline			       const string&amp input,\newline			       const string&amp output) {\newline  // get RNN option (unique) instance\newline  Options* rnn_option = Options::instance();\newline\newline  // set BRNN parameters from bonding state config file\newline  rnn_option-&gtparse_config(config);\newline  rnn_option-&gtsetParameter(&quotnetname&quot, model);\newline  \newline  // Create test set with only the given input \newline  DataSet *testset = new DataSet(input.c_str());\newline  if(!testset) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: failed dataset creation.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // initialize BRNN\newline  RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt* \newline    rnn = new RecursiveNN&ltTanH, Sigmoid, MGradientDescent&gt(model.c_str());\newline  if(!rnn) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable &quot\newline      &quotto read brnn file &quot &lt&lt model &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  // predict\newline  DataSet::iterator it=testset-&gtbegin(); // only one input chain\newline  vector&ltNode*&gt *nodes = it.currenTONodes();\newline  std::pair&ltDPAG, DPAG&gt *dpags = it.currentDPAGs();\newline  rnn-&gtpropagateStructuredInput(*nodes, *dpags);\newline\newline  // write predictions to output file\newline  ofstream ofs(output.c_str());\newline  if(!ofs) {\newline    cerr &lt&lt &quotbrnn_predict_bonding_state: unable to open file &quot\newline	 &lt&lt output &lt&lt &quot.\\n&quot;\newline    exit(1);\newline  }\newline\newline  for(std::vector&ltNode*&gt::iterator nit=nodes-&gtbegin(); \newline      nit!=nodes-&gtend(); ++nit) {\newline    float py1 = (*nit)-&gt_h_layers_activations[(*nit)-&gt_s-1][0];\newline    ofs &lt&lt (1-py1) &lt&lt &#039 &#039 &lt&lt py1 &lt&lt endl;\newline  }\newline  \newline  // deallocate Recursive Network structure\newline  delete rnn; rnn = 0;\newline  // deallocate dataset\newline  if(testset) { delete testset; testset = 0; }\newline}\newline","\newlinePredict bonding state with BRNN model.\newline \newline","286520","trace-kernel.c","struct ltt_kernel_event *trace_kernel_create_event(struct lttng_event *ev,\newline		char *filter_expression, struct lttng_filter_bytecode *filter)\newline{\newline	struct ltt_kernel_event *lke;\newline	struct lttng_kernel_event *attr;\newline\newline	assert(ev);\newline\newline	lke = zmalloc(sizeof(struct ltt_kernel_event));\newline	attr = zmalloc(sizeof(struct lttng_kernel_event));\newline	if (lke == NULL || attr == NULL) {\newline		PERROR(&quotkernel event zmalloc&quot);\newline		goto error;\newline	}\newline\newline	switch (ev-&gttype) {\newline	case LTTNG_EVENT_PROBE:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KPROBE;\newline		attr-&gtu.kprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_KRETPROBE;\newline		attr-&gtu.kretprobe.addr = ev-&gtattr.probe.addr;\newline		attr-&gtu.kretprobe.offset = ev-&gtattr.probe.offset;\newline		strncpy(attr-&gtu.kretprobe.symbol_name,\newline				ev-&gtattr.probe.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.kretprobe.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_FUNCTION_ENTRY:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_FUNCTION;\newline		strncpy(attr-&gtu.ftrace.symbol_name,\newline				ev-&gtattr.ftrace.symbol_name, LTTNG_KERNEL_SYM_NAME_LEN);\newline		attr-&gtu.ftrace.symbol_name[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline		break;\newline	case LTTNG_EVENT_TRACEPOINT:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_TRACEPOINT;\newline		break;\newline	case LTTNG_EVENT_SYSCALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_SYSCALL;\newline		break;\newline	case LTTNG_EVENT_ALL:\newline		attr-&gtinstrumentation = LTTNG_KERNEL_ALL;\newline		break;\newline	default:\newline		ERR(&quotUnknown kernel instrumentation type (%d)&quot, ev-&gttype);\newline		goto error;\newline	}\newline\newline	/* Copy event name */\newline	strncpy(attr-&gtname, ev-&gtname, LTTNG_KERNEL_SYM_NAME_LEN);\newline	attr-&gtname[LTTNG_KERNEL_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline\newline	/* Setting up a kernel event */\newline	lke-&gtfd = -1;\newline	lke-&gtevent = attr;\newline	lke-&gtenabled = 1;\newline	lke-&gtfilter_expression = filter_expression;\newline	lke-&gtfilter = filter;\newline\newline	return lke;\newline\newlineerror:\newline	free(filter_expression);\newline	free(filter);\newline	free(lke);\newline	free(attr);\newline	return NULL;\newline}\newline","\newline Allocate and initialize a kernel event. Set name and event type.\newline We own filter_expression, and filter.\newline \newline Return pointer to structure or NULL.\newline \newline","2083110","output.c","static unsigned count_move_list_ply(Move *move_list, Boolean count_variations)\newline{\newline    unsigned count = 0;\newline    while(move_list != NULL) {\newline        count += count_single_move_ply(move_list, count_variations);\newline	move_list = move_list-&gtnext;\newline    }\newline    return count;\newline}\newline","\newline Count how many plies in the game in total.\newline Include variations if count_variations.\newline \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Load an image from the named file. Return an OpenGL texture object.","Create a bunch of tasks","Changes a balls trajectory depending on which side","Display options to the screen","column_names","returns GIF_OK if succesful.","Wait for an iteration to start","Parses a drawbar registration.","used to show a blank display","this function isn't very robust.)","Predict bonding state with BRNN model.","deals with the exclusive or operator when right-handoperand","Allocate and initialize a kernel event.","Count how many plies in the game in total.","should call setIntegerParseOnly(TRUE)","Traverse args, and copy the non-numeral exprs to result,","Get pointers to RRset members and signature(s) for same.","Decode DCS to sms fields","Open a stream for incoming and outgoing data","Search for ATI card on PCI bus","Find an event using the name and signature in the given registry."