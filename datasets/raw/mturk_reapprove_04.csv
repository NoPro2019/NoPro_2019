HITId,HITTypeId,Title,Description,Keywords,Reward,CreationTime,MaxAssignments,RequesterAnnotation,AssignmentDurationInSeconds,AutoApprovalDelayInSeconds,Expiration,NumberOfSimilarHITs,LifetimeInSeconds,AssignmentId,WorkerId,AssignmentStatus,AcceptTime,SubmitTime,AutoApprovalTime,ApprovalTime,RejectionTime,RequesterFeedback,WorkTimeInSeconds,LifetimeApprovalRate,Last30DaysApprovalRate,Last7DaysApprovalRate,Input.fid_1,Input.file_name_1,Input.function_body_1,Input.comment_body_1,Input.fid_2,Input.file_name_2,Input.function_body_2,Input.comment_body_2,Input.fid_3,Input.file_name_3,Input.function_body_3,Input.comment_body_3,Input.fid_4,Input.file_name_4,Input.function_body_4,Input.comment_body_4,Input.fid_5,Input.file_name_5,Input.function_body_5,Input.comment_body_5,Input.fid_6,Input.file_name_6,Input.function_body_6,Input.comment_body_6,Input.fid_7,Input.file_name_7,Input.function_body_7,Input.comment_body_7,Input.fid_8,Input.file_name_8,Input.function_body_8,Input.comment_body_8,Input.fid_9,Input.file_name_9,Input.function_body_9,Input.comment_body_9,Input.fid_10,Input.file_name_10,Input.function_body_10,Input.comment_body_10,Input.fid_11,Input.file_name_11,Input.function_body_11,Input.comment_body_11,Input.fid_12,Input.file_name_12,Input.function_body_12,Input.comment_body_12,Input.fid_13,Input.file_name_13,Input.function_body_13,Input.comment_body_13,Input.fid_14,Input.file_name_14,Input.function_body_14,Input.comment_body_14,Input.fid_15,Input.file_name_15,Input.function_body_15,Input.comment_body_15,Input.fid_16,Input.file_name_16,Input.function_body_16,Input.comment_body_16,Input.fid_17,Input.file_name_17,Input.function_body_17,Input.comment_body_17,Input.fid_18,Input.file_name_18,Input.function_body_18,Input.comment_body_18,Input.fid_19,Input.file_name_19,Input.function_body_19,Input.comment_body_19,Input.fid_20,Input.file_name_20,Input.function_body_20,Input.comment_body_20,Input.fid_21,Input.file_name_21,Input.function_body_21,Input.comment_body_21,Answer.empty_1,Answer.empty_10,Answer.empty_11,Answer.empty_12,Answer.empty_13,Answer.empty_14,Answer.empty_15,Answer.empty_16,Answer.empty_17,Answer.empty_18,Answer.empty_19,Answer.empty_2,Answer.empty_20,Answer.empty_21,Answer.empty_3,Answer.empty_4,Answer.empty_5,Answer.empty_6,Answer.empty_7,Answer.empty_8,Answer.empty_9,Answer.multiple_1,Answer.multiple_10,Answer.multiple_11,Answer.multiple_12,Answer.multiple_13,Answer.multiple_14,Answer.multiple_15,Answer.multiple_16,Answer.multiple_17,Answer.multiple_18,Answer.multiple_19,Answer.multiple_2,Answer.multiple_20,Answer.multiple_21,Answer.multiple_3,Answer.multiple_4,Answer.multiple_5,Answer.multiple_6,Answer.multiple_7,Answer.multiple_8,Answer.multiple_9,Answer.tag_1,Answer.tag_10,Answer.tag_11,Answer.tag_12,Answer.tag_13,Answer.tag_14,Answer.tag_15,Answer.tag_16,Answer.tag_17,Answer.tag_18,Answer.tag_19,Answer.tag_2,Answer.tag_20,Answer.tag_21,Answer.tag_3,Answer.tag_4,Answer.tag_5,Answer.tag_6,Answer.tag_7,Answer.tag_8,Answer.tag_9,Approve,Reject
3KL228NDMVM6DKMB6TPCUBTAUDEKG3,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:14 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:14 PDT 2019,,,3SBEHTYCWN3HG0EGQYV7DEHQP00IYT,AITP2LUW8GPB,Submitted,Fri Apr 26 12:54:02 PDT 2019,Fri Apr 26 13:31:45 PDT 2019,Sun Apr 28 13:31:45 PDT 2019,,,,2263,100% (62/62),100% (62/62),0% (0/0),2560644,license_gen.c,"static void encode_int(unsigned char *to, unsigned int from)\newline{\newline    to[3] = from &amp 0xFF;\newline    from &gt&gt= 8;\newline    to[2] = from &amp 0xFF;\newline    from &gt&gt= 8;\newline    to[1] = from &amp 0xFF;\newline    from &gt&gt= 8;\newline    to[0] = from &amp 0xFF;\newline}\newline",Big-endian \newline,4581656,decode.c,"u32 fetch_data_long_abs(sel_t *seg, u32 ofs)\newline{\newline  u32 val;\newline\newline  check_data_access(seg, ofs, 4);\newline\newline  decode_memio(seg-&gtbase + ofs, &ampval, X86EMU_MEMIO_32 + X86EMU_MEMIO_R);\newline\newline  return val;\newline}\newline",\newlinePARAMETERS:\newlinesegment - Segment to load data from\newlineoffset - Offset to load data from\newlineRETURNS:\newlineLong value read from the absolute memory location.\newline \newline,245045,audio_analyzer.c,"int PaQa_SaveRecordingToWaveFile( PaQaRecording *recording, const char *filename )\newline{\newline    WAV_Writer writer;\newline    int result = 0;\newline#define NUM_SAMPLES  (200)\newline    short data[NUM_SAMPLES];\newline	const int samplesPerFrame = 1;\newline    int numLeft = recording-&gtnumFrames;\newline	float *buffer = &amprecording-&gtbuffer[0];\newline\newline    result =  Audio_WAV_OpenWriter( &ampwriter, filename, recording-&gtsampleRate, samplesPerFrame );\newline    if( result &lt 0 ) goto error;\newline	\newline	while( numLeft &gt 0 )\newline    {\newline		int i;\newline        int numToSave = (numLeft &gt NUM_SAMPLES) ? NUM_SAMPLES : numLeft;\newline		// Convert double samples to shorts.\newline		for( i=0; i&ltnumToSave; i++ )\newline		{\newline			double fval = *buffer++;\newline			// Convert float to int and clip to short range.\newline			int ival = fval * 32768.0;\newline			if( ival &gt 32767 ) ival = 32767;\newline			else if( ival &lt -32768 ) ival = -32768;\newline			data[i] = ival;\newline		}\newline		result =  Audio_WAV_WriteShorts( &ampwriter, data, numToSave );\newline        if( result &lt 0 ) goto error;\newline		numLeft -= numToSave;\newline    }\newline	\newline    result =  Audio_WAV_CloseWriter( &ampwriter );\newline    if( result &lt 0 ) goto error;\newline	\newline    return 0;\newline	\newlineerror:\newline    printf(&quotERROR: result = %d\\n&quot, result );\newline    return result;\newline#undef NUM_SAMPLES\newline}\newline",\newline Write recording to WAV file.\newline \newline,1003750,lusol1.h,"void LU1MXR(LUSOLrec *LUSOL, int K1, int K2, int IX[], REAL AMAXR[])\newline{\newline#define FastMXR\newline#ifdef FastMXR\newline  static int  I, *J, *IC, K, LC, LC1, LC2, LR, LR1, LR2;\newline  static REAL AMAX;\newline#else\newline  int  I, J, K, LC, LC1, LC2, LR, LR1, LR2;\newline  REAL AMAX;\newline#endif\newline\newline  for(K = K1; K &lt= K2; K++) {\newline    AMAX = ZERO;\newline    I = IX[K];\newline/*      Find largest element in row i. */\newline    LR1 = LUSOL-&gtlocr[I];\newline    LR2 = (LR1+LUSOL-&gtlenr[I])-1;\newline#ifdef FastMXR\newline    for(LR = LR1, J = LUSOL-&gtindr + LR1;\newline        LR &lt= LR2; LR++, J++) {\newline/*      Find where  aij  is in column  j. */\newline      LC1 = LUSOL-&gtlocc[*J];\newline      LC2 = LC1+LUSOL-&gtlenc[*J];\newline      for(LC = LC1, IC = LUSOL-&gtindc + LC1;\newline          LC &lt LC2; LC++, IC++) {\newline        if(*IC==I)\newline          break;\newline      }\newline      SETMAX(AMAX,fabs(LUSOL-&gta[LC]));\newline    }\newline#else\newline    for(LR = LR1; LR &lt= LR2; LR++) {\newline      J = LUSOL-&gtindr[LR];\newline/*      Find where  aij  is in column  j. */\newline      LC1 = LUSOL-&gtlocc[J];\newline      LC2 = (LC1+LUSOL-&gtlenc[J])-1;\newline      for(LC = LC1; LC &lt= LC2; LC++) {\newline        if(LUSOL-&gtindc[LC]==I)\newline          break;\newline      }\newline      SETMAX(AMAX,fabs(LUSOL-&gta[LC]));\newline    }\newline#endif\newline    AMAXR[I] = AMAX;\newline  }\newline}\newline","==================================================================\newlinelu1mxr finds the largest element in each of row ip(k1:k2)\newlineand stores it in Amaxr( ). The nonzeros are stored column-wise\newlinein (a,indc,lenc,locc) and their structure is row-wise\newlinein ( indr,lenr,locr).\newlineIf k1 &gt k2, nothing happens.\newline------------------------------------------------------------------\newline11 Jun 2002: First version of lu1mxr.\newlineAllow for empty columns.\newline================================================================== \newline",6249278,index.c,"static dictWord *dict_add_word_to_list (\newline   lst_List l,\newline   const dictDatabase *database,\newline   const dictIndex *dbindex,\newline   const char *pt)\newline{\newline   dictWord * datum;\newline\newline   assert (l);\newline\newline   if (define_or_match){\newline      if (_dict_daemon_limit_defs\newline	  &amp&amp lst_length (l) &gt= _dict_daemon_limit_defs)\newline	 return NULL;\newline   }else{\newline      if (_dict_daemon_limit_matches\newline	  &amp&amp lst_length (l) &gt= _dict_daemon_limit_matches)\newline	 return NULL;\newline   }\newline\newline   datum = dict_word_create (pt, database, dbindex);\newline   lst_append (l, datum);\newline   return datum;\newline}\newline",returns NULL if limits exceeded \newline,264724,stickynotes_callbacks.c,"void properties_font_cb (GtkWidget *button, StickyNote *note)\newline{\newline	const char *font_str = gtk_font_button_get_font_name (GTK_FONT_BUTTON (button));\newline	stickynote_set_font(note, font_str, TRUE);\newline}\newline",Properties Dialog Callback : Font \newline,700028,kbuffer-parse.c,"void *kbuffer_read_at_offset(struct kbuffer *kbuf, int offset,\newline			     unsigned long long *ts)\newline{\newline	void *data;\newline\newline	if (offset &lt kbuf-&gtstart)\newline		offset = 0;\newline	else\newline		offset -= kbuf-&gtstart;\newline\newline	/* Reset the buffer */\newline	kbuffer_load_subbuffer(kbuf, kbuf-&gtsubbuffer);\newline\newline	while (kbuf-&gtcurr &lt offset) {\newline		data = kbuffer_next_event(kbuf, ts);\newline		if (!data)\newline			break;\newline	}\newline\newline	return data;\newline}\newline","\newline kbuffer_read_at_offset - read the event that is at offset\newline @kbuf: The kbuffer to read from\newline @offset: The offset into the subbuffer\newline @ts: The address to store the timestamp of the event (may be NULL to ignore)\newline \newline The @offset must be an index from the @kbuf subbuffer beginning.\newline If @offset is bigger than the stored subbuffer, NULL will be returned.\newline \newline Returns the data of the record that is at @offset. Note, @offset does\newline not need to be the start of the record, the offset just needs to be\newline in the record (or beginning of it).\newline \newline Note, the kbuf timestamp and pointers are updated to the\newline returned record. That is, kbuffer_read_event() will return the same\newline data and timestamp, and kbuffer_next_event() will increment from\newline this record.\newline \newline",3100939,sym53c8xx.c,const char *sym53c8xx_info (struct Scsi_Host *host)\newline{\newline	return SCSI_NCR_DRIVER_NAME;\newline}\newline,\newline Linux entry point for info() function\newline \newline,4206588,parsers.c,"static jb_err crunch_client_header(struct client_state *csp, char **header)\newline{\newline   const char *crunch_pattern;\newline\newline   /* Do we feel like crunching? */\newline   if ((csp-&gtaction-&gtflags &amp ACTION_CRUNCH_CLIENT_HEADER))\newline   {\newline      crunch_pattern = csp-&gtaction-&gtstring[ACTION_STRING_CLIENT_HEADER];\newline\newline      /* Is the current header the lucky one? */\newline      if (strstr(*header, crunch_pattern))\newline      {\newline         log_error(LOG_LEVEL_HEADER, &quotCrunching client header: %s (contains: %s)&quot, *header, crunch_pattern);\newline         freez(*header);\newline      }\newline   }\newline   return JB_ERR_OK;\newline}\newline","\newline \newline Function : crunch_client_header\newline \newline Description : Crunch client header if it matches a string supplied by the\newline user. Called from `sed&#039.\newline \newline Parameters :\newline 1 : csp = Current client state (buffers, headers, etc...)\newline 2 : header = On input, pointer to header to modify.\newline On output, pointer to the modified header, or NULL\newline to remove the header. This function frees the\newline original string if necessary.\newline \newline Returns : JB_ERR_OK on success and always succeeds\newline \newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,893001,script_functions.c,"int c_make_always_on_top(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 0) {\newline		luaL_error(lua, &quotmake_always_on_top: %s&quot, no_indata_expected_error);\newline		return 0;\newline	}\newline\newline	if (!devilspie2_emulate) {\newline		WnckWindow *window = get_current_window();\newline\newline		if (window) {\newline			wnck_window_make_above(window);\newline		}\newline	}\newline\newline	return 0;\newline}\newline",\newline Sets the window on top of all others and locks it &quotalways on top&quot\newline \newline,6615106,digitemp.c,"int read_temperature( int sensor_family, int sensor )\newline{\newline  char    temp[1024];              /* For output string                    */\newline  unsigned char lastcrc8,\newline                scratchpad[30],    /* Scratchpad block from the sensor     */\newline                TempSN[8];\newline  int     j,\newline          try,                     /* Number of tries at reading device    */\newline          ds1820_try,              /* Allow ds1820 glitch 1 time           */\newline          ds18s20_try;             /* Allow DS18S20 error 1 time           */\newline  float   temp_c,                  /* Calculated temperature in Centigrade */\newline          hi_precision;\newline\newline  ds1820_try = 0;\newline  ds18s20_try = 0;  \newline  temp_c = 0;\newline  \newline  for( try = 0; try &lt MAX_READ_TRIES; try++ )\newline  {\newline    if( owAccess(0) )\newline    {\newline      /* Convert Temperature */\newline      if( !owWriteBytePower( 0, 0x44 ) )\newline      {\newline        return FALSE;\newline      }\newline\newline      /* Sleep for conversion second */\newline      msDelay( read_time );\newline      \newline      /* Turn off the strong pullup */\newline      owLevel( 0, MODE_NORMAL );\newline\newline      /* Now read the scratchpad from the device */\newline      if( owAccess(0) )\newline      {\newline/* Use Read_Scratchpad instead? */\newline        /* Build a block for the Scratchpad read */\newline        scratchpad[0] = 0xBE;\newline        for( j = 1; j &lt 10; j++ )\newline          scratchpad[j] = 0xFF;\newline\newline        /* Send the block */\newline        if( owBlock( 0, FALSE, scratchpad, 10 ) )\newline        {\newline          /* Calculate the CRC 8 checksum on the received data */\newline          setcrc8(0, 0);\newline          for( j = 1; j &lt 10; j++ )\newline            lastcrc8 = docrc8( 0, scratchpad[j] );\newline\newline          /* If the CRC8 is valid then calculate the temperature */\newline          if( lastcrc8 == 0x00 )\newline          {\newline            /* DS1822 and DS18B20 use a different calculation */\newline            if( (sensor_family == DS18B20_FAMILY) ||\newline                (sensor_family == DS1822_FAMILY) ||\newline                (sensor_family == DS28EA00_FAMILY) ||\newline                (sensor_family == DS1923_FAMILY) )\newline            {\newline              short int temp2 = (scratchpad[2] &lt&lt 8) | scratchpad[1];\newline              temp_c = temp2 / 16.0;\newline            }\newline\newline            /* Handle the DS1820 and DS18S20 */\newline            if( sensor_family == DS1820_FAMILY )\newline            {\newline              /* Check for DS1820 glitch condition */\newline              /* COUNT_PER_C - COUNT_REMAIN == 1 */\newline              if( ds1820_try == 0 )\newline              {\newline                if( (scratchpad[7] - scratchpad[6]) == 1 )\newline                {\newline                  ds1820_try = 1;\newline                  continue;\newline                } /* DS1820 error */\newline              } /* ds1820_try */\newline            \newline              /* Check for DS18S20 Error condition */\newline              /*  LSB = 0xAA\newline                  MSB = 0x00\newline                  COUNT_REMAIN = 0x0C\newline                  COUNT_PER_C = 0x10\newline              */\newline              if( ds18s20_try == 0 )\newline              {\newline                if( (scratchpad[4]==0xAA) &amp&amp\newline                    (scratchpad[3]==0x00) &amp&amp\newline                    (scratchpad[7]==0x0C) &amp&amp\newline                    (scratchpad[8]==0x10)\newline                  )\newline                {\newline                  ds18s20_try = 1;\newline                  continue;\newline                } /* DS18S20 error condition */\newline              } /* ds18s20_try */\newline          \newline              /* Convert data to temperature */\newline              if( scratchpad[2] == 0 )\newline              {\newline                temp_c = (int) scratchpad[1] &gt&gt 1;\newline              } else {\newline                temp_c = -1 * (int) (0x100-scratchpad[1]) &gt&gt 1;\newline              } /* Negative temp calculation */\newline              temp_c -= 0.25;\newline              hi_precision = (int) scratchpad[8] - (int) scratchpad[7];\newline              hi_precision = hi_precision / (int) scratchpad[8];\newline              temp_c = temp_c + hi_precision;\newline            } /* DS1820_FAMILY */\newline            \newline            /* Log the temperature */\newline            switch( log_type )\newline            {\newline              /* Multiple Centigrade temps per line */\newline              case 2:     sprintf( temp, &quot\\t%3.2f&quot, temp_c );\newline                          log_string( temp );\newline                          break;\newline\newline              /* Multiple Fahrenheit temps per line */\newline              case 3:     sprintf( temp, &quot\\t%3.2f&quot, c2f(temp_c) );\newline                          log_string( temp );\newline                          break;\newline\newline              default:    owSerialNum( 0, &ampTempSN[0], TRUE );\newline                          log_temp( sensor, temp_c, TempSN );\newline                          break;\newline            } /* switch( log_type ) */\newline\newline            /* Show the scratchpad if verbose is seelcted */\newline            if( opts &amp OPT_VERBOSE )\newline            {\newline              show_scratchpad( scratchpad, sensor_family );              \newline            } /* if OPT_VERBOSE */\newline\newline            /* Good conversion finished */\newline            return TRUE;\newline          } else {\newline            fprintf( stderr, &quotCRC Failed. CRC is %02X instead of 0x00\\n&quot, lastcrc8 );\newline\newline            if (try == MAX_READ_TRIES - 1)\newline            {\newline              /* need to output something (0,-,NaN?) to keep columns consistent */\newline              switch( log_type )\newline              {\newline            	/* Multiple Centigrade temps per line */\newline                case 2:\newline                 /* Multiple Fahrenheit temps per line */\newline                 case 3:     sprintf( temp, &quot\\t%3.2f&quot, (double) 0 );\newline                             log_string( temp );\newline                             break;\newline             \newline                 default:\newline                             break;\newline               } /* switch( log_type ) */\newline            } /* if tries == max_read_tries */\newline\newline            if( opts &amp OPT_VERBOSE )\newline            {\newline              show_scratchpad( scratchpad, sensor_family );              \newline            } /* if OPT_VERBOSE */\newline          } /* CRC 8 is OK */\newline        } /* Scratchpad Read */\newline      } /* owAccess failed */\newline    } /* owAccess failed */\newline    \newline    /* Failed to read, rest the network, delay and try again */\newline    owTouchReset(0);\newline    msDelay( read_time );\newline  } /* for try &lt 3 */\newline  \newline  /* Failed, no good reads after MAX_READ_TRIES */\newline  return FALSE;\newline}\newline","-----------------------------------------------------------------------\newlineRead the temperature from one sensor\newlineReturn the high-precision temperature value\newlineCalculated using formula from DS1820 datasheet\newlineTemperature = scratchpad[1]\newlineSign = scratchpad[2]\newlineTH = scratchpad[3]\newlineTL = scratchpad[4]\newlineCount Remain = scratchpad[7]\newlineCount Per C = scratchpad[8]\newlineCRC = scratchpad[9]\newline\newlinecount_per_C - count_remain\newline(temp - 0.25) --------------------------\newlinecount_per_C\newlineIf Sign is not 0x00 then it is a negative (Centigrade) number, and\newlinethe temperature must be subtracted from 0x100 and multiplied by -1\newline----------------------------------------------------------------------- \newline",5024468,buf.c,"struct Buf *buf_strnappend (struct Buf *buf, const char *str, int n)\newline{\newline	buf_append (buf, str, n + 1);\newline\newline	/* &quotundo&quot the &#039\\0&#039 character that buf_append() already copied. */\newline	buf-&gtnelts--;\newline\newline	return buf;\newline}\newline",Appends n characters in str to buf. \newline,263597,graylcd.c,"static void tmr_screen_update(TilemCalc *calc, void *data)\newline{\newline	TilemGrayLCD *glcd = data;\newline	byte *np, *op, nb, ob, d;\newline	int i, j, n;\newline	dword delta;\newline\newline	glcd-&gtt++;\newline\newline	if (calc-&gtz80.lastlcdwrite == glcd-&gtlcdupdatetime)\newline		return;\newline	glcd-&gtlcdupdatetime = calc-&gtz80.lastlcdwrite;\newline\newline	(*calc-&gthw.get_lcd)(calc, glcd-&gtnewbits);\newline\newline	np = glcd-&gtnewbits;\newline	op = glcd-&gtoldbits;\newline	glcd-&gtoldbits = np;\newline	glcd-&gtnewbits = op;\newline	n = 0;\newline\newline	for (i = 0; i &lt glcd-&gtbwidth * glcd-&gtheight; i++) {\newline		nb = *np;\newline		ob = *op;\newline		d = nb ^ ob;\newline		for (j = 0; j &lt 8; j++) {\newline			if (d &amp (0x80 &gt&gt j)) {\newline				delta = glcd-&gtt - glcd-&gttchange[n];\newline				glcd-&gttchange[n] = glcd-&gtt;\newline\newline				if (ob &amp (0x80 &gt&gt j)) {\newline					glcd-&gtcurpixels[n].ndark += delta;\newline					glcd-&gtcurpixels[n].ndarkseg++;\newline				}\newline				else {\newline					glcd-&gtcurpixels[n].nlight += delta;\newline					glcd-&gtcurpixels[n].nlightseg++;\newline				}\newline			}\newline			n++;\newline		}\newline\newline		np++;\newline		op++;\newline	}\newline}\newline",Read screen contents and update pixels that have changed \newline,6344523,yasaraformat.cpp,"void storeint32le(char *data,int32 value)\newline{ int i;\newline\newline  for (i=0;i&lt4;i++) data[i]=(value&gt&gt(i*8))&amp255; }\newline",STORE AN INT32 IN LITTLE ENDIAN FORMAT\newline====================================== \newline,5611490,blur.c,"LIQ_PRIVATE void liq_max3(unsigned char *src, unsigned char *dst, unsigned int width, unsigned int height)\newline{\newline    for(unsigned int j=0; j &lt height; j++) {\newline        const unsigned char *row = src + j*width,\newline        *prevrow = src + (j &gt 1 ? j-1 : 0)*width,\newline        *nextrow = src + MIN(height-1,j+1)*width;\newline\newline        unsigned char prev,curr=row[0],next=row[0];\newline\newline        for(unsigned int i=0; i &lt width-1; i++) {\newline            prev=curr;\newline            curr=next;\newline            next=row[i+1];\newline\newline            unsigned char t1 = MAX(prev,next);\newline            unsigned char t2 = MAX(nextrow[i],prevrow[i]);\newline            *dst++ = MAX(curr,MAX(t1,t2));\newline        }\newline        unsigned char t1 = MAX(curr,next);\newline        unsigned char t2 = MAX(nextrow[width-1],prevrow[width-1]);\newline        *dst++ = MAX(t1,t2);\newline    }\newline}\newline",\newline Picks maximum of neighboring pixels (blur + lighten)\newline \newline,287207,add_context.c,"static void print_ctx_type(FILE *ofp)\newline{\newline	int i = 0;\newline\newline	while (ctx_opts[i].symbol != NULL) {\newline		if (!ctx_opts[i].hide_help) {\newline			fprintf(ofp, &quot%s\\n&quot, ctx_opts[i].symbol);\newline		}\newline		i++;\newline	}\newline}\newline",\newline Pretty print context type.\newline \newline,897362,ospusageind.c,const char *OSPPUsageIndGetDestNumber(\newline    OSPT_USAGE_IND *ospvUsageInd)   /* usage ind */\newline{\newline    const char *num = OSPC_OSNULL;\newline\newline    if (ospvUsageInd != OSPC_OSNULL) {\newline        num = ospvUsageInd-&gtDestinationNumber;\newline    }\newline\newline    return num;\newline}\newline,\newline OSPPUsageIndGetDestNumber() - returns the destination number for a usage ind\newline \newline,897042,ospfail.c,"void OSPPSetTermCause(  /* nothing returned */\newline    OSPT_TERM_CAUSE *ospvTermCause,\newline    OSPE_TERM_CAUSE ospvType,\newline    unsigned ospvTCCode,\newline    const char *ospvTCDesc)\newline{\newline    if (ospvTermCause != OSPC_OSNULL) {\newline        if ((ospvType &gt= OSPC_TCAUSE_START) &amp&amp (ospvType &lt OSPC_TCAUSE_NUMBER)) {\newline            ospvTermCause-&gttccode[ospvType] = ospvTCCode;\newline            if ((ospvTCDesc != OSPC_OSNULL) &amp&amp (ospvTCDesc[0] != &#039\\0&#039)) {\newline                OSPM_STRNCPY(ospvTermCause-&gttcdesc[ospvType], ospvTCDesc, sizeof(ospvTermCause-&gttcdesc[ospvType]));\newline            }\newline            ospvTermCause-&gthastermcause[ospvType] = OSPC_TRUE;\newline        }\newline    }\newline}\newline",\newline OSPPSetTermCause() - Set termination cause\newline \newline,3432632,wsysdep.cpp,"static std::wstring parse_proxy(const std::wstring&amp input)\newline{\newline	if(input.find(&#039=&#039) == input.npos)\newline		return input;\newline\newline	std::vector&ltstd::wstring&gt parts;\newline	split(parts, input, boost::algorithm::is_any_of(&quot; \\t\\r\\n&quot), boost::algorithm::token_compress_on);\newline	\newline	for(size_t i = 0; i &lt parts.size(); ++i)\newline		if(boost::algorithm::starts_with(parts[i], &quothttp=&quot))\newline			return parts[i].substr(5);\newline	\newline	// If we got this far, proxies were only set for non-HTTP protocols\newline	return L&quot&quot;\newline}\newline","\newline Given a string of the form\newline &quotexample.com:80&quot\newline or\newline &quotftp=ftp.example.com:80;http=example.com:80;https=example.com:80&quot\newline separated by semicolons or whitespace,\newline return the string &quotexample.com:80&quot.\newline \newline",3185431,parse.c,"static void msg_parse__trimwhitespace(opts_t opts, msg_t msg)\newline{\newline	long rpos, wpos, words_alloced;\newline	int prevws;\newline	char *ptr;\newline\newline	msg-&gtnum_words = 0;\newline	words_alloced = 10000;\newline\newline	msg-&gtwordpos = calloc(words_alloced, sizeof(long));\newline	msg-&gtwordlength = calloc(words_alloced, sizeof(int));\newline\newline	for (rpos = 0, wpos = 0, prevws = 0; rpos &lt msg-&gttext_size; rpos++) {\newline		if ((msg-&gttextcontent[rpos] == &#039 &#039)\newline		    || (msg-&gttextcontent[rpos] == &#039\\r&#039)\newline		    || (msg-&gttextcontent[rpos] == &#039\\n&#039)\newline		    || (msg-&gttextcontent[rpos] == &#039\\t&#039)\newline		    ) {\newline			if (prevws)\newline				continue;\newline			prevws = 1;\newline			msg-&gttextcontent[wpos++] = &#039 &#039;\newline			if (msg-&gtnum_words &gt 0) {\newline				msg-&gtwordlength[msg-&gtnum_words - 1] =\newline				    (wpos - 1) -\newline				    msg-&gtwordpos[msg-&gtnum_words - 1];\newline			}\newline			continue;\newline		}\newline\newline		/*\newline		 * Non-whitespace. If it follows whitespace, or is the first\newline		 * character, add it to the word list.\newline		 */\newline		if ((wpos == 0) || (prevws)) {\newline\newline			/*\newline			 * First, make sure there&#039s room in the array; if\newline			 * not, extend the array.\newline			 */\newline			if (msg-&gtnum_words &gt= words_alloced - 1) {\newline				long *newwordpos;\newline				int *newwordlength;\newline\newline				words_alloced += 10000;\newline\newline				newwordpos = realloc(msg-&gtwordpos,	/* RATS: ignore */\newline						     words_alloced *\newline						     sizeof(long));\newline				if (newwordpos != NULL) {\newline					msg-&gtwordpos = newwordpos;\newline					newwordlength = realloc(msg-&gtwordlength,	/* RATS: ignore */\newline								words_alloced\newline								*\newline								sizeof\newline								(int));\newline					if (newwordlength != NULL) {\newline						msg-&gtwordlength =\newline						    newwordlength;\newline					} else {\newline						words_alloced -= 10000;\newline					}\newline				} else {\newline					words_alloced -= 10000;\newline				}\newline			}\newline\newline			/*\newline			 * Next, assuming the array can hold another entry\newline			 * (the above extension could have failed), add the\newline			 * word to the list. The word&#039s default length is\newline			 * set to the size of the remaining buffer.\newline			 */\newline\newline			if (msg-&gtnum_words &lt words_alloced - 1) {\newline				msg-&gtwordpos[msg-&gtnum_words] = wpos;\newline				msg-&gtwordlength[msg-&gtnum_words] =\newline				    msg-&gttext_size - rpos;\newline				msg-&gtnum_words++;\newline			}\newline		}\newline\newline		prevws = 0;\newline		msg-&gttextcontent[wpos++] = msg-&gttextcontent[rpos];\newline	}\newline\newline	msg-&gttext_size = wpos;\newline\newline	ptr = realloc(msg-&gttextcontent,	    /* RATS: ignore (not sensitive) */\newline		      msg-&gttext_size);\newline	if (ptr != NULL)\newline		msg-&gttextcontent = ptr;\newline\newline	return;\newline}\newline","\newline Trim the whitespace from msg-&gttextcontent, such that long runs of \\r,\newline space, tab, \\n, etc get truncated to a single space.\newline \newline Also fill in the wordpos[] and wordlength[] arrays, and count the number\newline of words.\newline \newline",on,,,on,,,on,,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,{},Load an image from the named file.,Sets the window on top of all others and locks,{},Appends n characters in str to buf.,Read screen contents and update pixels that have changed,{},Picks maximum of neighboring pixels (blur + lighten),{},returns the destination number for a usage ind,Set termination cause,Long value read from the absolute memory location.,{},"Trim the whitespace from msg->textcontent,",Write recording to WAV file.,lu1mxr finds the largest element in each of row ip(k1:k2),returns NULL if limits exceeded,Dialog Callback : Font,Returns the data of the record that is at @offset.,Linux entry point for info() function,"Crunch client header if it matches a string supplied by the
user.",x,
336OE47KI2KGQH6NK271INQF4ZBWV0,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:14 PDT 2019,2,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:14 PDT 2019,,,3C8HJ7UOP7U3H9EC7ZVIJEX9C45MZN,AITP2LUW8GPB,Submitted,Fri Apr 26 13:52:32 PDT 2019,Fri Apr 26 13:57:02 PDT 2019,Sun Apr 28 13:57:02 PDT 2019,,,,270,100% (62/62),100% (62/62),0% (0/0),1125019,cram.c,"static svn_error_t *fail(svn_ra_svn_conn_t *conn, apr_pool_t *pool,\newline                         const char *msg)\newline{\newline  SVN_ERR(svn_ra_svn__write_tuple(conn, pool, &quotw(c)&quot, &quotfailure&quot, msg));\newline  return svn_error_trace(svn_ra_svn__flush(conn, pool));\newline}\newline","Fail the authentication, from the server&#039s perspective. \newline",3923065,dicom_network.c,"static Acr_Status read_abort_rq(Acr_File *afp, Acr_Group group)\newline{\newline   unsigned char buffer[ABORT_RQ_LEN - PDU_HEADER_LEN];\newline   Acr_Status status;\newline\newline   /* Read in request header */\newline   status = acr_read_buffer(afp, buffer, sizeof(buffer), NULL);\newline   if (status != ACR_OK) return status;\newline\newline   /* Get values */\newline   SAVE_SHORT(group, DCM_PDU_Source, buffer[8 - PDU_HEADER_LEN]);\newline   SAVE_SHORT(group, DCM_PDU_Reason, buffer[9 - PDU_HEADER_LEN]);\newline\newline   return status;\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : read_abort_rq\newline@INPUT : afp - acr file pointer\newline@OUTPUT : group - group to which pdu information should be added\newline@RETURNS : status of input\newline@DESCRIPTION: Reads in an abort request\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : February 10, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline",4539887,emitter.c,"static unsigned int utf8_width(yaml_char_t* pointer, yaml_char_t* end)\newline{\newline    unsigned char octet = pointer[0];\newline    if (octet &lt 0x80) {\newline        /* 1-byte character */\newline        return 1;\newline    } else if (octet &lt 0xC2) {\newline        /* continuation byte or overlong 2-byte encoding */\newline        return 0;\newline    } else if (octet &lt 0xE0) {\newline        /* 2-byte character */\newline        if (end-pointer &lt 2) return 0;\newline        if ((pointer[1] &amp 0xC0) != 0x80) return 0;\newline        return 2;\newline    } else if (octet &lt 0xF0) {\newline        /* 3-byte character */\newline        if (end-pointer &lt 3) return 0;\newline        if (octet == 0xE0 &amp&amp pointer[1] &lt 0xA0) return 0; /* overlong */\newline        if ((pointer[1] &amp 0xC0) != 0x80) return 0;\newline        if ((pointer[2] &amp 0xC0) != 0x80) return 0;\newline        return 3;\newline    } else if (octet &lt 0xF5) {\newline        /* 4-byte character */\newline        if (end-pointer &lt 4) return 0;\newline        if (octet == 0xF0 &amp&amp pointer[1] &lt 0x90) return 0; /* overlong */\newline        if (octet == 0xF4 &amp&amp pointer[1] &gt 0x8F) return 0; /* &gt 0x10FFFF */\newline        if ((pointer[1] &amp 0xC0) != 0x80) return 0;\newline        if ((pointer[2] &amp 0xC0) != 0x80) return 0;\newline        if ((pointer[3] &amp 0xC0) != 0x80) return 0;\newline        return 4;\newline    } else {\newline        /* can never appear in UTF-8 */\newline        return 0;\newline    }\newline}\newline","\newlineReturn the number of bytes in the next UTF-8 character.\newlineReturns 0 for any error, includinge incorrect bytes, not enough\newlinebytes before the end pointer, and overlong encodings. If 0 is\newlinereturned, pointer[0] will always have the high bit set and will\newlinethus never match any ASCII character.\newlineThe encodings of surrogate halves are allowed! Otherwise it is not\newlinepossible to losslessly encode invalid UTF-16 into UTF-8. (There is\newlinea vocal contingent trying to sabotage UTF-8 by declaring surrogate\newlinehalf encodings invalid. Anybody such claim should be investigated\newlinecarefully: if that user&#039s code does not also reject invalid UTF-16,\newlinethen they are being hypocrites and can be ignored.)\newline \newline",3408590,io-read-data.c,"char *output_warning_msgs( int n_att, att_DS att, database_DS db, model_DS model)\newline{\newline  char *msg, caller[] = &quotoutput_warning_msgs&quot;\newline  fxlstr warning_msg;\newline  shortstr *att_ignore_ids = model-&gtatt_ignore_ids;\newline  int i, msg_length = 4 * sizeof(fxlstr);\newline  warn_err_DS errors = att-&gtwarnings_and_errors;\newline\newline  msg = (char *) malloc( msg_length);\newline  msg[0]=&#039\\0&#039;\newline\newline  if (strlen(errors-&gtunspecified_dummy_warning) != 0) \newline    safe_sprintf( msg, msg_length, caller,\newline                 &quotWARNING[2]: attribute #%d definition has not been specified --&quot\newline                  &quot type set to dummy\\n&quot, n_att);\newline  if (errors-&gtunused_translators_warning != NULL) { \newline    safe_sprintf( warning_msg, sizeof( warning_msg), caller, \newline                  &quotWARNING[2]: attribute #%d: \\&quot%s\\&quot\\n&quot, n_att, att-&gtdscrp); \newline    strcat(msg, warning_msg); \newline\newline    /* commented since defined translators are not implemented 03dec94 wmt */\newline    /*     length = 0; */\newline    /*     while( errors-&gtunused_translators_warning[length] &gt MOST_NEGATIVE_SINGLE_FLOAT) { */\newline    /*       strncat(msg, &quotNo occurrences observed for value %f\\n&quot, */\newline    /*               errors-&gtunused_translators_warning[length]); */\newline    /*       length++; */\newline    /*     } */\newline    /*     safe_sprintf(warning_msg, sizeof( warning_msg), caller, */\newline    /*             &quotTo improve sensitivity of classification, reduce range by %d\\n&quot, */\newline    /*             length); */\newline    /*     for (i=0; i&ltdb-&gtnum_tsp; i++) */\newline    /*       if (db-&gttranslations_supplied_p[i] == n_att) { */\newline    /*         strcat(warning_msg, */\newline    /*                &quotand redefine its translations to eliminate non-occurring entries\\n&quot); */\newline    /*         break; */\newline    /*       } */\newline    /* do this instead */\newline\newline    safe_sprintf( warning_msg, sizeof( warning_msg), caller, \newline                  &quot            to improve sensitivity of classification, reduce range to %d.\\n&quot,\newline                  (int) errors-&gtunused_translators_warning[0]); \newline    strcat(msg, warning_msg); \newline  } \newline  if (eqstring(att_ignore_ids[n_att], &quotmodel_term_not_specified&quot) == TRUE) {\newline    safe_sprintf( warning_msg, sizeof( warning_msg), caller,\newline                 &quotWARNING[3]: attribute #%d: \\&quot%s\\&quot\\n&quot, n_att, att-&gtdscrp);\newline    strcat( msg, warning_msg);\newline    strcat( msg,\newline           &quot            model term type has not been specified and is set to ignore\\n&quot);\newline  }\newline  if (errors-&gtmodel_expander_warnings != NULL)\newline    for (i=errors-&gtnum_expander_warnings-1; i&gt=0; i--) {\newline      safe_sprintf( warning_msg, sizeof( warning_msg), caller,\newline                   &quotWARNING[3]: attribute #%d: \\&quot%s\\&quot\\n&quot, n_att, att-&gtdscrp);\newline      strcat( msg, warning_msg);\newline      strcat( msg, errors-&gtmodel_expander_warnings[i]);\newline    }\newline  if (strlen(errors-&gtsingle_valued_warning) != 0) {\newline    safe_sprintf( warning_msg, sizeof( warning_msg), caller,\newline                 &quotWARNING[3]: attribute #%d: \\&quot%s\\&quot\\n&quot, n_att, att-&gtdscrp);\newline    strcat( msg, warning_msg);\newline    safe_sprintf( warning_msg, sizeof( warning_msg), caller,\newline            &quot            has only one unique value. Change model term type to ignore.\\n&quot);\newline    strcat( msg, warning_msg);\newline  }\newline  if ((int) strlen( msg) &gt (msg_length - 1)) {\newline    fprintf( stderr, &quotERROR: %s produced %d chars (max number is %d)\\n&quot,\newline            caller, (int) strlen( msg), (msg_length - 1));\newline    abort();\newline  }\newline  return (msg);\newline}\newline","OUTPUT_WARNING_MSGS\newline23mar92 - WMT - single-valued functionality changed from error to warning\newline-error slot retained for backward compatability to existing .results files \newline03dec94 wmt: changed unused_translators &amp single_valued errors \newline25may95 wmt: replaced sizeof(msg) with msg_length in first safe_sprintf\newline18feb98 wmt: for number of translators less than .hd2 range, reduce the\newlinerange and output advisory, rather than outputting warning -- REMOVED \newline13mar98 JCS due to incompatablility with previous results files\newlineformat all warning messages into returned string \newline \newline",4352393,n2builder.cpp,"Norm *Normalizer2DataBuilder::createNorm(UChar32 c) {\newline    uint32_t i=utrie2_get32(normTrie, c);\newline    if(i!=0) {\newline        return norms+i;\newline    } else {\newline        /* allocate Norm */\newline        Norm *p=allocNorm();\newline        IcuToolErrorCode errorCode(&quotgennorm2/createNorm()&quot);\newline        utrie2_set32(normTrie, c, (uint32_t)(p-norms), errorCode);\newline        return p;\newline    }\newline}\newline",\newline get or create a Norm unit;\newline get or create the intermediate trie entries for it as well\newline \newline,312160,xodtemplate.c,"int xodtemplate_resolve_hostgroup(xodtemplate_hostgroup *this_hostgroup) {\newline	char *temp_ptr = NULL;\newline	char *template_names = NULL;\newline	char *template_name_ptr = NULL;\newline	xodtemplate_hostgroup *template_hostgroup = NULL;\newline\newline	/* return if this hostgroup has already been resolved */\newline	if (this_hostgroup-&gthas_been_resolved == TRUE)\newline		return OK;\newline\newline	/* set the resolved flag */\newline	this_hostgroup-&gthas_been_resolved = TRUE;\newline\newline	/* return if we have no template */\newline	if (this_hostgroup-&gttemplate == NULL)\newline		return OK;\newline\newline	if ((template_names = (char *)strdup(this_hostgroup-&gttemplate)) == NULL)\newline		return ERROR;\newline\newline	/* apply all templates */\newline	template_name_ptr = template_names;\newline	for (temp_ptr = my_strsep(&amptemplate_name_ptr, &quot,&quot); temp_ptr != NULL; temp_ptr = my_strsep(&amptemplate_name_ptr, &quot,&quot)) {\newline\newline		/* strip whitespaces */\newline		strip(temp_ptr);\newline\newline		template_hostgroup = xodtemplate_find_hostgroup(temp_ptr);\newline		if (template_hostgroup == NULL) {\newline			logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Template &#039%s&#039 specified in hostgroup definition could not be found (config file &#039%s&#039, starting on line %d)\\n&quot, temp_ptr, xodtemplate_config_file_name(this_hostgroup-&gt_config_file), this_hostgroup-&gt_start_line);\newline			my_free(template_names);\newline			return ERROR;\newline		}\newline\newline		/* resolve the template hostgroup... */\newline		if (xodtemplate_resolve_hostgroup(template_hostgroup) == ERROR) {\newline			my_free(template_names);\newline			return ERROR;\newline		}\newline\newline		/* apply missing properties from template hostgroup... */\newline		if (this_hostgroup-&gthostgroup_name == NULL &amp&amp template_hostgroup-&gthostgroup_name != NULL)\newline			this_hostgroup-&gthostgroup_name = (char *)strdup(template_hostgroup-&gthostgroup_name);\newline		if (this_hostgroup-&gtalias == NULL &amp&amp template_hostgroup-&gtalias != NULL)\newline			this_hostgroup-&gtalias = (char *)strdup(template_hostgroup-&gtalias);\newline\newline		xodtemplate_get_inherited_string(&amptemplate_hostgroup-&gthave_members, &amptemplate_hostgroup-&gtmembers, &ampthis_hostgroup-&gthave_members, &ampthis_hostgroup-&gtmembers);\newline		xodtemplate_get_inherited_string(&amptemplate_hostgroup-&gthave_hostgroup_members, &amptemplate_hostgroup-&gthostgroup_members, &ampthis_hostgroup-&gthave_hostgroup_members, &ampthis_hostgroup-&gthostgroup_members);\newline\newline		if (this_hostgroup-&gthave_notes == FALSE &amp&amp template_hostgroup-&gthave_notes == TRUE) {\newline			if (this_hostgroup-&gtnotes == NULL &amp&amp template_hostgroup-&gtnotes != NULL)\newline				this_hostgroup-&gtnotes = (char *)strdup(template_hostgroup-&gtnotes);\newline			this_hostgroup-&gthave_notes = TRUE;\newline		}\newline		if (this_hostgroup-&gthave_notes_url == FALSE &amp&amp template_hostgroup-&gthave_notes_url == TRUE) {\newline			if (this_hostgroup-&gtnotes_url == NULL &amp&amp template_hostgroup-&gtnotes_url != NULL)\newline				this_hostgroup-&gtnotes_url = (char *)strdup(template_hostgroup-&gtnotes_url);\newline			this_hostgroup-&gthave_notes_url = TRUE;\newline		}\newline		if (this_hostgroup-&gthave_action_url == FALSE &amp&amp template_hostgroup-&gthave_action_url == TRUE) {\newline			if (this_hostgroup-&gtaction_url == NULL &amp&amp template_hostgroup-&gtaction_url != NULL)\newline				this_hostgroup-&gtaction_url = (char *)strdup(template_hostgroup-&gtaction_url);\newline			this_hostgroup-&gthave_action_url = TRUE;\newline		}\newline	}\newline\newline	my_free(template_names);\newline\newline	return OK;\newline}\newline",resolves a hostgroup object \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2815971,obj.c,static void clean_mustQ (dlq_hdr_t *mustQ)\newline{\newline    if ( !mustQ ) {\newline        return;\newline    }\newline\newline    while (!dlq_empty(mustQ)) {\newline        xpath_pcb_t *must = (xpath_pcb_t *)dlq_deque(mustQ);\newline        xpath_free_pcb(must);\newline    }\newline}  /* clean_mustQ */\newline,\newline Clean a Q of xpath_pcb_t entries\newline \newline \\param mustQ Q of ncx_errinfo_t to delete\newline \newline \newline,2643035,edge.c,"GtsFace * gts_edge_is_boundary (GtsEdge * e, GtsSurface * surface)\newline{\newline  GSList * i;\newline  GtsFace * f = NULL;\newline  \newline  g_return_val_if_fail (e != NULL, NULL);\newline  \newline  i = e-&gttriangles;\newline  while (i) {\newline    if (GTS_IS_FACE (i-&gtdata)) {\newline      if (!surface || gts_face_has_parent_surface (i-&gtdata, surface)) {\newline	if (f != NULL)\newline	  return NULL;\newline	f = i-&gtdata;\newline      }\newline    }\newline    i = i-&gtnext;    \newline  }\newline  return f;\newline}\newline",\newline gts_edge_is_boundary:\newline @e: a #GtsEdge.\newline @surface: a #GtsSurface or %NULL.\newline \newline Returns: the unique #GtsFace (which belongs to @surface) and which\newline has @e as an edge (i.e. @e is a boundary edge (of @surface)) or %NULL \newline if there is more than one or no faces (belonging to @surface) and\newline with @e as an edge.\newline \newline,4564638,safe_id_range_list.c,"int safe_parse_id_list(safe_id_range_list *list, const char *value)\newline{\newline    return parse_id_list(list, value, name_to_error);\newline}\newline",\newline safe_parse_id_list\newline Parse the value and store the ranges in the range list in the list\newline structure.\newline \newline The value is parsed as described in strto_id_list.\newline \newline It is an error if any of the ranges contain an error.\newline \newline It is an error if there is non-whitespace after the parsed value.\newline \newline On error errno is set to a non-zero value including EINVAL and ERANGE.\newline On success errno is set to 0.\newline parameters\newline list\newline a pointer to a range list to have the ranges parsed added\newline value\newline pointer to the beginning of the string to find the name or\newline number\newline returns\newline 0 on success\newline -1 on error\newline \newline,4678419,rea.c,"static void algInsertEdge(SmiNode *snode, SmiNode *enode, \newline			  SmiIndexkind indexkind,\newline			  GraphEnhIndex enhancedindex) \newline{\newline    GraphNode *startNode;\newline    GraphNode *endNode;\newline\newline    if (!graph) return;\newline\newline    startNode = graphGetNode(graph, snode);\newline    endNode   = graphGetNode(graph, enode);\newline\newline    /* insert imported nodes into graph if needed */\newline    if (startNode == NULL) {\newline	if (IGNORE_IMPORTED_NODES) return;\newline	\newline	startNode = graphInsertNode(graph, snode);\newline    }\newline    if (endNode == NULL) {\newline	if (IGNORE_IMPORTED_NODES) return;\newline	\newline	endNode = graphInsertNode(graph, enode);\newline    }  \newline\newline    if (graphCheckForRedundantEdge(graph, startNode, endNode) == 0 &amp&amp\newline	graphCheckForRedundantEdge(graph, endNode, startNode) == 0) {\newline	graphInsertEdge(graph, startNode, endNode, indexkind, enhancedindex); \newline    }\newline}\newline",\newline algInsertEdge\newline \newline Inserts an edge in a given graph. The edge is adjacent to snode \newline and enode.\newline The type of edge is given in indexkind and the enhanced index as\newline an additional information in enhancedindex.\newline Nodes which are not loaded yet into the node list of the graph\newline are added (nodes from imported MIBs).\newline \newline,3688002,spc.c,int spc_setup_drive(struct burn_drive *d)\newline{\newline	d-&gtgetcaps = spc_getcaps;\newline	d-&gtlock = spc_prevent;\newline	d-&gtunlock = spc_allow;\newline	d-&gtread_disc_info = spc_sense_write_params;\newline	d-&gtget_erase_progress = spc_get_erase_progress;\newline	d-&gttest_unit_ready = spc_test_unit_ready;\newline	d-&gtprobe_write_modes = spc_probe_write_modes;\newline	d-&gtsend_parameters = spc_select_error_params;\newline	d-&gtsend_write_parameters = spc_select_write_params;\newline	return 1;	\newline}\newline,ts A61021 : the spc specific part of sg.c:enumerate_common()\newline \newline,5179143,xml_node.c,"static VALUE attr(VALUE self, VALUE name)\newline{\newline  xmlNodePtr node;\newline  xmlAttrPtr prop;\newline  Data_Get_Struct(self, xmlNode, node);\newline  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));\newline\newline  if(! prop) return Qnil;\newline  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);\newline}\newline",\newline call-seq:\newline attribute(name)\newline \newline Get the attribute node with +name+\newline \newline,100423,tdb_index.c,"static uint64_t db_checksum(const tdb *db)\newline{\newline    XXH64_state_t hash_state;\newline    uint64_t data[] = {tdb_num_trails(db),\newline                       tdb_num_events(db),\newline                       tdb_num_fields(db),\newline                       tdb_min_timestamp(db),\newline                       tdb_max_timestamp(db),\newline                       tdb_version(db)};\newline    XXH64_reset(&amphash_state, 2016);\newline    XXH64_update(&amphash_state, data, sizeof(data));\newline    return XXH64_digest(&amphash_state);\newline}\newline",\newlineProduce a sanity check of a checksum that can be used to make sure that\newlinethe index matches with the db it was based on.\newline \newline,5853483,inflate.c,static int inflate_block(int *e)\newline{\newline  unsigned t;           /* block type */\newline  unsigned w;           /* current window position */\newline  register ulg b;       /* bit buffer */\newline  register unsigned k;  /* number of bits in bit buffer */\newline\newline\newline  /* make local bit buffer */\newline  b = bb;\newline  k = bk;\newline  w = wp;\newline\newline\newline  /* read in last block bit */\newline  NEEDBITS(1)\newline  *e = (int)b &amp 1;\newline  DUMPBITS(1)\newline\newline\newline  /* read in block type */\newline  NEEDBITS(2)\newline  t = (unsigned)b &amp 3;\newline  DUMPBITS(2)\newline\newline\newline  /* restore the global bit buffer */\newline  bb = b;\newline  bk = k;\newline\newline\newline  /* inflate that block type */\newline  if (t == 2)\newline    return inflate_dynamic();\newline  if (t == 0)\newline    return inflate_stored();\newline  if (t == 1)\newline    return inflate_fixed();\newline\newline\newline  /* bad block type */\newline  return 2;\newline}\newline,E is the last block flag \newline,6200968,dosgus.c,int gus_timer_base(int base)\newline{\newline	gus.timer_base = base;\newline	return 0;\newline}\newline,return value: zero if setup was success (default timebase = 100) \newline,5071486,parse.c,"static void ParseTitle(char **ss, byte *flags, byte *mask)\newline{\newline	char *titleopts[] =\newline	{\newline		&quotleft&quot,\newline		&quotright&quot,\newline		&quotcenter&quot,\newline		&quotside&quot,\newline		NULL\newline	};\newline	char *t, *s = *ss;\newline\newline	while (*s &amp&amp *s != &#039)&#039)\newline	{\newline		s = trimleft(s);\newline		if (*s == &#039,&#039)\newline		{\newline			s++;\newline			continue;\newline		}\newline\newline		switch (GetTokenIndex(s, titleopts, -1, &amps))\newline		{\newline		case 0: /* Left */\newline			*flags &amp= ~b_TitleHoriz;\newline			*flags &amp= ~3;\newline			*mask |= b_TitleHoriz;\newline			break;\newline		case 1: /* Right */\newline			*flags &amp= ~b_TitleHoriz;\newline			*flags &amp= ~3;\newline			*flags |= 2;\newline			*mask |= b_TitleHoriz;\newline			break;\newline		case 2: /* Center */\newline			*flags &amp= ~b_TitleHoriz;\newline			*flags &amp= ~3;\newline			*flags |= 1;\newline			*mask |= b_TitleHoriz;\newline			break;\newline		case 3: /* Side */\newline			*flags |= b_Horizontal;\newline			*flags &amp= ~3;\newline			*mask |= b_Horizontal;\newline			break;\newline		default:\newline			t = seekright(&amps);\newline			fprintf(stderr,\newline				&quot%s: Illegal title option \\&quot%s\\&quot\\n&quot,\newline				MyName, (t) ? t : &quot&quot);\newline			if (t)\newline			{\newline				free(t);\newline			}\newline		}\newline	}\newline	if (*s)\newline	{\newline		s++;\newline	}\newline	*ss = s;\newline}\newline",\newline ParseTitle()\newline Parses the options possible to Title\newline \newline,4458916,windows_cl.c,void extcl_UnloadLibrary() {\newline    if ( handleOCL != NULL ) {\newline	    FreeLibrary(handleOCL);\newline	    handleOCL = NULL;\newline	}\newline},\newline Unloads the OpenCL Library\newline \newline,121378,kfileitemlistviewtest.cpp,"void KFileItemListViewTest::testGroupedItemChanges()\newline{\newline    m_model-&gtsetGroupedSorting(true);\newline\newline    m_testDir-&gtcreateFiles(QStringList() &lt&lt &quot1&quot &lt&lt &quot3&quot &lt&lt &quot5&quot);\newline\newline    m_model-&gtloadDirectory(m_testDir-&gturl());\newline    QVERIFY(QTest::kWaitForSignal(m_model, SIGNAL(itemsInserted(KItemRangeList)), DefaultTimeout));\newline    QCOMPARE(m_model-&gtcount(), 3);\newline\newline    m_testDir-&gtcreateFiles(QStringList() &lt&lt &quot2&quot &lt&lt &quot4&quot);\newline    m_model-&gtm_dirLister-&gtupdateDirectory(m_testDir-&gturl());\newline    QVERIFY(QTest::kWaitForSignal(m_model, SIGNAL(itemsInserted(KItemRangeList)), DefaultTimeout));\newline    QCOMPARE(m_model-&gtcount(), 5);\newline\newline    m_testDir-&gtremoveFile(&quot1&quot);\newline    m_testDir-&gtremoveFile(&quot3&quot);\newline    m_testDir-&gtremoveFile(&quot5&quot);\newline    m_model-&gtm_dirLister-&gtupdateDirectory(m_testDir-&gturl());\newline    QVERIFY(QTest::kWaitForSignal(m_model, SIGNAL(itemsRemoved(KItemRangeList)), DefaultTimeout));\newline    QCOMPARE(m_model-&gtcount(), 2);\newline}\newline","\newline If grouping is enabled, the group headers must be updated\newline when items have been inserted or removed. This updating\newline may only be done after all multiple ranges have been inserted\newline or removed and not after each individual range (see description\newline in #ifndef QT_NO_DEBUG-block of KItemListView::slotItemsInserted()\newline and KItemListView::slotItemsRemoved()). This test inserts and\newline removes multiple ranges and will trigger the Q_ASSERT in the\newline ifndef QT_NO_DEBUG-block in case if a group-header will be updated\newline too early.\newline \newline",4865774,udbradtree.c,"static struct udb_radarray_d* lookup(udb_ptr* n)\newline{\newline	assert(udb_ptr_get_type(n) == udb_chunk_type_radnode);\newline	return (struct udb_radarray_d*)UDB_REL(*n-&gtbase,\newline		RADNODE(n)-&gtlookup.data);\newline}\newline",get the lookup array for a node \newline,5268589,extension.c,"int initialize_extension(Tracee *tracee, extension_callback_t callback, const char *cli)\newline{\newline	Extension *extension;\newline	int status;\newline\newline	extension = new_extension(tracee, callback);\newline	if (extension == NULL) {\newline		notice(tracee, WARNING, INTERNAL, &quotcan&#039t create a new extension&quot);\newline		return -1;\newline	}\newline\newline	/* Remove the new extension if its initialized has failed.  */\newline	status = extension-&gtcallback(extension, INITIALIZATION, (intptr_t) cli, 0);\newline	if (status &lt 0) {\newline		TALLOC_FREE(extension);\newline		return status;\newline	}\newline\newline	return 0;\newline}\newline","\newline Initialize a new extension for the given @callback then attach it\newline to its @tracee. The parameter @cli is its argument that was passed\newline to the command-line interface. This function return -1 if an error\newline occurred, otherwise 0.\newline \newline",on,,,,,on,,,,,on,,,,,on,,,,,on,,,,,,,,,,,,,,,,,,,,,,{},The value is parsed as described in strto_id_list.,Inserts an edge in a given graph.,the spc specific part of sg.c:enumerate_common(),Get the attribute node with +name+,{},E is the last block flag,zero if setup was success,Parses the options possible to Title,Unloads the OpenCL Library,{},Reads in an abort request,get the lookup array for a node,Initialize a new extension for the given,The encodings of surrogate halves are allowed!,{},get or create a Norm unit;,resolves a hostgroup object,Load an image from the named file.,Clean a Q of xpath_pcb_t entries,{},x,
3BO3NEOQM0HEXYJKKQCQL93U4ECAI6,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:13 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:13 PDT 2019,,,3VNXK88KKCI715Q8HT2ATMETOT99VQ,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:28 PDT 2019,Fri Apr 26 13:18:37 PDT 2019,Sun Apr 28 13:18:37 PDT 2019,,,,1809,100% (62/62),100% (62/62),0% (0/0),5249863,list.c,"void list_iter_set(struct list_iterator *i, struct list *l)\newline{\newline	__lock(l);\newline	i-&gti_list = l;\newline	i-&gti_cur = l-&gtl_first;\newline	i-&gti_next = l-&gtl_iter;\newline	l-&gtl_iter = i;\newline	__unlock(l);\newline}\newline",\newline list_iter\newline \newline,1419163,error.c,int	ErrGetNum()\newline{\newline	return(ErrorNumber);\newline}\newline,\newline ErrGetNum()\newline \newline returns the current error number\newline \newline,2464231,aacenc.c,"int aacenc_mp4asc(const aacenc_param_t *params,\newline                  const uint8_t *asc, uint32_t ascsize,\newline                  uint8_t *outasc, uint32_t *outsize)\newline{\newline    unsigned asc_sfreq = aacenc_sampling_freq_tab[(asc[0]&amp0x7)&lt&lt1 |asc[1]&gt&gt7];\newline    unsigned shift = aacenc_is_dual_rate_sbr(params);\newline\newline    switch (params-&gtprofile) {\newline    case AOT_SBR:\newline    case AOT_PS:\newline        if (!shift)\newline            break;\newline        if (*outsize &lt ascsize + 3)\newline            return -1;\newline        memcpy(outasc, asc, ascsize);\newline        /* syncExtensionType:11 (value:0x2b7) */\newline        outasc[ascsize+0] = 0x2b &lt&lt 1;\newline        outasc[ascsize+1] = 0x7 &lt&lt 5;\newline        /* extensionAudioObjectType:5 (value:5)*/\newline        outasc[ascsize+1] |= 5;\newline        /* sbrPresentFlag:1 (value:1) */\newline        outasc[ascsize+2] = 0x80;\newline        /* extensionSamplingFrequencyIndex:4 */\newline        outasc[ascsize+2] |= sampling_freq_index(asc_sfreq &lt&lt shift) &lt&lt 3;\newline        if (params-&gtprofile == AOT_SBR) {\newline            *outsize = ascsize + 3;\newline            return 0;\newline        }\newline        if (*outsize &lt ascsize + 5)\newline            return -1;\newline        /* syncExtensionType:11 (value:0x548) */\newline        outasc[ascsize+2] |= 0x5;\newline        outasc[ascsize+3] = 0x48;\newline        /* psPresentFlag:1 (value:1) */\newline        outasc[ascsize+4] = 0x80;\newline        *outsize = ascsize + 5;\newline        return 0;\newline    }\newline    if (*outsize &lt ascsize)\newline        return -1;\newline    memcpy(outasc, asc, ascsize);\newline    *outsize = ascsize;\newline    return 0;\newline}\newline","\newline Append backward compatible SBR/PS signaling to implicit signaling ASC,\newline if SBR/PS is present.\newline \newline",3829274,io.c,"void usbi_remove_pollfd(struct libusb_context *ctx, int fd)\newline{\newline	struct usbi_pollfd *ipollfd;\newline	int found = 0;\newline\newline	usbi_dbg(&quotremove fd %d&quot, fd);\newline	pthread_mutex_lock(&ampctx-&gtpollfds_lock);\newline	list_for_each_entry(ipollfd, &ampctx-&gtpollfds, list)\newline		if (ipollfd-&gtpollfd.fd == fd) {\newline			found = 1;\newline			break;\newline		}\newline\newline	if (!found) {\newline		usbi_dbg(&quotcouldn&#039t find fd %d to remove&quot, fd);\newline		pthread_mutex_unlock(&ampctx-&gtpollfds_lock);\newline		return;\newline	}\newline\newline	list_del(&ampipollfd-&gtlist);\newline	pthread_mutex_unlock(&ampctx-&gtpollfds_lock);\newline	free(ipollfd);\newline	if (ctx-&gtfd_removed_cb)\newline		ctx-&gtfd_removed_cb(fd, ctx-&gtfd_cb_user_data);\newline}\newline",Remove a file descriptor from the list of file descriptors to be polled. \newline,4475095,udomain.c,"int ul_event_init(void)\newline{\newline	ei_ins_id = evi_publish_event(ei_ins_name);\newline	if (ei_ins_id == EVI_ERROR) {\newline		LM_ERR(&quotcannot register aor insert event\\n&quot);\newline		return -1;\newline	}\newline\newline	ei_del_id = evi_publish_event(ei_del_name);\newline	if (ei_del_id == EVI_ERROR) {\newline		LM_ERR(&quotcannot register aor delete event\\n&quot);\newline		return -1;\newline	}\newline\newline	ei_c_ins_id = evi_publish_event(ei_contact_ins_name);\newline	if (ei_c_ins_id == EVI_ERROR) {\newline		LM_ERR(&quotcannot register contact insert event\\n&quot);\newline		return -1;\newline	}\newline\newline	ei_c_del_id = evi_publish_event(ei_contact_del_name);\newline	if (ei_c_del_id == EVI_ERROR) {\newline		LM_ERR(&quotcannot register contact delete event\\n&quot);\newline		return -1;\newline	}\newline\newline	ei_c_update_id = evi_publish_event(ei_contact_update_name);\newline	if (ei_c_update_id == EVI_ERROR) {\newline		LM_ERR(&quotcannot register contact delete event\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_event_params = pkg_malloc(sizeof(evi_params_t));\newline	if (!ul_event_params) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(ul_event_params, 0, sizeof(evi_params_t));\newline	ul_aor_param = evi_param_create(ul_event_params, &ampei_aor_name);\newline	if (!ul_aor_param) {\newline		LM_ERR(&quotcannot create AOR parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_contact_event_params = pkg_malloc(sizeof(evi_params_t));\newline	if (!ul_contact_event_params) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(ul_contact_event_params, 0, sizeof(evi_params_t));\newline\newline	ul_c_addr_param = evi_param_create(ul_contact_event_params, &ampei_c_addr_name);\newline	if (!ul_c_addr_param) {\newline		LM_ERR(&quotcannot create contact address parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_c_aor_param = evi_param_create(ul_contact_event_params, &ampei_aor_name);\newline	if (!ul_c_aor_param) {\newline		LM_ERR(&quotcannot create contact aor parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_c_callid_param = evi_param_create(ul_contact_event_params, &ampei_callid_name);\newline	if (!ul_c_callid_param) {\newline		LM_ERR(&quotcannot create callid parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_c_recv_param = evi_param_create(ul_contact_event_params, &ampei_c_recv_name);\newline	if (!ul_c_recv_param) {\newline		LM_ERR(&quotcannot create received parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	ul_c_cseq_param = evi_param_create(ul_contact_event_params, &ampei_cseq_name);\newline	if (!ul_c_cseq_param) {\newline		LM_ERR(&quotcannot create cseq parameter\\n&quot);\newline		return -1;\newline	}\newline\newline	return 0;\newline}\newline",! \\brief\newline Initialize event structures\newline \newline,4223678,ao_pulse.c,"static void info_func(struct pa_context *c, const struct pa_sink_input_info *i, int is_last, void *userdata) {\newline    struct pa_cvolume *volume = userdata;\newline    if (is_last &lt 0) {\newline        GENERIC_ERR_MSG(context, &quotFailed to get sink input info&quot);\newline        return;\newline    }\newline    if (!i)\newline        return;\newline    *volume = i-&gtvolume;\newline    pa_threaded_mainloop_signal(mainloop, 0);\newline}\newline",A callback function that is called when the\newline pa_context_get_sink_input_info() operation completes. Saves the\newline volume field of the specified structure to the global variable volume. \newline,2788010,lwgeodetic_tree.c,"int circ_tree_get_point(const CIRC_NODE* node, POINT2D* pt)\newline{\newline	if ( circ_node_is_leaf(node) )\newline	{\newline		pt-&gtx = node-&gtp1-&gtx;\newline		pt-&gty = node-&gtp1-&gty;\newline		return LW_SUCCESS;\newline	}\newline	else\newline	{\newline		return circ_tree_get_point(node-&gtnodes[0], pt);\newline	}\newline}\newline",\newline Returns a #POINT2D that is a vertex of the input shape\newline \newline,4198743,texstudio.cpp,"void Texstudio::fileNewFromTemplate()\newline{\newline	TemplateManager tmplMgr;\newline	connectUnique(&amptmplMgr, SIGNAL(editRequested(QString)), this, SLOT(templateEdit(QString)));\newline\newline	TemplateSelector *dialog = tmplMgr.createLatexTemplateDialog();\newline	if (!dialog-&gtexec()) return;\newline\newline	TemplateHandle th = dialog-&gtselectedTemplate();\newline	if (!th.isValid()) return;\newline\newline	if (dialog-&gtcreateInFolder()) {\newline		th.createInFolder(dialog-&gtcreationFolder());\newline		if (th.isMultifile()) {\newline			QDir dir(dialog-&gtcreationFolder());\newline			foreach (const QString &ampf, th.filesToOpen()) {\newline				QFileInfo fi(dir, f);\newline				if (fi.exists() &amp&amp fi.isFile())\newline					load(fi.absoluteFilePath());\newline			}\newline		} else {\newline			QDir dir(dialog-&gtcreationFolder());\newline			QFileInfo fi(dir, QFileInfo(th.file()).fileName());\newline			load(fi.absoluteFilePath());\newline		}\newline	} else {\newline		QString fname = th.file();\newline		QFile file(fname);\newline		if (!file.exists()) {\newline			txsWarning(tr(&quotFile not found:&quot) + QString(&quot\\n%1&quot).arg(fname));\newline			return;\newline		}\newline		if (!file.open(QIODevice::ReadOnly)) {\newline			txsWarning(tr(&quotYou do not have read permission to this file:&quot) + QString(&quot\\n%1&quot).arg(fname));\newline			return;\newline		}\newline\newline		//set up new editor with template\newline		fileNewInternal();\newline		LatexEditorView *edit = currentEditorView();\newline\newline		QString mTemplate;\newline		bool loadAsSnippet = false;\newline		QTextStream in(&ampfile);\newline		in.setCodec(QTextCodec::codecForMib(MIB_UTF8));\newline		QString line = in.readLine();\newline		if (line.contains(QRegExp(&quot^%\\\\s*!TXS\\\\s+template&quot))) {\newline			loadAsSnippet = true;\newline		} else {\newline			mTemplate += line + &#039\\n&#039;\newline		}\newline		while (!in.atEnd()) {\newline			line = in.readLine();\newline			mTemplate += line + &quot\\n&quot;\newline		}\newline		if (loadAsSnippet) {\newline			bool flag = edit-&gteditor-&gtflag(QEditor::AutoIndent);\newline			edit-&gteditor-&gtsetFlag(QEditor::AutoIndent, false);\newline			CodeSnippet toInsert(mTemplate, false);\newline			toInsert.insert(edit-&gteditor);\newline			edit-&gteditor-&gtsetFlag(QEditor::AutoIndent, flag);\newline			edit-&gteditor-&gtsetCursorPosition(0, 0, false);\newline			edit-&gteditor-&gtnextPlaceHolder();\newline			edit-&gteditor-&gtensureCursorVisible(QEditor::KeepSurrounding);\newline		} else {\newline			edit-&gteditor-&gtsetText(mTemplate, false);\newline		}\newline\newline		emit infoNewFromTemplate();\newline	}\newline	delete dialog;\newline}\newline",!\newline \\brief generate new file from template\newline \newline,887886,omx_alsasink_component.c,"void omx_alsasink_component_BufferMgmtCallback(OMX_COMPONENTTYPE *openmaxStandComp, OMX_BUFFERHEADERTYPE* inputbuffer) {\newline  OMX_U32                             frameSize;\newline  OMX_S32                             written;\newline  OMX_S32                             totalBuffer;\newline  OMX_S32                             offsetBuffer;\newline  OMX_BOOL                            allDataSent;\newline  omx_alsasink_component_PrivateType* omx_alsasink_component_Private = openmaxStandComp-&gtpComponentPrivate;\newline\newline  /* Feed it to ALSA */\newline  frameSize = (omx_alsasink_component_Private-&gtsPCMModeParam.nChannels * omx_alsasink_component_Private-&gtsPCMModeParam.nBitPerSample) &gt&gt 3;\newline  DEBUG(DEB_LEV_FULL_SEQ, &quotFramesize is %u chl=%d sRate=%d bufSize=%d \\n&quot,\newline    (int)frameSize, (int)omx_alsasink_component_Private-&gtsPCMModeParam.nChannels,\newline    (int)omx_alsasink_component_Private-&gtsPCMModeParam.nSamplingRate , (int)inputbuffer-&gtnFilledLen);\newline\newline  if(inputbuffer-&gtnFilledLen &lt frameSize){\newline    DEBUG(DEB_LEV_ERR, &quotOuch!! In %s input buffer filled len(%d) less than frame size(%d)\\n&quot,__func__, (int)inputbuffer-&gtnFilledLen, (int)frameSize);\newline    return;\newline  }\newline\newline  allDataSent = OMX_FALSE;\newline\newline  totalBuffer = inputbuffer-&gtnFilledLen/frameSize;\newline  offsetBuffer = 0;\newline  while (!allDataSent) {\newline//  DEBUG(DEB_LEV_ERR, &quotWriting to the device ..\\n&quot);\newline    written = snd_pcm_writei(omx_alsasink_component_Private-&gtplayback_handle, inputbuffer-&gtpBuffer + (offsetBuffer * frameSize), totalBuffer);\newline    if (written &lt 0) {\newline      if(written == -EPIPE){\newline        DEBUG(DEB_LEV_ERR, &quotALSA Underrun..\\n&quot);\newline        snd_pcm_prepare(omx_alsasink_component_Private-&gtplayback_handle);\newline        written = 0;\newline      } else {\newline        DEBUG(DEB_LEV_ERR, &quotCannot send any data to the audio device %s (%s)\\n&quot, &quotdefault&quot, snd_strerror (written));\newline        DEBUG(DEB_LEV_ERR, &quotIB FilledLen=%d,totalBuffer=%d,frame size=%d,offset=%d\\n&quot,\newline        (int)inputbuffer-&gtnFilledLen, (int)totalBuffer, (int)frameSize, (int)offsetBuffer);\newline        break;\newline        return;\newline      }\newline    }\newline\newline    if(written != totalBuffer){\newline      totalBuffer = totalBuffer - written;\newline      offsetBuffer = written;\newline    } else {\newline      DEBUG(DEB_LEV_FULL_SEQ, &quotBuffer successfully sent to ALSA. Length was %i\\n&quot, (int)inputbuffer-&gtnFilledLen);\newline      allDataSent = OMX_TRUE;\newline    }\newline  }\newline  inputbuffer-&gtnFilledLen=0;\newline}\newline",\newline This function plays the input buffer. When fully consumed it returns.\newline \newline,5282375,lj_opt_mem.c,"static AliasRet aa_fref(jit_State *J, IRIns *refa, IRIns *refb)\newline{\newline  if (refa-&gtop2 != refb-&gtop2)\newline    return ALIAS_NO;  /* Different fields. */\newline  if (refa-&gtop1 == refb-&gtop1)\newline    return ALIAS_MUST;  /* Same field, same object. */\newline  else if (refa-&gtop2 &gt= IRFL_TAB_META &amp&amp refa-&gtop2 &lt= IRFL_TAB_NOMM)\newline    return aa_table(J, refa-&gtop1, refb-&gtop1);  /* Disambiguate tables. */\newline  else\newline    return ALIAS_MAY;  /* Same field, possibly different object. */\newline}\newline",Alias analysis for field access.\newline Field loads are cheap and field stores are rare.\newline Simple disambiguation based on field types is good enough.\newline \newline,4528679,pfmlib_pentium4.c,"static int pentium4_pmu_detect(void)\newline{\newline	int ret, family;\newline	char buffer[128];\newline\newline	ret = __pfm_getcpuinfo_attr(&quotvendor_id&quot, buffer, sizeof(buffer));\newline	if (ret == -1)\newline		return PFMLIB_ERR_NOTSUPP;\newline\newline	if (strcmp(buffer, &quotGenuineIntel&quot))\newline		return PFMLIB_ERR_NOTSUPP;\newline\newline	ret = __pfm_getcpuinfo_attr(&quotcpu family&quot, buffer, sizeof(buffer));\newline	if (ret == -1)\newline		return PFMLIB_ERR_NOTSUPP;\newline\newline	family = atoi(buffer);\newline\newline	ret = __pfm_getcpuinfo_attr(&quotmodel&quot, buffer, sizeof(buffer));\newline	if (ret == -1)\newline		return PFMLIB_ERR_NOTSUPP;\newline\newline	/*\newline	 * we use model to detect model 2 which has one more counter IQ_ESCR1\newline	 */\newline	p4_model = atoi(buffer);\newline	if (family != 15)\newline		return PFMLIB_ERR_NOTSUPP;\newline	/*\newline	 * IQ_ESCR0, IQ_ESCR1 only for model 1 and 2 \newline	 */\newline	if (p4_model &gt2)\newline		pentium4_support.pmc_count -= 2;\newline\newline	return family == 15 ? PFMLIB_SUCCESS : PFMLIB_ERR_NOTSUPP;\newline}\newline",\newline pentium4_pmu_detect\newline \newline Determine whether the system we&#039re running on is a Pentium4\newline (or other CPU that uses the same PMU).\newline \newline,5745621,wiresedit.c,"GWireNode *wirenode_cutcorner(GWireNode *n,GModuleDef *M)\newline{\newline  GWireNode *cn;\newline  GWire *w = wirenode_driver(n);\newline\newline  cn = new_GWireNode();\newline  ob_touch(cn);\newline  cn-&gtin = n-&gtin;\newline  ob_touch(cn-&gtin);\newline  cn-&gtin-&gtout = cn;\newline  cn-&gtout = NULL;\newline  ob_touch(n);\newline  n-&gtin = NULL;\newline\newline  cn-&gtend = wire_newend(M,w-&gtnet,0);\newline  ob_touch(cn-&gtend);\newline  cn-&gtend-&gtnodes = cn;\newline\newline  n-&gtend = wire_newend(M,w-&gtnet,0);\newline  ob_touch(n-&gtend);\newline  n-&gtend-&gtnodes = n;\newline\newline  cn-&gtx = n-&gtx;\newline  cn-&gty = n-&gty;\newline\newline  GWireNode_setends(n);\newline  GWireNode_setends(cn);\newline\newline  /*\newline   * Decide which net to rename.\newline   */\newline  GWire_pickRenameWire(n-&gtend,cn-&gtend,M);\newline\newline  return cn;\newline}\newline",\newlineCalled when the wire clippers are used to cut a wire on a corner.\newline \newline,3408627,struct-model.c,"void free_model_DS( model_DS model, int i_model)\newline{\newline\newline  int n_prior, n_term;\newline  term_DS term;\newline\newline  if (G_clsf_storage_log_p == TRUE)\newline    fprintf(stdout, &quotfree_model(%d): %p\\n&quot, i_model, (void *) model);\newline\newline  if (model-&gtterms != NULL) {\newline    for (n_term=0; n_term &lt model-&gtn_terms ; n_term++) {\newline      term = model-&gtterms[n_term];\newline      free ( term-&gtatt_list);\newline      free_tparm_DS( term-&gttparm);\newline      free( term);\newline    }\newline    free( model-&gtterms);\newline  }\newline\newline  if (model-&gtatt_locs != NULL)\newline    free( model-&gtatt_locs);\newline  if (model-&gtatt_ignore_ids != NULL)\newline    free( model-&gtatt_ignore_ids);\newline\newline  if (model-&gtpriors != NULL) {\newline    for (n_prior=0; n_prior&ltmodel-&gtnum_priors ; n_prior++)\newline      if (model-&gtpriors[n_prior] != NULL)\newline        free( model-&gtpriors[n_prior]);\newline    free( model-&gtpriors);\newline  }\newline  free( model);\newline}\newline",FREE_MODEL_DS\newline25feb95 wmt: new\newline \newline,5746708,hdl.c,"void hdl_load(GModuleDef *M)\newline{\newline  hdl_active_module = M;\newline\newline  if (M-&gtm_text) {\newline    DoTcl(&quotHdlEditor::enable&quot);\newline    DoTcl(&quotHdlEditor::clear&quot);\newline\newline    DoTclL(&quotHdlEditor::loadText&quot,M-&gtm_text,NULL);\newline\newline    if (GModuleDef_isDataProtected(M))\newline      DoTcl(&quotHdlEditor::disable&quot);\newline  } else {\newline    printf(&quothdl_load ignored for non-HDL module [%s]\\n&quot,M-&gtm_name);\newline  }\newline\newline}\newline",\newline \newline Load HDL text from module definition to editor.\newline \newline Parameters:\newline M Module to be loaded into hdl editor.\newline \newline \newline,6420149,ircd.c,"static iftype_t _ircd_client_signal (INTERFACE *cli, ifsig_t sig)\newline{\newline  peer_priv *peer = cli-&gtdata;\newline  const char *reason, *host;\newline  INTERFACE *tmp;\newline  size_t sw;\newline  char nstr[MB_LEN_MAX*NICKLEN+2];\newline  char buff[STRING];\newline\newline  dprint(5, &quotircd:ircd.c:_ircd_client_signal: name=%s sig=%d&quot,\newline	 NONULL((char *)cli-&gtname), (int)sig);\newline  switch (sig)\newline  {\newline    case S_REPORT:\newline      tmp = Set_Iface(cli);\newline      if (peer-&gtlink == NULL) {\newline	printl(buff, sizeof(buff), ReportFormat, 0, NULL, NULL, NULL,\newline	       NULL, 0, peer-&gtp.socket + 1, (int)(Time - peer-&gtstarted),\newline	       &quotunknown connection (startup)&quot);\newline	New_Request(tmp, F_REPORT, &quot%s&quot, buff);\newline	Unset_Iface();\newline	break;\newline      }\newline      if (peer-&gtlink-&gtcl-&gtumode &amp (A_OP | A_HALFOP))\newline	nstr[0] = &#039*&#039;\newline      else if (peer-&gtlink-&gtcl-&gtumode &amp A_RESTRICTED)\newline	nstr[0] = &#039=&#039;\newline      else\newline	nstr[0] = &#039 &#039;\newline      strfcpy(&ampnstr[1], peer-&gtlink-&gtcl-&gtnick, sizeof(nstr) - 1);\newline      if (peer-&gtp.state == P_LOGIN || peer-&gtp.state == P_TALK)\newline	host = peer-&gtlink-&gtcl-&gthost;\newline      else\newline	host = NULL;		/*host isn&#039t valid if not P_LOGIN nor P_TALK */\newline      switch (peer-&gtp.state) {\newline      case P_TALK:\newline	if (CLIENT_IS_SERVER(peer-&gtlink-&gtcl))\newline	  reason = &quotactive IRCD server connection&quot;\newline#ifdef USE_SERVICES\newline	else if (CLIENT_IS_SERVICE(peer-&gtlink-&gtcl))\newline	  reason = &quotactive IRCD service connection&quot;\newline#endif\newline	else\newline	  reason = &quotactive IRCD client connection&quot;\newline	break;\newline      case P_LASTWAIT:\newline      case P_QUIT:\newline	reason = &quot(IRCD) link is terminating&quot;\newline	break;\newline      default:\newline	reason = &quot(IRCD) registering&quot;\newline      }\newline      printl(buff, sizeof(buff), ReportFormat, 0, nstr, host,\newline	     CLIENT_IS_SERVER(peer-&gtlink-&gtcl) ? peer-&gtlink-&gtcl-&gtlcnick :\newline						peer-&gtlink-&gtcl-&gtx.class-&gtname,\newline	     NULL, 0, peer-&gtp.socket + 1, (int)(Time - peer-&gtnoidle), reason);\newline      New_Request(tmp, F_REPORT, &quot%s&quot, buff);\newline      Unset_Iface();\newline      break;\newline    case S_TERMINATE:\newline      switch (peer-&gtp.state)\newline      {\newline	case P_DISCONNECTED:		/* there is a thread still */\newline	case P_INITIAL:\newline	  pthread_cancel (peer-&gtth);\newline	  Unset_Iface();		/* let it to finish bindings */\newline	  pthread_join (peer-&gtth, NULL);\newline	  Set_Iface(cli);\newline	case P_LOGIN:			/* isn&#039t registered yet */\newline	case P_IDLE:\newline	  sw = (peer-&gtlink != NULL &amp&amp peer-&gtlink-&gtcl-&gtumode &amp A_UPLINK) ? 1 : 0;\newline					/* no peer-&gtlink yet if P_DISCONNECTED */\newline	  if (ShutdownR)\newline	    _ircd_peer_kill (peer, ShutdownR);\newline	  else\newline	    _ircd_peer_kill (peer, &quotConnection timeout&quot);\newline	  if (sw)			/* couldn&#039t connect uplink, retry */\newline	    peer-&gtlink-&gtcl-&gtumode |= A_UPLINK;\newline	case P_QUIT:			/* shutdown is in progress */\newline	case P_LASTWAIT:\newline	  cli-&gtift &amp= ~I_FINWAIT;	/* don&#039t kill me again */\newline	  break;\newline	case P_TALK:			/* shedule death to it */\newline	  if (peer-&gtp.last_input == 0)\newline	    reason = &quotPing timeout&quot;\newline	  else if (peer-&gtp.last_input &lt 0)\newline	    reason = SocketError(peer-&gtp.last_input, buff, sizeof(buff));\newline	  else if (ShutdownR)\newline	    reason = ShutdownR;\newline	  else\newline	    reason = &quotLink broken&quot;\newline	  if (CLIENT_IS_SERVER (peer-&gtlink-&gtcl))\newline	    ircd_do_squit (peer-&gtlink, peer, reason);\newline	  else\newline	  {\newline#ifdef USE_SERVICES\newline	    ircd_sendto_services_mark_nick (Ircd, SERVICE_WANT_QUIT | SERVICE_WANT_RQUIT);\newline#endif\newline	    ircd_sendto_servers_all_ack (Ircd, peer-&gtlink-&gtcl, NULL, NULL,\newline					 &quot:%s QUIT :%s&quot, peer-&gtp.dname, reason);\newline	    ircd_prepare_quit (peer-&gtlink-&gtcl, peer, reason);\newline#ifdef USE_SERVICES\newline	    ircd_sendto_services_mark_prefix (Ircd, SERVICE_WANT_QUIT | SERVICE_WANT_RQUIT);\newline#endif\newline	    peer-&gtlink-&gtcl-&gthold_upto = Time;\newline	    Add_Request (I_PENDING, &quot*&quot, 0, &quot:%s!%s@%s QUIT :%s&quot, peer-&gtp.dname,\newline			 peer-&gtlink-&gtcl-&gtuser, peer-&gtlink-&gtcl-&gtvhost, reason);\newline	  }\newline      }\newline      break;\newline    case S_SHUTDOWN:\newline      sw = snprintf (buff, sizeof(buff), &quotERROR : Emergency : %s&quot,\newline		     NONULL(ShutdownR));\newline      if (Peer_Put ((&amppeer-&gtp), buff, &ampsw) &gt 0)\newline	while (!Peer_Put ((&amppeer-&gtp), NULL, &ampsw));\newline      //CloseSocket (peer-&gtp.socket);\newline      cli-&gtift = I_DIED;\newline      break;\newline    default: ;\newline  }\newline  return 0;\newline}\newline",-- client interface ----------------------------------------------------\newlineon terminating it does not kill interface but shedules death instead \newline,2742176,file-item.c,"int btrfs_del_csums(struct btrfs_trans_handle *trans,\newline		    struct btrfs_root *root, u64 bytenr, u64 len)\newline{\newline	struct btrfs_path *path;\newline	struct btrfs_key key;\newline	u64 end_byte = bytenr + len;\newline	u64 csum_end;\newline	struct extent_buffer *leaf;\newline	int ret;\newline	u16 csum_size =\newline		btrfs_super_csum_size(root-&gtfs_info-&gtsuper_copy);\newline	int blocksize = root-&gtsectorsize;\newline\newline	root = root-&gtfs_info-&gtcsum_root;\newline\newline	path = btrfs_alloc_path();\newline	if (!path)\newline		return -ENOMEM;\newline\newline	while (1) {\newline		key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\newline		key.offset = end_byte - 1;\newline		key.type = BTRFS_EXTENT_CSUM_KEY;\newline\newline		ret = btrfs_search_slot(trans, root, &ampkey, path, -1, 1);\newline		if (ret &gt 0) {\newline			if (path-&gtslots[0] == 0)\newline				goto out;\newline			path-&gtslots[0]--;\newline		}\newline		leaf = path-&gtnodes[0];\newline		btrfs_item_key_to_cpu(leaf, &ampkey, path-&gtslots[0]);\newline\newline		if (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\newline		    key.type != BTRFS_EXTENT_CSUM_KEY) {\newline			break;\newline		}\newline\newline		if (key.offset &gt= end_byte)\newline			break;\newline\newline		csum_end = btrfs_item_size_nr(leaf, path-&gtslots[0]) / csum_size;\newline		csum_end *= blocksize;\newline		csum_end += key.offset;\newline\newline		/* this csum ends before we start, we&#039re done */\newline		if (csum_end &lt= bytenr)\newline			break;\newline\newline		/* delete the entire item, it is inside our range */\newline		if (key.offset &gt= bytenr &amp&amp csum_end &lt= end_byte) {\newline			ret = btrfs_del_item(trans, root, path);\newline			BUG_ON(ret);\newline		} else if (key.offset &lt bytenr &amp&amp csum_end &gt end_byte) {\newline			unsigned long offset;\newline			unsigned long shift_len;\newline			unsigned long item_offset;\newline			/*\newline			 *        [ bytenr - len ]\newline			 *     [csum                ]\newline			 *\newline			 * Our bytes are in the middle of the csum,\newline			 * we need to split this item and insert a new one.\newline			 *\newline			 * But we can&#039t drop the path because the\newline			 * csum could change, get removed, extended etc.\newline			 *\newline			 * The trick here is the max size of a csum item leaves\newline			 * enough room in the tree block for a single\newline			 * item header.  So, we split the item in place,\newline			 * adding a new header pointing to the existing\newline			 * bytes.  Then we loop around again and we have\newline			 * a nicely formed csum item that we can neatly\newline			 * truncate.\newline			 */\newline			offset = (bytenr - key.offset) / blocksize;\newline			offset *= csum_size;\newline\newline			shift_len = (len / blocksize) * csum_size;\newline\newline			item_offset = btrfs_item_ptr_offset(leaf,\newline							    path-&gtslots[0]);\newline\newline			memset_extent_buffer(leaf, 0, item_offset + offset,\newline					     shift_len);\newline			key.offset = bytenr;\newline\newline			/*\newline			 * btrfs_split_item returns -EAGAIN when the\newline			 * item changed size or key\newline			 */\newline			ret = btrfs_split_item(trans, root, path, &ampkey, offset);\newline			BUG_ON(ret &amp&amp ret != -EAGAIN);\newline\newline			key.offset = end_byte - 1;\newline		} else {\newline			ret = truncate_one_csum(trans, root, path,\newline						&ampkey, bytenr, len);\newline			BUG_ON(ret);\newline		}\newline		btrfs_release_path(path);\newline	}\newlineout:\newline	btrfs_free_path(path);\newline	return 0;\newline}\newline",\newline deletes the csum items from the csum tree for a given\newline range of bytes.\newline \newline,184015,lemon.c,"void Configlist_sort(){\newline  current = (struct config *)msort(current,(void **)&amp(current-&gtnext),Configcmp);\newline  currentend = 0;\newline  return;\newline}\newline",Sort the configuration list \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1860731,savestate.c,"void realizeTextviewHighlight(GtkWidget *widget, GKeyFile *keyString, const gchar *group, const gchar *name)\newline{\newline  GtkTextView *textview;\newline  if (getResultsViewHorizontal(widget)) {\newline    textview = GTK_TEXT_VIEW(lookup_widget(widget, &quottextview1&quot));\newline  } else {\newline    textview = GTK_TEXT_VIEW(lookup_widget(widget, &quottextview4&quot));\newline  }\newline  gchar *newColor;\newline  GdkColor cp;\newline  GtkTextBuffer* textBuf = gtk_text_view_get_buffer (textview);\newline  GtkTextTagTable* tagTable = gtk_text_buffer_get_tag_table(textBuf);\newline  GtkTextTag* tag = gtk_text_tag_table_lookup(tagTable, &quotword_highlight&quot);\newline  \newline  g_assert(textview != NULL);\newline  g_assert(tag != NULL);\newline  g_assert(tagTable != NULL);\newline  g_assert(textBuf != NULL);\newline  \newline  if (g_key_file_has_key(keyString, group, name, NULL)) {\newline    newColor = g_key_file_get_string (keyString, group, name, NULL);\newline    if (newColor != NULL) {\newline      if (gdk_color_parse (newColor, &ampcp)) {\newline        g_object_set( G_OBJECT(tag), &quotforeground-gdk&quot, &ampcp, NULL);\newline      }\newline      g_free(newColor);\newline    }\newline  }\newline}\newline",\newline Callback helper: retrieve content result&#039s highlight colour from config.ini settings\newline \newline,1765801,kern.c,"void k_set_router_alert(int socket)\newline{\newline    char router_alert[4];	/* Router Alert IP Option	    */\newline\newline    router_alert[0] = IPOPT_RA;	/* Router Alert */\newline    router_alert[1] = 4;	/* 4 bytes */\newline    router_alert[2] = 0;\newline    router_alert[3] = 0;\newline\newline    if (setsockopt(socket, IPPROTO_IP, IP_OPTIONS, router_alert, sizeof(router_alert) )&lt 0)\newline	logit(LOG_ERR, errno, &quotsetsockopt IP_OPTIONS IPOPT_RA&quot);\newline}\newline","\newline Set Router Alert IP option, RFC2113\newline \newline",2032234,mod_auth_cas.c,"int cas_match_attribute(const char *const attr_spec, const cas_saml_attr *const attributes, struct request_rec *r) {\newline	const cas_saml_attr *attr = attributes;\newline\newline	/* Loop over all of the user attributes */\newline	for ( ; attr; attr = attr-&gtnext ) {\newline\newline		const char *attr_c = attr-&gtattr;\newline		const char *spec_c = attr_spec;\newline\newline		/* Walk both strings until we get to the end of either or we\newline		 * find a differing character */\newline		while ((*attr_c) &amp&amp\newline		       (*spec_c) &amp&amp\newline		       (*attr_c) == (*spec_c)) {\newline			attr_c++;\newline			spec_c++;\newline		}\newline\newline		/* The match is a success if we walked the whole attribute\newline		 * name and the attr_spec is at a colon. */\newline		if (!(*attr_c) &amp&amp (*spec_c) == &#039:&#039) {\newline			const cas_saml_attr_val *val;\newline\newline			/* Skip the colon */\newline			spec_c++;\newline\newline			/* Compare the attribute values */\newline			val = attr-&gtvalues;\newline			for ( ; val; val = val-&gtnext ) {\newline\newline				/* Approximately compare the attribute value (ignoring\newline				 * whitespace). At this point, spec_c points to the\newline				 * NULL-terminated value pattern. */\newline				if (apr_strnatcmp(val-&gtvalue, spec_c) == 0) {\newline					return CAS_ATTR_MATCH;\newline				}\newline			}\newline		}\newline		/* The match is a success is we walked the whole attribute\newline		 * name and the attr_spec is a tilde (denotes a PCRE match). */\newline		else if (!(*attr_c) &amp&amp (*spec_c) == &#039~&#039) {\newline			const cas_saml_attr_val *val;\newline			const char *errorptr;\newline			int erroffset;\newline			pcre *preg;\newline\newline			/* Skip the tilde */\newline			spec_c++;\newline\newline			/* Set up the regex */\newline			preg = pcre_compile(spec_c, 0, &amperrorptr, &amperroffset, NULL);\newline			if (NULL == preg) {\newline				ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, &quotPattern [%s] is not a valid regular expression&quot, spec_c);\newline				continue;\newline			}\newline\newline			/* Compare the attribute values */\newline			val = attr-&gtvalues;\newline			for ( ; val; val = val-&gtnext) {\newline				/* PCRE-compare the attribute value. At this point, spec_c\newline				 * points to the NULL-terminated value pattern. */\newline				if (0 == pcre_exec(preg, NULL, val-&gtvalue, (int)strlen(val-&gtvalue), 0, 0, NULL, 0)) {\newline					pcre_free(preg);\newline					return CAS_ATTR_MATCH;\newline				}\newline			}\newline\newline			pcre_free(preg);\newline		}\newline	}\newline	return CAS_ATTR_NO_MATCH;\newline}\newline","Look for an attribute that matches the given attribute spec (e.g.\newline from a Require directive)\newline \newline An attribute spec is a string containing an attribute name and an\newline attribute value separated by a colon. This means that attribute\newline specification strings containing more than one colon produce ambiguous\newline specifications that match multiple attributes. For instance:\newline \newline spec = &quotfoo:bar:baz&quot\newline \newline matches both:\newline \newline attr1 = &quotfoo&quot &quotbar:baz&quot\newline attr2 = &quotfoo:bar&quot &quotbaz&quot\newline \newline Attribute name matching is exact, and value matching has some\newline leeway. Value matching uses apr_strnatcmp to determine equality, so\newline whitespace is ignored and decimal numbers can have differing\newline representations. See the documentation of apr_strnatcmp for\newline details.\newline \newline",on,,,on,on,,on,,,,on,,on,on,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,{},Field loads are cheap and field stores are rare.,Determine whether the system we're running on is a Pentium4,{},{},Load HDL text from module definition to editor.,{},deletes the csum items,Sort the configuration list,Load an image from the named file.,{},returns the current error number,{},{},{},Remove a file descriptor,Initialize event structures,A callback function,Returns a #POINT2D that is a vertex of the input shape,\brief generate new file from template,This function plays the input buffer.,x,
3Y3N5A7N4G91PZ7ELBOYGOSIOEZMY8,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:13 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:13 PDT 2019,,,3VW04L3ZLT6P6QD1KO96XAXWB75XXX,AITP2LUW8GPB,Submitted,Fri Apr 26 13:36:00 PDT 2019,Fri Apr 26 13:48:00 PDT 2019,Sun Apr 28 13:48:00 PDT 2019,,,,720,100% (62/62),100% (62/62),0% (0/0),6482462,dico.c,StrIBM ( byte *str )\newline{\newline    while ( *str )\newline    {\newline        iso2ibm( str++ );\newline    } \newline}\newline,\newline strIBM: Translates an ISO accentuated string to an MS-DOS one.\newline \newline \newline \newline,2187598,bookmarks.c,"static int Bmsrv_send_modify_update(Dsh *sh, char *url)\newline{\newline   static char *url1 = NULL;\newline   static Dstr *dstr = NULL;\newline   char *p, *q;\newline   int i, key, n_sec, n_url;\newline   BmRec *bm_node;\newline   BmSec *sec_node;\newline\newline   /* bookmarks were loaded before */\newline\newline   if (!dstr)\newline      dstr = dStr_new(&quot&quot);\newline\newline   if (sh == NULL) {\newline      /* just copy url */\newline      dFree(url1);\newline      url1 = dStrdup(url);\newline      return 0;\newline   }\newline\newline   /* send HTML here */\newline   if (a_Dpip_dsh_write_str(sh, 0, modifypage_update_header))\newline      return 1;\newline\newline   /* Count number of marked urls and sections */\newline   Bmsrv_count_urls_and_sections(url1, &ampn_sec, &ampn_url);\newline\newline   if (n_sec) {\newline      dStr_sprintf(dstr, modifypage_update_title, &quotUpdate&ampnbsp;sections:&quot);\newline      a_Dpip_dsh_write_str(sh, 0, dstr-&gtstr);\newline      a_Dpip_dsh_write_str(sh, 0, modifypage_update_item_header);\newline      /* send items here */\newline      p = strchr(url1, &#039?&#039);\newline      for (q = p; (q = strstr(q, &quot&amps&quot)); ++q) {\newline         for (i = 0; isdigit(q[2+i]); ++i);\newline         if (q[2+i] == &#039=&#039) {\newline            key = strtol(q + 2, NULL, 10);\newline            if ((sec_node = Bms_get_sec(key))) {\newline               dStr_sprintf(dstr, modifypage_update_item2,\newline                            sec_node-&gtsection, sec_node-&gttitle);\newline               a_Dpip_dsh_write_str(sh, 0, dstr-&gtstr);\newline            }\newline         }\newline      }\newline      a_Dpip_dsh_write_str(sh, 0, modifypage_update_item_footer);\newline   }\newline\newline   if (n_url) {\newline      dStr_sprintf(dstr, modifypage_update_title, &quotUpdate&ampnbsp;titles:&quot);\newline      a_Dpip_dsh_write_str(sh, 0, dstr-&gtstr);\newline      a_Dpip_dsh_write_str(sh, 0, modifypage_update_item_header);\newline      /* send items here */\newline      p = strchr(url1, &#039?&#039);\newline      for (q = p; (q = strstr(q, &quot&ampurl&quot)); ++q) {\newline         for (i = 0; isdigit(q[4+i]); ++i);\newline         if (q[4+i] == &#039=&#039) {\newline            key = strtol(q + 4, NULL, 10);\newline            bm_node = Bms_get(key);\newline            dStr_sprintf(dstr, modifypage_update_item,\newline                         bm_node-&gtkey, bm_node-&gttitle, bm_node-&gturl);\newline            a_Dpip_dsh_write_str(sh, 0, dstr-&gtstr);\newline         }\newline      }\newline      a_Dpip_dsh_write_str(sh, 0, modifypage_update_item_footer);\newline   }\newline\newline   a_Dpip_dsh_write_str(sh, 1, modifypage_update_footer);\newline\newline   return 2;\newline}\newline","\newline Parse a modify urls request and either:\newline - make a local copy of the url\newline or\newline - send the modify page for the marked urls and sections\newline Return code: { 0:OK, 1:Abort, 2:Close }\newline \newline",638884,cmph.c,"cmph_uint32 cmph_search_packed(void *packed_mphf, const char *key, cmph_uint32 keylen)\newline{\newline	cmph_uint32 *ptr = (cmph_uint32 *)packed_mphf;\newline//	fprintf(stderr, &quotalgo:%u\\n&quot, *ptr);\newline	switch(*ptr)\newline	{\newline		case CMPH_CHM:\newline			return chm_search_packed(++ptr, key, keylen);\newline		case CMPH_BMZ: /* included -- Fabiano */\newline			return bmz_search_packed(++ptr, key, keylen);\newline		case CMPH_BMZ8: /* included -- Fabiano */\newline			return bmz8_search_packed(++ptr, key, keylen);\newline		case CMPH_BRZ: /* included -- Fabiano */\newline			return brz_search_packed(++ptr, key, keylen);\newline		case CMPH_FCH: /* included -- Fabiano */\newline			return fch_search_packed(++ptr, key, keylen);\newline		case CMPH_BDZ: /* included -- Fabiano */\newline			return bdz_search_packed(++ptr, key, keylen);\newline		case CMPH_BDZ_PH: /* included -- Fabiano */\newline			return bdz_ph_search_packed(++ptr, key, keylen);\newline		case CMPH_CHD_PH: /* included -- Fabiano */\newline			return chd_ph_search_packed(++ptr, key, keylen);\newline		case CMPH_CHD: /* included -- Fabiano */\newline			return chd_search_packed(++ptr, key, keylen);\newline		default:\newline			assert(0);\newline	}\newline	return 0; // FAILURE\newline}\newline","cmph_uint32 cmph_search(void packed_mphf, const char key, cmph_uint32 keylen);\newline \\brief Use the packed mphf to do a search.\newline \\param packed_mphf pointer to the packed mphf\newline \\param key key to be hashed\newline \\param keylen key legth in bytes\newline \\return The mphf value\newline \newline",5980608,pat_unwind.c,"boolean_t pat_unwind(\newline	int		*count,\newline	struct leaf	*leaves,\newline	int		leaf_num,\newline	int		*total_min,\newline	int		*total_max,\newline	int		min[],\newline	int		max[],\newline	int		size[],\newline	int		altmin,\newline	int		altmax,\newline	boolean_t	*last_infinite_ptr,\newline	uint4		**fstchar_ptr,\newline	uint4		**outchar_ptr,\newline	uint4		**lastpatptr_ptr)\newline{\newline	pat_strlit	strlit;\newline	uint4		pattern_mask;\newline	int		minim, maxim, leaf_cnt, charpos, offset, atom_map;\newline	boolean_t	infinite;\newline\newline	assert(MAX_SYM &gt leaf_num);\newline	for (atom_map = *count, leaf_cnt = 0; leaf_cnt &lt leaf_num; atom_map++)\newline	{\newline		infinite = leaves-&gtnullable[leaf_cnt];\newline		if (!(leaves-&gtletter[leaf_cnt][0] &amp DFABIT))\newline		{\newline			pattern_mask = PATM_STRLIT;\newline			for (offset = 0; offset &lt size[atom_map]; offset += charpos)\newline			{\newline				for (charpos = 0; leaves-&gtletter[leaf_cnt][charpos] &gt= 0; charpos++)\newline				{\newline					assert((SIZEOF(strlit.buff) / SIZEOF(strlit.buff[0])) &gt (offset + charpos));\newline					strlit.buff[offset + charpos] = leaves-&gtletter[leaf_cnt][charpos];\newline				}\newline				leaf_cnt++;\newline			}\newline		} else\newline		{\newline			pattern_mask = 0;\newline			for (charpos = 0; leaves-&gtletter[leaf_cnt][charpos] &gt= 0; charpos++)\newline			{\newline				assert(MAX_DFA_STRLEN &gt charpos);\newline				pattern_mask |= leaves-&gtletter[leaf_cnt][charpos];\newline			}\newline			leaf_cnt++;\newline		}\newline		minim = min[atom_map];\newline		maxim = max[atom_map];\newline		leaf_cnt += MAX(minim - 1, 0) * size[atom_map];\newline		strlit.bytelen = offset;\newline 		/* Since multi-byte characters currently dont go through DFA logic, the bytelen is guaranteed to be charlen */\newline 		strlit.charlen = offset;\newline		/* Since non-ascii characters in strings currently dont go through DFA logic, it is guaranteed to be an ascii\newline		 * string with no badchars */\newline		strlit.flags = 0;\newline		if ((MAX_PATTERN_ATOMS &lt= *count)\newline				|| !add_atom(count, pattern_mask, &ampstrlit, infinite,\newline					&ampmin[*count], &ampmax[*count], &ampsize[*count], total_min, total_max,\newline					minim, maxim, altmin, altmax, last_infinite_ptr, fstchar_ptr, outchar_ptr, lastpatptr_ptr))\newline			return FALSE;\newline	}\newline	return TRUE;\newline}\newline","This procedure is part of the MUMPS compiler. Under certain circumstances, procedure patstr will decide that a\newline pattern is a candidate for optimized processing using a DFA method. In such cases, procedure dfa_calc is called\newline to compile the instructions for do_pattern to execute the DFA evaluation. When, later, either dfa_calc or patstr\newline decides that the rest of the pattern invalidates the DFA strategy, this procedure is called to undo the compilation\newline for the DFA engine and build the data that would &quotnormally&quot have been compiled for the pattern segment in question.\newline \newline",782868,qrq.c,"static int calc_score (char * realcall, char * input, int spd, char * output) {\newline	int i,x,m=0;\newline\newline	x = strlen(realcall);\newline\newline	if (strcmp(input, realcall) == 0) {		 /* exact match! */\newline		output[0]=&#039*&#039;						/* * == OK, no mistake */\newline		output[1]=&#039\\0&#039;	\newline		if (speed &gt maxspeed) {maxspeed = speed;}\newline		if (!fixspeed) speed += 10;\newline		if (attemptvalid) {\newline			return 2*x*spd;						/* score */\newline		}\newline		else {\newline			return 0;\newline		}\newline	}\newline	else {									/* assemble error string */\newline		errornr += 1;\newline		if (strlen(input) &gt= x) {x =  strlen(input);}\newline		for (i=0;i &lt x;i++) {\newline			if (realcall[i] != input[i]) {\newline				m++;								/* mistake! */\newline				output[i] = tolower(input[i]);		/* print as lower case */\newline			}\newline			else {\newline				output[i] = input[i];\newline			}\newline		}\newline		output[i]=&#039\\0&#039;\newline		if ((speed &gt 29) &amp&amp !fixspeed) {speed -= 10;}\newline\newline		/* score when 1-3 mistakes was made */\newline		if ((m &lt 4) &amp&amp attemptvalid) {\newline			return (int) (2*x*spd)/(5*m);\newline		}\newline		else {return 0;};\newline	}\newline}\newline","calculate score depending on number of errors and speed.\newline writes the correct call and entered call with highlighted errors to output\newline and returns the score for this call\newline \newline in training modes (unlimited attempts, f6, fixed speed), no points.\newline \newline",2214765,zmalloc.c,float zmalloc_get_fragmentation_ratio(void) {\newline    return (float)zmalloc_get_rss()/zmalloc_used_memory();\newline}\newline,Fragmentation = RSS / allocated-bytes \newline,5209011,mcs-mutex.c,"int MCS_Mutex_create(int tail_rank, MPI_Comm comm, MCS_Mutex * hdl_out)\newline{\newline    int rank, nproc;\newline    MCS_Mutex hdl;\newline\newline    hdl = malloc(sizeof(struct mcs_mutex_s));\newline    assert(hdl != NULL);\newline\newline    MPI_Comm_dup(comm, &amphdl-&gtcomm);\newline\newline    MPI_Comm_rank(hdl-&gtcomm, &amprank);\newline    MPI_Comm_size(hdl-&gtcomm, &ampnproc);\newline\newline    hdl-&gttail_rank = tail_rank;\newline\newline#ifdef USE_WIN_SHARED\newline    MPI_Win_allocate_shared(2*sizeof(int), sizeof(int), MPI_INFO_NULL,\newline                            hdl-&gtcomm, &amphdl-&gtbase, &amphdl-&gtwindow);\newline#else\newline#ifdef USE_WIN_ALLOC_SHM\newline    MPI_Info_create(&amphdl-&gtwin_info);\newline    MPI_Info_set(hdl-&gtwin_info, &quotalloc_shm&quot, &quottrue&quot);\newline#else\newline    MPI_Info_create(&amphdl-&gtwin_info);\newline    MPI_Info_set(hdl-&gtwin_info, &quotalloc_shm&quot, &quotfalse&quot);\newline#endif\newline    MPI_Win_allocate(2*sizeof(int), sizeof(int), hdl-&gtwin_info, hdl-&gtcomm,\newline                     &amphdl-&gtbase, &amphdl-&gtwindow);\newline#endif\newline\newline    MPI_Win_lock_all(0, hdl-&gtwindow);\newline\newline    hdl-&gtbase[0] = MPI_PROC_NULL;\newline    hdl-&gtbase[1] = MPI_PROC_NULL;\newline\newline    MPI_Win_sync(hdl-&gtwindow);\newline    MPI_Barrier(hdl-&gtcomm);\newline\newline    *hdl_out = hdl;\newline    return MPI_SUCCESS;\newline}\newline",Create an MCS mutex. Collective on comm.\newline \newline @param[out] comm communicator containing all processes that will use the\newline mutex\newline @param[out] tail_rank rank of the process in comm that holds the tail\newline pointer\newline @param[out] hdl handle to the mutex\newline @return MPI status\newline \newline,3784935,md5.c,void	md5_init(md5_t *md5_p)\newline{\newline  md5_p-&gtmd_A = 0x67452301;\newline  md5_p-&gtmd_B = 0xefcdab89;\newline  md5_p-&gtmd_C = 0x98badcfe;\newline  md5_p-&gtmd_D = 0x10325476;\newline\newline  md5_p-&gtmd_total[0] = 0;\newline  md5_p-&gtmd_total[1] = 0;\newline  md5_p-&gtmd_buf_len = 0;\newline}\newline,"\newline md5_init\newline \newline DESCRIPTION:\newline \newline Initialize structure containing state of MD5 computation. (RFC 1321,\newline 3.3: Step 3). This is for progressive MD5 calculations only. If\newline you have the complete string available, md5_buffer should be used.\newline md5_process should be called for each bunch of bytes and after the\newline last process call, md5_finish should be called to get the\newline signature.\newline \newline RETURNS:\newline \newline None.\newline \newline ARGUMENTS:\newline \newline md5_p - Pointer to md5 structure that we are initializing.\newline \newline",5790306,pk_vector.c,"void vector_realloc(numint_t** pq, size_t size, size_t nsize)\newline{\newline  size_t i;\newline  numint_t* q;\newline  numint_t* nq;\newline\newline  q = *pq;\newline  for (i=nsize; i&ltsize; i++){\newline    numint_clear(q[i]);\newline  }\newline  nq = realloc(q, nsize*sizeof(numint_t));\newline  for (i=size; i&ltnsize; i++){\newline    numint_init(nq[i]);\newline  }\newline  *pq = nq;\newline}\newline","Reallocation function, to change the dimension \newline",2838475,cpufreqd_programs.c,"static TNODE * new_tnode(void) {\newline	TNODE *ret = (TNODE *)calloc(1, sizeof(TNODE));\newline	return ret;\newline}\newline",create a new node obj \newline,1480326,storemodel.cpp,StoreModel::StoreModel() { fs = NULL; }\newline,\newline @brief StoreModel::StoreModel\newline SubClass of QSortFilterProxyModel via\newline http://www.qtcentre.org/threads/46471-QTreeView-Filter\newline \newline,5402839,servers.c,"tld_t *tld_add(const char *name)\newline{\newline        tld_t *tld;\newline        mowgli_node_t *n = mowgli_node_create();\newline\newline        slog(LG_DEBUG, &quottld_add(): %s&quot, name);\newline\newline        tld = mowgli_heap_alloc(tld_heap);\newline\newline        mowgli_node_add(tld, n, &amptldlist);\newline\newline        tld-&gtname = sstrdup(name);\newline\newline        cnt.tld++;\newline\newline        return tld;\newline}\newline","\newline tld_add(const char name)\newline \newline TLD object factory.\newline \newline Inputs:\newline - name of TLD to cache as an object\newline \newline Outputs:\newline - on success, a TLD object\newline - on failure, NULL\newline \newline Side Effects:\newline - the TLD object is registered with the TLD list.\newline \newline",713837,smpte.c,"long int frame_to_vf(SMPTEFrame *f, FrameRate *fps) {\newline	int hours =	(f-&gthoursUnits + f-&gthoursTens*10);\newline	int minutes = (f-&gtminsUnits + f-&gtminsTens*10);\newline	int seconds = (f-&gtsecsUnits + f-&gtsecsTens*10);\newline	int frames = (f-&gtframeUnits + f-&gtframeTens*10);\newline	\newline	return FR_smpte2vf(fps, frames, seconds, minutes, hours, 0);\newline}\newline",convert SMPTEFrame into video-frame number (zero-based).\newline \newline,1565988,md5.c,"transform( MD5_CONTEXT *ctx, byte *data )\newline{\newline    u32 correct_words[16];\newline    register u32 A = ctx-&gtA;\newline    register u32 B = ctx-&gtB;\newline    register u32 C = ctx-&gtC;\newline    register u32 D = ctx-&gtD;\newline    u32 *cwp = correct_words;\newline    int i;\newline    byte *p1;\newline\newline    for(i=0, p1=data; i &lt 16; i++, p1 += 4)\newline	correct_words[i] = p1[0] | (p1[1] &lt&lt 8) | (p1[2] &lt&lt 16) | (p1[3] &lt&lt 24);\newline\newline#define OP(a, b, c, d, s, T)					    \\\newline  do								    \\\newline    {								    \\\newline      a += FF (b, c, d) + (*cwp++) + T; 	    \\\newline      a = rol(a, s);						    \\\newline      a += b;							    \\\newline    }								    \\\newline  while (0)\newline\newline    /* Before we start, one word about the strange constants.\newline       They are defined in RFC 1321 as\newline\newline       T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\newline     */\newline\newline    /* Round 1.  */\newline    OP (A, B, C, D,  7, 0xd76aa478);\newline    OP (D, A, B, C, 12, 0xe8c7b756);\newline    OP (C, D, A, B, 17, 0x242070db);\newline    OP (B, C, D, A, 22, 0xc1bdceee);\newline    OP (A, B, C, D,  7, 0xf57c0faf);\newline    OP (D, A, B, C, 12, 0x4787c62a);\newline    OP (C, D, A, B, 17, 0xa8304613);\newline    OP (B, C, D, A, 22, 0xfd469501);\newline    OP (A, B, C, D,  7, 0x698098d8);\newline    OP (D, A, B, C, 12, 0x8b44f7af);\newline    OP (C, D, A, B, 17, 0xffff5bb1);\newline    OP (B, C, D, A, 22, 0x895cd7be);\newline    OP (A, B, C, D,  7, 0x6b901122);\newline    OP (D, A, B, C, 12, 0xfd987193);\newline    OP (C, D, A, B, 17, 0xa679438e);\newline    OP (B, C, D, A, 22, 0x49b40821);\newline\newline#undef OP\newline#define OP(f, a, b, c, d, k, s, T)  \\\newline    do								      \\\newline      { 							      \\\newline	a += f (b, c, d) + correct_words[k] + T;		      \\\newline	a = rol(a, s);						      \\\newline	a += b; 						      \\\newline      } 							      \\\newline    while (0)\newline\newline    /* Round 2.  */\newline    OP (FG, A, B, C, D,  1,  5, 0xf61e2562);\newline    OP (FG, D, A, B, C,  6,  9, 0xc040b340);\newline    OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\newline    OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);\newline    OP (FG, A, B, C, D,  5,  5, 0xd62f105d);\newline    OP (FG, D, A, B, C, 10,  9, 0x02441453);\newline    OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\newline    OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);\newline    OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);\newline    OP (FG, D, A, B, C, 14,  9, 0xc33707d6);\newline    OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);\newline    OP (FG, B, C, D, A,  8, 20, 0x455a14ed);\newline    OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);\newline    OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);\newline    OP (FG, C, D, A, B,  7, 14, 0x676f02d9);\newline    OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\newline\newline    /* Round 3.  */\newline    OP (FH, A, B, C, D,  5,  4, 0xfffa3942);\newline    OP (FH, D, A, B, C,  8, 11, 0x8771f681);\newline    OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\newline    OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\newline    OP (FH, A, B, C, D,  1,  4, 0xa4beea44);\newline    OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);\newline    OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);\newline    OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\newline    OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);\newline    OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);\newline    OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);\newline    OP (FH, B, C, D, A,  6, 23, 0x04881d05);\newline    OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);\newline    OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\newline    OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\newline    OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);\newline\newline    /* Round 4.  */\newline    OP (FI, A, B, C, D,  0,  6, 0xf4292244);\newline    OP (FI, D, A, B, C,  7, 10, 0x432aff97);\newline    OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\newline    OP (FI, B, C, D, A,  5, 21, 0xfc93a039);\newline    OP (FI, A, B, C, D, 12,  6, 0x655b59c3);\newline    OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);\newline    OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\newline    OP (FI, B, C, D, A,  1, 21, 0x85845dd1);\newline    OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);\newline    OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\newline    OP (FI, C, D, A, B,  6, 15, 0xa3014314);\newline    OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\newline    OP (FI, A, B, C, D,  4,  6, 0xf7537e82);\newline    OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\newline    OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);\newline    OP (FI, B, C, D, A,  9, 21, 0xeb86d391);\newline\newline    /* Put checksum in context given as argument.  */\newline    ctx-&gtA += A;\newline    ctx-&gtB += B;\newline    ctx-&gtC += C;\newline    ctx-&gtD += D;\newline}\newline","transform( MD5_CONTEXT ctx, const void buffer, size_t len ) \newline",1418983,h5reader.c,void _NclFree_HDF5dataset_list(NclHDF5dataset_list_t *NclHDF5dataset_list)\newline{\newline    NclHDF5dataset_list_t  *curHDF5dataset_list;\newline\newline    while(NclHDF5dataset_list)\newline    {\newline        curHDF5dataset_list = NclHDF5dataset_list;\newline        NclHDF5dataset_list = curHDF5dataset_list-&gtnext;\newline        curHDF5dataset_list-&gtnext = NULL;\newline\newline        if(curHDF5dataset_list-&gtdataset_node)\newline        {\newline            if(curHDF5dataset_list-&gtdataset_node-&gtattr_list)\newline                _NclFree_HDF5attr_list(curHDF5dataset_list-&gtdataset_node-&gtattr_list);\newline\newline            free(curHDF5dataset_list-&gtdataset_node);\newline        }\newline        free(curHDF5dataset_list);\newline    }\newline}\newline,"\newline \newline Function: _NclFree_HDF5dataset_list\newline \newline Purpose: Free NclHDF5dataset_list\newline \newline Return: void\newline \newline Programmer: Wei Huang\newline Created: July 2, 2009\newline \newline \newline \newline",5923796,redis_array_impl.c,"static void zval_rehash_callback(zend_fcall_info *z_cb, zend_fcall_info_cache *z_cb_cache,\newline	const char *hostname, long count, zval *z_ret TSRMLS_DC) {\newline\newline    zval z_args[2];\newline\newline    ZVAL_STRING(&ampz_args[0], hostname);\newline    ZVAL_LONG(&ampz_args[1], count);\newline\newline#if (PHP_MAJOR_VERSION &lt 7)\newline    zval *z_host = &ampz_args[0], *z_count = &ampz_args[1],\newline        **z_args_pp[2] = { &ampz_host, &ampz_count };\newline    z_cb-&gtparams = z_args_pp;\newline    z_cb-&gtretval_ptr_ptr = &ampz_ret;\newline#else\newline    z_cb-&gtparams = z_args;\newline    z_cb-&gtretval = z_ret;\newline#endif\newline	z_cb-&gtparam_count = 2;\newline	z_cb-&gtno_separation = 0;\newline\newline	/* run cb(hostname, count) */\newline	zend_call_function(z_cb, z_cb_cache TSRMLS_CC);\newline\newline	/* cleanup */\newline    zval_dtor(&ampz_args[0]);\newline#if (PHP_MAJOR_VERSION &lt 7)\newline    zval_ptr_dtor(&ampz_ret);\newline#endif\newline}\newline","callback with the current progress, with hostname and count \newline",2090820,matching.cpp,"int fftImagesMulti(float *fftImage1, float *fftImage2, int numRows, int numColls,\newline                   float *multi)\newline{\newline    int i, index, size;\newline    size = numRows * numColls;\newline    for (i = 0; i &lt size; i++)\newline    {\newline        index = 2 * i;\newline        multi[index] = fftImage1[index] * fftImage2[index] -\newline                       fftImage1[index + 1] * fftImage2[index + 1];\newline        multi[index + 1] = fftImage1[index] * fftImage2[index + 1] +\newline                           fftImage1[index + 1] * fftImage2[index];\newline    }\newline    return LATENT_SVM_OK;\newline}\newline","\newline// Computation multiplication of FFT images\newline//\newline// API\newline// int fftImagesMulti(float fftImage1, float fftImage2, int numRows, int numColls,\newlinefloat multi);\newline// INPUT\newline// fftImage1 - first fft image\newline// fftImage2 - second fft image\newline// (numRows, numColls) - image dimesions\newline// OUTPUT\newline// multi - multiplication\newline// RESULT\newline// Error status\newline \newline",5636665,serilut.c,"HYPRE_Int hypre_ExchangeStructuralUnions( DataDistType *ddist,\newline                    HYPRE_Int **structural_union,\newline                    hypre_PilutSolverGlobals *globals )\newline{ \newline  HYPRE_Int ierr=0, *recv_unions;\newline\newline  /* allocate space for receiving unions */\newline  recv_unions = hypre_CTAlloc( HYPRE_Int, nrows );\newline\newline  hypre_MPI_Allreduce( *structural_union, recv_unions, nrows, \newline                 HYPRE_MPI_INT, hypre_MPI_LOR, pilut_comm );\newline\newline  /* free and reallocate structural union so that is of local size */\newline  hypre_TFree( *structural_union );\newline  *structural_union = hypre_TAlloc( HYPRE_Int, lnrows );\newline\newline  hypre_memcpy_int( *structural_union, &amprecv_unions[firstrow], lnrows );\newline\newline  /* deallocate recv_unions */\newline  hypre_TFree( recv_unions );\newline\newline  return(ierr);\newline}\newline",\newline hypre_ExchangeStructuralUnions\newline Exchanges structural union vectors with other processors and produces\newline a vector the size of the number of locally stored rows that marks\newline whether any exterior processor has a nonzero in the column corresponding\newline to each row. This is used to determine if a local row might have to\newline update an off-processor row.\newline \newline,4492736,distance.c,"float distance(double lat1, double lon1, double lat2, double lon2,\newline               int units )\newline{\newline   double a,b,p,dtheta,d;\newline   double R[2] = { 3958.754, 6370.997 }\newline#ifndef PI\newline, PI=3.141592654\newline#endif\newline   ;\newline   double DEG2RAD=(PI/180.0), RAD2DEG=(180.0/PI);\newline\newline   if ((units&lt0)||(units&gt1)) units = 0;\newline\newline   if (lat1 &gt 90.0) lat1 -= 180.0;\newline   if (lat2 &gt 90.0) lat2 -= 180.0;\newline\newline   a = lat1*DEG2RAD;  /* Degrees must be converted to radians */\newline   b = lat2*DEG2RAD;\newline   p = fabs(lon1-lon2)*DEG2RAD;\newline   dtheta = (sin(a)*sin(b)) + (cos(a)*cos(b)*cos(p));\newline   dtheta = acos(dtheta)*RAD2DEG;   /* Compute arc distance in degrees */\newline   d = (dtheta*PI*R[units])/180.0;  /* Compute distance in miles or km */\newline   return (float)d;\newline}\newline","\newline \newline N distance\newline \newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Purpose:\newline P\newline This function computes the distance between two points on the\newline surface of the (spherical) earth. The points are specified in\newline geographic coordinates (lat1,lon1) and (lat2,lon2). The algorithm\newline used here is taken directly from ELEMENTS OF CARTOGRAPHY, 4e. -\newline Robinson, Sale, Morrison - John Wiley &amp Sons, Inc. - pp. 44-45.\newline Geometrically, the function computes the arc distance dtheta on\newline the sphere between two points A and B by the following formula:\newline \newline cos dtheta = (sin a sin b) + (cos a cos b cos p)\newline \newline where:\newline \newline dtheta = arc distance between A and B\newline a = latitude of A\newline b = latitude of B\newline p = degrees of longitude between A and B\newline \newline Once the arc distance is determined, it is converted into miles by\newline taking the ratio between the circumference of the earth (2 PI R) and\newline the number of degrees in a circle (360):\newline \newline distance in miles (d) arc distance in degrees (dtheta)\newline ------------------------------ = --------------------------------\newline earth&#039s circumference in miles earth&#039s circumference in degrees\newline \newline or\newline \newline d = (dtheta (2 PI R)) / 360 =&gt\newline d = (dtheta PI R)/180\newline \newline The calculated distance is also referred to as the Great Circle.\newline \newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Parameters:\newline A\newline lat1 &ltinput&gt == (double) latitude of point A.\newline lon1 &ltinput&gt == (double) longitude of point A.\newline lat2 &ltinput&gt == (double) latitude of point B.\newline lon2 &ltinput&gt == (double) longitude of point B.\newline units &ltinput&gt == (int) flag to indicate output distance units.\newline 0 -&gt Miles, 1 -&gt Kilometers\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline History:\newline H\newline Barry Michaels November 1990 Original Version DOS Turbo C\newline Added kilometers option - May 1991 - BJM\newline E\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,6138926,tpm_activate.c,"int main(int argc, char **argv)\newline{\newline\newline	char *szTpmPasswd = NULL;\newline	int tpm_len;\newline	TSS_HTPM hTpm;\newline	TSS_HPOLICY hTpmPolicy;\newline	TSS_BOOL bValue;\newline	int iRc = -1;\newline	struct option opts[] = { {&quotactive&quot, no_argument, NULL, &#039a&#039},\newline	{&quotinactive&quot, no_argument, NULL, &#039i&#039},\newline	{&quottemp&quot, no_argument, NULL, &#039t&#039},\newline	{&quotstatus&quot, no_argument, NULL, &#039s&#039},\newline	{&quotwell-known&quot, no_argument, NULL, &#039z&#039},\newline	};\newline	BYTE well_known[] = TSS_WELL_KNOWN_SECRET;\newline\newline        initIntlSys();\newline\newline	if (genericOptHandler\newline	    (argc, argv, &quotaitsz&quot, opts,\newline	     sizeof(opts) / sizeof(struct option), parse, help) != 0)\newline		goto out;\newline\newline	if (contextCreate(&amphContext) != TSS_SUCCESS)\newline		goto out;\newline\newline	if (contextConnect(hContext) != TSS_SUCCESS)\newline		goto out_close;\newline\newline	if (contextGetTpm(hContext, &amphTpm) != TSS_SUCCESS)\newline		goto out_close;\newline\newline	switch(request) {\newline	case STATUS_CHECK:\newline		logInfo(_(&quotChecking status:\\n&quot));\newline		if (isWellKnown){\newline			szTpmPasswd = (char *)well_known;\newline			tpm_len = sizeof(well_known);\newline		} else {\newline			szTpmPasswd = GETPASSWD(_(&quotEnter owner password: &quot), &amptpm_len, FALSE);\newline			if (!szTpmPasswd) {\newline				logMsg(_(&quotFailed to get password\\n&quot));\newline				goto out_close;\newline			}\newline		}\newline\newline		if (policyGet(hTpm, &amphTpmPolicy) != TSS_SUCCESS)\newline			goto out_close;\newline\newline		if (policySetSecret\newline		    (hTpmPolicy, tpm_len,\newline		     (BYTE *)szTpmPasswd) != TSS_SUCCESS)\newline			goto out_close;\newline		if (tpmGetStatus\newline		    (hTpm, TSS_TPMSTATUS_PHYSICALSETDEACTIVATED,\newline		     &ampbValue) != TSS_SUCCESS)\newline			goto out_close;\newline		logMsg(_(&quotPersistent Deactivated Status: %s\\n&quot),\newline		       logBool(mapTssBool(bValue)));\newline\newline		if (tpmGetStatus\newline		    (hTpm, TSS_TPMSTATUS_SETTEMPDEACTIVATED, &ampbValue))\newline			goto out_close;\newline		logMsg(_(&quotVolatile Deactivated Status: %s\\n&quot),\newline		       logBool(mapTssBool(bValue)));\newline		break;\newline	case ACTIVATE:\newline		if (tpmSetStatus(hTpm, TSS_TPMSTATUS_PHYSICALSETDEACTIVATED, FALSE) != TSS_SUCCESS)\newline			goto out_close;\newline		logMsg(_(&quotAction requires a reboot to take effect\\n&quot));\newline		break;\newline	case DEACTIVATE:\newline		if (tpmSetStatus(hTpm, TSS_TPMSTATUS_PHYSICALSETDEACTIVATED, TRUE) != TSS_SUCCESS)\newline			goto out_close;\newline		logMsg(_(&quotAction requires a reboot to take effect\\n&quot));\newline		break;\newline	case TEMP_DEACTIVATE:\newline		if (tpmSetStatus(hTpm, TSS_TPMSTATUS_SETTEMPDEACTIVATED, TRUE) != TSS_SUCCESS)\newline			goto out_close;\newline		break;\newline	}\newline\newline	//Command successful\newline	iRc = 0;\newline	logSuccess(argv[0]);\newline	//Cleanup\newline      out_close:\newline	if (szTpmPasswd &amp&amp !isWellKnown)\newline		shredPasswd(szTpmPasswd);\newline\newline	contextClose(hContext);\newline\newline      out:\newline	return iRc;\newline}\newline",\newline Affect: Change state of TPM between Active and Inactive\newline Default: report status\newline Requires: Physical presence unless --temp specified\newline \newline,,,on,,,on,on,,on,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,Translates an ISO accentuated string to an MS-DOS one.,create a new node obj,{},name of TLD to cache as an object,convert SMPTEFrame into video-frame number (zero-based).,{},{},"callback with the current progress, with hostname and count",{},Exchanges structural union vectors,This function computes the distance between two points,Parse a modify urls request and either:,Load an image from the named file.,Change state of TPM between Active and Inactive,{},This procedure is part of the MUMPS compiler.,calculate score depending on number of errors and speed.,Fragmentation = RSS / allocated-bytes,Create an MCS mutex. Collective on comm.,Pointer to md5 structure that we are initializing.,"Reallocation function, to change the dimension",x,
3NFWQRSHVEEVXYUX5IYFEY15MHXFGW,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:15 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:15 PDT 2019,,,3RXPCZQMQPB6U3XIOLOVEFT032X1GK,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:47 PDT 2019,Fri Apr 26 13:07:59 PDT 2019,Sun Apr 28 13:07:59 PDT 2019,,,,1212,100% (62/62),100% (62/62),0% (0/0),5256646,board.cpp,"void Board::updateStone(StoneColor c, int x, int y, bool dead)\newline{\newline    Stone *stone = stones-&gtvalue(coordsToKey(x, y),NULL);\newline    //if ((stone == NULL) &amp ((c == stoneBlack) || (c == stoneWhite)))\newline\newline	switch (c)\newline	{\newline	case stoneBlack:\newline	case stoneWhite:\newline		if (stone == NULL)\newline		{\newline            stone = new Stone(imageHandler-&gtgetStonePixmaps(), canvas, c, x, y,true);\newline            stone-&gtsetPos(offsetX + square_size * (x - 1) - stone-&gtpixmap().width()/2,\newline                offsetY + square_size * (y - 1) - stone-&gtpixmap().height()/2 );\newline            stones-&gtinsert(coordsToKey(x,y) , stone);\newline            break;\newline        }\newline\newline        if (stone-&gtgetColor() != c)\newline            stone-&gtsetColor(c);\newline		\newline		// We need to check wether the stones have been toggled dead or seki before (scoring mode)\newline		if ((stone-&gtisDead() || stone-&gtisSeki()) &amp&amp !dead)\newline		{\newline			stone-&gttogglePixmap(imageHandler-&gtgetStonePixmaps(), true);\newline			stone-&gtsetDead(false);\newline		}\newline		\newline		if ((!stone-&gtisDead()) &amp&amp dead)\newline		{\newline			stone-&gttogglePixmap(imageHandler-&gtgetGhostPixmaps(), false);\newline			stone-&gtsetDead();\newline		}\newline\newline        if (!stone-&gtisVisible())\newline            stone-&gtshow();\newline\newline		break;\newline		\newline		\newline	case stoneNone:\newline	case stoneErase:\newline		if (stone &amp&amp stone-&gtisVisible())\newline		{\newline            stone-&gthide();\newline		}\newline		break;\newline		\newline	default:\newline		qWarning(&quotBad data &lt%d&gt at %d/%d in board::updateStone !&quot,\newline			c, x, y);\newline	}\newline}\newline",\newline Synchronize the board with the given stone color and coordinates\newline This is usually called by boardhandler when scanning a matrix.\newline \newline,3503557,inotifytools.c,"struct inotify_event * inotifytools_next_event( int timeout ) {\newline	return inotifytools_next_events( timeout, 1 );\newline}\newline","\newline Get the next inotify event to occur.\newline \newline inotifytools_initialize() must be called before this function can\newline be used.\newline \newline @param timeout maximum amount of time, in seconds, to wait for an event.\newline If @a timeout is 0, the function is non-blocking. If\newline @a timeout is negative, the function will block until an\newline event occurs.\newline \newline @return pointer to an inotify event, or NULL if function timed out before\newline an event occurred. The event is located in static storage and it\newline may be overwritten in subsequent calls; do not call free() on it,\newline and make a copy if you want to keep it.\newline \newline @note Your program should call this function or\newline inotifytools_next_events() frequently; between calls to this function,\newline inotify events will be queued in the kernel, and eventually the queue\newline will overflow and you will miss some events.\newline \newline @note If the function inotifytools_ignore_events_by_regex() has been called\newline with a non-NULL parameter, this function will not return on events\newline which match the regular expression passed to that function. However,\newline the @a timeout period begins again each time a matching event occurs.\newline \newline",2267066,sdl.c,"void Sdl_UnDim(int steps, int delay, int trp)\newline{\newline#ifndef NODIM\newline    SDL_Surface    *buffer;\newline    int per_step = trp / steps;\newline    int i;\newline    if (trm_gm) return;\newline    buffer = SS_Crt(sdl.scr-&gtw, sdl.scr-&gth, SDL_SWSURFACE);\newline    SDL_SetColorKey(buffer, 0, 0);\newline    D_FDST(buffer);\newline    D_FSRC(sdl.scr);\newline    SS_Blt();\newline    for (i = trp; i &gt= 0; i -= per_step) {\newline        D_FDST(sdl.scr);\newline        SS_Fill(0x0);\newline        D_FSRC(buffer);\newline        SS_ABlt(i);\newline        Sdl_FUpd();\newline        SDL_Delay(delay);\newline    }\newline    D_FDST(sdl.scr);\newline    D_FSRC(buffer);\newline    SS_Blt();\newline    Sdl_FUpd();\newline    SDL_FreeSurface(buffer);\newline#else\newline    Sdl_FUpd();\newline#endif\newline}\newline",\newlineundim screen\newline \newline,1793640,ini.c,"int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,\newline                     void* user)\newline{\newline    /* Uses a fair bit of stack (use heap instead if you need to) */\newline#if INI_USE_STACK\newline    char line[INI_MAX_LINE];\newline#else\newline    char* line;\newline#endif\newline    char section[MAX_SECTION] = &quot&quot;\newline    char prev_name[MAX_NAME] = &quot&quot;\newline\newline    char* start;\newline    char* end;\newline    char* name;\newline    char* value;\newline    int lineno = 0;\newline    int error = 0;\newline\newline#if !INI_USE_STACK\newline    line = (char*)malloc(INI_MAX_LINE);\newline    if (!line) {\newline        return -2;\newline    }\newline#endif\newline\newline    /* Scan through stream line by line */\newline    while (reader(line, INI_MAX_LINE, stream) != NULL) {\newline        lineno++;\newline\newline        start = line;\newline#if INI_ALLOW_BOM\newline        if (lineno == 1 &amp&amp (unsigned char)start[0] == 0xEF &amp&amp\newline                           (unsigned char)start[1] == 0xBB &amp&amp\newline                           (unsigned char)start[2] == 0xBF) {\newline            start += 3;\newline        }\newline#endif\newline        start = lskip(rstrip(start));\newline\newline        if (*start == &#039;&#039 || *start == &#039#&#039) {\newline            /* Per Python ConfigParser, allow &#039#&#039 comments at start of line */\newline        }\newline#if INI_ALLOW_MULTILINE\newline        else if (*prev_name &amp&amp *start &amp&amp start &gt line) {\newline            /* Non-black line with leading whitespace, treat as continuation\newline               of previous name&#039s value (as per Python ConfigParser). */\newline            if (!handler(user, section, prev_name, start) &amp&amp !error)\newline                error = lineno;\newline        }\newline#endif\newline        else if (*start == &#039[&#039) {\newline            /* A &quot[section]&quot line */\newline            end = find_char_or_comment(start + 1, &#039]&#039);\newline            if (*end == &#039]&#039) {\newline                *end = &#039\\0&#039;\newline                strncpy0(section, start + 1, sizeof(section));\newline                *prev_name = &#039\\0&#039;\newline            }\newline            else if (!error) {\newline                /* No &#039]&#039 found on section line */\newline                error = lineno;\newline            }\newline        }\newline        else if (*start &amp&amp *start != &#039;&#039) {\newline            /* Not a comment, must be a name[=:]value pair */\newline            end = find_char_or_comment(start, &#039=&#039);\newline            if (*end != &#039=&#039) {\newline                end = find_char_or_comment(start, &#039:&#039);\newline            }\newline            if (*end == &#039=&#039 || *end == &#039:&#039) {\newline                *end = &#039\\0&#039;\newline                name = rstrip(start);\newline                value = lskip(end + 1);\newline                end = find_char_or_comment(value, &#039\\0&#039);\newline                if (*end == &#039;&#039)\newline                    *end = &#039\\0&#039;\newline                rstrip(value);\newline\newline                /* Valid name[=:]value pair found, call handler */\newline                strncpy0(prev_name, name, sizeof(prev_name));\newline                if (!handler(user, section, name, value) &amp&amp !error)\newline                    error = lineno;\newline            }\newline            else if (!error) {\newline                /* No &#039=&#039 or &#039:&#039 found on name[=:]value line */\newline                error = lineno;\newline            }\newline        }\newline\newline#if INI_STOP_ON_FIRST_ERROR\newline        if (error)\newline            break;\newline#endif\newline    }\newline\newline#if !INI_USE_STACK\newline    free(line);\newline#endif\newline\newline    return error;\newline}\newline",See documentation in header file. \newline,85433,str.c,GLOBAL void my_strlwr ( char *string )\newline{\newline#if HAVE_STRLWR\newline	strlwr(string);\newline#else\newline	size_t i;\newline	if (string[0]==EOS)\newline	{	return;\newline	}\newline	\newline	for (i=0; i&ltstrlen(string); i++)\newline	{	if ( string[i]&gt=&#039A&#039 &amp&amp string[i]&lt=&#039Z&#039 )\newline		{\newline			string[i] = (char)tolower(string[i]);\newline		}\newline	}\newline#endif\newline}	/* my_strlwr */\newline,----------------------------------------------\newline String in Kleinbuchstaben umwandeln\newline ---------------------------------------------- \newline,1125170,marshal.c,"static svn_error_t *writebuf_flush(svn_ra_svn_conn_t *conn, apr_pool_t *pool)\newline{\newline  apr_size_t write_pos = conn-&gtwrite_pos;\newline\newline  /* Clear conn-&gtwrite_pos first in case the block handler does a read. */\newline  conn-&gtwrite_pos = 0;\newline  SVN_ERR(writebuf_output(conn, pool, conn-&gtwrite_buf, write_pos));\newline  return SVN_NO_ERROR;\newline}\newline",Write data from the write buffer out to the socket. \newline,4462950,gen_collate.c,"static unsigned int add_rule(weighted_item_t *wi)\newline{\newline	weight_t *w = wi-&gtweight;\newline	int i, j, r, n;\newline	uint16_t rbuf[MAX_COLLATION_WEIGHTS];\newline	uint16_t ws_buf[32];\newline	void *mm;\newline	char buf[32];\newline	const char *s;\newline	const char *e;\newline\newline	for (i=0 ; i &lt MAX_COLLATION_WEIGHTS ; i++) {\newline		rbuf[i] = rule2val[R_FORWARD]; /* set a default to forward-ignore */\newline	}\newline\newline	if (base_locale_array[base_locale_len].num_weights &lt w-&gtnum_weights) {\newline		base_locale_array[base_locale_len].num_weights = w-&gtnum_weights;\newline	}\newline\newline	for (i=0 ; i &lt w-&gtnum_weights ; i++) {\newline		assert(rule2val[(int)(w-&gtrule[i])] &gt= 0);\newline		assert(w-&gtcolitem[i] &amp&amp *w-&gtcolitem[i]);\newline		if (*w-&gtcolitem[i] == &#039&quot&#039) { /* string... */\newline			s = w-&gtcolitem[i] + 1;\newline			assert(*s == &#039&lt&#039);\newline			n = 0;\newline			do {\newline				e = s;\newline				do {\newline					if (*e == &#039/&#039) {\newline						e += 2;\newline						continue;\newline					}\newline				} while (*e++ != &#039&gt&#039);\newline				assert(((size_t)(e-s) &lt sizeof(buf)));\newline				memcpy(buf, s, (size_t)(e-s));\newline				buf[(size_t)(e-s)] = 0;\newline\newline				r = final_index_val_x(buf, wi-&gtsymbol);\newline				assert(n + 1 &lt sizeof(ws_buf)/sizeof(ws_buf[0]));\newline				ws_buf[n++] = r | rule2val[(int)(w-&gtrule[i])];\newline\newline				s = e;\newline			} while (*s != &#039&quot&#039);\newline			ws_buf[n++] = 0;	/* terminator */\newline\newline			mm = memmem(weightstr_buffer, weightstr_len*sizeof(weightstr_buffer[0]),\newline						ws_buf, n*sizeof(ws_buf[0]));\newline\newline			if (!mm) {\newline				assert(weightstr_len + n &lt WEIGHTSTR_LEN);\newline				memcpy(weightstr_buffer + weightstr_len, ws_buf, n*sizeof(ws_buf[0]));\newline				mm = weightstr_buffer + weightstr_len;\newline				weightstr_len += n;\newline			}\newline			r = (((uint16_t *)(mm)) - weightstr_buffer)\newline				+ base_locale_array[base_locale_len].max_col_index + 2;\newline			assert(r &lt (1 &lt&lt 14));\newline			rbuf[i] = r | rule2val[(int)(w-&gtrule[i])];\newline		} else {				/* item */\newline			r = final_index_val_x(w-&gtcolitem[i], wi-&gtsymbol);\newline			rbuf[i] = r | rule2val[(int)(w-&gtrule[i])];\newline		}\newline	}\newline\newline	for (i=0 ; i &lt ruletable_len ; i += MAX_COLLATION_WEIGHTS) {\newline		if (!memcmp(ruletable_buffer + i, rbuf, MAX_COLLATION_WEIGHTS*sizeof(ruletable_buffer[0]))) {\newline			return i/MAX_COLLATION_WEIGHTS;\newline		}\newline	}\newline\newline	memcpy(ruletable_buffer + ruletable_len, rbuf, MAX_COLLATION_WEIGHTS*sizeof(ruletable_buffer[0]));\newline	ruletable_len += MAX_COLLATION_WEIGHTS;\newline\newline	return  (ruletable_len / MAX_COLLATION_WEIGHTS)-1;\newline}\newline","store rule2val in 2 high bits and collation index in lower.\newline for sort strings, store (offset from base) + max colindex as index.\newline \newline",346427,hxindex.c,"static void save_index(const string indexdb, Indexterm terms)\newline{\newline  if (! (globalfile = fopen(indexdb, &quotw&quot)))\newline    errx(1, &quot%s: %s&quot, indexdb, strerror(errno));\newline  twalk(terms, save_a_term);\newline  fclose(globalfile);\newline}\newline",save_index -- write terms to file \newline,4587596,lbtable.c,"static void print_unknown_record (const struct lb_record *cmos_item)\newline { const char *data;\newline\newline   printf(&quot    UNKNOWN record at physical address 0x%lx:\\n&quot\newline          &quot        tag:  0x%x (decimal: %d)\\n&quot\newline          &quot        size: 0x%x (decimal: %d)\\n&quot\newline          &quot        data:\\n&quot,\newline          vtophys(cmos_item), cmos_item-&gttag, cmos_item-&gttag,\newline          cmos_item-&gtsize, cmos_item-&gtsize);\newline   data = ((const char *) cmos_item) + sizeof(*cmos_item);\newline   hexdump(data, cmos_item-&gtsize - sizeof(*cmos_item), vtophys(data), stdout,\newline           &ampformat);\newline }\newline",\newline print_unknown_record\newline \newline Display record of unknown type from CMOS option table.\newline \newline,2296005,strenc.c,"Int WriteImagePlaneHeader(CWMImageStrCodec * pSC)\newline{\newline    CWMImageInfo * pII = &amppSC-&gtWMII;\newline    CWMIStrCodecParam * pSCP = &amppSC-&gtWMISCP;\newline    BitIOInfo* pIO = pSC-&gtpIOHeader;\newline\newline    PUTBITS(pIO, (Int) pSC-&gtm_param.cfColorFormat, 3); // internal color format\newline    PUTBITS(pIO, (Int) pSC-&gtm_param.bScaledArith, 1); // lossless mode\newline\newline// subbands\newline    PUTBITS(pIO, (U32)pSCP-&gtsbSubband, 4);\newline\newline// color parameters\newline    switch (pSC-&gtm_param.cfColorFormat) {\newline        case YUV_420:\newline        case YUV_422:\newline        case YUV_444:\newline            PUTBITS(pIO, 0, 4);\newline            PUTBITS(pIO, 0, 4);\newline            break;\newline        case NCOMPONENT:\newline            PUTBITS(pIO, (Int) pSC-&gtm_param.cNumChannels - 1, 4);\newline            PUTBITS(pIO, 0, 4);\newline            break;\newline        default:\newline            break;\newline    }\newline\newline// float and 32s additional parameters\newline    switch (pII-&gtbdBitDepth) {\newline        case BD_16:\newline        case BD_16S:\newline            PUTBITS(pIO, pSCP-&gtnLenMantissaOrShift, 8);\newline            break;\newline        case BD_32:\newline        case BD_32S:\newline            if(pSCP-&gtnLenMantissaOrShift == 0)\newline                pSCP-&gtnLenMantissaOrShift = 10;//default\newline            PUTBITS(pIO, pSCP-&gtnLenMantissaOrShift, 8);\newline            break;\newline        case BD_32F:\newline            if(pSCP-&gtnLenMantissaOrShift == 0)\newline                pSCP-&gtnLenMantissaOrShift = 13;//default\newline            PUTBITS(pIO, pSCP-&gtnLenMantissaOrShift, 8);//float conversion parameters\newline            PUTBITS(pIO, pSCP-&gtnExpBias, 8);\newline            break;\newline        default:\newline            break;\newline    }\newline\newline        // quantization\newline    PUTBITS(pIO, (pSC-&gtm_param.uQPMode &amp 1) == 1 ? 0 : 1, 1); // DC frame uniform quantization?\newline    if((pSC-&gtm_param.uQPMode &amp 1) == 0)\newline        writeQuantizer(pSC-&gtpTile[0].pQuantizerDC, pIO, (pSC-&gtm_param.uQPMode &gt&gt 3) &amp 3, pSC-&gtm_param.cNumChannels, 0);\newline    if(pSC-&gtWMISCP.sbSubband != SB_DC_ONLY){\newline        PUTBITS(pIO, (pSC-&gtm_param.uQPMode &amp 0x200) == 0 ? 1 : 0, 1); // use DC quantization?\newline        if((pSC-&gtm_param.uQPMode &amp 0x200) != 0){\newline            PUTBITS(pIO, (pSC-&gtm_param.uQPMode &amp 2) == 2 ? 0 : 1, 1); // LP frame uniform quantization?\newline            if((pSC-&gtm_param.uQPMode &amp 2) == 0)\newline                writeQuantizer(pSC-&gtpTile[0].pQuantizerLP, pIO, (pSC-&gtm_param.uQPMode &gt&gt 5) &amp 3,  pSC-&gtm_param.cNumChannels, 0);\newline        }\newline\newline        if(pSC-&gtWMISCP.sbSubband != SB_NO_HIGHPASS){\newline            PUTBITS(pIO, (pSC-&gtm_param.uQPMode &amp 0x400) == 0 ? 1 : 0, 1); // use LP quantization?\newline            if((pSC-&gtm_param.uQPMode &amp 0x400) != 0){\newline                PUTBITS(pIO, (pSC-&gtm_param.uQPMode &amp 4) == 4 ? 0 : 1, 1); // HP frame uniform quantization?\newline                if((pSC-&gtm_param.uQPMode &amp 4) == 0)\newline                    writeQuantizer(pSC-&gtpTile[0].pQuantizerHP, pIO, (pSC-&gtm_param.uQPMode &gt&gt 7) &amp 3,  pSC-&gtm_param.cNumChannels, 0);\newline            }\newline        }\newline    }\newline\newline    fillToByte(pIO);  // remove this later\newline    return ICERR_OK;\newline}\newline",\newlineWrite header of image plane\newline \newline,3675512,pbzip2.cpp,"inline void safe_mutex_unlock(pthread_mutex_t *mutex)\newline{\newline	int ret = pthread_mutex_unlock(mutex);\newline	if (ret != 0)\newline	{\newline		fprintf(stderr, &quotpthread_mutex_unlock error [%d]! Aborting immediately!\\n&quot, ret);\newline		cleanupAndQuit(-6);\newline	}\newline}\newline",\newline Unlock mutex or exit application immediately on error.\newline \newline,2574703,jpilot.c,"gboolean jpilot_get_modified( JPilotFile *pilotFile ) {\newline	g_return_val_if_fail( pilotFile != NULL, FALSE );\newline	return jpilot_check_files( pilotFile );\newline}\newline",\newline Test whether file was modified since last access.\newline Return: TRUE if file was modified.\newline \newline,2225764,port.c,"int port(char *dev,u_long dst_ip,libnet_plist_t *plist_p,int lg)\newline{\newline   int c, build_ip, fr, fd ;\newline   libnet_t *l;\newline   libnet_ptag_t tcp;\newline   libnet_ptag_t t;\newline   struct timeval tv;\newline   struct servent *service;\newline   fd_set rfsd;\newline   int sd,close;\newline   struct libnet_tcp_hdr *Tcp;\newline   struct libnet_ipv4_hdr *ip;\newline   struct libnet_icmpv4_hdr *icmp;\newline   u_long src_ip;\newline   u_char *pkt;\newline   u_short bport, eport, cport;\newline   char errbuf[LIBNET_ERRBUF_SIZE];\newline   int lineh;\newline   //char *filter=&quotnot src host 62.10.127.46&quot;\newline   //char *filter=&quotnot src host 192.168.1.1&quot;\newline   lineh = 1;\newline   pkt = NULL;\newline   close = bport = eport = cport = t = fr = fd = 0;\newline\newline\newline   tm = time(NULL);\newline   /* per avere sia ora che data si pu usare %c, ma il compilatore tira fuori dei warning decisamente noiosi:)*/\newline   strftime(timed,60,&quot%b %d %T&quot,localtime(&amptm));\newline\newline   if (lg)\newline     {\newline	openfile();\newline	n_print (NULL,0,0,lg,&quotLogging to file... \\n&quot);\newline	fflush (stdout);\newline	n_print (NULL,0,0,lg,&quotNAST PORT SCAN REPORT\\n&quot);\newline	n_print (NULL,0,0,lg,&quotMade on %s\\n\\n&quot, timed);\newline     }\newline\newline#ifdef HAVE_LIBNCURSES\newline   if (graph)\newline     init_scr();\newline#endif\newline\newline/* demonize */\newline   if (demonize)\newline     {\newline	w_error(0,&quotIs very useless demonize me in checking banner! Omit&quot);\newline	demonize=0;\newline     }\newline\newline   n_print(&quotprinc&quot,lineh,2,lg,&quotWait for scanning...\\n\\n&quot);\newline   n_print(&quotprinc&quot,++lineh,2,lg,&quotState	       	Port		Services		Notes\\n\\n&quot);\newline   ++lineh;\newline   \newline   if(pcap_lookupnet(dev,&ampnetp,&ampmaskp,errbuf)==-1)\newline     {\newline     	w_error(1,&quotpcap_lookupnet() error %s\\n&quot,errbuf);\newline     } \newline\newline   if ((descr = pcap_open_live (dev, BUFSIZ, 0, 1, errbuf))==NULL)\newline     {\newline	w_error(1, &quotpcap_open_live() error: %s\\n&quot,errbuf);\newline     }\newline\newline   sd = pcap_fileno(descr);\newline\newline   if ((offset=(device(dev,descr)))==-1) return -1;\newline\newline   l = libnet_init(\newline		   LIBNET_RAW4,                            /* injection type */\newline		   dev,                                   /* network interface */\newline		   errbuf);                                /* errbuf */\newline\newline   if (l == NULL)\newline     {\newline        w_error(1, &quotlibnet_init() failed: %s&quot, errbuf);\newline     }\newline     \newline   if ((src_ip = libnet_get_ipaddr4(l))==-1)\newline     {\newline	w_error(1, &quotCan&#039t get local ip address : %s\\n&quot, libnet_geterror(l));\newline     }\newline     \newline   /*if(pcap_compile(descr,&ampfp,filter,0,netp) == -1)\newline	  {\newline	     if(w_error(0, &quotError in pcap_compile, insert a different filter\\n&quot)==-1)\newline	     	return(0);\newline	  }\newline	if(pcap_setfilter(descr,&ampfp) == -1)\newline	  {\newline	     w_error(1, &quotError calling pcap_setfilter\\n\\n&quot);\newline	  }*/\newline\newline   tcp = 0;\newline\newline   build_ip = 1;\newline\newline   while (libnet_plist_chain_next_pair(plist_p, &ampbport, &ampeport))\newline     {\newline        while (!(bport &gt eport) &amp&amp bport != 0)\newline	  {\newline	     cport = bport++;\newline	     tcp = libnet_build_tcp(\newline				    1050,                                    /* source port */\newline				    cport,                                    /* destination port */\newline				    0x01010101,                                 /* sequence number */\newline				    0,                                          /* acknowledgement num */\newline				    TH_SYN,                                     /* control flags */\newline				    32767,                                      /* window size */\newline				    0,                                          /* checksum */\newline				    0,                                          /* urgent pointer */\newline				    LIBNET_TCP_H,                               /* TCP packet size */\newline				    NULL,                                       /* payload */\newline				    0,                                          /* payload size */\newline				    l,                                          /* libnet handle */\newline				    tcp);                                         /* libnet id */\newline	     if (tcp == -1)\newline	       {\newline		  w_error(1, &quotCan&#039t build TCP header: %s\\n&quot, libnet_geterror(l));\newline	       }\newline\newline	     if (build_ip)\newline	       {\newline		  build_ip = 0;\newline		  t = libnet_build_ipv4(\newline					LIBNET_IPV4_H + LIBNET_TCP_H,               /* length */\newline					0,                                          /* TOS */\newline					242,                                        /* IP ID */\newline					0,                                          /* IP Frag */\newline					64,                                         /* TTL */\newline					IPPROTO_TCP,                                /* protocol */\newline					0,                                          /* checksum */\newline					src_ip,                                     /* source IP */\newline					dst_ip,                                     /* destination IP */\newline					NULL,                                       /* payload */\newline					0,                                          /* payload size */\newline					l,                                          /* libnet handle */\newline					0);\newline		  if (t == -1)\newline		    {\newline		       w_error(1, &quotCan&#039t build IP header: %s\\n&quot, libnet_geterror(l));\newline		    }\newline\newline	       }\newline\newline	       /* usleep con be omissed when scanned another linux box,but if u scan a openBSD\newline	       it must be uesed! otherwise it find drop rule that doesn&#039t exist!*/\newline	     //usleep(100);\newline	     usleep(900);\newline	     c = libnet_write(l);\newline	     if (c == -1)\newline	       {\newline		  w_error(1, &quotLibnet_write() Error: %s\\n&quot, libnet_geterror(l));\newline	       }\newline	       \newline\newline	    for(;;)\newline	       {\newline		  fflush (logd);\newline	          tv.tv_sec = 2;\newline		  //tv.tv_usec = 75000;\newline		  FD_ZERO (&amprfsd);\newline	          FD_SET (sd ,&amprfsd);\newline\newline		  if((pkt = (u_char *) pcap_next(descr,&amphdr))==NULL)\newline		  	{\newline			break;\newline			}\newline			\newline		  ip = (struct libnet_ipv4_hdr *) (pkt + offset);\newline		  icmp = (struct libnet_icmpv4_hdr *) (pkt + offset + LIBNET_IPV4_H);\newline		  Tcp = (struct libnet_tcp_hdr *) (pkt + offset + LIBNET_IPV4_H);\newline\newline		 \newline		  if (Tcp-&gtth_flags == (TH_RST|TH_ACK))\newline		    {\newline		       close++;\newline		       break;\newline		    }\newline		       \newline		  service = getservbyport(htons(cport), &quottcp&quot);\newline\newline		  if(ip-&gtip_p == IPPROTO_ICMP)\newline		    {\newline		       n_print(&quotprinc&quot,lineh,2,lg,&quotFiltered	%d		%s&quot,(cport), (service) ? service-&gts_name : &quotunknown&quot);\newline		       if(!graph || (graph &amp&amp lg)) fprintf(logd,&quot\\t\\t\\t&quot);\newline		       switch((icmp-&gticmp_type))\newline			 {\newline\newline			  case 3:\newline			    switch (icmp-&gticmp_code)\newline			      {\newline			       case 0:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotNetwork Unreachable(*)\\n&quot);\newline				 break;\newline			       case 1:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotHost Unreachable(*)\\n&quot);\newline				 break;\newline			       case 2:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotProtocol Unreachable(*)\\n&quot);\newline				 break;\newline			       case 3:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotPort Unreachable(*)\\n&quot);\newline				 break;\newline			       case 9:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotDestination network administratively prohibited(*)\\n&quot);\newline				 break;\newline			       case 10:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotDestination host administratively prohibited(*)\\n&quot);\newline				 break;\newline			       case 13:\newline				 n_print(&quotprinc&quot,lineh,56,lg,&quotComm. administratively prohibited(*)\\n&quot);\newline			      }\newline\newline			    break;\newline			  default:\newline			    n_print(&quotprinc&quot,lineh,56,lg,&quot%d(*)\\n&quot, icmp-&gticmp_type);\newline			    break;\newline			 }\newline		       fr++;\newline		       ++lineh;\newline		       break;\newline		    }\newline\newline\newline		  if (!select(sd+1, &amprfsd, NULL, NULL, &amptv))\newline		    {\newline		       n_print(&quotprinc&quot,lineh,2,lg,&quotFiltered	%d		%s&quot, (cport),(service) ? service-&gts_name : &quotunknown&quot);\newline		       if(!graph || (graph &amp&amp lg)) fprintf(logd,&quot\\t\\t\\t&quot);\newline		       n_print(&quotprinc&quot,lineh,56,lg,&quotSYN packet timeout(**)\\n&quot);\newline		       fd++;\newline		       ++lineh;\newline		       break;\newline		    }\newline\newline		  if (Tcp-&gtth_seq != 0 &amp&amp (Tcp-&gtth_flags == (TH_SYN|TH_ACK)))\newline		    {\newline		       n_print(&quotprinc&quot,lineh,2,lg,&quotOpen		%d		%s&quot, cport ,(service) ? service-&gts_name : &quotunknown&quot);\newline		       if(!graph || (graph &amp&amp lg)) fprintf(logd,&quot\\t\\t\\t&quot);\newline		       n_print(&quotprinc&quot,lineh,56,lg,&quotNone\\n&quot);\newline		       ++lineh;\newline		       break;\newline		    }\newline\newline	       }\newline\newline	  }\newline     }\newline\newline   n_print(&quotwinfo&quot,1,2,lg,&quot\\nAll the other %d ports are in state closed\\n&quot,close);\newline   if (fr!=0) n_print(&quotwinfo&quot,2,1,lg,&quot(*)Possible REJECT rule in the firewall\\n&quot);\newline   if (fd!=0) n_print(&quotwinfo&quot,3,1,lg,&quot(**)Possible DROP rule in the firewall\\n&quot);\newline\newline   libnet_destroy(l);\newline   pcap_close(descr);\newline   n_print(&quotprinc&quot,lineh+2,1,lg,&quotScanning terminated on %s\\n&quot,timed);\newline\newline   if (lg)\newline     {\newline	n_print(NULL,0,0,lg,&quotDone! Results has been writed to &#039%s&#039\\n&quot, logname);\newline	fclose (logd);\newline     }\newline   printf (&quot\\n&quot);\newline   return 0;\newline\newline   if (lg)\newline     {\newline	n_print(NULL,0,0,lg,&quotError! Results has been writed to &#039%s&#039\\n&quot, logname);\newline	fclose (logd);\newline     }\newline   printf (&quot\\n&quot);\newline   return 1;\newline\newline}\newline",single host syn port scanner \newline,4396696,sock.c,"int sock_active (sock_t sock)\newline{\newline    char c;\newline    int l;\newline\newline    l = recv (sock, &ampc, 1, MSG_PEEK);\newline    if (l == 0)\newline        return 0;\newline    if (l == SOCK_ERROR &amp&amp sock_recoverable (sock_error()))\newline        return 1;\newline    return 0;\newline}\newline",determines if the passed socket is still connected \newline,5948856,flow6.c,void usage(void){\newline	puts(&quotusage: flow6 -d DST_ADDR [-i INTERFACE] [-S LINK_SRC_ADDR] [-D LINK-DST-ADDR]\\n&quot\newline	     &quot       [-s SRC_ADDR[/LEN]] [-A HOP_LIMIT] [-P PROTOCOL] [-p PORT]\\n&quot\newline	     &quot       [-W] [-v] [-h]&quot);\newline}\newline,\newline Function: usage()\newline \newline Prints the syntax of the flow6 tool\newline \newline,1679270,hash.c,"double hash_get_delta(HASH * Hash, const char *key, const char *column, const int delay)\newline{\newline    HASH_ITEM *Item;\newline    HASH_SLOT *Slot1, *Slot2;\newline    int i, c;\newline    double v1, v2;\newline    double dv, dt;\newline    struct timeval now, end;\newline\newline    /* lookup item */\newline    Item = hash_lookup(Hash, key, 1);\newline    if (Item == NULL)\newline	return 0.0;\newline\newline    /* this is the &quotcurrent&quot Slot */\newline    Slot1 = &amp(Item-&gtSlot[Item-&gtindex]);\newline\newline    /* fetch column number */\newline    c = hash_get_column(Hash, column);\newline\newline    /* if delay is zero, return absolute value */\newline    if (delay == 0)\newline	return atof(split(Slot1-&gtvalue, c, Hash-&gtdelimiter));\newline\newline    /* prepare timing values */\newline    now = Slot1-&gttimestamp;\newline    end.tv_sec = now.tv_sec;\newline    end.tv_usec = now.tv_usec - 1000 * delay;\newline    while (end.tv_usec &lt 0) {\newline	end.tv_sec--;\newline	end.tv_usec += 1000000;\newline    }\newline\newline    /* search delta slot */\newline    Slot2 = &amp(Item-&gtSlot[Item-&gtindex]);\newline    for (i = 1; i &lt Item-&gtnSlot; i++) {\newline	Slot2 = &amp(Item-&gtSlot[(Item-&gtindex + i) % Item-&gtnSlot]);\newline	if (Slot2-&gttimestamp.tv_sec == 0)\newline	    break;\newline	if (timercmp(&amp(Slot2-&gttimestamp), &ampend, &lt))\newline	    break;\newline    }\newline\newline    /* empty slot =&gt try the one before */\newline    if (Slot2-&gttimestamp.tv_sec == 0) {\newline	i--;\newline	Slot2 = &amp(Item-&gtSlot[(Item-&gtindex + i) % Item-&gtnSlot]);\newline    }\newline\newline    /* not enough slots available... */\newline    if (i == 0)\newline	return 0.0;\newline\newline    /* delta value, delta time */\newline    v1 = atof(split(Slot1-&gtvalue, c, Hash-&gtdelimiter));\newline    v2 = atof(split(Slot2-&gtvalue, c, Hash-&gtdelimiter));\newline    dv = v1 - v2;\newline    dt = (Slot1-&gttimestamp.tv_sec - Slot2-&gttimestamp.tv_sec)\newline	+ (Slot1-&gttimestamp.tv_usec - Slot2-&gttimestamp.tv_usec) / 1000000.0;\newline\newline    if (dt &gt 0.0 &amp&amp dv &gt= 0.0)\newline	return dv / dt;\newline    return 0.0;\newline}\newline",get a delta value from the delta table \newline,3392826,nilfs.c,int nilfs_opt_set_mmap(struct nilfs *nilfs)\newline{\newline	long pagesize;\newline	size_t segsize;\newline\newline	pagesize = sysconf(_SC_PAGESIZE);\newline	if (pagesize &lt 0)\newline		return -1;\newline	segsize = le32_to_cpu(nilfs-&gtn_sb-&gts_blocks_per_segment) *\newline		nilfs_get_block_size(nilfs);\newline	if (segsize % pagesize != 0)\newline		return -1;\newline\newline	nilfs-&gtn_opts |= NILFS_OPT_MMAP;\newline	return 0;\newline}\newline,\newline nilfs_opt_set_mmap - set mmap option\newline @nilfs: nilfs object\newline \newline,6006702,multifun.c,"globle int DeleteMultiValueField(\newline  void *theEnv,\newline  DATA_OBJECT *dst,\newline  DATA_OBJECT *src,\newline  long rb,\newline  long re,\newline  char *funcName)\newline  {\newline   register long i,j;\newline   register FIELD_PTR deptr,septr;\newline   unsigned long srclen, dstlen;\newline\newline   srclen = (unsigned long) ((src != NULL) ? (src-&gtend - src-&gtbegin + 1) : 0);\newline   if ((re &lt rb) ||\newline       (rb &lt 1) || (re &lt 1) ||\newline       (rb &gt ((long) srclen)) || (re &gt ((long) srclen)))\newline     {\newline      MVRangeError(theEnv,rb,re,srclen,funcName);\newline      return(FALSE);\newline     }\newline   dst-&gttype = MULTIFIELD;\newline   dst-&gtbegin = 0;\newline   if (srclen == 0)\newline    {\newline     dst-&gtvalue = EnvCreateMultifield(theEnv,0L);\newline     dst-&gtend = -1;\newline     return(TRUE);\newline    }\newline   rb = src-&gtbegin + rb -1;\newline   re = src-&gtbegin + re -1;\newline   dstlen = srclen-(re-rb+1);\newline   SetpDOEnd(dst,dstlen);\newline   dst-&gtvalue = EnvCreateMultifield(theEnv,dstlen);\newline   for (i = 0 , j = src-&gtbegin ; j &lt rb ; i++ , j++)\newline     {\newline      deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[i];\newline      septr = &amp((struct multifield *) src-&gtvalue)-&gttheFields[j];\newline      deptr-&gttype = septr-&gttype;\newline      deptr-&gtvalue = septr-&gtvalue;\newline     }\newline   while (j &lt re)\newline     j++;\newline   for (j++ ; i &lt= dst-&gtend ; j++ , i++)\newline     {\newline      deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[i];\newline      septr = &amp((struct multifield *) src-&gtvalue)-&gttheFields[j];\newline      deptr-&gttype = septr-&gttype;\newline      deptr-&gtvalue = septr-&gtvalue;\newline     }\newline   return(TRUE);\newline  }\newline","\newlineNAME : DeleteMultiValueField\newlineDESCRIPTION : Performs a modify on the src multi-field value\newlinestoring the results in the dst multi-field value\newlineINPUTS : 1) The destination value buffer\newline2) The source value (can be NULL)\newline3) The beginning index for deletion\newline4) The ending index for deletion\newlineRETURNS : TRUE if successful, FALSE otherwise\newlineSIDE EFFECTS : Allocates and sets a ephemeral segment (even if new\newlinenumber of fields is 0)\newlineSrc value segment is not changed\newlineNOTES : index is NOT guaranteed to be valid\newlinesrc is guaranteed to be a multi-field variable or NULL\newline \newline",2663673,litdirectory.c,"int write_encint(U8 * p,int index,int total,U64 x)\newline{\newline    int     len,i;\newline    U64     mask;\newline    \newline    len = 0;\newline    mask = 0x7f;\newline    while (x &gt mask) { len++; mask = (mask &lt&lt 7)|0x7f;  }\newline    len++;\newline    if (len &gt (total - index)) return -1; \newline    \newline    for (i = 1; i &lt len; i++)\newline    {\newline        *(p+index) = 0x80 + (U8)((x &amp mask) &gt&gt ((len - i) * 7));\newline        mask &gt&gt= 7;\newline        index++;\newline    }\newline    *(p+index) = (U8)((x &amp mask) &amp0xff);\newline    return len;    \newline}\newline",--[write_encint]-------------------------------------------------------------\newline| \newline| Store an encoded integer into a location.\newline \newline,2161311,imapd.c,"static int getsortcriteria(char *tag, struct sortcrit **sortcrit)\newline{\newline    int c;\newline    static struct buf criteria;\newline    int nsort, n;\newline\newline    *sortcrit = NULL;\newline\newline    c = prot_getc(imapd_in);\newline    if (c != &#039(&#039) goto missingcrit;\newline\newline    c = getword(imapd_in, &ampcriteria);\newline    if (criteria.s[0] == &#039\\0&#039) goto missingcrit;\newline\newline    nsort = 0;\newline    n = 0;\newline    for (;;) {\newline	if (n &gt= nsort - 1) {	/* leave room for implicit criterion */\newline	    /* (Re)allocate an array for sort criteria */\newline	    nsort += SORTGROWSIZE;\newline	    *sortcrit =\newline		(struct sortcrit *) xrealloc(*sortcrit,\newline					     nsort * sizeof(struct sortcrit));\newline	    /* Zero out the newly added sortcrit */\newline	    memset((*sortcrit)+n, 0, SORTGROWSIZE * sizeof(struct sortcrit));\newline	}\newline\newline	lcase(criteria.s);\newline	if (!strcmp(criteria.s, &quotreverse&quot)) {\newline	    (*sortcrit)[n].flags |= SORT_REVERSE;\newline	    goto nextcrit;\newline	}\newline	else if (!strcmp(criteria.s, &quotarrival&quot))\newline	    (*sortcrit)[n].key = SORT_ARRIVAL;\newline	else if (!strcmp(criteria.s, &quotcc&quot))\newline	    (*sortcrit)[n].key = SORT_CC;\newline	else if (!strcmp(criteria.s, &quotdate&quot))\newline	    (*sortcrit)[n].key = SORT_DATE;\newline        else if (!strcmp(criteria.s, &quotdisplayfrom&quot))\newline            (*sortcrit)[n].key = SORT_DISPLAYFROM;\newline        else if (!strcmp(criteria.s, &quotdisplayto&quot))\newline            (*sortcrit)[n].key = SORT_DISPLAYTO;\newline	else if (!strcmp(criteria.s, &quotfrom&quot))\newline	    (*sortcrit)[n].key = SORT_FROM;\newline	else if (!strcmp(criteria.s, &quotsize&quot))\newline	    (*sortcrit)[n].key = SORT_SIZE;\newline	else if (!strcmp(criteria.s, &quotsubject&quot))\newline	    (*sortcrit)[n].key = SORT_SUBJECT;\newline	else if (!strcmp(criteria.s, &quotto&quot))\newline	    (*sortcrit)[n].key = SORT_TO;\newline	else if (!strcmp(criteria.s, &quotannotation&quot)) {\newline	    const char *userid = NULL;\newline\newline	    (*sortcrit)[n].key = SORT_ANNOTATION;\newline	    if (c != &#039 &#039) goto missingarg;\newline	    c = getastring(imapd_in, imapd_out, &ampcriteria);\newline	    if (c != &#039 &#039) goto missingarg;\newline	    (*sortcrit)[n].args.annot.entry = xstrdup(criteria.s);\newline	    c = getastring(imapd_in, imapd_out, &ampcriteria);\newline	    if (c == EOF) goto missingarg;\newline	    if (!strcmp(criteria.s, &quotvalue.shared&quot))\newline		userid = &quot&quot;\newline	    else if (!strcmp(criteria.s, &quotvalue.priv&quot))\newline		userid = imapd_userid;\newline	    else\newline		goto missingarg;\newline	    (*sortcrit)[n].args.annot.userid = xstrdup(userid);\newline	}\newline	else if (!strcmp(criteria.s, &quotmodseq&quot))\newline	    (*sortcrit)[n].key = SORT_MODSEQ;\newline	else if (!strcmp(criteria.s, &quotuid&quot))\newline	    (*sortcrit)[n].key = SORT_UID;\newline	else {\newline	    prot_printf(imapd_out, &quot%s BAD Invalid Sort criterion %s\\r\\n&quot,\newline			tag, criteria.s);\newline	    if (c != EOF) prot_ungetc(c, imapd_in);\newline	    return EOF;\newline	}\newline\newline	n++;\newline\newline nextcrit:\newline	if (c == &#039 &#039) c = getword(imapd_in, &ampcriteria);\newline	else break;\newline    }\newline\newline    if ((*sortcrit)[n].flags &amp SORT_REVERSE  &amp&amp !(*sortcrit)[n].key) {\newline	prot_printf(imapd_out,\newline		    &quot%s BAD Missing Sort criterion to reverse\\r\\n&quot, tag);\newline	if (c != EOF) prot_ungetc(c, imapd_in);\newline	return EOF;\newline    }\newline\newline    if (c != &#039)&#039) {\newline	prot_printf(imapd_out,\newline		    &quot%s BAD Missing close parenthesis in Sort\\r\\n&quot, tag);\newline	if (c != EOF) prot_ungetc(c, imapd_in);\newline	return EOF;\newline    }\newline\newline    /* Terminate the list with the implicit sort criterion */\newline    (*sortcrit)[n++].key = SORT_SEQUENCE;\newline\newline    c = prot_getc(imapd_in);\newline\newline    return c;\newline\newline missingcrit:\newline    prot_printf(imapd_out, &quot%s BAD Missing Sort criteria\\r\\n&quot, tag);\newline    if (c != EOF) prot_ungetc(c, imapd_in);\newline    return EOF;\newline missingarg:\newline    prot_printf(imapd_out, &quot%s BAD Missing argument to Sort criterion %s\\r\\n&quot,\newline		tag, criteria.s);\newline    if (c != EOF) prot_ungetc(c, imapd_in);\newline    return EOF;\newline}\newline",\newline Parse sort criteria\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,,,,on,,,,,on,,,,,,on,,on,,on,,,,,,,,,,,,,,,,,,,,,,,,This is usually called by boardhandler when scanning a matrix.,Write header of image plane,Unlock mutex or exit application immediately on error.,{},single host syn port scanner,determines if the passed socket is still connected,Prints the syntax of the flow6 tool,get a delta value from the delta table,{},Performs a modify on the src multi-field value,Store an encoded integer into a location.,Get the next inotify event to occur.,Parse sort criteria,Load an image from the named file.,{},See documentation in header file.,{},Write data from the write buffer out to the socket.,{},write terms to file,Display record of unknown type from CMOS option table.,x,
38G0E1M85M53YDHIP2S00Z5IJJ0VU0,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:28 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:28 PDT 2019,,,3E4GGUZ1T8RILABXXG9OHQVY2PQK2L,AITP2LUW8GPB,Submitted,Fri Apr 26 13:46:02 PDT 2019,Fri Apr 26 13:50:44 PDT 2019,Sun Apr 28 13:50:44 PDT 2019,,,,282,100% (62/62),100% (62/62),0% (0/0),1052861,kfilereplacelib.cpp,"QString KFileReplaceLib::addExtension(const QString&amp fileName, const QString&amp extension)\newline{\newline  QString fullExtension = &quot.&quot;\newline  QString fname = fileName;\newline\newline  fullExtension.append(extension);\newline\newline  // filename cannot contain &quot.ext&quot ==&gt Add it\newline  if(fname.length() &lt= fullExtension.length())\newline   fname.append(fullExtension);\newline  else // filename can contain &quot.ext&quot\newline  {\newline   if (fname.right(fullExtension.length()) != fullExtension)\newline    fname.append(fullExtension);\newline  }\newline\newline  return fname;\newline}\newline","\newlineAdd an extension to a filename, or a filepath\newlineParameters::..... fileName: filename or filepath (it can have already the extension)\newline................. extension: extension to add without &quot.&quot (ex: &quothtml&quot, &quotkfr&quot)\newlineReturn values:... Filename / Filepath with the extension\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,313291,objects.c,"commandsmember *add_host_notification_command_to_contact(contact *cntct, char *command_name) {\newline	commandsmember *new_commandsmember = NULL;\newline\newline	/* make sure we have the data we need */\newline	if (cntct == NULL || (command_name == NULL || !strcmp(command_name, &quot&quot))) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Contact or host notification command is NULL\\n&quot);\newline		return NULL;\newline	}\newline\newline	/* allocate memory */\newline	if ((new_commandsmember = calloc(1, sizeof(commandsmember))) == NULL)\newline		return NULL;\newline\newline	/* duplicate vars */\newline	if ((new_commandsmember-&gtcommand = (char *)strdup(command_name)) == NULL) {\newline		my_free(new_commandsmember-&gtcommand);\newline		my_free(new_commandsmember);\newline		return NULL;\newline	}\newline\newline	/* add the notification command */\newline	new_commandsmember-&gtnext = cntct-&gthost_notification_commands;\newline	cntct-&gthost_notification_commands = new_commandsmember;\newline\newline	return new_commandsmember;\newline}\newline",adds a host notification command to a contact definition \newline,3414833,tpage.c,"void tpage_set_readonly(gboolean readonly)\newline{\newline	gtk_text_view_set_editable (GTK_TEXT_VIEW (args_textview), !readonly);\newline	gtk_widget_set_sensitive (target_button_browse, !readonly);\newline	gtk_widget_set_sensitive (debugger_cmb, !readonly);\newline\newline	envtree_set_readonly(readonly);\newline}\newline",\newline set the page readonly\newline \newline,3064793,context-extravars.h,"inline void set_block(int val)  { seti(WR_VAR(0, 1, 1), val); }\newline",Set the value of &quotWMO block number&quot from a variable of type int \newline,35044,il_io.c,"ILboolean ILAPIENTRY ilSaveImage(ILconst_string FileName)\newline{\newline	ILstring Ext;\newline	ILboolean	bRet = IL_FALSE;\newline\newline	if (FileName == NULL || ilStrLen(FileName) &lt 1) {\newline		ilSetError(IL_INVALID_PARAM);\newline		return IL_FALSE;\newline	}\newline\newline	if (iCurImage == NULL) {\newline		ilSetError(IL_ILLEGAL_OPERATION);\newline		return IL_FALSE;\newline	}\newline\newline	Ext = iGetExtension(FileName);\newline	if (Ext == NULL) {\newline		ilSetError(IL_INVALID_PARAM);\newline		return IL_FALSE;\newline	}\newline\newline	#ifndef IL_NO_BMP\newline	if (!iStrCmp(Ext, IL_TEXT(&quotbmp&quot))) {\newline		bRet = ilSaveBmp(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_CHEAD\newline	if (!iStrCmp(Ext, IL_TEXT(&quoth&quot))) {\newline		bRet = ilSaveCHeader(FileName, &quotIL_IMAGE&quot);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_DDS\newline	if (!iStrCmp(Ext, IL_TEXT(&quotdds&quot))) {\newline		bRet = ilSaveDds(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_EXR\newline	if (!iStrCmp(Ext, IL_TEXT(&quotexr&quot))) {\newline		bRet = ilSaveExr(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_HDR\newline	if (!iStrCmp(Ext, IL_TEXT(&quothdr&quot))) {\newline		bRet = ilSaveHdr(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_JP2\newline	if (!iStrCmp(Ext, IL_TEXT(&quotjp2&quot))) {\newline		bRet = ilSaveJp2(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_JPG\newline	if (!iStrCmp(Ext, IL_TEXT(&quotjpg&quot)) || !iStrCmp(Ext, IL_TEXT(&quotjpeg&quot)) || !iStrCmp(Ext, IL_TEXT(&quotjpe&quot))) {\newline		bRet = ilSaveJpeg(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_PCX\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpcx&quot))) {\newline		bRet = ilSavePcx(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_PNG\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpng&quot))) {\newline		bRet = ilSavePng(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_PNM  // Not sure if binary or ascii should be defaulted...maybe an option?\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpbm&quot))) {\newline		bRet = ilSavePnm(FileName);\newline		goto finish;\newline	}\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpgm&quot))) {\newline		bRet = ilSavePnm(FileName);\newline		goto finish;\newline	}\newline	if (!iStrCmp(Ext, IL_TEXT(&quotppm&quot))) {\newline		bRet = ilSavePnm(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_PSD\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpsd&quot))) {\newline		bRet = ilSavePsd(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_RAW\newline	if (!iStrCmp(Ext, IL_TEXT(&quotraw&quot))) {\newline		bRet = ilSaveRaw(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_SGI\newline	if (!iStrCmp(Ext, IL_TEXT(&quotsgi&quot)) || !iStrCmp(Ext, IL_TEXT(&quotbw&quot)) ||\newline		!iStrCmp(Ext, IL_TEXT(&quotrgb&quot)) || !iStrCmp(Ext, IL_TEXT(&quotrgba&quot))) {\newline		bRet = ilSaveSgi(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_TGA\newline	if (!iStrCmp(Ext, IL_TEXT(&quottga&quot))) {\newline		bRet = ilSaveTarga(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_TIF\newline	if (!iStrCmp(Ext, IL_TEXT(&quottif&quot)) || !iStrCmp(Ext, IL_TEXT(&quottiff&quot))) {\newline		bRet = ilSaveTiff(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_VTF\newline	if (!iStrCmp(Ext, IL_TEXT(&quotvtf&quot))) {\newline		bRet = ilSaveVtf(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_WBMP\newline	if (!iStrCmp(Ext, IL_TEXT(&quotwbmp&quot))) {\newline		bRet = ilSaveWbmp(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	#ifndef IL_NO_MNG\newline	if (!iStrCmp(Ext, IL_TEXT(&quotmng&quot))) {\newline		bRet = ilSaveMng(FileName);\newline		goto finish;\newline	}\newline	#endif\newline\newline	// Check if we just want to save the palette.\newline	if (!iStrCmp(Ext, IL_TEXT(&quotpal&quot))) {\newline		bRet = ilSavePal(FileName);\newline		goto finish;\newline	}\newline\newline	// Try registered procedures\newline	if (iRegisterSave(FileName))\newline		return IL_TRUE;\newline\newline	ilSetError(IL_INVALID_EXTENSION);\newline	return IL_FALSE;\newline\newlinefinish:\newline	return bRet;\newline}\newline","! \\param FileName Ansi or Unicode string, depending on the compiled version of DevIL, that gives\newline the filename to save to.\newline \\return Boolean value of failure or success. Returns IL_FALSE if saving failed. \newline",5248084,unixos.c,"char *os_genid(void)\newline{\newline    static int pid = 0;\newline    static time_t curtime;\newline    static char hostname[MAXHOSTNAMELEN+1];\newline    char *result;\newline    struct hostent *hp;\newline    \newline\newline    if (pid == 0) {\newline	pid = getpid();\newline	time(&ampcurtime);\newline	gethostname(hostname, sizeof(hostname));\newline\newline	/* If we don&#039t have a FQDN, try canonicalizing with gethostbyname */\newline	if (!strchr(hostname, &#039.&#039)) {\newline	    hp = gethostbyname(hostname);\newline	    if (hp) {\newline		strcpy(hostname, hp-&gth_name);\newline	    }\newline	}\newline    }\newline\newline    result = malloc(25+strlen(hostname));\newline    sprintf(result, &quot%d.%lu@%s&quot, pid, (unsigned long) curtime++, hostname);\newline    return result;\newline}\newline",Generate a message-id \newline,3437584,dos-keyboard.c,"int UpdateKeyboard(void)\newline{\newline int t=newk;\newline\newline if(t)\newline {\newline  asm volatile(\newline        &quotsubl %%eax,_newk\\n\\t&quot\newline	:\newline	: &quota&quot (t)\newline  );\newline\newline  if(keybuf[SCAN_LEFTCONTROL] &amp&amp keybuf[SCAN_C])\newline   raise(SIGINT);\newline  return(1);\newline }\newline return(0);\newline}\newline","Returns 1 on new scan codes generated, 0 on no new scan codes. \newline",3367414,abstractfindwidget.cpp,AbstractFindWidget::~AbstractFindWidget()\newline{\newline}\newline,!\newlineDestroys the AbstractFindWidget.\newline \newline,5201304,xgnokii_logos.c,"void UpdatePointsRectangle(GtkWidget * widget, int x1, int y1, int x2, int y2)\newline{\newline	GdkRectangle updateRect;\newline	int x, y, dx = 0, dy = 0;\newline\newline	if (bitmap.type != GN_BMP_StartupLogo) {\newline		dx = PREVIEWJUMPX;\newline		dy = PREVIEWJUMPY;\newline	}\newline\newline	if (x1 &gt x2) {\newline		x = x1;\newline		x1 = x2;\newline		x2 = x;\newline	}\newline\newline	if (y1 &gt y2) {\newline		y = y1;\newline		y1 = y2;\newline		y2 = y;\newline	}\newline\newline	for (y = y1; y &lt= y2; y++)\newline		for (x = x1; x &lt= x2; x++) {\newline			if (IsPoint(x, y)) {\newline				/* set on drawing area */\newline				gdk_draw_pixmap(drawingPixmap,\newline						drawingArea-&gtstyle-&gt\newline						fg_gc[GTK_WIDGET_STATE(drawingArea)],\newline						blackPointPixmap, 0, 0, x * (POINTSIZE + 1),\newline						y * (POINTSIZE + 1), -1, -1);\newline\newline				/* set on preview */\newline				if (previewAvailable &amp&amp previewPixmap)\newline					gdk_draw_point(previewPixmap, previewArea-&gtstyle-&gtblack_gc,\newline						       x + PREVIEWSTARTX + dx,\newline						       y + PREVIEWSTARTY + dy);\newline			} else {\newline				/* clear from drawing */\newline				gdk_draw_pixmap(drawingPixmap,\newline						drawingArea-&gtstyle-&gt\newline						fg_gc[GTK_WIDGET_STATE(drawingArea)],\newline						greenPointPixmap, 0, 0, x * (POINTSIZE + 1),\newline						y * (POINTSIZE + 1), -1, -1);\newline\newline				/* clear from preview */\newline				if (previewAvailable &amp&amp previewPixmap)\newline					gdk_draw_pixmap(previewPixmap,\newline							previewArea-&gtstyle-&gt\newline							fg_gc[GTK_WIDGET_STATE(previewArea)],\newline							greenPixelPixmap, 0, 0,\newline							x + PREVIEWSTARTX + dx,\newline							y + PREVIEWSTARTY + dy, 1, 1);\newline			}\newline		}\newline\newline	if (previewAvailable) {\newline		updateRect.x = PREVIEWSTARTX + dx + x1;\newline		updateRect.y = PREVIEWSTARTY + dy + y1;\newline		updateRect.width = x2 - x1 + 1;\newline		updateRect.height = y2 - y1 + 1;\newline		gtk_widget_draw(previewArea, &ampupdateRect);\newline	}\newline\newline	updateRect.x = x1 * (POINTSIZE + 1);\newline	updateRect.y = y1 * (POINTSIZE + 1);\newline	updateRect.width = (x2 - x1 + 1) * (POINTSIZE + 1) + 1;\newline	updateRect.height = (y2 - y1 + 1) * (POINTSIZE + 1) + 1;\newline	gtk_widget_draw(drawingArea, &ampupdateRect);\newline}\newline",this redraw all logo points - preview &amp drawing area \newline,6061730,imagescalertest.cpp,"void ImageScalerTest::testScaleDownBigImage()\newline{\newline    QImage image(1704, 2272, QImage::Format_RGB32);\newline    image.fill(255);\newline\newline    Gwenview::ImageScaler scaler;\newline    ImageScalerClient client(&ampscaler);\newline\newline    const qreal zoom = 0.28125;\newline    scaler.setImage(&ampimage);\newline    scaler.setZoom(zoom);\newline    scaler.setDestinationRegion(QRect(QPoint(0, 0), image.size() * zoom));\newline\newline    QImage scaledImage = client.createFullImage();\newline\newline    QImage expectedImage = image.scaled(scaledImage.size());\newline    QCOMPARE(expectedImage, scaledImage);\newline}\newline",\newline Test that scaling down a big image (==bigger than MAX_CHUNK_AREA) does not\newline produce any gap\newline \newline,500688,work_queue_worker.c,"static int stream_output_item(struct link *master, const char *filename, int recursive)\newline{\newline	DIR *dir;\newline	struct dirent *dent;\newline	char dentline[WORK_QUEUE_LINE_MAX];\newline	char cached_filename[WORK_QUEUE_LINE_MAX];\newline	struct stat info;\newline	INT64_T actual, length;\newline	int fd;\newline\newline	sprintf(cached_filename, &quotcache/%s&quot, filename);\newline\newline	if(stat(cached_filename, &ampinfo) != 0) {\newline		goto failure;\newline	}\newline\newline	if(S_ISDIR(info.st_mode)) {\newline		// stream a directory\newline		dir = opendir(cached_filename);\newline		if(!dir) {\newline			goto failure;\newline		}\newline		send_master_message(master, &quotdir %s %lld\\n&quot, filename, (INT64_T) 0);\newline		\newline		while(recursive &amp&amp (dent = readdir(dir))) {\newline			if(!strcmp(dent-&gtd_name, &quot.&quot) || !strcmp(dent-&gtd_name, &quot..&quot))\newline				continue;\newline			sprintf(dentline, &quot%s/%s&quot, filename, dent-&gtd_name);\newline			stream_output_item(master, dentline, recursive);\newline		}\newline\newline		closedir(dir);\newline	} else {\newline		// stream a file\newline		fd = open(cached_filename, O_RDONLY, 0);\newline		if(fd &gt= 0) {\newline			length = (INT64_T) info.st_size;\newline			send_master_message(master, &quotfile %s %lld\\n&quot, filename, length);\newline			actual = link_stream_from_fd(master, fd, length, time(0) + active_timeout);\newline			close(fd);\newline			if(actual != length) {\newline				debug(D_WQ, &quotSending back output file - %s failed: bytes to send = %lld and bytes actually sent = %lld.&quot, filename, length, actual);\newline				return 0;\newline			}\newline		} else {\newline			goto failure;\newline		}\newline	}\newline\newline	return 1;\newline\newlinefailure:\newline	send_master_message(master, &quotmissing %s %d\\n&quot, filename, errno);\newline	return 0;\newline}\newline",\newline Stream file/directory contents for the rget protocol.\newline Format:\newline for a directory: a new line in the format of &quotdir $DIR_NAME 0&quot\newline for a file: a new line in the format of &quotfile $FILE_NAME $FILE_LENGTH&quot\newline then file contents.\newline string &quotend&quot at the end of the stream (on a new line).\newline \newline Example:\newline Assume we have the following directory structure:\newline mydir\newline -- 1.txt\newline -- 2.txt\newline -- mysubdir\newline -- a.txt\newline -- b.txt\newline -- z.jpg\newline \newline The stream contents would be:\newline \newline dir mydir 0\newline file 1.txt $file_len\newline $$ FILE 1.txt&#039s CONTENTS $$\newline file 2.txt $file_len\newline $$ FILE 2.txt&#039s CONTENTS $$\newline dir mysubdir 0\newline file mysubdir/a.txt $file_len\newline $$ FILE mysubdir/a.txt&#039s CONTENTS $$\newline file mysubdir/b.txt $file_len\newline $$ FILE mysubdir/b.txt&#039s CONTENTS $$\newline file z.jpg $file_len\newline $$ FILE z.jpg&#039s CONTENTS $$\newline end\newline \newline \newline,5111482,getdata.c,"void gdidl_add_spec(int argc, IDL_VPTR argv[], char *argk)\newline{\newline  dtraceidl();\newline\newline  typedef struct {\newline    IDL_KW_RESULT_FIRST_FIELD;\newline    GDIDL_KW_RESULT_ERROR;\newline    int fragment_index;\newline    IDL_STRING parent;\newline    int parent_x;\newline  } KW_RESULT;\newline  KW_RESULT kw;\newline\newline  GDIDL_KW_INIT_ERROR;\newline  kw.fragment_index = 0;\newline  kw.parent_x = 0;\newline\newline  static IDL_KW_PAR kw_pars[] = {\newline    GDIDL_KW_PAR_ERROR,\newline    GDIDL_KW_PAR_ESTRING,\newline    { &quotFRAGMENT&quot, IDL_TYP_INT, 1, 0, 0, IDL_KW_OFFSETOF(fragment_index) },\newline    { &quotPARENT&quot, IDL_TYP_STRING, 1, 0, IDL_KW_OFFSETOF(parent_x),\newline      IDL_KW_OFFSETOF(parent) },\newline    { NULL }\newline  };\newline\newline  IDL_KWProcessByOffset(argc, argv, argk, kw_pars, NULL, 1, &ampkw);\newline\newline  DIRFILE* D = gdidl_get_dirfile(IDL_LongScalar(argv[0]));\newline  const char* line = IDL_VarGetString(argv[1]);\newline\newline  if (kw.parent_x) {\newline    const char* parent = IDL_STRING_STR(&ampkw.parent);\newline    gd_madd_spec(D, line, parent);\newline  } else\newline    gd_add_spec(D, line, kw.fragment_index);\newline\newline  GDIDL_SET_ERROR(D);\newline\newline  IDL_KW_FREE;\newline\newline  dreturnvoid();\newline}\newline",@@DLM: P gdidl_add_spec GD_ADD_SPEC 2 2 KEYWORDS \newline,203821,writevcf.c,"static void write_list_elt(SEXP v_elt, const char mv_sep, kstring_t *bufp) \newline{\newline    SEXPTYPE v_type;\newline    int v, v_len;\newline\newline    v_type = TYPEOF(v_elt);\newline    v_len = length(v_elt);\newline    switch (v_type) {\newline        case NILSXP:\newline            break;\newline        case LGLSXP:\newline            Rf_warning(&quot&#039logical&#039 is not a valid FORMAT data type&quot);\newline            break;\newline        case INTSXP:\newline            for (v = 0; v &lt v_len; v++) {\newline                if (NA_INTEGER != INTEGER(v_elt)[v]) \newline                    kputw(INTEGER(v_elt)[v], bufp);\newline                else\newline                    kputc(&#039.&#039, bufp);\newline                if (v &lt v_len - 1)\newline                    kputc(mv_sep, bufp);\newline            }\newline            break;\newline        case REALSXP:\newline            for (v = 0; v &lt v_len; v++) {\newline                if (!ISNAN(REAL(v_elt)[v]))\newline                    ksprintf(bufp, &quot%g&quot, REAL(v_elt)[v]);\newline                else\newline                    kputc(&#039.&#039, bufp);\newline                if (v &lt v_len - 1)\newline                    kputc(mv_sep, bufp);\newline            }\newline            break;\newline        case STRSXP:\newline            for (v = 0; v &lt v_len; v++) {\newline                if (NA_STRING != STRING_ELT(v_elt, v))\newline                    kputs(CHAR(STRING_ELT(v_elt, v)), bufp);\newline                else\newline                    kputc(&#039.&#039, bufp);\newline                if (v &lt v_len - 1)\newline                    kputc(mv_sep, bufp);\newline            }\newline            break;\newline        default:\newline            Rf_error(&quotunsupported &#039geno&#039 type: %s&quot, type2char(v_type));\newline            break;\newline    }\newline}\newline",write all elements of &#039list&#039 genotype field \newline,504228,timezonerule.cpp,"void TimeZoneRule::nextDSTChange( const KStarsDateTime &amplocal_date, const double TZoffset ) {\newline    // just decrement timezone offset and hour offset\newline    KStarsDateTime result = local_date.addSecs( int( (TZoffset + deltaTZ()) * -3600) );\newline\newline    qDebug() &lt&lt &quotNext Daylight Savings Time change (UTC): &quot &lt&lt result.toString();\newline    next_change_utc = result;\newline}\newline",Convert current local DST change time in universal time \newline,5983662,logger.c,"int disposeLogging() {\newline#ifdef WIN32\newline    \newline    /* Always call maintain logger once to make sure that all queued messages are logged before we exit. */\newline    maintainLogger();\newline    \newline    if (log_printfMutexHandle) {\newline        if (!CloseHandle(log_printfMutexHandle)) {\newline            _tprintf(TEXT(&quotUnable to close Logging Mutex handle. %s\\n&quot), getLastErrorText());\newline            return 1;\newline        }\newline    }\newline#endif\newline    if (threadPrintBuffer &amp&amp threadPrintBufferSize &gt 0) {\newline        free(threadPrintBuffer);\newline        threadPrintBuffer = NULL;\newline        threadPrintBufferSize = 0;\newline    }\newline    if (threadMessageBuffer &amp&amp threadMessageBufferSize &gt 0) {\newline        free(threadMessageBuffer);\newline        threadMessageBuffer = NULL;\newline        threadMessageBufferSize = 0;\newline    }\newline\newline\newline    if (logFilePath) {\newline        free(logFilePath);\newline        logFilePath = NULL;\newline    }\newline    if (currentLogFileName) {\newline        free(currentLogFileName);\newline        currentLogFileName = NULL;\newline    }\newline    if (confLogFileName) {\newline        free(confLogFileName);\newline        confLogFileName = NULL;\newline    }\newline    if (workLogFileName) {\newline        free(workLogFileName);\newline        workLogFileName = NULL;\newline    }\newline    if ((loginfoSourceName != defaultLoginfoSourceName) &amp&amp (loginfoSourceName != NULL)) {\newline        free(loginfoSourceName);\newline        loginfoSourceName = NULL;\newline    }\newline    if (logfileFP) {\newline        fclose(logfileFP);\newline        logfileFP = NULL;\newline    }\newline    return 0;\newline}\newline",\newline Disposes of any logging resouces prior to shutdown.\newline \newline,3442041,lua-engine.cpp,"static void FCEU_LuaOnStop()\newline{\newline	luaRunning = FALSE;\newline	for (int i = 0 ; i &lt 4 ; i++ ){\newline		luajoypads1[i]= 0xFF;	// Set these back to pass-through\newline		luajoypads2[i]= 0x00;\newline	}\newline	gui_used = GUI_CLEAR;\newline	//if (wasPaused &amp&amp !FCEUI_EmulationPaused())\newline	//	FCEUI_ToggleEmulationPause();\newline	FCEUD_SetEmulationSpeed(EMUSPEED_NORMAL);		//TODO: Ideally lua returns the speed to the speed the user set before running the script\newline													//rather than returning it to normal, and turbo off.  Perhaps some flags and a FCEUD_GetEmulationSpeed function\newline	turbo = false;\newline	//FCEUD_TurboOff();\newline#ifdef WIN32\newline	TaseditorDisableManualFunctionIfNeeded();\newline#endif\newline}\newline",\newline Resets emulator speed / pause states after script exit.\newline \newline,1679273,hash.c,"void hash_put(HASH * Hash, const char *key, const char *value)\newline{\newline    hash_set(Hash, key, value, 1);\newline}\newline",without delta processing \newline,4900288,database_llist.c,"static int dbase_llist_cache_locate(semanage_handle_t * handle,\newline				    dbase_llist_t * dbase,\newline				    const record_key_t * key,\newline				    cache_entry_t ** entry)\newline{\newline\newline	cache_entry_t *ptr;\newline\newline	/* Implemented in parent */\newline	if (dbase-&gtdtable-&gtcache(handle, dbase) &lt 0)\newline		goto err;\newline\newline	for (ptr = dbase-&gtcache; ptr != NULL; ptr = ptr-&gtnext) {\newline		if (!dbase-&gtrtable-&gtcompare(ptr-&gtdata, key)) {\newline			*entry = ptr;\newline			return STATUS_SUCCESS;\newline		}\newline	}\newline\newline	return STATUS_NODATA;\newline\newline      err:\newline	ERR(handle, &quotcould not complete cache lookup&quot);\newline	return STATUS_ERR;\newline}\newline",Helper for finding records in the cache \newline,6550436,uim-helper.c,"static gboolean prop_menu_shell_deactivate( GtkMenuShell *menu_shell,\newline                                            gpointer data ) {\newline  prop_menu_showing = FALSE;\newline\newline  return FALSE;\newline}\newline",\newline taken from uim-1.4.2/helper/toolbar-common-gtk.c\newline \newline,5846065,main.c,"static int tachyon_display_reshape(dispHandle *dh) {\newline  float wscalex, wscaley, wminscale;\newline  float wxoffset, wyoffset;\newline  int wsx, wsy, instereo, maxx, maxy;\newline\newline  glwin_get_wininfo(dh-&gtglwin, &ampinstereo, NULL);\newline  glwin_get_winsize(dh-&gtglwin, &ampwsx, &ampwsy);\newline  maxx=dh-&gtxsize;\newline  maxy=dh-&gtysize;  \newline  wscalex = wsx / (float) maxx;\newline  wscaley = wsy / (float) maxy;\newline  wminscale = (wscalex &lt wscaley) ? wscalex : wscaley;\newline  wxoffset = ((wminscale * maxx) - wsx) / 2.0f;\newline  wyoffset = ((wminscale * maxy) - wsy) / 2.0f;\newline\newline  glDrawBuffer(GL_BACK);\newline  glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\newline  glClearColor(0.0, 0.0, 0.0, 1.0); /* black */\newline  glViewport(0, 0, wsx, wsy);\newline  glClear(GL_COLOR_BUFFER_BIT);\newline\newline  glShadeModel(GL_FLAT);\newline  glViewport((int) -wxoffset, (int) -wyoffset, wsx, wsy);\newline  glMatrixMode(GL_PROJECTION);\newline  glLoadIdentity();\newline  glOrtho(0.0, wsx, 0.0, wsy, -1.0, 1.0); /* flip upside-down Tachyon image */\newline\newline  glMatrixMode(GL_MODELVIEW);\newline  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\newline  glPixelZoom(wminscale, wminscale); /* flip upside-down Tachyon image */\newline\newline  return 0;\newline}\newline",\newline routines for managing runtime display of ray traced scene\newline \newline,,,,,on,,,,,,,,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,"Add an extension to a filename, or a filepath",this redraw all logo points,Test that scaling down a big image,"a new line in the format of ""dir $DIR_NAME 0""",{},write all elements of 'list' genotype field,Convert current local DST change time in universal time,Disposes of any logging resouces prior to shutdown.,Resets emulator speed,without delta processing,Helper for finding records in the cache,Load an image from the named file.,{},routines for managing runtime display of ray traced scene,adds a host notification command to a contact definition,set the page readonly,{},Boolean value of failure or success.,Generate a message-id,"Returns 1 on new scan codes generated,",Destroys the AbstractFindWidget.,x,
37PGLWGSJT6K9BS6WHPFFN6Q9Q6KIV,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:14 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:14 PDT 2019,,,3GDTJDAPVUBOXDDPY9V56U05DUDM8V,AITP2LUW8GPB,Submitted,Fri Apr 26 12:45:27 PDT 2019,Fri Apr 26 12:47:08 PDT 2019,Sun Apr 28 12:47:08 PDT 2019,,,,101,100% (62/62),100% (62/62),0% (0/0),4946423,randutils.c,"const char *random_tell_source(void)\newline{\newline	size_t i;\newline	static const char *random_sources[] = {\newline		&quot/dev/urandom&quot,\newline		&quot/dev/random&quot\newline	};\newline\newline	for (i = 0; i &lt ARRAY_SIZE(random_sources); i++) {\newline		if (!access(random_sources[i], R_OK))\newline			return random_sources[i];\newline	}\newline\newline	return _(&quotlibc pseudo-random functions&quot);\newline}\newline",\newline Tell source of randomness.\newline \newline,3699972,gene.c,"double calculate_confidence(double score, double start_weight) {\newline  double conf;\newline\newline  if(score/start_weight &lt 41) {\newline    conf = exp(score/start_weight);\newline    conf = (conf/(conf+1))*100.0;\newline  }\newline  else conf = 99.99;\newline  if(conf &lt= 50.00) { conf = 50.00; }\newline  return conf;\newline}\newline",Convert score to a percent confidence \newline,2688639,kexec.c,"static void do_exchange(struct xc_dom_image *dom, xen_pfn_t target_pfn, xen_pfn_t source_mfn)\newline{\newline    xen_pfn_t source_pfn;\newline    xen_pfn_t target_mfn;\newline\newline    for (source_pfn = 0; source_pfn &lt start_info.nr_pages; source_pfn++)\newline        if (dom-&gtp2m_host[source_pfn] == source_mfn)\newline            break;\newline    ASSERT(source_pfn &lt start_info.nr_pages);\newline\newline    target_mfn = dom-&gtp2m_host[target_pfn];\newline\newline    /* Put target MFN at source PFN */\newline    dom-&gtp2m_host[source_pfn] = target_mfn;\newline\newline    /* Put source MFN at target PFN */\newline    dom-&gtp2m_host[target_pfn] = source_mfn;\newline}\newline","We need mfn to appear as target_pfn, so exchange with the MFN there \newline",6331242,events.c,"gpointer CreateEvent(WapiSecurityAttributes *security G_GNUC_UNUSED,\newline		     gboolean manual, gboolean initial,\newline		     const gunichar2 *name G_GNUC_UNUSED)\newline{\newline	mono_once (&ampevent_ops_once, event_ops_init);\newline\newline	if (name == NULL) {\newline		return(event_create (security, manual, initial));\newline	} else {\newline		return(namedevent_create (security, manual, initial, name));\newline	}\newline}\newline","\newline CreateEvent:\newline @security: Ignored for now.\newline @manual: Specifies whether the new event handle has manual or auto\newline reset behaviour.\newline @initial: Specifies whether the new event handle is initially\newline signalled or not.\newline @name:Pointer to a string specifying the name of this name, or\newline %NULL. Currently ignored.\newline \newline Creates a new event handle.\newline \newline An event handle is signalled with SetEvent(). If the new handle is\newline a manual reset event handle, it remains signalled until it is reset\newline with ResetEvent(). An auto reset event remains signalled until a\newline single thread has waited for it, at which time the event handle is\newline automatically reset to unsignalled.\newline \newline Return value: A new handle, or %NULL on error.\newline \newline",797732,omx_vorbisdec_component.c,"OMX_ERRORTYPE omx_vorbis_decoder_MessageHandler(OMX_COMPONENTTYPE* openmaxStandComp,internalRequestMessageType *message)  {\newline  omx_vorbisdec_component_PrivateType* omx_vorbisdec_component_Private = (omx_vorbisdec_component_PrivateType*)openmaxStandComp-&gtpComponentPrivate;\newline  OMX_ERRORTYPE err;\newline\newline  DEBUG(DEB_LEV_FUNCTION_NAME, &quotIn %s\\n&quot, __func__);\newline\newline  if (message-&gtmessageType == OMX_CommandStateSet){\newline    if ((message-&gtmessageParam == OMX_StateIdle) &amp&amp (omx_vorbisdec_component_Private-&gtstate == OMX_StateLoaded)) {\newline      err = omx_vorbisdec_component_Init(openmaxStandComp);\newline      if(err!=OMX_ErrorNone) {\newline        DEBUG(DEB_LEV_ERR, &quotIn %s Vorbis Decoder Init Failed=%x\\n&quot,__func__,err);\newline        return err;\newline      }\newline    } else if ((message-&gtmessageParam == OMX_StateLoaded) &amp&amp (omx_vorbisdec_component_Private-&gtstate == OMX_StateIdle)) {\newline      err = omx_vorbisdec_component_Deinit(openmaxStandComp);\newline      if(err!=OMX_ErrorNone) {\newline        DEBUG(DEB_LEV_ERR, &quotIn %s Vorbis Decoder Deinit Failed=%x\\n&quot,__func__,err);\newline        return err;\newline      }\newline    }\newline  }\newline  // Execute the base message handling\newline  return omx_base_component_MessageHandler(openmaxStandComp, message);\newline}\newline",handles the message generated by the IL client\newline @param openmaxStandComp the component handle\newline @param message is the message type\newline \newline,6214203,linux.c,"static int32_t linux_submit_ctrl(struct usbi_dev_handle *hdev, struct usbi_io *io)\newline{\newline	openusb_ctrl_request_t *ctrl;\newline	uint8_t 							setup[USBI_CONTROL_SETUP_LEN];\newline	int32_t								ret;\newline	\newline	/* Validate... */\newline	if ((!hdev) || (!io)) {\newline		return (OPENUSB_BADARG);\newline	}\newline\newline	pthread_mutex_lock(&ampio-&gtlock);\newline	\newline	/* allocate memory for the private part */\newline	io-&gtpriv = malloc(sizeof(struct usbi_io_private));\newline	if (!io-&gtpriv) {\newline		usbi_debug(hdev-&gtlib_hdl, 1, &quotunable to allocate memory for the &quot\newline							 &quotprivate io member&quot);\newline		pthread_mutex_unlock(&ampio-&gtlock);\newline		return (OPENUSB_NO_RESOURCES);\newline	}\newline	memset(io-&gtpriv, 0, sizeof(*io-&gtpriv));\newline\newline	/* allocate memory for the urb */\newline	io-&gtpriv-&gtnum_urbs = 1;\newline	io-&gtpriv-&gturbs = (struct usbk_urb*)malloc(sizeof(struct usbk_urb));\newline	if (!io-&gtpriv-&gturbs) {\newline		usbi_debug(hdev-&gtlib_hdl, 1, &quotunable to allocate memory for the urb&quot);\newline		pthread_mutex_unlock(&ampio-&gtlock);\newline		return (OPENUSB_NO_RESOURCES);\newline	}\newline	memset(io-&gtpriv-&gturbs, 0, sizeof(struct usbk_urb));\newline	\newline	/* get a pointer to the request */\newline	ctrl = io-&gtreq-&gtreq.ctrl;\newline\newline	/* setup the user context */\newline	io-&gtpriv-&gturbs[0].usercontext = io;\newline	\newline	/* fill in the setup packet */\newline	setup[0] = ctrl-&gtsetup.bmRequestType;\newline	setup[1] = ctrl-&gtsetup.bRequest;\newline	*(uint16_t *)(setup + 2) = openusb_cpu_to_le16(ctrl-&gtsetup.wValue);\newline	*(uint16_t *)(setup + 4) = openusb_cpu_to_le16(ctrl-&gtsetup.wIndex);\newline	*(uint16_t *)(setup + 6) = openusb_cpu_to_le16(ctrl-&gtlength);\newline	\newline	/* setup the URB */\newline	io-&gtpriv-&gturbs[0].type = USBK_URB_TYPE_CONTROL;\newline\newline	/* allocate a temporary buffer for the payload */\newline	io-&gtpriv-&gturbs[0].buffer = malloc(USBI_CONTROL_SETUP_LEN + ctrl-&gtlength);\newline	if (!io-&gtpriv-&gturbs[0].buffer) {\newline		pthread_mutex_unlock(&ampio-&gtlock);\newline		return (OPENUSB_NO_RESOURCES);\newline	}\newline	memset(io-&gtpriv-&gturbs[0].buffer,0,USBI_CONTROL_SETUP_LEN + ctrl-&gtlength);\newline\newline	/* fill in the temporary buffer */\newline	memcpy(io-&gtpriv-&gturbs[0].buffer, setup, USBI_CONTROL_SETUP_LEN);\newline	io-&gtpriv-&gturbs[0].buffer_length = USBI_CONTROL_SETUP_LEN + ctrl-&gtlength;\newline\newline	/* copy the data if we&#039re writing */\newline	if ((ctrl-&gtsetup.bmRequestType &amp USB_REQ_DIR_MASK) == USB_REQ_HOST_TO_DEV) {\newline		memcpy(io-&gtpriv-&gturbs[0].buffer + USBI_CONTROL_SETUP_LEN,\newline					 ctrl-&gtpayload, ctrl-&gtlength);\newline	}\newline\newline	/* lock the device */\newline	pthread_mutex_lock(&amphdev-&gtlock);\newline	\newline	/* submit the URB */\newline	ret = urb_submit(hdev, &ampio-&gtpriv-&gturbs[0]);\newline	if (ret &lt 0) {\newline		usbi_debug(hdev-&gtlib_hdl, 1, &quoterror submitting URB on ep %x: %s&quot,\newline							 io-&gtreq-&gtendpoint, strerror(errno));\newline		io-&gtstatus = USBI_IO_COMPLETED_FAIL;\newline		\newline		pthread_mutex_unlock(&ampio-&gtlock);\newline		pthread_mutex_unlock(&amphdev-&gtlock);\newline		return translate_errno(errno);\newline	}\newline	\newline	/* unlock the device &amp io request */\newline	pthread_mutex_unlock(&ampio-&gtlock);\newline	pthread_mutex_unlock(&amphdev-&gtlock);\newline\newline	/* always do this to avoid race conditions */\newline	wakeup_io_thread(hdev);\newline	\newline	return (ret);\newline}\newline",\newline linux_submit_ctrl\newline \newline Submits an io request to the control endpoint\newline \newline,5933653,parsedata.cpp,"void ParseData::makeProdFsms()\newline{\newline	/* There are two items in the index for each production (high and low). */\newline	int indexLen = prodList.length() * 2;\newline	dotItemIndex.setAsNew( indexLen );\newline	int dsiLow = 0, indexPos = 0;\newline\newline	/* Build FSMs for all production language elements. */\newline	for ( DefList::Iter prod = prodList; prod.lte(); prod++ ) {\newline		/* Verify that rhs references are legal. */\newline		checkReferences( prod );\newline		prod-&gtfsm = prod-&gtprodElList-&gtwalk( this );\newline	}\newline\newline	makeNonTermFirstSets();\newline	makeFirstSets();\newline\newline	/* Build FSMs for all production language elements. */\newline	for ( DefList::Iter prod = prodList; prod.lte(); prod++ ) {\newline		if ( addUniqueEmptyProductions ) {\newline			/* This must be re-implemented. */\newline			assert( false );\newline			//if ( !prod-&gtisLeftRec &amp&amp prod-&gtuniqueEmptyLeader != 0 ) {\newline			//	FsmAp *emptyLeader = prod-&gtuniqueEmptyLeader-&gtwalk( this );\newline			//	emptyLeader-&gtconcatOp( prod-&gtfsm );\newline			//	prod-&gtfsm = emptyLeader;\newline			//}\newline		}\newline\newline		/* Compute the machine&#039s length. */\newline		prod-&gtfsmLength = prod-&gtfsm-&gtfsmLength( );\newline\newline		/* Productions have a unique production id for each final state.\newline		 * This lets us use a production length specific to each final state.\newline		 * Start states are always isolated therefore if the start state is\newline		 * final then reductions from it will always have a fixed production\newline		 * length. This is a simple method for determining the length\newline		 * of zero-length derivations when reducing. */\newline\newline		/* Number of dot items needed for the production is elements + 1\newline		 * because the dot can be before the first and after the last element. */\newline		int numForProd = prod-&gtfsm-&gtstateList.length() + 1;\newline\newline		/* Set up the low and high values in the index for this production. */\newline		dotItemIndex.data[indexPos].key = dsiLow;\newline		dotItemIndex.data[indexPos].value = prod;\newline		dotItemIndex.data[indexPos+1].key = dsiLow + numForProd - 1;\newline		dotItemIndex.data[indexPos+1].value = prod;\newline\newline		int dsi = dsiLow;\newline		for ( StateList::Iter state = prod-&gtfsm-&gtstateList; state.lte(); state++, dsi++ ) {\newline			/* All transitions are shifts. */\newline			for ( TransMap::Iter out = state-&gttransMap; out.lte(); out++ )\newline				assert( out-&gtvalue-&gtisShift );\newline\newline			state-&gtdotSet.insert( dsi );\newline		}\newline\newline		/* Move over the production. */\newline		dsiLow += numForProd;\newline		indexPos += 2;\newline\newline		if ( prod-&gtprodCommit ) {\newline			for ( StateSet::Iter fin = prod-&gtfsm-&gtfinStateSet; fin.lte(); fin++ ) {\newline				int length = prod-&gtfsmLength;\newline				//cerr &lt&lt &quotPENDING COMMIT IN FINAL STATE of &quot &lt&lt prod-&gtprodId &lt&lt\newline				//		&quot with len: &quot &lt&lt length &lt&lt endl;\newline				(*fin)-&gtpendingCommits.insert( ProdIdPair( prod-&gtprodId, length ) );\newline			}\newline		}\newline	}\newline\newline	/* Make the final state specific prod id to prod id mapping. */\newline	prodIdIndex = new Definition*[prodList.length()];\newline	for ( DefList::Iter prod = prodList; prod.lte(); prod++ )\newline		prodIdIndex[prod-&gtprodId] = prod;\newline}\newline","Set up dot sets, shift info, and prod sets. \newline",5968821,hash.c,"struct hash_it_t *hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in)\newline{\newline	struct hash_it_t *iter;\newline\newline	if (iter_in == NULL) {\newline		iter = kmalloc(sizeof(struct hash_it_t), GFP_KERNEL);\newline		iter-&gtindex = -1;\newline		iter-&gtbucket = NULL;\newline		iter-&gtprev_bucket = NULL;\newline	} else {\newline		iter= iter_in;\newline	}\newline\newline	/* sanity checks first (if our bucket got deleted in the last iteration): */\newline	if (iter-&gtbucket != NULL) {\newline		if (iter-&gtfirst_bucket != NULL) {\newline			/* we&#039re on the first element and it got removed after the last iteration. */\newline			if ((*iter-&gtfirst_bucket) != iter-&gtbucket) {\newline				/* there are still other elements in the list */\newline				if ((*iter-&gtfirst_bucket) != NULL) {\newline					iter-&gtprev_bucket = NULL;\newline					iter-&gtbucket = (*iter-&gtfirst_bucket);\newline					iter-&gtfirst_bucket = &amphash-&gttable[iter-&gtindex];\newline					return iter;\newline				} else {\newline					iter-&gtbucket = NULL;\newline				}\newline			}\newline		} else if (iter-&gtprev_bucket != NULL) {\newline			/*\newline			* we&#039re not on the first element, and the bucket got removed after the last iteration.\newline			* the last bucket&#039s next pointer is not pointing to our actual bucket anymore.\newline			* select the next.\newline			*/\newline			if (iter-&gtprev_bucket-&gtnext != iter-&gtbucket)\newline				iter-&gtbucket = iter-&gtprev_bucket;\newline		}\newline	}\newline\newline	/* now as we are sane, select the next one if there is some */\newline	if (iter-&gtbucket != NULL) {\newline		if (iter-&gtbucket-&gtnext != NULL) {\newline			iter-&gtprev_bucket = iter-&gtbucket;\newline			iter-&gtbucket = iter-&gtbucket-&gtnext;\newline			iter-&gtfirst_bucket = NULL;\newline			return iter;\newline		}\newline	}\newline\newline	/* if not returned yet, we&#039ve reached the last one on the index and have to search forward */\newline	iter-&gtindex++;\newline	/* go through the entries of the hash table */\newline	while (iter-&gtindex &lt hash-&gtsize) {\newline		if ((hash-&gttable[iter-&gtindex]) != NULL){\newline			iter-&gtprev_bucket = NULL;\newline			iter-&gtbucket = hash-&gttable[iter-&gtindex];\newline			iter-&gtfirst_bucket = &amphash-&gttable[iter-&gtindex];\newline			return iter;\newline		} else {\newline			iter-&gtindex++;\newline		}\newline	}\newline\newline	/* nothing to iterate over anymore */\newline	kfree(iter);\newline	return NULL;\newline}\newline",iterate though the hash. first element is selected with iter_in NULL.\newline use the returned iterator to access the elements until hash_it_t returns NULL. \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,6267943,vfunc_simplevec.cpp,"void activeSimplevec( int n, int m, adouble* indeps, adouble* deps ) {\newline    int i, j;\newline    adouble temp = 1.0;\newline    for (j=0; j&ltm; j++) {\newline        deps[j] = temp;\newline        for (i=0; i&ltn; i++)\newline            deps[j] *= indeps[i];\newline        temp = deps[j];\newline    }\newline}\newline",The simple adouble vector function \newline,5844695,readheader.cpp,"int read_tape_header(char *buffer, tapeheader_t *header)\newline{\newline  static char *receivers[]={&quot&quot,&quotsynthetic&quot,&quotao1420&quot};\newline  int done=0,len;\newline  int pos=0,i;\newline  char tmpstr[256];\newline  double dummy;\newline  unsigned int firstdata;\newline\newline  do {\newline    len=strlen(buffer+pos)+1;\newline    if (!strncmp(buffer+pos,&quotEOH=&quot,4)) {\newline      done=1;\newline    } else if (!strncmp(buffer+pos,&quotNAME=&quot,5)) {\newline       strncpy(tmpstr,buffer+pos+5,36);\newline       i=0;\newline       while(!isalnum(tmpstr[i])) i++;\newline       strncpy(header-&gtname,tmpstr+i,36);\newline    } else if (!strncmp(buffer+pos,&quotRCDTYPE=&quot,8)) {\newline       sscanf(buffer+pos+8,&quot%d&quot,&amp(header-&gtrcdtype));\newline    } else if (!strncmp(buffer+pos,&quotFRAMESEQ=&quot,9)) {\newline       sscanf(buffer+pos+9,&quot%lu&quot,&amp(header-&gtframeseq));\newline    } else if (!strncmp(buffer+pos,&quotDATASEQ=&quot,8)) {\newline       sscanf(buffer+pos+8,&quot%lu&quot,&amp(header-&gtdataseq));\newline    } else if (!strncmp(buffer+pos,&quotNUMRINGBUFS=&quot,12)) {\newline       sscanf(buffer+pos+12,&quot%d&quot,&amp(header-&gtnumringbufs));\newline    } else if (!strncmp(buffer+pos,&quotNUMDISKBUFS=&quot,12)) {\newline       sscanf(buffer+pos+12,&quot%d&quot,&amp(header-&gtnumdiskbufs));\newline    } else if (!strncmp(buffer+pos,&quotMISSED=&quot,7)) {\newline       sscanf(buffer+pos+7,&quot%d&quot,&amp(header-&gtmissed));\newline    } else if (!strncmp(buffer+pos,&quotAST=&quot,4)) {\newline       sscanf(buffer+pos+4,&quot%2d%3d%2d%2d%2d%2d&quot,\newline	 &amp(header-&gtst.y), &amp(header-&gtst.d), &amp(header-&gtst.h),\newline	 &amp(header-&gtst.m), &amp(header-&gtst.s), &amp(header-&gtst.c));\newline	 header-&gtst.tz=AST;\newline    } else if (!strncmp(buffer+pos,&quotTELSTR=&quot,7)) {\newline       sscanf(buffer+pos+7,&quot%2d%3d%2d%2d%2d %lf %lf %lf&quot,\newline	 &amp(header-&gttelstr.st.y), &amp(header-&gttelstr.st.d), \newline	 &amp(header-&gttelstr.st.h), &amp(header-&gttelstr.st.m), \newline	 &amp(header-&gttelstr.st.s), &amp(header-&gttelstr.az), \newline	 gregorian?&amp(header-&gttelstr.alt):&ampdummy,\newline	 gregorian?&ampdummy:&amp(header-&gttelstr.alt));\newline	 header-&gttelstr.alt=90.0-header-&gttelstr.alt;\newline	 header-&gttelstr.st.tz=AST;\newline	 header-&gttelstr.st.c=0;\newline    } else if (!strncmp(buffer+pos,&quotRECEIVER=&quot,9)) {\newline       i=1;\newline       while ((!strstr(buffer+pos+9,receivers[i])) &amp&amp (++i&ltNUM_SRCS)) ;\newline       if (i==NUM_SRCS) {\newline          log_messages.printf(SCHED_MSG_LOG::MSG_NORMAL,&quotUnknown receiver: %s\\n&quot,buffer+pos+9);\newline	  header-&gtsource=0;\newline       } else {\newline	  header-&gtsource=i;\newline       }\newline    } else if (!strncmp(buffer+pos,&quotCENTERFREQ=&quot,11)) {\newline       sscanf(buffer+pos+11,&quot%lf&quot,&amp(header-&gtcenterfreq));\newline       header-&gtcenterfreq*=1e6;\newline    } else if (!strncmp(buffer+pos,&quotSAMPLERATE=&quot,11)) {\newline       sscanf(buffer+pos+11,&quot%lf&quot,&amp(header-&gtsamplerate));\newline       header-&gtsamplerate*=1e6;\newline    } else if (!strncmp(buffer+pos,&quotVER=&quot,4)) {\newline       strncpy(&amp(header-&gtversion[0]),&amp(buffer[pos+4]),16);\newline    } else if (len&gt1) {\newline       log_messages.printf(SCHED_MSG_LOG::MSG_NORMAL,&quotUnknown header field: %40s\\n&quot,buffer+pos);\newline    }\newline    pos+=len;\newline  } while (!done &amp&amp (pos&ltTAPE_HEADER_SIZE));\newline/* Right now were only doing this for one observatory. (Arecibo)\newline * May want to change list later to a switch statement on the reciever \newline */\newline\newline  st_time_convert(&amp(header-&gtst));\newline  header-&gtst.jd-=(float)RECORDER_BUFFER_SAMPLES/header-&gtsamplerate/86400;\newline  st_time_convert(&amp(header-&gttelstr.st));\newline  telstr_coord_convert(&amp(header-&gttelstr),ARECIBO_LAT,ARECIBO_LON);\newline\newline/*\newline * Fix a bug in recorder versions prior to 1.30\newline */\newline\newline if (atof(&amp(header-&gtversion[0]))&lt1.299) {\newline   header-&gtcenterfreq-=2.0;\newline }\newline\newline/*\newline * Check for blank tape\newline */\newline  firstdata=*(unsigned int *)(buffer+TAPE_HEADER_SIZE);\newline  if (!(firstdata &amp 0x55555555) || !(firstdata &amp 0xaaaaaaaa) ||\newline       ((firstdata &amp 0x55555555) == 0x55555555) ||\newline       ((firstdata &amp 0xaaaaaaaa) == 0xaaaaaaaa)) {\newline    header-&gtmissed++;\newline    log_messages.printf(SCHED_MSG_LOG::MSG_NORMAL,&quotPossible data problem...data[0] = 0x%x\\n&quot,firstdata);\newline  }\newline\newline  return(1);\newline}\newline",Read a tape header at buffer into a tapeheader_t \newline,6213352,dsputil.h,"static inline void ff_fft_calc(FFTContext *s, FFTComplex *z)\newline{\newline    s-&gtfft_calc(s, z);\newline}\newline",\newline Do a complex FFT with the parameters defined in ff_fft_init(). The\newline input data must be permuted before. No 1.0/sqrt(n) normalization is done.\newline \newline,4943734,partitions.c,"int blkid_probe_is_covered_by_pt(blkid_probe pr,\newline				 uint64_t offset, uint64_t size)\newline{\newline	blkid_probe prc = NULL;\newline	blkid_partlist ls = NULL;\newline	uint64_t start, end;\newline	int nparts, i, rc = 0;\newline\newline	DBG(LOWPROBE, ul_debug(\newline		&quot=&gt checking if off=%&quotPRIu64&quot size=%&quotPRIu64&quot covered by PT&quot,\newline		offset, size));\newline\newline	if (pr-&gtflags &amp BLKID_FL_NOSCAN_DEV)\newline		goto done;\newline\newline	prc = blkid_clone_probe(pr);\newline	if (!prc)\newline		goto done;\newline\newline	ls = blkid_probe_get_partitions(prc);\newline	if (!ls)\newline		goto done;\newline\newline	nparts = blkid_partlist_numof_partitions(ls);\newline	if (!nparts)\newline		goto done;\newline\newline	end = (offset + size) &gt&gt 9;\newline	start = offset &gt&gt 9;\newline\newline	/* check if the partition table fits into the device */\newline	for (i = 0; i &lt nparts; i++) {\newline		blkid_partition par = &ampls-&gtparts[i];\newline\newline		if (par-&gtstart + par-&gtsize &gt (pr-&gtsize &gt&gt 9)) {\newline			DBG(LOWPROBE, ul_debug(&quotpartition #%d overflows &quot\newline				&quotdevice (off=%&quot PRId64 &quot size=%&quot PRId64 &quot)&quot,\newline				par-&gtpartno, par-&gtstart, par-&gtsize));\newline			goto done;\newline		}\newline	}\newline\newline	/* check if the requested area is covered by PT */\newline	for (i = 0; i &lt nparts; i++) {\newline		blkid_partition par = &ampls-&gtparts[i];\newline\newline		if (start &gt= par-&gtstart &amp&amp end &lt= par-&gtstart + par-&gtsize) {\newline			rc = 1;\newline			break;\newline		}\newline	}\newlinedone:\newline	blkid_free_probe(prc);\newline\newline	DBG(LOWPROBE, ul_debug(&quot&lt= %s covered by PT&quot, rc ? &quotIS&quot : &quotNOT&quot));\newline	return rc;\newline}\newline",\newline Returns 1 if the device is whole-disk and the area specified by @offset and\newline @size is covered by any partition.\newline \newline,1525255,gdw.cpp,"void Gdw::fs_set_view(int number, int addFlag)\newline{\newline  Q3ListViewItemIterator it(varListView, Q3ListViewItemIterator::Selected);\newline  QString orgName, orgType, orgID;\newline  while (it.current()) {\newline    orgID = it.current()-&gttext(2);\newline    if (!orgID.isEmpty()) {\newline      orgName = it.current()-&gttext(0);\newline      orgType = it.current()-&gttext(1);\newline      it.current()-&gtsetText(0, orgName + &quot (FS group)&quot);\newline      it.current()-&gtsetText(1, QString::null);\newline      it.current()-&gtsetText(2, QString::null);\newline      if (addFlag)\newline	(void) new Q3ListViewItem(it.current(), orgName + &quot [DC]&quot, orgType, orgID); \newline      QString nameStr;\newline      for (int i = 1; i &lt= number; i++) {\newline	nameStr = orgName + &quot [sin #&quot + QString::number(i) + &quot]&quot;	\newline	(void) new Q3ListViewItem(it.current(), getLastChild(it.current()), nameStr, orgType, orgID); \newline	nameStr = orgName + &quot [cos #&quot + QString::number(i) + &quot]&quot;	\newline	(void) new Q3ListViewItem(it.current(), getLastChild(it.current()), nameStr, orgType, orgID); \newline      }\newline      it.current()-&gtsetOpen(true);\newline    }\newline    ++it;\newline  }\newline}\newline","Update varListView for new Fourier Set covariates \newline This step could be done at the same time when covList is updated,\newline but that makes debugging more difficult \newline",4399360,title_dialog.c,"static int menu_title_quit(gg_widget_t *widget, gg_widget_t *emitter, void *data, void *extra_data)\newline{\newline    set_title_process_retval(1);\newline    gg_dialog_close();\newline    return 1;\newline}\newline",@brief Triggers DreamChess exit. \newline,3334649,fwdovl5.c,"int is_route (char *route)\newline{\newline	Route *r_ptr = pvoie-&gtr_tete;\newline	char *ptr;\newline	int nb;\newline\newline	df (&quotis_route&quot, 2);\newline	while (r_ptr)\newline	{\newline		for (nb = 0; nb &lt NBROUTE; nb++)\newline		{\newline			ptr = r_ptr-&gtcall[nb];\newline			if (*ptr == &#039\\0&#039)\newline				break;\newline			if (strcmp (route, ptr) == 0)\newline			{\newline				ff ();\newline				return (1);\newline			}\newline		}\newline		r_ptr = r_ptr-&gtsuite;\newline	}\newline	ff ();\newline	return (0);\newline}\newline",Teste si la route existe dans les headers \newline,1673464,ebjs.c,"jsobjtype run_function_object(jsobjtype obj, const char *name)\newline{\newline	run_function(obj, name, 0, NULL);\newline	if (!propval)\newline		return NULL;\newline	if (head.proptype == EJ_PROP_OBJECT || head.proptype == EJ_PROP_ARRAY) {\newline		jsobjtype p;\newline		sscanf(propval, &quot%p&quot, &ampp);\newline		nzFree(propval);\newline		propval = 0;\newline		return p;\newline	}\newline/* wrong type, just return NULL */\newline	nzFree(propval);\newline	propval = 0;\newline	return NULL;\newline}				/* run_function_object */\newline",run a function with no args that returns an object \newline,3834196,serial.c,"int serial_init(void)\newline{\newline	int initialized = 0;\newline	int status;\newline	int divisor, lcs;\newline\newline	divisor = COMBRD;\newline	lcs = UART_LCS;\newline\newline\newline#ifdef COMPRESERVE\newline	lcs = inb(COMCONSOLE + UART_LCR) &amp 0x7f;\newline	outb(0x80 | lcs, COMCONSOLE + UART_LCR);\newline	divisor = (inb(COMCONSOLE + UART_DLM) &lt&lt 8) | inb(COMCONSOLE + UART_DLL);\newline	outb(lcs, COMCONSOLE + UART_LCR);\newline#endif\newline\newline	/* Set Baud Rate Divisor to CONSPEED, and test to see if the\newline	 * serial port appears to be present.\newline	 */\newline	outb(0x80 | lcs, COMCONSOLE + UART_LCR);\newline	outb(0xaa, COMCONSOLE + UART_DLL);\newline	if (inb(COMCONSOLE + UART_DLL) != 0xaa) \newline		goto out;\newline	outb(0x55, COMCONSOLE + UART_DLL);\newline	if (inb(COMCONSOLE + UART_DLL) != 0x55)\newline		goto out;\newline	outb(divisor &amp 0xff, COMCONSOLE + UART_DLL);\newline	if (inb(COMCONSOLE + UART_DLL) != (divisor &amp 0xff))\newline		goto out;\newline	outb(0xaa, COMCONSOLE + UART_DLM);\newline	if (inb(COMCONSOLE + UART_DLM) != 0xaa) \newline		goto out;\newline	outb(0x55, COMCONSOLE + UART_DLM);\newline	if (inb(COMCONSOLE + UART_DLM) != 0x55)\newline		goto out;\newline	outb((divisor &gt&gt 8) &amp 0xff, COMCONSOLE + UART_DLM);\newline	if (inb(COMCONSOLE + UART_DLM) != ((divisor &gt&gt 8) &amp 0xff))\newline		goto out;\newline	outb(lcs, COMCONSOLE + UART_LCR);\newline	\newline	/* disable interrupts */\newline	outb(0x0, COMCONSOLE + UART_IER);\newline\newline	/* disable fifo&#039s */\newline	outb(0x00, COMCONSOLE + UART_FCR);\newline\newline	/* Set clear to send, so flow control works... */\newline	outb((1&lt&lt1), COMCONSOLE + UART_MCR);\newline\newline\newline	/* Flush the input buffer. */\newline	do {\newline		/* rx buffer reg\newline		 * throw away (unconditionally the first time)\newline		 */\newline		inb(COMCONSOLE + UART_RBR);\newline		/* line status reg */\newline		status = inb(COMCONSOLE + UART_LSR);\newline	} while(status &amp 1);\newline	initialized = 1;\newline out:\newline	found = initialized;\newline	return initialized;\newline}\newline","\newline int serial_init(void);\newline Initialize port COMCONSOLE to speed CONSPEED, line settings 8N1.\newline \newline",5400601,main.c,"static sasl_mechanism_t *find_mechanism(char *name)\newline{\newline	mowgli_node_t *n;\newline	sasl_mechanism_t *mptr;\newline\newline	MOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\newline	{\newline		mptr = n-&gtdata;\newline		if(!strcmp(mptr-&gtname, name))\newline			return mptr;\newline	}\newline\newline	slog(LG_DEBUG, &quotfind_mechanism(): cannot find mechanism `%s&#039!&quot, name);\newline\newline	return NULL;\newline}\newline",find a mechanism by name \newline,2166474,eftd.c,"static int eft_setup_user(struct eft * eft)\newline{\newline#ifdef CONFIG_EFTD_WUAUTH\newline#if 0	/*\newline	 * FIXME: for stuff like sending messages, which can only be\newline	 * execuded after access regime is established, we need to\newline	 * implement a hook function in the tdu state machine which\newline	 * is called after access regime is established.\newline	 */\newline	eft_msg(eft,autherrmsg);\newline#endif\newline	/* tdu_printf(TDU_LOG_LOG,&quoterrmsg=%s\\n&quot,autherrmsg); */\newline#endif\newline	/* if( ! eft_remote_has_navigation(eft) ) */ chdir(eft_flat_dir_name);\newline	return 0;\newline}\newline",\newline This is to perform further setup after access regime has been established.\newline \newline \newline,4553216,radiusplugin.cpp,"void write_auth_control_file(PluginContext * context, string filename, char c)\newline{\newline  ofstream file;\newline  file.open(filename.c_str(),ios::out);\newline  if ( DEBUG ( context-&gtgetVerbosity() ))\newline    cerr &lt&lt getTime() &lt&lt &quotRADIUS-PLUGIN: Write &quot &lt&lt c &lt&lt &quot to auth_control_file &quot&lt&lt filename &lt&lt &quot.\\n&quot;\newline  if (file.is_open())\newline  {\newline    file &lt&lt c;\newline    file.close();\newline  }\newline  else\newline  {\newline    cerr &lt&lt getTime() &lt&lt &quotRADIUS-PLUGIN: Could not open auth_control_file &quot&lt&lt filename &lt&lt &quot.\\n&quot;\newline  }\newline\newline}\newline","Writes the result of the authentication to the auth control file (0: failure, 1: success).\newline @param filename The auth control file.\newline @param c The authentication result.\newline \newline",,on,,on,,on,,on,,,,,on,,on,,,,,on,,,,,,,,,,,,,,,,,,,,,,,Tell source of randomness.,{},Read a tape header at buffer into a tapeheader_t,{},Returns 1 if the device is whole-disk,{},Triggers DreamChess exit.,{},run a function with no args that returns an object,"Initialize port COMCONSOLE to speed CONSPEED, line settings 8N1.",find a mechanism by name,Convert score to a percent confidence,{},Writes the result of the authentication to the auth control file,{},Creates a new event handle.,handles the message generated by the IL client,Submits an io request to the control endpoint,"Set up dot sets, shift info, and prod sets.",{},Load an image from the named file.,x,
3PA41K45VN4OVI8QQIQQKF2GPK1P76,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:14 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:14 PDT 2019,,,34YB12FSQYO3QSJ7H77TY7H31DRMGC,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:43 PDT 2019,Fri Apr 26 13:05:10 PDT 2019,Sun Apr 28 13:05:10 PDT 2019,,,,1047,100% (62/62),100% (62/62),0% (0/0),4492935,lsmbox.c,"static char *path_expand(const char *str)\newline{\newline	char *tmp = NULL, *tmp2 = NULL;\newline	struct passwd *pw;\newline\newline	if (!strcmp(str, &quot!&quot))\newline		tmp = strdup_null(spoolfilepath);\newline	else if (*str == &#039+&#039 || *str == &#039=&#039)\newline		tmp = strjoin(&quot/&quot, mailfolderpath, str + 1, NULL);\newline	else if (strchr(str, &#039/&#039))\newline		tmp = strdup(str);\newline	else\newline		tmp = strjoin(&quot/&quot, mailfolderpath, str, NULL);\newline\newline	if (*tmp == &#039~&#039) {\newline		char *rest = NULL;\newline\newline		if (*(tmp + 1) == &#039/&#039) {\newline			assert((pw = getpwuid(getuid())));\newline		} else {\newline			char *name = strdup_null(tmp + 1);\newline			char *end;\newline			end = strchr(name, &#039/&#039);\newline			*end = &#039\\0&#039;\newline			assert((pw = getpwnam(name)));\newline			free(name);\newline		}\newline\newline		rest = strchr(tmp, &#039/&#039) + 1;\newline		tmp2 = strjoin(&quot/&quot, pw-&gtpw_dir, rest, NULL);\newline	} else {\newline		tmp2 = strdup_null(tmp);\newline	}\newline\newline	free(tmp);\newline\newline	return tmp2;\newline}\newline",\newline Expand a path-name\newline \newline @param str The path to expand\newline @return A pointer to the string with the new path;\newline needs to be freed after use\newline \newline,4476812,asynch.c,"int set_timeout(unsigned type, const char* val)\newline{\newline	int rc = set_tv(type, val, &amprequest_tm);\newline\newline	if (!rc) {\newline		synch_mode = is_zero_tm(&amprequest_tm);\newline		if (!synch_mode &amp&amp is_zero_tm(&amprestore_tm))\newline			restore_tm = defrest_tm;\newline	}\newline\newline	return rc;\newline}\newline",\newline set operation timeout\newline \newline,4855223,profiler.c,"static void profiler_dealloc() {\newline\newline  int i;  /* Loop iterator */\newline\newline  /* Deallocate profiling output name */\newline  free_safe( profiling_output, (strlen( profiling_output ) + 1) );\newline\newline  /* Iterate through the profiler array and deallocate all timer structures */\newline  for( i=0; i&ltNUM_PROFILES; i++ ) {\newline    free_safe( profiles[i].time_in, sizeof( timer ) );\newline  }\newline\newline}\newline",!\newlineDeallocates all allocated memory for profiler.\newline \newline,6434828,send.c,static int can_send(struct Client* to)\newline{\newline  assert(0 != to);\newline  return (IsDead(to) || IsMe(to) || -1 == cli_fd(to)) ? 0 : 1;\newline}\newline,Test whether we can send to a client.\newline @param[in] to Client we want to send to.\newline @return Non-zero if we can send to the client.\newline \newline,5983595,wrapper.c,"int wrapperBuildJavaCommandArrayClasspath(TCHAR **strings, int addQuotes, int index, const TCHAR *classpath) {\newline    size_t len;\newline    size_t cpLen;\newline\newline    /* Store the classpath */\newline    if (strings) {\newline        strings[index] = malloc(sizeof(TCHAR) * (10 + 1));\newline        if (!strings[index]) {\newline            outOfMemory(TEXT(&quotWBJCAC&quot), 1);\newline            return -1;\newline        }\newline        _sntprintf(strings[index], 10 + 1, TEXT(&quot-classpath&quot));\newline    }\newline    index++;\newline    if (strings) {\newline        cpLen = 0;\newline\newline        len = _tcslen(classpath);\newline        strings[index] = malloc(sizeof(TCHAR) * (len + 4));\newline        if (!strings[index]) {\newline            outOfMemory(TEXT(&quotWBJCAC&quot), 2);\newline            return -1;\newline        }\newline\newline        /* Add an open quote the classpath */\newline        if (addQuotes) {\newline            _sntprintf(&amp(strings[index][cpLen]), len + 4 - cpLen, TEXT(&quot\\&quot&quot));\newline            cpLen++;\newline        }\newline\newline        _sntprintf(&amp(strings[index][cpLen]), len + 4 - cpLen, TEXT(&quot%s&quot), classpath);\newline        cpLen += len;\newline\newline        /* Add ending quote.  If the previous character is a backslash then\newline         *  Windows will use it to escape the quote.  To make things work\newline         *  correctly, we need to add another backslash first so it will\newline         *  result in a single backslash before the quote. */\newline        if (addQuotes) {\newline            if (strings[index][cpLen - 1] == TEXT(&#039\\\\&#039)) {\newline                _sntprintf(&amp(strings[index][cpLen]), len + 4 - cpLen, TEXT(&quot\\\\&quot));\newline                cpLen++;\newline            }\newline            _sntprintf(&amp(strings[index][cpLen]), len + 4 - cpLen, TEXT(&quot\\&quot&quot));\newline            cpLen++;\newline        }\newline\newline        if (addQuotes) {\newline            wrapperCheckQuotes(strings[index], TEXT(&quotwrapper.java.classpath.&ltn&gt&quot));\newline        }\newline    }\newline    index++;\newline\newline    return index;\newline}\newline","\newline Builds up the java classpath section of the Java command line.\newline \newline @return The final index into the strings array, or -1 if there were any problems.\newline \newline",993843,infback.c,"int ZEXPORT inflateBack(\newline    z_streamp strm,\newline    in_func in,\newline    void FAR *in_desc,\newline    out_func out,\newline    void FAR *out_desc)\newline{\newline    struct inflate_state FAR *state;\newline    z_const unsigned char FAR *next;    /* next input */\newline    unsigned char FAR *put;     /* next output */\newline    unsigned have, left;        /* available input and output */\newline    unsigned long hold;         /* bit buffer */\newline    unsigned bits;              /* bits in bit buffer */\newline    unsigned copy;              /* number of stored or match bytes to copy */\newline    unsigned char FAR *from;    /* where to copy match bytes from */\newline    code here;                  /* current decoding table entry */\newline    code last;                  /* parent table entry */\newline    unsigned len;               /* length to copy for repeats, bits to drop */\newline    int ret;                    /* return code */\newline    static const unsigned short order[19] = /* permutation of code lengths */\newline        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\newline\newline    /* Check that the strm exists and that the state was initialized */\newline    if (strm == Z_NULL || strm-&gtstate == Z_NULL)\newline        return Z_STREAM_ERROR;\newline    state = (struct inflate_state FAR *)strm-&gtstate;\newline\newline    /* Reset the state */\newline    strm-&gtmsg = Z_NULL;\newline    state-&gtmode = TYPE;\newline    state-&gtlast = 0;\newline    state-&gtwhave = 0;\newline    next = strm-&gtnext_in;\newline    have = next != Z_NULL ? strm-&gtavail_in : 0;\newline    hold = 0;\newline    bits = 0;\newline    put = state-&gtwindow;\newline    left = state-&gtwsize;\newline\newline    /* Inflate until end of block marked as last */\newline    for (;;)\newline        switch (state-&gtmode) {\newline        case TYPE:\newline            /* determine and dispatch block type */\newline            if (state-&gtlast) {\newline                BYTEBITS();\newline                state-&gtmode = DONE;\newline                break;\newline            }\newline            NEEDBITS(3);\newline            state-&gtlast = BITS(1);\newline            DROPBITS(1);\newline            switch (BITS(2)) {\newline            case 0:                             /* stored block */\newline                Tracev((stderr, &quotinflate:     stored block%s\\n&quot,\newline                        state-&gtlast ? &quot (last)&quot : &quot&quot));\newline                state-&gtmode = STORED;\newline                break;\newline            case 1:                             /* fixed block */\newline                fixedtables(state);\newline                Tracev((stderr, &quotinflate:     fixed codes block%s\\n&quot,\newline                        state-&gtlast ? &quot (last)&quot : &quot&quot));\newline                state-&gtmode = LEN;              /* decode codes */\newline                break;\newline            case 2:                             /* dynamic block */\newline                Tracev((stderr, &quotinflate:     dynamic codes block%s\\n&quot,\newline                        state-&gtlast ? &quot (last)&quot : &quot&quot));\newline                state-&gtmode = TABLE;\newline                break;\newline            case 3:\newline                strm-&gtmsg = (char *)&quotinvalid block type&quot;\newline                state-&gtmode = BAD;\newline            }\newline            DROPBITS(2);\newline            break;\newline\newline        case STORED:\newline            /* get and verify stored block length */\newline            BYTEBITS();                         /* go to byte boundary */\newline            NEEDBITS(32);\newline            if ((hold &amp 0xffff) != ((hold &gt&gt 16) ^ 0xffff)) {\newline                strm-&gtmsg = (char *)&quotinvalid stored block lengths&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            state-&gtlength = (unsigned)hold &amp 0xffff;\newline            Tracev((stderr, &quotinflate:       stored length %u\\n&quot,\newline                    state-&gtlength));\newline            INITBITS();\newline\newline            /* copy stored block from input to output */\newline            while (state-&gtlength != 0) {\newline                copy = state-&gtlength;\newline                PULL();\newline                ROOM();\newline                if (copy &gt have) copy = have;\newline                if (copy &gt left) copy = left;\newline                zmemcpy(put, next, copy);\newline                have -= copy;\newline                next += copy;\newline                left -= copy;\newline                put += copy;\newline                state-&gtlength -= copy;\newline            }\newline            Tracev((stderr, &quotinflate:       stored end\\n&quot));\newline            state-&gtmode = TYPE;\newline            break;\newline\newline        case TABLE:\newline            /* get dynamic table entries descriptor */\newline            NEEDBITS(14);\newline            state-&gtnlen = BITS(5) + 257;\newline            DROPBITS(5);\newline            state-&gtndist = BITS(5) + 1;\newline            DROPBITS(5);\newline            state-&gtncode = BITS(4) + 4;\newline            DROPBITS(4);\newline#ifndef PKZIP_BUG_WORKAROUND\newline            if (state-&gtnlen &gt 286 || state-&gtndist &gt 30) {\newline                strm-&gtmsg = (char *)&quottoo many length or distance symbols&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline#endif\newline            Tracev((stderr, &quotinflate:       table sizes ok\\n&quot));\newline\newline            /* get code length code lengths (not a typo) */\newline            state-&gthave = 0;\newline            while (state-&gthave &lt state-&gtncode) {\newline                NEEDBITS(3);\newline                state-&gtlens[order[state-&gthave++]] = (unsigned short)BITS(3);\newline                DROPBITS(3);\newline            }\newline            while (state-&gthave &lt 19)\newline                state-&gtlens[order[state-&gthave++]] = 0;\newline            state-&gtnext = state-&gtcodes;\newline            state-&gtlencode = (code const FAR *)(state-&gtnext);\newline            state-&gtlenbits = 7;\newline            ret = inflate_table(CODES, state-&gtlens, 19, &amp(state-&gtnext),\newline                                &amp(state-&gtlenbits), state-&gtwork);\newline            if (ret) {\newline                strm-&gtmsg = (char *)&quotinvalid code lengths set&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            Tracev((stderr, &quotinflate:       code lengths ok\\n&quot));\newline\newline            /* get length and distance code code lengths */\newline            state-&gthave = 0;\newline            while (state-&gthave &lt state-&gtnlen + state-&gtndist) {\newline                for (;;) {\newline                    here = state-&gtlencode[BITS(state-&gtlenbits)];\newline                    if ((unsigned)(here.bits) &lt= bits) break;\newline                    PULLBYTE();\newline                }\newline                if (here.val &lt 16) {\newline                    DROPBITS(here.bits);\newline                    state-&gtlens[state-&gthave++] = here.val;\newline                }\newline                else {\newline                    if (here.val == 16) {\newline                        NEEDBITS(here.bits + 2);\newline                        DROPBITS(here.bits);\newline                        if (state-&gthave == 0) {\newline                            strm-&gtmsg = (char *)&quotinvalid bit length repeat&quot;\newline                            state-&gtmode = BAD;\newline                            break;\newline                        }\newline                        len = (unsigned)(state-&gtlens[state-&gthave - 1]);\newline                        copy = 3 + BITS(2);\newline                        DROPBITS(2);\newline                    }\newline                    else if (here.val == 17) {\newline                        NEEDBITS(here.bits + 3);\newline                        DROPBITS(here.bits);\newline                        len = 0;\newline                        copy = 3 + BITS(3);\newline                        DROPBITS(3);\newline                    }\newline                    else {\newline                        NEEDBITS(here.bits + 7);\newline                        DROPBITS(here.bits);\newline                        len = 0;\newline                        copy = 11 + BITS(7);\newline                        DROPBITS(7);\newline                    }\newline                    if (state-&gthave + copy &gt state-&gtnlen + state-&gtndist) {\newline                        strm-&gtmsg = (char *)&quotinvalid bit length repeat&quot;\newline                        state-&gtmode = BAD;\newline                        break;\newline                    }\newline                    while (copy--)\newline                        state-&gtlens[state-&gthave++] = (unsigned short)len;\newline                }\newline            }\newline\newline            /* handle error breaks in while */\newline            if (state-&gtmode == BAD) break;\newline\newline            /* check for end-of-block code (better have one) */\newline            if (state-&gtlens[256] == 0) {\newline                strm-&gtmsg = (char *)&quotinvalid code -- missing end-of-block&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline\newline            /* build code tables -- note: do not change the lenbits or distbits\newline               values here (9 and 6) without reading the comments in inftrees.h\newline               concerning the ENOUGH constants, which depend on those values */\newline            state-&gtnext = state-&gtcodes;\newline            state-&gtlencode = (code const FAR *)(state-&gtnext);\newline            state-&gtlenbits = 9;\newline            ret = inflate_table(LENS, state-&gtlens, state-&gtnlen, &amp(state-&gtnext),\newline                                &amp(state-&gtlenbits), state-&gtwork);\newline            if (ret) {\newline                strm-&gtmsg = (char *)&quotinvalid literal/lengths set&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            state-&gtdistcode = (code const FAR *)(state-&gtnext);\newline            state-&gtdistbits = 6;\newline            ret = inflate_table(DISTS, state-&gtlens + state-&gtnlen, state-&gtndist,\newline                            &amp(state-&gtnext), &amp(state-&gtdistbits), state-&gtwork);\newline            if (ret) {\newline                strm-&gtmsg = (char *)&quotinvalid distances set&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            Tracev((stderr, &quotinflate:       codes ok\\n&quot));\newline            state-&gtmode = LEN;\newline\newline        case LEN:\newline            /* use inflate_fast() if we have enough input and output */\newline            if (have &gt= 6 &amp&amp left &gt= 258) {\newline                RESTORE();\newline                if (state-&gtwhave &lt state-&gtwsize)\newline                    state-&gtwhave = state-&gtwsize - left;\newline                inflate_fast(strm, state-&gtwsize);\newline                LOAD();\newline                break;\newline            }\newline\newline            /* get a literal, length, or end-of-block code */\newline            for (;;) {\newline                here = state-&gtlencode[BITS(state-&gtlenbits)];\newline                if ((unsigned)(here.bits) &lt= bits) break;\newline                PULLBYTE();\newline            }\newline            if (here.op &amp&amp (here.op &amp 0xf0) == 0) {\newline                last = here;\newline                for (;;) {\newline                    here = state-&gtlencode[last.val +\newline                            (BITS(last.bits + last.op) &gt&gt last.bits)];\newline                    if ((unsigned)(last.bits + here.bits) &lt= bits) break;\newline                    PULLBYTE();\newline                }\newline                DROPBITS(last.bits);\newline            }\newline            DROPBITS(here.bits);\newline            state-&gtlength = (unsigned)here.val;\newline\newline            /* process literal */\newline            if (here.op == 0) {\newline                Tracevv((stderr, here.val &gt= 0x20 &amp&amp here.val &lt 0x7f ?\newline                        &quotinflate:         literal &#039%c&#039\\n&quot :\newline                        &quotinflate:         literal 0x%02x\\n&quot, here.val));\newline                ROOM();\newline                *put++ = (unsigned char)(state-&gtlength);\newline                left--;\newline                state-&gtmode = LEN;\newline                break;\newline            }\newline\newline            /* process end of block */\newline            if (here.op &amp 32) {\newline                Tracevv((stderr, &quotinflate:         end of block\\n&quot));\newline                state-&gtmode = TYPE;\newline                break;\newline            }\newline\newline            /* invalid code */\newline            if (here.op &amp 64) {\newline                strm-&gtmsg = (char *)&quotinvalid literal/length code&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline\newline            /* length code -- get extra bits, if any */\newline            state-&gtextra = (unsigned)(here.op) &amp 15;\newline            if (state-&gtextra != 0) {\newline                NEEDBITS(state-&gtextra);\newline                state-&gtlength += BITS(state-&gtextra);\newline                DROPBITS(state-&gtextra);\newline            }\newline            Tracevv((stderr, &quotinflate:         length %u\\n&quot, state-&gtlength));\newline\newline            /* get distance code */\newline            for (;;) {\newline                here = state-&gtdistcode[BITS(state-&gtdistbits)];\newline                if ((unsigned)(here.bits) &lt= bits) break;\newline                PULLBYTE();\newline            }\newline            if ((here.op &amp 0xf0) == 0) {\newline                last = here;\newline                for (;;) {\newline                    here = state-&gtdistcode[last.val +\newline                            (BITS(last.bits + last.op) &gt&gt last.bits)];\newline                    if ((unsigned)(last.bits + here.bits) &lt= bits) break;\newline                    PULLBYTE();\newline                }\newline                DROPBITS(last.bits);\newline            }\newline            DROPBITS(here.bits);\newline            if (here.op &amp 64) {\newline                strm-&gtmsg = (char *)&quotinvalid distance code&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            state-&gtoffset = (unsigned)here.val;\newline\newline            /* get distance extra bits, if any */\newline            state-&gtextra = (unsigned)(here.op) &amp 15;\newline            if (state-&gtextra != 0) {\newline                NEEDBITS(state-&gtextra);\newline                state-&gtoffset += BITS(state-&gtextra);\newline                DROPBITS(state-&gtextra);\newline            }\newline            if (state-&gtoffset &gt state-&gtwsize - (state-&gtwhave &lt state-&gtwsize ?\newline                                                left : 0)) {\newline                strm-&gtmsg = (char *)&quotinvalid distance too far back&quot;\newline                state-&gtmode = BAD;\newline                break;\newline            }\newline            Tracevv((stderr, &quotinflate:         distance %u\\n&quot, state-&gtoffset));\newline\newline            /* copy match from window to output */\newline            do {\newline                ROOM();\newline                copy = state-&gtwsize - state-&gtoffset;\newline                if (copy &lt left) {\newline                    from = put + copy;\newline                    copy = left - copy;\newline                }\newline                else {\newline                    from = put - state-&gtoffset;\newline                    copy = left;\newline                }\newline                if (copy &gt state-&gtlength) copy = state-&gtlength;\newline                state-&gtlength -= copy;\newline                left -= copy;\newline                do {\newline                    *put++ = *from++;\newline                } while (--copy);\newline            } while (state-&gtlength != 0);\newline            break;\newline\newline        case DONE:\newline            /* inflate stream terminated properly -- write leftover output */\newline            ret = Z_STREAM_END;\newline            if (left &lt state-&gtwsize) {\newline                if (out(out_desc, state-&gtwindow, state-&gtwsize - left))\newline                    ret = Z_BUF_ERROR;\newline            }\newline            goto inf_leave;\newline\newline        case BAD:\newline            ret = Z_DATA_ERROR;\newline            goto inf_leave;\newline\newline        default:                /* can&#039t happen, but makes compilers happy */\newline            ret = Z_STREAM_ERROR;\newline            goto inf_leave;\newline        }\newline\newline    /* Return unused input */\newline  inf_leave:\newline    strm-&gtnext_in = next;\newline    strm-&gtavail_in = have;\newline    return ret;\newline}\newline","\newlinestrm provides the memory allocation functions and window buffer on input,\newlineand provides information on the unused input on return. For Z_DATA_ERROR\newlinereturns, strm will also provide an error message.\newlinein() and out() are the call-back input and output functions. When\newlineinflateBack() needs more input, it calls in(). When inflateBack() has\newlinefilled the window with output, or when it completes with data in the\newlinewindow, it calls out() to write out the data. The application must not\newlinechange the provided input until in() is called again or inflateBack()\newlinereturns. The application must not change the window/output buffer until\newlineinflateBack() returns.\newlinein() and out() are called with a descriptor parameter provided in the\newlineinflateBack() call. This parameter can be a structure that provides the\newlineinformation required to do the read or write, as well as accumulated\newlineinformation on the input and output such as totals and check values.\newlinein() should return zero on failure. out() should return non-zero on\newlinefailure. If either in() or out() fails, than inflateBack() returns a\newlineZ_BUF_ERROR. strm-&gtnext_in can be checked for Z_NULL to see whether it\newlinewas in() or out() that caused in the error. Otherwise, inflateBack()\newlinereturns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\newlineerror, or Z_MEM_ERROR if it could not allocate memory for the state.\newlineinflateBack() can also return Z_STREAM_ERROR if the input parameters\newlineare not correct, i.e. strm is Z_NULL or the state was not initialized.\newline \newline",5935619,q_plsf.cpp,"Word16 Q_plsf_reset(Q_plsfState *state)\newline{\newline    Word16 i;\newline\newline    if (state == (Q_plsfState *) NULL)\newline    {\newline        /* fprintf(stderr, &quotQ_plsf_reset: invalid parameter\\n&quot); */\newline        return -1;\newline    }\newline\newline    for (i = 0; i &lt M; i++)\newline        state-&gtpast_rq[i] = 0;\newline\newline    return 0;\newline}\newline",\newline \newline \newline Function : Q_plsf_reset\newline Purpose : Resets state memory\newline \newline \newline \newline,2973573,dvb_ecmg.c,"static void send_channel_status(void)\newline{\newline    uint8_t p_tlv_h[MAX_TLV_SIZE];\newline    uint8_t *p_tlv = tlvh_get_tlv(p_tlv_h);\newline    uint8_t *p_tlv_n;\newline\newline    tlvh_set_version(p_tlv_h, i_version);\newline    ecmg_init(p_tlv);\newline    tlv_set_type(p_tlv, ECMG_TYPE_CHANNEL_STATUS);\newline    /* length will be written at the end */\newline    tlv_set_length(p_tlv, MAX_TLV_SIZE - TLV_HEADER_SIZE - TLVH_HEADER_SIZE);\newline\newline    ecmg_append_channelid(p_tlv, i_channelid);\newline    ecmg_append_sectiontspkt(p_tlv, 0x0); /* sections */\newline    ecmg_append_delaystart(p_tlv, DELAY_START);\newline    ecmg_append_delaystop(p_tlv, DELAY_STOP);\newline    ecmg_append_repperiod(p_tlv, REP_PERIOD);\newline    ecmg_append_maxstreams(p_tlv, MAX_STREAMS);\newline    ecmg_append_mincpdur(p_tlv, MIN_CP_DUR);\newline    ecmg_append_leadcw(p_tlv, LEAD_CW);\newline    ecmg_append_cwpermsg(p_tlv, CW_PER_MSG);\newline    ecmg_append_maxcomptime(p_tlv, MAX_COMP_TIME);\newline\newline    p_tlv_n = tlv_find_param(p_tlv, TLV_PARAM_EMPTY, 0);\newline    tlv_set_length(p_tlv, p_tlv_n - p_tlv - TLV_HEADER_SIZE);\newline    write_wrapper(p_tlv_h, p_tlv_n - p_tlv_h);\newline}\newline",\newline send_channel_status\newline \newline,2285171,rrd_thread_safe_nt.c,"struct tm *localtime_r(\newline    const time_t *timep,\newline    struct tm *result)\newline{\newline    struct tm *local;\newline\newline    context_init_context();\newline\newline    EnterCriticalSection(&ampCriticalSection);\newline    local = localtime(timep);\newline    memcpy(result, local, sizeof(struct tm));\newline    LeaveCriticalSection(&ampCriticalSection);\newline    return result;\newline}\newline",\newline there much be a re-entrant version of these somewhere in win32 land\newline \newline,4565342,starter_main.cpp,"void wait_for_debugger( int do_wait )\newline{\newline	sigset_t	sigset;\newline\newline	// This is not strictly POSIX conforming becuase it uses SIGTRAP, but\newline	// since it is only used in those environments where is is defined, it\newline	// will probably pass...\newline#if defined(SIGTRAP)\newline		/* Make sure we don&#039t block the signal used by the\newline		** debugger to control the debugged process (us).\newline		*/\newline	sigemptyset( &ampsigset );\newline	sigaddset( &ampsigset, SIGTRAP );\newline	sigprocmask( SIG_UNBLOCK, &ampsigset, 0 );\newline#endif\newline\newline	while( do_wait )\newline		;\newline}\newline","\newlineWait up for one of those nice debuggers which attaches to a running\newlineprocess. These days, most every debugger can do this with a notable\newlineexception being the ULTRIX version of &quotdbx&quot.\newline \newline",4732120,rotate.c,"int rotate_map(struct context *cnt, unsigned char *map)\newline{\newline    /*\newline     * The image format is either YUV 4:2:0 planar, in which case the pixel\newline     * data is divided in three parts:\newline     *    Y - width x height bytes\newline     *    U - width x height / 4 bytes\newline     *    V - as U\newline     * or, it is in greyscale, in which case the pixel data simply consists\newline     * of width x height bytes.\newline     */\newline    int wh, wh4 = 0, w2 = 0, h2 = 0;  /* width * height, width * height / 4 etc. */\newline    int size, deg;\newline    int width, height;\newline\newline    deg = cnt-&gtrotate_data.degrees;\newline    width = cnt-&gtrotate_data.cap_width;\newline    height = cnt-&gtrotate_data.cap_height;\newline\newline    /*\newline     * Pre-calculate some stuff:\newline     *  wh   - size of the Y plane, or the entire greyscale image\newline     *  size - size of the entire memory block\newline     *  wh4  - size of the U plane, and the V plane\newline     *  w2   - width of the U plane, and the V plane\newline     *  h2   - as w2, but height instead\newline     */\newline    wh = width * height;\newline    if (cnt-&gtimgs.type == VIDEO_PALETTE_YUV420P) {\newline        size = wh * 3 / 2;\newline        wh4 = wh / 4;\newline        w2 = width / 2;\newline        h2 = height / 2;\newline    } else { /* VIDEO_PALETTE_GREY */\newline        size = wh;\newline    }\newline\newline    switch (deg) {\newline    case 90:\newline        /* First do the Y part */\newline        rot90cw(map, cnt-&gtrotate_data.temp_buf, wh, width, height);\newline        if (cnt-&gtimgs.type == VIDEO_PALETTE_YUV420P) {\newline            /* Then do U and V */\newline            rot90cw(map + wh, cnt-&gtrotate_data.temp_buf + wh, wh4, w2, h2);\newline            rot90cw(map + wh + wh4, cnt-&gtrotate_data.temp_buf + wh + wh4,\newline                    wh4, w2, h2);\newline        }\newline\newline        /* Then copy back from the temp buffer to map. */\newline        memcpy(map, cnt-&gtrotate_data.temp_buf, size);\newline        break;\newline\newline    case 180:\newline        /*\newline         * 180 degrees is easy - just reverse the data within\newline         * Y, U and V.\newline         */\newline        reverse_inplace_quad(map, wh);\newline        if (cnt-&gtimgs.type == VIDEO_PALETTE_YUV420P) {\newline            reverse_inplace_quad(map + wh, wh4);\newline            reverse_inplace_quad(map + wh + wh4, wh4);\newline        }\newline        break;\newline\newline    case 270:\newline\newline        /* First do the Y part */\newline        rot90ccw(map, cnt-&gtrotate_data.temp_buf, wh, width, height);\newline        if (cnt-&gtimgs.type == VIDEO_PALETTE_YUV420P) {\newline            /* Then do U and V */\newline            rot90ccw(map + wh, cnt-&gtrotate_data.temp_buf + wh, wh4, w2, h2);\newline            rot90ccw(map + wh + wh4, cnt-&gtrotate_data.temp_buf + wh + wh4,\newline                     wh4, w2, h2);\newline        }\newline\newline        /* Then copy back from the temp buffer to map. */\newline        memcpy(map, cnt-&gtrotate_data.temp_buf, size);\newline        break;\newline\newline    default:\newline        /* Invalid */\newline        return -1;\newline    }\newline\newline    return 0;\newline}\newline",\newline rotate_map\newline \newline Main entry point for rotation. This is the function that is called from\newline video.c/video_freebsd.c to perform the rotation.\newline \newline Parameters:\newline \newline map - pointer to the image/data to rotate\newline cnt - the current thread&#039s context structure\newline \newline Returns:\newline \newline 0 - success\newline -1 - failure (shouldn&#039t happen)\newline \newline,6567783,sp.c,"void sp_det(char *p, int ptype)\newline{\newline    fprintf(outf,&quot%stmp=!translate $	$ to ; in %s\\n\\n\\\newline%stmp%d=!exec pari matdet([$tmp])\\n&quot,\newline          setpre,p,setpre,prepcnt);\newline}\newline",user pari to compute matrix determinant. \newline,4319077,disk_ops.c,"int Xorriso_restore_sorted(struct XorrisO *xorriso, int count,\newline                           char **src_array, char **tgt_array,\newline                           int *problem_count, int flag)\newline{\newline int i, ret, with_node_array= 0, hflag= 0, hret;\newline\newline *problem_count= 0;\newline if(!(((xorriso-&gtino_behavior &amp 16) &amp&amp xorriso-&gtdo_restore_sort_lba) ||\newline      (xorriso-&gtino_behavior &amp 4) || (flag &amp 1))) {\newline   ret= Xorriso_make_hln_array(xorriso, 0);\newline   if(ret&lt=0)\newline     goto ex;\newline }\newline if(xorriso-&gtdo_restore_sort_lba) {\newline   /* Count affected nodes */\newline   Xorriso_destroy_node_array(xorriso, 0);\newline   for(i= 0; i &lt count; i++) {\newline     if(src_array[i] == NULL || tgt_array[i] == NULL)\newline   continue;\newline     /* sort_lba : Make directories plus node_array and then\newline                   run array extractor (with eventual hardlink detection)\newline     */\newline     hflag= (1 &lt&lt 7) | ((!!(flag &amp 2)) &lt&lt 9) | (flag &amp 32);\newline     ret= Xorriso_restore(xorriso, src_array[i], tgt_array[i],\newline                          (off_t) 0, (off_t) 0, hflag);\newline     if(ret &lt= 0) {\newline       (*problem_count)++;\newline       hret= Xorriso_eval_problem_status(xorriso, ret, 1 | 2);\newline       if(hret &lt 0)\newline         goto ex;\newline     }\newline     with_node_array= 1;\newline   }\newline }\newline\newline if(with_node_array) {\newline   /* Allocate and fill node array */\newline   if(xorriso-&gtnode_counter &lt= 0)\newline     {ret= 2; goto ex;}\newline   ret= Xorriso_new_node_array(xorriso, xorriso-&gttemp_mem_limit, 0,\newline                               !xorriso-&gtdo_restore_sort_lba);\newline   if(ret&lt=0)\newline     goto ex;\newline   for(i= 0; i &lt count; i++) {\newline     if(src_array[i] == NULL || tgt_array[i] == NULL)\newline   continue;\newline     ret= Xorriso_restore(xorriso, src_array[i], tgt_array[i],\newline                          (off_t) 0, (off_t) 0, (2 &lt&lt 7) | (flag &amp 32));\newline     if(ret &lt= 0) {\newline       (*problem_count)++;\newline       hret= Xorriso_eval_problem_status(xorriso, ret, 1 | 2);\newline       if(hret &lt 0)\newline         goto ex;\newline     }\newline   }\newline }\newline\newline /* Perform restore operations */\newline if(xorriso-&gtdo_restore_sort_lba) {\newline   ret= Xorriso_restore_node_array(xorriso, 0);\newline   if(ret &lt= 0)\newline     goto ex;\newline } else {\newline   for(i= 0; i &lt count; i++) {\newline     if(src_array[i] == NULL || tgt_array[i] == NULL)\newline   continue;\newline     ret= Xorriso_restore(xorriso, src_array[i], tgt_array[i],\newline                          (off_t) 0, (off_t) 0, flag &amp 32);\newline     if(ret &lt= 0) {\newline       (*problem_count)++;\newline       hret= Xorriso_eval_problem_status(xorriso, ret, 1 | 2);\newline       if(hret &lt 0)\newline         goto ex;\newline     }\newline   }\newline }\newline\newline ret= 1;\newlineex:;\newline return(ret);\newline}\newline",@param flag bit0= no hardlink reconstruction\newlinebit1= do not set xorriso-&gtnode_ _prefixes\newlinebit5= -extract_single: eventually do not insert directory tree\newline \newline,2691549,time.c,"static inline u32 mul_frac(u32 multiplicand, u32 multiplier)\newline{\newline    u32 product_int, product_frac;\newline    asm (\newline        &quotmul %3&quot\newline        : &quot=a&quot (product_frac), &quot=d&quot (product_int)\newline        : &quot0&quot (multiplicand), &quotr&quot (multiplier) );\newline    return product_int;\newline}\newline",\newline 32-bit multiplication of multiplicand and fractional multiplier\newline yielding 32-bit product (radix point at same position as in multiplicand).\newline \newline,1193444,layoutreader.c,"void *layoutreader_element_init(struct layout *layout, char *element, size_t size)\newline{\newline	START_FUNC\newline	void *ret=NULL;\newline	while (layout-&gtcur &amp&amp xmlStrcmp(layout-&gtcur-&gtname, (xmlChar *)element))\newline		layout-&gtcur=layout-&gtcur-&gtnext;\newline	if (layout-&gtcur) {\newline		ret=g_malloc(size);\newline		memset(ret, 0, size);\newline		layout-&gtcur=layout-&gtcur-&gtchildren;\newline	}\newline	END_FUNC\newline	return ret;\newline}\newline",Initialize an element structure and look for it in the layout document \newline,1086566,nes_apu.c,int32 apu_getcyclerate(void)\newline{\newline   ASSERT(apu);\newline   return apu-&gtcycle_rate;\newline}\newline,this exists for external mixing routines \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1682706,bind.c,"RETCODE SQL_API PG_SQLBindCol(\newline        HSTMT      hstmt,\newline        UWORD      icol,\newline        SWORD      fCType,\newline        PTR        rgbValue,\newline        SQLLEN     cbValueMax,\newline        SQLLEN    *pcbValue)\newline{\newlineStatementClass *stmt = (StatementClass *) hstmt;\newlinestatic char* const func=&quotSQLBindCol&quot;\newline\newline	mylog( &quot%s: entering...\\n&quot, func);\newline    \newlinemylog(&quot**** SQLBindCol: stmt = %u, icol = %d\\n&quot, stmt, icol);\newline\newline	if ( ! stmt) {\newline		SC_log_error(func, &quot&quot, NULL);\newline		return SQL_INVALID_HANDLE;\newline	}\newline\newline\newline	SC_clear_error(stmt);\newline    \newline	if( stmt-&gtstatus == STMT_EXECUTING) {\newline		SC_set_error(stmt, STMT_SEQUENCE_ERROR, &quotCan&#039t bind columns while statement is still executing.&quot);\newline		SC_log_error(func, &quot&quot, stmt);\newline		return SQL_ERROR;\newline	}\newline\newline	/*	If the bookmark column is being bound, then just save it */\newline	if (icol == 0) {\newline\newline		if (rgbValue == NULL) {\newline			stmt-&gtbookmark.buffer = NULL;\newline			stmt-&gtbookmark.used = NULL;\newline		}\newline		else {\newline			/*	Make sure it is the bookmark data type */\newline			if ( fCType != SQL_C_BOOKMARK &amp&amp fCType != SQL_C_BINARY ) {\newline				SC_set_error(stmt, STMT_PROGRAM_TYPE_OUT_OF_RANGE, &quotColumn 0 is not of type SQL_C_BOOKMARK&quot);\newline				SC_log_error(func, &quot&quot, stmt);\newline				return SQL_ERROR;\newline			}\newline\newline			stmt-&gtbookmark.buffer = rgbValue;\newline			stmt-&gtbookmark.used = pcbValue;\newline		}\newline		return SQL_SUCCESS;\newline	}\newline\newline	/*	allocate enough bindings if not already done */\newline	/*	Most likely, execution of a statement would have setup the  */\newline	/*	necessary bindings. But some apps call BindCol before any */\newline	/*	statement is executed. */\newline	if ( icol &gt stmt-&gtbindings_allocated)\newline		extend_bindings(stmt, icol);\newline\newline	/*	check to see if the bindings were allocated */\newline	if ( ! stmt-&gtbindings) {\newline		SC_set_error(stmt, STMT_NO_MEMORY_ERROR, &quotCould not allocate memory for bindings.&quot);\newline		SC_log_error(func, &quot&quot, stmt);\newline		return SQL_ERROR;\newline	}\newline\newline	icol--;		/* use zero based col numbers from here out */\newline\newline	/*	Reset for SQLGetData */\newline	stmt-&gtbindings[icol].data_left = -1;\newline\newline	if (rgbValue == NULL) {\newline		/* we have to unbind the column */\newline		stmt-&gtbindings[icol].buflen = 0;\newline		stmt-&gtbindings[icol].buffer = NULL;\newline		stmt-&gtbindings[icol].used =   NULL;\newline		stmt-&gtbindings[icol].returntype = SQL_C_CHAR;\newline	} else {\newline		/* ok, bind that column */\newline		stmt-&gtbindings[icol].buflen     = cbValueMax;\newline		stmt-&gtbindings[icol].buffer     = rgbValue;\newline		stmt-&gtbindings[icol].used       = pcbValue;\newline		stmt-&gtbindings[icol].returntype = fCType;\newline\newline		mylog(&quot       bound buffer[%d] = %u\\n&quot, icol, stmt-&gtbindings[icol].buffer);\newline	}\newline\newline	return SQL_SUCCESS;\newline}\newline",Associate a user-supplied buffer with a database column. \newline,6642318,util.c,"double wtaverage(double *LOD, int n_draws)\newline{\newline    int k, idx, nnewLOD;\newline    double sum, sums, meanLOD, varLOD, *newLOD;\newline\newline    /* calculate the number of LOD needs to be thrown */\newline    idx = (int) floor( 0.5*log(n_draws)/log(2) );\newline    nnewLOD = n_draws-2*idx; /* number of items in newLOD vector */\newline    /* allocate memory for newLOD */\newline    newLOD = (double *)R_alloc( nnewLOD, sizeof(double) );\newline\newline    /* sort the LOD scores in ascending order */\newline    R_rsort(LOD, n_draws);\newline\newline    /* get a new list of LOD scores, throwing the biggest\newline       and smallest idx LOD scores. */\newline    for(k=idx, sum=0.0; k&ltn_draws-idx; k++) {\newline        newLOD[k-idx] = LOD[k];\newline        sum += LOD[k]; /* calculate the sum of newLOD in the same loop */\newline    }\newline\newline    /* calculate the mean of newLOD */\newline    meanLOD = sum / nnewLOD;\newline    /* calculate the variance of newLOD */\newline    if(nnewLOD &gt 1) {\newline        for(k=0,sums=0.0; k&ltnnewLOD; k++)\newline            sums += (newLOD[k]-meanLOD) * (newLOD[k]-meanLOD);\newline        varLOD = sums/(nnewLOD-1);\newline    }\newline    else varLOD = 0.0;\newline\newline    /* return the weight average */\newline    return( meanLOD+0.5*log(10.0)*varLOD );\newline\newline}\newline",\newline wtaverage\newline calculate the weight average of the LOD scores\newline \newline,5923483,heap.c,"void heap_insert(heap_t *heap, void *value) {\newline    long idx, parent_idx;\newline\newline    // If at capacity, ignore.\newline    if (heap-&gtcount == heap-&gtcapacity) {\newline        return;\newline    }\newline\newline    // Insert into first empty slot.\newline    idx = heap-&gtcount;\newline    heap-&gtentries[idx] = value;\newline    heap-&gtcount++;\newline\newline    // Bubble upwards until heap property is restored.\newline    parent_idx = HEAP_PARENT(idx);\newline    while (idx &amp&amp !heap_property(heap, parent_idx, idx)) {\newline        heap_swap(heap, idx, parent_idx);\newline        idx = parent_idx;\newline        parent_idx = HEAP_PARENT(idx);\newline    }\newline}\newline",\newline Inserts `value` into `heap`.\newline \newline,2144381,file.c,"static apr_status_t oidc_cache_file_clean(request_rec *r) {\newline	apr_status_t rc = APR_SUCCESS;\newline	apr_dir_t *dir = NULL;\newline	apr_file_t *fd = NULL;\newline	apr_status_t i;\newline	apr_finfo_t fi;\newline	oidc_cache_file_info_t info;\newline	char s_err[128];\newline\newline	oidc_cfg *cfg = ap_get_module_config(r-&gtserver-&gtmodule_config,\newline			&ampauth_openidc_module);\newline\newline	/* get the path to the metadata file that holds &quotlast cleaned&quot metadata info */\newline	const char *metadata_path = oidc_cache_file_path(r, &quotcache-file&quot,\newline			OIDC_CACHE_FILE_LAST_CLEANED);\newline\newline	/* open the metadata file if it exists */\newline	if ((rc = apr_stat(&ampfi, metadata_path, APR_FINFO_MTIME, r-&gtpool))\newline			== APR_SUCCESS) {\newline\newline		/* really only clean once per so much time, check that we haven not recently run */\newline		if (apr_time_now() &lt fi.mtime + apr_time_from_sec(cfg-&gtcache_file_clean_interval)) {\newline			oidc_debug(r,\newline					&quotlast cleanup call was less than %d seconds ago (next one as early as in %&quot APR_TIME_T_FMT &quot secs)&quot,\newline					cfg-&gtcache_file_clean_interval,\newline					apr_time_sec( fi.mtime + apr_time_from_sec(cfg-&gtcache_file_clean_interval) - apr_time_now()));\newline			return APR_SUCCESS;\newline		}\newline\newline		/* time to clean, reset the modification time of the metadata file to reflect the timestamp of this cleaning cycle */\newline		apr_file_mtime_set(metadata_path, apr_time_now(), r-&gtpool);\newline\newline	} else {\newline\newline		/* no metadata file exists yet, create one (and open it) */\newline		if ((rc = apr_file_open(&ampfd, metadata_path,\newline				(APR_FOPEN_WRITE | APR_FOPEN_CREATE), APR_OS_DEFAULT, r-&gtpool))\newline				!= APR_SUCCESS) {\newline			oidc_error(r, &quoterror creating cache timestamp file &#039%s&#039 (%s)&quot,\newline					metadata_path, apr_strerror(rc, s_err, sizeof(s_err)));\newline			return rc;\newline		}\newline\newline		/* and cleanup... */\newline		if ((rc = apr_file_close(fd)) != APR_SUCCESS) {\newline			oidc_error(r, &quoterror closing cache timestamp file &#039%s&#039 (%s)&quot,\newline					metadata_path, apr_strerror(rc, s_err, sizeof(s_err)));\newline		}\newline	}\newline\newline	/* time to clean, open the cache directory */\newline	if ((rc = apr_dir_open(&ampdir, cfg-&gtcache_file_dir, r-&gtpool)) != APR_SUCCESS) {\newline		oidc_error(r, &quoterror opening cache directory &#039%s&#039 for cleaning (%s)&quot,\newline				cfg-&gtcache_file_dir, apr_strerror(rc, s_err, sizeof(s_err)));\newline		return rc;\newline	}\newline\newline	/* loop trough the cache file entries */\newline	do {\newline\newline		/* read the next entry from the directory */\newline		i = apr_dir_read(&ampfi, APR_FINFO_NAME, dir);\newline\newline		if (i == APR_SUCCESS) {\newline\newline			/* skip non-cache entries, cq. the &quot.&quot, &quot..&quot and the metadata file */\newline			if ((fi.name[0] == &#039.&#039)\newline					|| (strstr(fi.name, OIDC_CACHE_FILE_PREFIX) != fi.name)\newline					|| ((apr_strnatcmp(fi.name,\newline							oidc_cache_file_name(r, &quotcache-file&quot,\newline									OIDC_CACHE_FILE_LAST_CLEANED)) == 0)))\newline				continue;\newline\newline			/* get the fully qualified path to the cache file and open it */\newline			const char *path = apr_psprintf(r-&gtpool, &quot%s/%s&quot,\newline					cfg-&gtcache_file_dir, fi.name);\newline			if ((rc = apr_file_open(&ampfd, path, APR_FOPEN_READ, APR_OS_DEFAULT,\newline					r-&gtpool)) != APR_SUCCESS) {\newline				oidc_error(r, &quotunable to open cache entry \\&quot%s\\&quot (%s)&quot, path,\newline						apr_strerror(rc, s_err, sizeof(s_err)));\newline				continue;\newline			}\newline\newline			/* read the header with cache metadata info */\newline			rc = oidc_cache_file_read(r, path, fd, &ampinfo,\newline					sizeof(oidc_cache_file_info_t));\newline			apr_file_close(fd);\newline\newline			if (rc == APR_SUCCESS) {\newline\newline				/* check if this entry expired, if not just continue to the next entry */\newline				if (apr_time_now() &lt info.expire)\newline					continue;\newline\newline				/* the cache entry expired, we&#039re going to remove it so log that event */\newline				oidc_debug(r, &quotcache entry (%s) expired, removing file \\&quot%s\\&quot)&quot,\newline						fi.name, path);\newline\newline			} else {\newline\newline				/* file open returned an error, log that */\newline				oidc_error(r,\newline						&quotcache entry (%s) corrupted (%s), removing file \\&quot%s\\&quot&quot,\newline						fi.name, apr_strerror(rc, s_err, sizeof(s_err)), path);\newline\newline			}\newline\newline			/* delete the cache file */\newline			if ((rc = apr_file_remove(path, r-&gtpool)) != APR_SUCCESS) {\newline\newline				/* hrm, this will most probably happen again on the next run... */\newline				oidc_error(r, &quotcould not delete cache file \\&quot%s\\&quot (%s)&quot, path,\newline						apr_strerror(rc, s_err, sizeof(s_err)));\newline			}\newline\newline		}\newline\newline	} while (i == APR_SUCCESS);\newline\newline	apr_dir_close(dir);\newline\newline	return APR_SUCCESS;\newline}\newline",\newline delete all expired entries from the cache directory\newline \newline,,on,,,,,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,Expand a path-name,{},pointer to the image/data to rotate,user pari to compute matrix determinant.,do not set xorriso->node_ _prefixes,32-bit multiplication of multiplicand and fractional multiplier,Initialize an element structure and look for it in the layout document,this exists for external mixing routines,Load an image from the named file.,Associate a user-supplied buffer with a database column.,calculate the weight average of the LOD scores,set operation timeout,Inserts `value` into `heap`.,delete all expired entries from the cache directory,Deallocates all allocated memory for profiler.,Test whether we can send to a client.,Builds up the java classpath section of the Java command line.,{},Q_plsf_reset,send_channel_status,there much be a re-entrant version of these somewhere in win32 land,x,
3THR0FZ95PT5P3LRFCELEKFRAZALOU,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:29 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:29 PDT 2019,,,382M9COHEHFOJMSPKE8RPEDL1JFUEV,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:01 PDT 2019,Fri Apr 26 13:16:11 PDT 2019,Sun Apr 28 13:16:11 PDT 2019,,,,1690,100% (62/62),100% (62/62),0% (0/0),5108142,mainstate.c,void exec_repeat(void) {\newline  basicvars.current++;		/* Skip REPEAT token */\newline  if (*basicvars.current == &#039:&#039) basicvars.current++;	/* Found a &#039:&#039 - Move past it */\newline  if (*basicvars.current == NUL) {	/* Nothing on line after REPEAT - Try next line */\newline    basicvars.current++;	/* Move to start of next line */\newline    if (basicvars.traces.lines) trace_line(get_lineno(basicvars.current));\newline    basicvars.current = FIND_EXEC(basicvars.current);\newline  }\newline  push_repeat();\newline}\newline,\newline &#039exec_repeat&#039 handles the start of a &#039REPEAT&#039 loop\newline \newline,2808391,icaltime.c,"time_t icaltime_as_timet_with_zone(const struct icaltimetype _tt,\newline	const icaltimezone *zone)\newline{\newline    struct icaltimetype tt = _tt;\newline    struct tm stm;\newline    time_t t;\newline\newline    /* If the time is the special null time, return 0. */\newline    if (icaltime_is_null_time(tt)) {\newline	return 0;\newline    }\newline\newline    if (zone != NULL) {\newline	tt = icaltime_convert_to_zone(_tt, (icaltimezone *)zone);\newline    }\newline\newline    /* Copy the icaltimetype to a struct tm. */\newline    memset (&ampstm, 0, sizeof (struct tm));\newline\newline    if (icaltime_is_date(tt)) {\newline	stm.tm_sec = stm.tm_min = stm.tm_hour = 0;\newline    } else {\newline	stm.tm_sec = tt.second;\newline	stm.tm_min = tt.minute;\newline	stm.tm_hour = tt.hour;\newline    }\newline\newline    stm.tm_mday = tt.day;\newline    stm.tm_mon = tt.month-1;\newline    stm.tm_year = tt.year-1900;\newline    stm.tm_isdst = -1;\newline\newline    t = make_time(&ampstm, 0);\newline\newline    return t;\newline}\newline","@brief Return the time as seconds past the UNIX epoch, using the\newline given timezone.\newline \newline This convenience method combines a call to icaltime_convert() with\newline a call to icaltime_as_timet().\newline If the input timezone is null, no conversion is done; that is, the\newline time is simply returned as time_t in its native timezone.\newline \newline",2729812,epr_dump.c,"void epr_dump_record(const EPR_SRecord* record)\newline{\newline    epr_print_record(record, stdout);\newline}\newline",\newline Dumps the record content to stdout.\newline \newline @param record the pointer to the record to be printed out.\newline \newline,5723395,ignore.c,"int ign___translate_bracketed_expr(char *end_of_buffer,\newline		char **src, char **dest)\newline{\newline	int status = 0;\newline	int pos_in_bracket_expr = -1; // zero-based, -1 == outside\newline	int backslashed = 0;\newline\newline\newline	STOPIF(**src != &#039[&#039,\newline			&quotinvalid argument, **src does not point to &quot\newline			&quotstart of bracket expression&quot);\newline\newline	do\newline	{\newline		if (backslashed)\newline		{\newline			/* Escaped mode; blindly copy the next character. */\newline			*((*dest)++) = *((*src)++);\newline			backslashed = 0;\newline			/* pos_in_bracket_expr has already been increased. */\newline		}\newline		else if ( pos_in_bracket_expr == 0 &amp&amp\newline				(**src == &#039!&#039 || **src == &#039^&#039) )\newline		{\newline			*((*dest)++) = &#039^&#039;\newline			++(*src);\newline			/* &quot!&quot or &quot^&quot at the start of a bracket expression (negation of the \newline			 * bracket expression/character class) do not count as a regular \newline			 * content element, so pos_in_bracket_expr is left alone. */\newline		}\newline		else\newline		{\newline			if (**src == &#039]&#039 &amp&amp pos_in_bracket_expr &gt 0)\newline			{\newline				/* Bracket expression ends. Set &quotend of expression&quot\newline					 marker and fall through to copy the closing bracket. */\newline				pos_in_bracket_expr = -1;\newline			}\newline			else\newline			{\newline				/* Now we&#039re at the next character position. */\newline				++pos_in_bracket_expr; \newline			}\newline\newline			/* Enter escaped mode? */\newline			backslashed = (**src == &#039\\\\&#039); \newline\newline			*((*dest)++) = *((*src)++);\newline		}\newline\newline		/* end_of_buffer points at character after the allocated destination \newline		 * buffer space -- *end_of_buffer is invalid/undefined.\newline		 * Here we just have to be careful to not overwrite the stack - the \newline		 * real length check is in ign__compile_pattern(). */\newline		STOPIF_CODE_ERR( end_of_buffer - *dest &lt 5, ENOSPC,\newline				&quotnot enough space in buffer&quot);\newline	}\newline	while(**src &amp&amp pos_in_bracket_expr &gt= 0);\newline\newline\newlineex:\newline	return status;\newline}\newline",Processes a character class in shell ignore patterns.\newline \newline,1429301,mpi.cpp,"int mp_lcm (mp_int * a, mp_int * b, mp_int * c)\newline{\newline  int     res;\newline  mp_int  t1, t2;\newline\newline\newline  if ((res = mp_init_multi (&ampt1, &ampt2, NULL)) != MP_OKAY) {\newline    return res;\newline  }\newline\newline  /* t1 = get the GCD of the two inputs */\newline  if ((res = mp_gcd (a, b, &ampt1)) != MP_OKAY) {\newline    goto LBL_T;\newline  }\newline\newline  /* divide the smallest by the GCD */\newline  if (mp_cmp_mag(a, b) == MP_LT) {\newline     /* store quotient in t2 such that t2 * b is the LCM */\newline     if ((res = mp_div(a, &ampt1, &ampt2, NULL)) != MP_OKAY) {\newline        goto LBL_T;\newline     }\newline     res = mp_mul(b, &ampt2, c);\newline  } else {\newline     /* store quotient in t2 such that t2 * a is the LCM */\newline     if ((res = mp_div(b, &ampt1, &ampt2, NULL)) != MP_OKAY) {\newline        goto LBL_T;\newline     }\newline     res = mp_mul(a, &ampt2, c);\newline  }\newline\newline  /* fix the sign to positive */\newline  c-&gtsign = MP_ZPOS;\newline\newlineLBL_T:\newline  mp_clear_multi (&ampt1, &ampt2, NULL);\newline  return res;\newline}\newline","computes least common multiple as |a b|/(a, b) \newline",3835547,s404_dec.c,"static int checkS404File(uint32 *buf, /*size_t len,*/\newline			 int32 *oLen, int32 *pLen, int32 *sLen )\newline{\newline  /*if (len &lt 16)\newline    return -1;*/\newline\newline  if (memcmp(buf, &quotS404&quot, 4) != 0)\newline    return -1;\newline\newline  *sLen = readmem32b((uint8 *)&ampbuf[1]); /* Security length */\newline  if (*sLen &lt 0)\newline    return -1;\newline  *oLen = readmem32b((uint8 *)&ampbuf[2]); /* Depacked length */\newline  if (*oLen &lt 0)\newline    return -1;\newline  *pLen = readmem32b((uint8 *)&ampbuf[3]); /* Packed length */\newline  if (*pLen &lt 0)\newline    return -1;\newline\newline  return 0;\newline}\newline",Returns bytes still to read.. or &lt 0 if error. \newline,174791,msequenceserver.cpp,double msequenceServer::get_time(void)\newline{\newline	return m_dTime/(double)CLOCKS_PER_SEC;\newline}\newline,\newline returns the time elapsed retrieving sequences in seconds \newline \newline,2671622,gmpc-metadata-browser2.c,"static void gmpc_browsers_metadata_album_add_clicked (GmpcBrowsersMetadata* self, GtkWidget* item) {\newline	gchar* _tmp0_ = NULL;\newline	gchar* artist;\newline	g_return_if_fail (self != NULL);\newline	g_return_if_fail (item != NULL);\newline	_tmp0_ = gmpc_browsers_metadata_browser_get_selected_artist (self);\newline	artist = _tmp0_;\newline	if (artist != NULL) {\newline		gchar* albumartist;\newline		gchar* _tmp1_ = NULL;\newline		gchar* album;\newline		gboolean _tmp2_ = FALSE;\newline		gboolean _tmp7_ = FALSE;\newline		MpdData* _tmp9_ = NULL;\newline		MpdData* data;\newline		albumartist = NULL;\newline		_tmp1_ = gmpc_browsers_metadata_browser_get_selected_album (self);\newline		album = _tmp1_;\newline		if (album != NULL) {\newline			gboolean _tmp3_;\newline			_tmp3_ = mpd_server_tag_supported (connection, MPD_TAG_ITEM_ALBUM_ARTIST);\newline			_tmp2_ = _tmp3_;\newline		} else {\newline			_tmp2_ = FALSE;\newline		}\newline		if (_tmp2_) {\newline			MpdData* _tmp4_ = NULL;\newline			MpdData* ydata;\newline			mpd_database_search_field_start (connection, MPD_TAG_ITEM_ALBUM_ARTIST);\newline			mpd_database_search_add_constraint (connection, MPD_TAG_ITEM_ALBUM, album);\newline			mpd_database_search_add_constraint (connection, MPD_TAG_ITEM_ARTIST, artist);\newline			_tmp4_ = mpd_database_search_commit (connection);\newline			ydata = _tmp4_;\newline			if (ydata != NULL) {\newline				gint _tmp5_;\newline				_tmp5_ = strlen (ydata-&gttag);\newline				if (_tmp5_ &gt 0) {\newline					gchar* _tmp6_;\newline					_tmp6_ = g_strdup (ydata-&gttag);\newline					_g_free0 (albumartist);\newline					albumartist = _tmp6_;\newline				}\newline			}\newline			_mpd_data_free0 (ydata);\newline		}\newline		mpd_database_search_start (connection, TRUE);\newline		if (albumartist != NULL) {\newline			gint _tmp8_;\newline			_tmp8_ = strlen (albumartist);\newline			_tmp7_ = _tmp8_ &gt 0;\newline		} else {\newline			_tmp7_ = FALSE;\newline		}\newline		if (_tmp7_) {\newline			mpd_database_search_add_constraint (connection, MPD_TAG_ITEM_ALBUM_ARTIST, albumartist);\newline		} else {\newline			mpd_database_search_add_constraint (connection, MPD_TAG_ITEM_ARTIST, artist);\newline		}\newline		if (album != NULL) {\newline			mpd_database_search_add_constraint (connection, MPD_TAG_ITEM_ALBUM, album);\newline		}\newline		_tmp9_ = mpd_database_search_commit (connection);\newline		data = _tmp9_;\newline		data = misc_sort_mpddata_by_album_disc_track (data);\newline		if (data != NULL) {\newline			{\newline				gboolean _tmp10_;\newline				_tmp10_ = TRUE;\newline				while (TRUE) {\newline					if (!_tmp10_) {\newline						if (!(data != NULL)) {\newline							break;\newline						}\newline					}\newline					_tmp10_ = FALSE;\newline					mpd_playlist_queue_add (connection, data-&gtsong-&gtfile);\newline					data = mpd_data_get_next (data);\newline				}\newline			}\newline			mpd_playlist_queue_commit (connection);\newline		}\newline		_mpd_data_free0 (data);\newline		_g_free0 (album);\newline		_g_free0 (albumartist);\newline	}\newline	_g_free0 (artist);\newline}\newline",\newline Album tree view\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4217113,gl_md3.c,"void R_DrawAlias3Model (entity_t *ent)\newline{\newline	float		l, lerpfrac, scale;\newline	int distance = INTERP_MAXDIST / MD3_XYZ_SCALE;\newline	vec3_t		interpolated_verts;\newline\newline	md3model_t *mhead;\newline	md3Header_t *pheader;\newline	model_t *mod;\newline	int surfnum, numtris, i;\newline	md3Surface_t *surf;\newline\newline	int frame1 = ent-&gtoldframe, frame2 = ent-&gtframe;\newline	md3XyzNormal_t *verts, *v1, *v2;\newline\newline	surfinf_t *sinf;\newline\newline	unsigned int	*tris;\newline	md3St_t *tc;\newline\newline//	float ang;\newline\newline	float r_modelalpha;\newline\newline	mod = ent-&gtmodel;\newline\newline	GL_DisableMultitexture();\newline\newline	glPushMatrix ();\newline\newline	R_RotateForEntity (ent);\newline\newline	r_modelalpha = ((ent-&gtrenderfx &amp RF_WEAPONMODEL) &amp&amp gl_mtexable) ? bound(0, cl_drawgun.value, 1) : 1;\newline	if (ent-&gtalpha)\newline		r_modelalpha = ent-&gtalpha;\newline\newline	if (r_modelalpha &lt 1)\newline		glEnable(GL_BLEND);\newline//	glDisable(GL_ALPHA_TEST);\newline\newline	scale = (ent-&gtrenderfx &amp RF_WEAPONMODEL) ? bound(0.5, r_viewmodelsize.value, 1) : 1;\newline	// perform two scalling at once, one scalling for MD3_XYZ_SCALE, other for r_viewmodelsize\newline	glScalef(scale * MD3_XYZ_SCALE, MD3_XYZ_SCALE, MD3_XYZ_SCALE);\newline	glColor4f(1, 1, 1, r_modelalpha);\newline\newline	if (gl_fogenable.value)\newline		glEnable(GL_FOG);\newline\newline	R_AliasSetupLighting(ent);\newline	shadedots = r_avertexnormal_dots[((int) (ent-&gtangles[1] * (SHADEDOT_QUANT / 360.0))) &amp (SHADEDOT_QUANT - 1)];\newline\newline	if (gl_fb_models.value == 1) {\newline		ambientlight = 999999;\newline	}\newline\newline	if (gl_smoothmodels.value)\newline		glShadeModel(GL_SMOOTH);\newline\newline	if (gl_affinemodels.value)\newline		glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);\newline\newline	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\newline\newline/*\newline	ang = ent-&gtangles[1]/180*M_PI;\newline	shadevector[0] = cos(-ang);\newline	shadevector[1] = sin(-ang);\newline	shadevector[2] = 1;\newline	VectorNormalize (shadevector);\newline*/\newline\newline	mhead = (md3model_t *)Mod_Extradata (mod);\newline	sinf = (surfinf_t *)((char *)mhead + mhead-&gtsurfinf);\newline	pheader = (md3Header_t *)((char *)mhead + mhead-&gtmd3model);\newline\newline	if (frame1 &gt= pheader-&gtnumFrames)\newline		frame1 = pheader-&gtnumFrames-1;\newline	if (frame2 &gt= pheader-&gtnumFrames)\newline		frame2 = pheader-&gtnumFrames-1;\newline\newline	if (!r_lerpframes.value || ent-&gtframelerp &lt 0 || ent-&gtoldframe == ent-&gtframe)\newline		lerpfrac = 1.0;\newline	else\newline		lerpfrac = min (ent-&gtframelerp, 1);\newline\newline	surf = (md3Surface_t *)((char *)pheader + pheader-&gtofsSurfaces);\newline\newline	for (surfnum = 0; surfnum &lt pheader-&gtnumSurfaces; surfnum++) //loop through the surfaces.\newline	{\newline		int pose1, pose2;\newline\newline		pose1 = frame1*surf-&gtnumVerts;\newline		pose2 = frame2*surf-&gtnumVerts;\newline\newline		tc = (md3St_t *)((char *)surf + surf-&gtofsSt);	//skin texture coords.\newline		verts = (md3XyzNormal_t *)((char *)surf + surf-&gtofsXyzNormals);\newline\newline		tris = (unsigned int *)((char *)surf + surf-&gtofsTriangles);\newline		numtris = surf-&gtnumTriangles * 3;		\newline\newline		GL_Bind((sinf+pheader-&gtnumSurfaces*pheader-&gtnumSkins + surfnum)-&gttexnum);\newline\newline		glBegin (GL_TRIANGLES);\newline\newline		for (i = 0 ; i &lt numtris ; i++)\newline		{\newline			float	s, t;\newline    \newline			v1 = verts + *tris + pose1;\newline			v2 = verts + *tris + pose2;\newline\newline/*    \newline			if (poweruptexture &amp&amp !surface_transparent)\newline			{\newline				float	adjustedScrollS, adjustedScrollT, timeScale = cl.time; // some refdef time here\newline				float	degs, sinValue, cosValue;\newline    \newline				degs = -30 * timeScale;\newline				sinValue = sin(DEG2RAD(degs));\newline				cosValue = cos(DEG2RAD(degs));\newline    \newline				s = tc[*tris].s * cosValue + tc[*tris].t * -sinValue + (0.5 - 0.5 * cosValue + 0.5 * sinValue);\newline				t = tc[*tris].s * sinValue + tc[*tris].t *  cosValue + (0.5 - 0.5 * sinValue - 0.5 * cosValue);\newline    \newline				s *= 2;\newline				t *= 2;\newline    \newline				adjustedScrollS = 0.1 * timeScale;\newline				adjustedScrollT = 0.01 * timeScale;\newline    \newline				// clamp so coordinates don&#039t continuously get larger, causing problems\newline				// with hardware limits\newline				adjustedScrollS = adjustedScrollS - floor(adjustedScrollS);\newline				adjustedScrollT = adjustedScrollT - floor(adjustedScrollT);\newline    \newline				s += adjustedScrollS;\newline				t += adjustedScrollT;\newline			}\newline\newlinewtf: where else{ }\newline\newline*/\newline\newline			s = tc[*tris].s, t = tc[*tris].t;\newline\newline/*    \newline			if (gl_mtexable)\newline			{\newline				qglMultiTexCoord2f (GL_TEXTURE0_ARB, s, t);\newline				qglMultiTexCoord2f (GL_TEXTURE1_ARB, s, t);\newline			}\newline			else\newline*/\newline			{\newline				glTexCoord2f (s, t);\newline			}\newline    \newline			lerpfrac = VectorL2Compare(v1-&gtxyz, v2-&gtxyz, distance) ? lerpfrac : 1;\newline\newline/*    \newline			if (gl_vertexlights.value &amp&amp !full_light)\newline			{\newline				l = R_LerpVertexLight (v1-&gtanorm_pitch, v1-&gtanorm_yaw, v2-&gtanorm_pitch, v2-&gtanorm_yaw, lerpfrac, apitch, ayaw);\newline				l = min(l, 1);\newline    \newline				for (j=0 ; j&lt3 ; j++)\newline					lightvec[j] = lightcolor[j] / 256 + l;\newline				glColor4f (lightvec[0], lightvec[1], lightvec[2], ent-&gttransparency);\newline			}\newline			else\newline*/\newline			{\newline				l = FloatInterpolate (shadedots[v1-&gtnormal&gt&gt8], lerpfrac, shadedots[v2-&gtnormal&gt&gt8]);\newline				l = (l * shadelight + ambientlight) / 256;\newline				l = min(l, 1);\newline    \newline				glColor4f (l, l, l, r_modelalpha);\newline			}\newline    \newline			VectorInterpolate (v1-&gtxyz, lerpfrac, v2-&gtxyz, interpolated_verts);\newline			glVertex3fv (interpolated_verts);\newline    \newline			tris++;\newline		}\newline\newline		glEnd();\newline\newline\newline		surf = (md3Surface_t *)((char *)surf + surf-&gtofsEnd);	//NEXT!   Getting cocky!\newline	}\newline\newline	if (r_modelalpha &lt 1)\newline		glDisable (GL_BLEND);\newline\newline	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\newline//	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\newline	glColor4f(1, 1, 1, 1);\newline\newline	glShadeModel(GL_FLAT);\newline	\newline	if (gl_affinemodels.value)\newline		glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); \newline\newline	glPopMatrix();\newline	glEnable(GL_TEXTURE_2D);\newline\newline	if (gl_fogenable.value)\newline		glDisable(GL_FOG);\newline}\newline","\newlineTo draw, for each surface, run through the triangles, getting tex coords from s+t, \newline \newline",1831860,align.c,"void free_refs(TEXT ***rset, TEXT ***ref_id, int refcnt){\newline    free_2dimarr((*rset),refcnt,TEXT); \newline    free_2dimarr((*ref_id),refcnt,TEXT);\newline}\newline",free the reference transcripts \newline,1673960,cookies.c,"bool domainSecurityCheck(const char *server, const char *domain)\newline{\newline	int i, dl, nd;\newline	dl = strlen(domain);\newline/* x.com or x.y.z */\newline	if (dl &lt 5)\newline		return false;\newline	if (dl &gt strlen(server))\newline		return false;\newline	i = strlen(server) - dl;\newline	if (!stringEqualCI(server + i, domain))\newline		return false;\newline	if (i &amp&amp server[i - 1] != &#039.&#039)\newline		return false;\newline	nd = 2;			/* number of dots */\newline	if (dl &gt 4 &amp&amp domain[dl - 4] == &#039.&#039) {\newline		static const char *const tld[] = {\newline			&quotcom&quot, &quotedu&quot, &quotnet&quot, &quotorg&quot, &quotgov&quot, &quotmil&quot, &quotint&quot, &quotbiz&quot,\newline			NULL\newline		};\newline		if (stringInListCI(tld, domain + dl - 3) &gt= 0)\newline			nd = 1;\newline	}\newline	for (i = 0; domain[i]; i++)\newline		if (domain[i] == &#039.&#039)\newline			if (!--nd)\newline				return true;\newline	return false;\newline}				/* domainSecurityCheck */\newline",Domain must be the trailing substring of server. \newline,6008672,main.c,"struct rule *matchRules(struct ra_info *data)\newline{\newline	u08 rule_number = 0;\newline	struct rule *matching_rule = NULL;\newline	struct rule *this_rule = NULL;\newline \newline	this_rule = (struct rule *)apr_hash_get(config-&gtrules,\newline					&amprule_number,\newline					sizeof(rule_number));\newline\newline	while(this_rule != NULL)\newline	{\newline		u08 i = 0;\newline		u08 prefix_match = FALSE;\newline		u08 mac_match = FALSE;\newline		u08 interface_match = FALSE;\newline		u08 lifetime_match = FALSE;\newline \newline		/* Check the prefixes */\newline		if(this_rule-&gtplen != -1)\newline		{\newline			for(i = 0 ; i &lt data-&gtnumber_prefixes; i++)\newline			{\newline				struct ra_prefix *prf = \newline					apr_hash_get(data-&gtprefixes,\newline							&ampi, sizeof(i));\newline	\newline				if(areAddressesAdjacent(prf-&gtprefix, \newline							this_rule-&gtprefix, \newline							this_rule-&gtplen))\newline				{\newline					prefix_match = TRUE;\newline					data-&gtmatched_prefix = prf;\newline					break;\newline				}\newline			}\newline		}\newline		else\newline		{\newline			/* We weren&#039t interested in the prefix */\newline			prefix_match = TRUE;\newline\newline			/* Because the prefix gets passed to the user script \newline				we need to set it to _something_ */\newline			data-&gtmatched_prefix = NULL;\newline		}\newline\newline		/* Check the source mac */\newline		if(apr_hash_count(this_rule-&gtmac_addresses) != 0)\newline		{\newline			struct macaddress *src = apr_hash_get(\newline				this_rule-&gtmac_addresses, \newline				&amp(data-&gtll_addr), \newline				sizeof(struct macaddress));\newline\newline			if(src == NULL)\newline			{\newline				mac_match = FALSE;\newline			}\newline			else\newline			{\newline				mac_match = TRUE;\newline			}\newline		}\newline		else\newline		{\newline			/* We weren&#039t interested in the source mac */\newline			mac_match = TRUE;\newline		}\newline\newline		/* Check the interface */\newline		if(this_rule-&gtinterface != -1)\newline		{\newline			if(this_rule-&gtinterface == data-&gtinterface)\newline			{\newline				interface_match = TRUE;\newline			}\newline			else\newline			{\newline				interface_match = FALSE;\newline			}\newline		}\newline		else\newline		{\newline			/* We weren&#039t interested in the interface */\newline			interface_match = TRUE;\newline		}\newline \newline		/* Check the lifetime */\newline		if(this_rule-&gtcheck_lifetime != FALSE)\newline		{\newline			if(this_rule-&gtlifetime == data-&gtra-&gtnd_ra_router_lifetime)\newline			{\newline				lifetime_match = TRUE;\newline			}\newline			else\newline			{\newline				lifetime_match = FALSE;\newline			}\newline		}\newline		else\newline		{\newline			/* We weren&#039t interested in the lifetime */\newline			lifetime_match = TRUE;\newline		}\newline\newline		if(prefix_match &amp&amp mac_match &amp&amp interface_match &amp&amp lifetime_match)\newline		{\newline			matching_rule = this_rule;\newline			break;\newline		}\newline		else\newline		{\newline			/* Advance to the next rule */\newline			rule_number++;\newline\newline			this_rule = (struct rule *)apr_hash_get(config-&gtrules,\newline					&amprule_number,\newline					sizeof(rule_number));\newline		}\newline	}\newline\newline	return matching_rule;\newline}\newline","\newline Walks all the rules, and returns a pointer to the first\newline matching rule, or NULL\newline \newline",264540,pam_otpw.c,"static int converse(pam_handle_t *pamh, int nargs,\newline		    struct pam_message **message,\newline		    struct pam_response **response,\newline		    int debug)\newline{\newline  int retval;\newline  struct pam_conv *conv;\newline  \newline  /* get pointer to conversation function */\newline  retval = pam_get_item(pamh, PAM_CONV, (const void **) &ampconv);\newline  if (retval != PAM_SUCCESS) {\newline    log_message(LOG_ERR, pamh, &quotno conversation function: %s&quot,\newline		pam_strerror(pamh, retval));\newline    return retval;\newline  }\newline  \newline  D(log_message(LOG_DEBUG, pamh, &quotcalling conversation function&quot));\newline\newline  /* call conversation function */\newline  retval = conv-&gtconv(nargs, (const struct pam_message **) message,\newline		      response, conv-&gtappdata_ptr);\newline\newline  D(log_message(LOG_DEBUG, pamh, &quotconversation function returned %d&quot, retval));\newline\newline  if (retval != PAM_SUCCESS) {\newline    log_message(LOG_WARNING, pamh, &quotconversation function failed: %s&quot,\newline		pam_strerror(pamh, retval));\newline  }\newline\newline  return retval;          /* propagate error status */\newline}\newline",\newline Wrapper around conversation function (a callback function provided by\newline the PAM application to interact with the user)\newline \newline (based on converse in pam_unix/support.c)\newline \newline,4214776,gl_rmain.c,"static void R_RenderSceneBlurDo(float alpha)\newline{\newline	static double last_time;\newline	double current_time = Sys_DoubleTime(), diff_time = current_time - last_time;\newline	double fps = gl_motion_blur_fps.value &gt 0 ? gl_motion_blur_fps.value : 77;\newline	qbool draw = (alpha &gt= 0); // negative alpha mean we don&#039t draw anything but copy screen only.\newline\newline	int vwidth = 1, vheight = 1;\newline	float vs, vt, cs, ct;\newline\newline	// Remember all attributes.\newline	glPushAttrib(GL_ALL_ATTRIB_BITS);\newline\newline	// alpha more than 0.5 are wrong.\newline	alpha = bound(0.1, alpha, 0.5);\newline\newline	if (gl_support_arb_texture_non_power_of_two)\newline	{	//we can use any size, supposedly\newline		vwidth = glwidth;\newline		vheight = glheight;\newline	}\newline	else\newline	{	//limit the texture size to square and use padding.\newline		while (vwidth &lt glwidth)\newline			vwidth *= 2;\newline		while (vheight &lt glheight)\newline			vheight *= 2;\newline	}\newline\newline	glViewport (0, 0, glwidth, glheight);\newline\newline	GL_Bind(sceneblur_texture);\newline\newline	// go 2d\newline	glMatrixMode(GL_PROJECTION);\newline	glPushMatrix();\newline	glLoadIdentity ();\newline	glOrtho(0, glwidth, 0, glheight, -99999, 99999);\newline	glMatrixMode(GL_MODELVIEW);\newline	glPushMatrix();\newline	glLoadIdentity ();\newline\newline	//blend the last frame onto the scene\newline	//the maths is because our texture is over-sized (must be power of two)\newline	cs = vs = (float)glwidth / vwidth * 0.5;\newline	ct = vt = (float)glheight / vheight * 0.5;\newline	// qqshka: I don&#039t get what is gl_motionblurscale, so simply removed it.\newline	vs *= 1;//gl_motionblurscale.value;\newline	vt *= 1;//gl_motionblurscale.value;\newline\newline	glDisable(GL_DEPTH_TEST);\newline	glDisable (GL_CULL_FACE);\newline	glDisable(GL_ALPHA_TEST);\newline	glEnable(GL_BLEND);\newline\newline	glColor4f(1, 1, 1, alpha);\newline\newline	if (draw)\newline	{\newline		glBegin(GL_QUADS);\newline		glTexCoord2f(cs-vs, ct-vt);\newline		glVertex2f(0, 0);\newline		glTexCoord2f(cs+vs, ct-vt);\newline		glVertex2f(glwidth, 0);\newline		glTexCoord2f(cs+vs, ct+vt);\newline		glVertex2f(glwidth, glheight);\newline		glTexCoord2f(cs-vs, ct+vt);\newline		glVertex2f(0, glheight);\newline		glEnd();\newline	}\newline\newline	// Restore matrices.\newline	glMatrixMode(GL_PROJECTION);\newline	glPopMatrix();\newline	glMatrixMode(GL_MODELVIEW);\newline	glPopMatrix();\newline\newline	// With high frame rate frames difference is soo smaaaal, so motion blur almost unnoticeable,\newline	// so I copy frame not every frame.\newline	if (diff_time &gt= 1.0 / fps)\newline	{\newline		last_time = current_time;\newline\newline		//copy the image into the texture so that we can play with it next frame too!\newline		glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 0, 0, vwidth, vheight, 0);\newline		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\newline		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\newline	}\newline\newline	// Restore attributes.\newline	glPopAttrib();\newline}\newline",\newlineMotion blur effect.\newlineStolen from FTE engine.\newline \newline,2092204,cnn.cpp,"static void icvCNNConvolutionBackward(\newline    CvCNNLayer* _layer, int t, const CvMat* X, const CvMat* dE_dY, CvMat* dE_dX )\newline{\newline    CvMat* dY_dX = 0;\newline    CvMat* dY_dW = 0;\newline    CvMat* dE_dW = 0;\newline\newline    CV_FUNCNAME(&quoticvCNNConvolutionBackward&quot);\newline\newline    if( !ICV_IS_CNN_CONVOLUTION_LAYER(_layer) )\newline        CV_ERROR( CV_StsBadArg, &quotInvalid layer&quot );\newline\newline    {__BEGIN__;\newline\newline    const CvCNNConvolutionLayer* layer = (CvCNNConvolutionLayer*) _layer;\newline\newline    const int K = layer-&gtK;\newline\newline    const int n_X_planes     = layer-&gtn_input_planes;\newline    const int X_plane_height = layer-&gtinput_height;\newline    const int X_plane_width  = layer-&gtinput_width;\newline    const int X_plane_size   = X_plane_height*X_plane_width;\newline\newline    const int n_Y_planes     = layer-&gtn_output_planes;\newline    const int Y_plane_height = layer-&gtoutput_height;\newline    const int Y_plane_width  = layer-&gtoutput_width;\newline    const int Y_plane_size   = Y_plane_height*Y_plane_width;\newline\newline    int no, ni, yy, xx, ky, kx;\newline    int X_idx = 0, Y_idx = 0;\newline\newline    float *X_plane = 0, *w = 0;\newline\newline    CvMat* weights = layer-&gtweights;\newline\newline    CV_ASSERT( t &gt= 1 );\newline    CV_ASSERT( n_Y_planes == weights-&gtrows );\newline\newline    dY_dX = cvCreateMat( n_Y_planes*Y_plane_size, X-&gtrows, CV_32FC1 );\newline    dY_dW = cvCreateMat( dY_dX-&gtrows, weights-&gtcols*weights-&gtrows, CV_32FC1 );\newline    dE_dW = cvCreateMat( 1, dY_dW-&gtcols, CV_32FC1 );\newline\newline    cvZero( dY_dX );\newline    cvZero( dY_dW );\newline\newline    // compute gradient of the loss function with respect to X and W\newline    for( no = 0; no &lt n_Y_planes; no++, Y_idx += Y_plane_size )\newline    {\newline        w = weights-&gtdata.fl + no*(K*K+1);\newline        X_idx = 0;\newline        X_plane = X-&gtdata.fl;\newline        for( ni = 0; ni &lt n_X_planes; ni++, X_plane += X_plane_size )\newline        {\newline            if( layer-&gtconnect_mask-&gtdata.ptr[ni*n_Y_planes+no] )\newline            {\newline                for( yy = 0; yy &lt X_plane_height - K + 1; yy++ )\newline                {\newline                    for( xx = 0; xx &lt X_plane_width - K + 1; xx++ )\newline                    {\newline                        for( ky = 0; ky &lt K; ky++ )\newline                        {\newline                            for( kx = 0; kx &lt K; kx++ )\newline                            {\newline                                CV_MAT_ELEM(*dY_dX, float, Y_idx+yy*Y_plane_width+xx,\newline                                    X_idx+(yy+ky)*X_plane_width+(xx+kx)) = w[ky*K+kx];\newline\newline                                // dY_dWi, i=1,...,K*K\newline                                CV_MAT_ELEM(*dY_dW, float, Y_idx+yy*Y_plane_width+xx,\newline                                    no*(K*K+1)+ky*K+kx) +=\newline                                    X_plane[(yy+ky)*X_plane_width+(xx+kx)];\newline                            }\newline                        }\newline                        // dY_dW(K*K+1)==1 because W(K*K+1) is bias\newline                        CV_MAT_ELEM(*dY_dW, float, Y_idx+yy*Y_plane_width+xx,\newline                            no*(K*K+1)+K*K) += 1;\newline                    }\newline                }\newline            }\newline            X_idx += X_plane_size;\newline        }\newline    }\newline\newline    CV_CALL(cvMatMul( dE_dY, dY_dW, dE_dW ));\newline    CV_CALL(cvMatMul( dE_dY, dY_dX, dE_dX ));\newline\newline    // update weights\newline    {\newline        CvMat dE_dW_mat;\newline        float eta;\newline        if( layer-&gtlearn_rate_decrease_type == CV_CNN_LEARN_RATE_DECREASE_LOG_INV )\newline            eta = -layer-&gtinit_learn_rate/logf(1+(float)t);\newline        else if( layer-&gtlearn_rate_decrease_type == CV_CNN_LEARN_RATE_DECREASE_SQRT_INV )\newline            eta = -layer-&gtinit_learn_rate/sqrtf((float)t);\newline        else\newline            eta = -layer-&gtinit_learn_rate/(float)t;\newline        cvReshape( dE_dW, &ampdE_dW_mat, 0, weights-&gtrows );\newline        cvScaleAdd( &ampdE_dW_mat, cvRealScalar(eta), weights, weights );\newline    }\newline\newline    }__END__;\newline\newline    cvReleaseMat( &ampdY_dX );\newline    cvReleaseMat( &ampdY_dW );\newline    cvReleaseMat( &ampdE_dW );\newline}\newline","&ltdE_dY&gt, &ltdE_dX&gt should be row-vectors.\newlineFunction computes partial derivatives &ltdE_dX&gt\newlineof the loss function with respect to the planes components\newlineof the previous layer (X).\newlineIt is a basic function for back propagation method.\newlineInput parameter &ltdE_dY&gt is the partial derivative of the\newlineloss function with respect to the planes components\newlineof the current layer. \newline",90729,nsock_pool.c,int nsock_pool_get_error(nsock_pool nsp) {\newline  struct npool *mt = (struct npool *)nsp;\newline  return mt-&gterrnum;\newline}\newline,This next function returns the errno style error code -- which is only\newline valid if the status NSOCK_LOOP_ERROR was returned by nsock_loop() \newline,5744751,bytecode.c,"void BCMemPut_exec(BCMemPut *bmo,VGThread *t)\newline{\newline  Memory *m  = &ampbmo-&gtm_net-&gtn_data.memory;\newline  unsigned addr;\newline  unsigned netLsb = 0;\newline\newline  if (Value_toInt(bmo-&gtm_addr,&ampaddr) &lt 0) {\newline#if DEBUG\newline    vgio_echo(&quot%p: BCMemPut: %s[?]=?&quot,t,Net_getName(bmo-&gtm_net));\newline#endif\newline    if ((Memory_getFlags(m) &amp MF_INITIALIZED))\newline      errorRun(ERR_MEMADDR,Net_getName(bmo-&gtm_net));\newline    goto done;\newline  } else {\newline    Memory_setFlags(m, MF_INITIALIZED);\newline    if (bmo-&gtm_netLsb &amp&amp Value_toInt(bmo-&gtm_netLsb,&ampnetLsb) &lt 0) {\newline      errorRun(ERR_MEMBITS,Net_getName(bmo-&gtm_net));\newline      goto done;\newline    } else if (Net_nbits(bmo-&gtm_net) == bmo-&gtm_width) {\newline      Net_memSet(bmo-&gtm_net, addr, bmo-&gtm_data);\newline    } else\newline      Net_memSetRange(bmo-&gtm_net, addr, netLsb, bmo-&gtm_data, bmo-&gtm_valLsb+bmo-&gtm_width-1, bmo-&gtm_valLsb);\newline  }\newline\newline#if DEBUG\newline  vgio_echo(&quot%p: BCMemPut: %s[%x][%d:%d]=&quot,t,Net_getName(bmo-&gtm_net), addr,bmo-&gtm_width+netLsb-1,netLsb);\newline  Value_print(bmo-&gtm_data, stdout);\newline  vgio_printf(&quot[%d:%d]\\n&quot,bmo-&gtm_width+bmo-&gtm_valLsb-1,bmo-&gtm_valLsb);\newline#endif\newline done:\newline  t-&gtt_pc++;\newline}\newline",\newline \newline Executete a BCMemPut instruction\newline \newline \newline,4153244,client_config.c,"char *get_config_filename(const char *env, const char *file) {\newline        struct stat chk;\newline        static char fname[1026];\newline        char *ptr;\newline        int flen = 1024 - strlen_nullsafe(file);\newline\newline        assert( (file != NULL));\newline        memset(&ampfname, 0, 1026);\newline\newline        if( env != NULL ) {\newline                // Use the explicit eurephia session file, if set in environment\newline                if( (ptr = getenv(env)) != NULL ) {\newline                        snprintf(fname, 1024, &quot%s&quot, ptr);\newline                        return fname;\newline                }\newline        }\newline\newline        // Use the explicit set eurephia session directory for a session file\newline        if( ((ptr = getenv(&quotEUREPHIA_DIR&quot)) != NULL) &amp&amp (strlen_nullsafe(ptr) &lt= 1016) ) {\newline                strncat(fname, ptr, flen-1);\newline                strcat(fname, &quot/&quot);\newline                strcat(fname, file);\newline                // Make sure we have this directory\newline                if( stat(ptr, &ampchk) == -1 ) {\newline                        if( mkdir(ptr, S_IRWXU) == -1 ) {\newline                                fprintf(stderr, &quotCould not create eurephia directory: %s\\n&quot, ptr);\newline                                return NULL;\newline                        }\newline                }\newline                return fname;\newline        }\newline\newline        // Use default ~/.eurephia directory for session file\newline        if( ((ptr = getenv(&quotHOME&quot)) != NULL) &amp&amp (strlen_nullsafe(ptr) &lt= 1016) ) {\newline                flen -= 10;\newline                strncat(fname, ptr, flen);\newline                strcat(fname, &quot/.eurephia&quot);\newline\newline                // Make sure we have this directory\newline                if( stat(fname, &ampchk) == -1 ) {\newline                        if( mkdir(fname, S_IRWXU) == -1 ) {\newline                                fprintf(stderr, &quotCould not create eurephia directory: %s\\n&quot, fname);\newline                                return NULL;\newline                        }\newline                }\newline                strcat(fname, &quot/&quot);\newline                strcat(fname, file);\newline                return fname;\newline        }\newline        return NULL;\newline}\newline","\newline Retrieve a the full path of a file name. Will try to look for the file in different places, like\newline if EUREPHIA_DIR is set, it will look here or else in ${HOME}/.eurephia.\newline \newline @param env const char to an environment variable to look for the given filename\newline @param file File name which we are looking for\newline \newline @return Returns a full path to the file name, or NULL on error.\newline \newline",1560716,expression.c,"Expression *Expression::extractLast(Expression *e, Expression **pe0)\newline{\newline    if (e-&gtop != TOKcomma)\newline    {\newline        *pe0 = NULL;\newline        return e;\newline    }\newline\newline    CommaExp *ce = (CommaExp *)e;\newline    if (ce-&gte2-&gtop != TOKcomma)\newline    {\newline        *pe0 = ce-&gte1;\newline        return ce-&gte2;\newline    }\newline    else\newline    {\newline        *pe0 = e;\newline\newline        Expression **pce = &ampce-&gte2;\newline        while (((CommaExp *)(*pce))-&gte2-&gtop == TOKcomma)\newline        {\newline            pce = &amp((CommaExp *)(*pce))-&gte2;\newline        }\newline        assert((*pce)-&gtop == TOKcomma);\newline        ce = (CommaExp *)(*pce);\newline        *pce = ce-&gte1;\newline\newline        return ce-&gte2;\newline    }\newline}\newline","\newline If &#039e&#039 is a tree of commas, returns the leftmost expression\newline by stripping off it from the tree. The remained part of the tree\newline is returned via pe0.\newline Otherwise &#039e&#039 is directly returned and pe0 is set to NULL.\newline \newline",1813064,sha1.c,"void sha1_hmac_update( sha1_context *ctx, const unsigned char *input, size_t ilen )\newline{\newline    sha1_update( ctx, input, ilen );\newline}\newline",\newline SHA-1 HMAC process buffer\newline \newline,,,,,on,on,,,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,handles the start of a 'REPEAT' loop,"To draw, for each surface, run through the triangles,",free the reference transcripts,Domain must be the trailing substring of server.,{},{},Motion blur effect.,Function computes partial derivatives,This next function returns the errno style error code,Executete a BCMemPut instruction,"Returns a full path to the file name,",This convenience method combines a call,Otherwise 'e' is directly returned and pe0 is set to NULL.,process buffer,Dumps the record content to stdout.,Processes a character class in shell ignore patterns.,computes least common multiple,Returns bytes still to read..,returns the time elapsed retrieving sequences in seconds,{},Load an image from the named file.,x,
3B9XR6P1WEVFBJ8I8MXMSL20ZBNBJF,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:44 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:44 PDT 2019,,,308XBLVESI4YWROO6TBWJVKGRNYRBO,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:41 PDT 2019,Fri Apr 26 13:03:30 PDT 2019,Sun Apr 28 13:03:30 PDT 2019,,,,949,100% (62/62),100% (62/62),0% (0/0),775118,dmsetup.c,"static void _display_tree_walk_children(struct dm_tree_node *node,\newline					unsigned depth)\newline{\newline	struct dm_tree_node *child, *next_child;\newline	void *handle = NULL;\newline	uint32_t inverted = _tree_switches[TR_BOTTOMUP];\newline	unsigned first_child = 1;\newline	unsigned has_children;\newline\newline	next_child = dm_tree_next_child(&amphandle, node, inverted);\newline\newline	while ((child = next_child)) {\newline		next_child = dm_tree_next_child(&amphandle, node, inverted);\newline		has_children =\newline		    dm_tree_node_num_children(child, inverted) ? 1 : 0;\newline\newline		_display_tree_node(child, depth, first_child,\newline				   next_child ? 0U : 1U, has_children);\newline\newline		if (has_children)\newline			_display_tree_walk_children(child, depth + 1);\newline\newline		first_child = 0;\newline	}\newline}\newline",\newline Walk the dependency tree\newline \newline,4586703,qglviewer.cpp,"void QGLViewer::closeEvent(QCloseEvent *e)\newline{\newline	// When the user clicks on the window close (x) button:\newline	// - If the viewer is a top level window, closeEvent is called and then saves to file.\newline	// - Otherwise, nothing happen s:(\newline	// When the user press the EXIT_VIEWER keyboard shortcut:\newline	// - If the viewer is a top level window, saveStateToFile() is also called\newline	// - Otherwise, closeEvent is NOT called and keyPressEvent does the job.\newline\newline	/* After tests:\newline	E : Embedded widget\newline	N : Widget created with new\newline	C : closeEvent called\newline	D : destructor called\newline\newline	E	N	C	D\newline	y	y\newline	y	n		y\newline	n	y	y\newline	n	n	y	y\newline\newline	closeEvent is called iif the widget is NOT embedded.\newline\newline	Destructor is called iif the widget is created on the stack\newline	or if widget (resp. parent if embedded) is created with WDestructiveClose flag.\newline\newline	closeEvent always before destructor.\newline\newline	Close using qApp-&gtcloseAllWindows or (x) is identical.\newline	*/\newline\newline	// #CONNECTION# Also done for EXIT_VIEWER in keyPressEvent().\newline	saveStateToFile();\newline	QGLWidget::closeEvent(e);\newline}\newline",! Overloading of the \\c QWidget method.\newlineSaves the viewer state using saveStateToFile() and then calls QGLWidget::closeEvent(). \newline,1080193,info_helper.c,"static void meta_info_public_reset_unlocked(xine_stream_t *stream, int info) {\newline  if(meta_valid(info)) {\newline    if(stream-&gtmeta_info_public[info])\newline      free(stream-&gtmeta_info_public[info]);\newline    stream-&gtmeta_info_public[info] = NULL;\newline  }\newline}\newline",\newline Reset (nullify) public info value.\newline \newline,2810764,mktclapp.c,"&quotstatic int Et_FileSeek(\\n&quot\newline&quot  ClientData instanceData,    /* The file structure */\\n&quot\newline&quot  long offset,                /* Offset to seek to */\\n&quot\newline&quot  int mode,                   /* One of SEEK_CUR, SEEK_SET or SEEK_END */\\n&quot\newline&quot  int *pErrorCode             /* Write the error code here */\\n&quot\newline&quot){\\n&quot\newline&quot  Et_FileStruct *p = (Et_FileStruct*)instanceData;\\n&quot\newline&quot  switch( mode ){\\n&quot\newline&quot    case SEEK_CUR:     offset += p-&gtcursor;   break;\\n&quot\newline&quot    case SEEK_END:     offset += p-&gtnData;    break;\\n&quot\newline&quot    default:           break;\\n&quot\newline&quot  }\\n&quot\newline&quot  if( offset&lt0 ) offset = 0;\\n&quot\newline&quot  if( offset&gtp-&gtnData ) offset = p-&gtnData;\\n&quot\newline&quot  p-&gtcursor = offset;\\n&quot\newline&quot  return offset;\\n&quot\newline&quot}\\n&quot\newline",&quot \\n&quot\newline&quot Move the cursor around within the built-in file.\\n&quot\newline&quot \\n&quot\newline,4227689,subopt-helper.c,int int_pos(void *iptr)\newline{\newline  int *i = iptr;\newline  return *i &gt 0;\newline}\newline,\\brief Test if i is positive. \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1119506,fivestatemodel.c,int flush_FiveStateScore(FiveStateScore * obj) \newline{\newline    int i;   \newline\newline\newline    for(i=0;i&ltobj-&gtlen;i++)  { /*for i over list length*/ \newline      if( obj-&gtunit[i] != NULL)  {  \newline        free_FiveStateScoreUnit(obj-&gtunit[i]);   \newline        obj-&gtunit[i] = NULL; \newline        }  \newline      } /* end of for i over list length */ \newline\newline\newline    obj-&gtlen = 0;    \newline    return i;    \newline}    \newline,"Function: flush_FiveStateScore(obj)\newline \newline Descrip: Frees the list elements, sets length to 0\newline If you want to save some elements, use hard_link_xxx\newline to protect them from being actually destroyed in the free\newline \newline \newline Arg: obj [UNKN ] Object which contains the list [FiveStateScore ]\newline \newline Return [UNKN ] Undocumented return value [int]\newline \newline \newline",264138,debugger.c,"void tilem_debugger_show(TilemDebugger *dbg)\newline{\newline	g_return_if_fail(dbg != NULL);\newline	g_return_if_fail(dbg-&gtemu-&gtcalc != NULL);\newline	tilem_calc_emulator_pause(dbg-&gtemu);\newline	cancel_step_bp(dbg);\newline	refresh_all(dbg, TRUE);\newline	go_to_stack_pos(dbg, -1);\newline	gtk_window_present(GTK_WINDOW(dbg-&gtwindow));\newline}\newline","Show debugger, and pause emulator if not already paused. \newline",2847057,draw1.cpp,"int GetColorFloatToInt(float red, float green, float blue)\newline{  \newline        int Color;\newline        int red_int, green_int, blue_int;\newline        \newline        \newline        red_int = Round_float_to_int(red * MAXFARBANTEIL);\newline        green_int = Round_float_to_int(green * MAXFARBANTEIL);\newline        blue_int = Round_float_to_int(blue * MAXFARBANTEIL);\newline                \newline        Color = 0;\newline        Color += (red_int &amp 0xff);\newline            Color += (green_int &amp 0xff) &lt&lt 8;\newline            Color += (blue_int &amp 0xff) &lt&lt 16;\newline        return Color;\newline} \newline",\newline GetColorFloatToInt -- Errechnet die zusammengesetze Farbe von Scrollbar(0-100) float werten in\newline Farbwerte(0-255) und setzt diese dann zusammen in rin Integer Wert\newline um diesen gibt er dann als Rueckgabewert zurueck\newline \newline red Rotanteil der ganzen Farbe\newline \newline green Gruenanteil der ganzen Farbe\newline \newline blue Blauanteil der ganzen Farbe\newline \newline RETURN Rueckgabe der vollstaendigen Farbe als ein Integerwert\newline \newline,4459099,field_integer.cpp,void ID3_FieldImpl::Set(uint32 val)\newline{\newline  this-&gtSetInteger(val);\newline}\newline,\\brief Sets the value of the field to the specified integer.\newline \\param data The data to assign to this field\newline \newline,3094392,packetforge-ng.c,"int getip( char *s, unsigned char *ip , unsigned short *port)\newline{\newline    int i = 0, n;\newline\newline    while( sscanf( s, &quot%d&quot, &ampn ) == 1 )\newline    {\newline        if( n &lt 0 || n &gt 255 )\newline            return( 1 );\newline\newline        ip[i] = n;\newline\newline        if( ++i == 4 ) break;\newline\newline        if( ! ( s = strchr( s, &#039.&#039 ) ) )\newline            break;\newline\newline        s++;\newline    }\newline\newline    if(i != 4) return 1;\newline\newline    if( ( s = strchr( s, &#039:&#039 ) ) &amp&amp i == 4 )\newline    {\newline        s++;\newline        if( sscanf( s, &quot%d&quot, &ampn ) == 1 )\newline        {\newline            if(n &gt 0 &amp&amp n &lt 65536)\newline                *port = n;\newline        }\newline    }\newline\newline    return( i != 4 );\newline}\newline",IP address parsing routine \newline,2626709,im.c,"int aim_mpmsg_init(aim_session_t *sess, aim_mpmsg_t *mpm)\newline{\newline\newline	memset(mpm, 0, sizeof(aim_mpmsg_t));\newline\newline	return 0;\newline}\newline","\newline Ahh, the joys of nearly ridiculous over-engineering.\newline \newline Not only do AIM ICBM&#039s support multiple channels. Not only do they\newline support multiple character sets. But they support multiple character\newline sets / encodings within the same ICBM.\newline \newline These multipart messages allow for complex space savings techniques, which\newline seem utterly unnecessary by today&#039s standards. In fact, there is only\newline one client still in popular use that still uses this method: AOL for the\newline Macintosh, Version 5.0. Obscure, yes, I know.\newline \newline In modern (non-&quotlegacy&quot) clients, if the user tries to send a character\newline that is not ISO-8859-1 or ASCII, the client will send the entire message\newline as UNICODE, meaning that every character in the message will occupy the\newline full 16 bit UNICODE field, even if the high order byte would be zero.\newline Multipart messages prevent this wasted space by allowing the client to\newline only send the characters in UNICODE that need to be sent that way, and\newline the rest of the message can be sent in whatever the native character\newline set is (probably ASCII).\newline \newline An important note is that sections will be displayed in the order that\newline they appear in the ICBM. There is no facility for merging or rearranging\newline sections at run time. So if you have, say, ASCII then UNICODE then ASCII,\newline you must supply two ASCII sections with a UNICODE in the middle, and incur\newline the associated overhead.\newline \newline Normally I would have laughed and given a firm &#039no&#039 to supporting this\newline seldom-used feature, but something is attracting me to it. In the future,\newline it may be possible to abuse this to send mixed-media messages to other\newline open source clients (like encryption or something) -- see faimtest for\newline examples of how to do this.\newline \newline I would definitely recommend avoiding this feature unless you really\newline know what you are doing, and/or you have something neat to do with it.\newline \newline \newline",4900240,semanage_store.c,"static int append_arg(char ***argv, int *num_args, const char *arg)\newline{\newline	char **a;\newline\newline	a = realloc(*argv, sizeof(**argv) * (*num_args + 1));\newline	if (a == NULL)\newline		return -1;\newline\newline	*argv = a;\newline	a[*num_args] = NULL;\newline\newline	if (arg) {\newline		a[*num_args] = strdup(arg);\newline		if (!a[*num_args])\newline			return -1;\newline	}\newline	(*num_args)++;\newline	return 0;\newline}\newline",\newline Append an argument string to an argument vector. Replaces the\newline argument pointer passed in. Returns -1 on error. Increments\newline &#039num_args&#039 on success.\newline \newline,5704114,qscriptdebuggercommand.cpp,QScriptDebuggerCommand &ampQScriptDebuggerCommand::operator=(const QScriptDebuggerCommand &ampother)\newline{\newline    *d_ptr = *other.d_ptr;\newline    return *this;\newline}\newline,!\newlineAssigns the \\a other value to this QScriptDebuggerCommand.\newline \newline,3081822,nfctype1.c,"static int read_dynamic_tag(uint8_t *cc, int length, void *data)\newline{\newline	struct type1_tag *t1_tag = data;\newline	struct type1_dynamic_cmd t1_cmd;\newline	uint8_t *tagdata;\newline	uint8_t	*pndef;\newline	size_t data_length;\newline	uint8_t current_addr = 12; /* CC =&gt after HR, UID */\newline\newline	DBG(&quotDynamic Mode&quot);\newline\newline	tagdata = near_tag_get_data(t1_tag-&gttag, &ampdata_length);\newline\newline	/* Skip capability container bytes  */\newline	pndef = cc + 4;		/* right after CC bytes */\newline	length -= 14; /* Remove HR + UID + CC */\newline\newline	/*\newline	 * First bytes of the data memory might contains LOCK TLV\newline	 * Let&#039s store them and continue till we found the NDEF TLV\newline	 */\newline	do {\newline		uint16_t byte_addr;\newline		uint8_t page_addr;\newline		uint8_t byte_offset;\newline		uint8_t bytes_per_page;\newline		uint8_t size = 0;\newline\newline		if (*pndef == NDEF_TLV_TYPE) {\newline			break;\newline		} else if (*pndef == LOCK_TLV_TYPE ||\newline			   *pndef == RESERVED_TLV_TYPE) {\newline			page_addr = (pndef[2] &gt&gt 4) &amp 0xF;\newline			byte_offset = pndef[2] &amp 0xF;\newline			if (*pndef == LOCK_TLV_TYPE)\newline				size = pndef[3] / 8; /* Convert in bytes */\newline			else\newline				size = pndef[3];\newline			bytes_per_page = pndef[4] &amp 0xF;\newline			byte_addr = (page_addr - 1) * (2 &lt&lt (bytes_per_page - 1))\newline				+ byte_offset;\newline		}\newline\newline		if (size != 0) {\newline			uint8_t i;\newline\newline			for (i = 0; i &lt size; ++i)\newline				t1_tag-&gtlocked_bytes[t1_tag-&gtnb_locked_bytes++] = byte_addr + i;\newline		}\newline		length -= 2 + pndef[1];\newline		current_addr += 2 + pndef[1];\newline		pndef += 2 + pndef[1];\newline	} while (length &gt 0);\newline\newline\newline	if (length &lt= 0) {\newline		DBG(&quotNDEF TLV not found&quot);\newline		return -1;\newline	}\newline\newline	t1_tag-&gtreal_addr = current_addr;\newline\newline	if (lock_bytes_in_region(t1_tag, current_addr, length)) {\newline		uint8_t i, j;\newline\newline		for (i = j = 0; i &lt length; ++i)\newline			if (!lock_byte(t1_tag, current_addr + i))\newline				tagdata[j++] = pndef[i];\newline		t1_tag-&gtreal_addr += i;\newline		length = j;\newline	} else {\newline		/*\newline		 * Save NDEF TLV first bytes of payload to tag memoy\newline		 */\newline		memcpy(tagdata,	pndef, length);\newline		t1_tag-&gtreal_addr += length;\newline	}\newline\newline	/* Read the next one, up to the end of the data area */\newline	t1_tag-&gtcurrent_seg = 1;\newline	t1_tag-&gtlast_seg = ((cc[2] * BLOCK_SIZE) / TAG_T1_SEGMENT_SIZE);\newline	t1_tag-&gtdata_read = length;\newline\newline	t1_init_dynamic_cmd(t1_tag, &ampt1_cmd);\newline\newline	/* T1 read segment */\newline	t1_cmd.cmd = CMD_READ_SEGS;\newline	/* 5.3.3 ADDS operand is [b8..b5] */\newline	t1_cmd.addr = (t1_tag-&gtcurrent_seg &lt&lt 4) &amp 0xFF;\newline\newline	return near_adapter_send(t1_tag-&gtadapter_idx,\newline			(uint8_t *)&ampt1_cmd, sizeof(t1_cmd),\newline			data_recv, t1_tag, NULL);\newline}\newline","\newline The dynamic read function:\newline Bytes [0..3] : CC\newline [4..8]: TLV Lock ControlIT (0x01, 0x03, v1, V2, V3)\newline [9..13]: TLV Reserved Memory Control (0x02, 0x03, V1, V2, V3)\newline [14..]: TLV NDEF (0x03, L0, L1, L2, V1,V2 ...)\newline \newline",2489276,gzread.c,"local int gz_load(\newline    gz_statep state,\newline    unsigned char *buf,\newline    unsigned len,\newline    unsigned *have)\newline{\newline    int ret;\newline\newline    *have = 0;\newline    do {\newline        ret = read(state-&gtfd, buf + *have, len - *have);\newline        if (ret &lt= 0)\newline            break;\newline        *have += ret;\newline    } while (*have &lt len);\newline    if (ret &lt 0) {\newline        gz_error(state, Z_ERRNO, zstrerror());\newline        return -1;\newline    }\newline    if (ret == 0)\newline        state-&gteof = 1;\newline    return 0;\newline}\newline","Use read() to load a buffer -- return -1 on error, otherwise 0. Read from\newlinestate-&gtfd, and update state-&gteof, state-&gterr, and state-&gtmsg as appropriate.\newlineThis function needs to loop on read(), since read() is not guaranteed to\newlineread the number of bytes requested, depending on the type of descriptor. \newline",4236172,aa_drawcircle.c,"void aa_drawcircle(aa_context *context, int cx, int cy,\newline				int r, int color, int fillcolor) {\newline	/* Set fillcolor to -1 to leave empty */\newline	int x, y, xchange, ychange, radiuserror;\newline	x = r;\newline	y = 0;\newline	xchange = 1 - 2*r;\newline	ychange = 1;\newline	radiuserror = 0;\newline	while (x&gt=y) {\newline		aa_plot8circlepoints(context, x, y, cx, cy, color, fillcolor);\newline		y++;\newline		radiuserror+=ychange;\newline		ychange+=2;\newline		if(radiuserror*2 + xchange &gt 0) {\newline			x--;\newline			radiuserror+=xchange;\newline			xchange+=2;\newline		}\newline	}\newline}\newline",Flagrantly ripped from http://homepage.smc.edu/kennedy_john/BCIRCLE.PDF\newline &quotA Fast Bresenham Type Algorithm For Drawing Circles&quot \newline,703091,pmath.c,int fpcrtl_signi(int x)\newline{\newline    if(x &gt 0){\newline        return 1;\newline    }\newline    else if(x &lt 0){\newline        return -1;\newline    }\newline    else{\newline        return 0;\newline    }\newline}\newline,Currently the games only uses sign of an integer \newline,5692326,pnmin.c,"int pnm_fget_bytes(const pnm_struct *pnm_ptr,\newline                   unsigned char *sample_bytes,\newline                   size_t sample_size,\newline                   unsigned int num_rows,\newline                   FILE *stream)\newline{\newline    unsigned int format = pnm_ptr-&gtformat;\newline    unsigned int depth  = pnm_ptr-&gtdepth;\newline    unsigned int width  = pnm_ptr-&gtwidth;\newline    unsigned int maxval = pnm_ptr-&gtmaxval;\newline    size_t row_length = (size_t)depth * (size_t)width;\newline    size_t num_samples = num_rows * row_length;\newline    size_t raw_sample_size;\newline    int ch, mask;\newline    size_t i, j;\newline\newline    /* validate the given sample size */\newline    if (maxval &lt= 0xffU)\newline        raw_sample_size = 1;\newline    else if (maxval &lt= 0xffffU)\newline        raw_sample_size = 2;\newline#if PNM_UINT_BIT &gt 16\newline    else if (maxval &lt= 0xffffffU)\newline        raw_sample_size = 3;\newline    else if (maxval &lt= 0xffffffffU)\newline        raw_sample_size = 4;\newline#endif\newline    else  /* maxval &gt PNM_UINT_MAX */\newline        raw_sample_size = !sample_size;\newline    if (raw_sample_size != sample_size)\newline    {\newline        errno = EINVAL;\newline        return 0;\newline    }\newline\newline    /* read the raw sample bytes */\newline    switch (format)\newline    {\newline    case PNM_P4:\newline        for (i = j = 0; i &lt num_samples; )\newline        {\newline            ch = getc(stream);\newline            if (ch == EOF)\newline                break;\newline            for (mask = 0x80; mask != 0; mask &gt&gt= 1)\newline            {\newline                sample_bytes[i++] = (unsigned char)((ch &amp mask) ? 0 : 1);\newline                if (++j == row_length)\newline                {\newline                    j = 0;\newline                    break;\newline                }\newline            }\newline        }\newline        break;\newline    case PNM_P5:\newline    case PNM_P6:\newline    case PNM_P7:\newline        i = fread(sample_bytes, sample_size, num_samples, stream);\newline        break;\newline    default:\newline        errno = EINVAL;\newline        return 0;\newline    }\newline\newline    /* check the result */\newline    if (i &lt num_samples)\newline    {\newline        memset(sample_bytes + i, 0, sample_size * num_samples - i);\newline        return -1;\newline    }\newline    return 1;\newline}\newline","\newline Reads an array of sample bytes from a raw PNM file stream.\newline Multi-byte samples are stored in network order, as in the PNM stream.\newline The byte count is sample_size pnm_ptr-&gtdepth pnm_ptr-&gtwidth num_rows.\newline The validity check performed on the PNM structure is only partial.\newline Returns 1 on success, 0 on validation failure, or -1 on input failure.\newline If reading is incomplete, the remaining sample bytes are set to 0.\newline \newline",3245747,guiclient.cpp,void GUIClient::sPurchaseOrderReceiptsUpdated()\newline{\newline  emit purchaseOrderReceiptsUpdated();\newline}\newline,"@brief This slot tells other open windows the definition or status of one or more Receipts has changed.\newlineThe name @c sPurchaseORderReceiptsUpdated is no longer accurate, as this\newlineapplies to any receipt.\newline \newline",3068950,nxstaxablock.cpp,unsigned NxsTaxaBlock::GetMaxTaxonLabelLength()\newline	{\newline	NxsStringVector::const_iterator tlIt = taxLabels.begin();\newline	unsigned maxlen = 0;\newline	for (; tlIt &lt taxLabels.end(); ++tlIt)\newline		{\newline		const unsigned thislen = (unsigned)tlIt-&gtsize();\newline		if (thislen &gt maxlen)\newline			maxlen = thislen;\newline		}\newline	return maxlen;\newline	}\newline,"Returns the length of the longest taxon label stored. Useful for formatting purposes in outputting the data matrix\newline (i.e., you want the left edge of the matrix to line up).\newline \newline",,,,on,,,on,,on,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,Walk the dependency tree,Sets the value of the field to the specified integer.,IP address parsing routine,{},Returns -1 on error.,Assigns the \a other value to this QScriptDebuggerCommand.,{},"This function needs to loop on read(),",{},Currently the games only uses sign of an integer,Reads an array of sample bytes from a raw PNM file stream.,Saves the viewer state using saveStateToFile(),This slot tells other open windows,Returns the length of the longest taxon label stored.,Reset (nullify) public info value.,"Move the cursor around within the built-in file.\n""",Test if i is positive.,Load an image from the named file.,"Frees the list elements, sets length to 0","Show debugger, and pause emulator if not already paused.",{},x,
33NKDW9FFXIZG85D3Q8IUEGXSU1CXA,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:17 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:17 PDT 2019,,,3MYYFCXHJ37NM2U1B37XCD03FNTG40,AITP2LUW8GPB,Submitted,Fri Apr 26 13:43:25 PDT 2019,Fri Apr 26 13:49:00 PDT 2019,Sun Apr 28 13:49:00 PDT 2019,,,,335,100% (62/62),100% (62/62),0% (0/0),4359554,stats.c,"static Stats Add__Stats(Object o, char *compname, \newline			char *statname, int cfmember, struct stats *sptr)\newline{\newline    Array a, na = NULL;\newline    Type type;\newline    Category category;\newline    int rank;\newline    Pointer dp, dp2;\newline    int isarray = 0;\newline    int size, shape[MAXDIM];\newline    double origin[MAXDIM];\newline    struct stats *s = NULL;\newline    ICH hasinvalid = NULL;\newline\newline    /* this code either does a simple field, or a single array */\newline    if (DXGetObjectClass(o) == CLASS_FIELD) {\newline	a = (Array)DXGetComponentValue((Field)o, compname);\newline	if (!a) {\newline	    DXSetError(ERROR_MISSING_DATA, &quot#10250&quot, &quotinput&quot, compname);\newline	    return NULL;\newline	}\newline	/* are they already there?  they must be if cfmember is set, they\newline         *  may or may not be otherwise.\newline	 */\newline	na = (Array)DXGetComponentValue((Field)o, statname);\newline	if (cfmember &amp&amp !na) {\newline	    DXSetError(ERROR_INTERNAL, \newline		       &quotproblems computing partitioned statistics&quot);\newline	    return NULL;\newline	}\newline	if (!cfmember &amp&amp na)\newline	    return (Stats)DXGetArrayData(na);\newline\newline	na = NULL;\newline	if (!HasInvalid((Field)o, compname, &amphasinvalid))\newline	    return NULL;\newline    } else {\newline	a = (Array)o;\newline	isarray++;\newline    }\newline    if (DXGetObjectClass((Object)a) != CLASS_ARRAY) {\newline	DXSetError(ERROR_BAD_CLASS, &quot#11890&quot);\newline	goto done1;\newline    }\newline\newline    /* get size and shape */\newline    DXGetArrayInfo(a, &ampsize, &amptype, &ampcategory, &amprank, shape);\newline    if (rank == 0)\newline	shape[0] = 1;\newline\newline    /* check type, category, rank &amp shape */\newline    if (supported(a) != OK)\newline	goto done1;\newline\newline    s = sptr;\newline    memset(s, &#039\\0&#039, sizeof(struct stats));\newline    \newline\newline    /* after the stats array is set to 0, return if there is no data */\newline    if (size &lt= 0)\newline	goto nodata;\newline\newline    s-&gtcounts = size;\newline	\newline\newline    /* if the data is constant, this converts the origins to double, and\newline     *  does NOT call DXGetArrayData so the constant array doesn&#039t get\newline     *  expanded.\newline     */\newline    if (ConstantData(a, origin) &amp&amp !hasinvalid) {\newline	\newline	switch(shape[0]) {\newline	  case 0:    /* scalar == 1-vector == 1-matrix, etc */\newline	  case 1:\newline	    doubleS_stat(origin, 1, s, NULL);\newline	    break;\newline	    \newline	  case 2:  /* 2-vector or 2x2 matrix */\newline	    switch(rank) {\newline	      case 1:\newline		doublev2D_stat(origin, 1, s, NULL);\newline		break;\newline	      case 2:\newline		doublem2D_stat(origin, 1, s, NULL);\newline		break;\newline	    }\newline	    break;\newline\newline	  case 3:   /* 3-vector or 3x3 matrix */\newline	    switch(rank) {\newline	      case 1:\newline		doublev3D_stat(origin, 1, s, NULL);\newline		break;\newline	      case 2:\newline		doublem3D_stat(origin, 1, s, NULL);\newline		break;\newline	    }\newline	    break;\newline	    \newline	  default:  /* N-vector or NxN matrix */\newline	    switch(rank) {\newline	      case 1:\newline		doublevND_stat(origin, 1, shape[0], s, NULL);\newline		break;\newline	      case 2:\newline		doublemND_stat(origin, 1, shape[0], s, NULL);\newline		break;\newline	    }\newline	    break;\newline	}\newline\newline	/* fix sum and sum squared because we&#039ve only actually worked\newline         * on 1 data item instead of the real count.  also have to\newline	 * fix counts as well.\newline	 */\newline	s-&gtsum = s-&gtavg * size;\newline	s-&gtsumsq = s-&gtavg * s-&gtavg * size;\newline	s-&gtcounts = size;  \newline\newline	if (s-&gtcounts &lt= 0)\newline	    goto nodata;\newline\newline	s-&gtisvalid = 1;\newline	goto done;\newline    }\newline\newline    /* define the macros used in the case statements below.\newline     */\newline\newline#define EACHTYPE(ss) \\\newline    switch(type) { \\\newline      case TYPE_UBYTE: ubyte##ss##_stat((ubyte *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_BYTE: byte##ss##_stat((byte *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_USHORT: ushort##ss##_stat((ushort *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_SHORT: short##ss##_stat((short *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_UINT: uint##ss##_stat((uint *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_INT: int##ss##_stat((int *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_FLOAT: float##ss##_stat((float *)dp, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_DOUBLE: double##ss##_stat((double *)dp, size, s, hasinvalid); \\\newline	break; \\\newline    }\newline    \newline#define EACHTYPE_R(ss) \\\newline    switch(type) { \\\newline      case TYPE_UBYTE: \\\newline	ubyte##ss##_stat((ubyte *)dp, (ubyte *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_BYTE: \\\newline        byte##ss##_stat((byte *)dp, (byte *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_USHORT: \\\newline        ushort##ss##_stat((ushort *)dp, (ushort *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_SHORT: \\\newline        short##ss##_stat((short *)dp, (short *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_UINT: \\\newline        uint##ss##_stat((uint *)dp, (uint *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_INT: \\\newline        int##ss##_stat((int *)dp, (int *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_FLOAT: \\\newline        float##ss##_stat((float *)dp, (float *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_DOUBLE: \\\newline        double##ss##_stat((double *)dp, (double *)dp2, size, s, hasinvalid); \\\newline	break; \\\newline    }\newline    \newline#define EACHTYPE_N(ss, len) \\\newline    switch(type) { \\\newline      case TYPE_UBYTE: \\\newline        ubyte##ss##_stat((ubyte *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_BYTE: \\\newline        byte##ss##_stat((byte *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_USHORT: \\\newline        ushort##ss##_stat((ushort *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_SHORT: \\\newline        short##ss##_stat((short *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_UINT: \\\newline        uint##ss##_stat((uint *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_INT: \\\newline        int##ss##_stat((int *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_FLOAT: \\\newline        float##ss##_stat((float *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline      case TYPE_DOUBLE: \\\newline        double##ss##_stat((double *)dp, size, len, s, hasinvalid); \\\newline	break; \\\newline    }\newline    \newline\newline    /* if the data is scalar and regular, compute the stats without\newline     *  calling DXGetArrayData so the data doesn&#039t get expanded.\newline     */\newline    if (RegularData(a)) {\newline	\newline	switch(shape[0]) {\newline	  case 0:    /* scalar == 1-vector == 1-matrix, etc */\newline	  case 1:\newline	    dp = (Pointer)origin;\newline	    dp2 = (Pointer)(origin+1);\newline	    if (!DXGetRegularArrayInfo((RegularArray)a, NULL, dp, dp2))\newline		goto error;\newline\newline	    EACHTYPE_R(RS);\newline	    \newline	    if (s-&gtcounts &lt= 0)\newline		goto nodata;\newline	    \newline	    s-&gtisvalid = 1;\newline	    goto done;\newline	    \newline	  default: /* for now, don&#039t handle vectors or matricies */\newline	    break;\newline	}\newline    }\newline\newline\newline    /* must be irregular and/or have invalid parts */\newline    \newline    dp = DXGetArrayData(a);\newline    if (!dp)\newline	goto error;\newline    \newline    switch(shape[0]) {\newline      case 0:    /* scalar == 1-vector == 1-matrix, etc */\newline      case 1:\newline	EACHTYPE(S);\newline	break;\newline	\newline      case 2:  /* 2-vector or 2x2 matrix */\newline	switch(rank) {\newline	  case 1:\newline	    EACHTYPE(v2D);\newline	    break;\newline	  case 2:\newline	    EACHTYPE(m2D);\newline	    break;\newline	}\newline	break;\newline\newline      case 3:   /* 3-vector or 3x3 matrix */\newline	switch(rank) {\newline	  case 1:\newline	    EACHTYPE(v3D);\newline	    break;\newline	  case 2:\newline	    EACHTYPE(m3D);\newline	    break;\newline	}\newline	break;\newline	\newline      default:  /* N-vector or NxN matrix */\newline	switch(rank) {\newline	  case 1:\newline	    EACHTYPE_N(vND, shape[0]);\newline	    break;\newline	  case 2:\newline	    EACHTYPE_N(mND, shape[0]);\newline	    break;\newline	}\newline	break;\newline    }\newline\newline    if (s-&gtcounts &lt= 0)\newline	goto nodata;\newline\newline#define STATLEN 12  /* strlen(&quot statistics&quot); */\newline\newline  nodata:\newline    /* fall thru */\newline\newline  done:\newline    if (!isarray) {\newline	int n = sizeof(struct stats) / sizeof(double);\newline	double one = 1.0;\newline\newline	/* make new stats component if not composite field */\newline	if (!cfmember) {\newline	    na = DXNewArray(TYPE_DOUBLE, CATEGORY_REAL, 0);\newline	    if(!na)\newline		goto error;\newline	    \newline	    if (!DXAddArrayData(na, 0, n, (Pointer)sptr))\newline		goto error;\newline\newline	    /* if there was an invalid component, make the stats both der\newline	     * on the data and on the invalid component.  else just der data.\newline	     */\newline	    if (hasinvalid) {\newline		char *cp;\newline		Array sl;\newline\newline		if (!InvalidName((Field)o, compname, &ampcp))\newline		    goto error;\newline		sl = DXMakeStringList(2, compname, cp);\newline		DXFree(cp);\newline		if (!sl)\newline		    goto error;\newline		if (!DXSetAttribute((Object)na, &quotder&quot, (Object)sl)) {\newline		    DXDelete((Object)sl);\newline		    goto error;\newline		}\newline	    } else if (!DXSetStringAttribute((Object)na, &quotder&quot, compname))\newline		goto error;\newline\newline	    if (!DXSetComponentValue((Field)o, statname, (Object)na))\newline		goto error;\newline	    \newline	} else {\newline	    na = (Array)DXGetComponentValue((Field)o, statname);\newline	    if (!na)\newline		goto error;\newline\newline	    if (!DXAddArrayData(na, n, n, (Pointer)sptr))\newline		goto error;\newline	    \newline	    if (!DXAddArrayData(na, n*2, 1, &ampone))\newline		goto error;\newline	}\newline    }\newline\newline  done1:    \newline    DXFreeInvalidComponentHandle(hasinvalid);\newline    return s;\newline\newline  error:\newline    DXFreeInvalidComponentHandle(hasinvalid);\newline    DXDelete((Object)na);\newline    return NULL;\newline}\newline","\newline On successful completion, fill in the Stats structure pointed to by sp.\newline \newline",1219570,test.c,"void PanacheCreateNotify (XCreateWindowEvent *event) {\newline							\newline	if (event-&gtoverride_redirect == 0 || event-&gtparent != root) {\newline		return;\newline	}\newline	\newline	CListAppend (keepAboveWindowList, event-&gtwindow);\newline}\newline","This appends windows that are not to be managed by \newline Panache to a list, and Panache will later on raise \newline them above other windows. \newline \newline",6428202,htscharset.c,static unsigned int nlz8(unsigned char x) {\newline  unsigned int b = 0;\newline\newline  if (x &amp 0xf0) {\newline    x &gt&gt= 4;\newline  } else {\newline    b += 4;\newline  }\newline\newline  if (x &amp 0x0c) {\newline    x &gt&gt= 2;\newline  } else {\newline    b += 2;\newline  }\newline\newline  if (! (x &amp 0x02) ) {\newline    b++;\newline  }\newline\newline  return b;\newline}\newline,Number of leading zeros. Returns a value between 0 and 8. \newline,3630245,malloc.c,unsigned int	dmalloc_debug_current(void)\newline{\newline  if (! enabled_b) {\newline    (void)dmalloc_startup(NULL /* no options string */);\newline  }\newline  \newline  /* should not check the heap here since we are dumping the debug variable */\newline  return _dmalloc_flags;\newline}\newline,\newline unsigned int dmalloc_debug_current\newline \newline DESCRIPTION:\newline \newline Returns the current debug functionality flags. This allows you to\newline save a dmalloc library state to be restored later.\newline \newline RETURNS:\newline \newline Current debug flags.\newline \newline ARGUMENTS:\newline \newline None.\newline \newline,5282039,lj_cparse.c,"static void cp_decl_asm(CPState *cp, CPDecl *decl)\newline{\newline  UNUSED(decl);\newline  cp_next(cp);\newline  cp_check(cp, &#039(&#039);\newline  if (cp-&gttok == CTOK_STRING) {\newline    GCstr *str = cp-&gtstr;\newline    while (cp_next(cp) == CTOK_STRING) {\newline      lj_str_pushf(cp-&gtL, &quot%s%s&quot, strdata(str), strdata(cp-&gtstr));\newline      cp-&gtL-&gttop--;\newline      str = strV(cp-&gtL-&gttop);\newline    }\newline    decl-&gtredir = str;\newline  }\newline  cp_check(cp, &#039)&#039);\newline}\newline",Parse GCC asm(&quotname&quot) redirect. \newline,813029,webkitdownload.cpp,"WebKitNetworkResponse* webkit_download_get_network_response(WebKitDownload* download)\newline{\newline    g_return_val_if_fail(WEBKIT_IS_DOWNLOAD(download), NULL);\newline\newline    WebKitDownloadPrivate* priv = download-&gtpriv;\newline    return priv-&gtnetworkResponse;\newline}\newline",\newline webkit_download_get_network_response:\newline @download: the #WebKitDownload\newline \newline Retrieves the #WebKitNetworkResponse object that backs the download\newline process.\newline \newline Returns: (transfer none): the #WebKitNetworkResponse instance\newline \newline Since: 1.1.16\newline \newline,3839431,apcsmart.c,"static int sdcmd_Z(const void *foo)\newline{\newline	int ret;\newline\newline	debx(1, &quotissuing [%s]&quot, prtchr(APC_CMD_OFF));\newline\newline	apc_flush(0);\newline	ret = apc_write_rep(APC_CMD_OFF);\newline	if (ret != 2) {\newline		return STAT_INSTCMD_FAILED;\newline	}\newline\newline	/* note: ups will not reply anything after this command */\newline	return sdok(1);\newline}\newline",shutdown: Z - immediate poweroff \newline,4218035,pr2_cmds.c,"void PF2_nextent(byte* base, unsigned int mask, pr2val_t* stack, pr2val_t*retval)\newline{\newline	int		i;\newline	edict_t	*ent;\newline\newline	i = stack[0]._int;\newline	while (1)\newline	{\newline		i++;\newline		if (i &gt= sv.num_edicts)\newline		{\newline			retval-&gt_int = 0;\newline			return;\newline		}\newline		ent = EDICT_NUM(i);\newline		if (!ent-&gte-&gtfree)\newline		{\newline			retval-&gt_int = i;\newline			return;\newline		}\newline	}\newline}\newline",\newline=============\newlinePF2_nextent\newline\newlineentity nextent(entity)\newline=============\newline \newline,147812,memarray.c,"static int Lrealloc(lua_State * L)\newline{\newline   memarray_t *m;\newline   const char *typename;\newline   int type;\newline   size_t length;\newline   size_t size;\newline   void * data;\newline   char errmsg[128];\newline\newline   m = memarray_get(L, 1);\newline   typename = luaL_optstring(L, 2, &quotuchar&quot);\newline\newline   if ( (type = get_memtype(typename)) &lt 0 ) {\newline      luaL_error(L, &quotmemarray:realloc(): unknown type &#039%s&#039&quot, typename);\newline      return 0;\newline   }\newline\newline   length  = (size_t) luaL_optnumber(L, 3, 0);\newline   size = length * m_types[type].size;\newline\newline   if (lua_gettop(L) &gt 3) {\newline      /* do not allocate memory, inherit something else */\newline      memarray_delete(m);\newline      m-&gtsize    = size;\newline      m-&gtlength  = length;\newline      m-&gtflags   = type | MEMARRAY_INHERITED;\newline      m-&gtdata    = lua_touserdata(L, 4);\newline   } else {\newline      /* allocate memory */\newline      memarray_delete(m);\newline      data = (void *) malloc(size);\newline      if ((size != 0) &amp&amp (data == NULL)) {\newline         m-&gtflags = type | MEMARRAY_INHERITED;\newline         sprintf(errmsg, &quotmemarray:__call(): memory allocation failure &quot\newline            &quotfor %zd bytes (%s x %zd)\\n&quot, size, typename, length);\newline         luaL_error(L, errmsg);\newline      } else {\newline         m-&gtflags   = type;\newline         m-&gtsize    = size;\newline         m-&gtlength  = length;\newline         m-&gtdata    = data;\newline      }\newline   }\newline   lua_settop(L, 1);\newline   return 1;\newline}\newline","self, &#039type&#039, n, [address] \newline",3064994,msg-extravars.h,"inline void set_wind_speed_var(const wreport::Var&amp val)  { set(val, WR_VAR(0, 11, 2), Level(103, 10000, MISSING_INT, MISSING_INT), Trange(254, 0, 0)); }\newline",Set the value of &quotWind speed at 10 metres above ground&quot from a wreport::Var \newline,1085205,slice_xvmc.c,"static void motion_fr_conceal (picture_t * picture)\newline{\newline#define bit_buf (picture-&gtbitstream_buf)\newline#define bits (picture-&gtbitstream_bits)\newline#define bit_ptr (picture-&gtbitstream_ptr)\newline    int tmp;\newline\newline    NEEDBITS (bit_buf, bits, bit_ptr);\newline    tmp = (picture-&gtf_motion.pmv[0][0] +\newline	   get_xvmc_motion_delta (picture, picture-&gtf_motion.f_code[0]));\newline    tmp = bound_motion_vector (tmp, picture-&gtf_motion.f_code[0]);\newline    picture-&gtf_motion.pmv[1][0] = picture-&gtf_motion.pmv[0][0] = tmp;\newline\newline    NEEDBITS (bit_buf, bits, bit_ptr);\newline    tmp = (picture-&gtf_motion.pmv[0][1] +\newline	   get_xvmc_motion_delta (picture, picture-&gtf_motion.f_code[1]));\newline    tmp = bound_motion_vector (tmp, picture-&gtf_motion.f_code[1]);\newline    picture-&gtf_motion.pmv[1][1] = picture-&gtf_motion.pmv[0][1] = tmp;\newline\newline    DUMPBITS (bit_buf, bits, 1); /* remove marker_bit */\newline#undef bit_buf\newline#undef bits\newline#undef bit_ptr\newline}\newline","like motion_frame, but parsing without actual motion compensation \newline",1532093,nnpi.c,"nnpi* nnpi_create(delaunay* d)\newline{\newline    nnpi* nn = malloc(sizeof(nnpi));\newline\newline    nn-&gtd = d;\newline    nn-&gtwmin = -DBL_MAX;\newline    nn-&gtn = 0;\newline    nn-&gtncircles = 0;\newline    nn-&gtvertices = calloc(NSTART, sizeof(int));\newline    nn-&gtweights = calloc(NSTART, sizeof(double));\newline    nn-&gtnvertices = 0;\newline    nn-&gtnallocated = NSTART;\newline    nn-&gtbad = NULL;\newline\newline    return nn;\newline}\newline",Creates Natural Neighbours point interpolator.\newline \newline @param d Delaunay triangulation\newline @return Natural Neighbours interpolation\newline \newline,4705709,p256_ec.c,"void p256_base_point_mul(const p256_int* n, p256_int* out_x, p256_int* out_y) {\newline  felem x, y, z;\newline\newline  scalar_base_mult(x, y, z, n);\newline\newline  {\newline    felem x_affine, y_affine;\newline\newline    point_to_affine(x_affine, y_affine, x, y, z);\newline    from_montgomery(out_x, x_affine);\newline    from_montgomery(out_y, y_affine);\newline  }\newline}\newline","p256_base_point_mul sets {out_x,out_y} = nG, where n is &lt the\newline order of the group. \newline",6100203,xqueue.c,"static gboolean read_events(gboolean block)\newline{\newline    gint sth, n;\newline\newline    n = XEventsQueued(obt_display, QueuedAfterFlush) &gt 0;\newline    sth = FALSE;\newline\newline    while ((block &amp&amp !sth) || n &gt 0) {\newline        XEvent e;\newline\newline        if (XNextEvent(obt_display, &ampe) != Success)\newline            return FALSE;\newline\newline        grow(); /* make sure there is room */\newline\newline        ++qnum;\newline        qend = (qend + 1) % qsz; /* move the end */\newline        q[qend] = e; /* stick the event at the end */\newline\newline        --n;\newline        sth = TRUE;\newline    }\newline\newline    return sth; /* return if we read anything */\newline}\newline",Grab all pending X events \newline,3592397,agenda.cpp,"AgendaItem::QPtr Agenda::insertItem(const KCalCore::Incidence::Ptr &ampincidence, const KDateTime &amprecurrenceId,\newline                                    int X, int YTop, int YBottom, int itemPos, int itemCount,\newline                                    bool isSelected)\newline{\newline    if (d-&gtmAllDayMode) {\newline        qCDebug(CALENDARVIEW_LOG) &lt&lt &quotusing this in all-day mode is illegal.&quot;\newline        return Q_NULLPTR;\newline    }\newline\newline    d-&gtmActionType = NOP;\newline\newline    AgendaItem::QPtr agendaItem = createAgendaItem(incidence, itemPos, itemCount, recurrenceId, isSelected);\newline    if (!agendaItem) {\newline        return AgendaItem::QPtr();\newline    }\newline\newline    if (YBottom &lt= YTop) {\newline        qCDebug(CALENDARVIEW_LOG) &lt&lt &quotText:&quot &lt&lt agendaItem-&gttext() &lt&lt &quot YSize&lt0&quot;\newline        YBottom = YTop;\newline    }\newline\newline    agendaItem-&gtresize(int((X + 1) * d-&gtmGridSpacingX) -\newline                       int(X * d-&gtmGridSpacingX),\newline                       int(YTop * d-&gtmGridSpacingY) -\newline                       int((YBottom + 1) * d-&gtmGridSpacingY));\newline    agendaItem-&gtsetCellXY(X, YTop, YBottom);\newline    agendaItem-&gtsetCellXRight(X);\newline    agendaItem-&gtsetResourceColor(d-&gtmCalendar-&gtresourceColor(incidence));\newline    agendaItem-&gtinstallEventFilter(this);\newline\newline    agendaItem-&gtmove(int(X * d-&gtmGridSpacingX), int(YTop * d-&gtmGridSpacingY));\newline\newline    d-&gtmItems.append(agendaItem);\newline\newline    placeSubCells(agendaItem);\newline\newline    agendaItem-&gtshow();\newline\newline    marcus_bains();\newline\newline    return agendaItem;\newline}\newline",\newlineInsert AgendaItem into agenda.\newline \newline,240308,rediff.c,"static int rediff (const char *original, const char *edited, FILE *out)\newline{\newline	pid_t child;\newline	FILE *o;\newline	FILE *m;\newline	FILE *t = NULL;\newline	char *line = NULL;\newline	size_t linelen = 0;\newline	unsigned long linenum = 0;\newline	struct hunk *hunks = NULL, **p = &amphunks, *last = NULL;\newline	struct hunk *current_hunk = NULL;\newline	long line_offset = 0;\newline\newline	/* Let&#039s take a look at what hunks are in the original diff. */\newline	o = xopen (original, &quotrbm&quot);\newline	while (!feof (o)) {\newline		unsigned long o_count, n_count;\newline		struct hunk *newhunk;\newline		fpos_t pos;\newline\newline		/* Search for start of hunk (or file info). */\newline		do {\newline			fgetpos (o, &amppos);\newline			if (getline (&ampline, &amplinelen, o) == -1)\newline				break;\newline			linenum++;\newline\newline			if (!strncmp (line, &quot*** &quot, 4))\newline				error (EXIT_FAILURE, errno,\newline				       &quotDon&#039t know how to handle context &quot\newline				       &quotformat yet.&quot);\newline		} while (strncmp (line, &quot@@ &quot, 3) &amp&amp\newline			 strncmp (line, &quot--- &quot, 4));\newline\newline		if (feof (o))\newline			break;\newline\newline		if (last)\newline			last-&gtnum_lines = linenum - last-&gtline_in_diff + 1;\newline\newline		newhunk = xmalloc (sizeof *newhunk);\newline		newhunk-&gtfilepos = pos;\newline		newhunk-&gtline_in_diff = linenum;\newline		newhunk-&gtnum_lines = 0;\newline\newline		if (!strncmp (line, &quot--- &quot, 4)) {\newline			struct file_info *info = xmalloc (sizeof *info);\newline			info-&gtinfo_written = info-&gtinfo_pending = 0;\newline			info-&gtorig_file = xstrdup (line);\newline			if (getline (&ampline, &amplinelen, o) == -1)\newline				error (EXIT_FAILURE, errno,\newline				       &quotPremature end of file&quot);\newline			info-&gtnew_file = xstrdup (line);\newline			newhunk-&gtinfo = info;\newline			if (getline (&ampline, &amplinelen, o) == -1)\newline				error (EXIT_FAILURE, errno,\newline				       &quotPremature end of file&quot);\newline			linenum += 2;\newline		} else newhunk-&gtinfo = NULL;\newline\newline		read_atatline (line, &ampnewhunk-&gtorig_offset,\newline			       &ampnewhunk-&gtorig_count,\newline			       &ampnewhunk-&gtnew_offset,\newline			       &ampnewhunk-&gtnew_count);\newline		o_count = newhunk-&gtorig_count;\newline		n_count = newhunk-&gtnew_count;\newline\newline		newhunk-&gtnext = NULL;\newline		if (*p)\newline			(*p)-&gtnext = newhunk;\newline		*p = last = newhunk;\newline		p = &ampnewhunk-&gtnext;\newline\newline#ifdef DEBUG\newline		if (newhunk-&gtinfo)\newline			fprintf (stderr, &quotThis is the first of a group\\n&quot);\newline		fprintf (stderr, &quotOriginal hunk at line %lu: &quot\newline			 &quot-%lu,%lu +%lu,%lu\\n&quot, newhunk-&gtline_in_diff,\newline			 newhunk-&gtorig_offset, newhunk-&gtorig_count,\newline			 newhunk-&gtnew_offset, newhunk-&gtnew_count);\newline#endif /* DEBUG */\newline\newline		/* Skip to next hunk. */\newline		while (o_count || n_count) {\newline			if (getline (&ampline, &amplinelen, o) == -1)\newline				break;\newline\newline			linenum++;\newline			switch (line[0]) {\newline			case &#039 &#039:\newline				if (n_count) n_count--;\newline			case &#039-&#039:\newline				if (o_count) o_count--;\newline				break;\newline			case &#039+&#039:\newline				if (n_count) n_count--;\newline				break;\newline			}\newline		}\newline	}\newline\newline	if (!hunks)\newline		error (EXIT_FAILURE, 0, &quotOriginal patch seems empty&quot);\newline\newline	last-&gtnum_lines = linenum - last-&gtline_in_diff + 1;\newline\newline	/* Run diff between original and edited. */\newline	t = xpipe (DIFF, &ampchild, &quotr&quot, DIFF, &quot-U0&quot,\newline		   original, edited, NULL);\newline	m = xtmpfile ();\newline	if (m) {\newline		size_t buffer_size = 10000;\newline		char *buffer = xmalloc (buffer_size);\newline		while (!feof (t)) {\newline			size_t got = fread (buffer, 1, buffer_size, t);\newline			fwrite (buffer, 1, got, m);\newline		}\newline		fclose (t);\newline		waitpid (child, NULL, 0);\newline		rewind (m);\newline		free (buffer);\newline	} else error (EXIT_FAILURE, errno, &quotCouldn&#039t create temporary file&quot);\newline\newline	/* For each hunk in m, identify which hunk in o has been\newline	 * touched.  Display unmodified hunks before that one\newline	 * (adjusting offsets), then step through the touched hunk\newline	 * applying changes as necessary. */\newline	*line = &#039\\0&#039;\newline	while (!feof (m)) {\newline		unsigned long orig_line;\newline		unsigned long orig_count;\newline		struct hunk *which;\newline		fpos_t pos;\newline\newline		while (strncmp (line, &quot@@ &quot, 3)) {\newline			fgetpos (m, &amppos);\newline			if (getline (&ampline, &amplinelen, m) == -1)\newline				break;\newline		}\newline	\newline		if (feof (m))\newline			break;\newline\newline		read_atatline (line, &amporig_line, &amporig_count, NULL, NULL);\newline		if (!orig_count)\newline			orig_line++;\newline\newline		/* Find out which hunk that is. */\newline		for (which = hunks; which; which = which-&gtnext) {\newline			int header;\newline\newline			if (!which-&gtnext) {\newline				/* Last one; this must be it. */\newline				break;\newline			}\newline\newline			header = which-&gtnext-&gtinfo ? 2 : 0;\newline			if (which-&gtnext-&gtline_in_diff + header &gt orig_line)\newline				/* Next one is past that point. */\newline				break;\newline		}\newline		assert (which);\newline\newline		if (which-&gtline_in_diff + which-&gtnum_lines &lt= orig_line)\newline			which-&gtdiscard_offset = 1;\newline\newline#ifdef DEBUG\newline		fprintf (stderr, &quotModified hunk starts on line %lu\\n&quot,\newline			 which-&gtline_in_diff);\newline		if (which-&gtdiscard_offset)\newline			fprintf (stderr, &quot(But discarding offset)\\n&quot);\newline#endif /* DEBUG */\newline\newline		/* If this is modifying a new hunk, we need to write\newline		 * out what we had and all the intervening hunks,\newline		 * adjusting offsets as we go. */\newline		if (current_hunk != which) {\newline			if (current_hunk) {\newline				line_offset += show_modified_hunk\newline					(&ampcurrent_hunk, line_offset,\newline					 t, o, out);\newline				current_hunk = current_hunk-&gtnext;\newline			}\newline\newline			/* Copy hunks, adjusting offsets. */\newline			copy_to (current_hunk ? current_hunk : hunks,\newline				 which, &ampline_offset, o, out,\newline				 current_hunk == NULL);\newline\newline			/* This meta hunk is the first pertaining to\newline			 * the hunk in the original. */\newline			t = xtmpfile ();\newline		}\newline\newline		current_hunk = which;\newline\newline		/* Append the meta hunk to a temporary file. */\newline		fputs (line, t);\newline		while (!feof (m)) {\newline			if (getline (&ampline, &amplinelen, m) == -1)\newline				break;\newline			if (!strncmp (line, &quot@@ &quot, 3))\newline				break;\newline			fputs (line, t);\newline		}\newline	}\newline\newline	/* Now display the remaining hunks, adjusting offsets. */\newline	if (current_hunk) {\newline		line_offset += show_modified_hunk (&ampcurrent_hunk, line_offset,\newline						   t, o, out);\newline		current_hunk = current_hunk-&gtnext;\newline		if (current_hunk)\newline			copy_to (current_hunk, NULL, &ampline_offset, o, out, 0);\newline	} else\newline		copy_to (hunks, NULL, &ampline_offset, o, out, 1);\newline\newline	fclose (o);\newline	fclose (m);\newline	if (line)\newline		free (line);\newline\newline	return 0;\newline}\newline",Write a corrected version of the edited diff to standard output.\newline \newline This works by comparing the modified lines in the edited diff with\newline the hunks in the original diff. \newline,5980867,op_setzpiece.c,"void op_setzpiece(mval *src, mval *del, mval *expr, int4 first, int4 last, mval *dst)\newline{\newline	size_t		str_len, delim_cnt;\newline	int 		match_res, len, src_len, first_src_ind, second_src_ind, numpcs;\newline	unsigned char 	*match_ptr, *src_str, *str_addr, *tmp_str;\newline	delimfmt	unichar;\newline\newline	if (0 &gt --first)\newline		first = 0;\newline	assert(last &gt= first);\newline	second_src_ind = last - first;\newline	MV_FORCE_STR(del);\newline	/* Null delimiter */\newline	if (0 == del-&gtstr.len)\newline	{\newline		if (first &amp&amp src-&gtmvtype)\newline		{\newline			/* concat src &amp expr to dst */\newline			op_cat(VARLSTCNT(3) dst, src, expr);\newline			return;\newline		}\newline		MV_FORCE_STR(expr);\newline		*dst = *expr;\newline		return;\newline	}\newline	MV_FORCE_STR(expr);\newline	if (!MV_DEFINED(src))\newline	{\newline		first_src_ind = 0;\newline		second_src_ind = -1;\newline	} else\newline	{\newline		/* Valid delimiter -  See if we can take a short cut to op_fnzp1. If so, delimiter value needs to be reformated */\newline		if ((1 == second_src_ind) &amp&amp (1 == del-&gtstr.len))\newline		{	/* Count of pieces to retrieve is 1 so see what we can do quickly */\newline			unichar.unichar_val = 0;\newline			unichar.unibytes_val[0] = *del-&gtstr.addr;\newline			op_setzp1(src, unichar.unichar_val, expr, last, dst);	/* Use &quotlast&quot since it has not been modified */\newline			return;\newline		}\newline		/* We have a valid src with something in it */\newline		MV_FORCE_STR(src);\newline		src_str = (unsigned char *)src-&gtstr.addr;\newline		src_len = src-&gtstr.len;\newline		/* skip all pieces until start one */\newline		if (first)\newline		{\newline			numpcs = first;	/* copy int4 type &quotfirst&quot into &quotint&quot type numpcs for passing to matchc */\newline			match_ptr = matchb(del-&gtstr.len, (uchar_ptr_t)del-&gtstr.addr, src_len, src_str, &ampmatch_res, &ampnumpcs);\newline			/* Note: &quotnumpcs&quot is modified above by the function &quotmatchb&quot to reflect the # of unmatched pieces */\newline			first = numpcs;	/* copy updated &quotnumpcs&quot value back into &quotfirst&quot */\newline		} else\newline		{\newline			match_ptr = src_str;\newline			match_res = 1;\newline		}\newline		first_src_ind = INTCAST(match_ptr - (unsigned char *)src-&gtstr.addr);\newline		if (0 == match_res) /* if match not found */\newline			second_src_ind = -1;\newline		else\newline		{\newline			src_len -= INTCAST(match_ptr - src_str);\newline			src_str = match_ptr;\newline			/* skip # delimiters this piece will replace, e.g. if we are setting\newline			 * pieces 2 - 4, then the pieces 2-4 will be replaced by one piece - expr.\newline			 */\newline			match_ptr = matchb(del-&gtstr.len, (uchar_ptr_t)del-&gtstr.addr, src_len, src_str, &ampmatch_res, &ampsecond_src_ind);\newline			second_src_ind = (0 == match_res) ? -1 : INTCAST(match_ptr - (unsigned char *)src-&gtstr.addr - del-&gtstr.len);\newline		}\newline	}\newline	delim_cnt = (size_t)first;\newline	/* Calculate total string len. */\newline	str_len = (size_t)expr-&gtstr.len + ((size_t)first_src_ind + ((size_t)del-&gtstr.len * delim_cnt));\newline	/* add len. of trailing chars past insertion point */\newline	if (0 &lt= second_src_ind)\newline		str_len += (size_t)(src-&gtstr.len - second_src_ind);\newline	if (MAX_STRLEN &lt str_len)\newline	{\newline		rts_error_csa(CSA_ARG(NULL) VARLSTCNT(1) ERR_MAXSTRLEN);\newline		return;\newline	}\newline	ENSURE_STP_FREE_SPACE((int)str_len);\newline	str_addr = stringpool.free;\newline	/* copy prefix */\newline	if (first_src_ind)\newline	{\newline		memcpy(str_addr, src-&gtstr.addr, first_src_ind);\newline		str_addr += first_src_ind;\newline	}\newline	/* copy delimiters */\newline	while (0 &lt delim_cnt--)\newline	{\newline		memcpy(str_addr, del-&gtstr.addr, del-&gtstr.len);\newline		str_addr += del-&gtstr.len;\newline	}\newline	/* copy expression */\newline	memcpy(str_addr, expr-&gtstr.addr, expr-&gtstr.len);\newline	str_addr += expr-&gtstr.len;\newline	/* copy trailing pieces */\newline	if (0 &lt= second_src_ind)\newline	{\newline		len = src-&gtstr.len - second_src_ind;\newline		tmp_str = (unsigned char *)src-&gtstr.addr + second_src_ind;\newline		memcpy(str_addr, tmp_str, len);\newline		str_addr += len;\newline	}\newline	assert(IS_AT_END_OF_STRINGPOOL(str_addr, -str_len));\newline	dst-&gtmvtype = MV_STR;\newline	dst-&gtstr.len = INTCAST(str_addr - stringpool.free);\newline	dst-&gtstr.addr = (char *)stringpool.free;\newline	stringpool.free = str_addr;\newline	return;\newline}\newline",\newline ----------------------------------------------------------\newline Set $zpiece procedure.\newline Set pieces first through last to expr.\newline \newline Arguments:\newline src - source mval\newline del - delimiter string mval\newline expr - expression string mval\newline first - starting index in source mval to be set\newline last - last index\newline dst - destination mval where the result is saved.\newline \newline Return:\newline none\newline ----------------------------------------------------------\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4913063,memberof.c,"void memberof_load_array(Slapi_Value **array, Slapi_Attr *attr)\newline{\newline	Slapi_Value *val = 0;\newline	int hint = slapi_attr_first_value(attr, &ampval);\newline\newline	while(val)\newline	{\newline		*array = val;\newline		array++;\newline		hint = slapi_attr_next_value(attr, hint, &ampval);\newline	}\newline}\newline",memberof_load_array()\newline \newline put attribute values in array structure\newline \newline,675943,constituents.c,"static int gen_comp(con_context_t *ctxt, Linkage linkage,\newline                    int numcon_total, int numcon_subl,\newline					     const char * ctype1, const char * ctype2,\newline                    const char * ctype3, case_type x)\newline{\newline	size_t w, w2, w3;\newline	int c, c1, c2;\newline	bool done;\newline	c = numcon_total + numcon_subl;\newline\newline	for (c1=numcon_total; c1&ltnumcon_total + numcon_subl; c1++)\newline	{\newline		/* If ctype1 is NP, it has to be an appositive to continue */\newline		if ((x==CASE_APPOS) &amp&amp (post_process_match(&quotMX#*&quot, ctxt-&gtconstituent[c1].start_link)==0))\newline			continue;\newline\newline#ifdef REVIVE_DEAD_CODE\newline		/* If ctype1 is X, and domain_type is t, it&#039s an infinitive - skip it */\newline		if ((x==CASE_UNUSED) &amp&amp (ctxt-&gtconstituent[c1].domain_type==&#039t&#039))\newline			continue;\newline#endif /* REVIVE_DEAD_CODE */\newline\newline		/* If it&#039s domain-type z, it&#039s a subject-relative clause;\newline		   the VP doesn&#039t need an NP */\newline		if (ctxt-&gtconstituent[c1].domain_type==&#039z&#039)\newline			continue;\newline\newline		/* If ctype1 is X or VP, and it&#039s not started by an S, don&#039t generate an NP\newline		 (Neither of the two previous checks are necessary now, right?) */\newline#ifdef REVIVE_DEAD_CODE\newline		/* use this ... if ((x==CASE_S || x==CASE_UNUSED) &amp&amp */\newline#endif /* REVIVE_DEAD_CODE */\newline		if ((x==CASE_S) &amp&amp\newline			(((post_process_match(&quotS&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			  (post_process_match(&quotSX&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			  (post_process_match(&quotSF&quot, ctxt-&gtconstituent[c1].start_link) == 0)) ||\newline			 (post_process_match(&quotS##w&quot, ctxt-&gtconstituent[c1].start_link) != 0)))\newline			continue;\newline\newline		/* If it&#039s an SBAR (relative clause case), it has to be a relative clause */\newline		if ((x==CASE_REL_CLAUSE) &amp&amp\newline			((post_process_match(&quotRn&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			 (post_process_match(&quotR*&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			 (post_process_match(&quotMX#r&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			 (post_process_match(&quotMr&quot, ctxt-&gtconstituent[c1].start_link) == 0) &amp&amp\newline			 (post_process_match(&quotMX#d&quot, ctxt-&gtconstituent[c1].start_link) == 0)))\newline			continue;\newline\newline		/* If ctype1 is SBAR (clause opener case), it has to be an f domain */\newline		if ((x==CASE_OPENER) &amp&amp (ctxt-&gtconstituent[c1].domain_type!=&#039f&#039))\newline			continue;\newline\newline		/* If ctype1 is SBAR (pp opener case), it has to be a g domain */\newline		if ((x==CASE_PPOPEN) &amp&amp (ctxt-&gtconstituent[c1].domain_type!=&#039g&#039))\newline			continue;\newline\newline		/* If ctype1 is NP (paraphrase case), it has to be started by an SI */\newline		if ((x==CASE_SVINV) &amp&amp (post_process_match(&quotSI&quot, ctxt-&gtconstituent[c1].start_link)==0))\newline			continue;\newline\newline		/* If ctype1 is VP (participle modifier case), it has to be\newline		   started by an Mv or Mg */\newline		if ((x==CASE_PART_MOD) &amp&amp (post_process_match(&quotM&quot, ctxt-&gtconstituent[c1].start_link)==0))\newline			continue;\newline\newline		/* If ctype1 is VP (participle opener case), it has\newline		   to be started by a COp */\newline		if ((x==CASE_PART_OPEN) &amp&amp (post_process_match(&quotCOp&quot, ctxt-&gtconstituent[c1].start_link)==0))\newline			continue;\newline\newline		/* Now start at the bounds of c1, and work outwards until you\newline		   find a larger constituent of type ctype2 */\newline		if (!(strcmp(ctxt-&gtconstituent[c1].type, ctype1)==0))\newline			continue;\newline\newline		if (verbosity_level(D_CONST))\newline			err_msg(lg_Debug, &quotGenerating complement constituent for c %d of type %s\\n&quot,\newline				   c1, ctype1);\newline		done = false;\newline		for (w2 = ctxt-&gtconstituent[c1].left; (done == false) &amp&amp (w2 != (size_t)-1); w2--)\newline		{\newline			for (w3 = ctxt-&gtconstituent[c1].right; w3&ltlinkage-&gtnum_words; w3++)\newline			{\newline				for (c2 = numcon_total; (done == false) &amp&amp\newline						 (c2 &lt numcon_total + numcon_subl); c2++) {\newline					if (!((ctxt-&gtconstituent[c2].left == w2) &amp&amp\newline						  (ctxt-&gtconstituent[c2].right == w3)) || (c2==c1))\newline						continue;\newline					if (!(strcmp(ctxt-&gtconstituent[c2].type, ctype2)==0))\newline						continue;\newline\newline					/* if the new constituent (c) is to the left\newline					   of c1, its right edge should be adjacent to the\newline					   left edge of c1 - or as close as possible. */\newline					if ((x==CASE_OPENER) || (x==CASE_PPOPEN) || (x==CASE_PART_OPEN))\newline					{\newline								/* This is the case where c is to the\newline								   RIGHT of c1 */\newline						w = ctxt-&gtconstituent[c1].right + 1;\newline						if (w &gt ctxt-&gtconstituent[c2].right)\newline						{\newline							done = true;\newline							continue;\newline						}\newline						ctxt-&gtconstituent[c].left = w;\newline						ctxt-&gtconstituent[c].right = ctxt-&gtconstituent[c2].right;\newline					}\newline					else\newline					{\newline						w = ctxt-&gtconstituent[c1].left - 1;\newline						if (w &lt ctxt-&gtconstituent[c2].left) {\newline							done = true;\newline							continue;\newline						}\newline						ctxt-&gtconstituent[c].right = w;\newline						ctxt-&gtconstituent[c].left = ctxt-&gtconstituent[c2].left;\newline					}\newline\newline					adjust_for_left_comma(ctxt, linkage, c1);\newline					adjust_for_right_comma(ctxt, linkage, c1);\newline\newline					ctxt-&gtconstituent[c].type =\newline						string_set_add(ctype3, ctxt-&gtphrase_ss);\newline					ctxt-&gtconstituent[c].domain_type = &#039x&#039;\newline					ctxt-&gtconstituent[c].start_link =\newline						string_set_add(&quotXX&quot, ctxt-&gtphrase_ss);\newline					if (verbosity_level(D_CONST))\newline					{\newline						err_msg(lg_Debug, &quotLarger c found: c %d (%s); &quot, c2, ctype2);\newline						err_msg(lg_Debug, &quotAdding constituent:\\n\\\\&quot);\newline						print_constituent(ctxt, linkage, c);\newline					}\newline					c++;\newline					assert (c &lt ctxt-&gtconlen, &quotToo many constituents&quot);\newline					done = true;\newline				}\newline			}\newline		}\newline		if (verbosity_level(D_CONST))\newline		{\newline			if (done == false)\newline				err_msg(lg_Debug, &quotNo constituent added, because no larger %s&quot \\\newline					   &quot was found\\n&quot, ctype2);\newline		}\newline	}\newline	numcon_subl = c - numcon_total;\newline	return numcon_subl;\newline}\newline","\newline This function looks for constituents of type ctype1. Say it finds\newline one, call it c1. It searches for the next larger constituent of\newline type ctype2, call it c2. It then generates a new constituent of\newline ctype3, containing all the words in c2 but not c1.\newline \newline",2959306,edge_inline.h,inline void Edge::setElement( QDomElement elem)\newline{\newline    element = elem;\newline}\newline,\newline Set document element\newline \newline,,,,,on,,,,on,,,,,,,,,on,on,on,on,,,,,,,,,,,,,,,,,,,,,,"On successful completion, fill in the Stats structure pointed to by sp.","Set the value of ""Wind speed at 10 metres above ground""",parsing without actual motion compensation,Creates Natural Neighbours point interpolator.,{},Grab all pending X events,Insert AgendaItem into agenda.,Write a corrected version of the edited diff to standard output.,{},Load an image from the named file.,put attribute values in array structure,This appends windows that are not to be managed,This function looks for constituents of type ctype1.,Set document element,Number of leading zeros.,Returns the current debug functionality flags.,"Parse GCC asm(""name"") redirect.",{},{},{},{},x,
3OCZWXS7ZO7JHTF9AXIM5EF0T465LA,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:30 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:30 PDT 2019,,,3WOKGM4L71GUFRTYGLX35JJSPWGO0P,AITP2LUW8GPB,Submitted,Fri Apr 26 13:13:01 PDT 2019,Fri Apr 26 13:42:24 PDT 2019,Sun Apr 28 13:42:24 PDT 2019,,,,1763,100% (62/62),100% (62/62),0% (0/0),1581566,formhull.cpp,"void CFormHull::slotDef()\newline{\newline    CHullDef defcopy = def;\newline\newline    if ( CFormHullDef(this, &ampdefcopy).exec() )\newline    {\newline        // we returned from the dialog with an &#039OK&#039,\newline        setDef(defcopy);\newline    }\newline}\newline",\newline Displays the sail CFormHullDef sail definition dialog.\newline \newline,3615780,prefs.c,"static void table_free()\newline{\newline	g_hash_table_foreach_remove(prefs, table_free_entry, NULL);\newline	g_hash_table_destroy(prefs);\newline	prefs = NULL;\newline}\newline",\newline Frees the prefs table and all the entries it contains.\newline \newline,512038,patch_set_and_get.c,"int patch_set_legato(int patch_id, bool val)\newline{\newline    assert(patchok(patch_id));\newline    patches[patch_id]-&gtlegato.active = val;\newline    return 0;\newline}\newline",set whether this patch should be played legato or not \newline,5792613,libfat.c,int utf8_strlen(char *s) {\newline    int i = 0;\newline    int cur = 0;\newline//    int res;\newline    \newline    for (;;) {\newline		if (s[cur] == 0) {\newline		    break;	// null terminator encountered\newline		} else {\newline			i++;\newline			cur += unicode_utf8_len(s[cur]) ;	// incrementing the cursor of character size\newline		}\newline    }\newline    return i;\newline} \newline,return the length in characters of an utf8 null-terminated string excluding null terminator \newline,2936254,allchblk.c,"struct hblk * GC_get_first_part(struct hblk *h, hdr *hhdr,\newline			        size_t bytes, int index)\newline{\newline    word total_size = hhdr -&gt hb_sz;\newline    struct hblk * rest;\newline    hdr * rest_hdr;\newline\newline    GC_ASSERT((total_size &amp (HBLKSIZE-1)) == 0);\newline    GC_remove_from_fl(hhdr, index);\newline    if (total_size == bytes) return h;\newline    rest = (struct hblk *)((word)h + bytes);\newline    rest_hdr = GC_install_header(rest);\newline    if (0 == rest_hdr) {\newline	/* FIXME: This is likely to be very bad news ... */\newline	WARN(&quotHeader allocation failed: Dropping block.\\n&quot, 0);\newline	return(0);\newline    }\newline    rest_hdr -&gt hb_sz = total_size - bytes;\newline    rest_hdr -&gt hb_flags = 0;\newline#   ifdef GC_ASSERTIONS\newline      /* Mark h not free, to avoid assertion about adjacent free blocks. */\newline        hhdr -&gt hb_flags &amp= ~FREE_BLK;\newline#   endif\newline    GC_add_to_fl(rest, rest_hdr);\newline    return h;\newline}\newline","\newline Return a pointer to a block starting at h of length bytes.\newline Memory for the block is mapped.\newline Remove the block from its free list, and return the remainder (if any)\newline to its appropriate free list.\newline May fail by returning 0.\newline The header for the returned block must be set up by the caller.\newline If the return value is not 0, then hhdr is the header for it.\newline \newline",3135256,4digits-text.c,"void compare(const int *in_digits, const int *ans_digits, int *a, int *b) {\newline    for(register int i=0 ; i&lt4; i++)\newline        for(register int j=0 ; j&lt4; j++)\newline            if(in_digits[i] == ans_digits[j])\newline                (i == j) ? (*a)++ : (*b)++;\newline}\newline","compare answer and input, refresh A &amp B \newline",6146260,rtpproxy_relay.c,"int rtp_relay_stop_fwd (osip_call_id_t *callid,\newline                        int rtp_direction,\newline                        int media_stream_no, int nolock) {\newline   int i, sts;\newline   int retsts=STS_SUCCESS;\newline   int got_match=0;\newline   osip_call_id_t cid;\newline \newline   if (callid == NULL) {\newline      ERROR(&quotrtp_relay_stop_fwd: callid is NULL!&quot);\newline      return STS_FAILURE;\newline   }\newline\newline   DEBUGC(DBCLASS_RTP,&quotrtp_relay_stop_fwd: stopping RTP proxy &quot\newline          &quotstream for: %s@%s (%s) (nolock=%i)&quot,\newline          callid-&gtnumber, callid-&gthost,\newline          ((rtp_direction == DIR_INCOMING) ? &quotincoming&quot : &quotoutgoing&quot),\newline          nolock);\newline\newline   /*\newline    * lock mutex - only if not requested to skip the lock.\newline    * this is needed as we are also called from within\newline    * the RTP thread itself - and there we already own the lock.\newline    */\newline   #define return is_forbidden_in_this_code_section\newline   if (nolock == 0) {\newline      pthread_mutex_lock(&amprtp_proxytable_mutex);\newline      /*\newline       * !! We now have a locked MUTEX! It is forbidden to return() from\newline       * !! here up to the end of this funtion where the MUTEX is\newline       * !! unlocked again.\newline       * !! Per design, a mutex is locked (for one purpose) at *exactly one*\newline       * !! place in the code and unlocked also at *exactly one* place.\newline       * !! this minimizes the risk of deadlocks.\newline       */\newline   }\newline   /* \newline   * wakeup/signal rtp_proxythread from select() hibernation.\newline   * This must be done here before we close the socket, otherwise\newline   * we may get an select() error later from the proxy thread that\newline   * is still hibernating in select() now.\newline   */\newline   if (!pthread_equal(rtpproxy_tid, pthread_self()))\newline      pthread_kill(rtpproxy_tid, SIGALRM);\newline\newline   /*\newline    * find the proper entry in rtp_proxytable\newline    * we need to loop the whole table, as there might be multiple\newline    * media streams active for the same callid (audio + video stream)\newline    * if media_stream_no == -1, all streams are stoppen, otherwise\newline    * if media_stream_no &gt 0 only the specified stream is stopped.\newline    */\newline   for (i=0; i&ltRTPPROXY_SIZE; i++) {\newline      cid.number = rtp_proxytable[i].callid_number;\newline      cid.host   = rtp_proxytable[i].callid_host;\newline      if (rtp_proxytable[i].rtp_rx_sock &amp&amp\newline         (compare_callid(callid, &ampcid) == STS_SUCCESS) &amp&amp\newline         (rtp_proxytable[i].direction == rtp_direction) &amp&amp\newline         ((media_stream_no &lt 0) ||\newline          (media_stream_no == rtp_proxytable[i].media_stream_no))) {\newline         /* close RTP sockets */\newline         sts = close(rtp_proxytable[i].rtp_rx_sock);\newline         DEBUGC(DBCLASS_RTP,&quotclosed socket %i for RTP stream &quot\newline                &quot%s:%s == %s:%s  (idx=%i) sts=%i&quot,\newline                rtp_proxytable[i].rtp_rx_sock,\newline                rtp_proxytable[i].callid_number,\newline                rtp_proxytable[i].callid_host,\newline                callid-&gtnumber, callid-&gthost, i, sts);\newline         if (sts &lt 0) {\newline            ERROR(&quotError in close(%i): %s nolock=%i %s:%s\\n&quot,\newline                  rtp_proxytable[i].rtp_rx_sock,\newline                  strerror(errno), nolock,\newline                  callid-&gtnumber, callid-&gthost);\newline         }\newline         /* call to firewall API (RTP port) */\newline         fwapi_stop_rtp(rtp_proxytable[i].direction,\newline                   rtp_proxytable[i].local_ipaddr,\newline                   rtp_proxytable[i].local_port,\newline                   rtp_proxytable[i].remote_ipaddr,\newline                   rtp_proxytable[i].remote_port);\newline         /* close RTCP socket */\newline         sts = close(rtp_proxytable[i].rtp_con_rx_sock);\newline         DEBUGC(DBCLASS_RTP,&quotclosed socket %i for RTCP stream sts=%i&quot,\newline                rtp_proxytable[i].rtp_con_rx_sock, sts);\newline         if (sts &lt 0) {\newline            ERROR(&quotError in close(%i): %s nolock=%i %s:%s\\n&quot,\newline                  rtp_proxytable[i].rtp_con_rx_sock,\newline                  strerror(errno), nolock,\newline                  callid-&gtnumber, callid-&gthost);\newline         }\newline         /* call to firewall API (RTCP port) */\newline         fwapi_stop_rtp(rtp_proxytable[i].direction,\newline                   rtp_proxytable[i].local_ipaddr,\newline                   rtp_proxytable[i].local_port + 1,\newline                   rtp_proxytable[i].remote_ipaddr,\newline                   rtp_proxytable[i].remote_port + 1);\newline         /* clean up */\newline         if (rtp_proxytable[i].opposite_entry) {\newline            rtp_proxytable[rtp_proxytable[i].opposite_entry-1].opposite_entry=0;\newline         }\newline         memset(&amprtp_proxytable[i], 0, sizeof(rtp_proxytable[0]));\newline         got_match=1;\newline      }\newline   }\newline\newline   /* did not find an active stream... */\newline   if (!got_match) {\newline      DEBUGC(DBCLASS_RTP,\newline             &quotrtp_relay_stop_fwd: can&#039t find active stream for %s@%s (%s)&quot,\newline             callid-&gtnumber, callid-&gthost,\newline             ((rtp_direction == DIR_INCOMING) ? &quotincoming RTP&quot : &quotoutgoing RTP&quot));\newline      retsts = STS_FAILURE;\newline      goto unlock_and_exit;\newline   }\newline\newline\newline   /* prepare FD set for next select operation */\newline   rtp_recreate_fdset();\newline   \newline\newlineunlock_and_exit:\newline   /*\newline    * unlock mutex - only if not requested to skip the lock.\newline    * this is needed as we are also called from within\newline    * the RTP thread itself - and there we already own the lock.\newline    */\newline   if (nolock == 0) {\newline      pthread_mutex_unlock(&amprtp_proxytable_mutex);\newline   }\newline   #undef return\newline\newline   return retsts;\newline}\newline","\newline stop a rtp stream on the proxy\newline \newline if media_stream_no == -1, all media streams will be stopped,\newline otherwise only the specified one.\newline \newline RETURNS\newline STS_SUCCESS on success\newline STS_FAILURE on error\newline \newline",1043354,tsm_screen.c,"static void link_to_scrollback(struct tsm_screen *con, struct line *line)\newline{\newline	struct line *tmp;\newline\newline	/* TODO: more sophisticated ageing */\newline	con-&gtage = con-&gtage_cnt;\newline\newline	if (con-&gtsb_max == 0) {\newline		if (con-&gtsel_active) {\newline			if (con-&gtsel_start.line == line) {\newline				con-&gtsel_start.line = NULL;\newline				con-&gtsel_start.y = SELECTION_TOP;\newline			}\newline			if (con-&gtsel_end.line == line) {\newline				con-&gtsel_end.line = NULL;\newline				con-&gtsel_end.y = SELECTION_TOP;\newline			}\newline		}\newline		line_free(line);\newline		return;\newline	}\newline\newline	/* Remove a line from the scrollback buffer if it reaches its maximum.\newline	 * We must take care to correctly keep the current position as the new\newline	 * line is linked in after we remove the top-most line here.\newline	 * sb_max == 0 is tested earlier so we can assume sb_max &gt 0 here. In\newline	 * other words, buf-&gtsb_first is a valid line if sb_count &gt= sb_max. */\newline	if (con-&gtsb_count &gt= con-&gtsb_max) {\newline		tmp = con-&gtsb_first;\newline		con-&gtsb_first = tmp-&gtnext;\newline		if (tmp-&gtnext)\newline			tmp-&gtnext-&gtprev = NULL;\newline		else\newline			con-&gtsb_last = NULL;\newline		--con-&gtsb_count;\newline\newline		/* (position == tmp &amp&amp !next) means we have sb_max=1 so set\newline		 * position to the new line. Otherwise, set to new first line.\newline		 * If position!=tmp and we have a fixed-position then nothing\newline		 * needs to be done because we can stay at the same line. If we\newline		 * have no fixed-position, we need to set the position to the\newline		 * next inserted line, which can be &quotline&quot, too. */\newline		if (con-&gtsb_pos) {\newline			if (con-&gtsb_pos == tmp ||\newline			    !(con-&gtflags &amp TSM_SCREEN_FIXED_POS)) {\newline				if (con-&gtsb_pos-&gtnext)\newline					con-&gtsb_pos = con-&gtsb_pos-&gtnext;\newline				else\newline					con-&gtsb_pos = line;\newline			}\newline		}\newline\newline		if (con-&gtsel_active) {\newline			if (con-&gtsel_start.line == tmp) {\newline				con-&gtsel_start.line = NULL;\newline				con-&gtsel_start.y = SELECTION_TOP;\newline			}\newline			if (con-&gtsel_end.line == tmp) {\newline				con-&gtsel_end.line = NULL;\newline				con-&gtsel_end.y = SELECTION_TOP;\newline			}\newline		}\newline		line_free(tmp);\newline	}\newline\newline	line-&gtsb_id = ++con-&gtsb_last_id;\newline	line-&gtnext = NULL;\newline	line-&gtprev = con-&gtsb_last;\newline	if (con-&gtsb_last)\newline		con-&gtsb_last-&gtnext = line;\newline	else\newline		con-&gtsb_first = line;\newline	con-&gtsb_last = line;\newline	++con-&gtsb_count;\newline}\newline",This links the given line into the scrollback-buffer \newline,514331,usbhw_lpc.c,"int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)\newline{\newline    U32 idx;\newline    \newline    idx = EP2IDX(bEP);\newline    \newline    // set write enable for specific endpoint\newline    USBCtrl = WR_EN | ((bEP &amp 0xF) &lt&lt 2);\newline    \newline    // set packet length\newline    USBTxPLen = iLen;\newline    \newline    // write data\newline    while (USBCtrl &amp WR_EN) {\newline        USBTxData = (pbBuf[3] &lt&lt 24) | (pbBuf[2] &lt&lt 16) | (pbBuf[1] &lt&lt 8) | pbBuf[0];\newline        pbBuf += 4;\newline    }\newline\newline    USBCtrl = 0;\newline\newline    // select endpoint and validate buffer\newline    USBHwCmd(CMD_EP_SELECT | idx);\newline    USBHwCmd(CMD_EP_VALIDATE_BUFFER);\newline    \newline    return iLen;\newline}\newline",\newlineWrites data to an endpoint buffer\newline\newline@param [in] bEP Endpoint number\newline@param [in] pbBuf Endpoint data\newline@param [in] iLen Number of bytes to write\newline\newline@return number of bytes written into the endpoint buffer\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2529936,smemstat.c,"static void smemstat_top_setup(void)\newline{\newline	initscr();\newline	cbreak();\newline	noecho();\newline	nodelay(stdscr, 1);\newline	keypad(stdscr, 1);\newline	curs_set(0);\newline}\newline",\newline smemstat_top_setup()\newline setup display for ncurses top mode\newline \newline,6442137,tickr_main.c,"static int get_visible_link_and_rank(int position_x_in_drwa)\newline{\newline	int	i, location_on_surface;\newline\newline	if (position_x_in_drwa &gt -1) {\newline		location_on_surface = shift_counter * prm-&gtshift_size + position_x_in_drwa;\newline		for (i = 0; i &lt NFEEDLINKANDOFFSETMAX; i++) {\newline			if (resrc-&gtlink_and_offset[i].offset_in_surface &gt location_on_surface) {\newline				str_n_cpy(env-&gtactive_link, resrc-&gtlink_and_offset[i].url, FILE_NAME_MAXLEN);\newline				return i;\newline			}\newline		}\newline	}\newline	env-&gtactive_link[0] = &#039\\0&#039;\newline	return -1;\newline}\newline","If link found, copy it into env-&gtactive_link and return rank (starting at 1),\newline otherwise, return -1 (with link = &quot&quot) \newline",4500152,sstrip.c,"static int modifyheaders_32(Elf32_Ehdr *ehdr, Elf32_Phdr *phdrs,\newline			    unsigned long newsize)\newline{\newline    Elf32_Phdr   *phdr;\newline    unsigned int  i;\newline\newline    /* If the section header table is gone, then remove all references\newline     * to it in the ELF header.\newline     */\newline    if (ehdr-&gte_shoff &gt= newsize) {\newline	ehdr-&gte_shoff = 0;\newline	ehdr-&gte_shnum = 0;\newline	ehdr-&gte_shentsize = 0;\newline	ehdr-&gte_shstrndx = 0;\newline    }\newline\newline    /* The program adjusts the file size of any segment that was\newline     * truncated. The case of a segment being completely stripped out\newline     * is handled separately.\newline     */\newline    for (i = 0, phdr = phdrs ; i &lt ehdr-&gte_phnum ; ++i, ++phdr) {\newline	if (phdr-&gtp_offset &gt= newsize) {\newline	    phdr-&gtp_offset = newsize;\newline	    phdr-&gtp_filesz = 0;\newline	} else if (phdr-&gtp_offset + phdr-&gtp_filesz &gt newsize) {\newline	    phdr-&gtp_filesz = newsize - phdr-&gtp_offset;\newline	}\newline    }\newline\newline    return TRUE;\newline}\newline","modifyheaders() removes references to the section header table if\newline it was stripped, and reduces program header table entries that\newline included truncated bytes at the end of the file.\newline \newline",2261308,bloc.c,static int mmc_read_capacity_req (void *buffer)\newline{\newline    uint8_t *p;\newline    \newline    p = buffer;\newline    p[0] = 0x25;\newline    p[1] = 0x00;\newline    p[2] = 0x00;\newline    p[3] = 0x00;\newline    p[4] = 0x00;\newline    p[5] = 0x00;\newline    p[6] = 0x00;\newline    p[7] = 0x00;\newline    p[8] = 0x00;\newline    p[9] = 0x00;\newline\newline    return 10;\newline}\newline,MMC: multimedia commands \newline,6388080,qcc_pr_lex.c,int QCC_PR_LexInteger (void)\newline{\newline	int		c;\newline	int		len;\newline	\newline	len = 0;\newline	c = *pr_file_p;\newline	if (pr_file_p[0] == &#0390&#039 &amp&amp pr_file_p[1] == &#039x&#039)\newline	{\newline		pr_token[0] = &#0390&#039;\newline		pr_token[1] = &#039x&#039;\newline		len = 2;\newline		c = *(pr_file_p+=2);\newline	}\newline	do\newline	{\newline		pr_token[len] = c;\newline		len++;\newline		pr_file_p++;\newline		c = *pr_file_p;\newline	} while ((c &gt= &#0390&#039 &amp&amp c&lt= &#0399&#039) || c == &#039.&#039 || (c&gt=&#039a&#039 &amp&amp c &lt= &#039f&#039));\newline	pr_token[len] = 0;\newline	return atoi (pr_token);\newline}\newline,\newline==============\newlinePR_LexNumber\newline==============\newline \newline,429865,interrupt.h,"static void interrupted(int n)\newline{\newline    (void) n;\newline    siglongjmp(jmpbuf, 1);\newline}\newline",signal handler to handle interrupt during a commands \newline,1530129,catsearch.c,static void clearstack(void) \newline{\newline	save_cidx = -1;\newline	while (dsidx &gt 0) {\newline		dsidx--;\newline	}\newline}\newline,Clears directory stack. \newline,313322,objects.c,"command * find_command(char *name) {\newline	command temp_command;\newline\newline	if (name == NULL)\newline		return NULL;\newline\newline	temp_command.name = name;\newline\newline	return skiplist_find_first(object_skiplists[COMMAND_SKIPLIST], &amptemp_command, NULL);\newline}\newline","given a command name, find a command from the list in memory \newline",4347377,nucnvtst.c,"static ETestConvertResult testConvertFromU( const UChar *source, int sourceLen,  const uint8_t *expect, int expectLen,\newline                const char *codepage, const int32_t *expectOffsets , UBool useFallback)\newline{\newline    UErrorCode status = U_ZERO_ERROR;\newline    UConverter *conv = 0;\newline    char    junkout[NEW_MAX_BUFFER]; /* FIX */\newline    int32_t    junokout[NEW_MAX_BUFFER]; /* FIX */\newline    char *p;\newline    const UChar *src;\newline    char *end;\newline    char *targ;\newline    int32_t *offs;\newline    int i;\newline    int32_t   realBufferSize;\newline    char *realBufferEnd;\newline    const UChar *realSourceEnd;\newline    const UChar *sourceLimit;\newline    UBool checkOffsets = TRUE;\newline    UBool doFlush;\newline\newline    for(i=0;i&ltNEW_MAX_BUFFER;i++)\newline        junkout[i] = (char)0xF0;\newline    for(i=0;i&ltNEW_MAX_BUFFER;i++)\newline        junokout[i] = 0xFF;\newline\newline    setNuConvTestName(codepage, &quotFROM&quot);\newline\newline    log_verbose(&quot\\n=========  %s\\n&quot, gNuConvTestName);\newline\newline    conv = my_ucnv_open(codepage, &ampstatus);\newline\newline    if(U_FAILURE(status))\newline    {\newline        log_data_err(&quotCouldn&#039t open converter %s\\n&quot,codepage);\newline        return TC_FAIL;\newline    }\newline    if(useFallback){\newline        ucnv_setFallback(conv,useFallback);\newline    }\newline\newline    log_verbose(&quotConverter opened..\\n&quot);\newline\newline    src = source;\newline    targ = junkout;\newline    offs = junokout;\newline\newline    realBufferSize = UPRV_LENGTHOF(junkout);\newline    realBufferEnd = junkout + realBufferSize;\newline    realSourceEnd = source + sourceLen;\newline\newline    if ( gOutBufferSize != realBufferSize || gInBufferSize != NEW_MAX_BUFFER )\newline        checkOffsets = FALSE;\newline\newline    do\newline    {\newline      end = nct_min(targ + gOutBufferSize, realBufferEnd);\newline      sourceLimit = nct_min(src + gInBufferSize, realSourceEnd);\newline      \newline      doFlush = (UBool)(sourceLimit == realSourceEnd);\newline      \newline      if(targ == realBufferEnd) {\newline        log_err(&quotError, overflowed the real buffer while about to call fromUnicode! targ=%08lx %s&quot, targ, gNuConvTestName);\newline        return TC_FAIL;\newline      }\newline      log_verbose(&quotcalling fromUnicode @ SOURCE:%08lx to %08lx  TARGET: %08lx to %08lx, flush=%s\\n&quot, src,sourceLimit, targ,end, doFlush?&quotTRUE&quot:&quotFALSE&quot);\newline\newline\newline      status = U_ZERO_ERROR;\newline      \newline      ucnv_fromUnicode (conv,\newline                        &amptarg,\newline                        end,\newline                        &ampsrc,\newline                        sourceLimit,\newline                        checkOffsets ? offs : NULL,\newline                        doFlush, /* flush if we&#039re at the end of the input data */\newline                        &ampstatus);\newline    } while ( (status == U_BUFFER_OVERFLOW_ERROR) || (U_SUCCESS(status) &amp&amp sourceLimit &lt realSourceEnd) );\newline\newline    if(U_FAILURE(status)) {\newline      log_err(&quotProblem doing fromUnicode to %s, errcode %s %s\\n&quot, codepage, myErrorName(status), gNuConvTestName);\newline      return TC_FAIL;\newline    }\newline\newline    log_verbose(&quot\\nConversion done [%d uchars in -&gt %d chars out]. \\nResult :&quot,\newline                sourceLen, targ-junkout);\newline\newline    if(getTestOption(VERBOSITY_OPTION))\newline    {\newline      char junk[9999];\newline      char offset_str[9999];\newline      char *ptr;\newline      \newline      junk[0] = 0;\newline      offset_str[0] = 0;\newline      for(ptr = junkout;ptr&lttarg;ptr++) {\newline        sprintf(junk + strlen(junk), &quot0x%02x, &quot, (int)(0xFF &amp *ptr));\newline        sprintf(offset_str + strlen(offset_str), &quot0x%02x, &quot, (int)(0xFF &amp junokout[ptr-junkout]));\newline      }\newline      \newline      log_verbose(junk);\newline      printSeq((const uint8_t *)expect, expectLen);\newline      if ( checkOffsets ) {\newline        log_verbose(&quot\\nOffsets:&quot);\newline        log_verbose(offset_str);\newline      }\newline      log_verbose(&quot\\n&quot);\newline    }\newline    ucnv_close(conv);\newline    \newline    if(expectLen != targ-junkout) {\newline      log_err(&quotExpected %d chars out, got %d %s\\n&quot, expectLen, targ-junkout, gNuConvTestName);\newline      log_verbose(&quotExpected %d chars out, got %d %s\\n&quot, expectLen, targ-junkout, gNuConvTestName);\newline      fprintf(stderr, &quotGot:\\n&quot);\newline      printSeqErr((const unsigned char*)junkout, (int32_t)(targ-junkout));\newline      fprintf(stderr, &quotExpected:\\n&quot);\newline      printSeqErr((const unsigned char*)expect, expectLen);\newline      return TC_MISMATCH;\newline    }\newline    \newline    if (checkOffsets &amp&amp (expectOffsets != 0) ) {\newline      log_verbose(&quotcomparing %d offsets..\\n&quot, targ-junkout);\newline      if(memcmp(junokout,expectOffsets,(targ-junkout) * sizeof(int32_t) )){\newline        log_err(&quotdid not get the expected offsets. %s\\n&quot, gNuConvTestName);\newline        printSeqErr((const unsigned char*)junkout, (int32_t)(targ-junkout));\newline        log_err(&quot\\n&quot);\newline        log_err(&quotGot  :     &quot);\newline        for(p=junkout;p&lttarg;p++) {\newline          log_err(&quot%d,&quot, junokout[p-junkout]);\newline        }\newline        log_err(&quot\\n&quot);\newline        log_err(&quotExpected:  &quot);\newline        for(i=0; i&lt(targ-junkout); i++) {\newline          log_err(&quot%d,&quot, expectOffsets[i]);\newline        }\newline        log_err(&quot\\n&quot);\newline      }\newline    }\newline\newline    log_verbose(&quotcomparing..\\n&quot);\newline    if(!memcmp(junkout, expect, expectLen)) {\newline      log_verbose(&quotMatches!\\n&quot);\newline      return TC_OK;\newline    } else {\newline      log_err(&quotString does not match u-&gt%s\\n&quot, gNuConvTestName);\newline      printUSeqErr(source, sourceLen);\newline      fprintf(stderr, &quotGot:\\n&quot);\newline      printSeqErr((const unsigned char *)junkout, expectLen);\newline      fprintf(stderr, &quotExpected:\\n&quot);\newline      printSeqErr((const unsigned char *)expect, expectLen);\newline      \newline      return TC_MISMATCH;\newline    }\newline}\newline",Note: This function uses global variables and it will not do offset\newlinechecking without gOutBufferSize and gInBufferSize set to NEW_MAX_BUFFER \newline,4966843,mainwindowgui.cpp,"void MainWindowGUI::keyPressEvent( QKeyEvent *k )\newline{\newline	switch ( k-&gtkey() )\newline	{\newline		case Key_Shift:\newline		{\newline			frameBar-&gtsetSelecting(true);\newline			break;\newline		}\newline		case Key_A:\newline		{\newline			DomainFacade* facade = DomainFacade::getFacade();\newline			int scene = frameBar-&gtgetActiveScene();\newline			if(0 &lt= scene) {\newline				int sceneSize = facade-&gtgetSceneSize(scene);\newline				if( sceneSize &gt 1) {\newline					frameBar-&gtupdateNewActiveFrame(scene, 0);\newline					frameBar-&gtsetSelection(sceneSize - 1);\newline				}\newline			}\newline			break;\newline		}\newline		default:\newline		{\newline			k-&gtignore();\newline			break;\newline		}\newline	}\newline}\newline",\newline @todo change so that CTRL+A instead of just A selects all the frames.\newline \newline,4350936,normconf.cpp,"void NormalizerConformanceTest::iterativeNorm(const UnicodeString&amp str,\newline                                              UNormalizationMode mode, int32_t options,\newline                                              UnicodeString&amp result,\newline                                              int8_t dir) {\newline    UErrorCode status = U_ZERO_ERROR;\newline    normalizer.setText(str, status);\newline    normalizer.setMode(mode);\newline    normalizer.setOption(-1, 0);        // reset all options\newline    normalizer.setOption(options, 1);   // set desired options\newline    result.truncate(0);\newline    if (U_FAILURE(status)) {\newline        return;\newline    }\newline    UChar32 ch;\newline    if (dir &gt 0) {\newline        for (ch = normalizer.first(); ch != Normalizer::DONE;\newline             ch = normalizer.next()) {\newline            result.append(ch);\newline        }\newline    } else {\newline        for (ch = normalizer.last(); ch != Normalizer::DONE;\newline             ch = normalizer.previous()) {\newline            result.insert(0, ch);\newline        }\newline    }\newline}\newline",\newline Do a normalization using the iterative API in the given direction.\newline @param dir either +1 or -1\newline \newline,,,,on,on,on,on,,,,,,on,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,Displays the sail CFormHullDef sail definition dialog.,Load an image from the named file.,setup display for ncurses top mode,{},{},{},{},signal handler to handle interrupt during a commands,Clears directory stack.,find a command from the list in memory,This function uses global variables,Frees the prefs table and all the entries it contains.,{},Do a normalization using the iterative API in the given direction.,set whether this patch should be played legato or not,{},"Remove the block from its free list,","compare answer and input, refresh A & B",stop a rtp stream on the proxy,This links the given line into the scrollback-buffer,Writes data to an endpoint buffer,x,
3IKDQS3DQE02QDGI448HR4TI4HXICG,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:19 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:19 PDT 2019,,,3VELCLL3GKJ0G31ND1IDWUTO2NVF1X,AITP2LUW8GPB,Submitted,Fri Apr 26 13:09:13 PDT 2019,Fri Apr 26 13:41:30 PDT 2019,Sun Apr 28 13:41:30 PDT 2019,,,,1937,100% (62/62),100% (62/62),0% (0/0),2299792,mpi.c,"int PF_LongSingleReceive(int src, int tag, int *psrc, int *ptag)\newline{\newline	int ret, missed, oncemore;\newline	MPI_Status status;\newline	PF_longSingleReset(0);\newline	do {\newline		ret = MPI_Recv(PF_longPackBuf,PF_longPackTop,MPI_PACKED,src,tag,\newline		               PF_COMM,&ampstatus);\newline		if ( ret != MPI_SUCCESS ) return(ret);\newline/*\newline			The source and tag must be specified here for the case if\newline			MPI_Recv is performed more than once:\newline*/\newline		src = status.MPI_SOURCE;\newline		tag = status.MPI_TAG;\newline		if ( psrc ) *psrc = status.MPI_SOURCE;\newline		if ( ptag ) *ptag = status.MPI_TAG;\newline/*\newline			Now we got either small buffer with the new PF_longPackTop,\newline			or just a regular chunk.\newline*/\newline		ret = MPI_Unpack(PF_longPackBuf,PF_longPackTop,&ampPF_longPackPos,\newline		                 &ampmissed,1,MPI_INT,PF_COMM);\newline		if ( ret != MPI_SUCCESS ) return(ret);\newline\newline		if ( missed &lt 0 ) { /* The small buffer was received. */\newline			oncemore = 1; /* repeat receiving afterwards */\newline						  /* Reallocate the buffer and get the data */\newline			missed = -missed;\newline/*\newline				restore after unpacking small from buffer:\newline*/\newline			PF_longPackPos = 0;\newline		}\newline		else {\newline			oncemore = 0;  /* That&#039s all, no repetition */\newline		}\newline		if ( missed &gt PF_longPackTop ) {\newline			/*\newline			 * The room must be increased. We need a re-allocation for the\newline			 * case that there is no repetition.\newline			 */\newline			if ( PF_longAddChunk( (missed-PF_longPackTop)/PF_packsize, !oncemore ) )\newline				return(-1);\newline		}\newline	} while ( oncemore );\newline	return(0);\newline}\newline","\newline Receives data into the &quotlong single&quot pack buffer from the process\newline specified by \\a src.\newline This function allows &ampsrc == psrc or &amptag == ptag.\newline Either \\a psrc or \\a ptag can be NULL.\newline \newline See the example of PF_LongSingleSend().\newline \newline @param src the source process number (can be PF_ANY_SOURCE).\newline @param tag the source message tag (can be PF_ANY_TAG).\newline @param[out] psrc the actual source process number of received message.\newline @param[out] ptag the received message tag.\newline @return 0 if OK, nonzero on error.\newline \newline",5175562,ge25519.c,"int ge25519_unpackneg_vartime(ge25519_p3 *r, const unsigned char p[32])\newline{\newline  unsigned char par;\newline  fe25519 t, chk, num, den, den2, den4, den6;\newline  fe25519_setone(&ampr-&gtz);\newline  par = p[31] &gt&gt 7;\newline  fe25519_unpack(&ampr-&gty, p); \newline  fe25519_square(&ampnum, &ampr-&gty); /* x = y^2 */\newline  fe25519_mul(&ampden, &ampnum, &ampge25519_ecd); /* den = dy^2 */\newline  fe25519_sub(&ampnum, &ampnum, &ampr-&gtz); /* x = y^2-1 */\newline  fe25519_add(&ampden, &ampr-&gtz, &ampden); /* den = dy^2+1 */\newline\newline  /* Computation of sqrt(num/den) */\newline  /* 1.: computation of num^((p-5)/8)*den^((7p-35)/8) = (num*den^7)^((p-5)/8) */\newline  fe25519_square(&ampden2, &ampden);\newline  fe25519_square(&ampden4, &ampden2);\newline  fe25519_mul(&ampden6, &ampden4, &ampden2);\newline  fe25519_mul(&ampt, &ampden6, &ampnum);\newline  fe25519_mul(&ampt, &ampt, &ampden);\newline\newline  fe25519_pow2523(&ampt, &ampt);\newline  /* 2. computation of r-&gtx = t * num * den^3 */\newline  fe25519_mul(&ampt, &ampt, &ampnum);\newline  fe25519_mul(&ampt, &ampt, &ampden);\newline  fe25519_mul(&ampt, &ampt, &ampden);\newline  fe25519_mul(&ampr-&gtx, &ampt, &ampden);\newline\newline  /* 3. Check whether sqrt computation gave correct result, multiply by sqrt(-1) if not: */\newline  fe25519_square(&ampchk, &ampr-&gtx);\newline  fe25519_mul(&ampchk, &ampchk, &ampden);\newline  if (!fe25519_iseq_vartime(&ampchk, &ampnum))\newline    fe25519_mul(&ampr-&gtx, &ampr-&gtx, &ampge25519_sqrtm1);\newline\newline  /* 4. Now we have one of the two square roots, except if input was not a square */\newline  fe25519_square(&ampchk, &ampr-&gtx);\newline  fe25519_mul(&ampchk, &ampchk, &ampden);\newline  if (!fe25519_iseq_vartime(&ampchk, &ampnum))\newline    return -1;\newline\newline  /* 5. Choose the desired square root according to parity: */\newline  if(fe25519_getparity(&ampr-&gtx) != (1-par))\newline    fe25519_neg(&ampr-&gtx, &ampr-&gtx);\newline\newline  fe25519_mul(&ampr-&gtt, &ampr-&gtx, &ampr-&gty);\newline  return 0;\newline}\newline","return 0 on success, -1 otherwise \newline",1321455,ppc_vec.c,"void ppc_opc_vsum4ubs()\newline{\newline	VECTOR_DEBUG;\newline	int vrD, vrA, vrB;\newline	uint64 res;\newline	PPC_OPC_TEMPL_X(gCPU.current_opc, vrD, vrA, vrB);\newline\newline	/* For this, there&#039s no way to get around 64-bit math.  If we use\newline	 *   the hacks used before, then we have to do it so often, that\newline	 *   we&#039ll outpace the 64-bit math in execution time.\newline	 */\newline	int i;\newline	for (i=0; i&lt4; i++) {\newline		res = (uint64)gCPU.vr[vrB].w[i];\newline\newline		res += (uint64)gCPU.vr[vrA].b[(i&lt&lt2)];\newline		res += (uint64)gCPU.vr[vrA].b[(i&lt&lt2)+1];\newline		res += (uint64)gCPU.vr[vrA].b[(i&lt&lt2)+2];\newline		res += (uint64)gCPU.vr[vrA].b[(i&lt&lt2)+3];\newline\newline		gCPU.vr[vrD].w[i] = SATURATE_UW(res);\newline	}\newline}\newline",vsum4ubs Vector Sum Across Partial (1/4) Unsigned Byte Saturate\newline v.275\newline \newline,4492785,vpfwrite.c,"ossim_int32 put_table_element( ossim_int32              field,\newline		       row_type         row,\newline		       vpf_table_type   table,\newline		       void           * value,\newline		       ossim_int32         count )\newline{\newline   ossim_int32 i, len, stat;\newline   char *str;\newline\newline   stat=0;\newline\newline   if ((count != table.header[field].count) &amp&amp\newline       (table.header[field].count &gt 0)) {\newline      printf(&quotInvalid element count! (%ld, %ld)\\n&quot,\newline	     count,table.header[field].count);\newline      return -1;\newline   }\newline\newline   if (field &lt 0 || field &gt= table.nfields)\newline     return -1;\newline\newline   row[field].count = count;\newline\newline   if (row[field].ptr) {\newline      free(row[field].ptr);\newline      row[field].ptr = NULL;\newline   }\newline\newline   switch ( table.header[field].type ) {\newline      case &#039T&#039:\newline	len = (ossim_int32)max(count,table.header[field].count);\newline	str = (char *) vpfmalloc( len + 1 );\newline	row[field].ptr = (char *) vpfmalloc ( len + 1 ) ;\newline	strcpy( (char*)str, (char*)value );\newline	for ( i = (long)strlen((char*)value) ; i &lt table.header[field].count; i++ )\newline	   str[i] = SPACE ;\newline	str[len] = &#039\\0&#039;\newline	memcpy(row[field].ptr, str, len+1);\newline	free(str);\newline	break ;\newline\newline      case &#039D&#039:\newline	row[field].ptr = (date_type *) vpfmalloc (count*sizeof(date_type));\newline	memcpy ( row[field].ptr, value, sizeof (date_type) * count ) ;\newline	break;\newline\newline      case &#039I&#039 :\newline	row[field].ptr = (ossim_int32 *) vpfmalloc (count*sizeof(ossim_int32));\newline	memcpy ( row[field].ptr, value, sizeof (ossim_int32) * count ) ;\newline	break;\newline\newline      case &#039S&#039 :\newline	row[field].ptr = (ossim_int16 *) vpfmalloc (count*sizeof(ossim_int16));\newline	memcpy ( row[field].ptr, value, sizeof (ossim_int16) * count ) ;\newline	break;\newline\newline      case &#039F&#039:\newline	row[field].ptr = (float *) vpfmalloc (count*sizeof(float));\newline	memcpy ( row[field].ptr, value, sizeof (float) * count ) ;\newline	break;\newline\newline      case &#039R&#039:\newline	row[field].ptr = (double *) vpfmalloc (count*sizeof(double));\newline	memcpy ( row[field].ptr, value, sizeof (double) * count ) ;\newline	break;\newline\newline      case &#039K&#039:\newline	row[field].ptr =\newline	  (id_triplet_type *) vpfmalloc ( count*sizeof(id_triplet_type ));\newline	memcpy ( row[field].ptr, value, sizeof(id_triplet_type)*count ) ;\newline	break;\newline\newline      case &#039C&#039:\newline	if (value) {\newline	   row[field].ptr = (coordinate_type *)\newline	       malloc ( count * sizeof( coordinate_type ));\newline	   if (row[field].ptr)\newline	      memcpy ( row[field].ptr, value,\newline		       sizeof(coordinate_type)*count ) ;\newline	} else {\newline	   row[field].ptr = NULL;\newline	}\newline	break;\newline\newline      case &#039Z&#039:\newline	if (value) {\newline	  row[field].ptr = (tri_coordinate_type *)\newline	     malloc ( count * sizeof( tri_coordinate_type ));\newline	  if (row[field].ptr)\newline	     memcpy ( row[field].ptr, value,\newline		      sizeof(tri_coordinate_type)*count ) ;\newline	} else {\newline	   row[field].ptr = NULL;\newline	}\newline	break;\newline\newline      case &#039B&#039:\newline	if (value) {\newline	   row[field].ptr = (double_coordinate_type *)\newline	     malloc ( count * sizeof( double_coordinate_type ));\newline	   if (row[field].ptr)\newline	      memcpy ( row[field].ptr, value,\newline		       sizeof(double_coordinate_type)*count ) ;\newline	} else {\newline	   row[field].ptr = NULL;\newline	}\newline	break;\newline\newline      case &#039Y&#039:\newline	if (value) {\newline	   row[field].ptr = (double_tri_coordinate_type *)\newline	     malloc ( count * sizeof( double_tri_coordinate_type ));\newline	   if (row[field].ptr)\newline	      memcpy( row[field].ptr, value,\newline		      sizeof(double_tri_coordinate_type)*count);\newline	} else {\newline	   row[field].ptr = NULL;\newline	}\newline	break;\newline\newline      default:\newline	stat = -1;\newline	break ;\newline   }\newline\newline   return stat;\newline}\newline","\newline \newline N put_table_element\newline \newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Purpose:\newline P\newline Copies one element into the designated field.\newline The parameter row must be initialized prior to this functional, either\newline buy being read in from an existing table or set to valid values. The\newline parameter table must be a valid table and initialized prior to this\newline function, by vpf_open_table. Note that if errorfp is used, it must\newline be opened prior to this function.\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Parameters:\newline A\newline field &ltinput&gt == (ossim_int32) column offset.\newline row &ltin-out&gt == (row_type) row containing target field.\newline table &ltin-out&gt == (vpf_table_type) VPF table owning row.\newline value &ltin&gt == (void ) source field element.\newline count &ltin&gt == (ossim_int32) number of items in value.\newline put_table_element &ltoutput&gt == (ossim_int32)\newline 0 --&gt element write succeeded\newline 1 --&gt unknown element type or\newline invalid column offset\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline History:\newline H\newline RDF 7/91 original\newline JTB 10/91 removed call to exit();\newline guaranteed function always returns value\newline 0: element write succeeded\newline -1: unknown element type or invalid column (field) offset\newline E\newline \newline",896404,ospbfr.c,unsigned OSPPBfrSize(   /* returns the size */\newline    OSPTBFR *ospvBfr)   /* buffer in question */\newline{\newline    unsigned ospvSize = 0;\newline\newline    if (ospvBfr != OSPC_OSNULL) {\newline        ospvSize = ospvBfr-&gtospmBfrWrite - ospvBfr-&gtospmBfrRead;\newline    }\newline\newline    return ospvSize;\newline}\newline,\newline OSPPBfrSize() - get the number of bytes currently in buffer\newline \newline,2163022,http_dav.c,"int ensure_ns(xmlNsPtr *respNs, int ns, xmlNodePtr node,\newline	      const char *url, const char *prefix)\newline{\newline    if (!respNs[ns]) {\newline	xmlNsPtr nsDef;\newline	char myprefix[20];\newline\newline	/* Search for existing namespace using our prefix */\newline	for (nsDef = node-&gtnsDef; nsDef; nsDef = nsDef-&gtnext) {\newline	    if ((!nsDef-&gtprefix &amp&amp !prefix) ||\newline		(nsDef-&gtprefix &amp&amp prefix &amp&amp\newline		 !strcmp((const char *) nsDef-&gtprefix, prefix))) break;\newline	}\newline    \newline	if (nsDef) {\newline	    /* Prefix is already used - generate a new one */\newline	    snprintf(myprefix, sizeof(myprefix), &quotX%X&quot, strhash(url) &amp 0xffff);\newline	    prefix = myprefix;\newline	}\newline\newline	respNs[ns] = xmlNewNs(node, BAD_CAST url, BAD_CAST prefix);\newline    }\newline\newline    /* XXX  check for errors */\newline    return 0;\newline}\newline","Ensure that we have a given namespace. If it doesn&#039t exist in what we\newline parsed in the request, create it and attach to &#039node&#039.\newline \newline",2907468,gtk-ui.c,"static void otrg_gtk_ui_get_prefs(OtrgUiPrefs *prefsp, PurpleAccount *account,\newline	const char *name)\newline{\newline    PurpleBuddy *buddy;\newline    gboolean otrenabled, otrautomatic, otronlyprivate, otravoidloggingotr;\newline    gboolean buddyusedefault, buddyenabled, buddyautomatic, buddyonlyprivate,\newline	    buddyavoidloggingotr;\newline\newline    prefsp-&gtpolicy = OTRL_POLICY_DEFAULT;\newline    prefsp-&gtavoid_logging_otr = FALSE;\newline    prefsp-&gtshow_otr_button = FALSE;\newline\newline    /* Get the default policy */\newline    otrg_gtk_ui_global_prefs_load(&ampotrenabled, &ampotrautomatic, &ampotronlyprivate,\newline	    &ampotravoidloggingotr);\newline    otrg_gtk_ui_global_options_load(&amp(prefsp-&gtshow_otr_button));\newline\newline    if (otrenabled) {\newline	if (otrautomatic) {\newline	    if (otronlyprivate) {\newline		prefsp-&gtpolicy = OTRL_POLICY_ALWAYS;\newline	    } else {\newline		prefsp-&gtpolicy = OTRL_POLICY_OPPORTUNISTIC;\newline	    }\newline	} else {\newline	    prefsp-&gtpolicy = OTRL_POLICY_MANUAL;\newline	}\newline	prefsp-&gtavoid_logging_otr = otravoidloggingotr;\newline    } else {\newline	prefsp-&gtpolicy = OTRL_POLICY_NEVER;\newline    }\newline\newline    buddy = purple_find_buddy(account, name);\newline    if (!buddy) return;\newline\newline    /* Get the buddy-specific policy, if present */\newline    otrg_gtk_ui_buddy_prefs_load(buddy, &ampbuddyusedefault, &ampbuddyenabled,\newline	    &ampbuddyautomatic, &ampbuddyonlyprivate, &ampbuddyavoidloggingotr);\newline\newline    if (buddyusedefault) return;\newline\newline    if (buddyenabled) {\newline	if (buddyautomatic) {\newline	    if (buddyonlyprivate) {\newline		prefsp-&gtpolicy = OTRL_POLICY_ALWAYS;\newline	    } else {\newline		prefsp-&gtpolicy = OTRL_POLICY_OPPORTUNISTIC;\newline	    }\newline	} else {\newline	    prefsp-&gtpolicy = OTRL_POLICY_MANUAL;\newline	}\newline	prefsp-&gtavoid_logging_otr = buddyavoidloggingotr;\newline    } else {\newline	prefsp-&gtpolicy = OTRL_POLICY_NEVER;\newline    }\newline}\newline",Load the preferences for a particular account / username \newline,4047882,pickup.c,"void pickup_init(GtkWidget *window_root)\newline{\newline    static int has_init=0;\newline\newline    /*\newline     * There isn&#039t really any harm doing this multiple times, but isn&#039t any\newline     * point either.\newline     */\newline    if (has_init) {\newline        return;\newline    }\newline    has_init=1;\newline\newline    /*\newline     * The order here really doesn&#039t make much difference.  I suppose order\newline     * could either be in pickup modes (PU_...) or the list of items in the\newline     * menu tree.  I chose the later, as easier to make sure all the items are\newline     * accounted for.\newline     *\newline     * In practice, with these values now set up, we could use a single\newline     * function to hande all the events from the menubar instead of the values\newline     * above - that function basically takes the structure that was clicked,\newline     * and finds the value in this array that corresponds to it.  But that code\newline     * currently works fine and isn&#039t really outdated, so isn&#039t a big reason to\newline     * change it.\newline     */\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotdo_not_pickup&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_INHIBIT;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotstop_before_pickup&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_STOP;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotbody_armor&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_ARMOUR;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotboots&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_BOOTS;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotcloaks&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_CLOAK;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotgloves&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_GLOVES;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quothelmets&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_HELMET;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotshields&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_SHIELD;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotskillscrolls&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_SKILLSCROLL;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotnormal_book_scrolls&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_READABLES;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotspellbooks&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_SPELLBOOK;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotdrinks&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_DRINK;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotfood&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_FOOD;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotflesh&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_FLESH;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotkeys&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_KEY;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotmagical_items&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_MAGICAL;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotpotions&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_POTION;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotvaluables&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_VALUABLES;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotwands_rods_horns&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_MAGIC_DEVICE;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotjewels&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_JEWELS;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotcontainers&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_CONTAINERS;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotall_weapons&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_ALLWEAPON;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotmissile_weapons&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_MISSILEWEAPON;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotbows&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_BOW;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotarrows&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_ARROW;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_pickup_off&quot));\newline    pickup_mapping[num_pickups].pickup_mode = ~PU_RATIO;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_5&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 1;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_10&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 2;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_15&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 3;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_20&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 4;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_25&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 5;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_30&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 6;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_35&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 7;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_40&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 8;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_45&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 9;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotratio_50&quot));\newline    pickup_mapping[num_pickups].pickup_mode = 10;\newline    num_pickups++;\newline\newline    pickup_mapping[num_pickups].menuitem =\newline        GTK_WIDGET(gtk_builder_get_object(window_xml, &quotnot_cursed&quot));\newline    pickup_mapping[num_pickups].pickup_mode = PU_NOT_CURSED;\newline    num_pickups++;\newline\newline    /*\newline     * Do some bounds checking.  We could actually set this exactly right,\newline     * since additional menu entries are not likely to be added often.  We exit\newline     * because if we overrun that structure, we&#039ve screwed up memory and will\newline     * likely crash or otherwise have odd behaviour.\newline     */\newline    if (num_pickups&gt=MAX_PICKUPS) {\newline        LOG(LOG_ERROR, &quotpickup.c::pickup_init&quot, &quotnum_pickups (%d) &gt= MAX_PICKUPS (%d)\\n&quot,\newline            num_pickups, MAX_PICKUPS);\newline        exit(1);\newline    }\newline\newline}\newline","\newline Maps the menuitem lists into pickup values. In this way, client_pickup\newline knows what values to change.\newline \newline @param window_root\newline \newline",4215164,sv_phys.c,void SV_RunNewmis (void)\newline{\newline	edict_t	*ent;\newline	double save_frametime;\newline\newline	if (pr_nqprogs)\newline		return;\newline\newline	if (!pr_global_struct-&gtnewmis)\newline		return;\newline\newline	ent = PROG_TO_EDICT(pr_global_struct-&gtnewmis);\newline	pr_global_struct-&gtnewmis = 0;\newline\newline	save_frametime = sv_frametime;\newline	sv_frametime = 0.05;\newline\newline	SV_RunEntity (ent);\newline\newline	sv_frametime = save_frametime;\newline}\newline,\newline================\newlineSV_RunNewmis\newline================\newline \newline,1201925,libxc_tools.c,"void xc_get_flags_constants(int *xc_cst_flags_have_exc,\newline                            int *xc_cst_flags_have_vxc,\newline                            int *xc_cst_flags_have_fxc,\newline                            int *xc_cst_flags_have_kxc,\newline                            int *xc_cst_flags_have_lxc)\newline{\newline *xc_cst_flags_have_exc  = XC_FLAGS_HAVE_EXC;\newline *xc_cst_flags_have_vxc  = XC_FLAGS_HAVE_VXC;\newline *xc_cst_flags_have_fxc  = XC_FLAGS_HAVE_FXC;\newline *xc_cst_flags_have_kxc  = XC_FLAGS_HAVE_KXC;\newline *xc_cst_flags_have_lxc  = XC_FLAGS_HAVE_LXC;\newline}\newline",===============================================================\newline Get the FLAGS constants\newline ===============================================================\newline \newline,3256718,message.c,"int AH_Msg_ReadSegment(AH_MSG *msg,\newline                       GWEN_MSGENGINE *e,\newline                       const char *gtype,\newline                       GWEN_BUFFER *mbuf,\newline                       GWEN_DB_NODE *gr,\newline                       unsigned int flags) {\newline  GWEN_XMLNODE *node;\newline  unsigned int posBak;\newline  const char *p;\newline  GWEN_DB_NODE *tmpdb;\newline  int segVer;\newline\newline  /* find head segment description */\newline  tmpdb=GWEN_DB_Group_new(&quothead&quot);\newline  node=GWEN_MsgEngine_FindGroupByProperty(e,\newline                                          &quotid&quot,\newline                                          0,\newline                                          &quotSegHead&quot);\newline  if (node==0) {\newline    DBG_ERROR(AQHBCI_LOGDOMAIN, &quotSegment description not found (internal error)&quot);\newline    GWEN_DB_Group_free(tmpdb);\newline    return -2;\newline  }\newline\newline  /* parse head segment */\newline  posBak=GWEN_Buffer_GetPos(mbuf);\newline  if (GWEN_MsgEngine_ParseMessage(e,\newline                                  node,\newline                                  mbuf,\newline                                  tmpdb,\newline                                  flags)) {\newline    DBG_ERROR(AQHBCI_LOGDOMAIN, &quotError parsing segment head&quot);\newline    GWEN_DB_Group_free(tmpdb);\newline    return -2;\newline  }\newline\newline  GWEN_Buffer_SetPos(mbuf, posBak);\newline\newline  /* get segment code */\newline  segVer=GWEN_DB_GetIntValue(tmpdb,\newline                             &quotversion&quot,\newline                             0,\newline                             0);\newline  p=GWEN_DB_GetCharValue(tmpdb,\newline                         &quotcode&quot,\newline                         0,\newline                         0);\newline  if (!p) {\newline    DBG_ERROR(AQHBCI_LOGDOMAIN,\newline              &quotNo segment code for %s ? This seems to be a bad msg...&quot,\newline              gtype);\newline    DBG_ERROR(AQHBCI_LOGDOMAIN, &quotFull message (pos=%04x)&quot, posBak);\newline    GWEN_Text_DumpString(GWEN_Buffer_GetStart(mbuf),\newline                         GWEN_Buffer_GetUsedBytes(mbuf),\newline                         1);\newline    GWEN_DB_Dump(tmpdb, 1);\newline    GWEN_DB_Group_free(tmpdb);\newline    return -1;\newline  }\newline\newline  /* try to find corresponding XML node */\newline  node=GWEN_MsgEngine_FindNodeByProperty(e,\newline                                         gtype,\newline                                         &quotcode&quot,\newline                                         segVer,\newline                                         p);\newline  if (node==0) {\newline    GWEN_DB_NODE *storegrp;\newline    unsigned int startPos;\newline\newline    GWEN_Buffer_SetPos(mbuf, posBak);\newline    startPos=posBak;\newline\newline    storegrp=GWEN_DB_GetGroup(gr,\newline                              GWEN_PATH_FLAGS_CREATE_GROUP,\newline                              p);\newline    assert(storegrp);\newline    GWEN_DB_AddGroup(storegrp, GWEN_DB_Group_dup(tmpdb));\newline\newline    /* store the start position of this segment within the DB */\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/pos&quot,\newline                        startPos);\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/error/code&quot,\newline                        9130);\newline    GWEN_DB_SetCharValue(storegrp,\newline                         GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                         &quotsegment/error/text&quot,\newline                         &quotUnbekanntes segment (Parser)&quot);\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/error/pos&quot,\newline                        startPos);\newline\newline    /* node not found, skip it */\newline    DBG_WARN(AQHBCI_LOGDOMAIN,\newline             &quotUnknown segment \\&quot%s\\&quot (Segnum=%d, version=%d, ref=%d)&quot,\newline             p,\newline             GWEN_DB_GetIntValue(tmpdb, &quotseq&quot, 0, -1),\newline             GWEN_DB_GetIntValue(tmpdb, &quotversion&quot, 0, -1),\newline             GWEN_DB_GetIntValue(tmpdb, &quotref&quot, 0, -1));\newline    if (GWEN_MsgEngine_SkipSegment(e, mbuf, &#039?&#039, &#039\\&#039&#039)) {\newline      DBG_ERROR(AQHBCI_LOGDOMAIN, &quotError skipping segment \\&quot%s\\&quot&quot, p);\newline      GWEN_DB_Group_free(tmpdb);\newline      return -1;\newline    }\newline    /* store segment size within DB */\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/length&quot,\newline                        GWEN_Buffer_GetPos(mbuf)-startPos);\newline    /* handle trust info */\newline    if (flags &amp GWEN_MSGENGINE_READ_FLAGS_TRUSTINFO) {\newline      unsigned int usize;\newline\newline      usize=GWEN_Buffer_GetPos(mbuf)-(startPos+1)-1;\newline      if (GWEN_MsgEngine_AddTrustInfo(e,\newline                                      GWEN_Buffer_GetStart(mbuf)+startPos,\newline                                      usize,\newline                                      p,\newline                                      GWEN_MsgEngineTrustLevelHigh,\newline                                      startPos)) {\newline        DBG_INFO(AQHBCI_LOGDOMAIN, &quotcalled from here&quot);\newline        GWEN_DB_Group_free(tmpdb);\newline        return -1;\newline      }\newline    } /* if trustInfo handling wanted */\newline  }\newline  else {\newline    /* ok, node available, get the corresponding description and parse\newline     * the segment */\newline    const char *id;\newline    GWEN_DB_NODE *storegrp;\newline    unsigned int startPos;\newline\newline    /* restore start position, since the segment head is part of a full\newline     * description, so we need to restart reading from the very begin */\newline    GWEN_Buffer_SetPos(mbuf, posBak);\newline\newline    /* create group in DB for this segment */\newline    id=GWEN_XMLNode_GetProperty(node, &quotid&quot, p);\newline    storegrp=GWEN_DB_GetGroup(gr,\newline                              GWEN_PATH_FLAGS_CREATE_GROUP,\newline                              id);\newline    assert(storegrp);\newline\newline    /* store the start position of this segment within the DB */\newline    startPos=GWEN_Buffer_GetPos(mbuf);\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/pos&quot,\newline                        startPos);\newline\newline    /* parse the segment */\newline    if (GWEN_MsgEngine_ParseMessage(e,\newline                                    node,\newline                                    mbuf,\newline                                    storegrp,\newline                                    flags)) {\newline      GWEN_DB_SetIntValue(storegrp,\newline                          GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                          &quotsegment/error/code&quot,\newline                          9130);\newline      GWEN_DB_SetCharValue(storegrp,\newline                           GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                           &quotsegment/error/text&quot,\newline                           &quotSyntaxfehler&quot);\newline      GWEN_DB_SetIntValue(storegrp,\newline                          GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                          &quotsegment/error/pos&quot,\newline                          GWEN_Buffer_GetPos(mbuf)-startPos);\newline\newline      DBG_ERROR(AQHBCI_LOGDOMAIN, &quotError parsing segment \\&quot%s\\&quot&quot,p);\newline      GWEN_Text_DumpString(GWEN_Buffer_GetStart(mbuf)+startPos,\newline                           GWEN_Buffer_GetUsedBytes(mbuf)-startPos,\newline                           1);\newline      GWEN_DB_Group_free(tmpdb);\newline      return -1;\newline    }\newline\newline    /* store segment size within DB */\newline    GWEN_DB_SetIntValue(storegrp,\newline                        GWEN_DB_FLAGS_OVERWRITE_VARS,\newline                        &quotsegment/length&quot,\newline                        GWEN_Buffer_GetPos(mbuf)-startPos);\newline    if (strcasecmp(id, &quotMsgHead&quot)==0) {\newline      int protocolVersion;\newline\newline      protocolVersion=GWEN_DB_GetIntValue(storegrp,\newline                                          &quothversion&quot,\newline                                          0, 0);\newline      if (!protocolVersion) {\newline        DBG_WARN(AQHBCI_LOGDOMAIN, &quotUnknown protocol version, using default of 210&quot);\newline        protocolVersion=210;\newline      }\newline      /* set HBCI protocol version to be used (taken from MsgHead) */\newline      DBG_DEBUG(AQHBCI_LOGDOMAIN, &quotSetting protocol version to %d&quot, protocolVersion);\newline      GWEN_MsgEngine_SetProtocolVersion(e, protocolVersion);\newline      msg-&gthbciVersion=protocolVersion;\newline    }\newline  } /* if node found */\newline  GWEN_DB_Group_free(tmpdb);\newline\newline  return 0;\newline}\newline",return -1 on error (with group &quotseg/error&quot set) or -2 if the message is\newline faulty \newline,4945247,utils.c,"int mnt_fstype_is_pseudofs(const char *type)\newline{\newline	/* This array must remain sorted when adding new fstypes */\newline	static const char *pseudofs[] = {\newline		&quotanon_inodefs&quot,\newline		&quotautofs&quot,\newline		&quotbdev&quot,\newline		&quotbinfmt_misc&quot,\newline		&quotcgroup&quot,\newline		&quotcgroup2&quot,\newline		&quotconfigfs&quot,\newline		&quotcpuset&quot,\newline		&quotdebugfs&quot,\newline		&quotdevfs&quot,\newline		&quotdevpts&quot,\newline		&quotdevtmpfs&quot,\newline		&quotdlmfs&quot,\newline		&quotefivarfs&quot,\newline		&quotfuse.gvfs-fuse-daemon&quot,\newline		&quotfusectl&quot,\newline		&quothugetlbfs&quot,\newline		&quotmqueue&quot,\newline		&quotnfsd&quot,\newline		&quotnone&quot,\newline		&quotoverlay&quot,\newline		&quotpipefs&quot,\newline		&quotproc&quot,\newline		&quotpstore&quot,\newline		&quotramfs&quot,\newline		&quotrootfs&quot,\newline		&quotrpc_pipefs&quot,\newline		&quotsecurityfs&quot,\newline		&quotsockfs&quot,\newline		&quotspufs&quot,\newline		&quotsysfs&quot,\newline		&quottmpfs&quot\newline	};\newline\newline	assert(type);\newline\newline	return !(bsearch(&amptype, pseudofs, ARRAY_SIZE(pseudofs),\newline				sizeof(char*), fstype_cmp) == NULL);\newline}\newline","\newline mnt_fstype_is_pseudofs:\newline @type: filesystem name\newline \newline Returns: 1 for filesystems like proc, sysfs, ... or 0.\newline \newline",1040523,getgr_nam_gid.c,"extern /*@only@*//*@null@*/struct group *getgr_nam_gid (/*@null@*/const char *grname)\newline{\newline	long long int gid;\newline	char *endptr;\newline\newline	if (NULL == grname) {\newline		return NULL;\newline	}\newline\newline	errno = 0;\newline	gid = strtoll (grname, &ampendptr, 10);\newline	if (   (&#039\\0&#039 != *grname)\newline	    &amp&amp (&#039\\0&#039 == *endptr)\newline	    &amp&amp (ERANGE != errno)\newline	    &amp&amp (/*@+longintegral@*/gid == (gid_t)gid)/*@=longintegral@*/) {\newline		return xgetgrgid ((gid_t) gid);\newline	}\newline	return xgetgrnam (grname);\newline}\newline","\newline getgr_nam_gid - Return a pointer to the group specified by a string.\newline The string may be a valid GID or a valid groupname.\newline If the group does not exist on the system, NULL is returned.\newline \newline",5745130,paux.c,"int ycDirective(char *token)\newline{\newline  if (ycLookup(token,lex_directive_words,lex_directive_num) &gt 0) {\newline    yc_unputstring(token);\newline    SaveLast();\newline    BeginCD();\newline    return -1;\newline  } else\newline    return Directive_macroReplace(token);\newline}\newline",\newline \newline Handle a verilog directive or macro lookup.\newline \newline \newline,2838638,sock_utils.c,"int open_unix_sock(const char *dirname, gid_t gid) {\newline	mode_t oldmode = 0;\newline	int fd = -1;\newline	struct sockaddr_un sa;\newline\newline	sa.sun_family = AF_UNIX;\newline	snprintf(sa.sun_path, 108 , &quot%s%s&quot, dirname, CPUFREQD_SOCKET);\newline\newline	if (gid &gt 0) {\newline		oldmode = umask(S_IXUSR | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);\newline	}\newline	if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {\newline		clog(LOG_ERR, &quotsocket(): %s.\\n&quot, strerror(errno));\newline\newline	} else if (bind(fd, &ampsa, sizeof(sa)) == -1) {\newline		clog(LOG_ERR, &quotbind(): %s.\\n&quot, strerror(errno));\newline		close(fd);\newline		fd = -1;\newline\newline	} else if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {\newline		clog(LOG_ERR, &quotfcntl(): %s.\\n&quot, strerror(errno));\newline		close(fd);\newline		fd = -1;\newline\newline	} else if (listen(fd, 5) == -1) {\newline		clog(LOG_ERR, &quotlisten(): %s.\\n&quot, strerror(errno));\newline		close(fd);\newline		fd = -1;\newline\newline	} else if (gid &gt 0 &amp&amp chown(sa.sun_path, 0, gid) &lt 0) {\newline		clog(LOG_ERR, &quotCouldn&#039t chown %s (%s).\\n&quot,\newline				sa.sun_path, strerror(errno));\newline	}\newline	if (gid &gt 0) {\newline		umask(oldmode);\newline	}\newline	return fd;\newline}\newline","opens a PF_UNIX socket and returns the file\newline descriptor (&gt0) on success, -1 otherwise.\newline Also, if the gid parameter is &gt 0 it changes\newline permissions on the file in order to let the privided\newline group read/write to the socket\newline \newline",4139580,lpty.c,"static int lpty_hasproc(lua_State *L)\newline{\newline	lPty *pty = lpty_checkLPty(L, 1);\newline	int hasit = _lpty_hasrunningchild(pty);\newline	lua_pushboolean(L, hasit);\newline	return 1;\newline}\newline","lpty_hasproc\newline \newline Check wether this pty has an active process attached to it.\newline \newline Arguments:\newline L Lua State\newline \newline Lua Stack:\newline 1 lpty userdata\newline \newline Lua Returns:\newline +1 true if there is an active subprocess, false if not.\newline \newline",809415,common.c,"void x264_picture_clean( x264_picture_t *pic )\newline{\newline    x264_free( pic-&gtimg.plane[0] );\newline\newline    /* just to be safe */\newline    memset( pic, 0, sizeof( x264_picture_t ) );\newline}\newline",\newline x264_picture_clean:\newline \newline,1480841,sasl.c,"static char *_add_key(xmpp_ctx_t *ctx, hash_t *table, const char *key, \newline		      char *buf, int *len, int quote)\newline{\newline    int olen,nlen;\newline    int keylen, valuelen;\newline    const char *value, *qvalue;\newline    char *c;\newline\newline    /* allocate a zero-length string if necessary */\newline    if (buf == NULL) {\newline	buf = xmpp_alloc(ctx, 1);\newline	buf[0] = &#039\\0&#039;\newline    }\newline    if (buf == NULL) return NULL;\newline\newline    /* get current string length */\newline    olen = strlen(buf);\newline    value = hash_get(table, key);\newline    if (value == NULL) {\newline	xmpp_error(ctx, &quotSASL&quot, &quotcouldn&#039t retrieve value for &#039%s&#039&quot, key);\newline	value = &quot&quot;\newline    }\newline    if (quote) {\newline	qvalue = _make_quoted(ctx, value);\newline    } else {\newline	qvalue = value;\newline    }\newline    /* added length is key + &#039=&#039 + value */\newline    /*   (+ &#039,&#039 if we&#039re not the first entry   */\newline    keylen = strlen(key);\newline    valuelen = strlen(qvalue);\newline    nlen = (olen ? 1 : 0) + keylen + 1 + valuelen + 1;\newline    buf = xmpp_realloc(ctx, buf, olen+nlen);\newline\newline    if (buf != NULL) {\newline	c = buf + olen;\newline	if (olen) *c++ = &#039,&#039;\newline	memcpy(c, key, keylen); c += keylen;\newline	*c++ = &#039=&#039;\newline	memcpy(c, qvalue, valuelen); c += valuelen;\newline	*c++ = &#039\\0&#039;\newline    }\newline\newline    if (quote) xmpp_free(ctx, (char *)qvalue);\newline\newline    return buf;\newline}\newline","append &#039key=&quotvalue&quot&#039 to a buffer, growing as necessary \newline",4378193,select_handlers.c,"static gboolean focus_path(GtkTreeView * view, GdkEventExpose * event,\newline                           GtkTreePath * path)\newline{\newline    gtk_tree_view_scroll_to_cell(\newline        view, path, NULL /* don&#039t scroll to a particular column */,\newline        TRUE /* please align */, 0.5 /* center row */, 0 /* left column */);\newline    g_signal_handlers_disconnect_by_func(view, focus_path, path);\newline    gtk_tree_path_free(path);\newline    return FALSE; /* propagate the event */\newline}\newline","Focus the given GtkTreeView to the given GtkTreePath.\newline \newline This will scroll and move the cursor appropriately.\newline \newline This function is required because there is no point in scrolling the widget\newline before it has been realized (= shown on screen) and so we need to do it\newline in a callback connected after the default &quotexpose-event&quot signal.\newline See #340007 for more details.\newline \newline Once run, it will disconnect itself from the signal and free the given path.\newline \newline @param view the widget where the focus will be set\newline @param path path to the row that will be selected\newline @return FALSE to propage the event further\newline \newline",512106,maths.h,"inline static float delerp(float y0, float y1, float y)\newline{\newline     return (y - y0) / (y1 - y);\newline}\newline",return the distance between y0 and y1 given some value y \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,,on,on,,,,,,on,on,,,,,on,,,,,,on,,,,,,,,,,,,,,,,,,,,,,"Receives data into the ""long single"" pack",{},{},"Returns: 1 for filesystems like proc, sysfs, ... or 0.",The string may be a valid GID or a valid groupname.,Handle a verilog directive or macro lookup.,if the gid parameter is > 0 it changes,Check wether this pty has an active process attached to it.,{},{},This will scroll and move the cursor appropriately.,"return 0 on success, -1 otherwise",return the distance between y0 and y1 given some value y,Load an image from the named file.,{},Copies one element into the designated field.,get the number of bytes currently in buffer,Ensure that we have a given namespace.,Load the preferences for a particular account / username,Maps the menuitem lists into pickup values.,{},x,
3WUVMVA7OB30SO8UKU0CL46K0REZAS,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:46 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:46 PDT 2019,,,3DR23U6WE5E9J9D0K9IHKIRJI59TE4,AITP2LUW8GPB,Submitted,Fri Apr 26 12:49:13 PDT 2019,Fri Apr 26 13:29:18 PDT 2019,Sun Apr 28 13:29:18 PDT 2019,,,,2405,100% (62/62),100% (62/62),0% (0/0),1562924,node.c,const char *iso_symlink_get_dest(const IsoSymlink *link)\newline{\newline    return link-&gtdest;\newline}\newline,\newline Get the destination of a node.\newline The returned string belongs to the node and should not be modified nor\newline freed. Use strdup if you really need your own copy.\newline \newline,6058198,lemon.c,"void FindLinks(struct lemon *lemp)\newline{\newline  int i;\newline  struct config *cfp, *other;\newline  struct state *stp;\newline  struct plink *plp;\newline\newline  /* Housekeeping detail:\newline  ** Add to every propagate link a pointer back to the state to\newline  ** which the link is attached. */\newline  for(i=0; i&ltlemp-&gtnstate; i++){\newline    stp = lemp-&gtsorted[i];\newline    for(cfp=stp-&gtcfp; cfp; cfp=cfp-&gtnext){\newline      cfp-&gtstp = stp;\newline    }\newline  }\newline\newline  /* Convert all backlinks into forward links.  Only the forward\newline  ** links are used in the follow-set computation. */\newline  for(i=0; i&ltlemp-&gtnstate; i++){\newline    stp = lemp-&gtsorted[i];\newline    for(cfp=stp-&gtcfp; cfp; cfp=cfp-&gtnext){\newline      for(plp=cfp-&gtbplp; plp; plp=plp-&gtnext){\newline        other = plp-&gtcfp;\newline        Plink_add(&ampother-&gtfplp,cfp);\newline      }\newline    }\newline  }\newline}\newline",\newline Construct the propagation links\newline \newline,6637946,queue.c,"t_list		*init_queue(void)\newline{\newline  int		nb;\newline  t_list	*queue;\newline\newline  if (!(queue = calloc(QUEUE_SIZE, sizeof(t_list))))\newline    return (0);\newline  for (nb=0; nb &lt QUEUE_SIZE-1; nb++)\newline    queue[nb].next = &ampqueue[nb+1];\newline  queue[QUEUE_SIZE-1].next = NULL;\newline\newline  return (queue);\newline}\newline",\newline @brief initialize client messages queue\newline \newline,5178980,html_element_description.c,"static VALUE implied_start_tag_eh(VALUE self)\newline{\newline  htmlElemDesc * description;\newline  Data_Get_Struct(self, htmlElemDesc, description);\newline\newline  if(description-&gtstartTag) return Qtrue;\newline  return Qfalse;\newline}\newline",\newline call-seq:\newline implied_start_tag?\newline \newline Can the start tag be implied for this tag?\newline \newline,773035,libdevmapper-event.c,"static int _init_client(char *dmeventd_path, struct dm_event_fifos *fifos)\newline{\newline	if (!_start_daemon(dmeventd_path, fifos))\newline		return_0;\newline\newline	return dm_event_daemon_init_fifos(fifos);\newline}\newline",Initialize client. \newline,878371,lanplus_crypt_impl.c,"int lanplus_seed_prng(uint32_t bytes)\newline{\newline	if (! RAND_load_file(&quot/dev/urandom&quot, bytes))\newline		return 1;\newline	else\newline		return 0;\newline}\newline",\newline lanplus_seed_prng\newline \newline Seed our PRNG with the specified number of bytes from /dev/random\newline \newline param bytes specifies the number of bytes to read from /dev/random\newline \newline returns 0 on success\newline 1 on failure\newline \newline,804443,rawsock-pcapfile.c,"static unsigned PCAP16(unsigned byte_order, const unsigned char *buf)\newline{\newline    switch (byte_order) {\newline    case CAPFILE_BIGENDIAN: return buf[0]*256 + buf[1];\newline    case CAPFILE_LITTLEENDIAN: return buf[1]*256 + buf[0];\newline    default: return (unsigned)0xa3a3;\newline    }\newline}\newline","Read a 16-bit value from a capture file, depending upon the byte\newline order within that file \newline",5289347,eap_methods.c,"const char * eap_get_name(int vendor, EapType type)\newline{\newline	struct eap_method *m;\newline	for (m = eap_methods; m; m = m-&gtnext) {\newline		if (m-&gtvendor == vendor &amp&amp m-&gtmethod == type)\newline			return m-&gtname;\newline	}\newline	return NULL;\newline}\newline","\newline eap_get_name - Get EAP method name for the given EAP type\newline @vendor: EAP Vendor-Id (0 = IETF)\newline @type: EAP method type\newline Returns: EAP method name, e.g., TLS, or %NULL if not found\newline \newline This function maps EAP type numbers into EAP type names based on the list of\newline EAP methods included in the build.\newline \newline",4670491,spiceqxl_audio.c,"static inline void fifo_data_added(struct fifo_data *f, int n)\newline{\newline    f-&gtadd_to = (f-&gtadd_to + n) % f-&gtsize;\newline    f-&gtlen += n;\newline}\newline","We maintain a ring buffer for each file we are reading from;\newlinethese helper functions facilitate adding data to the buffer,\newlineand removing it. \newline",4487927,g_combat.c,"static int catchup_damage(int damage, int attacker_points, int target_points) {\newline    int newdamage;\newline    if(g_catchup.integer &lt= 0 )\newline        return damage;\newline    //Reduce damage\newline    if(attacker_points&lt=target_points+5)\newline        return damage; //Never reduce damage if only 5 points ahead.\newline\newline    newdamage=damage-((attacker_points-target_points-5) * (g_catchup.integer*damage))/100;\newline    if(newdamage&ltdamage/2)\newline        return damage/2;\newline    return newdamage;\newline}\newline",\newlinecatchup_damage\newline \newline,760321,ares_gethostbyname.c,"static int get_address_index(const struct in_addr *addr,\newline                             const struct apattern *sortlist,\newline                             int nsort)\newline{\newline  int i;\newline\newline  for (i = 0; i &lt nsort; i++)\newline    {\newline      if (sortlist[i].family != AF_INET)\newline        continue;\newline      if (sortlist[i].type == PATTERN_MASK)\newline        {\newline          if ((addr-&gts_addr &amp sortlist[i].mask.addr4.s_addr)\newline              == sortlist[i].addrV4.s_addr)\newline            break;\newline        }\newline      else\newline        {\newline          if (!ares__bitncmp(&ampaddr-&gts_addr, &ampsortlist[i].addrV4.s_addr,\newline                             sortlist[i].mask.bits))\newline            break;\newline        }\newline    }\newline  return i;\newline}\newline",Find the first entry in sortlist which matches addr. Return nsort\newline if none of them match.\newline \newline,5502292,ldo.c,"static int call_errfunc (lua_State *L) {\newline  CallInfo *ci;\newline  for (ci = L-&gtci; ci &gt L-&gtbase_ci &amp&amp ci-&gterrfunc == 0; ci--) ;\newline  if (ci-&gterrfunc &gt= 2) {\newline    StkId errfunc = ci-&gtbase + (ci-&gterrfunc - 2);\newline    if (!ttisfunction(errfunc)) return LUA_ERRERR;\newline    setobjs2s(L, L-&gttop, L-&gttop - 1);  /* move argument */\newline    setobjs2s(L, L-&gttop - 1, errfunc);  /* push function */\newline    incr_top(L);\newline    luaD_call(L, L-&gttop - 2, 1, LUA_NOYIELD | LUA_NOVPCALL);  /* call it */\newline  }\newline  return LUA_ERRRUN;\newline}\newline",search for an error handler in the frame stack and call it \newline,3634597,simpleskeleton.cpp,"bool SimpleSkeleton::initProperties()\newline{\newline    DefaultDevice::initProperties();\newline\newline    // This is the default driver skeleton file location\newline    // Convention is: drivername_sk_xml\newline    // Default location is /usr/share/indi\newline    const char *skelFileName = &quot/usr/share/indi/tutorial_four_sk.xml&quot;\newline    struct stat st;\newline\newline\newline    char *skel = getenv(&quotINDISKEL&quot);\newline    if (skel)\newline        buildSkeleton(skel);\newline    else if (stat(skelFileName,&ampst) == 0)\newline        buildSkeleton(skelFileName);\newline    else\newline        IDLog(&quotNo skeleton file was specified. Set environment variable INDISKEL to the skeleton path and try again.\\n&quot);\newline\newline    // Optional: Add aux controls for configuration, debug &amp simulation that get added in the Options tab\newline    //           of the driver.\newline    addAuxControls();\newline\newline    std::vector&ltINDI::Property *&gt *pAll = getProperties();\newline\newline    // Let&#039s print a list of all device properties\newline    for (int i=0; i &lt pAll-&gtsize(); i++)\newline        IDLog(&quotProperty #%d: %s\\n&quot, i, pAll-&gtat(i)-&gtgetName());\newline\newline    return true;\newline}\newline",\newline Initialize all properties &amp set default values.\newline \newline,5196033,ffindex.c,"int ffindex_insert_dir(FILE *data_file, FILE *index_file, size_t *start_offset, char *input_dir_name)\newline{\newline  DIR *dir = opendir(input_dir_name);\newline  if(dir == NULL)\newline  {\newline    fferror_print(__FILE__, __LINE__, __func__, input_dir_name);\newline    return -1;\newline  }\newline\newline  size_t input_dir_name_len = strnlen(input_dir_name, FILENAME_MAX);\newline  char path[PATH_MAX];\newline  strncpy(path, input_dir_name, NAME_MAX);\newline  if(input_dir_name[input_dir_name_len - 1] != &#039/&#039)\newline  {\newline    path[input_dir_name_len] = &#039/&#039;\newline    input_dir_name_len += 1;\newline  }\newline\newline  size_t offset = *start_offset;\newline  struct dirent *entry;\newline  while((entry = readdir(dir)) != NULL)\newline  {\newline    if(entry-&gtd_name[0] == &#039.&#039)\newline      continue;\newline    strncpy(path + input_dir_name_len, entry-&gtd_name, NAME_MAX);\newline    struct stat sb;\newline    if(stat(path, &ampsb) == -1)\newline      fferror_print(__FILE__, __LINE__, __func__, path);\newline    if(!S_ISREG(sb.st_mode))\newline      continue;\newline    ffindex_insert_file(data_file, index_file, &ampoffset, path, entry-&gtd_name);\newline  }\newline  closedir(dir);\newline\newline  /* update return value */\newline  *start_offset = offset;\newline\newline  return 0;\newline}\newline",Insert all files from directory into ffindex \newline,2153266,entry.c,"static void _destroyCDKEntry (CDKOBJS *object)\newline{\newline   if (object != 0)\newline   {\newline      CDKENTRY *entry = (CDKENTRY *)object;\newline\newline      cleanCdkTitle (object);\newline      freeChtype (entry-&gtlabel);\newline      freeChar (entry-&gtinfo);\newline\newline      /* Delete the windows. */\newline      deleteCursesWindow (entry-&gtfieldWin);\newline      deleteCursesWindow (entry-&gtlabelWin);\newline      deleteCursesWindow (entry-&gtshadowWin);\newline      deleteCursesWindow (entry-&gtwin);\newline\newline      /* Clean the key bindings. */\newline      cleanCDKObjectBindings (vENTRY, entry);\newline\newline      /* Unregister this object. */\newline      unregisterCDKObject (vENTRY, entry);\newline   }\newline}\newline",\newline This destroys an entry widget.\newline \newline,2022086,nntp.c,"int nntp_get_current_article(int fd) {\newline	if (send_cmd(fd, &quotARTICLE&quot) == -1)\newline		return -1;\newline	if (recv_response(fd) == 220)\newline		return 0;\newline	return -1;\newline}\newline","\newline Ask for the head and body of the current article. Return 0 for OK\newline (read the text with nntp_next_line), or -1 for error.\newline \newline",263803,disasmview.c,"static gboolean tilem_disasm_view_move_cursor(GtkTreeView *tv,\newline                                              GtkMovementStep step,\newline                                              gint count)\newline{\newline	TilemDisasmView *dv;\newline\newline	g_return_val_if_fail(TILEM_IS_DISASM_VIEW(tv), FALSE);\newline	dv = TILEM_DISASM_VIEW(tv);\newline\newline	if (!dv-&gtdbg-&gtemu-&gtcalc)\newline		return FALSE;\newline\newline	switch (step) {\newline	case GTK_MOVEMENT_DISPLAY_LINES:\newline		if (count &lt 0) {\newline			if (move_up_lines(dv, -count))\newline				return TRUE;\newline		}\newline		else {\newline			if (move_down_lines(dv, count))\newline				return TRUE;\newline		}\newline		break;\newline\newline	case GTK_MOVEMENT_PARAGRAPHS:\newline	case GTK_MOVEMENT_PARAGRAPH_ENDS:\newline	case GTK_MOVEMENT_PAGES:\newline		/* FIXME: might be better to move by actual &quotpages&quot of code */\newline		move_bytes(dv, count * 0x100);\newline		return TRUE;\newline\newline	case GTK_MOVEMENT_BUFFER_ENDS:\newline		move_bytes(dv, count * 0x4000);\newline		return TRUE;\newline\newline	case GTK_MOVEMENT_LOGICAL_POSITIONS:\newline	case GTK_MOVEMENT_VISUAL_POSITIONS:\newline	case GTK_MOVEMENT_WORDS:\newline	case GTK_MOVEMENT_DISPLAY_LINE_ENDS:\newline	case GTK_MOVEMENT_HORIZONTAL_PAGES:\newline	default:\newline		break;\newline	}\newline\newline	return (*GTK_TREE_VIEW_CLASS(parent_class)-&gtmove_cursor)(tv, step, count);\newline}\newline",Move the cursor (action signal) \newline,5940729,japanese.c,"void Euc2Sjis(char *buf, int max_len)\newline{\newline        if (buf == NULL) return;\newline        if (max_len &lt= 0) return;\newline        Euc2SjisCpy(buf, buf, max_len);\newline}\newline",\newlineconvert euc to sjis.\newlinesize of buf must be more than max_len.\newlinefunction simply calls Euc2SjisCpy().\newlinethis function exists for symmetry.\newline \newline,2011473,set_options.c,"static void cmaps_set_current( Cmaplist *cmlist )\newline{\newline	int	ncmaps, ii;\newline	char	*cmap_name;\newline	int	cmap_enabled;\newline	XColor	*color_list;\newline\newline	ncmaps = x_n_colormaps( cmlist );\newline	if( ncmaps == 0 ) return;\newline\newline	for( ii=0; ii&ltncmaps; ii++ ) {\newline		/* Get colormap name and whether or not it is enabled */\newline		x_colormap_info( cmlist, ii, &ampcmap_name, &ampcmap_enabled, &ampcolor_list );\newline		XtVaSetValues( opt_cbsel_name_widget[ii], \newline			XtNlabel, cmap_name, \newline			XtNwidth, CMAP_NAME_WIDTH,\newline			NULL );\newline\newline		/* Set the little colorbar image to the correct ximage */\newline		draw_cbar_ximage( ii, cbar_ximages[ii] );\newline\newline		/* Set whether or not this colormap is enabled */\newline		XtVaSetValues( opt_cbsel_enable_widget[ii], \newline			XtNstate, cmap_enabled, \newline			NULL );\newline		}\newline}\newline","Give the LOCAL COPY of the global colormap list (which we may modify during the course of this\newline funcation, and possibly discard if the user selects &quotcancel&quot instead of &quotOK&quot), this sets the\newline widget names and colormaps to reflect that local colormap list (&quotcmlist&quot).\newline \newline",39015,io.c,"int writen(int fd, char *ptr, int nbytes) {\newline  int nleft, nwritten;\newline\newline  nleft=nbytes;\newline  while (nleft&gt0) {\newline    nwritten=write(fd, ptr, nleft);\newline    if (nwritten&lt0) return(nwritten);\newline    nleft-=nwritten;\newline    ptr+=nwritten;\newline  }\newline  return(nbytes-nleft);\newline}\newline",\newline writen - write n bytes to network socket\newline \newline INPUT: fd - socket file descriptor\newline ptr - string to send\newline nbytes - number of bytes to send\newline \newline RETURN: number of actual written bytes\newline \newline this function is derived from example code from\newline &quotUnix Networking Programming&quot by W. R. Stevens\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,,on,,,,,,,,,,,,,,on,,,,,on,,,,,,,,,,,,,,,,,,,,,,Use strdup if you really need your own copy.,{},Find the first entry in sortlist which matches addr.,search for an error handler in the frame stack and call it,Initialize all properties & set default values.,Insert all files from directory into ffindex,This destroys an entry widget.,Ask for the head and body of the current article.,Move the cursor,convert euc to sjis.,"this sets the
widget names",Construct the propagation links,this function is derived from example code from,Load an image from the named file.,initialize client messages queue,{},Initialize client.,Seed our PRNG with the specified number of bytes from /dev/random,"Read a 16-bit value from a capture file,",This function maps EAP type numbers,{},x,
375VMB7D4JJCV5MW403SBAB0PH9IDG,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:19 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:19 PDT 2019,,,3Q5C1WP23M18E68Y7P54AI2BDTJ152,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:44 PDT 2019,Fri Apr 26 13:22:00 PDT 2019,Sun Apr 28 13:22:00 PDT 2019,,,,1996,100% (62/62),100% (62/62),0% (0/0),1257879,rpc_clntout.c,"	if (newstyle &amp&amp args2) {\newline		f_print(fout, &quot\\t%s&quot, proc-&gtargs.argname);\newline		f_print(fout, &quot arg;\\n&quot);\newline	}\newline","For new style with multiple arguments, need a structure in which\newline to stuff the arguments. \newline",4157210,listener.c,"static void init_signals() {\newline    //Handle SIGINT and SIGTERM\newline    signal(SIGINT, quit);\newline    signal(SIGTERM, quit);\newline\newline    //Prints queue status with this signal\newline    signal(SIGUSR1, print_queue_status);\newline}\newline",\newline Set quit action on SIGTERM and SIGINT\newline and prints the internal status on SIGUSR1\newline \newline,4319122,iso_manip.c,"int Exprtest_match_disk_name(struct XorrisO *xorriso, struct ExprtesT *ftest,\newline                             IsoNode *node, int flag)\newline\newline{\newline int ret;\newline char *disk_path= NULL, *npt;\newline regmatch_t name_match;\newline char *arg1;\newline void *arg2;\newline\newline Xorriso_alloc_meM(disk_path, char, SfileadrL);\newline\newline ret= Xorriso_retrieve_disk_path(xorriso, node, disk_path, 0);\newline if(ret &lt= 0)\newline   {ret= 0; goto ex;}\newline if(flag &amp 1) {\newline   if(strcmp(disk_path, ftest-&gtarg1) == 0)\newline     {ret= 1; goto ex;}\newline   {ret= 0; goto ex;}\newline }\newline arg1= (char *) ftest-&gtarg1;\newline arg2= ftest-&gtarg2;\newline npt= strrchr(disk_path, &#039/&#039);\newline if(npt != NULL)\newline   npt++;\newline else\newline   npt= disk_path;\newline if(flag &amp 2) {\newline   ret= ! regexec(arg2, npt, 1, &ampname_match, 0);\newline } else {\newline   ret= (strcmp(arg1, npt) == 0);\newline }\newlineex:;\newline Xorriso_free_meM(disk_path);\newline return(ret);\newline}\newline",flag bit0= perform -disk_path rather than -disk_name\newlinebit0= use_pattern\newline \newline,2688519,vtpm_cmd_handler.c,"static TPM_RESULT find_vtpm_khash(int domid, struct tpm_opaque *opq)\newline{\newline	char buf[128];\newline	int i, rv;\newline	buf[127] = 0;\newline	rv = tpmback_get_peercontext(opq-&gtdomid, opq-&gthandle, buf, sizeof(buf) - 1);\newline	if (rv &lt 0)\newline		return TPM_FAIL;\newline\newline	sha1((void*)buf, strlen(buf), opq-&gtkern_hash);\newline\newline	/*\newline	 * As a hack to support the use of the XSM user field as an optional\newline	 * wildcard, check the hash against the group here. If it fails, replace\newline	 * the user field with a &quot*&quot and return the hash of that value.\newline	 */\newline	for(i=0; i &lt be32_native(opq-&gtgroup-&gtseal_bits.nr_kerns); i++) {\newline		if (!memcmp(opq-&gtgroup-&gtseal_bits.kernels[i].bits, opq-&gtkern_hash, 20)) {\newline			return TPM_SUCCESS;\newline		}\newline	}\newline\newline	char* upos = strchr(buf, &#039:&#039);\newline	if (upos == NULL || upos == buf)\newline		return TPM_SUCCESS;\newline\newline	upos--;\newline	upos[0] = &#039*&#039;\newline\newline	sha1((void*)upos, strlen(upos), opq-&gtkern_hash);\newline	return TPM_SUCCESS;\newline}\newline","\newline Instead of using a kernel hash, which requires a trusted domain builder to\newline report, use the XSM label as a substitute.\newline \newline",3355352,test-rilmodem-cb.c,"static void test_call_barring_func(gconstpointer data)\newline{\newline	const struct cb_data *sd = data;\newline	struct rilmodem_cb_data *rsd;\newline\newline	ril_call_barring_init();\newline\newline	rsd = g_new0(struct rilmodem_cb_data, 1);\newline\newline	rsd-&gttest_data = sd;\newline\newline	rsd-&gtserverd = rilmodem_test_server_create(&ampserver_connect_cb,\newline								&ampsd-&gtrtd, rsd);\newline\newline	rsd-&gtril = g_ril_new(RIL_SERVER_SOCK_PATH, OFONO_RIL_VENDOR_AOSP);\newline	g_assert(rsd-&gtril != NULL);\newline\newline	mainloop = g_main_loop_new(NULL, FALSE);\newline\newline	g_main_loop_run(mainloop);\newline	g_main_loop_unref(mainloop);\newline\newline	cbdriver-&gtremove(rsd-&gtcb);\newline	g_ril_unref(rsd-&gtril);\newline	g_free(rsd);\newline\newline	rilmodem_test_server_close(rsd-&gtserverd);\newline\newline	ril_call_barring_exit();\newline}\newline",\newline This unit test:\newline - does some test data setup\newline - configures a dummy server socket\newline - creates a new gril client instance\newline - triggers a connect to the dummy\newline server socket\newline - starts a mainloop\newline \newline,2790880,lorenz.c,"void calc_deriv ( double position[3], double deriv[3] )\newline{\newline  /* Calculate the Lorenz attractor derivatives */\newline  deriv[0] = sigma * ( position[1] - position[0] ) ;\newline  deriv[1] = ( r + position[2] ) * position[0] - position[1] ;\newline  deriv[2] = -position[0] * position[1] - b * position[2] ;\newline}\newline",The Lorenz Attractor \newline,6150934,tunnel.c,"int tunnel_up(const char *dev)\newline{\newline	struct ifreq ifr;\newline	int fd;\newline\newline	strncpy(ifr.ifr_name, dev, IFNAMSIZ);\newline	fd = socket(AF_INET, SOCK_DGRAM, 0);\newline	if (fd &lt 0)\newline		return -1;\newline\newline	if (ioctl(fd, SIOCGIFFLAGS, &ampifr)) {\newline		close(fd);\newline		return -1;\newline	}\newline	ifr.ifr_flags |= IFF_UP;\newline\newline	if (ioctl(fd, SIOCSIFFLAGS, &ampifr)) {\newline		close(fd);\newline		return -1;\newline	}\newline	close(fd);\newline	return 0;\newline}\newline",\newline Sets tunnel interface to UP\newline \newline,6077889,dbd_pgsql.c,"char *_unescape_hex_binary(char* raw, size_t in_len, size_t* out_len) {\newline  size_t i;\newline  int in_pair = 0;\newline  int last_nibble = 0;\newline  char *outstring;\newline  char *end_of_outstring;\newline  int have_backslash = 0;\newline  int have_singlequote = 0;\newline  char tempchar;\newline\newline  /* algorithm borrowed and modified from:\newline     http://pqxx.org/development/libpqxx/browser/trunk/src/binarystring.cxx\newline  */\newline\newline  if ((outstring = malloc(((in_len-2)/2)+1)) == NULL) {\newline    return NULL;\newline  }\newline  end_of_outstring = outstring;\newline\newline  for (i=2; i&ltin_len; ++i) {\newline    const unsigned char c = raw[i];\newline    if (isspace(c)) {\newline      if (in_pair) {\newline	/* &quotEscaped binary data is malformed.&quot */\newline      }\newline    }\newline    else if (!isxdigit(c)) {\newline      /* &quotEscaped binary data contains invalid characters.&quot */\newline    }\newline    else {\newline      const int nibble = (isdigit(c) ? _digit_to_number(c) : (10 + tolower(c) - &#039a&#039));\newline      if (in_pair) {\newline	tempchar = (char)((last_nibble&lt&lt4) | nibble);\newline	if (tempchar == &#039\\\\&#039 &amp&amp have_backslash) {\newline	  /* skip second consecutive backslash */\newline	  have_backslash = 0;\newline	}\newline	else if (tempchar == &#039\\&#039&#039 &amp&amp have_singlequote) {\newline	  /* skip second consecutive single quote */\newline	  have_singlequote = 0;\newline	}\newline	else {\newline	  if (tempchar == &#039\\\\&#039) {\newline	    have_backslash = 1;\newline	  }\newline	  else if (tempchar == &#039\\&#039&#039) {\newline	    have_singlequote = 1;\newline	  }\newline	  else {\newline	    have_backslash = 0;\newline	    have_singlequote = 0;\newline	  }\newline	  *end_of_outstring = tempchar;\newline	  end_of_outstring++;\newline	}\newline      }\newline      else {\newline	last_nibble = nibble;\newline      }\newline      in_pair = !in_pair;\newline    }\newline  }\newline  *end_of_outstring = &#039\\0&#039;\newline  *out_len = end_of_outstring-outstring;\newline  return outstring;\newline}\newline",this function reverts the changes done by PQescapeByteaConn to a\newlinebinary string. libpq does not provide such a function. Returns the\newlineresult as a malloc&#039ed string which must be freed by the caller. The\newlineoutput string is in the BYTEA escape format with single backslashes\newlineand single single quotes. It must be post-processed by\newlinePQunescapeBytea() to obtain true binary data\newline \newline,6642249,hmm_bci.c,"void fms_bci(double lambda, double *f, int m, double tol, int maxit)\newline{\newline    int i,k;\newline    double diff;\newline\newline    for (i=0; i&lt2*m+1; i++) {\newline        k=1;\newline        f[i]=0;\newline        if (i &lt= m) {\newline            f[i] = dpois((double)(k*(m+1)+i), lambda, 0);\newline\newline            for(k=2; k&ltmaxit; k++) {\newline                diff = dpois((double)(k*(m+1)+i), lambda, 0);\newline                f[i] += diff;\newline\newline                if(diff &lt tol) break;\newline            }\newline        }\newline        else /* i&ltm */ {\newline            f[i] += dpois((double)(k*(m+1)+(m-i)), lambda, 0);\newline\newline            for(k=2; k&ltmaxit; k++) {\newline                diff = dpois((double)(k*(m+1)+(m-i)), lambda, 0);\newline                f[i] += diff;\newline\newline                if(diff &lt tol) break;\newline            }\newline        }\newline        f[i] *= 0.5;\newline    }\newline}\newline",\newline fms_bci: this function calculates the sum to infinity part of the\newline transition probabilities for a given lambda_t\newline \newline f should have length 2m+1\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,6582003,compile.c,"static void dcc_perhaps_adjust_cpp_where_and_protover(\newline    char *input_fname,\newline    struct dcc_hostdef *host,\newline    char *discrepancy_filename)\newline{\newline    /* It&#039s unfortunate that the variable that controls preprocessing is in the\newline       &quothost&quot datastructure. See elaborate complaint in dcc_build_somewhere. */\newline\newline    /* Check whether there has been too much trouble running distcc-pump during\newline       this build. */\newline    if (dcc_read_number_discrepancies(discrepancy_filename) &gt=\newline        max_discrepancies_before_demotion) {\newline        /* Give up on using distcc-pump */\newline        host-&gtcpp_where = DCC_CPP_ON_CLIENT;\newline        dcc_get_protover_from_features(host-&gtcompr,\newline                                       host-&gtcpp_where,\newline                                       &amphost-&gtprotover);\newline    }\newline\newline    /* Don&#039t do anything silly for already preprocessed files. */\newline    if (dcc_is_preprocessed(input_fname)) {\newline        /* Don&#039t subject input file to include analysis. */\newline        rs_log_warning(&quotcannot use distcc_pump on already preprocessed file&quot\newline                       &quot (such as emitted by ccache)&quot);\newline        host-&gtcpp_where = DCC_CPP_ON_CLIENT;\newline        dcc_get_protover_from_features(host-&gtcompr,\newline                                       host-&gtcpp_where,\newline                                       &amphost-&gtprotover);\newline    }\newline    /* Environment variables CPATH and two friends are hidden ways of passing\newline     * -I&#039s. Beware! */\newline    if (getenv(&quotCPATH&quot) || getenv(&quotC_INCLUDE_PATH&quot)\newline        || getenv(&quotCPLUS_INCLUDE_PATH&quot)) {\newline        rs_log_warning(&quotcannot use distcc_pump with any of environment&quot\newline                       &quot variables CPATH, C_INCLUDE_PATH or CPLUS_INCLUDE_PATH&quot\newline                       &quot set, preprocessing locally&quot);\newline        host-&gtcpp_where = DCC_CPP_ON_CLIENT;\newline        dcc_get_protover_from_features(host-&gtcompr,\newline                                       host-&gtcpp_where,\newline                                       &amphost-&gtprotover);\newline    }\newline}\newline","\newline In some cases, it is ill-advised to preprocess on the server. Check for such\newline situations. If they occur, then change protocol version.\newline \newline",4139816,zxcvbn.c,void ZxcvbnUnInit()\newline{\newline    if (DictNodes)\newline        FreeFn(DictNodes);\newline    DictNodes = 0;\newline}\newline,\newline Free the data allocated by ZxcvbnInit().\newline \newline,4224225,gl_common.c,"static void gen_spline_lookup_tex(GLenum unit) {\newline  GLfloat *tex = calloc(4 * LOOKUP_BSPLINE_RES, sizeof(*tex));\newline  GLfloat *tp = tex;\newline  int i;\newline  for (i = 0; i &lt LOOKUP_BSPLINE_RES; i++) {\newline    float x = (float)(i + 0.5) / LOOKUP_BSPLINE_RES;\newline    store_weights(x, tp);\newline    tp += 4;\newline  }\newline  store_weights(0, tex);\newline  store_weights(1, &amptex[4 * (LOOKUP_BSPLINE_RES - 1)]);\newline  mpglActiveTexture(unit);\newline  mpglTexImage1D(GL_TEXTURE_1D, 0, GL_RGBA16, LOOKUP_BSPLINE_RES, 0, GL_RGBA, GL_FLOAT, tex);\newline  mpglTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, 1.0);\newline  mpglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\newline  mpglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\newline  mpglTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);\newline  mpglActiveTexture(GL_TEXTURE0);\newline  free(tex);\newline}\newline",\newline \\brief creates the 1D lookup texture needed for fast higher-order filtering\newline \\param unit texture unit to attach texture to\newline \newline,2702390,block-remus.c,"static inline unsigned int ring_next(struct req_ring* ring, unsigned int pos)\newline{\newline	if (++pos &gt= MAX_REQUESTS * 2 + 1)\newline		return 0;\newline\newline	return pos;\newline}\newline",ring functions \newline,84697,beeplisten.c,static void sbLstnSessFreeLinkedListDummy(sbSessObj *pSess)\newline{\newline	int bShouldNeverBeCalled = 0;\newline\newline	sbSessCHECKVALIDOBJECT(pSess);\newline	sbSessAbort(pSess);\newline}\newline,"\newline This method is used to &quotfree&quot a session. If there is still\newline a valid session pointer in the structure when the tree is\newline deleted, that means something went wrong and we need to get\newline rid of the leftovers. As such, any sessions found are aborted.\newline \newline",1321463,ppc_vec.c,"void ppc_opc_vavguw()\newline{\newline	VECTOR_DEBUG;\newline	int vrD, vrA, vrB;\newline	uint64 res;\newline	PPC_OPC_TEMPL_X(gCPU.current_opc, vrD, vrA, vrB);\newline	int i;\newline	for (i=0; i&lt4; i++) {\newline		res = (uint64)gCPU.vr[vrA].w[i] +\newline			(uint64)gCPU.vr[vrB].w[i] + 1;\newline\newline		gCPU.vr[vrD].w[i] = (res &gt&gt 1);\newline	}\newline}\newline",vavguw Vector Average Unsigned Word\newline v.154\newline \newline,5256324,igsconnection.cpp,"BoardDispatch * IGSConnection::getBoardFromAttrib(QString black_player, unsigned int black_captures, float black_komi, QString white_player, unsigned int white_captures, float white_komi)\newline{\newline	BoardDispatch * board;\newline    QMap&ltunsigned int, class BoardDispatch *&gt::iterator i;\newline    for(i = boardDispatchMap.begin(); i != boardDispatchMap.end(); i++)\newline	{\newline        board = i.value();\newline		if(board-&gtisAttribBoard(black_player, black_captures, black_komi, white_player, white_captures, white_komi))\newline			return board;\newline	}\newline	return NULL;\newline}\newline","Because the IGS protocol is garbage, we have to break encapsulation here\newline and in BoardDispatch \newline",2700789,xl_cmdimpl.c,"static bool freemem(uint32_t domid, libxl_domain_build_info *b_info)\newline{\newline    int rc, retries = 3;\newline    uint64_t need_memkb, free_memkb;\newline\newline    if (!autoballoon)\newline        return true;\newline\newline    rc = libxl_domain_need_memory(ctx, b_info, &ampneed_memkb);\newline    if (rc &lt 0)\newline        return false;\newline\newline    do {\newline        rc = libxl_get_free_memory(ctx, &ampfree_memkb);\newline        if (rc &lt 0)\newline            return false;\newline\newline        if (free_memkb &gt= need_memkb)\newline            return true;\newline\newline        rc = libxl_set_memory_target(ctx, 0, free_memkb - need_memkb, 1, 0);\newline        if (rc &lt 0)\newline            return false;\newline\newline        /* wait until dom0 reaches its target, as long as we are making\newline         * progress */\newline        rc = libxl_wait_for_memory_target(ctx, 0, 10);\newline        if (rc &lt 0)\newline            return false;\newline\newline        retries--;\newline    } while (retries &gt 0);\newline\newline    return false;\newline}\newline","\newline Returns false if memory can&#039t be freed, but also if we encounter errors.\newline Returns true in case there is already, or we manage to free it, enough\newline memory, but also if autoballoon is false.\newline \newline",1629554,qtpropertybrowser.cpp,QtProperty *QtAbstractPropertyManager::createProperty()\newline{\newline    return new QtProperty(this);\newline}\newline,"!\newlineCreates a property.\newlineThe base implementation produce QtProperty instances; Reimplement\newlinethis function to make this manager produce objects of a QtProperty\newlinesubclass.\newline\\sa addProperty(), initializeProperty()\newline \newline",1649212,upnpapi.c,"static int UpnpInitThreadPools(void)\newline{\newline	int ret = UPNP_E_SUCCESS;\newline	ThreadPoolAttr attr;\newline\newline	TPAttrInit(&ampattr);\newline	TPAttrSetMaxThreads(&ampattr, MAX_THREADS);\newline	TPAttrSetMinThreads(&ampattr, MIN_THREADS);\newline	TPAttrSetStackSize(&ampattr, THREAD_STACK_SIZE);\newline	TPAttrSetJobsPerThread(&ampattr, JOBS_PER_THREAD);\newline	TPAttrSetIdleTime(&ampattr, THREAD_IDLE_TIME);\newline	TPAttrSetMaxJobsTotal(&ampattr, MAX_JOBS_TOTAL);\newline\newline	if (ThreadPoolInit(&ampgSendThreadPool, &ampattr) != UPNP_E_SUCCESS) {\newline		ret = UPNP_E_INIT_FAILED;\newline		goto exit_function;\newline	}\newline\newline	if (ThreadPoolInit(&ampgRecvThreadPool, &ampattr) != UPNP_E_SUCCESS) {\newline		ret = UPNP_E_INIT_FAILED;\newline		goto exit_function;\newline	}\newline\newline	if (ThreadPoolInit(&ampgMiniServerThreadPool, &ampattr) != UPNP_E_SUCCESS) {\newline		ret = UPNP_E_INIT_FAILED;\newline		goto exit_function;\newline	}\newline\newlineexit_function:\newline	if (ret != UPNP_E_SUCCESS) {\newline		UpnpSdkInit = 0;\newline		UpnpFinish();\newline	}\newline\newline	return ret;\newline}\newline",!\newline \\brief Initializes the global threadm pools used by the UPnP SDK.\newline \newline \\return UPNP_E_SUCCESS on success or UPNP_E_INIT_FAILED if a mutex could not\newline be initialized.\newline \newline,5143452,gateway.c,"static bool multiGwRulesSgwServerTunnel(bool add) {\newline  return multiGwRunScript(SCRIPT_MODE_SGWSRVTUN, add, server_tunnel_name(), NULL);\newline}\newline","\newline Setup multi-gateway iptables and ip rules for the smart gateway server tunnel.\newline \newline - sgw server tunnel interface (on olsrd start/stop)\newline iptablesExecutable -t mangle -A PREROUTING -i tunl0 -j CONNMARK --restore-mark\newline \newline @param add true to add policy routing, false to remove it\newline @return true when successful\newline \newline",,,,,,,on,on,,,,,,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,"need a structure in which
to stuff the arguments.",Load an image from the named file.,"If they occur, then change protocol version.",Free the data allocated by ZxcvbnInit().,creates the 1D lookup texture needed for fast higher-order filtering,ring functions,{},{},"we have to break encapsulation here
and in BoardDispatch","Returns false if memory can't be freed,",Creates a property.,Set quit action on SIGTERM and SIGINT,\brief Initializes the global threadm pools used by the UPnP SDK.,{},flag bit0= perform -disk_path rather than -disk_name,use the XSM label as a substitute.,does some test data setup,{},Sets tunnel interface to UP,"this function reverts the changes done by PQescapeByteaConn to a
binary string.","this function calculates the sum to infinity part of the
transition probabilities",x,
32FESTC2NHQ7Z4BIYLXVA7HTYCKCUI,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:16 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:16 PDT 2019,,,32M8BPYGATMHU9TGWS916EAMK46GIP,AITP2LUW8GPB,Submitted,Fri Apr 26 13:06:47 PDT 2019,Fri Apr 26 13:40:16 PDT 2019,Sun Apr 28 13:40:16 PDT 2019,,,,2009,100% (62/62),100% (62/62),0% (0/0),3923027,group.c,"void acr_group_steal_element(Acr_Group group, Acr_Element element)\newline{\newline   int element_id;\newline   Acr_Element next_element, prev_element;\newline\newline   /* Get element id from element */\newline   element_id = acr_get_element_element(element);\newline\newline   /* Search for the appropriate location */\newline   prev_element = NULL;\newline   next_element = group-&gtlist_head;\newline   while ((next_element != NULL) &amp&amp \newline          (acr_get_element_element(next_element) != element_id)) {\newline      prev_element = next_element;\newline      next_element = acr_get_element_next(next_element);\newline   }\newline\newline   /* Check for an existing element and get rid of it */\newline   if ((next_element != NULL) &amp&amp\newline       (acr_get_element_element(next_element) == element_id)) {\newline\newline      /* Set pointers and get rid of the old element */\newline      steal_element(group, next_element, prev_element);\newline\newline   }\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_group_steal_element\newline@INPUT : group\newlineelement - the caller must pass an element so that we\newlineknow that they have a handle to it.\newline@OUTPUT : (none)\newline@RETURNS : (nothing)\newline@DESCRIPTION: Remove an element from a group without deleting it.\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : November 6, 1998 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline",1581460,sailworker.cpp,"real CSailWorker::LeechLength( const real &amph )\newline{\newline    unsigned int i=0, imax=20;\newline    CPoint3d p1, p2, p3;\newline    real l=0, h1=0;\newline\newline    p1 = clew;\newline\newline    for (i = 1; i &lt= imax; i++)\newline    {\newline        h1= real(i) / imax;\newline        p2 = clew + leechV * (h * h1);\newline        p3 = Zpoint( EdgeIntersect( LEECH_EDGE, p2 , leechVP) );\newline        l = l + CVector3d(p3 - p1).norm();\newline        // printf (&quotstep = %f - p2.y = %f - leech length = %f \\n&quot, h1, p2.y(), l);\newline        p1 = p3;\newline    }\newline    return ( l );\newline}\newline",\newline Routine for computing the actual length of the leech edge\newline up to a given relative heigth on straight leech line.\newline \newline @author Robert Laine alias Sailcuter\newline \newline,2175553,ncdf3.c,"SEXP R_nc4_get_vara_numvarid( SEXP sx_nc, SEXP sx_varid, SEXP sx_start, SEXP sx_count ) \newline{\newline	int 	varid, ncid, ndims, len_start, len_count, i, j, ierr,\newline		start_arg[MAX_NC_DIMS], count_arg[MAX_NC_DIMS],\newline		*data_addr_i, missval_i, ndims_cgt1;\newline	SEXP 	rv_data = R_NilValue /* -Wall */, sx_ncdf_var, sx_dim;\newline	size_t	start[MAX_NC_DIMS], count[MAX_NC_DIMS], varsize[MAX_NC_DIMS], tot_var_size,\newline		i_szt;\newline	double	*data_addr_d, missval_d, missval_tol;\newline	nc_type	vartype;\newline\newline	/*--------------------------------------------------------------------------- \newline	 * On entry, the following are guaranteed to be integers:\newline	 *	varid\newline	 *	*start\newline	 *	*count\newline	 *\newline	 * Note that varid, start, and/or count could be a single &#039-1&#039 if the user\newline	 * has not specified the start and count to use.\newline	 * &#039sx_nc&#039 is guaranteed to be the full object of class &#039ncdf&#039.\newline	 *----------------------------------------------------------------------------*/\newline\newline\newline	varid = INTEGER(sx_varid)[0];\newline	ncid  = INTEGER(R_ncu4_getListElement( sx_nc, &quotid&quot ))[0];\newline	sx_ncdf_var = R_ncu4_getListElement( sx_nc, &quotvar&quot );\newline\newline	/*-----------------------------------------------------------------------\newline	 * Copy passed start and count to local vars so we can modify them safely\newline	 *----------------------------------------------------------------------*/\newline	len_start = length(sx_start);\newline	for( i=0; i&ltlen_start; i++ )\newline		start_arg[i] = INTEGER(sx_start)[i];\newline	len_count = length(sx_count);\newline	for( i=0; i&ltlen_count; i++ )\newline		count_arg[i] = INTEGER(sx_count)[i];\newline	\newline	/*-----------------------------------------\newline	 * Get varid to use, if passed value is -1.\newline	 *----------------------------------------*/\newline	if( varid == -1 ) {\newline		/*----------------------------------------------------\newline		 * Get how many vars are in this file ... if only one,\newline		 * use that one.  Otherwise, signal error.\newline		 *---------------------------------------------------*/\newline		varid = R_ncu4_varid_onlyvar( ncid );\newline		if( varid == -1 ) \newline			error( &quotError: no var specified, and the file has more than one valid var!&quot );\newline		}\newline	else\newline		varid--;	/* go from R to C indexing */\newline	\newline	/*--------------------------------------------------------\newline	 * Get # of dims for this var, as a check to make sure any\newline	 * passed &#039start&#039 and &#039count&#039 are correct.\newline	 *-------------------------------------------------------*/\newline	ierr = nc_inq_varndims( ncid, varid, &ampndims );\newline	if( ierr != NC_NOERR )\newline		error( &quotInternal error in ncdf package, routine R_nc4_get_vara_numvarid: failed to get ndims for var!\\n&quot );\newline\newline	/*------------------------------------------------------\newline	 * Get our variable&#039s size, and the start &amp count to use\newline	 *-----------------------------------------------------*/\newline	R_ncu4_get_varsize( ncid, varid, ndims, varsize );\newline	R_ncu4_calc_start_count( ncid, varid, start_arg, len_start, count_arg, len_count, \newline			varsize, ndims, start, count );\newline\newline	/*------------------------------------------------------------\newline	 * Allocate space for data, depending on the type of var it is\newline	 *-----------------------------------------------------------*/\newline	ierr = nc_inq_vartype( ncid, varid, &ampvartype );\newline	if( ierr != NC_NOERR )\newline		error( &quotInternal error in ncdf package, routine R_nc4_get_vara_numvarid: failed to get type for var!\\n&quot );\newline\newline	tot_var_size = 1L;\newline	for( i=0; i&ltndims; i++ ) {\newline		tot_var_size *= count[i];\newline		}\newline\newline	switch( vartype ) {\newline		case NC_CHAR:\newline			error( &quotchars not handled yet, use old interface&quot );\newline			break;\newline\newline		case NC_BYTE:\newline		case NC_SHORT:\newline		case NC_INT:\newline			/*---------------\newline			 * Allocate space\newline			 *--------------*/\newline			PROTECT( rv_data = allocVector( INTSXP, tot_var_size ));\newline			data_addr_i = &amp(INTEGER(rv_data)[0]);	/* Is this guaranteed to work?  Dunno. */\newline\newline			/*--------------\newline			 * Read the data\newline			 *-------------*/\newline			ierr        = nc_get_vara_int( ncid, varid, start, count, data_addr_i );\newline			if( ierr != NC_NOERR )\newline				error( &quotError while trying to read int data from file!&quot );\newline\newline			/*---------------------\newline			 * Handle missing value\newline			 *--------------------*/\newline			ierr = nc_get_att_int( ncid, varid, &quotmissing_value&quot, &ampmissval_i );\newline			if( ierr != NC_NOERR )\newline				/* No missing value attribute found, use default value */\newline				missval_i = NC_FILL_INT;\newline			for( i_szt=0L; i_szt&lttot_var_size; i_szt++ ) \newline				if( data_addr_i[i_szt] == missval_i )\newline					data_addr_i[i_szt] = NA_INTEGER;\newline			break;\newline\newline		case NC_FLOAT:\newline		case NC_DOUBLE:\newline			/*---------------\newline			 * Allocate space\newline			 *--------------*/\newline			PROTECT( rv_data = allocVector( REALSXP, tot_var_size ));\newline			data_addr_d = &amp(REAL(rv_data)[0]);	/* Is this guaranteed to work?  Dunno. */\newline\newline			/*--------------\newline			 * Read the data\newline			 *-------------*/\newline			ierr        = nc_get_vara_double( ncid, varid, start, count, data_addr_d );\newline			if( ierr != NC_NOERR )\newline				error( &quotError while trying to read real data from file!&quot );\newline\newline			/*---------------------\newline			 * Handle missing value\newline			 *--------------------*/\newline			ierr = nc_get_att_double( ncid, varid, &quotmissing_value&quot, &ampmissval_d );\newline			if( ierr != NC_NOERR )\newline				/* No missing value attribute found, use default value */\newline				missval_d = 1.e30;\newline			missval_tol = 1.e-5*fabs(missval_d);\newline			for( i_szt=0L; i_szt&lttot_var_size; i_szt++ ) \newline				if( fabs(data_addr_d[i_szt] - missval_d) &lt missval_tol )\newline					data_addr_d[i_szt] = NA_REAL;\newline			break;\newline\newline		default:\newline			error( &quotunhandled var type when allocating var space in R_nc4_get_vara_numvarid&quot);\newline		}\newline\newline	/*-----------------------------------------\newline	 * Set our dims (note: non-degenerate only)\newline	 *----------------------------------------*/\newline	ndims_cgt1 = 0;  \newline	for( i=0; i&ltndims; i++ )\newline		if( count[i] &gt 1 )\newline			ndims_cgt1++;\newline	if( ndims_cgt1 == 0 ) {\newline		PROTECT( sx_dim = allocVector( INTSXP, 1 ));\newline		INTEGER(sx_dim)[0] = 1;\newline		}\newline	else\newline		{\newline		PROTECT( sx_dim = allocVector( INTSXP, ndims_cgt1 ));\newline		j = 0;\newline		for( i=0; i&ltndims; i++ )\newline			if( count[i] &gt 1 ) {\newline				INTEGER(sx_dim)[ndims_cgt1-j-1] = count[i];\newline				j++;\newline				}\newline		}\newline	setAttrib( rv_data, R_DimSymbol, sx_dim );\newline\newline	UNPROTECT(2);\newline	return(rv_data);\newline}\newline","\newline Given a numeric varid, this reads the data from the file.\newline Does not return on errors.\newline \newline",2236547,mounts.c,"struct mnt_list *tree_make_mnt_tree(const char *table, const char *path)\newline{\newline	FILE *tab;\newline	struct mntent mnt_wrk;\newline	char buf[PATH_MAX * 3];\newline	struct mntent *mnt;\newline	struct mnt_list *ent, *mptr;\newline	struct mnt_list *tree = NULL;\newline	char *pgrp;\newline	size_t plen;\newline	int eq;\newline\newline	tab = open_setmntent_r(table);\newline	if (!tab) {\newline		char *estr = strerror_r(errno, buf, PATH_MAX - 1);\newline		logerr(&quotsetmntent: %s&quot, estr);\newline		return NULL;\newline	}\newline\newline	plen = strlen(path);\newline\newline	while ((mnt = getmntent_r(tab, &ampmnt_wrk, buf, PATH_MAX * 3))) {\newline		size_t len = strlen(mnt-&gtmnt_dir);\newline\newline		/* Not matching path */\newline		if (strncmp(mnt-&gtmnt_dir, path, plen))\newline			continue;\newline\newline		/* Not a subdirectory of requested path */\newline		if (plen &gt 1 &amp&amp len &gt plen &amp&amp mnt-&gtmnt_dir[plen] != &#039/&#039)\newline			continue;\newline\newline		ent = malloc(sizeof(*ent));\newline		if (!ent) {\newline			endmntent(tab);\newline			tree_free_mnt_tree(tree);\newline			return NULL;\newline		}\newline		memset(ent, 0, sizeof(*ent));\newline\newline		INIT_LIST_HEAD(&ampent-&gtself);\newline		INIT_LIST_HEAD(&ampent-&gtlist);\newline		INIT_LIST_HEAD(&ampent-&gtentries);\newline		INIT_LIST_HEAD(&ampent-&gtsublist);\newline\newline		ent-&gtpath = malloc(len + 1);\newline		if (!ent-&gtpath) {\newline			endmntent(tab);\newline			free(ent);\newline			tree_free_mnt_tree(tree);\newline			return NULL;\newline		}\newline		strcpy(ent-&gtpath, mnt-&gtmnt_dir);\newline\newline		ent-&gtfs_name = malloc(strlen(mnt-&gtmnt_fsname) + 1);\newline		if (!ent-&gtfs_name) {\newline			free(ent-&gtpath);\newline			free(ent);\newline			endmntent(tab);\newline			tree_free_mnt_tree(tree);\newline			return NULL;\newline		}\newline		strcpy(ent-&gtfs_name, mnt-&gtmnt_fsname);\newline\newline		ent-&gtfs_type = malloc(strlen(mnt-&gtmnt_type) + 1);\newline		if (!ent-&gtfs_type) {\newline			free(ent-&gtfs_name);\newline			free(ent-&gtpath);\newline			free(ent);\newline			endmntent(tab);\newline			tree_free_mnt_tree(tree);\newline			return NULL;\newline		}\newline		strcpy(ent-&gtfs_type, mnt-&gtmnt_type);\newline\newline		ent-&gtopts = malloc(strlen(mnt-&gtmnt_opts) + 1);\newline		if (!ent-&gtopts) {\newline			free(ent-&gtfs_type);\newline			free(ent-&gtfs_name);\newline			free(ent-&gtpath);\newline			free(ent);\newline			endmntent(tab);\newline			tree_free_mnt_tree(tree);\newline			return NULL;\newline		}\newline		strcpy(ent-&gtopts, mnt-&gtmnt_opts);\newline\newline		ent-&gtowner = 0;\newline		pgrp = strstr(mnt-&gtmnt_opts, &quotpgrp=&quot);\newline		if (pgrp) {\newline			char *end = strchr(pgrp, &#039,&#039);\newline			if (end)\newline				*end = &#039\\0&#039;\newline			sscanf(pgrp, &quotpgrp=%d&quot, &ampent-&gtowner);\newline		}\newline\newline		mptr = tree;\newline		while (mptr) {\newline			int elen = strlen(ent-&gtpath);\newline			int mlen = strlen(mptr-&gtpath);\newline\newline			if (elen &lt mlen) {\newline				if (mptr-&gtleft) {\newline					mptr = mptr-&gtleft;\newline					continue;\newline				} else {\newline					mptr-&gtleft = ent;\newline					break;\newline				}\newline			} else if (elen &gt mlen) {\newline				if (mptr-&gtright) {\newline					mptr = mptr-&gtright;\newline					continue;\newline				} else {\newline					mptr-&gtright = ent;\newline					break;\newline				}\newline			}\newline\newline			eq = strcmp(ent-&gtpath, mptr-&gtpath);\newline			if (eq &lt 0) {\newline				if (mptr-&gtleft)\newline					mptr = mptr-&gtleft;\newline				else {\newline					mptr-&gtleft = ent;\newline					break;\newline				}\newline			} else if (eq &gt 0) {\newline				if (mptr-&gtright)\newline					mptr = mptr-&gtright;\newline				else {\newline					mptr-&gtright = ent;\newline					break;\newline				}\newline			} else {\newline				list_add_tail(&ampent-&gtself, &ampmptr-&gtself);\newline				break;\newline			}\newline		}\newline\newline		if (!tree)\newline			tree = ent;\newline	}\newline	endmntent(tab);\newline\newline	return tree;\newline}\newline",\newline Make tree of system mounts in /proc/mounts.\newline \newline,22023,locid.cpp,"Locale&amp Locale::init(const char* localeID, UBool canonicalize)\newline{\newline    fIsBogus = FALSE;\newline    /* Free our current storage */\newline    if (baseName != fullName) {\newline        uprv_free(baseName);\newline    }\newline    baseName = NULL;\newline    if(fullName != fullNameBuffer) {\newline        uprv_free(fullName);\newline        fullName = fullNameBuffer;\newline    }\newline\newline    // not a loop:\newline    // just an easy way to have a common error-exit\newline    // without goto and without another function\newline    do {\newline        char *separator;\newline        char *field[5] = {0};\newline        int32_t fieldLen[5] = {0};\newline        int32_t fieldIdx;\newline        int32_t variantField;\newline        int32_t length;\newline        UErrorCode err;\newline\newline        if(localeID == NULL) {\newline            // not an error, just set the default locale\newline            return *this = getDefault();\newline        }\newline\newline        /* preset all fields to empty */\newline        language[0] = script[0] = country[0] = 0;\newline\newline        // &quotcanonicalize&quot the locale ID to ICU/Java format\newline        err = U_ZERO_ERROR;\newline        length = canonicalize ?\newline            uloc_canonicalize(localeID, fullName, sizeof(fullNameBuffer), &amperr) :\newline            uloc_getName(localeID, fullName, sizeof(fullNameBuffer), &amperr);\newline\newline        if(err == U_BUFFER_OVERFLOW_ERROR || length &gt= (int32_t)sizeof(fullNameBuffer)) {\newline            /*Go to heap for the fullName if necessary*/\newline            fullName = (char *)uprv_malloc(sizeof(char)*(length + 1));\newline            if(fullName == 0) {\newline                fullName = fullNameBuffer;\newline                break; // error: out of memory\newline            }\newline            err = U_ZERO_ERROR;\newline            length = canonicalize ?\newline                uloc_canonicalize(localeID, fullName, length+1, &amperr) :\newline                uloc_getName(localeID, fullName, length+1, &amperr);\newline        }\newline        if(U_FAILURE(err) || err == U_STRING_NOT_TERMINATED_WARNING) {\newline            /* should never occur */\newline            break;\newline        }\newline\newline        variantBegin = length;\newline\newline        /* after uloc_getName/canonicalize() we know that only &#039_&#039 are separators */\newline        separator = field[0] = fullName;\newline        fieldIdx = 1;\newline        while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) &amp&amp fieldIdx &lt (int32_t)(sizeof(field)/sizeof(field[0]))-1) {\newline            field[fieldIdx] = separator + 1;\newline            fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);\newline            fieldIdx++;\newline        }\newline        // variant may contain @foo or .foo POSIX cruft; remove it\newline        separator = uprv_strchr(field[fieldIdx-1], &#039@&#039);\newline        char* sep2 = uprv_strchr(field[fieldIdx-1], &#039.&#039);\newline        if (separator!=NULL || sep2!=NULL) {\newline            if (separator==NULL || (sep2!=NULL &amp&amp separator &gt sep2)) {\newline                separator = sep2;\newline            }\newline            fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);\newline        } else {\newline            fieldLen[fieldIdx-1] = length - (int32_t)(field[fieldIdx-1] - fullName);\newline        }\newline\newline        if (fieldLen[0] &gt= (int32_t)(sizeof(language)))\newline        {\newline            break; // error: the language field is too long\newline        }\newline\newline        variantField = 1; /* Usually the 2nd one, except when a script or country is also used. */\newline        if (fieldLen[0] &gt 0) {\newline            /* We have a language */\newline            uprv_memcpy(language, fullName, fieldLen[0]);\newline            language[fieldLen[0]] = 0;\newline        }\newline        if (fieldLen[1] == 4 &amp&amp ISASCIIALPHA(field[1][0]) &amp&amp\newline                ISASCIIALPHA(field[1][1]) &amp&amp ISASCIIALPHA(field[1][2]) &amp&amp\newline                ISASCIIALPHA(field[1][3])) {\newline            /* We have at least a script */\newline            uprv_memcpy(script, field[1], fieldLen[1]);\newline            script[fieldLen[1]] = 0;\newline            variantField++;\newline        }\newline\newline        if (fieldLen[variantField] == 2 || fieldLen[variantField] == 3) {\newline            /* We have a country */\newline            uprv_memcpy(country, field[variantField], fieldLen[variantField]);\newline            country[fieldLen[variantField]] = 0;\newline            variantField++;\newline        } else if (fieldLen[variantField] == 0) {\newline            variantField++; /* script or country empty but variant in next field (i.e. en__POSIX) */\newline        }\newline\newline        if (fieldLen[variantField] &gt 0) {\newline            /* We have a variant */\newline            variantBegin = (int32_t)(field[variantField] - fullName);\newline        }\newline\newline        err = U_ZERO_ERROR;\newline        initBaseName(err);\newline        if (U_FAILURE(err)) {\newline            break;\newline        }\newline\newline        // successful end of init()\newline        return *this;\newline    } while(0); /*loop doesn&#039t iterate*/\newline\newline    // when an error occurs, then set this object to &quotbogus&quot (there is no UErrorCode here)\newline    setToBogus();\newline\newline    return *this;\newline}\newline",This function initializes a Locale from a C locale ID \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,5097500,regex.c,"bool search_and_replace( const int first_addr, const int second_addr,\newline                         const int gflags, const int snum, const bool isglobal )\newline  {\newline  int lc;\newline  bool match_found = false;\newline\newline  set_current_addr( first_addr - 1 );\newline  for( lc = 0; lc &lt= second_addr - first_addr; ++lc )\newline    {\newline    const line_t * const lp = search_line_node( inc_current_addr() );\newline    const int size = replace_matching_text( lp, gflags, snum );\newline    if( size &lt 0 ) return false;\newline    if( size )\newline      {\newline      const char * txt = rbuf;\newline      const char * const eot = rbuf + size;\newline      undo_t * up = 0;\newline      disable_interrupts();\newline      if( !delete_lines( current_addr(), current_addr(), isglobal ) )\newline        { enable_interrupts(); return false; }\newline      do {\newline        txt = put_sbuf_line( txt, size, current_addr() );\newline        if( !txt ) { enable_interrupts(); return false; }\newline        if( up ) up-&gttail = search_line_node( current_addr() );\newline        else\newline          {\newline          up = push_undo_atom( UADD, current_addr(), current_addr() );\newline          if( !up ) { enable_interrupts(); return false; }\newline          }\newline        }\newline      while( txt != eot );\newline      enable_interrupts();\newline      match_found = true;\newline      }\newline    }\newline  if( !match_found &amp&amp !( gflags &amp GLB ) )\newline    { set_error_msg( &quotNo match&quot ); return false; }\newline  return true;\newline  }\newline","for each line in a range, change text matching a pattern according to\newlinea substitution template; return false if error \newline",5921350,rb_physfs_file.c,"VALUE physfs_file_eof (VALUE self)\newline{\newline    int result;\newline    PHYSFS_File *file;\newline\newline    Data_Get_Struct (self, PHYSFS_File, file);\newline    if (file == 0)\newline	return Qnil;\newline\newline    result = PHYSFS_eof (file);\newline\newline    if (result)\newline        return Qtrue;\newline\newline    return Qfalse;\newline}\newline",\newline PhysicsFS::File#eof? \newline \newline,1296220,index-direct-braille.c,"static void output(int c) {\newline	/**\newline	 * Keep track of number of bytes written, we wish to avoid a annoying\newline	 * bug in the printer usb-driver (or hardware?).\newline	 */\newline	bytes_written++;\newline	if (fputc(c, stdout) == EOF) {\newline		fprintf(stderr, &quotERROR: Unable to write to stdout: %s.\\n&quot, strerror(errno));\newline		exit(1);\newline	}\newline}\newline","\newline Send a single character to stdout, also keep track of number of bytes sent.\newline @param c Character value to send.\newline \newline",3443997,board_enable.c,static int fdc37b787_gpio50_raise_3f0(void)\newline{\newline	return fdc37b787_gpio50_raise(0x3f0);\newline}\newline,\newline Suited for:\newline - Nokia IP530: Intel 440BX + PIIX4 + FDC37B787\newline \newline,2924793,graphobject.c,"PyObject *igraphmodule_Graph_radius(igraphmodule_GraphObject * self,\newline                                      PyObject * args, PyObject * kwds)\newline{\newline  PyObject *mode_o = Py_None;\newline  igraph_neimode_t mode = IGRAPH_OUT;\newline  igraph_real_t radius;\newline\newline  static char *kwlist[] = { &quotmode&quot, NULL };\newline\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quot|O&quot, kwlist,\newline                                   &ampmode_o))\newline    return NULL;\newline\newline  if (igraphmodule_PyObject_to_neimode_t(mode_o, &ampmode))\newline    return NULL;\newline\newline  if (igraph_radius(&ampself-&gtg, &ampradius, mode)) {\newline    igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline\newline  return PyFloat_FromDouble((double)radius);\newline}\newline",\\ingroup python_interface_graph\newline \\brief Calculates the radius of an \\c igraph.Graph\newline \newline \\return the radius as a Python integer\newline \\sa igraph_radius\newline \newline,3676074,libics_sensor.c,"Ics_Error IcsSetSensorMediumRI (ICS* ics, double ri)\newline{\newline    ICS_FM_WMD( ics );\newline    ics-&gtRefrInxMedium = ri;\newline    return IcsErr_Ok;\newline}\newline",\newline Set the sensor embedding medium refractive index.\newline \newline,813026,webkitdownload.cpp,"void webkit_download_cancel(WebKitDownload* download)\newline{\newline    g_return_if_fail(WEBKIT_IS_DOWNLOAD(download));\newline\newline    WebKitDownloadPrivate* priv = download-&gtpriv;\newline\newline    // Cancel may be called even if start was not called, so we need\newline    // to make sure timer is non-NULL.\newline    if (priv-&gttimer)\newline        g_timer_stop(priv-&gttimer);\newline\newline    if (priv-&gtresourceHandle)\newline        priv-&gtresourceHandle-&gtcancel();\newline\newline    webkit_download_set_status(download, WEBKIT_DOWNLOAD_STATUS_CANCELLED);\newline    webkitDownloadEmitError(download, downloadCancelledByUserError(core(priv-&gtnetworkResponse)));\newline}\newline","\newline webkit_download_cancel:\newline @download: the #WebKitDownload\newline \newline Cancels the download. Calling this will not free the\newline #WebKitDownload object, so you still need to call\newline g_object_unref() on it, if you are the owner of a reference. Notice\newline that cancelling the download provokes the emission of the\newline WebKitDownload::error signal, reporting that the download was\newline cancelled.\newline \newline Since: 1.1.2\newline \newline",384689,net80211.c,"static void net80211_set_rtscts_rate ( struct net80211_device *dev )\newline{\newline	u16 datarate = dev-&gtrates[dev-&gtrate];\newline	u16 rtsrate = 0;\newline	int rts_idx = -1;\newline	int i;\newline\newline	for ( i = 0; i &lt dev-&gtnr_rates; i++ ) {\newline		u16 rate = dev-&gtrates[i];\newline\newline		if ( ! ( dev-&gtbasic_rates &amp ( 1 &lt&lt i ) ) || rate &gt datarate )\newline			continue;\newline\newline		if ( rate &gt rtsrate ) {\newline			rtsrate = rate;\newline			rts_idx = i;\newline		}\newline	}\newline\newline	/* If this is in initialization, we might not have any basic\newline	   rates; just use the first data rate in that case. */\newline	if ( rts_idx &lt 0 )\newline		rts_idx = 0;\newline\newline	dev-&gtrtscts_rate = rts_idx;\newline}\newline",\newline Pick TX rate for RTS/CTS packets based on data rate\newline \newline @v dev 802.11 device\newline \newline The RTS/CTS rate is the fastest TX rate marked as &quotbasic&quot that is\newline not faster than the data rate.\newline \newline,367368,filter.c,"gint country_mouse_click_left_list(GtkWidget * widget,\newline		GdkEventButton * event,\newline		gpointer func_data) {\newline	if ((event-&gttype == GDK_2BUTTON_PRESS) &amp&amp (event-&gtbutton==1)) {\newline		country_add_selection_to_right_list();\newline	}\newline\newline	return FALSE;\newline}\newline",callback: double click on row \newline,384922,iscsi.c,"static int iscsi_rx_data_in ( struct iscsi_session *iscsi,\newline			      const void *data, size_t len,\newline			      size_t remaining ) {\newline	struct iscsi_bhs_data_in *data_in = &ampiscsi-&gtrx_bhs.data_in;\newline	unsigned long offset;\newline\newline	/* Copy data to data-in buffer */\newline	offset = ntohl ( data_in-&gtoffset ) + iscsi-&gtrx_offset;\newline	assert ( iscsi-&gtcommand != NULL );\newline	assert ( iscsi-&gtcommand-&gtdata_in );\newline	assert ( ( offset + len ) &lt= iscsi-&gtcommand-&gtdata_in_len );\newline	copy_to_user ( iscsi-&gtcommand-&gtdata_in, offset, data, len );\newline\newline	/* Wait for whole SCSI response to arrive */\newline	if ( remaining )\newline		return 0;\newline\newline	/* Mark as completed if status is present */\newline	if ( data_in-&gtflags &amp ISCSI_DATA_FLAG_STATUS ) {\newline		assert ( ( offset + len ) == iscsi-&gtcommand-&gtdata_in_len );\newline		assert ( data_in-&gtflags &amp ISCSI_FLAG_FINAL );\newline		iscsi-&gtcommand-&gtstatus = data_in-&gtstatus;\newline		/* iSCSI cannot return an error status via a data-in */\newline		iscsi_scsi_done ( iscsi, 0 );\newline	}\newline\newline	return 0;\newline}\newline",\newline Receive data segment of an iSCSI data-in PDU\newline \newline @v iscsi iSCSI session\newline @v data Received data\newline @v len Length of received data\newline @v remaining Data remaining after this data\newline @ret rc Return status code\newline \newline,5209236,mtest.c,void MTestResetDatatypes( void )\newline{\newline    datatype_index = 0;\newline}\newline,Reset the datatype index (start from the initial data type.\newlineNote: This routine is rarely needed; MTestGetDatatypes automatically\newlinestarts over after the last available datatype is used.\newline \newline,5933716,closure.cpp,"void ParseData::lalr1AddFollowSets( )\newline{\newline	/* Make the state that all reduction actions go to. Since a reduction pops\newline	 * states of the stack and sets the new target state, this state is\newline	 * actually never reached. Just here to link the trans to. */\newline	actionDestState = graph-&gtaddState();\newline	graph-&gtsetFinState( actionDestState );\newline\newline	/* Get the entry into the graph and traverse over start. */\newline	StateAp *overStart = graph-&gtfollowFsm( graph-&gtstartState, startDef-&gtfsm );\newline\newline	/* Add _eof after the initial _start. */\newline	TransAp *eofTrans = graph-&gtattachNewTrans( overStart, actionDestState, \newline			eofKlangEl-&gtid, eofKlangEl-&gtid );\newline	eofTrans-&gtisShift = true;\newline\newline	/* This was used during lr0 table construction. */\newline	graph-&gttransClosureQueue.abandon();\newline\newline	/* Need to pass over every state initially. */\newline	for ( StateList::Iter state = graph-&gtstateList; state.lte(); state++ )\newline		lalr1AddFollow1( state );\newline\newline	/* While the closure queue has items, pop them off and add follow\newline	 * characters. */\newline	while ( graph-&gttransClosureQueue.length() &gt 0 ) {\newline		/* Pop the first item off and add Follow for it . */\newline		TransAp *trans = graph-&gttransClosureQueue.detachFirst();\newline		lalr1AddFollow1( trans );\newline	}\newline}\newline",Add follow sets to an LR(0) graph to make it LALR(1). \newline,6375656,fa.c,"static int is_splittable(struct fa *fa1, struct fa *fa2) {\newline    bitset *alpha1 = NULL;\newline    bitset *alpha2 = NULL;\newline    bitset *last1 = NULL;\newline    bitset *first2 = NULL;\newline    bool result = -1;\newline\newline    alpha2 = alphabet(fa2);\newline    last1 = last_chars(fa1);\newline    if (alpha2 == NULL || last1 == NULL)\newline        goto done;\newline    if (bitset_disjoint(last1, alpha2, UCHAR_NUM)) {\newline        result = 1;\newline        goto done;\newline    }\newline\newline    alpha1 = alphabet(fa1);\newline    first2 = first_chars(fa2);\newline    if (alpha1 == NULL || first2 == NULL)\newline        goto done;\newline    if (bitset_disjoint(first2, alpha1, UCHAR_NUM)) {\newline        result = 1;\newline        goto done;\newline    }\newline    result = 0;\newline done:\newline    bitset_free(alpha1);\newline    bitset_free(alpha2);\newline    bitset_free(last1);\newline    bitset_free(first2);\newline    return result;\newline}\newline",Return 1 if F1 and F2 are known to be unambiguously concatenable\newline according to simple heuristics. Return 0 if they need to be checked\newline further to decide ambiguity\newline Return -1 if an allocation fails\newline \newline,146555,main-loop.c,"RetroMainLoop* retro_main_loop_construct (GType object_type, RetroCore* core) {\newline	RetroMainLoop * self = NULL;\newline	RetroCore* _tmp0_;\newline	g_return_val_if_fail (core != NULL, NULL);\newline	_tmp0_ = core;\newline	self = (RetroMainLoop*) g_object_new (object_type, &quotcore&quot, _tmp0_, NULL);\newline	return self;\newline}\newline",\newline Creates a MainLoop to run a {@link Core}.\newline \newline @param core the {@link Core} tu run\newline \newline,2691054,mem_sharing.c,"static inline void page_sharing_dispose(struct page_info *page)\newline{\newline    /* Unlikely given our thresholds, but we should be careful. */\newline    if ( unlikely(RMAP_USES_HASHTAB(page)) )\newline        free_xenheap_pages(page-&gtsharing-&gthash_table.bucket, \newline                            RMAP_HASHTAB_ORDER);\newline\newline    spin_lock(&ampshr_audit_lock);\newline    list_del_rcu(&amppage-&gtsharing-&gtentry);\newline    spin_unlock(&ampshr_audit_lock);\newline    INIT_RCU_HEAD(&amppage-&gtsharing-&gtrcu_head);\newline    call_rcu(&amppage-&gtsharing-&gtrcu_head, _free_pg_shared_info);\newline}\newline",Removes from the audit list and cleans up the page sharing metadata. \newline,,on,,,,,,,,,,on,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,Remove an element from a group without deleting it.,{},\return the radius as a Python integer,Set the sensor embedding medium refractive index.,Cancels the download.,Pick TX rate for RTS/CTS packets based on data rate,double click on row,Receive data segment of an iSCSI data-in PDU,"MTestGetDatatypes automatically
starts over after the last available datatype is used.",Add follow sets to an LR(0) graph to make it LALR(1).,"Return 0 if they need to be checked
further to decide ambiguity",{},Creates a MainLoop to run a {@link Core}.,Removes from the audit list and cleans up the page sharing metadata.,this reads the data from the file.,Make tree of system mounts in /proc/mounts.,This function initializes a Locale from a C locale ID,Load an image from the named file.,"change text matching a pattern according to
a substitution template;",{},"Send a single character to stdout,",x,
308KJXFUJR646CZVE2BUZG53FVSTA6,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:31 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:31 PDT 2019,,,38BQUHLA9W0RI5055QK13GQ5SZIOM1,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:39 PDT 2019,Fri Apr 26 13:01:14 PDT 2019,Sun Apr 28 13:01:14 PDT 2019,,,,815,100% (62/62),100% (62/62),0% (0/0),2164298,prot.c,"EXPORTED struct protstream *prot_new(int fd, int write)\newline{\newline    struct protstream *newstream;\newline\newline    newstream = (struct protstream *) xzmalloc(sizeof(struct protstream));\newline    newstream-&gtbuf = (unsigned char *) \newline	xmalloc(sizeof(char) * (PROT_BUFSIZE));\newline    newstream-&gtbuf_size = PROT_BUFSIZE;\newline    newstream-&gtptr = newstream-&gtbuf;\newline    newstream-&gtmaxplain = PROT_BUFSIZE;\newline    newstream-&gtfd = fd;\newline    newstream-&gtwrite = write;\newline    newstream-&gtlogfd = PROT_NO_FD;\newline    newstream-&gtbig_buffer = PROT_NO_FD;\newline    if(write)\newline	newstream-&gtcnt = PROT_BUFSIZE;\newline\newline    return newstream;\newline}\newline",\newline Create a new protection stream for file descriptor &#039fd&#039. Stream\newline will be used for writing iff &#039write&#039 is nonzero.\newline \newline,4488960,ui_login.c,"static void Login_MenuEvent( void* ptr, int event ) {\newline	if( event != QM_ACTIVATED ) {\newline		return;\newline	}\newline\newline	switch( ((menucommon_s*)ptr)-&gtid ) {\newline	case ID_LOGIN:\newline		// set name								``\newline		//trap_Cvar_Set( &quotname&quot, s_login.name_box.field.buffer );\newline		/*\newline		trap_Cvar_Set( &quotrank_name&quot, s_login.name_box.field.buffer );\newline		trap_Cvar_Set( &quotrank_pwd&quot, s_login.password_box.field.buffer );\newline		*/\newline\newline		// login\newline		trap_CL_UI_RankUserLogin(\newline			s_login.name_box.field.buffer, \newline			s_login.password_box.field.buffer );\newline\newline		UI_ForceMenuOff();\newline		break;\newline		\newline	case ID_CANCEL:\newline		UI_PopMenu();\newline		break;\newline	}\newline}\newline",\newline===============\newlineLogin_MenuEvent\newline===============\newline \newline,2199161,tpoint.c,"double tpoint_maxx(int nelem,tpoint *points)\newline{\newline int	ii;\newline double	 maxx;\newline\newline if ( nelem &lt 1 || points == NULL )	return(0);\newline maxx=points[0].xcoord;\newline for ( ii=1 ; ii&ltnelem ; ii++ )\newline  {	if ( points[ii].xcoord&gtmaxx )	maxx=points[ii].xcoord;		}\newline\newline return(maxx);\newline}\newline",return maximum in x coordinates or 0 \newline,2575091,addressbook.c,"void addrbookctl_build_map(GtkWidget *window)\newline{\newline	AddressTypeControlItem *atci;\newline\newline	/* Build icons */\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_FOLDER_CLOSE, &ampfolderpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_FOLDER_OPEN, &ampfolderopenpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_GROUP, &ampgrouppix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_VCARD, &ampvcardpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_BOOK, &ampbookpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_PERSON, &amppersonpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_ADDRESS, &ampaddresspix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_JPILOT, &ampjpilotpix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_CATEGORY, &ampcategorypix);\newline	stock_pixbuf_gdk(window, STOCK_PIXMAP_LDAP, &ampldappix);\newline\newline	_addressBookTypeHash_ = g_hash_table_new(g_int_hash, g_int_equal);\newline	_addressBookTypeList_ = NULL;\newline\newline	/* Interface */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_INTERFACE;\newline	atci-&gtinterfaceType = ADDR_IF_NONE;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotInterface&quot);\newline	atci-&gticon_pixbuf = folderpix;\newline	atci-&gticon_open_pixbuf = folderopenpix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* Address book */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_BOOK;\newline	atci-&gtinterfaceType = ADDR_IF_BOOK;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotAddress Book&quot);\newline	atci-&gticon_pixbuf = bookpix;\newline	atci-&gticon_open_pixbuf = bookpix;\newline	atci-&gtmenuCommand = &quot/File/New Book&quot;\newline	g_hash_table_insert( _addressBookTypeHash_, &ampatci-&gtobjectType, atci );\newline	_addressBookTypeList_ = g_list_append( _addressBookTypeList_, atci );\newline\newline	/* Item person */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_ITEM_PERSON;\newline	atci-&gtinterfaceType = ADDR_IF_NONE;\newline	atci-&gtshowInTree = FALSE;\newline	atci-&gttreeExpand = FALSE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotPerson&quot);\newline	atci-&gticon_pixbuf = personpix;\newline	atci-&gticon_open_pixbuf = personpix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert( _addressBookTypeHash_, &ampatci-&gtobjectType, atci );\newline	_addressBookTypeList_ = g_list_append( _addressBookTypeList_, atci );\newline\newline	/* Item email */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_ITEM_EMAIL;\newline	atci-&gtinterfaceType = ADDR_IF_NONE;\newline	atci-&gtshowInTree = FALSE;\newline	atci-&gttreeExpand = FALSE;\newline	atci-&gttreeLeaf = TRUE;\newline	atci-&gtdisplayName = _(&quotEMail Address&quot);\newline	atci-&gticon_pixbuf = addresspix;\newline	atci-&gticon_open_pixbuf = addresspix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* Item group */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_ITEM_GROUP;\newline	atci-&gtinterfaceType = ADDR_IF_BOOK;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = FALSE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotGroup&quot);\newline	atci-&gticon_pixbuf = grouppix;\newline	atci-&gticon_open_pixbuf = grouppix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* Item folder */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_ITEM_FOLDER;\newline	atci-&gtinterfaceType = ADDR_IF_BOOK;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = FALSE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotFolder&quot);\newline	atci-&gticon_pixbuf = folderpix;\newline	atci-&gticon_open_pixbuf = folderopenpix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* vCard */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_VCARD;\newline	atci-&gtinterfaceType = ADDR_IF_VCARD;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = TRUE;\newline	atci-&gtdisplayName = _(&quotvCard&quot);\newline	atci-&gticon_pixbuf = vcardpix;\newline	atci-&gticon_open_pixbuf = vcardpix;\newline	atci-&gtmenuCommand = &quot/File/New vCard&quot;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* JPilot */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_JPILOT;\newline	atci-&gtinterfaceType = ADDR_IF_JPILOT;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = FALSE;\newline	atci-&gtdisplayName = _(&quotJPilot&quot);\newline	atci-&gticon_pixbuf = jpilotpix;\newline	atci-&gticon_open_pixbuf = jpilotpix;\newline	atci-&gtmenuCommand = &quot/File/New JPilot&quot;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* Category */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_CATEGORY;\newline	atci-&gtinterfaceType = ADDR_IF_JPILOT;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = TRUE;\newline	atci-&gtdisplayName = _(&quotJPilot&quot);\newline	atci-&gticon_pixbuf = categorypix;\newline	atci-&gticon_open_pixbuf = categorypix;\newline	atci-&gtmenuCommand = NULL;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline\newline	/* LDAP Server */\newline	atci = g_new0(AddressTypeControlItem, 1);\newline	atci-&gtobjectType = ADDR_LDAP;\newline	atci-&gtinterfaceType = ADDR_IF_LDAP;\newline	atci-&gtshowInTree = TRUE;\newline	atci-&gttreeExpand = TRUE;\newline	atci-&gttreeLeaf = TRUE;\newline	atci-&gtdisplayName = _(&quotLDAP Server&quot);\newline	atci-&gticon_pixbuf = ldappix;\newline	atci-&gticon_open_pixbuf = ldappix;\newline	atci-&gtmenuCommand = &quot/File/New LDAP Server&quot;\newline	g_hash_table_insert(_addressBookTypeHash_, &ampatci-&gtobjectType, atci);\newline	_addressBookTypeList_ = g_list_append(_addressBookTypeList_, atci);\newline}\newline",\newline Build table that controls the rendering of object types.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,554418,qswutil.c,"static void _verify_info_encoding(qsw_info_t * qi)\newline{\newline    int err;\newline    char tmpstr[1024];\newline    qsw_info_t qicpy;\newline\newline    err = qsw_encode_info(tmpstr, sizeof(tmpstr), qi);\newline    assert(err &gt= 0);\newline    err = qsw_decode_info(tmpstr, &ampqicpy);\newline    assert(memcmp(qi, &ampqicpy, sizeof(qicpy)) == 0);\newline}\newline","encode info, then decode and check that the result is what we started with \newline",6006303,insqypsr.c,"globle EXPRESSION *ParseQueryAction(\newline  void *theEnv,\newline  EXPRESSION *top,\newline  char *readSource)\newline  {\newline   EXPRESSION *insQuerySetVars;\newline   struct token queryInputToken;\newline\newline   insQuerySetVars = ParseQueryRestrictions(theEnv,top,readSource,&ampqueryInputToken);\newline   if (insQuerySetVars == NULL)\newline     return(NULL);\newline   IncrementIndentDepth(theEnv,3);\newline   PPCRAndIndent(theEnv);\newline   if (ParseQueryTestExpression(theEnv,top,readSource) == FALSE)\newline     {\newline      DecrementIndentDepth(theEnv,3);\newline      ReturnExpression(theEnv,insQuerySetVars);\newline      return(NULL);\newline     }\newline   PPCRAndIndent(theEnv);\newline   if (ParseQueryActionExpression(theEnv,top,readSource,insQuerySetVars,&ampqueryInputToken) == FALSE)\newline     {\newline      DecrementIndentDepth(theEnv,3);\newline      ReturnExpression(theEnv,insQuerySetVars);\newline      return(NULL);\newline     }\newline   DecrementIndentDepth(theEnv,3);\newline   \newline   if (GetType(queryInputToken) != RPAREN)\newline     {\newline      SyntaxErrorMessage(theEnv,&quotinstance-set query function&quot);\newline      ReturnExpression(theEnv,top);\newline      ReturnExpression(theEnv,insQuerySetVars);\newline      return(NULL);\newline     }\newline   ReplaceInstanceVariables(theEnv,insQuerySetVars,top-&gtargList,TRUE,0);\newline   ReplaceInstanceVariables(theEnv,insQuerySetVars,top-&gtargList-&gtnextArg,FALSE,0);\newline   ReturnExpression(theEnv,insQuerySetVars);\newline   return(top);\newline  }\newline","\newlineNAME : ParseQueryAction\newlineDESCRIPTION : Parses the following functions :\newline(do-for-instance)\newline(do-for-all-instances)\newline(delayed-do-for-all-instances)\newlineINPUTS : 1) The address of the top node of the query function\newline2) The logical name of the input\newlineRETURNS : The completed expression chain, or NULL on errors\newlineSIDE EFFECTS : The expression chain is extended, or the &quottop&quot node\newlineis deleted on errors\newlineNOTES : H/L Syntax :\newline(&ltfunction&gt &ltquery-block&gt &ltquery-action&gt)\newline&ltquery-block&gt :== (&ltinstance-var&gt+) &ltquery-expression&gt\newline&ltinstance-var&gt :== (&ltvar-name&gt &ltclass-name&gt+)\newlineParses into following form :\newline&ltquery-function&gt\newline|\newlineV\newline&ltquery-expression&gt -&gt &ltquery-action&gt -&gt\newline&ltclass-1a&gt -&gt &ltclass-1b&gt -&gt (QDS) -&gt\newline&ltclass-2a&gt -&gt &ltclass-2b&gt -&gt (QDS) -&gt ...\newline \newline",2059042,fluid_defsfont.c,"int delete_fluid_defsfont(fluid_defsfont_t* sfont)\newline{\newline  fluid_list_t *list;\newline  fluid_defpreset_t* preset;\newline  fluid_sample_t* sample;\newline\newline  /* Check that no samples are currently used */\newline  for (list = sfont-&gtsample; list; list = fluid_list_next(list)) {\newline    sample = (fluid_sample_t*) fluid_list_get(list);\newline    if (fluid_sample_refcount(sample) != 0) {\newline      return -1;\newline    }\newline  }\newline\newline  if (sfont-&gtfilename != NULL) {\newline    FLUID_FREE(sfont-&gtfilename);\newline  }\newline\newline  for (list = sfont-&gtsample; list; list = fluid_list_next(list)) {\newline    delete_fluid_sample((fluid_sample_t*) fluid_list_get(list));\newline  }\newline\newline  if (sfont-&gtsample) {\newline    delete_fluid_list(sfont-&gtsample);\newline  }\newline\newline  if (sfont-&gtsampledata != NULL) {\newline    fluid_munlock(sfont-&gtsampledata, sfont-&gtsamplesize);\newline    FLUID_FREE(sfont-&gtsampledata);\newline  }\newline\newline  preset = sfont-&gtpreset;\newline  while (preset != NULL) {\newline    sfont-&gtpreset = preset-&gtnext;\newline    delete_fluid_defpreset(preset);\newline    preset = sfont-&gtpreset;\newline  }\newline\newline  FLUID_FREE(sfont);\newline  return FLUID_OK;\newline}\newline",\newline delete_fluid_defsfont\newline \newline,4132376,client.c,"int lscp_get_channel_voice_count ( lscp_client_t *pClient, int iSamplerChannel )\newline{\newline	char szQuery[LSCP_BUFSIZ];\newline	int iVoiceCount = -1;\newline\newline	if (pClient == NULL)\newline		return -1;\newline	if (iSamplerChannel &lt 0)\newline		return -1;\newline\newline	// Lock this section up.\newline	lscp_mutex_lock(pClient-&gtmutex);\newline\newline	sprintf(szQuery, &quotGET CHANNEL VOICE_COUNT %d\\r\\n&quot, iSamplerChannel);\newline	if (lscp_client_call(pClient, szQuery, 0) == LSCP_OK)\newline		iVoiceCount = atoi(lscp_client_get_result(pClient));\newline\newline	// Unlock this section down.\newline	lscp_mutex_unlock(pClient-&gtmutex);\newline\newline	return iVoiceCount;\newline}\newline","\newline Current number of active voices:\newline GET CHANNEL VOICE_COUNT &ltsampler-channel&gt\newline \newline @param pClient Pointer to client instance structure.\newline @param iSamplerChannel Sampler channel number.\newline \newline @returns The number of voices currently active, -1 in case of failure.\newline \newline",4486486,cg_weapons.c,"static void CG_OldRocketTrail( centity_t *ent, const weaponInfo_t *wi ) {\newline	int		step;\newline	vec3_t	origin, lastPos;\newline	int		t;\newline	int		startTime, contents;\newline	int		lastContents;\newline	entityState_t	*es;\newline	vec3_t	up;\newline	localEntity_t	*smoke;\newline\newline	if ( cg_noProjectileTrail.integer ) {\newline		return;\newline	}\newline\newline	up[0] = 0;\newline	up[1] = 0;\newline	up[2] = 0;\newline\newline	step = 50;\newline\newline	es = &ampent-&gtcurrentState;\newline	startTime = ent-&gttrailTime;\newline	t = step * ( (startTime + step) / step );\newline\newline	BG_EvaluateTrajectory( &ampes-&gtpos, cg.time, origin );\newline	contents = CG_PointContents( origin, -1 );\newline\newline	// if object (e.g. grenade) is stationary, don&#039t toss up smoke\newline	if ( es-&gtpos.trType == TR_STATIONARY ) {\newline		ent-&gttrailTime = cg.time;\newline		return;\newline	}\newline\newline	BG_EvaluateTrajectory( &ampes-&gtpos, ent-&gttrailTime, lastPos );\newline	lastContents = CG_PointContents( lastPos, -1 );\newline\newline	ent-&gttrailTime = cg.time;\newline\newline	if ( contents &amp ( CONTENTS_WATER | CONTENTS_SLIME | CONTENTS_LAVA ) ) {\newline		if ( contents &amp lastContents &amp CONTENTS_WATER ) {\newline			CG_BubbleTrail( lastPos, origin, 8 );\newline		}\newline		return;\newline	}\newline\newline	for ( ; t &lt= ent-&gttrailTime ; t += step ) {\newline		BG_EvaluateTrajectory( &ampes-&gtpos, t, lastPos );\newline\newline		smoke = CG_SmokePuff( lastPos, up, \newline					  wi-&gttrailRadius, \newline					  1, 1, 1, 0.33f,\newline					  wi-&gtwiTrailTime, \newline					  t,\newline					  0,\newline					  0, \newline					  cgs.media.smokePuffShader );\newline		// use the optimized local entity add\newline		smoke-&gtleType = LE_SCALE_FADE;\newline	}\newline\newline}\newline",\newline==========================\newlineCG_OldRocketTrail (for the crappy old rocket trail.)\newline==========================\newline \newline,4119409,szddd.c,"static void szddd_close(struct msszdd_decompressor *base,\newline			struct msszddd_header *hdr)\newline{\newline    struct msszdd_decompressor_p *self = (struct msszdd_decompressor_p *) base;\newline    struct msszddd_header_p *hdr_p = (struct msszddd_header_p *) hdr;\newline\newline    if (!self || !self-&gtsystem) return;\newline\newline    /* close the file handle associated */\newline    self-&gtsystem-&gtclose(hdr_p-&gtfh);\newline\newline    /* free the memory associated */\newline    self-&gtsystem-&gtfree(hdr);\newline\newline    self-&gterror = MSPACK_ERR_OK;\newline}\newline",\newline SZDDD_CLOSE\newline \newline closes an SZDD file\newline \newline,5073101,stack.c,"Bool position_new_window_in_stack_ring(FvwmWindow *t, Bool do_lower)\newline{\newline	if (t-&gtstack_prev != &ampScr.FvwmRoot)\newline	{\newline		/* Not at top of stack ring, so it is already in place.\newline		 * add_window.c relies on this. */\newline		return False;\newline	}\newline	/* RaiseWindow/LowerWindow will put the window in its layer */\newline	raise_or_lower_window(\newline		t, (do_lower) ? SM_LOWER : SM_RAISE, False, True, False);\newline\newline	return True;\newline}\newline",Takes a window from the top of the stack ring and puts it at the appropriate\newline place. Called when new windows are created. \newline,5821713,idbm.c,"static int idbm_for_each_iface(int *found, void *data,\newline				idbm_iface_op_fn *fn,\newline				char *targetname, int tpgt, char *ip, int port)\newline{\newline	DIR *iface_dirfd;\newline	struct dirent *iface_dent;\newline	struct stat statb;\newline	node_rec_t rec;\newline	int rc = 0;\newline	char *portal;\newline\newline	portal = calloc(1, PATH_MAX);\newline	if (!portal)\newline		return ISCSI_ERR_NOMEM;\newline\newline	if (tpgt &gt= 0)\newline		goto read_iface;\newline\newline	/* old style portal as a config */\newline	snprintf(portal, PATH_MAX, &quot%s/%s/%s,%d&quot, NODE_CONFIG_DIR, targetname,\newline		 ip, port);\newline	if (stat(portal, &ampstatb)) {\newline		log_error(&quotiface iter could not stat %s.&quot, portal);\newline		rc = ISCSI_ERR_IDBM;\newline		goto free_portal;\newline	}\newline\newline	rc = __idbm_rec_read(&amprec, portal);\newline	if (rc)\newline		goto free_portal;\newline\newline	rc = fn(data, &amprec);\newline	if (!rc)\newline		(*found)++;\newline	else if (rc == -1)\newline		rc = 0;\newline	goto free_portal;\newline\newlineread_iface:\newline	snprintf(portal, PATH_MAX, &quot%s/%s/%s,%d,%d&quot, NODE_CONFIG_DIR,\newline		 targetname, ip, port, tpgt);\newline\newline	iface_dirfd = opendir(portal);\newline	if (!iface_dirfd) {\newline		log_error(&quotiface iter could not read dir %s.&quot, portal);\newline		rc = ISCSI_ERR_IDBM;\newline		goto free_portal;\newline	}\newline\newline	while ((iface_dent = readdir(iface_dirfd))) {\newline		int curr_rc;\newline\newline		if (!strcmp(iface_dent-&gtd_name, &quot.&quot) ||\newline		    !strcmp(iface_dent-&gtd_name, &quot..&quot))\newline			continue;\newline\newline		log_debug(5, &quotiface iter found %s.&quot, iface_dent-&gtd_name);\newline		memset(portal, 0, PATH_MAX);\newline		snprintf(portal, PATH_MAX, &quot%s/%s/%s,%d,%d/%s&quot, NODE_CONFIG_DIR,\newline			 targetname, ip, port, tpgt, iface_dent-&gtd_name);\newline		if (__idbm_rec_read(&amprec, portal))\newline			continue;\newline\newline		curr_rc = fn(data, &amprec);\newline		/* less than zero means it was not a match */\newline		if (curr_rc &gt 0 &amp&amp !rc)\newline			rc = curr_rc;\newline		else if (curr_rc == 0)\newline			(*found)++;\newline	}\newline\newline	closedir(iface_dirfd);\newlinefree_portal:\newline	free(portal);\newline	return rc;\newline}\newline","\newline idbm_for_each_iface - iterate over bound iface recs\newline @found: nr of recs found so far\newline @data: data pointer passed to fn\newline @fn: iterator function ran over each bound iface rec\newline @targetname: rec&#039s target name\newline @tpgt: rec&#039s portal group tag\newline @ip: rec&#039s ip address\newline @port: rec&#039s port\newline \newline This will run fn over all recs with the {targetname,tpgt,ip,port}\newline id. It does not iterate over the ifaces setup in /etc/iscsi/ifaces.\newline \newline fn should return -1 if it skipped the rec, an ISCSI_ERR error code if\newline the operation failed or 0 if fn was run successfully.\newline \newline",2194743,main_windows.cpp,void main_windows::Disconnect()\newline{\newline	debugQt(&quotmain_windows::Disconnect()&quot);\newline	sendToServer(end); // inform server\newline	sslSocket.close(); // close SSL/TCP connection\newline	setWidgetState();\newline}\newline,\newline Close TCP connection\newline \newline,3057373,charactersblock.cpp,int CharactersBlock::ApplyExset( IntSet&amp exset )\newline{\newline	assert( activeChar != NULL );\newline	int num_excluded = 0;\newline	int k;\newline	//for( k = 0; k &lt nchar; k++ )\newline	//	activeChar[k] = true;\newline		\newline	IntSet::const_iterator i;\newline	for( i = exset.begin(); i != exset.end(); i++ ) {\newline		k = charPos[*i];\newline		if( k &lt 0 ) continue;\newline		\newline		// k greater than -1 means character was not eliminated\newline		// and therefore can be excluded\newline		//\newline		if( activeChar[k] == true )\newline			num_excluded++;\newline		activeChar[k] = false;\newline	}\newline	return num_excluded;\newline}\newline,"\newline @method ApplyExset [void:protected]\newline @param exset [IntSet&amp] set of character indices to exclude in range [0..ncharTotal)\newline \newline Excludes characters whose indices are contained in the set exset. The indices supplied \newline should refer to the original character indices, not current character indices.\newline Returns number of characters actually excluded (some may have already been\newline excluded).\newline \newline",2793291,cmalign.c,"  if(cfg-&gtifp != NULL) { fprintf(cfg-&gtifp, &quot//\\n&quot); }\newline",finish insert and el files \newline,286911,trace-ust.c,"struct ltt_ust_event *trace_ust_create_event(struct lttng_event *ev,\newline		char *filter_expression,\newline		struct lttng_filter_bytecode *filter,\newline		struct lttng_event_exclusion *exclusion,\newline		bool internal_event)\newline{\newline	struct ltt_ust_event *lue;\newline\newline	assert(ev);\newline\newline	if (exclusion &amp&amp validate_exclusion(exclusion)) {\newline		goto error;\newline	}\newline\newline	lue = zmalloc(sizeof(struct ltt_ust_event));\newline	if (lue == NULL) {\newline		PERROR(&quotust event zmalloc&quot);\newline		goto error;\newline	}\newline\newline	lue-&gtinternal = internal_event;\newline\newline	switch (ev-&gttype) {\newline	case LTTNG_EVENT_PROBE:\newline		lue-&gtattr.instrumentation = LTTNG_UST_PROBE;\newline		break;\newline	case LTTNG_EVENT_FUNCTION:\newline		lue-&gtattr.instrumentation = LTTNG_UST_FUNCTION;\newline		break;\newline	case LTTNG_EVENT_FUNCTION_ENTRY:\newline		lue-&gtattr.instrumentation = LTTNG_UST_FUNCTION;\newline		break;\newline	case LTTNG_EVENT_TRACEPOINT:\newline		lue-&gtattr.instrumentation = LTTNG_UST_TRACEPOINT;\newline		break;\newline	default:\newline		ERR(&quotUnknown ust instrumentation type (%d)&quot, ev-&gttype);\newline		goto error_free_event;\newline	}\newline\newline	/* Copy event name */\newline	strncpy(lue-&gtattr.name, ev-&gtname, LTTNG_UST_SYM_NAME_LEN);\newline	lue-&gtattr.name[LTTNG_UST_SYM_NAME_LEN - 1] = &#039\\0&#039;\newline\newline	switch (ev-&gtloglevel_type) {\newline	case LTTNG_EVENT_LOGLEVEL_ALL:\newline		lue-&gtattr.loglevel_type = LTTNG_UST_LOGLEVEL_ALL;\newline		lue-&gtattr.loglevel = -1;	/* Force to -1 */\newline		break;\newline	case LTTNG_EVENT_LOGLEVEL_RANGE:\newline		lue-&gtattr.loglevel_type = LTTNG_UST_LOGLEVEL_RANGE;\newline		lue-&gtattr.loglevel = ev-&gtloglevel;\newline		break;\newline	case LTTNG_EVENT_LOGLEVEL_SINGLE:\newline		lue-&gtattr.loglevel_type = LTTNG_UST_LOGLEVEL_SINGLE;\newline		lue-&gtattr.loglevel = ev-&gtloglevel;\newline		break;\newline	default:\newline		ERR(&quotUnknown ust loglevel type (%d)&quot, ev-&gtloglevel_type);\newline		goto error_free_event;\newline	}\newline\newline	/* Same layout. */\newline	lue-&gtfilter_expression = filter_expression;\newline	lue-&gtfilter = filter;\newline	lue-&gtexclusion = exclusion;\newline\newline	/* Init node */\newline	lttng_ht_node_init_str(&amplue-&gtnode, lue-&gtattr.name);\newline\newline	DBG2(&quotTrace UST event %s, loglevel (%d,%d) created&quot,\newline		lue-&gtattr.name, lue-&gtattr.loglevel_type,\newline		lue-&gtattr.loglevel);\newline\newline	return lue;\newline\newlineerror_free_event:\newline	free(lue);\newlineerror:\newline	free(filter_expression);\newline	free(filter);\newline	free(exclusion);\newline	return NULL;\newline}\newline","\newline Allocate and initialize a ust event. Set name and event type.\newline We own filter_expression, filter, and exclusion.\newline \newline Return pointer to structure or NULL.\newline \newline",2161247,imapd.c,"static void cmd_close(char *tag, char *cmd)\newline{\newline    if (backend_current) {\newline	/* remote mailbox */\newline	prot_printf(backend_current-&gtout, &quot%s %s\\r\\n&quot, tag, cmd);\newline	/* xxx do we want this to say OK if the connection is gone?\newline	 * saying NO is clearly wrong, hense the fatal request. */\newline	pipe_including_tag(backend_current, tag, 0);\newline\newline	/* remove backend_current from the protgroup */\newline	protgroup_delete(protin, backend_current-&gtin);\newline\newline	backend_current = NULL;\newline	return;\newline    }\newline\newline    /* local mailbox */\newline    if ((cmd[0] == &#039C&#039) &amp&amp index_hasrights(imapd_index, ACL_EXPUNGE)) {\newline	index_expunge(imapd_index, NULL, 1);\newline	/* don&#039t tell changes here */\newline    }\newline\newline    index_close(&ampimapd_index);\newline\newline    /* http://www.rfc-editor.org/errata_search.php?rfc=5162 \newline     * Errata ID: 1808 - don&#039t send HIGHESTMODSEQ to a close\newline     * command, because it can lose synchronisation */\newline    prot_printf(imapd_out, &quot%s OK %s\\r\\n&quot,\newline		tag, error_message(IMAP_OK_COMPLETED));\newline}\newline",\newline Perform a CLOSE/UNSELECT command\newline \newline,4487287,ui_main.c,"static void UI_LoadDemos( void ) {\newline	char	demolist[4096];\newline	char demoExt[32];\newline	char	*demoname;\newline	int		i, len;\newline\newline	Com_sprintf(demoExt, sizeof(demoExt), &quotdm_%d&quot, (int)trap_Cvar_VariableValue(&quotprotocol&quot));\newline\newline	uiInfo.demoCount = trap_FS_GetFileList( &quotdemos&quot, demoExt, demolist, 4096 );\newline\newline	Com_sprintf(demoExt, sizeof(demoExt), &quot.dm_%d&quot, (int)trap_Cvar_VariableValue(&quotprotocol&quot));\newline\newline	if (uiInfo.demoCount) {\newline		if (uiInfo.demoCount &gt MAX_DEMOS) {\newline			uiInfo.demoCount = MAX_DEMOS;\newline		}\newline		demoname = demolist;\newline		for ( i = 0; i &lt uiInfo.demoCount; i++ ) {\newline			len = strlen( demoname );\newline			if (!Q_stricmp(demoname +  len - strlen(demoExt), demoExt)) {\newline				demoname[len-strlen(demoExt)] = &#039\\0&#039;\newline			}\newline			Q_strupr(demoname);\newline			uiInfo.demoList[i] = String_Alloc(demoname);\newline			demoname += len + 1;\newline		}\newline	}\newline\newline}\newline",\newline===============\newlineUI_LoadDemos\newline===============\newline \newline,6273144,wbxml_encoder.c,"static WBXMLError wbxml_encode_attr(WBXMLEncoder *encoder, WBXMLAttribute *attribute)\newline{\newline    WB_UTINY *value = NULL;\newline    WBXMLError ret = WBXML_OK;\newline\newline    /* Encode Attribute Start */\newline    if ((ret = wbxml_encode_attr_start(encoder, attribute, &ampvalue)) != WBXML_OK)\newline        return ret;\newline\newline    /* Encode Attribute Value */\newline    if (value != NULL) {\newline        if ((ret = wbxml_encode_value_element_buffer(encoder, value, WBXML_VALUE_ELEMENT_CTX_ATTR)) != WBXML_OK)\newline            return ret;\newline    }\newline\newline    /* Reset Current Attribute */\newline    encoder-&gtcurrent_attr = NULL;\newline\newline    return WBXML_OK;\newline}\newline","\newline @brief Encode a WBXML Attribute\newline @param encoder [in] The WBXML Encoder\newline @param attribute [in] The Attribute to encode\newline @return WBXML_OK if encoding is OK, an error code otherwise\newline @note attribute = attrStart attrValue\newline \newline",4932221,sbar.c,"static void Sbar_DrawString (int x, int y, char *str)\newline{\newline	DrawQ_String (sbar_x + x, sbar_y + y, str, 0, 8, 8, 1, 1, 1, sbar_alpha_fg.value, 0, NULL, false, FONT_SBAR);\newline}\newline",\newline================\newlineSbar_DrawString\newline================\newline \newline,,on,,,,,,,,,on,on,on,on,,,,,,on,on,,,,,,,,,,,,,,,,,,,,,,Create a new protection stream for file descriptor 'fd'.,{},closes an SZDD file,"puts it at the appropriate
place.","This will run fn over all recs with the {targetname,tpgt,ip,port}",Close TCP connection,Excludes characters whose indices are contained in the set exset.,finish insert and el files,"We own filter_expression, filter, and exclusion.",Perform a CLOSE/UNSELECT command,{},{},{},{},return maximum in x coordinates or 0,Build table that controls the rendering of object types.,Load an image from the named file.,"encode info,",Parses the following functions,{},{},x,
306996CF6WK8G2SEIXRGOL6E5UN1B1,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:47 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:47 PDT 2019,,,32XVDSJFPZXDBYB0ISM4W3N2RUMM2T,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:33 PDT 2019,Fri Apr 26 12:52:02 PDT 2019,Sun Apr 28 12:52:02 PDT 2019,,,,269,100% (62/62),100% (62/62),0% (0/0),283242,addr.c,"int nl_addr_resolve(const struct nl_addr *addr, char *host, size_t hostlen)\newline{\newline	int err;\newline	struct sockaddr_in6 buf;\newline	socklen_t salen = sizeof(buf);\newline\newline	err = nl_addr_fill_sockaddr(addr, (struct sockaddr *) &ampbuf, &ampsalen);\newline	if (err &lt 0)\newline		return err;\newline\newline	err = getnameinfo((struct sockaddr *) &ampbuf, salen, host, hostlen,\newline			  NULL, 0, NI_NAMEREQD);\newline	if (err &lt 0)\newline		return nl_syserr2nlerr(err);\newline\newline	return 0;\newline}\newline",\newline Resolve abstract address object to a name using getnameinfo().\newline @arg addr Abstract address object.\newline @arg host Destination buffer for host name.\newline @arg hostlen Length of destination buffer.\newline \newline Resolves the abstract address to a name and writes the looked up result\newline into the host buffer. getnameinfo() is used to perform the lookup and\newline is put into NI_NAMEREQD mode so the function will fail if the lookup\newline couldn&#039t be performed.\newline \newline @return 0 on success or a negative error code.\newline \newline,6299993,smbk5pwd.c,"static int k5key_chk(\newline	const struct berval *sc,\newline	const struct berval *passwd,\newline	const struct berval *cred,\newline	const char **text )\newline{\newline	void *ctx, *op_tmp;\newline	Operation *op;\newline	int rc;\newline	Entry *e;\newline	Attribute *a;\newline	krb5_error_code ret;\newline	krb5_keyblock key;\newline	krb5_salt salt;\newline	hdb_entry ent;\newline\newline	/* Find our thread context, find our Operation */\newline	ctx = ldap_pvt_thread_pool_context();\newline\newline	if ( ldap_pvt_thread_pool_getkey( ctx, smbk5pwd_op_cleanup, &ampop_tmp, NULL )\newline		 || !op_tmp )\newline		return LUTIL_PASSWD_ERR;\newline	op = op_tmp;\newline\newline	rc = be_entry_get_rw( op, &ampop-&gto_req_ndn, NULL, NULL, 0, &ampe );\newline	if ( rc != LDAP_SUCCESS ) return LUTIL_PASSWD_ERR;\newline\newline	rc = LUTIL_PASSWD_ERR;\newline	do {\newline		size_t l;\newline		Key ekey = {0};\newline\newline		a = attr_find( e-&gte_attrs, ad_krb5PrincipalName );\newline		if (!a ) break;\newline\newline		memset( &ampent, 0, sizeof(ent) );\newline		ret = krb5_parse_name(context, a-&gta_vals[0].bv_val, &ampent.principal);\newline		if ( ret ) break;\newline\newline		a = attr_find( e-&gte_attrs, ad_krb5ValidEnd );\newline		if (a) {\newline			struct lutil_tm tm;\newline			struct lutil_timet tt;\newline			if ( lutil_parsetime( a-&gta_vals[0].bv_val, &amptm ) == 0 &amp&amp\newline				lutil_tm2time( &amptm, &amptt ) == 0 &amp&amp tt.tt_usec &lt op-&gto_time ) {\newline				/* Account is expired */\newline				rc = LUTIL_PASSWD_ERR;\newline				break;\newline			}\newline		}\newline\newline		krb5_get_pw_salt( context, ent.principal, &ampsalt );\newline		krb5_free_principal( context, ent.principal );\newline\newline		a = attr_find( e-&gte_attrs, ad_krb5Key );\newline		if ( !a ) break;\newline\newline		ent.keys.len = 1;\newline		ent.keys.val = &ampekey;\newline		decode_Key((unsigned char *) a-&gta_vals[0].bv_val,\newline			(size_t) a-&gta_vals[0].bv_len, &ampent.keys.val[0], &ampl);\newline		if ( db-&gtHDB_MASTER_KEY_SET )\newline			hdb_unseal_keys( context, db, &ampent );\newline\newline		krb5_string_to_key_salt( context, ekey.key.keytype, cred-&gtbv_val,\newline			salt, &ampkey );\newline\newline		krb5_free_salt( context, salt );\newline\newline		if ( memcmp( ekey.key.keyvalue.data, key.keyvalue.data,\newline			key.keyvalue.length ) == 0 ) rc = LUTIL_PASSWD_OK;\newline\newline		krb5_free_keyblock_contents( context, &ampkey );\newline		krb5_free_keyblock_contents( context, &ampekey.key );\newline\newline	} while(0);\newline	be_entry_release_r( op, e );\newline	return rc;\newline}\newline","This password scheme stores no data in the userPassword attribute\newline other than the scheme name. It assumes the invoking entry is a\newline krb5KDCentry and compares the passed-in credentials against the\newline krb5Key attribute. The krb5Key may be multi-valued, but they are\newline simply multiple keytypes generated from the same input string, so\newline only the first value needs to be compared here.\newline \newline Since the lutil_passwd API doesn&#039t pass the Entry object in, we\newline have to fetch it ourselves in order to get access to the other\newline attributes. We accomplish this with the help of the overlay&#039s Bind\newline function, which stores the current Operation pointer in thread-specific\newline storage so we can retrieve it here. The Operation provides all\newline the necessary context for us to get Entry from the database.\newline \newline",6007885,defins.c,"static SYMBOL_HN *ParseDefinstancesName(\newline  void *theEnv,\newline  char *readSource,\newline  int *active)\newline  {\newline   SYMBOL_HN *dname;\newline\newline   *active = FALSE;\newline   dname = GetConstructNameAndComment(theEnv,readSource,&ampDefclassData(theEnv)-&gtObjectParseToken,&quotdefinstances&quot,\newline                                      EnvFindDefinstances,EnvUndefinstances,&quot@&quot,\newline                                      TRUE,FALSE,TRUE);\newline   if (dname == NULL)\newline     return(NULL);\newline\newline#if DEFRULE_CONSTRUCT\newline   if ((GetType(DefclassData(theEnv)-&gtObjectParseToken) != SYMBOL) ? FALSE :\newline       (strcmp(ValueToString(GetValue(DefclassData(theEnv)-&gtObjectParseToken)),ACTIVE_RLN) == 0))\newline     {\newline      PPBackup(theEnv);\newline      PPBackup(theEnv);\newline      SavePPBuffer(theEnv,&quot &quot);\newline      SavePPBuffer(theEnv,DefclassData(theEnv)-&gtObjectParseToken.printForm);\newline      PPCRAndIndent(theEnv);\newline      GetToken(theEnv,readSource,&ampDefclassData(theEnv)-&gtObjectParseToken);\newline      *active = TRUE;\newline     }\newline#endif\newline   if (GetType(DefclassData(theEnv)-&gtObjectParseToken) == STRING)\newline     {\newline      PPBackup(theEnv);\newline      PPBackup(theEnv);\newline      SavePPBuffer(theEnv,&quot &quot);\newline      SavePPBuffer(theEnv,DefclassData(theEnv)-&gtObjectParseToken.printForm);\newline      PPCRAndIndent(theEnv);\newline      GetToken(theEnv,readSource,&ampDefclassData(theEnv)-&gtObjectParseToken);\newline     }\newline   return(dname);\newline  }\newline","\newlineNAME : ParseDefinstancesName\newlineDESCRIPTION : Parses definstance name and optional comment\newlineand optional &quotactive&quot keyword\newlineINPUTS : 1) The logical name of the input source\newline2) Buffer to hold flag indicating if\newlinedefinstances should cause pattern-matching\newlineto occur during slot-overrides\newlineRETURNS : Address of name symbol, or\newlineNULL if there was an error\newlineSIDE EFFECTS : Token after name or comment is scanned\newlineNOTES : Assumes &quot(definstances&quot has already\newlinebeen scanned.\newline \newline",3500488,mpatch.c,"int mpatch_decode(const char *bin, ssize_t len, struct mpatch_flist **res)\newline{\newline	struct mpatch_flist *l;\newline	struct mpatch_frag *lt;\newline	int pos = 0;\newline\newline	/* assume worst case size, we won&#039t have many of these lists */\newline	l = lalloc(len / 12 + 1);\newline	if (!l)\newline		return MPATCH_ERR_NO_MEM;\newline\newline	lt = l-&gttail;\newline\newline	while (pos &gt= 0 &amp&amp pos &lt len) {\newline		lt-&gtstart = getbe32(bin + pos);\newline		lt-&gtend = getbe32(bin + pos + 4);\newline		lt-&gtlen = getbe32(bin + pos + 8);\newline		lt-&gtdata = bin + pos + 12;\newline		pos += 12 + lt-&gtlen;\newline		if (lt-&gtstart &gt lt-&gtend || lt-&gtlen &lt 0)\newline			break; /* sanity check */\newline		lt++;\newline	}\newline\newline	if (pos != len) {\newline		mpatch_lfree(l);\newline		return MPATCH_ERR_CANNOT_BE_DECODED;\newline	}\newline\newline	l-&gttail = lt;\newline	*res = l;\newline	return 0;\newline}\newline",decode a binary patch into a hunk list \newline,1039271,spectool_gtk_planar.c,"	if (planar-&gtdraw_peak) {\newline		cairo_save(cr);\newline		cairo_new_path(cr);\newline		cairo_move_to(cr, wwidget-&gtg_start_x + 0.5, wwidget-&gtg_end_y - 0.5);\newline		for (x = 0; x &lt wwidget-&gtsweepcache-&gtavg-&gtnum_samples; x++) {\newline			int px, py;\newline			int sdb = SPECTOOL_RSSI_CONVERT(wwidget-&gtamp_offset_mdbm, wwidget-&gtamp_res_mdbm,\newline										 wwidget-&gtsweepcache-&gtpeak-&gtsample_data[x]);\newline\newline			chpix = x * wwidget-&gtwbar;\newline\newline			px = wwidget-&gtg_start_x + chpix;\newline			py = (float) wwidget-&gtg_len_y * \newline				(float) ((float) (abs(sdb) + wwidget-&gtbase_db_offset) /\newline						 (float) (abs(wwidget-&gtmin_db_draw) + \newline								  wwidget-&gtbase_db_offset));\newline\newline			if (px &lt wwidget-&gtg_start_x)\newline				px = wwidget-&gtg_start_x;\newline			if (px &gt wwidget-&gtg_end_x)\newline				px = wwidget-&gtg_end_x;\newline\newline			if (py &lt wwidget-&gtg_start_y)\newline				py = wwidget-&gtg_start_y;\newline			if (py &gt wwidget-&gtg_end_y)\newline				py = wwidget-&gtg_end_y;\newline\newline			cairo_line_to(cr, px + 0.5, py + 0.5);\newline		}\newline		/* Close the path along the bottom */\newline		cairo_line_to(cr, wwidget-&gtg_end_x - 0.5, wwidget-&gtg_end_y - 0.5);\newline		cairo_line_to(cr, wwidget-&gtg_start_x + 0.5, wwidget-&gtg_end_y - 0.5);\newline		cairo_close_path(cr);\newline		/* Plot it - save the path so we can stroke and fill */\newline		cairo_set_source_rgb(cr, 0, 0, HC2CC(0xAA));\newline		cairo_fill_preserve(cr);\newline		cairo_set_source_rgb(cr, 1, 1, 1);\newline		cairo_set_line_width(cr, 1);\newline		cairo_stroke(cr);\newline		cairo_restore(cr);\newline	}\newline",Render the peak points \newline,2060874,hb-encoding.c,"gchar *homebank_utf8_ensure(gchar *buffer)\newline{\newlinegboolean isvalid;\newlinegchar *converted;\newline\newline	DB( g_print(&quot(homebank) homebank_utf8_ensure\\n&quot) );\newline\newline	if(buffer == NULL)\newline		return NULL;\newline\newline	isvalid = g_utf8_validate(buffer, -1, NULL);\newline	DB( g_print(&quot -&gt is valid utf8: %d\\n&quot, isvalid) );\newline\newline	if(!isvalid)\newline	{\newline		converted = homebank_utf8_convert(buffer, NULL);\newline		if(converted != NULL)\newline		{\newline			//g_warn here ?\newline			g_free(buffer);\newline			return converted;\newline		}\newline		//g_warn here ?\newline	}\newline	return buffer;\newline}\newline","\newline Ensure a buffer to be utf-8, and convert if necessary\newline \newline \newline",5745394,operators.c,"int Value_pmos(Value *R,Value *I,Value *G,Value *dummy)\newline{\newline  int wc = SSNUMWORDS(R-&gtnbits);\newline  register int i;\newline\newline  for (i = 0;i &lt wc;i++) {\newline    register unsigned GisZero = G-&gtzero[i] &amp ~G-&gtone[i] &amp ~G-&gtflt[i];\newline    register unsigned GisOne = ~G-&gtzero[i] &amp G-&gtone[i] &amp ~G-&gtflt[i];\newline    register unsigned IisLogic = (I-&gtzero[i] ^ I-&gtone[i]) &amp ~I-&gtflt[i];\newline\newline    R-&gtone[i]  = I-&gtone[i] &amp ~GisOne;\newline    R-&gtzero[i] = I-&gtzero[i] &amp ~GisOne;\newline    R-&gtflt[i] = ~(IisLogic &amp GisZero);\newline  }\newline\newline  return 0;\newline}\newline",\newline \newline pmos - do pmos transistor function\newline \newline Parameters:\newline R Return value\newline I Input value\newline E Control value\newline dummy Unused parameter (to allow use as &quotoperator&quot function).\newline \newline /G\\ one zero flt \newline 0 1 x z L H 0 1 x z L H 0 1 x z L H 0 1 x z L H 01z\newline +----------- +----------- +----------- +----------- ---\newline 0|0 z L L L L 0|0 0 0 0 0 0 0|1 0 1 1 1 1 0|0 1 1 1 1 1 100\newline 1|1 z H H H H 1|1 0 1 1 1 1 1|0 0 0 0 0 0 1|0 1 1 1 1 1 010\newline Ix|z z x x x x x|1 0 1 1 1 1 x|1 0 1 1 1 1 x|1 1 1 1 1 1 111\newline z|z z z z z z z|0 0 0 0 0 0 z|0 0 0 0 0 0 z|1 1 1 1 1 1 001\newline L|L z L L L L L|0 0 0 0 0 0 L|1 0 1 1 1 1 L|1 1 1 1 1 1 101\newline H|H z H H H H H|1 0 1 1 1 1 H|0 0 0 0 0 0 H|1 1 1 1 1 1 011\newline \newline \newline,345670,kganttview.cpp,void View::setConstraintModel( ConstraintModel* cm )\newline{\newline    d-&gtconstraintProxy.setSourceModel( cm );\newline    d-&gtgfxview-&gtsetConstraintModel( &ampd-&gtmappedConstraintModel );\newline}\newline,! Sets the constraintmodel displayed by this view.\newline \\see KGantt::ConstraintModel.\newline \newline,2945031,badpix.c,"static int bad_neighbours_green(struct bad_pix_map *map, int pixel)\newline{\newline	int i, bn = 0;\newline	int bx, by;\newline\newline	bx = map-&gtpix[pixel].x;\newline	by = map-&gtpix[pixel].y;\newline\newline        /* first we look above-left and below-left */\newline	for (i = pixel - 1; i &gt= 0; i--) {\newline		if (bx - map-&gtpix[i].x &gt 1)\newline			/* we are more that 1 pixel away, stop searching */\newline			break;\newline\newline		if ((by - map-&gtpix[i].y ==  1) &amp&amp (bx - map-&gtpix[i].x == 1))\newline			bn |= BAD_AL;\newline\newline		if ((by - map-&gtpix[i].y == -1) &amp&amp (bx - map-&gtpix[i].x == 1))\newline			bn |= BAD_BL;\newline	}\newline\newline	/* then we look above-right and below-right */\newline	for (i = pixel; i &lt map-&gtpixels; i++) {\newline		if (map-&gtpix[i].x - bx &gt 1)\newline			/* we are more than 1 pixel away, stop searching */\newline			break;\newline\newline		if ((by - map-&gtpix[i].y ==  1) &amp&amp (bx - map-&gtpix[i].x == -1))\newline			bn |= BAD_AR;\newline\newline		if ((by - map-&gtpix[i].y == -1) &amp&amp (bx - map-&gtpix[i].x == -1))\newline			bn |= BAD_BR;\newline	}\newline\newline	if (bn)\newline		d4_printf(&quotbad neighbor mask %08x at %d, %d [green]\\n&quot, bn, bx, by);\newline\newline	return bn;\newline}\newline","nearest green neighbors are above-left, above-right, below-left and\newlinebelow-right for RGB bayer patterns \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,5988651,lgc.c,"static int iscleared (global_State *g, const TValue *o) {\newline  if (!iscollectable(o)) return 0;\newline  else if (ttisstring(o)) {\newline    markobject(g, tsvalue(o));  /* strings are &#039values&#039, so are never weak */\newline    return 0;\newline  }\newline  else return iswhite(gcvalue(o));\newline}\newline","\newline tells whether a key or value can be cleared from a weak\newline table. Non-collectable objects are never removed from weak\newline tables. Strings behave as &#039values&#039, so are never removed too. for\newline other objects: if really collected, cannot keep them; for objects\newline being finalized, keep them in keys, but not in values\newline \newline",1912377,dbg_mem.c,"GtkWidget* dbgmem_create_window(void)\newline{\newline	GladeXML *xml = NULL;\newline	GtkWidget *dbox;\newline	\newline	xml = glade_xml_new\newline		(tilp_paths_build_glade(&quotdbg_mem-2.glade&quot), &quotdbgmem_window&quot,\newline		 PACKAGE);\newline	if (!xml)\newline		g_error(&quotGUI loading failed !\\n&quot);\newline	glade_xml_signal_autoconnect(xml);\newline	\newline	dbox = glade_xml_get_widget(xml, &quotdbgmem_window&quot);\newline	if(options3.transient)\newline		gtk_window_set_transient_for(GTK_WINDOW(dbox), GTK_WINDOW(main_wnd));\newline\newline    notebook = glade_xml_get_widget(xml, &quotnotebook1&quot);\newline    gtk_notebook_popup_enable(GTK_NOTEBOOK(notebook));\newline    \newline	notebook_add_page(notebook, &quot0x000000&quot);\newline\newline	return dbox;\newline}\newline",\newline Display memory window\newline \newline,6434637,class.c,"int get_conf_ping(const struct ConfItem* aconf)\newline{\newline  assert(0 != aconf);\newline  if (aconf-&gtconn_class)\newline    return (ConfPingFreq(aconf));\newline\newline  Debug((DEBUG_DEBUG, &quotNo Ping For %s&quot, aconf-&gtname));\newline\newline  return -1;\newline}\newline",Get ping time for a configuration item.\newline @param[in] aconf Configuration item to check.\newline @return Ping time for connection class associated with \\a aconf.\newline \newline,4295086,write_to_files.c,"int glogger_check_and_change_file(struct filelist *files,\newline				  struct timeval *changetime){\newline  struct timeval nowtime;\newline  gettimeofday(&ampnowtime, NULL);\newline\newline  //printf(&quot%u, %u\\n&quot, global_fileinterval.tv_sec, changetime-&gttv_sec);\newline\newline  glogger_renew_time();\newline  if(global_outputsizemax != 0){\newline    /* file size */\newline    while(files){\newline      if(files-&gtbuf_count &gt= files-&gtbuf_max){\newline	glogger_compare_and_change_filename(files);\newline	change_file(files);\newline      }\newline      files = files-&gtnext;\newline    }\newline  }\newline  else {\newline    /* path rule */\newline    while(files){\newline      if(glogger_compare_and_change_filename(files) &gt 0 ){\newline	change_file(files);\newline      }\newline      files = files-&gtnext;\newline    }\newline  }\newline  return 1;\newline}\newline",if(bufmode == BUFMODE_NONE &amp&amp reqloop == reqloop_top) \newline,6009656,create_import_selection.c,"void create_import_selection(struct w *widgets)\newline{\newline    /* Create and populate the import selector */\newline    FILE *fp;\newline    long conf_size;\newline    char *old_buffer, *new_buffer, *groupnr, *group_name;\newline    int i;\newline    GtkTreeIter iter;\newline    GtkTreeSelection *selection;\newline    gchar *import_msg=NULL, *utf8=NULL;\newline    GtkTreeViewColumn *user_col, *group_col;\newline    GtkCellRenderer *import_cell_renderer;\newline    GtkWidget *import_vbox;\newline    GtkWidget *import_label0;\newline    GtkWidget *import_scrolledwindow;\newline    GtkWidget *import_hbuttonbox;\newline    GtkWidget *import_button;\newline    GtkWidget *alignment1;\newline    GtkWidget *hbox2;\newline    GtkWidget *image1;\newline    GtkWidget *label2;\newline    GtkWidget *import_cancel_button;\newline    GtkWidget *alignment2;\newline    GtkWidget *hbox3;\newline    GtkWidget *image2;\newline    GtkWidget *label3;\newline    GtkTooltips *tooltips;\newline\newline    /* Destroy the first question window */\newline    gtk_widget_destroy(widgets-&gtimport_question_window);\newline\newline    tooltips = gtk_tooltips_new();\newline\newline    widgets-&gtimport_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\newline    gtk_widget_set_size_request(widgets-&gtimport_window, 560, 350);\newline\newline    /* Set some descriptive texts in the window based on what was selected */\newline    if( global_import_local &amp&amp global_import_users )\newline      import_msg = g_strdup_printf(_(&quotSelect any local users you want to import&quot));\newline\newline    if( global_import_local &amp&amp global_import_groups )\newline      import_msg = g_strdup_printf(_(&quotSelect any local groups you want to import&quot));\newline\newline    if( global_import_remote &amp&amp global_import_users )\newline      import_msg = g_strdup_printf(_(&quotSelect any remote users you want to import&quot));\newline\newline    if( global_import_remote &amp&amp global_import_groups )\newline      import_msg = g_strdup_printf(_(&quotSelect any remote groups you want to import&quot));\newline\newline    utf8 = g_locale_to_utf8(import_msg, strlen(import_msg), NULL, NULL, NULL);\newline    g_free(import_msg);\newline\newline    /* Set a variable window title */\newline    gtk_window_set_title(GTK_WINDOW(widgets-&gtimport_window), utf8);\newline    gtk_window_set_position(GTK_WINDOW(widgets-&gtimport_window), GTK_WIN_POS_CENTER);\newline    import_vbox = gtk_vbox_new(FALSE, 0);\newline    gtk_container_add(GTK_CONTAINER(widgets-&gtimport_window), import_vbox);\newline\newline    import_label0 = gtk_label_new(utf8);\newline\newline\newline    gtk_box_pack_start(GTK_BOX(import_vbox), import_label0, FALSE, FALSE, 0);\newline    gtk_label_set_justify(GTK_LABEL(import_label0), GTK_JUSTIFY_LEFT);\newline    gtk_misc_set_padding(GTK_MISC(import_label0), 0, 5);\newline\newline    import_scrolledwindow = gtk_scrolled_window_new(NULL, NULL);\newline    gtk_box_pack_start(GTK_BOX(import_vbox), import_scrolledwindow, TRUE, TRUE, 0);\newline    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(import_scrolledwindow), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);\newline\newline    widgets-&gtimport_treeview = gtk_tree_view_new();\newline    gtk_container_add(GTK_CONTAINER(import_scrolledwindow), widgets-&gtimport_treeview);\newline    gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(widgets-&gtimport_treeview), TRUE);\newline\newline    widgets-&gtimport_store = gtk_list_store_new(2, G_TYPE_STRING, G_TYPE_STRING);\newline    gtk_tree_view_set_model(GTK_TREE_VIEW(widgets-&gtimport_treeview), GTK_TREE_MODEL(widgets-&gtimport_store));\newline\newline    /* Set the column labels in the treeview */\newline    import_cell_renderer = gtk_cell_renderer_text_new();\newline\newline    user_col = gtk_tree_view_column_new_with_attributes(_(&quotUsername&quot), import_cell_renderer, &quottext&quot, 0, NULL);\newline    gtk_tree_view_append_column(GTK_TREE_VIEW(widgets-&gtimport_treeview), GTK_TREE_VIEW_COLUMN(user_col));\newline\newline    group_col = gtk_tree_view_column_new_with_attributes(_(&quotGroup&quot), import_cell_renderer, &quottext&quot, 1, NULL);\newline    gtk_tree_view_append_column(GTK_TREE_VIEW(widgets-&gtimport_treeview), GTK_TREE_VIEW_COLUMN(group_col));\newline\newline\newline    /* Selection is multiple */\newline    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widgets-&gtimport_treeview));\newline    gtk_tree_selection_set_mode(GTK_TREE_SELECTION(selection), GTK_SELECTION_MULTIPLE);\newline\newline\newline    import_hbuttonbox = gtk_hbutton_box_new();\newline    gtk_box_pack_start(GTK_BOX(import_vbox), import_hbuttonbox, FALSE, FALSE, 0);\newline    gtk_button_box_set_layout(GTK_BUTTON_BOX(import_hbuttonbox), GTK_BUTTONBOX_SPREAD);\newline\newline    /* Import cancel button */\newline    import_cancel_button = gtk_button_new();\newline    gtk_container_add(GTK_CONTAINER(import_hbuttonbox), import_cancel_button);\newline    GTK_WIDGET_SET_FLAGS(import_cancel_button, GTK_CAN_DEFAULT);\newline\newline    alignment2 = gtk_alignment_new(0.5, 0.5, 0, 0);\newline    gtk_container_add(GTK_CONTAINER(import_cancel_button), alignment2);\newline\newline    hbox3 = gtk_hbox_new(FALSE, 2);\newline    gtk_container_add(GTK_CONTAINER(alignment2), hbox3);\newline\newline    image2 = gtk_image_new_from_stock(&quotgtk-cancel&quot, GTK_ICON_SIZE_BUTTON);\newline    gtk_box_pack_start(GTK_BOX(hbox3), image2, FALSE, FALSE, 0);\newline\newline    label3 = gtk_label_new_with_mnemonic(_(&quotCancel&quot));\newline    gtk_box_pack_start(GTK_BOX(hbox3), label3, FALSE, FALSE, 0);\newline    gtk_label_set_justify(GTK_LABEL(label3), GTK_JUSTIFY_LEFT);\newline\newline\newline    /* The import button */\newline    import_button = gtk_button_new();\newline    gtk_container_add(GTK_CONTAINER(import_hbuttonbox), import_button);\newline    GTK_WIDGET_SET_FLAGS(import_button, GTK_CAN_DEFAULT);\newline\newline    alignment1 = gtk_alignment_new(0.5, 0.5, 0, 0);\newline    gtk_container_add(GTK_CONTAINER(import_button), alignment1);\newline\newline    hbox2 = gtk_hbox_new(FALSE, 2);\newline    gtk_container_add(GTK_CONTAINER(alignment1), hbox2);\newline\newline    image1 = gtk_image_new_from_stock(&quotgtk-yes&quot, GTK_ICON_SIZE_BUTTON);\newline    gtk_box_pack_start(GTK_BOX(hbox2), image1, FALSE, FALSE, 0);\newline\newline    \newline    /* Variable import button text */\newline    if( global_import_users )\newline	import_msg = g_strdup_printf(&quotImport users&quot);\newline    else\newline	import_msg = g_strdup_printf(&quotImport groups&quot);\newline\newline    utf8 = g_locale_to_utf8(import_msg, strlen(import_msg), NULL, NULL, NULL);\newline    g_free(import_msg);\newline\newline    label2 = gtk_label_new_with_mnemonic(utf8);\newline    \newline    gtk_box_pack_start(GTK_BOX (hbox2), label2, FALSE, FALSE, 0);\newline    gtk_label_set_justify(GTK_LABEL(label2), GTK_JUSTIFY_LEFT);\newline\newline    /* Callback is located in import_functions.c */    		    \newline    g_signal_connect((gpointer)import_button, &quotclicked&quot,\newline                	    G_CALLBACK(import_button_clicked), widgets);\newline\newline    /* Callback is located in this file */\newline    g_signal_connect((gpointer)import_cancel_button, &quotclicked&quot,\newline                	    G_CALLBACK(import_cancel_button_clicked), widgets);\newline\newline    gtk_widget_show_all(widgets-&gtimport_window);\newline\newline\newline    /* Populate the import treeview with LOCAL users and groups except machine accounts */\newline    if( global_import_local )\newline    {\newline	if((fp=fopen(PASSWD_FILE, &quotr&quot))==NULL)\newline	{\newline    	    printf(&quotCant open passwd here:\\n%s\\n&quot, PASSWD_FILE);\newline	    return;\newline	}\newline\newline	fseek(fp, 0, SEEK_END);\newline	conf_size = ftell(fp);\newline	rewind(fp);\newline\newline	old_buffer = allocate(conf_size);          \newline	new_buffer = allocate(8192);          \newline	\newline	if( conf_size &gt 1 )\newline	while(fgets(old_buffer, conf_size, fp)!=NULL) \newline	{\newline	    if( strlen(old_buffer) &gt 10 &amp&amp strlen(old_buffer) &lt 4000 )\newline	    {\newline		for(i=0; old_buffer[i]!=&#039\\0&#039; i++)\newline	          if( old_buffer[i]==&#039:&#039 )\newline		    break;\newline\newline		strcpy(new_buffer, old_buffer);\newline		new_buffer[i]=&#039\\0&#039;\newline		\newline		/* Dont insert root or the user the server runs as */\newline		if( !strcmp(new_buffer, &quotroot&quot) || !strcmp(new_buffer, NOBODY) )\newline	          continue;\newline\newline		/* Dont insert any machine account groups */\newline		if( strstr(new_buffer, &quot$&quot) )\newline	          continue;\newline		\newline		gtk_list_store_append(GTK_LIST_STORE(widgets-&gtimport_store), &ampiter);\newline		utf8 = g_locale_to_utf8(new_buffer, strlen(new_buffer), NULL, NULL, NULL);\newline		gtk_list_store_set(GTK_LIST_STORE(widgets-&gtimport_store), &ampiter, 0, utf8, -1);\newline\newline		groupnr = get_user_setting(new_buffer, &quotgroup&quot);\newline		group_name = get_group_name(groupnr);\newline		free(groupnr);\newline\newline		utf8 = g_locale_to_utf8(group_name, strlen(group_name), NULL, NULL, NULL);\newline		gtk_list_store_set(GTK_LIST_STORE(widgets-&gtimport_store), &ampiter, 1, utf8, -1);\newline\newline		free(group_name);\newline	    }\newline	}\newline	fclose(fp);\newline	free(old_buffer);\newline	free(new_buffer);\newline    }\newline\newline\newline    /* Populate the import treeview with REMOTE users and groups */\newline    if( global_import_remote )\newline    {\newline	import_msg = g_strdup_printf(&quotRemote population is incomplete.\\n&quot);\newline	show_info(import_msg);\newline	g_free(import_msg);\newline    }\newline\newline    \newline    if( utf8 != NULL )\newline      g_free(utf8);\newline}\newline",User and group import selector \newline,4902488,pitch.h,"static OPUS_INLINE void xcorr_kernel_c(const opus_val16 * x, const opus_val16 * y, opus_val32 sum[4], int len)\newline{\newline   int j;\newline   opus_val16 y_0, y_1, y_2, y_3;\newline   celt_assert(len&gt=3);\newline   y_3=0; /* gcc doesn&#039t realize that y_3 can&#039t be used uninitialized */\newline   y_0=*y++;\newline   y_1=*y++;\newline   y_2=*y++;\newline   for (j=0;j&ltlen-3;j+=4)\newline   {\newline      opus_val16 tmp;\newline      tmp = *x++;\newline      y_3=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_0);\newline      sum[1] = MAC16_16(sum[1],tmp,y_1);\newline      sum[2] = MAC16_16(sum[2],tmp,y_2);\newline      sum[3] = MAC16_16(sum[3],tmp,y_3);\newline      tmp=*x++;\newline      y_0=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_1);\newline      sum[1] = MAC16_16(sum[1],tmp,y_2);\newline      sum[2] = MAC16_16(sum[2],tmp,y_3);\newline      sum[3] = MAC16_16(sum[3],tmp,y_0);\newline      tmp=*x++;\newline      y_1=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_2);\newline      sum[1] = MAC16_16(sum[1],tmp,y_3);\newline      sum[2] = MAC16_16(sum[2],tmp,y_0);\newline      sum[3] = MAC16_16(sum[3],tmp,y_1);\newline      tmp=*x++;\newline      y_2=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_3);\newline      sum[1] = MAC16_16(sum[1],tmp,y_0);\newline      sum[2] = MAC16_16(sum[2],tmp,y_1);\newline      sum[3] = MAC16_16(sum[3],tmp,y_2);\newline   }\newline   if (j++&ltlen)\newline   {\newline      opus_val16 tmp = *x++;\newline      y_3=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_0);\newline      sum[1] = MAC16_16(sum[1],tmp,y_1);\newline      sum[2] = MAC16_16(sum[2],tmp,y_2);\newline      sum[3] = MAC16_16(sum[3],tmp,y_3);\newline   }\newline   if (j++&ltlen)\newline   {\newline      opus_val16 tmp=*x++;\newline      y_0=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_1);\newline      sum[1] = MAC16_16(sum[1],tmp,y_2);\newline      sum[2] = MAC16_16(sum[2],tmp,y_3);\newline      sum[3] = MAC16_16(sum[3],tmp,y_0);\newline   }\newline   if (j&ltlen)\newline   {\newline      opus_val16 tmp=*x++;\newline      y_1=*y++;\newline      sum[0] = MAC16_16(sum[0],tmp,y_2);\newline      sum[1] = MAC16_16(sum[1],tmp,y_3);\newline      sum[2] = MAC16_16(sum[2],tmp,y_0);\newline      sum[3] = MAC16_16(sum[3],tmp,y_1);\newline   }\newline}\newline",OPT: This is the kernel you really want to optimize. It gets used a lot\newlineby the prefilter and by the PLC. \newline,4765266,base.c,"static void _cmd_dequeue(struct wctdm *wc, u8 *eframe, int card, int pos)\newline{\newline	struct wctdm_module *const mod = &ampwc-&gtmods[card];\newline	unsigned int curcmd=0;\newline\newline	/* QRV only use commands relating to the first channel */\newline	if ((card &amp 0x03) &amp&amp (mod-&gttype == QRV))\newline		return;\newline\newline	/* Skip audio */\newline	eframe += 24;\newline	/* Search for something waiting to transmit */\newline	if (pos) {\newline		if (!list_empty(&ampmod-&gtpending_cmds)) {\newline			struct wctdm_cmd *const cmd =\newline				list_entry(mod-&gtpending_cmds.next,\newline					   struct wctdm_cmd, node);\newline			curcmd = cmd-&gtcmd;\newline			cmd-&gtident = wc-&gttxident;\newline			list_move_tail(&ampcmd-&gtnode, &ampmod-&gtactive_cmds);\newline		}\newline	}\newline\newline	if (!curcmd) {\newline		/* If nothing else, use filler */\newline		switch (mod-&gttype) {\newline		case FXS:\newline			curcmd = CMD_RD(LINE_STATE);\newline			break;\newline		case FXO:\newline			curcmd = CMD_RD(12);\newline			break;\newline		case BRI:\newline			curcmd = 0x101010;\newline			break;\newline		case QRV:\newline			curcmd = CMD_RD(3);\newline			break;\newline		default:\newline			break;\newline		}\newline	}\newline\newline	switch (mod-&gttype) {\newline	case FXS:\newline		eframe[CMD_BYTE(mod, 0)] = (1 &lt&lt (mod-&gtsubaddr));\newline		if (curcmd &amp __CMD_WR)\newline			eframe[CMD_BYTE(mod, 1)] = (curcmd &gt&gt 8) &amp 0x7f;\newline		else\newline			eframe[CMD_BYTE(mod, 1)] = 0x80 | ((curcmd &gt&gt 8) &amp 0x7f);\newline		eframe[CMD_BYTE(mod, 2)] = curcmd &amp 0xff;\newline		break;\newline\newline	case FXO:\newline	{\newline		static const int ADDRS[4] = {0x00, 0x08, 0x04, 0x0c};\newline		if (curcmd &amp __CMD_WR)\newline			eframe[CMD_BYTE(mod, 0)] = 0x20 | ADDRS[mod-&gtsubaddr];\newline		else\newline			eframe[CMD_BYTE(mod, 0)] = 0x60 | ADDRS[mod-&gtsubaddr];\newline		eframe[CMD_BYTE(mod, 1)] = (curcmd &gt&gt 8) &amp 0xff;\newline		eframe[CMD_BYTE(mod, 2)] = curcmd &amp 0xff;\newline		break;\newline	}\newline	case FXSINIT:\newline		/* Special case, we initialize the FXS&#039s into the three-byte command mode then\newline		   switch to the regular mode.  To send it into thee byte mode, treat the path as\newline		   6 two-byte commands and in the last one we initialize register 0 to 0x80. All modules\newline		   read this as the command to switch to daisy chain mode and we&#039re done.  */\newline		eframe[CMD_BYTE(mod, 0)] = 0x00;\newline		eframe[CMD_BYTE(mod, 1)] = 0x00;\newline		if ((card &amp 0x1) == 0x1) \newline			eframe[CMD_BYTE(mod, 2)] = 0x80;\newline		else\newline			eframe[CMD_BYTE(mod, 2)] = 0x00;\newline		break;\newline\newline	case BRI:\newline		if (unlikely((curcmd != 0x101010) &amp&amp (curcmd &amp 0x1010) == 0x1010)) /* b400m CPLD */\newline			eframe[CMD_BYTE(mod, 0)] = 0x55;\newline		else /* xhfc */\newline			eframe[CMD_BYTE(mod, 0)] = 0x10;\newline		eframe[CMD_BYTE(mod, 1)] = (curcmd &gt&gt 8) &amp 0xff;\newline		eframe[CMD_BYTE(mod, 2)] = curcmd &amp 0xff;\newline		break;\newline\newline	case QRV:\newline		eframe[CMD_BYTE(mod, 0)] = 0x00;\newline		if (!curcmd) {\newline			eframe[CMD_BYTE(mod, 1)] = 0x00;\newline			eframe[CMD_BYTE(mod, 2)] = 0x00;\newline		} else {\newline			if (curcmd &amp __CMD_WR)\newline				eframe[CMD_BYTE(mod, 1)] = 0x40 | ((curcmd &gt&gt 8) &amp 0x3f);\newline			else\newline				eframe[CMD_BYTE(mod, 1)] = 0xc0 | ((curcmd &gt&gt 8) &amp 0x3f);\newline			eframe[CMD_BYTE(mod, 2)] = curcmd &amp 0xff;\newline		}\newline		break;\newline\newline	case NONE:\newline		eframe[CMD_BYTE(mod, 0)] = 0x10;\newline		eframe[CMD_BYTE(mod, 1)] = 0x10;\newline		eframe[CMD_BYTE(mod, 2)] = 0x10;\newline		break;\newline	}\newline}\newline",Call with wc-&gtreglock held and local interrupts disabled \newline,3414826,tpage.c,"void tpage_clear(void)\newline{\newline	GtkTextBuffer *buffer;\newline\newline	/* target */\newline	gtk_entry_set_text(GTK_ENTRY(target_name), &quot&quot);\newline	\newline	/* reset debugger type */\newline	gtk_combo_box_set_active(GTK_COMBO_BOX(debugger_cmb), 0);\newline\newline	/* arguments */\newline	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(args_textview));\newline	gtk_text_buffer_set_text(buffer, &quot&quot, -1);\newline\newline	/* environment variables */\newline	envtree_clear();\newline}\newline",\newline removes all data (clears widgets)\newline \newline,1526271,plotscreen.cpp,"void PlotWidget::drawGraph(QPainter&amp p)\newline{\newline  for (unsigned i = 0; i &lt vecList.size(); i++) {\newline    calcXIndex(i);\newline\newline    int currentWidth = curveLineWidth;\newline    if (vecList.size() &gt 1 &amp&amp i == activeCurve)\newline      currentWidth += 2;\newline    QPen curvePen(colorList[i], currentWidth);\newline    p.setPen(curvePen);\newline\newline    unsigned currentMode = plotModeList[i];\newline    plotVector = new VB_Vector(vecList[i]);\newline    if (currentMode == 1)\newline      drawInMode1(p, i);\newline    else if (currentMode == 2)\newline      drawInMode2(p, i);\newline    else if (currentMode == 3)\newline      drawInMode3(p, i);\newline    else if (currentMode == 4)\newline      drawInMode4(p, i);\newline    else \newline      printf(&quotdrawGraph(): invalid plot mode.\\n&quot);\newline  }\newline\newline}\newline","drawGraph() draws the graph inside, it&#039s only a wrapper for drawInModeX() (X is 1, 2, 3 or 4) \newline",1834650,rince.cpp,"void SetMoverWalkReel(PMOVER pMover, DIRECTION reel, int scale, bool force) {\newline	SCNHANDLE	whichReel;\newline	const FILM *pfilm;\newline\newline	// Kill off any play that may be going on for this actor\newline	// and restore the real actor\newline	storeActorReel(pMover-&gtactorID, NULL, 0, NULL, 0, 0, 0);\newline	UnHideMover(pMover);\newline\newline	// Don&#039t do it if using a special walk reel\newline	if (pMover-&gtbWalkReel)\newline		return;\newline\newline	if (force || pMover-&gtscale != scale || pMover-&gtdirection != reel) {\newline		assert(reel &gt= 0 &amp&amp reel &lt= 3 &amp&amp scale &gt 0 &amp&amp scale &lt= TOTAL_SCALES); // out of range scale or reel\newline\newline		// If scale change and both are regular scales\newline		// and there&#039s a scaling reel in the right direction\newline		if (pMover-&gtscale != scale\newline				&amp&amp scale &lt= NUM_MAINSCALES &amp&amp pMover-&gtscale &lt= NUM_MAINSCALES\newline				&amp&amp (whichReel = ScalingReel(pMover-&gtactorID, pMover-&gtscale, scale, reel)) != 0) {\newline//			error(&quotCripes&quot);\newline			;	// Use what is now in &#039whichReel&#039\newline		} else {\newline			whichReel = pMover-&gtwalkReels[scale-1][reel];\newline			assert(whichReel); // no reel\newline		}\newline\newline		pfilm = (const FILM *)LockMem(whichReel);\newline		assert(pfilm != NULL); // no film\newline\newline		InitStepAnimScript(&amppMover-&gtactorAnim, pMover-&gtactorObj, FROM_32(pfilm-&gtreels[0].script), 1);\newline\newline		// Synchronised walking reels\newline		assert(pMover-&gtstepCount &gt= 0);\newline		SkipFrames(&amppMover-&gtactorAnim, pMover-&gtstepCount);\newline\newline		pMover-&gtscale = scale;\newline		pMover-&gtdirection = reel;\newline	}\newline}\newline",\newline Get actor to adopt its appropriate walking reel.\newline \newline,2673405,glibcurl.c,"gboolean prepare(GSource* source, gint* timeout) {\newline  assert(source == &ampcurlSrc-&gtsource);\newline  D((stderr, &quotprepare: callPerform=%d, thread=%p\\n&quot,\newline     curlSrc-&gtcallPerform, curlSrc-&gtselectThread));\newline\newline  *timeout = -1;\newline\newline  if (g_atomic_int_dec_and_test(&ampcurlSrc-&gtgtkBlockAndWait)) {\newline    /* The select thread wants us to block */\newline    D((stderr, &quotprepare: trying lock\\n&quot));\newline    g_mutex_lock(curlSrc-&gtmutex);\newline    D((stderr, &quotprepare: got lock\\n&quot));\newline    return TRUE;\newline  } else {\newline    g_atomic_int_inc(&ampcurlSrc-&gtgtkBlockAndWait);\newline  }\newline\newline  /* Usual behaviour: Nothing happened, so don&#039t dispatch. */\newline  if (!curlSrc-&gtcallPerform) return FALSE;\newline\newline  /* Always dispatch if callPerform, i.e. 1st download just starting. */\newline  D((stderr, &quotprepare: trying lock 2\\n&quot));\newline  /* Problem: We can block up to GLIBCURL_TIMEOUT msecs here, until the\newline     select() call returns. However, under Win32 this does not appear to be a\newline     problem (don&#039t know why) - it _does_ tend to block the GTK thread under\newline     Linux. */\newline  g_mutex_lock(curlSrc-&gtmutex);\newline  D((stderr, &quotprepare: got lock 2\\n&quot));\newline  curlSrc-&gtcallPerform = FALSE;\newline  if (curlSrc-&gtselectThread == NULL) {\newline    D((stderr, &quotprepare: starting select thread\\n&quot));\newline    /* Note that the thread will stop soon because we hold mutex */\newline    curlSrc-&gtselectThread = g_thread_create(&ampselectThread, 0, FALSE, NULL);\newline    assert(curlSrc-&gtselectThread != NULL);\newline  }\newline  return TRUE;\newline}\newline",Returns TRUE iff it holds the mutex lock \newline,,,,,,on,,,,,,on,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,Resolve abstract address object to a name using getnameinfo().,Load an image from the named file.,"Non-collectable objects are never removed from weak
tables.",Display memory window,Get ping time for a configuration item.,{},User and group import selector,This is the kernel you really want to optimize.,Call with wc->reglock held,removes all data,"draws the graph inside,",{},Get actor to adopt its appropriate walking reel.,Returns TRUE iff it holds the mutex lock,"Parses definstance name and optional comment
and optional ""active"" keyword",decode a binary patch into a hunk list,Render the peak points,"Ensure a buffer to be utf-8, and convert if necessary",{},Sets the constraintmodel displayed by this view.,"nearest green neighbors are above-left,",x,
3OWZNK3RYLPU1MJG1S8PYU87ML82U0,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:31 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:31 PDT 2019,,,3HPZF4IVNMTQ3XSGYOZL2BJVCW5CYC,AITP2LUW8GPB,Submitted,Fri Apr 26 14:15:03 PDT 2019,Fri Apr 26 14:20:07 PDT 2019,Sun Apr 28 14:20:07 PDT 2019,,,,304,100% (62/62),100% (62/62),0% (0/0),5790626,oct_hmat.c,"inline bound_t* hmat_alloc(oct_internal_t* pr, size_t dim)\newline{\newline  bound_t* r;\newline  size_t sz = matsize(dim);\newline  if (!sz) sz = 1; /* make sure we never malloc a O-sized block */\newline  checked_malloc(r,bound_t,sz,return NULL;);\newline  bound_init_array(r,matsize(dim));\newline  return r;\newline}\newline",alloced but not initialized \newline,4284136,shfile.c,"static int shfile_trailing_slash_hack(char *abspath)\newline{\newline    /*\newline     * Anything worth adjust here?\newline     */\newline    size_t path_len = strlen(abspath);\newline    if (   path_len == 0\newline        || (   abspath[path_len - 1] != &#039/&#039\newline#  if K_OS == K_OS_WINDOWS || K_OS == K_OS_OS2\newline            &amp&amp abspath[path_len - 1] != &#039\\\\&#039\newline#  endif\newline           )\newline       )\newline        return 0;\newline\newline    /*\newline     * Ok, make the adjustment.\newline     */\newline    if (path_len + 2 &lt= SHFILE_MAX_PATH)\newline    {\newline        /* Add a &#039.&#039 to the end. */\newline        abspath[path_len++] = &#039.&#039;\newline        abspath[path_len]   = &#039\\0&#039;\newline    }\newline    else\newline    {\newline        /* No space for a dot, remove the slash if it&#039s alone or just remove\newline           one and add a dot like above. */\newline        if (   abspath[path_len - 2] != &#039/&#039\newline#  if K_OS == K_OS_WINDOWS || K_OS == K_OS_OS2\newline            &amp&amp abspath[path_len - 2] != &#039\\\\&#039\newline#  endif\newline           )\newline            abspath[--path_len] = &#039\\0&#039;\newline        else\newline            abspath[path_len - 1] = &#039.&#039;\newline    }\newline\newline    return 1;\newline}\newline","\newline Adjusts the file name if it ends with a trailing directory slash.\newline \newline Windows APIs doesn&#039t like trailing slashes.\newline \newline @returns 1 if it has a directory slash, 0 if not.\newline \newline @param abspath The path to adjust (SHFILE_MAX_PATH).\newline \newline",4577803,gkremldk.c,"void *donkey_update(void *arg) {\newline\newline	donkeyMsg msg;\newline	gint      downloads = 0;\newline	gint      downloads_ended = 0;\newline	gint      nb_shared = 0;\newline	gfloat    shared_size = 0;\newline\newline	int n;\newline\newline	while (1) {\newline\newline		//Main Loop, try to connect permanently\newline\newline		close(sockfd);\newline		isConnected = FALSE;\newline		gkrellm_draw_decal_text(panel_cmd, start_stop_decal,\newline			_(&quotStart core&quot), -1);\newline		haveToReconnect = FALSE;\newline\newline/*		printf(&quotTempting Connection mldonkey://%s:%s@%s:%d\\n&quot,*/\newline/*				login, password, host, port);*/\newline		if (!donkeyConnect(&ampsockfd, host, port, login, password)) {\newline			sleep(3);\newline			continue;\newline		}\newline\newline\newline		while (!haveToReconnect) {\newline\newline			// Read donkey message\newline\newline			if ((n = readMsg(sockfd, &ampmsg)) &lt= 0) {\newline/*				printf(&quotOooops: readMsg returned %d, either server is&quot*/\newline/*					&quot disconnected, or login/password are incorrect.\\n&quot,n);*/\newline				sleep(3);\newline				break;\newline			}\newline\newline			// manage message, depending on opcode\newline			// See http://www.g2gui.net/wiki/index.php/GuiProtocol\newline\newline			switch(msg.opcode) {\newline				case 49:\newline					// clientStats\newline					shared_size = (readLong(&ampmsg) / 1000000.0); // 1\newline					readLong(&ampmsg); // 2\newline					readLong(&ampmsg); // 3\newline					readLong(&ampmsg); // 4\newline					readLong(&ampmsg); // 5\newline					readLong(&ampmsg); // 6\newline					nb_shared = readLong(&ampmsg); // 7\newline					ul_rate = (readLong(&ampmsg) / 1000.0); // 8\newline					dl_rate = (readLong(&ampmsg) / 1000.0); // 9\newline					readLong(&ampmsg); // 10\newline					readLong(&ampmsg); // 11\newline					downloads = readLong(&ampmsg); // 12\newline					downloads_ended = readLong(&ampmsg); // 13\newline					//current_downloads = readLong(&ampmsg);  // 10\newline\newline					sprintf(tooltip_text,\newline							&quot%s: %1.3f\\n%s: %1.3f\\n%s: %d/%d\\n&quot\newline							&quot%s: %d(%1.3f %s)&quot,\newline							_(&quotDownload&quot), dl_rate,\newline							_(&quotUpload&quot), ul_rate,\newline							_(&quotDownloaded&quot), downloads_ended, downloads,\newline							_(&quotShared&quot), nb_shared, shared_size, _(&quotMb&quot));\newline\newline					// consider we are connected when this kind of msg is received\newline					isConnected = TRUE;\newline					gkrellm_draw_decal_text(panel_cmd, start_stop_decal,\newline						_(&quotStop core&quot), -1);\newline					break;\newline\newline				case 1:\newline					// optionsInfos\newline					{\newline						short int nb = readInt(&ampmsg);\newline						short int i;\newline						for (i = 0; i &lt nb; i++) {\newline							char *key = readString(&ampmsg);\newline							char *value = readString(&ampmsg);\newline							if (key != NULL &amp&amp value != NULL) {\newline								if (strncmp(key, &quotmax_hard_upload_rate&quot, 20) == 0)\newline									ul_rate_max = atof(value);\newline								else if (strncmp(key, &quotmax_hard_download_rate&quot, 22) == 0)\newline									dl_rate_max = atof(value);\newline							}\newline							free(key); free(value);\newline						}\newline					}\newline					break;\newline\newline				default:\newline					break;\newline			}\newline			\newline			freeMsg(&ampmsg);\newline\newline		}\newline\newline	}\newline\newline}\newline",Donkey Thread \newline,5104400,flowtree.c,uint32_t CacheCheck(void) {\newline	return FLOWELEMENTNUM - NumFlows;\newline} // End of CacheCheck\newline,safety check - this must never become 0 - otherwise the cache is too small \newline,3515795,url.c,"void url_hostname(const char *url,char *hostname,int hostsize)\newline{\newline	int i;\newline\newline	hostsize--;\newline	for (i=0 ; i&lthostsize &amp&amp url[i] &amp&amp url[i]!=&#039/&#039 ; i++)\newline		hostname[i]=url[i];\newline	hostname[i]=&#039\\0&#039;\newline}\newline",!\newlineExtract the host name from the URL.\newline\\param url The url whose host name must be extracted.\newline\\param hostname The buffer to store the host name.\newline\\param hostsize The size of the host name buffer.\newline\\note The function is stupid at this time. It just searches for the first slash\newlinein the URL and truncates the URL there. It doesn&#039t take the protocol into account\newlinenor the port number nor any user or password information.\newline \newline,4214838,cmodel.c,"static void CM_LoadClipnodes (lump_t *l)\newline{\newline	dclipnode_t *in, *out;\newline	int i, count;\newline\newline	in = (void *)(cmod_base + l-&gtfileofs);\newline\newline	if (l-&gtfilelen % sizeof(*in))\newline		Host_Error (&quotCM_LoadMap: funny lump size&quot);\newline\newline	count = l-&gtfilelen / sizeof(*in);\newline	out = Hunk_AllocName ( count*sizeof(*out), loadname);\newline\newline	map_clipnodes = out;\newline	numclipnodes = count;\newline\newline	for (i = 0; i &lt count; i++, out++, in++)\newline	{\newline		out-&gtplanenum = LittleLong(in-&gtplanenum);\newline		out-&gtchildren[0] = LittleShort(in-&gtchildren[0]);\newline		out-&gtchildren[1] = LittleShort(in-&gtchildren[1]);\newline	}\newline}\newline",\newline=================\newlineCM_LoadClipnodes\newline=================\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,89796,attr_list.c,"void add_h_item(struct history_info *h, GtkWidget *w, GList* element, gint which)\newline{\newline	GList *ele;\newline	GList *op=NULL;\newline	switch(which){\newline		case OPERATE_DELETE:\newline			op=h-&gtdelete_list;\newline			break;\newline		case OPERATE_PERSIST:\newline			op=h-&gtpersist_list;\newline			break;\newline		default:\newline			g_fprintf(stderr,&quotInvalid list &#039%d&#039\\n&quot,which);\newline			return;\newline	}\newline	struct s_item_info *i;\newline	if(NULL == (ele=find_h_item(op,w,element) ) ){\newline		if(NULL != (i=g_malloc(sizeof(struct s_item_info)) ) ){\newline			i-&gtitem=w;\newline			i-&gtelement=element;\newline			switch(which){\newline				case OPERATE_DELETE:\newline					h-&gtdelete_list=g_list_prepend(op,(gpointer)i);\newline					break;\newline				case OPERATE_PERSIST:\newline					h-&gtpersist_list=g_list_prepend(op,(gpointer)i);\newline					break;\newline			}\newline			\newline			/*g_printf(&quotAdded w %p e %p %p\\n&quot,w,element,h-&gtdelete_list);	fflush(NULL); */\newline		}/*else g_fprintf(stderr,&quot%s: NULL allocating element for delete list!\\n&quot,__func__);	 */\newline	}/*else g_printf(&quotfound element??\\n&quot); */\newline}\newline",Add an item to the history delete list.\newline\\n\\b Arguments:\newline\\n\\b Returns:\newline \newline,2491832,error.c,"void err_quit(const char *fmt, ...) {\newline    va_list ap;\newline    va_start(ap, fmt);\newline    err_doit(0, 0, fmt, ap);\newline    va_end(ap);\newline    exit(1);\newline}\newline",\newline Fatal error unrelated to a system call.\newline Print a message and terminate.\newline \newline,636276,chat-details-room.cpp,bool ChatDetailsRoom::shouldStore()\newline{\newline	ensureLoaded();\newline\newline	return StorableObject::shouldStore() &amp&amp !m_room.isEmpty();\newline}\newline,\newline @author Rafal &#039Vogel&#039 Malinowski\newline @short Returns true if room name is not empty.\newline @return true if room name is not empty\newline \newline Returns true if assigned room name is not empty is not empty.\newline \newline,6308292,fors_stack-test.c,int main(void)\newline{\newline    TEST_INIT;\newline\newline    /* cpl_msg_set_level(CPL_MSG_DEBUG); */\newline    test_stack();\newline\newline    TEST_END;\newline}\newline,\newline @brief Test of image stacking module\newline \newline,6645919,swstring.c,int     isnumstring(unsigned char *s)\newline{\newline    if (!s || !*s)\newline        return 0;\newline    for (; *s; s++)\newline        if (!isdigit((int) (*s)))\newline            break;\newline    if (*s)\newline        return 0;\newline    return 1;\newline}\newline,Routine to check if a string contains only numbers \newline,4492765,set.c,"void set_on( set_type set )\newline{\newline   register long int nbytes,i, bufsize, nbyte;\newline#if !defined(__MSDOS__)\newline   unsigned\newline#endif\newline   char byte=255, *buf;\newline\newline   if (set.diskstorage) {\newline      rewind(set.fp);\newline      nbytes = NBYTES(set);\newline      /* Use buffered reads and writes to set blocks of bits */\newline      nbyte = 0;\newline      while (nbyte &lt nbytes) {\newline#ifdef __MSDOS__\newline	 bufsize = (long int)min(nbytes-nbyte,farcoreleft()/2L);\newline 	buf = (char*)malloc(bufsize);\newline#else\newline	 bufsize = (long int)(nbytes-nbyte);\newline	buf = (unsigned char*)malloc(bufsize);\newline#endif\newline	 memset(buf,byte,bufsize);\newline	 fwrite(buf,bufsize,1,set.fp);\newline	 free(buf);\newline	 nbyte += bufsize;\newline      }\newline\newline   } else {\newline      /* Turn on all bits up through set.size. */\newline      /* All but the last byte. */\newline      memset(set.buf,byte,set.size&gt&gt3L);\newline      /* The valid bits of the last byte. */\newline      for (i=(set.size&gt&gt3L)*8L;i&lt=set.size;i++)\newline	 set_insert(i,set);\newline   }\newline}\newline",\newline \newline N set_on\newline \newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Purpose:\newline P\newline Turns each element in the set &#039on&#039.\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Parameters:\newline A\newline set &ltinout&gt == (set_type) set to be acted upon.\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline History:\newline H\newline Barry Michaels Nov 1991 DOS Turbo C\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline External Variables:\newline X\newline None\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Functions Called:\newline F\newline None\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Portability:\newline O\newline This function conforms to ANSI C standards.\newline E\newline \newline,2810641,htmltext.c,"static Tcl_UniChar utf8Read(\newline  const unsigned char *z,         /* first byte of utf-8 character */\newline  const unsigned char *zTerm,     /* pretend this byte is 0x00 */\newline  const unsigned char **pzNext    /* write first byte past utf-8 char here */\newline){\newline    static const unsigned char UtfTrans[] = {\newline        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\newline        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\newline        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\newline        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\newline        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\newline        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\newline        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\newline        0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,\newline    };\newline\newline    unsigned int c = 0;\newline    if (zTerm&gtz) {\newline        c = (unsigned int)*z;\newline        if ((c&amp0xC0)==0xC0) {\newline            const unsigned char *zCsr = &ampz[1];\newline            c = UtfTrans[c-0xC0];\newline            while (zCsr!=zTerm &amp&amp ((*zCsr)&amp0xC0)==0x80){\newline                c = (c &lt&lt 6) + ((*zCsr)&amp0x3F);\newline                zCsr++;\newline            }\newline            *pzNext = zCsr;\newline        } else {\newline            *pzNext = &ampz[1];\newline        }\newline    } else {\newline      *pzNext = zTerm;\newline    }\newline  \newline    return c;\newline}\newline","\newline ---------------------------------------------------------------------------\newline \newline utf8Read --\newline \newline Decode a single UTF8 character from the buffer pointed to by z.\newline \newline Results:\newline Unicode codepoint of read character, or 0 if the end of the buffer\newline has been reached.\newline \newline Side effects:\newline None.\newline \newline ---------------------------------------------------------------------------\newline \newline",1427237,vmtable.c,void deleteColumnValue(VimosColumnValue *dValue)\newline{\newline  if (dValue) {\newline    cpl_free(dValue-&gtp);\newline    cpl_free(dValue);\newline  }\newline  \newline}\newline,Desctructor of VimosColumnValue \newline,5745230,net.c,"Net *new_Net(const char *name,nettype_t ntype,unsigned msb,unsigned lsb)\newline{\newline  Net *n = (Net*) malloc(sizeof(Net));\newline  Value *value = Net_getValue(n);\newline\newline  n-&gtn_name = strdup(name);\newline  n-&gtn_msb = msb;\newline  n-&gtn_lsb = lsb;\newline  n-&gtn_nbits = iabs(msb-lsb) + 1;\newline  n-&gtn_drivers = 0;\newline  n-&gtn_type = ntype;\newline  n-&gtn_flags = 0;\newline  n-&gtn_numMonitors = 0;\newline  n-&gtn_numDrivers = 0;\newline  n-&gtn_wfunc = Value_wire;\newline  List_init(&ampn-&gtn_posedgeNotify);\newline  List_init(&ampn-&gtn_negedgeNotify);\newline  Value_init(Net_getValue(n),n-&gtn_nbits);\newline\newline  if ((n-&gtn_type &amp NT_P_AND))\newline    n-&gtn_wfunc = Value_wand;\newline  else if ((n-&gtn_type &amp NT_P_OR))\newline    n-&gtn_wfunc = Value_wor;\newline  else if ((n-&gtn_type &amp NT_P_PULL0))\newline    n-&gtn_wfunc = Value_tri0;\newline  else if ((n-&gtn_type &amp NT_P_PULL1))\newline    n-&gtn_wfunc = Value_tri1;\newline\newline  switch ((n-&gtn_type &amp NT_P_REGTYPE_MASK)) {\newline  case NT_P_REAL :\newline    value-&gtflags = SF_REAL;\newline    break;\newline  case NT_P_INTEGER :\newline  case NT_P_TIME :\newline    value-&gtflags = SF_INT;\newline    break;\newline  }\newline\newline  \newline  if (NT_GET_0STR(ntype) &amp&amp !NT_GET_1STR(ntype)) {\newline    Value_zero(value);\newline    if (NT_GET_0STR(ntype) == NT_P_SUPPLY0) n-&gtn_flags = NA_FIXED;\newline  } else if (NT_GET_1STR(ntype) &amp&amp !NT_GET_0STR(ntype)) {\newline    Value_one(value);\newline    if (NT_GET_1STR(ntype) == NT_P_SUPPLY1) n-&gtn_flags = NA_FIXED;\newline  } else if ((ntype &amp NT_P_WIRE)) {\newline    Value_float(value);\newline  } else {\newline    Value_unknown(value);\newline  }\newline\newline  value-&gtpermFlags = SF_NETVAL | value-&gtflags;\newline\newline  return n;\newline}\newline",\newline \newline Create a new Net\newline \newline Parameter:\newline name Name of net\newline ntype Type code of net\newline msb MSB of net\newline lsb LSB of net\newline \newline \newline \newline \newline,5201567,misc.c,"int gnokii_strcmpsep(const char *s1, const char *s2, char sep)\newline{\newline	while (isblank(*s2))\newline		s2++;\newline	while (*s1 &amp&amp *s1 == *s2) {\newline		s1++;\newline		s2++;\newline	}\newline	while (isblank(*s2))\newline		s2++;\newline	if (!*s1 &amp&amp *s2 == sep)\newline		return 0;\newline\newline	return *s1 - *s2;\newline}\newline","\newline gnokii_strcmpsep:\newline @s1: a string, NUL terminated, may NOT contain @sep\newline @s2: a string, NUL terminated, may contain @sep\newline @sep: comparison stops if this char is found in @s2\newline \newline Returns: &lt 0 if @s1 &lt @s2\newline 0 if @s1 == @s2\newline &gt 0 if @s1 &gt @s2\newline \newline Compares two strings up to a NUL terminator or a separator char.\newline Leading and trailing white space in @s2 is ignored.\newline \newline",5184015,kjbucketsmodule.c,"static long GroupDump(Groupptr g, enum BucketFlag flag, FILE *fp)\newline{\newline  Bucketptr Bp;\newline  long i;\newline  fprintf(fp, &quotGroup:&quot);\newline  for (i=0; i&ltGSIZE; i++) {\newline    GetBucket(Bp, g, flag, i);\newline    if (BPtrDump(Bp,flag,fp) != 0) { return -1; }\newline  }\newline  fprintf(fp, &quot\\n&quot);\newline  return 0;\newline}\newline",test printing \newline,418941,regiong.cpp,"bool REGION::XEqualRegion(Region r1, Region r2)\newline{\newline    int i;\newline\newline    if( r1-&gtnumRects != r2-&gtnumRects ) return false;\newline    else if( r1-&gtnumRects == 0 ) return true;\newline    else if ( r1-&gtextents.x1 != r2-&gtextents.x1 ) return false;\newline    else if ( r1-&gtextents.x2 != r2-&gtextents.x2 ) return false;\newline    else if ( r1-&gtextents.y1 != r2-&gtextents.y1 ) return false;\newline    else if ( r1-&gtextents.y2 != r2-&gtextents.y2 ) return false;\newline    else for( i=0; i &lt r1-&gtnumRects; i++ ) {\newline            if ( r1-&gtrects[i].x1 != r2-&gtrects[i].x1 ) return false;\newline            else if ( r1-&gtrects[i].x2 != r2-&gtrects[i].x2 ) return false;\newline            else if ( r1-&gtrects[i].y1 != r2-&gtrects[i].y1 ) return false;\newline            else if ( r1-&gtrects[i].y2 != r2-&gtrects[i].y2 ) return false;\newline    }\newline    return true;\newline}\newline",\newline Check to see if two regions are equal\newline \newline,4486723,cg_marks.c,void CG_FreeMarkPoly( markPoly_t *le ) {\newline	if ( !le-&gtprevMark ) {\newline		CG_Error( &quotCG_FreeLocalEntity: not active&quot );\newline	}\newline\newline	// remove from the doubly linked active list\newline	le-&gtprevMark-&gtnextMark = le-&gtnextMark;\newline	le-&gtnextMark-&gtprevMark = le-&gtprevMark;\newline\newline	// the free list is only singly linked\newline	le-&gtnextMark = cg_freeMarkPolys;\newline	cg_freeMarkPolys = le;\newline}\newline,\newline==================\newlineCG_FreeMarkPoly\newline==================\newline \newline,85416,str.c,"GLOBAL int qreplace_all (	char *source,\newline							const char *replace,\newline							const size_t rlen,\newline							const char *by,\newline							const size_t blen\newline						)\newline{\newline	char 	*found;\newline	size_t	flen, i;\newline\newline#if CHECK_REPLACE_LEN\newline	if (rlen!=strlen(replace))\newline	{	fprintf(stdout, &quotFehler in qreplace_all:\\n&quot);\newline		fprintf(stdout, &quotrlen= %d\\n&quot, rlen);\newline		fprintf(stdout, &quotstrlen(%s)= %d\\n&quot, replace, strlen(replace));\newline	}\newline	if (blen!=strlen(by))\newline	{	fprintf(stdout, &quotFehler in qreplace_all:\\n&quot);\newline		fprintf(stdout, &quotblen= %d\\n&quot, blen);\newline		fprintf(stdout, &quotstrlen(%s)= %d\\n&quot, by, strlen(by));\newline	}\newline#endif\newline	\newline	if ( source[0]==&#039\\0&#039 )		return 0;\newline	if ( replace[0]==&#039\\0&#039 )		return 0;\newline\newline	if ( (found= strstr(source, replace))==NULL )	return 0;\newline\newline	if (rlen==blen)\newline	{\newline		while ( found!=NULL )\newline		{\newline			for (i=0; i&ltblen; i++)\newline			{	found[i]= by[i];\newline			}\newline			found= strstr(found+blen, replace);\newline		}\newline		return 1;\newline	}\newline\newline	while ( found!=NULL )\newline	{	flen= strlen(found);\newline\newline		/* Zu Ersetzendes entfernen */\newline		memmove(found, found+rlen, flen-rlen+1);\newline	\newline		/* Platz schaffen fuer neues und dorthin kopieren */\newline		if ( by[0]!=EOS )\newline		{	flen= strlen(found);\newline			memmove(found+blen, found, flen+1);\newline			memcpy(found, by, blen);\newline			found= strstr(found+blen, replace);\newline		}\newline		else\newline		{	found= strstr(found, replace);\newline		}\newline		\newline	}\newline\newline	return 1;\newline}	/* qreplace_all */\newline",------------------------------------------------------------\newline qreplace_all() ersetzt in &lts&gt alle &ltrep&gt durch &ltby&gt\newline ------------------------------------------------------------ \newline,,,,,,,,on,,,,,on,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,alloced but not initialized,Returns true if assigned room name is not empty is not empty.,Test of image stacking module,Routine to check if a string contains only numbers,This function conforms to ANSI C standards.,Decode a single UTF8 character from the buffer pointed to by z.,Desctructor of VimosColumnValue,{},Compares two strings,test printing,Check to see if two regions are equal,Adjusts the file name,{},{},Donkey Thread,safety check,Extract the host name from the URL.,{},Load an image from the named file.,Add an item to the history delete list.,Fatal error unrelated to a system call.,x,
301KG0KX9CLPW0DW1T1QFFJHSD6H2E,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:47 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:47 PDT 2019,,,3ZV9H2YQQD7Y1S1XQU6WOBULVB13WF,AITP2LUW8GPB,Submitted,Fri Apr 26 16:03:41 PDT 2019,Fri Apr 26 16:09:47 PDT 2019,Sun Apr 28 16:09:47 PDT 2019,,,,366,100% (62/62),100% (62/62),0% (0/0),676123,tokenize.c,"static bool is_common_entity(Dictionary dict, const char * str)\newline{\newline	if (word_contains(dict, str, COMMON_ENTITY_MARKER) == 1)\newline		return true;\newline	return false;\newline}\newline","\newline is_common_entity - Return true if word is a common noun or adjective\newline Common nouns and adjectives are typically used in corporate entity\newline names -- e.g. &quotSun State Bank&quot -- &quotsun&quot, &quotstate&quot and &quotbank&quot are all\newline common nouns.\newline \newline",3660711,regfi.c,"REGFI_BUFFER regfi_conv_charset(const char* input_charset, const char* output_charset,\newline                                uint8_t* input, uint32_t input_len)\newline{\newline  iconv_t conv_desc;\newline  char* inbuf = (char*)input;\newline  char* outbuf;\newline  char* retbuf;\newline  size_t allocated = (size_t)input_len;\newline  size_t in_left = (size_t)input_len;\newline  size_t out_left = (size_t)allocated-1;\newline  REGFI_BUFFER ret_val;\newline  int ret;\newline\newline  ret_val.buf = NULL;\newline  ret_val.len = 0;\newline  retbuf = talloc_array(NULL, char, allocated);\newline  outbuf = retbuf;\newline  if(outbuf == NULL)\newline  {\newline    errno = ENOMEM;\newline    return ret_val;\newline  }\newline\newline  /* Set up conversion descriptor. */\newline  /* XXX: Consider creating a couple of conversion descriptors earlier,\newline   *      storing them on an iterator so they don&#039t have to be recreated\newline   *      each time.\newline   */\newline  conv_desc = iconv_open(output_charset, input_charset);\newline\newline  ret = 0;\newline  do\newline  {\newline    if(ret == -1)\newline    {\newline      retbuf = talloc_realloc(NULL, retbuf, char, allocated+(in_left*2));\newline      if(retbuf == NULL)\newline      {\newline        errno = ENOMEM;\newline        return ret_val;\newline      }\newline      outbuf = retbuf+(allocated-1-out_left);\newline      out_left += in_left*2;\newline      allocated += in_left*2;\newline    }\newline    ret = iconv(conv_desc, &ampinbuf, &ampin_left, &ampoutbuf, &ampout_left);\newline    \newline  } while(ret == -1 &amp&amp errno == E2BIG);\newline  \newline  if(ret == -1)\newline  {\newline    iconv_close(conv_desc);\newline    return ret_val;\newline  }\newline\newline  /* Save memory */\newline  if(out_left &gt 0)\newline  {\newline    retbuf = talloc_realloc(NULL, retbuf, char, allocated-out_left);\newline    if(retbuf == NULL)\newline    {\newline      errno = ENOMEM;\newline      return ret_val;\newline    }\newline    allocated -= out_left;\newline  }\newline  retbuf[allocated-1] = &#039\\0&#039;\newline  iconv_close(conv_desc);\newline\newline  ret_val.buf = (uint8_t*)retbuf;\newline  ret_val.len = allocated-1;\newline  return ret_val;\newline}\newline","\newline Convert string from input_charset to output_charset.\newline On error, returns a NULL buf attribute and sets the errno.\newline \newline",6675782,packets.c,"int get_player_nr (char *host, char *port) {\newline    int i,\newline      res;\newline\newline    for (i = 0, res = -1; (i &lt MAX_PLAYERS &amp&amp res == -1); i++) {\newline        if (players[i].net.addr.host[0] != 0)\newline            if ((strcmp (players[i].net.addr.host, host) == 0)\newline                &amp&amp (strcmp (players[i].net.addr.port, port) == 0))\newline                res = i;\newline    }\newline    return res;\newline}\newline","\newline help function to get the playernumber from the address.\newline this function does not indicate which player it is, this function only checks\newline if the packet comed from a known player\newline \newline",2205020,fitsmisc.c,"void    warning(char *msg1, char *msg2)\newline  {\newline   time_t	warntime;\newline   struct tm	*tm;\newline\newline  warntime = time(NULL);\newline  tm = localtime(&ampwarntime);\newline \newline  fprintf(stderr, &quot\\n&gt WARNING: %s%s\\n\\n&quot,msg1,msg2);\newline  sprintf(warning_historystr[(nwarning++)%WARNING_NMAX],\newline	&quot%04d-%02d-%02d %02d:%02d:%02d : %.80s%.80s&quot,\newline	tm-&gttm_year+1900, tm-&gttm_mon+1, tm-&gttm_mday,\newline	tm-&gttm_hour, tm-&gttm_min, tm-&gttm_sec,\newline	msg1, msg2);\newline\newline\newline  return;\newline  }\newline",\newlinePrint a warning message on screen.\newline \newline,3519040,pdlua.c,"static int pdlua_post(lua_State *L)\newline/**&lt Lua interpreter state.\newline  * \\par Inputs:\newline  * \\li \\c 1 Message string.\newline  * */\newline{\newline    const char *str = luaL_checkstring(L, 1);\newline    PDLUA_DEBUG(&quotpdlua_post: stack top is %d&quot, lua_gettop(L));\newline    post(&quot%s&quot, str);\newline    PDLUA_DEBUG(&quotpdlua_post: end. stack top is %d&quot, lua_gettop(L));\newline    return 0;\newline}\newline",Post to Pd&#039s console. \newline,5245822,ow_parseobject.c,"GOOD_OR_BAD OWQ_create_plus(const char *path, const char *file, struct one_wire_query *owq)\newline{\newline	LEVEL_DEBUG(&quot%s + %s&quot, path, file);\newline\newline	OWQ_cleanup(owq) = owq_cleanup_none ;\newline	if ( GOOD( OWQ_parsename_plus(path,file,owq) ) ) {\newline		if ( GOOD( OWQ_allocate_array(owq)) ) {\newline			return gbGOOD ;\newline		}\newline		OWQ_destroy(owq);\newline	}\newline	return gbBAD ;\newline}\newline",Starts with a statically allocated owq space \newline,282192,map-file.c,"void MapFileSetIdRange ( MapFile *self, const ctx_t *ctx,\newline    int64_t first_id, uint64_t num_ids )\newline{\newline    rc_t rc;\newline    FUNC_ENTRY ( ctx );\newline\newline    if ( self == NULL )\newline    {\newline        rc = RC ( rcExe, rcFile, rcUpdating, rcSelf, rcNull );\newline        INTERNAL_ERROR ( rc, &quotbad self&quot );\newline    }\newline    else if ( self -&gt max_new_id != 0 )\newline    {\newline        rc = RC ( rcExe, rcFile, rcUpdating, rcConstraint, rcViolated );\newline        INTERNAL_ERROR ( rc, &quotcannot change id range after writing has begun&quot );\newline    }\newline    else\newline    {\newline        /* record new first id and count */\newline        self -&gt first_id = first_id;\newline        self -&gt num_ids = num_ids;\newline\newline        /* determine id size for all ids PLUS 0 for NULL */\newline        for ( ++ num_ids, self -&gt id_size = 1; self -&gt id_size &lt 8; ++ self -&gt id_size )\newline        {\newline            if ( num_ids &lt= ( ( uint64_t ) 1 ) &lt&lt ( self -&gt id_size * 8 ) )\newline                break;\newline        }\newline    }\newline}\newline",SsetIdRange\newline required second-stage initialization\newline must be called before any writes occur\newline \newline,1298024,lua.cpp,"static int intf_debug_ai(lua_State *L)\newline{\newline	if (!game_config::debug) { // This function works in debug mode only\newline		return 0;\newline	}\newline	int side = lua_tointeger(L, 1);\newline	lua_pop(L, 1);\newline\newline	ai::component* c = ai::manager::get_active_ai_holder_for_side_dbg(side).get_component(NULL, &quot&quot);\newline\newline	// Bad, but works\newline	std::vector&ltai::component*&gt engines = c-&gtget_children(&quotengine&quot);\newline	ai::engine_lua* lua_engine = NULL;\newline	for (std::vector&ltai::component*&gt::const_iterator i = engines.begin(); i != engines.end(); ++i)\newline	{\newline		if ((*i)-&gtget_name() == &quotlua&quot)\newline		{\newline			lua_engine = dynamic_cast&ltai::engine_lua *&gt(*i);\newline		}\newline	}\newline\newline	// Better way, but doesn&#039t work\newline	//ai::component* e = ai::manager::get_active_ai_holder_for_side_dbg(side).get_component(c, &quotengine[lua]&quot);\newline	//ai::engine_lua* lua_engine = dynamic_cast&ltai::engine_lua *&gt(e);\newline\newline	if (lua_engine == NULL)\newline	{\newline		//no lua engine is defined for this side.\newline		//so set up a dummy engine\newline\newline		ai::ai_composite * ai_ptr = dynamic_cast&ltai::ai_composite *&gt(c);\newline		ai::ai_context&amp ai_context = ai_ptr-&gtget_ai_context();\newline		config cfg = ai::configuration::get_default_ai_parameters();\newline\newline		lua_engine = new ai::engine_lua(ai_context, cfg);\newline		LOG_LUA &lt&lt &quotCreated new dummy lua-engine for debug_ai(). \\n&quot;\newline\newline		//and add the dummy engine as a component\newline		//to the manager, so we could use it later\newline		cfg.add_child(&quotengine&quot, lua_engine-&gtto_config());\newline		ai::component_manager::add_component(c, &quotengine[]&quot, cfg);\newline	}\newline\newline	lua_engine-&gtpush_ai_table(); // stack: [-1: ai_context]\newline\newline	lua_pushstring(L, &quotcomponents&quot);\newline	push_component(L, c); // stack: [-1: component tree; -2: ai context]\newline	lua_rawset(L, -3);\newline\newline	return 1;\newline}\newline",\newline Debug access to the ai tables\newline - Arg 1: int\newline - Ret 1: ai table\newline \newline,5792241,spicestream.c,"char *ss_var_name(SpiceVar *sv, int col, char *buf, int n)\newline{\newline	int idx;\newline\newline	if(buf == NULL) {\newline		int l;\newline		l = strlen(sv-&gtname + 3);\newline		buf = g_new(char, l);\newline		n = l;\newline	}\newline	strncpy(buf, sv-&gtname, n-1);\newline	n -= strlen(buf)+1;\newline	if(sv-&gtncols == 1 || col &lt 0)\newline		return buf;\newline	if(n&gt1) {\newline		idx = strlen(buf);\newline		buf[idx++] = &#039.&#039;\newline		buf[idx++] = &#0390&#039+col;\newline		buf[idx] = 0;\newline	}\newline	\newline	return(buf);\newline}\newline","\newline return pointer to string with printable name for a variable\newline or one of the columns of a variable.\newline buf is a pointer to a buffer to use. If NULL, one will be allocated.\newline n is the maximum number of characters to put in the buffer.\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,146707,open_trace_file.c,"static mFILE *find_file_srf(char *tname, char *srffile) {\newline    srf_t *srf;\newline    uint64_t cpos, hpos, dpos;\newline    mFILE *mf = NULL;\newline    char *cp;\newline\newline    if (NULL == (srf = srf_open(srffile, &quotr&quot)))\newline	return NULL;\newline\newline    if (NULL != (cp = strrchr(tname, &#039/&#039)))\newline    	tname = cp+1;\newline\newline    if (0 == srf_find_trace(srf, tname, &ampcpos, &amphpos, &ampdpos)) {\newline	char *data = malloc(srf-&gtth.trace_hdr_size + srf-&gttb.trace_size);\newline	if (!data) {\newline	    srf_destroy(srf, 1);\newline	    return NULL;\newline	}\newline	memcpy(data, srf-&gtth.trace_hdr, srf-&gtth.trace_hdr_size);\newline	memcpy(data + srf-&gtth.trace_hdr_size,\newline	       srf-&gttb.trace, srf-&gttb.trace_size);\newline	mf = mfcreate(data, srf-&gtth.trace_hdr_size + srf-&gttb.trace_size);\newline    }\newline\newline    srf_destroy(srf, 1);\newline    return mf;\newline}\newline",\newline Extracts a single trace from an SRF file.\newline \newline Return mFILE pointer if found\newline NULL if not\newline \newline,6011249,mipmap.c,"static void closestFit(GLenum target, GLint width, GLint height,\newline		       GLint internalFormat, GLenum format, GLenum type,\newline		       GLint *newWidth, GLint *newHeight)\newline{\newline   /* Use proxy textures if OpenGL version is &gt= 1.1 */\newline   if ( (strtod((const char *)glGetString(GL_VERSION),NULL) &gt= 1.1)\newline	) {\newline      GLint widthPowerOf2= nearestPower(width);\newline      GLint heightPowerOf2= nearestPower(height);       \newline      GLint proxyWidth;\newline\newline      do {\newline	 /* compute level 1 width &amp height, clamping each at 1 */\newline	 GLint widthAtLevelOne= (widthPowerOf2 &gt 1) ?\newline				 widthPowerOf2 &gt&gt 1 :\newline				 widthPowerOf2;\newline	 GLint heightAtLevelOne= (heightPowerOf2 &gt 1) ?\newline				  heightPowerOf2 &gt&gt 1 :\newline				  heightPowerOf2;\newline	 GLenum proxyTarget;\newline	 assert(widthAtLevelOne &gt 0); assert(heightAtLevelOne &gt 0);\newline\newline	 /* does width x height at level 1 &amp all their mipmaps fit? */\newline	 if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {\newline	    proxyTarget = GL_PROXY_TEXTURE_2D;\newline	    glTexImage2D(proxyTarget, 1, /* must be non-zero */\newline			 internalFormat,\newline			 widthAtLevelOne,heightAtLevelOne,0,format,type,NULL);\newline	 } else\newline#if defined(GL_ARB_texture_cube_map)\newline	 if ((target == GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB) ||\newline	     (target == GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB) ||\newline	     (target == GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB) ||\newline	     (target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB) ||\newline	     (target == GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB) ||\newline	     (target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {\newline	     proxyTarget = GL_PROXY_TEXTURE_CUBE_MAP_ARB;\newline	     glTexImage2D(proxyTarget, 1, /* must be non-zero */\newline			  internalFormat,\newline			  widthAtLevelOne,heightAtLevelOne,0,format,type,NULL);\newline	 } else\newline#endif /* GL_ARB_texture_cube_map */\newline	 {\newline	    assert(target == GL_TEXTURE_1D || target == GL_PROXY_TEXTURE_1D);\newline	    proxyTarget = GL_PROXY_TEXTURE_1D;\newline	    glTexImage1D(proxyTarget, 1, /* must be non-zero */\newline			 internalFormat,widthAtLevelOne,0,format,type,NULL);\newline	 }\newline	 glGetTexLevelParameteriv(proxyTarget, 1,GL_TEXTURE_WIDTH,&ampproxyWidth);\newline	 /* does it fit??? */\newline	 if (proxyWidth == 0) { /* nope, so try again with these sizes */\newline	    if (widthPowerOf2 == 1 &amp&amp heightPowerOf2 == 1) {\newline	       /* An 1x1 texture couldn&#039t fit for some reason, so\newline		* break out.  This should never happen. But things\newline		* happen.  The disadvantage with this if-statement is\newline		* that we will never be aware of when this happens\newline		* since it will silently branch out.\newline		*/\newline	       goto noProxyTextures;\newline	    }\newline	    widthPowerOf2= widthAtLevelOne;\newline	    heightPowerOf2= heightAtLevelOne;\newline	 }\newline	 /* else it does fit */\newline      } while (proxyWidth == 0);\newline      /* loop must terminate! */\newline\newline      /* return the width &amp height at level 0 that fits */\newline      *newWidth= widthPowerOf2;\newline      *newHeight= heightPowerOf2;\newline/*printf(&quotProxy Textures\\n&quot);*/\newline   } /* if gluCheckExtension() */\newline   else {			/* no texture extension, so do this instead */\newline      GLint maxsize;\newline\newlinenoProxyTextures:\newline\newline      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &ampmaxsize);\newline      /* clamp user&#039s texture sizes to maximum sizes, if necessary */\newline      *newWidth = nearestPower(width);\newline      if (*newWidth &gt maxsize) *newWidth = maxsize;\newline      *newHeight = nearestPower(height);\newline      if (*newHeight &gt maxsize) *newHeight = maxsize;\newline/*printf(&quotNO proxy textures\\n&quot);*/\newline   }\newline} /* closestFit() */\newline","Given user requested texture size, determine if it fits. If it\newline doesn&#039t then halve both sides and make the determination again\newline until it does fit (for IR only).\newline Note that proxy textures are not implemented in RE even though\newline they advertise the texture extension.\newline Note that proxy textures are implemented but not according to spec in\newline IMPACT .\newline \newline",6448848,qwt_plot_tradingcurve.cpp,"void QwtPlotTradingCurve::setSymbolBrush(\newline    Direction direction, const QBrush &ampbrush )\newline{\newline    if ( static_cast&ltint&gt(direction) &lt 0 || static_cast&ltint&gt(direction) &gt= 2 )\newline        return;\newline\newline    if ( brush != d_data-&gtsymbolBrush[ direction ] )\newline    {\newline        d_data-&gtsymbolBrush[ direction ] = brush;\newline\newline        legendChanged();\newline        itemChanged();\newline    }\newline}\newline","!\newlineSet the symbol brush\newline\\param direction Direction type\newline\\param brush Brush used to fill the body of all candlestick\newlinesymbols with the direction\newline\\sa symbolBrush(), setSymbolPen()\newline \newline",4825541,mod_log_sql.c,"static int log_sql_transaction(request_rec *orig)\newline{\newline	char **ptrptr, **ptrptr2;\newline	logsql_state *cls = ap_get_module_config(orig-&gtserver-&gtmodule_config, &amplog_sql_module);\newline	const char *access_query;\newline	request_rec *r;\newline	const char *transfer_tablename = cls-&gttransfer_table_name;\newline	const char *notes_tablename = cls-&gtnotes_table_name;\newline	const char *hout_tablename = cls-&gthout_table_name;\newline	const char *hin_tablename = cls-&gthin_table_name;\newline	const char *cookie_tablename = cls-&gtcookie_table_name;\newline	const char *scoreboard_domain = cls-&gtscoreboard_domain;\newline	const char *scoreboard_subdomain = cls-&gtscoreboard_subdomain;\newline	const char *scoreboard_table_name = cls-&gtscoreboard_table_name;\newline	struct timeval now_time;\newline\newline	/* We handle mass virtual hosting differently.  Dynamically determine the name\newline	 * of the table from the virtual server&#039s name, and flag it for creation.\newline	 */\newline	if (global_config.massvirtual) {\newline		/* TODO: Make these configurable? */\newline		char *access_base = &quotaccess_&quot;\newline		char *notes_base  = &quotnotes_&quot;\newline		char *hout_base   = &quotheadout_&quot;\newline		char *hin_base    = &quotheadin_&quot;\newline		char *cookie_base = &quotcookies_&quot;\newline\newline\newline		/* Determine the hostname and convert it to all lower-case; */\newline		char *servername = apr_pstrdup(orig-&gtpool,(char *)ap_get_server_name(orig));\newline\newline		char *p=servername;\newline		while (*p) {\newline			*p = apr_tolower(*p);\newline			if (*p == &#039.&#039) *p = &#039_&#039;\newline			if (*p == &#039-&#039) *p = &#039_&#039;\newline			++p;\newline		}\newline		\newline		/* Find memory long enough to hold the table name + \\0. */\newline		transfer_tablename = apr_pstrcat(orig-&gtpool, access_base, servername, NULL);\newline		notes_tablename = apr_pstrcat(orig-&gtpool, notes_base,  servername, NULL);\newline		hin_tablename = apr_pstrcat(orig-&gtpool, hin_base,    servername, NULL);\newline		hout_tablename = apr_pstrcat(orig-&gtpool, hout_base,   servername, NULL);\newline		cookie_tablename = apr_pstrcat(orig-&gtpool, cookie_base, servername, NULL);\newline\newline		/* Tell this virtual server its transfer table name, and\newline		 * turn on create_tables, which is implied by massvirtual.\newline		 */\newline		\newline		global_config.createtables = 1;\newline	}\newline\newline	/* Do we have enough info to log? */\newline	if (!transfer_tablename) {\newline		return DECLINED;\newline	} else {\newline		const char *thehost;\newline		const char *theitem;\newline		char *fields = &quot&quot, *values = &quot&quot;\newline		char *itemsets = &quot&quot;\newline		char *note_query = NULL;\newline		char *hin_query = NULL;\newline		char *hout_query = NULL;\newline		char *cookie_query = NULL;\newline		const char *unique_id;\newline		const char *formatted_item;\newline		int i,length;\newline		int proceed;\newline\newline		for (r = orig; r-&gtnext; r = r-&gtnext) {\newline			continue;\newline		}\newline\newline		/* The following is a stolen upsetting mess of pointers, I&#039m sorry.\newline		 * Anyone with the motiviation and/or the time should feel free\newline		 * to make this cleaner. :) */\newline		ptrptr2 = (char **) (cls-&gttransfer_accept_list-&gtelts + (cls-&gttransfer_accept_list-&gtnelts * cls-&gttransfer_accept_list-&gtelt_size));\newline\newline		/* Go through each element of the accept list and compare it to the\newline		 * request_uri.  If we don&#039t get a match, return without logging */\newline		if ((r-&gturi) &amp&amp (cls-&gttransfer_accept_list-&gtnelts)) {\newline			proceed = 0;\newline			for (ptrptr = (char **) cls-&gttransfer_accept_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gttransfer_accept_list-&gtelt_size))\newline				if (ap_strstr(r-&gturi, *ptrptr)) {\newline					proceed = 1;\newline					break;\newline				}\newline			if (!proceed)\newline				return OK;\newline		}\newline\newline		/* Go through each element of the ignore list and compare it to the\newline		 * request_uri.  If we get a match, return without logging */\newline		ptrptr2 = (char **) (cls-&gttransfer_ignore_list-&gtelts + (cls-&gttransfer_ignore_list-&gtnelts * cls-&gttransfer_ignore_list-&gtelt_size));\newline		if (r-&gturi) {\newline			for (ptrptr = (char **) cls-&gttransfer_ignore_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gttransfer_ignore_list-&gtelt_size))\newline				if (ap_strstr(r-&gturi, *ptrptr)) {\newline					return OK;\newline				}\newline		}\newline\newline		/* Go through each element of the ignore list and compare it to the\newline		 * remote host.  If we get a match, return without logging */\newline		ptrptr2 = (char **) (cls-&gtremhost_ignore_list-&gtelts + (cls-&gtremhost_ignore_list-&gtnelts * cls-&gtremhost_ignore_list-&gtelt_size));\newline		thehost = ap_get_remote_host(r-&gtconnection, r-&gtper_dir_config, REMOTE_NAME, NULL);\newline		if (thehost) {\newline			for (ptrptr = (char **) cls-&gtremhost_ignore_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gtremhost_ignore_list-&gtelt_size))\newline				if (ap_strstr(thehost, *ptrptr)) {\newline					return OK;\newline				}\newline		}\newline\newline\newline		/* Iterate through the format characters and set up the INSERT string according to\newline		 * what the user has configured. */\newline		length = strlen(cls-&gttransfer_log_format);\newline		for (i = 0; i&ltlength; i++) {\newline			logsql_item *item = cls-&gtparsed_log_format[i];\newline			if (item==NULL) {\newline				log_error(APLOG_MARK, APLOG_ERR, 0, orig-&gtserver,\newline					&quotLog Format &#039%c&#039 unknown&quot,cls-&gttransfer_log_format[i]);\newline				continue;\newline			}\newline\newline			/* Yes, this key is one of the configured keys.\newline			 * Call the key&#039s function and put the returned value into &#039formatted_item&#039 */\newline			formatted_item = item-&gtfunc(item-&gtwant_orig_default ? orig : r, &quot&quot);\newline\newline			/* Massage &#039formatted_item&#039 for proper SQL eligibility... */\newline			if (!formatted_item) {\newline				formatted_item = &quot&quot;\newline			} else if (formatted_item[0] == &#039-&#039 &amp&amp formatted_item[1] == &#039\\0&#039 &amp&amp !item-&gtstring_contents) {\newline				/* If apache tried to log a &#039-&#039 character for a numeric field, convert that to a zero\newline				 * because the database expects a numeral and will reject the &#039-&#039 character. */\newline				formatted_item = &quot0&quot;\newline			}\newline\newline		     /* Append the fieldname and value-to-insert to the appropriate strings, quoting stringvals with &#039 as appropriate */\newline			fields = apr_pstrcat(r-&gtpool, fields, (i ? &quot,&quot : &quot&quot),\newline						 item-&gtsql_field_name, NULL);\newline			values = apr_pstrcat(r-&gtpool, values, (i ? &quot,&quot : &quot&quot),\newline					     global_config.driver-&gtescape(formatted_item, r-&gtpool,&ampglobal_config.db), NULL);\newline		}\newline\newline		/* Work through the list of notes defined by LogSQLWhichNotes */\newline		i = 0;\newline		unique_id = extract_unique_id(r, &quot&quot);\newline\newline		ptrptr2 = (char **) (cls-&gtnotes_list-&gtelts + (cls-&gtnotes_list-&gtnelts * cls-&gtnotes_list-&gtelt_size));\newline		for (ptrptr = (char **) cls-&gtnotes_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gtnotes_list-&gtelt_size)) {\newline			/* If the specified note (*ptrptr) exists for the current request... */\newline		    if ((theitem = apr_table_get(r-&gtnotes, *ptrptr))) {\newline				itemsets = apr_pstrcat(r-&gtpool, itemsets,\newline									  (i &gt 0 ? &quot,&quot : &quot&quot),\newline									  &quot(&quot,\newline									  global_config.driver-&gtescape(unique_id, r-&gtpool, &ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(*ptrptr, r-&gtpool,&ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(theitem, r-&gtpool,&ampglobal_config.db),\newline									  &quot)&quot,\newline									  NULL);\newline				i++;\newline			}\newline		}\newline		if ( itemsets != &quot&quot ) {\newline			note_query = apr_psprintf(r-&gtpool, &quotinsert %s into %s (id, item, val) values %s&quot,\newline				/*global_config.insertdelayed?&quotdelayed&quot:*/&quot&quot, notes_tablename, itemsets);\newline\newline			log_error(APLOG_MARK,APLOG_DEBUG,0, orig-&gtserver,&quotmod_log_sql: note string: %s&quot, note_query);\newline		}\newline\newline		/* Work through the list of headers-out defined by LogSQLWhichHeadersOut*/\newline		i = 0;\newline		itemsets = &quot&quot;\newline\newline		ptrptr2 = (char **) (cls-&gthout_list-&gtelts + (cls-&gthout_list-&gtnelts * cls-&gthout_list-&gtelt_size));\newline		for (ptrptr = (char **) cls-&gthout_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gthout_list-&gtelt_size)) {\newline			/* If the specified header (*ptrptr) exists for the current request... */\newline		    if ((theitem = apr_table_get(r-&gtheaders_out, *ptrptr))) {\newline				itemsets = apr_pstrcat(r-&gtpool, itemsets,\newline									  (i &gt 0 ? &quot,&quot : &quot&quot),\newline									  &quot(&quot,\newline									  global_config.driver-&gtescape(unique_id, r-&gtpool, &ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(*ptrptr, r-&gtpool,&ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(theitem, r-&gtpool,&ampglobal_config.db),\newline									  &quot)&quot,\newline									  NULL);\newline				i++;\newline			}\newline		}\newline		if ( itemsets != &quot&quot ) {\newline			hout_query = apr_psprintf(r-&gtpool, &quotinsert %s into %s (id, item, val) values %s&quot,\newline				/*global_config.insertdelayed?&quotdelayed&quot:*/&quot&quot, hout_tablename, itemsets);\newline\newline			log_error(APLOG_MARK,APLOG_DEBUG,0, orig-&gtserver,&quotmod_log_sql: header_out string: %s&quot, hout_query);\newline		}\newline\newline\newline		/* Work through the list of headers-in defined by LogSQLWhichHeadersIn */\newline		i = 0;\newline		itemsets = &quot&quot;\newline\newline		ptrptr2 = (char **) (cls-&gthin_list-&gtelts + (cls-&gthin_list-&gtnelts * cls-&gthin_list-&gtelt_size));\newline		for (ptrptr = (char **) cls-&gthin_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gthin_list-&gtelt_size)) {\newline			/* If the specified header (*ptrptr) exists for the current request... */\newline		    if ((theitem = apr_table_get(r-&gtheaders_in, *ptrptr))) {\newline				itemsets = apr_pstrcat(r-&gtpool, itemsets,\newline									  (i &gt 0 ? &quot,&quot : &quot&quot),\newline									  &quot(&quot,\newline									  global_config.driver-&gtescape(unique_id, r-&gtpool, &ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(*ptrptr, r-&gtpool,&ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(theitem, r-&gtpool,&ampglobal_config.db),\newline									  &quot)&quot,\newline									  NULL);\newline				i++;\newline			}\newline		}\newline		if ( itemsets != &quot&quot ) {\newline			hin_query = apr_psprintf(r-&gtpool, &quotinsert %s into %s (id, item, val) values %s&quot,\newline				/*global_config.insertdelayed?&quotdelayed&quot:*/&quot&quot, hin_tablename, itemsets);\newline\newline			log_error(APLOG_MARK,APLOG_DEBUG,0, orig-&gtserver,&quotmod_log_sql: header_in string: %s&quot, hin_query);\newline		}\newline\newline\newline		/* Work through the list of cookies defined by LogSQLWhichCookies */\newline		i = 0;\newline		itemsets = &quot&quot;\newline\newline		ptrptr2 = (char **) (cls-&gtcookie_list-&gtelts + (cls-&gtcookie_list-&gtnelts * cls-&gtcookie_list-&gtelt_size));\newline		for (ptrptr = (char **) cls-&gtcookie_list-&gtelts; ptrptr &lt ptrptr2; ptrptr = (char **) ((char *) ptrptr + cls-&gtcookie_list-&gtelt_size)) {\newline			/* If the specified cookie (*ptrptr) exists for the current request... */\newline		    if ( strncmp((theitem = extract_specific_cookie(r, *ptrptr)), &quot-&quot, 1) ) {\newline				itemsets = apr_pstrcat(r-&gtpool, itemsets,\newline									  (i &gt 0 ? &quot,&quot : &quot&quot),\newline									  &quot(&quot,\newline									  global_config.driver-&gtescape(unique_id, r-&gtpool, &ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(*ptrptr, r-&gtpool,&ampglobal_config.db),\newline									  &quot,&quot,\newline									  global_config.driver-&gtescape(theitem, r-&gtpool,&ampglobal_config.db),\newline									  &quot)&quot,\newline									  NULL);\newline				i++;\newline			}\newline\newline		}\newline		if ( itemsets != &quot&quot ) {\newline			cookie_query = apr_psprintf(r-&gtpool, &quotinsert %s into %s (id, item, val) values %s&quot,\newline				/*global_config.insertdelayed?&quotdelayed&quot:*/&quot&quot, cookie_tablename, itemsets);\newline\newline			log_error(APLOG_MARK,APLOG_DEBUG,0, orig-&gtserver,&quotmod_log_sql: cookie string: %s&quot, cookie_query);\newline		}\newline\newline\newline		/* Set up the actual INSERT statement */\newline		access_query = apr_psprintf(r-&gtpool, &quotinsert %s into %s (%s) values (%s)&quot,\newline			/*global_config.insertdelayed?&quotdelayed&quot:*/&quot&quot, transfer_tablename, fields, values);\newline\newline        log_error(APLOG_MARK,APLOG_DEBUG,0, r-&gtserver,&quotmod_log_sql: access string: %s&quot, access_query);\newline\newline		/* If the person activated force-preserve, go ahead and push all the entries\newline		 * into the preserve file, then return.\newline		 */\newline		if (global_config.forcepreserve) {\newline			log_error(APLOG_MARK,APLOG_DEBUG,0, orig-&gtserver,&quotmod_log_sql: preservation forced&quot);\newline			preserve_entry(orig, access_query);\newline			if ( note_query != NULL )\newline				preserve_entry(orig, note_query);\newline			if ( hin_query != NULL )\newline			  	preserve_entry(orig, hin_query);\newline			if ( hout_query != NULL )\newline			  	preserve_entry(orig, hout_query);\newline			if ( cookie_query != NULL )\newline			  	preserve_entry(orig, cookie_query);\newline			return OK;\newline		}\newline\newline		/* How&#039s our mysql link integrity? */\newline		if (!global_config.db.connected) {\newline            if (!global_config.forcepreserve) {\newline			    /* Make a try to establish the link */\newline			    log_sql_opendb_link(r-&gtserver);\newline            }\newline			if (!global_config.db.connected) {\newline				/* Unable to re-establish a DB link, so assume that it&#039s really\newline				 * gone and send the entry to the preserve file instead.\newline				 * This short-circuits safe_sql_query() during a db outage and therefore\newline				 * we don&#039t keep logging the db error over and over.\newline				 */\newline				preserve_entry(orig, access_query);\newline				if ( note_query != NULL )\newline					preserve_entry(orig, note_query);\newline				if ( hin_query != NULL )\newline				  	preserve_entry(orig, hin_query);\newline				if ( hout_query != NULL )\newline				  	preserve_entry(orig, hout_query);\newline				if ( cookie_query != NULL )\newline				  	preserve_entry(orig, cookie_query);\newline\newline				return OK;\newline			} else {\newline				/* Whew, we got the DB link back */\newline				log_error(APLOG_MARK,APLOG_NOTICE,0, orig-&gtserver,&quotmod_log_sql: child established database connection&quot);\newline			}\newline		}\newline\newline\newline		/* ---&gt So as of here we have a non-null value of mysql_log. &lt--- */\newline		/* ---&gt i.e. we have a good MySQL connection.                &lt--- */\newline\newline  	    /* Make the access-table insert */\newline		safe_sql_insert(orig,LOGSQL_TABLE_ACCESS,transfer_tablename,access_query);\newline\newline		/* Log the optional notes, headers, etc. */\newline		if (note_query)\newline			safe_sql_insert(orig, LOGSQL_TABLE_NOTES,notes_tablename,note_query);\newline\newline		if (hout_query)\newline		  	safe_sql_insert(orig, LOGSQL_TABLE_HEADERSOUT,hout_tablename,hout_query);\newline\newline		if (hin_query)\newline		  	safe_sql_insert(orig, LOGSQL_TABLE_HEADERSIN,hin_tablename,hin_query);\newline\newline		if (cookie_query)\newline		  	safe_sql_insert(orig, LOGSQL_TABLE_COOKIES,cookie_tablename,cookie_query);\newline\newline		gettimeofday(&ampnow_time, (struct timeval*)0);\newline\newline		{\newline			const char *score_query_insert;\newline			const char *score_query_update;\newline			const char *score_query_insert_ignore;\newline			struct tm *ptr;\newline			time_t tm;\newline			char sql_month[60];\newline			char sql_year[60];\newline			char a[60];\newline			char* bytes_sent;\newline \newline			tm = time(NULL);\newline			ptr = localtime(&amptm);\newline			strftime(sql_month ,100 , &quot\\%m&quot,ptr);\newline			strftime(sql_year ,100 , &quot\\%Y&quot,ptr);\newline\newline			score_query_insert = apr_psprintf(r-&gtpool, &quot %s (domain,vhost,month,year,count_impressions) values (&#039%s&#039,&#039%s&#039,&#039%s&#039,&#039%s&#039,&#0390&#039)&quot\newline				,scoreboard_table_name,scoreboard_domain,scoreboard_subdomain,sql_month,sql_year);\newline			// Add insert ignore into ... ;\newline			// or begin; insert into ... ; commit;\newline			// depending on the drive used\newline			score_query_insert_ignore = log_sql_insert_enclose(score_query_insert,r);\newline\newline			safe_sql_insert(orig,LOGSQL_TABLE_SCORE,&quotscore_board&quot,score_query_insert_ignore);\newline			bytes_sent = extract_bytes_sent(r, a);\newline			if (bytes_sent[0] != &#039-&#039){\newline				score_query_update = apr_psprintf(r-&gtpool, &quotupdate %s SET count_impressions = count_impressions+1, bytes_sent = bytes_sent+%s WHERE domain=&#039%s&#039 AND vhost=&#039%s&#039 AND month=&#039%s&#039 AND year=&#039%s&#039&quot\newline					,scoreboard_table_name,extract_bytes_sent(r, a),scoreboard_domain,scoreboard_subdomain,sql_month,sql_year);\newline				safe_sql_insert(orig,LOGSQL_TABLE_SCORE,&quotscore_board&quot,score_query_update);\newline			}\newline		}\newline		return OK;\newline	}\newline}\newline",Routine to perform the actual construction and execution of the relevant\newline INSERT statements.\newline \newline,2508990,listing.c,"void follow_all(void)\newline{\newline    list_t *tmp;\newline\newline    /*\newline     * Follow all scripts and calculate the main ordering.\newline     */\newline    list_for_each(tmp, d_start) {\newline	maxorder = &ampmaxstart;\newline	follow(getdir(tmp), &#039S&#039, 1);\newline	maxorder = &ampmaxstop;\newline	follow(getdir(tmp), &#039K&#039, 1);\newline    }\newline\newline    /*\newline     * Guess order of not installed scripts in comparision\newline     * to the well known scripts.\newline     */\newline    list_for_each(tmp, d_start) {\newline	maxorder = &ampmaxstart;\newline	guess_order(getdir(tmp), &#039S&#039);\newline	maxorder = &ampmaxstop;\newline	guess_order(getdir(tmp), &#039K&#039);\newline    }\newline}\newline",\newline Follow all services and their dependencies recursivly.\newline \newline,3092460,dis.c,"static int decode_single(const uint8_t *code, address_t offset,\newline			 address_t size, struct msp430_instruction *insn)\newline{\newline	uint16_t op = (code[1] &lt&lt 8) | code[0];\newline	int need_arg = 0;\newline\newline	insn-&gtitype = MSP430_ITYPE_SINGLE;\newline	insn-&gtop = op &amp 0xff80;\newline	insn-&gtdsize = (op &amp 0x0400) ? MSP430_DSIZE_BYTE : MSP430_DSIZE_WORD;\newline\newline	insn-&gtdst_mode = (op &gt&gt 4) &amp 0x3;\newline	insn-&gtdst_reg = op &amp 0xf;\newline\newline	switch (insn-&gtdst_mode) {\newline	case MSP430_AMODE_REGISTER: break;\newline\newline	case MSP430_AMODE_INDEXED:\newline		need_arg = 1;\newline		if (insn-&gtdst_reg == MSP430_REG_PC) {\newline			insn-&gtdst_addr = offset + 4;\newline			insn-&gtdst_mode = MSP430_AMODE_SYMBOLIC;\newline		} else if (insn-&gtdst_reg == MSP430_REG_SR) {\newline			insn-&gtdst_mode = MSP430_AMODE_ABSOLUTE;\newline		} else if (insn-&gtdst_reg == MSP430_REG_R3) {\newline			need_arg = 0; /* constant generator: #1 */\newline		}\newline		break;\newline\newline	case MSP430_AMODE_INDIRECT: break;\newline\newline	case MSP430_AMODE_INDIRECT_INC:\newline		if (insn-&gtdst_reg == MSP430_REG_PC) {\newline			insn-&gtdst_mode = MSP430_AMODE_IMMEDIATE;\newline			need_arg = 1;\newline		}\newline		break;\newline\newline	default: break;\newline	}\newline\newline	if (need_arg) {\newline		if (size &lt 4)\newline			return -1;\newline\newline		insn-&gtdst_addr = add_index(insn-&gtdst_addr,\newline			(code[3] &lt&lt 8) | code[2]);\newline		return 4;\newline	}\newline\newline	return 2;\newline}\newline","Decode a single-operand instruction.\newline \newline Returns the number of bytes consumed in decoding, or -1 if the a\newline valid single-operand instruction could not be found.\newline \newline",3003824,isa_l_common.c,"static unsigned char* get_inverse_rows(int k,\newline                                       int m,\newline                                       unsigned char *decode_inverse,\newline                                       unsigned char* encode_matrix,\newline                                       int *missing_idxs,\newline                                       gf_mul_func gf_mul)\newline{\newline    uint64_t missing_bm = convert_list_to_bitmap(missing_idxs);\newline    int num_missing_elements = get_num_missing_elements(missing_idxs);\newline    unsigned char *inverse_rows = (unsigned char*)malloc(sizeof(unsigned\newline                                    char*) * k * num_missing_elements);\newline    int i, j, l = 0;\newline    int n = k + m;\newline\newline    if (NULL == inverse_rows) {\newline        return NULL;\newline    }\newline\newline    memset(inverse_rows, 0, sizeof(unsigned\newline                                    char*) * k * num_missing_elements);\newline\newline    /*\newline     * Fill in rows for missing data\newline     */\newline    for (i = 0; i &lt k; i++) {\newline        if ((1 &lt&lt i) &amp missing_bm) {\newline            for (j = 0; j &lt k; j++) {\newline                inverse_rows[(l * k) + j] = decode_inverse[(i * k) + j];\newline            }\newline            l++;\newline        }\newline    }\newline\newline    /*\newline     * Process missing parity.\newline     *\newline     * Start with an all-zero row.\newline     *\newline     * For each data element, if the data element is:\newline     *\newline     * Available: XOR the corresponding coefficient from the\newline     * encoding matrix.\newline     *\newline     * Unavailable: multiply corresponding coefficient with\newline     * the row that corresponds to the missing data in inverse_rows\newline     * and XOR the resulting row with this row.\newline     */\newline    for (i = k; i &lt n; i++) {\newline        // Parity is missing\newline        if ((1 &lt&lt i) &amp missing_bm) {\newline            int d_idx_avail = 0;\newline            int d_idx_unavail = 0;\newline            for (j = 0; j &lt k; j++) {\newline                // This data is available, so we can use the encode matrix\newline                if (((1 &lt&lt j) &amp missing_bm) == 0) {\newline                    inverse_rows[(l * k) + d_idx_avail] ^= encode_matrix[(i * k) + j];\newline                    d_idx_avail++;\newline                } else {\newline                    mult_and_xor_row(&ampinverse_rows[l * k],\newline                                     &ampinverse_rows[d_idx_unavail * k],\newline                                     encode_matrix[(i * k) + j],\newline                                     k,\newline                                     gf_mul);\newline                    d_idx_unavail++;\newline                }\newline            }\newline            l++;\newline        }\newline    }\newline    return inverse_rows;\newline}\newline",\newline TODO: Add in missing parity rows and adjust the inverse_rows to\newline be used for parity.\newline \newline,5923576,cluster_library.c,"unsigned short cluster_hash_key_zval(zval *z_key) {\newline    const char *kptr;\newline    char buf[255];\newline    int klen;\newline\newline    // Switch based on ZVAL type\newline    switch(Z_TYPE_P(z_key)) {\newline        case IS_STRING:\newline            kptr = Z_STRVAL_P(z_key);\newline            klen = Z_STRLEN_P(z_key);\newline            break;\newline        case IS_LONG:\newline            klen = snprintf(buf,sizeof(buf),&quot%ld&quot,Z_LVAL_P(z_key));\newline            kptr = (const char *)buf;\newline            break;\newline        case IS_DOUBLE:\newline            klen = snprintf(buf,sizeof(buf),&quot%f&quot,Z_DVAL_P(z_key));\newline            kptr = (const char *)buf;\newline            break;\newline        case IS_ARRAY:\newline            kptr = &quotArray&quot;\newline            klen = sizeof(&quotArray&quot)-1;\newline            break;\newline        case IS_OBJECT:\newline            kptr = &quotObject&quot;\newline            klen = sizeof(&quotObject&quot)-1;\newline            break;\newline        default:\newline            kptr = &quot&quot;\newline            klen = 0;\newline    }\newline\newline    // Hash the string representation\newline    return cluster_hash_key(kptr, klen);\newline}\newline",Hash a key from a ZVAL \newline,4281089,tinflate.c,"static int tinf_inflate_uncompressed_block(TINF_DATA *d)\newline{\newline   unsigned int length, invlength;\newline   unsigned int i;\newline\newline   if((d-&gtsourceLen + 4) &gt d-&gtsourceSize) return TINF_DATA_ERROR;\newline   /* get length */\newline   length = d-&gtsource[1];\newline   length = (length &lt&lt 8) + d-&gtsource[0];\newline\newline   /* get one&#039s complement of length */\newline   invlength = d-&gtsource[3];\newline   invlength = (invlength &lt&lt 8) + d-&gtsource[2];\newline\newline   /* check length */\newline   if (length != (~invlength &amp 0x0000ffff)) return TINF_DATA_ERROR;\newline\newline   d-&gtsource += 4;\newline   d-&gtsourceLen += 4;\newline\newline   /* copy block */\newline   if ((d-&gtsourceLen + length) &gt d-&gtsourceSize) return TINF_DATA_ERROR;\newline   if ((*d-&gtdestLen + length) &gt d-&gtdestSize) return TINF_DATA_ERROR;\newline   for (i = length; i; --i) *d-&gtdest++ = *d-&gtsource++;\newline\newline   /* make sure we start next block on a byte boundary */\newline   d-&gtbitcount = 0;\newline\newline   d-&gtsourceLen += length;\newline   *d-&gtdestLen += length;\newline\newline   return TINF_OK;\newline}\newline",inflate an uncompressed block of data \newline,2166326,assoc.c,"void tdu_assoc_set_idle(struct tdu_fsm * fsm)\newline{\newline	tdu_printf(TDU_LOG_TRC, &quottdu_assoc_set_idle()\\n&quot);\newline\newline	fsm -&gt regime_handler = &amp fsm-&gtassoc.handler;\newline	tdu_del_timer(fsm);\newline	fsm-&gtwait=0;\newline}\newline",\newline Set idle state of association regime\newline \newline,2144343,jose.c,"apr_byte_t oidc_jose_hash_string(apr_pool_t *pool, const char *alg,\newline		const char *msg, char **hash, unsigned int *hash_len,\newline		oidc_jose_error_t *err) {\newline\newline	char *s_digest = oidc_jose_alg_to_openssl_digest(alg);\newline	if (s_digest == NULL) {\newline		oidc_jose_error(err,\newline				&quotno OpenSSL digest algorithm name found for algorithm \\&quot%s\\&quot&quot,\newline				alg);\newline		return FALSE;\newline	}\newline\newline	return oidc_jose_hash_bytes(pool, s_digest, (const unsigned char *) msg,\newline			strlen(msg), (unsigned char **) hash, hash_len, err);\newline}\newline",\newline hash a string value with the specified algorithm\newline \newline,on,,,on,,,,,on,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,{},Load an image from the named file.,Extracts a single trace from an SRF file.,{},Set the symbol brush,Routine to perform the actual construction and execution of the relevant,Follow all services and their dependencies recursivly.,"Returns the number of bytes consumed in decoding,",{},Hash a key from a ZVAL,inflate an uncompressed block of data,Convert string from input_charset to output_charset.,Set idle state of association regime,hash a string value with the specified algorithm,help function to get the playernumber from the address.,Print a warning message on screen.,Post to Pd's console.,Starts with a statically allocated owq space,must be called before any writes occur,Debug access to the ai tables,{},x,
30F94FBDNRK9PM4NKGBQURP9XDDTB1,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:31 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:31 PDT 2019,,,3G0WWMR1UVK0LZYLW4R550A5CQ9QNA,AITP2LUW8GPB,Submitted,Fri Apr 26 12:54:54 PDT 2019,Fri Apr 26 13:33:00 PDT 2019,Sun Apr 28 13:33:00 PDT 2019,,,,2286,100% (62/62),100% (62/62),0% (0/0),5198092,apc_cache.c,"PHP_APCU_API zval* apc_cache_store_zval(zval* dst, const zval* src, apc_context_t* ctxt)\newline{\newline    if (Z_TYPE_P(src) == IS_ARRAY) {\newline        /* Maintain a list of zvals we&#039ve copied to properly handle recursive structures */\newline        zend_hash_init(&ampctxt-&gtcopied, 16, NULL, NULL, 0);\newline        dst = apc_copy_zval(dst, src, ctxt);\newline        /* remove from copied regardless if allocation failure */\newline        zend_hash_destroy(&ampctxt-&gtcopied);\newline        ctxt-&gtcopied.nTableSize=0;\newline    } else {\newline        dst = apc_copy_zval(dst, src, ctxt);\newline    }\newline\newline	if (dst == NULL || EG(exception)) {\newline		return NULL;\newline	}\newline\newline    return dst;\newline}\newline",{{{ apc_cache_store_zval \newline,6514202,key_management.c,"int ecryptfs_wrap_passphrase(char *filename, char *wrapping_passphrase,\newline			     char *unused, char *decrypted_passphrase)\newline{\newline	char wrapping_salt[ECRYPTFS_SALT_SIZE];\newline	char wrapping_auth_tok_sig[ECRYPTFS_SIG_SIZE_HEX + 1];\newline	char wrapping_key[ECRYPTFS_MAX_KEY_BYTES];\newline	char padded_decrypted_passphrase[ECRYPTFS_MAX_PASSPHRASE_BYTES +\newline		ECRYPTFS_AES_BLOCK_SIZE + 1];\newline	char encrypted_passphrase[ECRYPTFS_MAX_PASSPHRASE_BYTES +\newline		ECRYPTFS_AES_BLOCK_SIZE + 1];\newline	int encrypted_passphrase_pos = 0;\newline	int decrypted_passphrase_pos = 0;\newline	int tmp1_outlen = 0;\newline	int tmp2_outlen = 0;\newline	SECStatus err;\newline	SECItem key_item;\newline	PK11SymKey *sym_key = NULL;\newline	PK11SlotInfo *slot = NULL;\newline	PK11Context *enc_ctx = NULL;\newline	SECItem *sec_param = NULL;\newline	int encrypted_passphrase_bytes;\newline	int decrypted_passphrase_bytes;\newline	int fd;\newline	ssize_t size;\newline	int rc;\newline\newline	decrypted_passphrase_bytes = strlen(decrypted_passphrase);\newline	if (decrypted_passphrase_bytes &lt 1 ||\newline	    decrypted_passphrase_bytes &gt ECRYPTFS_MAX_PASSPHRASE_BYTES) {\newline		syslog(LOG_ERR, &quotDecrypted passphrase size is invalid; [1] to [%d] is the valid range\\n&quot,\newline		       ECRYPTFS_MAX_PASSPHRASE_BYTES);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	rc = read_urandom(wrapping_salt, ECRYPTFS_SALT_SIZE);\newline	if (rc != ECRYPTFS_SALT_SIZE) {\newline		rc = rc == -1 ? -errno : -EIO;\newline		syslog(LOG_ERR, &quotError generating random salt: %s\\n&quot,\newline		       strerror(-rc));\newline		goto out;\newline	}\newline	rc = generate_passphrase_sig(wrapping_auth_tok_sig, wrapping_key,\newline				     wrapping_salt, wrapping_passphrase);\newline	if (rc) {\newline		syslog(LOG_ERR, &quotError generating passphrase signature; &quot\newline		       &quotrc = [%d]\\n&quot, rc);\newline		rc = (rc &lt 0) ? rc : rc * -1;\newline		goto out;\newline	}\newline	memset(padded_decrypted_passphrase, 0,\newline	       (ECRYPTFS_MAX_PASSPHRASE_BYTES + 1));\newline	memcpy(padded_decrypted_passphrase, decrypted_passphrase,\newline	       decrypted_passphrase_bytes);\newline	if ((decrypted_passphrase_bytes % ECRYPTFS_AES_BLOCK_SIZE) != 0)\newline		decrypted_passphrase_bytes += (ECRYPTFS_AES_BLOCK_SIZE\newline					       - (decrypted_passphrase_bytes\newline						  % ECRYPTFS_AES_BLOCK_SIZE));\newline	encrypted_passphrase_bytes = decrypted_passphrase_bytes;\newline	NSS_NoDB_Init(NULL);\newline	slot = PK11_GetBestSlot(CKM_AES_ECB, NULL);\newline	key_item.data = (unsigned char *)wrapping_key;\newline	key_item.len = ECRYPTFS_AES_KEY_BYTES;\newline	sym_key = PK11_ImportSymKey(slot, CKM_AES_ECB, PK11_OriginUnwrap,\newline				    CKA_ENCRYPT, &ampkey_item, NULL);\newline	if (!sym_key) {\newline		syslog(LOG_ERR, &quot%s: PK11_ImportSymKey() returned NULL\\n&quot,\newline		       __FUNCTION__);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	sec_param = PK11_ParamFromIV(CKM_AES_ECB, NULL);\newline	enc_ctx = PK11_CreateContextBySymKey(CKM_AES_ECB, CKA_ENCRYPT,\newline					     sym_key, sec_param);\newline	err = PK11_CipherOp(\newline		enc_ctx, (unsigned char *) encrypted_passphrase,\newline		&amptmp1_outlen, ECRYPTFS_MAX_PASSPHRASE_BYTES +\newline		  ECRYPTFS_AES_BLOCK_SIZE,\newline		(unsigned char *) padded_decrypted_passphrase,\newline		decrypted_passphrase_bytes);//ECRYPTFS_MAX_PASSPHRASE_BYTES);\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11_CipherOp() error; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline		goto nss_finish;\newline	}\newline	err = PK11_DigestFinal(\newline		enc_ctx, \newline		(unsigned char *) encrypted_passphrase + tmp1_outlen,\newline		(unsigned int *) &amptmp2_outlen,\newline		(ECRYPTFS_MAX_PASSPHRASE_BYTES + \newline		  ECRYPTFS_AES_BLOCK_SIZE - tmp1_outlen));\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11 error on digest final; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline	}\newline\newlinenss_finish:\newline	if (enc_ctx)\newline		PK11_DestroyContext(enc_ctx, PR_TRUE);\newline	if (sym_key)\newline		PK11_FreeSymKey(sym_key);\newline	if (sec_param)\newline		SECITEM_FreeItem(sec_param, PR_TRUE);\newline	if (slot)\newline		PK11_FreeSlot(slot);\newline	if (rc)\newline		goto out;\newline	encrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	decrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	decrypted_passphrase_bytes -= tmp1_outlen + tmp2_outlen;\newline	if (decrypted_passphrase_bytes != 0) {\newline		syslog(LOG_ERR, &quotWrong size of wrapped passphrase\\n&quot);\newline		rc = - EIO;\newline		goto out;\newline	}\newline	rc = write_v2_wrapped_passphrase_file(filename, wrapping_salt,\newline					      wrapping_auth_tok_sig,\newline					      encrypted_passphrase,\newline					      encrypted_passphrase_bytes);\newline	if (rc)\newline		goto out;\newline	rc = 0;\newlineout:\newline	return rc;\newline}\newline",\newline ecryptfs_wrap_passphrase\newline @filename: Path to the wrapped passphrase file\newline @wrapping_passphrase: The passphrase used for wrapping the @decrypted_passphrase\newline @unused: Previously used for specifying a wrapping salt. It is now randomly\newline generated so @unused is no longer used.\newline @decrypted_passphrase: The passphrase to be wrapped\newline \newline Returns 0 upon success. Negative upon error.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4974623,lcmaps_pluginmanager.c,"int lcmaps_startPluginManager(\newline)\newline{\newline#if USE_EVALUATIONMANAGER\newline    lcmaps_db_entry_t *   lcmaps_db_handle=NULL;\newline#else\newline    lcmaps_db_entry_t **  lcmaps_db_handle=NULL;\newline#endif\newline    lcmaps_db_entry_t *   ihandle=NULL;\newline    lcmaps_plugindl_t *   plugin_entry=NULL;\newline    lcmaps_plugindl_t *   plugin_entry_cmp=NULL;\newline    char *                lcmaps_db_file=NULL;\newline    int                   ientry;\newline    int                   npol = 0;\newline    char *                pol1 = NULL;\newline\newline    /* get LCMAPS (database) home directory and set lcmaps_db_file */\newline    lcmaps_dir = getenv(&quotLCMAPS_DIR&quot);\newline    lcmaps_dir = (lcmaps_dir ? lcmaps_dir : getenv(&quotLCMAPS_ETC_DIR&quot) );\newline    lcmaps_dir = (lcmaps_dir ? lcmaps_dir : LCMAPS_ETC_HOME );\newline\newline    lcmaps_db_file_default = getenv(&quotLCMAPS_DB_FILE&quot);\newline    lcmaps_db_file_default = (lcmaps_db_file_default ? lcmaps_db_file_default : &quotlcmaps.db&quot );\newline\newline    lcmaps_db_file=lcmaps_genfilename(lcmaps_dir, lcmaps_db_file_default, NULL);\newline\newline\newline    /* Setting LCMAPS SIGPIPE handler - old SIGPIPE handler will be preserved */\newline    lcmaps_set_sigpipe_handler();\newline\newline\newline#if USE_EVALUATIONMANAGER\newline    /* To be done:\newline     * Start evaluation manager (evaluates the  LCMAPS policy database)\newline     */\newline    lcmaps_log_debug(4,&quotlcmaps.mod-lcmaps_startPluginManager(): doing lcmaps_startEvaluationManager(%s)\\n&quot, lcmaps_db_file);\newline    if (lcmaps_startEvaluationManager(lcmaps_db_file, npol, &amppol1 ) != 0)\newline    {\newline        lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager(): lcmaps_startEvaluationManager(%s) failed\\n&quot, lcmaps_db_file);\newline        goto fail_lcmaps_startPluginManager;\newline    }\newline#endif\newline\newline    /* \newline     * retrieve PLUGIN MODULE info from evaluation manager and store\newline     * the info in a lcmaps_db structure\newline     */\newline    lcmaps_log(LOG_DEBUG, &quotlcmaps.mod-lcmaps_startPluginManager(): Reading LCMAPS database %s\\n&quot, lcmaps_db_file);\newline#if USE_EVALUATIONMANAGER\newline    if (lcmaps_getPluginNameAndArgs(&amplcmaps_db_handle) != 0)\newline    {\newline        lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager(): Error fetching list of plugins from evaluation manager\\n&quot);\newline        goto fail_lcmaps_startPluginManager;\newline    }\newline#else\newline    lcmaps_db_handle=lcmaps_db_read(lcmaps_db_file);\newline#endif\newline\newline    if (lcmaps_db_handle == NULL)\newline    {\newline#if USE_EVALUATIONMANAGER\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_startPluginManager(): Evaluation manager found no plugins\\n&quot);\newline#else\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_startPluginManager(): no plugins found by lcmaps_db_read()\\n&quot);\newline#endif\newline        goto fail_lcmaps_startPluginManager;\newline    }\newline\newline    /*\newline     * init the PLUGIN AUTHORIZATION MODULES (PluginInit)\newline     * - open plugins and check the symbols plugin_init and confirm_authorization\newline     * - run plugin_init\newline     */\newline    ientry=0;\newline#if USE_EVALUATIONMANAGER\newline    ihandle=lcmaps_db_handle;\newline#else\newline    ihandle=*lcmaps_db_handle;\newline#endif\newline    while (ihandle)\newline    {\newline        if (strlen(ihandle-&gtpluginname) &gt 0)\newline        {\newline            lcmaps_log_debug(4,&quotlcmaps.mod-lcmaps_startPluginManager(): initializing plugin %s (db entry %d)\\n&quot, ihandle-&gtpluginname, ientry);\newline            if ((plugin_entry=PluginInit(ihandle,&ampplugin_list)) == NULL)\newline            {\newline                lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager(): error initializing plugin: %s\\n&quot,ihandle-&gtpluginname);\newline                goto fail_lcmaps_startPluginManager;\newline            }\newline            /* \newline	     * Check if plugin is already registered by comparing the handles of\newline	     * the plugins\newline             */\newline            plugin_entry_cmp=plugin_list;\newline            while (plugin_entry_cmp)\newline            {\newline		if ( plugin_entry_cmp!=plugin_entry &amp&amp\newline		     plugin_entry_cmp-&gthandle==plugin_entry-&gthandle )\newline		{\newline                    lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager() error: trying to use plugin %s twice (registered before as %s)\\n&quot,\newline			    plugin_entry-&gtpluginshortname,\newline			    plugin_entry_cmp-&gtpluginshortname);\newline                    goto fail_lcmaps_startPluginManager;\newline                }\newline                plugin_entry_cmp=plugin_entry_cmp-&gtnext;\newline            }\newline        }\newline        ientry++;\newline        ihandle=ihandle-&gtnext;\newline    }\newline\newline    plugin_entry=plugin_list;\newline    while (plugin_entry)\newline    {\newline#ifdef LCMAPS_DEBUG\newline        print_lcmaps_plugin(4,plugin_entry);\newline#endif\newline        plugin_entry=plugin_entry-&gtnext;\newline    }\newline\newline    /* clean PLUGIN authorization module database structure */\newline#if USE_EVALUATIONMANAGER\newline    /*\newline     * Do not clean lcmaps_db_entry_t structure since it is managed by the evaluation manager\newline     * and will be taken care of in lcmaps_stopEvaluationManager\newline     */\newline    /* if (lcmaps_db_clean_list(&amplcmaps_db_handle)) */\newline    /* { */\newline        /* lcmaps_log(1,&quotlcmaps.mod-lcmaps_startPluginManager() error: could not clean up plugin db structure\\n&quot); */\newline        /* goto fail_lcmaps_startPluginManager; */\newline    /* } */\newline    /* lcmaps_log_debug(5,&quotlcmaps.mod-lcmaps_startPluginManager(): cleaned lcmaps_db list: %p\\n&quot,lcmaps_db_handle); */\newline#else\newline    if (lcmaps_db_clean())\newline    {\newline        lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager() error: could not clean up plugin db structure\\n&quot);\newline        goto fail_lcmaps_startPluginManager;\newline    }\newline    lcmaps_log_debug(5,&quotlcmaps.mod-lcmaps_startPluginManager(): cleaned lcmaps_db list: %p\\n&quot,lcmaps_db_handle);\newline#endif\newline\newline    /* success */\newline    if (lcmaps_db_file) free(lcmaps_db_file);\newline    return 0;\newline\newline fail_lcmaps_startPluginManager:\newline    /* failure */\newline#if USE_EVALUATIONMANAGER\newline    /*\newline     * Do not clean lcmaps_db_entry_t structure since it is managed by the evaluation manager\newline     * and will be taken care of in lcmaps_stopEvaluationManager\newline     */\newline/*    lcmaps_db_clean_list(&amplcmaps_db_handle); */\newline#else\newline    lcmaps_db_clean();\newline#endif\newline    if (clean_plugin_list(&ampplugin_list)!=0)\newline    {\newline        lcmaps_log(LOG_ERR,&quotlcmaps.mod-lcmaps_startPluginManager() error: could not clean up plugin list\\n&quot);\newline    }\newline    if (lcmaps_db_file) free(lcmaps_db_file);\newline\newline    /* It is necessary to call lcmaps_free_resources() here in case LCMAPS\newline     * runs multiple times such as in gsisshd. Otherwise, on e.g. OpenSUSE,\newline     * memory corruption and/or improper close down of flex/yacc leads to a\newline     * segfaults. */\newline    lcmaps_free_resources();\newline\newline    return 1;\newline}\newline","!\newline\\fn lcmaps_startPluginManager(\newline)\newline\\brief start the PluginManager\newlinestart the PluginManager --&gt load plugins, start evaluation manager\newline\\retval 0 succes\newline\\retval 1 failure\newline \newline",1485230,wpass2.c,"wdloUT* parse_wdlo_UT (FILE *inputFile,const wdloIndex* idx) {\newline  int c1,c2,seeklen,i;\newline  wdloUT *ret=NULL,*icurrent=NULL,*inew;\newline  \newline  fseek(inputFile,idx-&gtpos,SEEK_SET);\newline  c1 = fgetc(inputFile);\newline  c2 = fgetc(inputFile);\newline  seeklen = wdlpass2_readShort(inputFile);\newline  while (seeklen &gt 0) {\newline    inew = (wdloUT*)malloc(sizeof(wdloUT));\newline    memset(inew,0,sizeof(wdloUT));\newline    inew-&gtx = wdlpass2_readShort(inputFile);\newline    seeklen -= 2;\newline    inew-&gty = wdlpass2_readShort(inputFile);\newline    seeklen -= 2;\newline    if (icurrent==NULL) {\newline      ret = inew;\newline      icurrent = inew;\newline    } else {\newline      icurrent-&gtnext = inew;\newline      icurrent = inew;\newline    }\newline    inew-&gtutf16data_len = wdlpass2_readShort(inputFile);\newline    seeklen -= 2;\newline    inew-&gtflag1 = fgetc(inputFile);\newline    seeklen -= 1;\newline    inew-&gtutf16data = (char*)malloc(sizeof(char)*2*( (inew-&gtutf16data_len)+1 ));\newline    memset(inew-&gtutf16data,0,sizeof(char)*2*( (inew-&gtutf16data_len)+1 ));\newline    fread(inew-&gtutf16data,2,inew-&gtutf16data_len,inputFile);\newline    seeklen -= (inew-&gtutf16data_len*2);\newline    if (inew-&gtflag1 &amp 0x0001) {\newline      inew-&gtflag1_0x1_x1 = wdlpass2_readShort(inputFile);\newline      seeklen -= 2;\newline      inew-&gtflag1_0x1_y1 = wdlpass2_readShort(inputFile);\newline      seeklen -= 2;\newline      inew-&gtflag1_0x1_x2 = wdlpass2_readShort(inputFile);\newline      seeklen -= 2;\newline      inew-&gtflag1_0x1_y2 = wdlpass2_readShort(inputFile);\newline      seeklen -= 2;\newline    }\newline    if (inew-&gtflag1 &amp 0x0002) {\newline      inew-&gtflag1_0x2_width = (int*)malloc(sizeof(int)*(inew-&gtutf16data_len));\newline      for (i=0 ; i&ltinew-&gtutf16data_len ; i++) {\newline        inew-&gtflag1_0x2_width[i] = wdlpass2_readShort(inputFile);\newline        seeklen -= 2;\newline      }\newline    }\newline    if (inew-&gtflag1 &gt 3) {\newline      error(0,0,&quotWarning: Please report bugs: unknown UT flag01: %d&quot,inew-&gtflag1);\newline    }\newline  }\newline  if (seeklen != 0) {\newline    error_at_line(0,0,__FILE__,__LINE__,&quotWarning: Please report bugs: %s seeklen = %d != 0&quot,__FUNCTION__,seeklen);\newline  }\newline  return ret;\newline}\newline",\newline parsing the data for UT structure\newline User should use free_wdlo_UT() function to free the returned data after use.\newline \newline @param inputFile the file descriptor of the input wdlo file\newline @param idx the node which it&#039s tag is UT\newline @return the linked-list of data in the UT structure\newline \newline,1259907,parser.c,"void TY_(ParseBlock)( TidyDocImpl* doc, Node *element, GetTokenMode mode)\newline{\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline    static int in_parse_block = 0;\newline    static int parse_block_cnt = 0;\newline#endif\newline    Lexer* lexer = doc-&gtlexer;\newline    Node *node;\newline    Bool checkstack = yes;\newline    uint istackbase = 0;\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline    in_parse_block++;\newline    parse_block_cnt++;\newline    SPRTF(&quotEntering ParseBlock %d... %d %s\\n&quot,in_parse_block,parse_block_cnt,\newline        ((element &amp&amp element-&gtelement) ? element-&gtelement : &quot&quot));\newline#endif\newline\newline    if ( element-&gttag-&gtmodel &amp CM_EMPTY ) {\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline        in_parse_block--;\newline        SPRTF(&quotExit ParseBlockL 1 %d...\\n&quot,in_parse_block);\newline#endif\newline        return;\newline    }\newline\newline    if ( nodeIsFORM(element) &amp&amp \newline         DescendantOf(element, TidyTag_FORM) )\newline        TY_(ReportError)(doc, element, NULL, ILLEGAL_NESTING );\newline\newline    /*\newline     InlineDup() asks the lexer to insert inline emphasis tags\newline     currently pushed on the istack, but take care to avoid\newline     propagating inline emphasis inside OBJECT or APPLET.\newline     For these elements a fresh inline stack context is created\newline     and disposed of upon reaching the end of the element.\newline     They thus behave like table cells in this respect.\newline    */\newline    if (element-&gttag-&gtmodel &amp CM_OBJECT)\newline    {\newline        istackbase = lexer-&gtistackbase;\newline        lexer-&gtistackbase = lexer-&gtistacksize;\newline    }\newline\newline    if (!(element-&gttag-&gtmodel &amp CM_MIXED))\newline        TY_(InlineDup)( doc, NULL );\newline\newline    /*\\\newline     *  Issue #212 - If it is likely that it may be necessary\newline     *  to move a leading space into a text node before this\newline     *  element, then keep the mode MixedContent to keep any\newline     *  leading space\newline    \\*/\newline    if ( !(element-&gttag-&gtmodel &amp CM_INLINE) ||\newline          (element-&gttag-&gtmodel &amp CM_FIELD ) )\newline    {\newline        mode = IgnoreWhitespace;\newline    }\newline    else if (mode == IgnoreWhitespace)\newline    {\newline        /* Issue #212 - Further fix in case ParseBlock() is called with &#039IgnoreWhitespace&#039\newline           when such a leading space may need to be inserted before this element to \newline           preverve the browser view */\newline        mode = MixedContent;\newline    }\newline\newline    while ((node = TY_(GetToken)(doc, mode /*MixedContent*/)) != NULL)\newline    {\newline        /* end tag for this element */\newline        if (node-&gttype == EndTag &amp&amp node-&gttag &amp&amp\newline            (node-&gttag == element-&gttag || element-&gtwas == node-&gttag))\newline        {\newline            TY_(FreeNode)( doc, node );\newline\newline            if (element-&gttag-&gtmodel &amp CM_OBJECT)\newline            {\newline                /* pop inline stack */\newline                while (lexer-&gtistacksize &gt lexer-&gtistackbase)\newline                    TY_(PopInline)( doc, NULL );\newline                lexer-&gtistackbase = istackbase;\newline            }\newline\newline            element-&gtclosed = yes;\newline            TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline            in_parse_block--;\newline            SPRTF(&quotExit ParseBlock 2 %d...\\n&quot,in_parse_block);\newline#endif\newline            return;\newline        }\newline\newline#if OBSOLETE /* Issue #380 Kill this code! But leave in src, just in case! */\newline        if ( nodeIsBODY( node ) &amp&amp DescendantOf( element, TidyTag_HEAD ))\newline        {\newline            /*  If we&#039re in the HEAD, close it before proceeding.\newline                This is an extremely rare occurance, but has been observed.\newline                ****************************************************************\newline                Issue #380 - This can cause an INFINITE loop!\newline                This code was added to SF CVS Tidy\newline                revision 1.121 by lpassey, Wed Jul 28 18:08:06 2004 UTC\newline                ****************************************************************\newline            */\newline            TY_(UngetToken)( doc );\newline            break;\newline        }\newline#endif /* #if OBSOLETE */\newline\newline        if ( nodeIsHTML(node) || nodeIsHEAD(node) || nodeIsBODY(node) )\newline        {\newline            if ( TY_(nodeIsElement)(node) )\newline                TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline            TY_(FreeNode)( doc, node );\newline            continue;\newline        }\newline\newline\newline        if (node-&gttype == EndTag)\newline        {\newline            if (node-&gttag == NULL)\newline            {\newline                TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline                TY_(FreeNode)( doc, node );\newline                continue;\newline            }\newline            else if ( nodeIsBR(node) )\newline                node-&gttype = StartTag;\newline            else if ( nodeIsP(node) )\newline            {\newline                /* Cannot have a block inside a paragraph, so no checking\newline                   for an ancestor is necessary -- but we _can_ have\newline                   paragraphs inside a block, so change it to an implicit\newline                   empty paragraph, to be dealt with according to the user&#039s\newline                   options\newline                */\newline                node-&gttype = StartEndTag;\newline                node-&gtimplicit = yes;\newline#if OBSOLETE\newline                TY_(CoerceNode)(doc, node, TidyTag_BR, no, no);\newline                TY_(FreeAttrs)( doc, node ); /* discard align attribute etc. */\newline                TY_(InsertNodeAtEnd)( element, node );\newline                node = InferredTag(doc, TidyTag_BR);\newline#endif\newline            }\newline            else if (DescendantOf( element, node-&gttag-&gtid ))\newline            {\newline                /* \newline                  if this is the end tag for an ancestor element\newline                  then infer end tag for this element\newline                */\newline                TY_(UngetToken)( doc );\newline                break;\newline#if OBSOLETE\newline                Node *parent;\newline                for ( parent = element-&gtparent;\newline                      parent != NULL; \newline                      parent = parent-&gtparent )\newline                {\newline                    if (node-&gttag == parent-&gttag)\newline                    {\newline                        if (!(element-&gttag-&gtmodel &amp CM_OPT))\newline                            TY_(ReportError)(doc, element, node, MISSING_ENDTAG_BEFORE );\newline\newline                        TY_(UngetToken)( doc );\newline\newline                        if (element-&gttag-&gtmodel &amp CM_OBJECT)\newline                        {\newline                            /* pop inline stack */\newline                            while (lexer-&gtistacksize &gt lexer-&gtistackbase)\newline                                TY_(PopInline)( doc, NULL );\newline                            lexer-&gtistackbase = istackbase;\newline                        }\newline\newline                        TrimSpaces( doc, element );\newline                        return;\newline                    }\newline                }\newline#endif\newline            }\newline            else\newline            {\newline                /* special case &lt/tr&gt etc. for stuff moved in front of table */\newline                if ( lexer-&gtexiled\newline                     &amp&amp (TY_(nodeHasCM)(node, CM_TABLE) || nodeIsTABLE(node)) )\newline                {\newline                    TY_(UngetToken)( doc );\newline                    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    in_parse_block--;\newline                    SPRTF(&quotExit ParseBlock 2 %d...\\n&quot,in_parse_block);\newline#endif\newline                    return;\newline                }\newline            }\newline        }\newline\newline        /* mixed content model permits text */\newline        if (TY_(nodeIsText)(node))\newline        {\newline            if ( checkstack )\newline            {\newline                checkstack = no;\newline                if (!(element-&gttag-&gtmodel &amp CM_MIXED))\newline                {\newline                    if ( TY_(InlineDup)(doc, node) &gt 0 )\newline                        continue;\newline                }\newline            }\newline\newline            TY_(InsertNodeAtEnd)(element, node);\newline            mode = MixedContent;\newline\newline            /*\newline              HTML4 strict doesn&#039t allow mixed content for\newline              elements with %block; as their content model\newline            */\newline            /*\newline              But only body, map, blockquote, form and\newline              noscript have content model %block;\newline            */\newline            if ( nodeIsBODY(element)       ||\newline                 nodeIsMAP(element)        ||\newline                 nodeIsBLOCKQUOTE(element) ||\newline                 nodeIsFORM(element)       ||\newline                 nodeIsNOSCRIPT(element) )\newline                TY_(ConstrainVersion)( doc, ~VERS_HTML40_STRICT );\newline            continue;\newline        }\newline\newline        if ( InsertMisc(element, node) )\newline            continue;\newline\newline        /* allow PARAM elements? */\newline        if ( nodeIsPARAM(node) )\newline        {\newline            if ( TY_(nodeHasCM)(element, CM_PARAM) &amp&amp TY_(nodeIsElement)(node) )\newline            {\newline                TY_(InsertNodeAtEnd)(element, node);\newline                continue;\newline            }\newline\newline            /* otherwise discard it */\newline            TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline            TY_(FreeNode)( doc, node );\newline            continue;\newline        }\newline\newline        /* allow AREA elements? */\newline        if ( nodeIsAREA(node) )\newline        {\newline            if ( nodeIsMAP(element) &amp&amp TY_(nodeIsElement)(node) )\newline            {\newline                TY_(InsertNodeAtEnd)(element, node);\newline                continue;\newline            }\newline\newline            /* otherwise discard it */\newline            TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline            TY_(FreeNode)( doc, node );\newline            continue;\newline        }\newline\newline        /* ignore unknown start/end tags */\newline        if ( node-&gttag == NULL )\newline        {\newline            TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline            TY_(FreeNode)( doc, node );\newline            continue;\newline        }\newline\newline        /*\newline          Allow CM_INLINE elements here.\newline\newline          Allow CM_BLOCK elements here unless\newline          lexer-&gtexcludeBlocks is yes.\newline\newline          LI and DD are special cased.\newline\newline          Otherwise infer end tag for this element.\newline        */\newline\newline        if ( !TY_(nodeHasCM)(node, CM_INLINE) )\newline        {\newline            if ( !TY_(nodeIsElement)(node) )\newline            {\newline                if ( nodeIsFORM(node) )\newline                    BadForm( doc );\newline\newline                TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline                TY_(FreeNode)( doc, node );\newline                continue;\newline            }\newline\newline            /* #427671 - Fix by Randy Waki - 10 Aug 00 */\newline            /*\newline             If an LI contains an illegal FRAME, FRAMESET, OPTGROUP, or OPTION\newline             start tag, discard the start tag and let the subsequent content get\newline             parsed as content of the enclosing LI.  This seems to mimic IE and\newline             Netscape, and avoids an infinite loop: without this check,\newline             ParseBlock (which is parsing the LI&#039s content) and ParseList (which\newline             is parsing the LI&#039s parent&#039s content) repeatedly defer to each\newline             other to parse the illegal start tag, each time inferring a missing\newline             &lt/li&gt or &ltli&gt respectively.\newline\newline             NOTE: This check is a bit fragile.  It specifically checks for the\newline             four tags that happen to weave their way through the current series\newline             of tests performed by ParseBlock and ParseList to trigger the\newline             infinite loop.\newline            */\newline            if ( nodeIsLI(element) )\newline            {\newline                if ( nodeIsFRAME(node)    ||\newline                     nodeIsFRAMESET(node) ||\newline                     nodeIsOPTGROUP(node) ||\newline                     nodeIsOPTION(node) )\newline                {\newline                    TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline                    TY_(FreeNode)( doc, node );  /* DSR - 27Apr02 avoid memory leak */\newline                    continue;\newline                }\newline            }\newline\newline            if ( nodeIsTD(element) || nodeIsTH(element) )\newline            {\newline                /* if parent is a table cell, avoid inferring the end of the cell */\newline\newline                if ( TY_(nodeHasCM)(node, CM_HEAD) )\newline                {\newline                    MoveToHead( doc, element, node );\newline                    continue;\newline                }\newline\newline                if ( TY_(nodeHasCM)(node, CM_LIST) )\newline                {\newline                    TY_(UngetToken)( doc );\newline                    node = TY_(InferredTag)(doc, TidyTag_UL);\newline                    AddClassNoIndent(doc, node);\newline                    lexer-&gtexcludeBlocks = yes;\newline                }\newline                else if ( TY_(nodeHasCM)(node, CM_DEFLIST) )\newline                {\newline                    TY_(UngetToken)( doc );\newline                    node = TY_(InferredTag)(doc, TidyTag_DL);\newline                    lexer-&gtexcludeBlocks = yes;\newline                }\newline\newline                /* infer end of current table cell */\newline                if ( !TY_(nodeHasCM)(node, CM_BLOCK) )\newline                {\newline                    TY_(UngetToken)( doc );\newline                    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    in_parse_block--;\newline                    SPRTF(&quotExit ParseBlock 3 %d...\\n&quot,in_parse_block);\newline#endif\newline                    return;\newline                }\newline            }\newline            else if ( TY_(nodeHasCM)(node, CM_BLOCK) )\newline            {\newline                if ( lexer-&gtexcludeBlocks )\newline                {\newline                    if ( !TY_(nodeHasCM)(element, CM_OPT) )\newline                        TY_(ReportError)(doc, element, node, MISSING_ENDTAG_BEFORE );\newline\newline                    TY_(UngetToken)( doc );\newline\newline                    if ( TY_(nodeHasCM)(element, CM_OBJECT) )\newline                        lexer-&gtistackbase = istackbase;\newline\newline                    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    in_parse_block--;\newline                    SPRTF(&quotExit ParseBlock 4 %d...\\n&quot,in_parse_block);\newline#endif\newline                    return;\newline                }\newline            }\newline            else /* things like list items */\newline            {\newline                if (node-&gttag-&gtmodel &amp CM_HEAD)\newline                {\newline                    MoveToHead( doc, element, node );\newline                    continue;\newline                }\newline\newline                /*\newline                 special case where a form start tag\newline                 occurs in a tr and is followed by td or th\newline                */\newline\newline                if ( nodeIsFORM(element) &amp&amp\newline                     nodeIsTD(element-&gtparent) &amp&amp\newline                     element-&gtparent-&gtimplicit )\newline                {\newline                    if ( nodeIsTD(node) )\newline                    {\newline                        TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline                        TY_(FreeNode)( doc, node );\newline                        continue;\newline                    }\newline\newline                    if ( nodeIsTH(node) )\newline                    {\newline                        TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline                        TY_(FreeNode)( doc, node );\newline                        node = element-&gtparent;\newline                        TidyDocFree(doc, node-&gtelement);\newline                        node-&gtelement = TY_(tmbstrdup)(doc-&gtallocator, &quotth&quot);\newline                        node-&gttag = TY_(LookupTagDef)( TidyTag_TH );\newline                        continue;\newline                    }\newline                }\newline\newline                if ( !TY_(nodeHasCM)(element, CM_OPT) &amp&amp !element-&gtimplicit )\newline                    TY_(ReportError)(doc, element, node, MISSING_ENDTAG_BEFORE );\newline\newline                TY_(UngetToken)( doc );\newline\newline                if ( TY_(nodeHasCM)(node, CM_LIST) )\newline                {\newline                    if ( element-&gtparent &amp&amp element-&gtparent-&gttag &amp&amp\newline                         element-&gtparent-&gttag-&gtparser == TY_(ParseList) )\newline                    {\newline                        TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                        in_parse_block--;\newline                        SPRTF(&quotExit ParseBlock 5 %d...\\n&quot,in_parse_block);\newline#endif\newline                        return;\newline                    }\newline\newline                    node = TY_(InferredTag)(doc, TidyTag_UL);\newline                    AddClassNoIndent(doc, node);\newline                }\newline                else if ( TY_(nodeHasCM)(node, CM_DEFLIST) )\newline                {\newline                    if ( nodeIsDL(element-&gtparent) )\newline                    {\newline                        TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                        in_parse_block--;\newline                        SPRTF(&quotExit ParseBlock 6 %d...\\n&quot,in_parse_block);\newline#endif\newline                        return;\newline                    }\newline\newline                    node = TY_(InferredTag)(doc, TidyTag_DL);\newline                }\newline                else if ( TY_(nodeHasCM)(node, CM_TABLE) || TY_(nodeHasCM)(node, CM_ROW) )\newline                {\newline                    /* http://tidy.sf.net/issue/1316307 */\newline                    /* In exiled mode, return so table processing can \newline                       continue. */\newline                    if (lexer-&gtexiled) {\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                        in_parse_block--;\newline                        SPRTF(&quotExit ParseBlock 7 %d...\\n&quot,in_parse_block);\newline#endif\newline                        return;\newline                    }\newline                    node = TY_(InferredTag)(doc, TidyTag_TABLE);\newline                }\newline                else if ( TY_(nodeHasCM)(element, CM_OBJECT) )\newline                {\newline                    /* pop inline stack */\newline                    while ( lexer-&gtistacksize &gt lexer-&gtistackbase )\newline                        TY_(PopInline)( doc, NULL );\newline                    lexer-&gtistackbase = istackbase;\newline                    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    in_parse_block--;\newline                    SPRTF(&quotExit ParseBlock 8 %d...\\n&quot,in_parse_block);\newline#endif\newline                    return;\newline\newline                }\newline                else\newline                {\newline                    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    in_parse_block--;\newline                    SPRTF(&quotExit ParseBlock 9 %d...\\n&quot,in_parse_block);\newline#endif\newline                    return;\newline                }\newline            }\newline        }\newline\newline        /*\\\newline         *  Issue #307 - an &ltA&gt tag to ends any open &ltA&gt element\newline         *  Like #427827 - fixed by Randy Waki and Bjoern Hoehrmann 23 Aug 00\newline         *  in ParseInline(), fix copied HERE to ParseBlock()\newline         *  href: http://www.w3.org/TR/html-markup/a.html\newline         *  The interactive element a must not appear as a descendant of the a element.\newline        \\*/\newline        if ( nodeIsA(node) &amp&amp !node-&gtimplicit &amp&amp \newline             (nodeIsA(element) || DescendantOf(element, TidyTag_A)) )\newline        {\newline            if (node-&gttype != EndTag &amp&amp node-&gtattributes == NULL\newline                &amp&amp cfgBool(doc, TidyCoerceEndTags) )\newline            {\newline                node-&gttype = EndTag;\newline                TY_(ReportError)(doc, element, node, COERCE_TO_ENDTAG);\newline                TY_(UngetToken)( doc );\newline                continue;\newline            }\newline\newline            if (nodeIsA(element))\newline            {\newline                TY_(UngetToken)( doc );\newline            }\newline            TY_(ReportError)(doc, element, node, MISSING_ENDTAG_BEFORE);\newline\newline            if (!(mode &amp Preformatted))\newline                TrimSpaces(doc, element);\newline\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline            in_parse_block--;\newline            SPRTF(&quotExit ParseBlock 9b %d...\\n&quot,in_parse_block);\newline#endif\newline            return;\newline        }\newline\newline        /* parse known element */\newline        if (TY_(nodeIsElement)(node))\newline        {\newline            if (node-&gttag-&gtmodel &amp CM_INLINE)\newline            {\newline                if (checkstack &amp&amp !node-&gtimplicit)\newline                {\newline                    checkstack = no;\newline\newline                    if (!(element-&gttag-&gtmodel &amp CM_MIXED)) /* #431731 - fix by Randy Waki 25 Dec 00 */\newline                    {\newline                        if ( TY_(InlineDup)(doc, node) &gt 0 )\newline                            continue;\newline                    }\newline                }\newline\newline                mode = MixedContent;\newline            }\newline            else\newline            {\newline                checkstack = yes;\newline                mode = IgnoreWhitespace;\newline            }\newline\newline            /* trim white space before &ltbr&gt */\newline            if ( nodeIsBR(node) )\newline                TrimSpaces( doc, element );\newline\newline            TY_(InsertNodeAtEnd)(element, node);\newline            \newline            if (node-&gtimplicit)\newline                TY_(ReportError)(doc, element, node, INSERTING_TAG );\newline\newline            /* Issue #212 - WHY is this hard coded to &#039IgnoreWhitespace&#039 while an \newline               effort has been made above to set a &#039MixedContent&#039 mode in some cases?\newline               WHY IS THE &#039mode&#039 VARIABLE NOT USED HERE???? */\newline            ParseTag( doc, node, IgnoreWhitespace /*MixedContent*/ );\newline            continue;\newline        }\newline\newline        /* discard unexpected tags */\newline        if (node-&gttype == EndTag)\newline            TY_(PopInline)( doc, node );  /* if inline end tag */\newline\newline        TY_(ReportError)(doc, element, node, DISCARDING_UNEXPECTED );\newline        TY_(FreeNode)( doc, node );\newline        continue;\newline    }\newline\newline    if (!(element-&gttag-&gtmodel &amp CM_OPT))\newline        TY_(ReportError)(doc, element, node, MISSING_ENDTAG_FOR);\newline\newline    if (element-&gttag-&gtmodel &amp CM_OBJECT)\newline    {\newline        /* pop inline stack */\newline        while ( lexer-&gtistacksize &gt lexer-&gtistackbase )\newline            TY_(PopInline)( doc, NULL );\newline        lexer-&gtistackbase = istackbase;\newline    }\newline\newline    TrimSpaces( doc, element );\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline    in_parse_block--;\newline    SPRTF(&quotExit ParseBlock 10 %d...\\n&quot,in_parse_block);\newline#endif\newline}\newline","\newlineelement is node created by the lexer\newlineupon seeing the start tag, or by the\newlineparser when the start tag is inferred\newline \newline",212608,screen.c,"static int findTerm(const char *sender, const char *path, int active, int depth) {\newline  dbus_uint32_t *states = getState(sender, path);\newline\newline  if (!states)\newline    return 0;\newline\newline  if (states[0] &amp (1&lt&ltATSPI_STATE_ACTIVE))\newline    /* This application is active */\newline    active = 1;\newline\newline  if (states[0] &amp (1&lt&ltATSPI_STATE_FOCUSED) &amp&amp active)\newline  {\newline    /* And this widget is focused */\newline    logMessage(LOG_CATEGORY(SCREEN_DRIVER),\newline               &quot%s %s is focused!&quot, sender, path);\newline    free(states);\newline    tryRestartTerm(sender, path);\newline    return 1;\newline  }\newline\newline  free(states);\newline  return recurseFindTerm(sender, path, active, depth+1);\newline}\newline","Test whether this object is active, and if not recurse in its children \newline",1813053,files.cpp,"void state::md5deep_add_hash(char *h, char *fn)\newline{\newline    class file_data_t *fdt = new file_data_t();\newline    fdt-&gthash_hex[opt_md5deep_mode_algorithm] = h; \newline    fdt-&gtfile_name = fn;\newline    ocb.add_fdt(fdt);\newline}\newline",\newline explicitly add a hash that will be matched or not matched.\newline @param h - The hash (in hex)\newline @param fn - The file name (although -a and -A actually provide the hash again)\newline \newline,2164213,cyrusdb_twoskip.c,"static int advance_loc(struct dbengine *db)\newline{\newline    struct skiploc *loc = &ampdb-&gtloc;\newline    uint8_t i;\newline    int r;\newline\newline    /* has another session made changes?  Need to re-find the location */\newline    if (loc-&gtend != db-&gtend || loc-&gtgeneration != db-&gtheader.generation) {\newline	r = relocate(db);\newline	if (r) return r;\newline    }\newline\newline    /* update back pointers */\newline    for (i = 0; i &lt loc-&gtrecord.level; i++)\newline	loc-&gtbackloc[i] = loc-&gtrecord.offset;\newline\newline    /* ADVANCE */\newline    r = read_skipdelete(db, loc-&gtforwardloc[0], &amploc-&gtrecord);\newline    if (r) return r;\newline\newline    /* reached the end? */\newline    if (!loc-&gtrecord.offset) {\newline	buf_reset(&amploc-&gtkeybuf);\newline	return relocate(db);\newline    }\newline\newline    /* update forward pointers */\newline    for (i = 0; i &lt loc-&gtrecord.level; i++)\newline	loc-&gtforwardloc[i] = _getloc(db, &amploc-&gtrecord, i);\newline\newline    /* keep our location */\newline    buf_setmap(&amploc-&gtkeybuf, KEY(db, &amploc-&gtrecord), loc-&gtrecord.keylen);\newline    loc-&gtis_exactmatch = 1;\newline\newline    /* make sure this record is complete */\newline    r = check_tailcrc(db, &amploc-&gtrecord);\newline    if (r) return r;\newline\newline    return 0;\newline}\newline","helper function to advance to the &quotnext&quot record. Used by foreach,\newline fetchnext, and internal functions \newline",174996,mprocess.cpp,"bool mprocess::rollback(vector&ltmspectrum&gt&amp _v,const double _m,const double _f)\newline{\newline	if(_v.empty())	{\newline		return false;\newline	}\newline	size_t a = 0;\newline	const size_t tSize = m_vSpectra.size();\newline	double dExpect = 1.0;\newline	double dExpectLast = 1.0;\newline	bool bDone = false;\newline	while(a &lt tSize)	{\newline		if(!m_vSpectra[a].m_vseqBest.empty() &amp&amp !_v[a].m_vseqBest.empty())	{\newline			bDone = false;\newline			m_vSpectra[a].m_hHyper.model();\newline			m_vSpectra[a].m_hHyper.set_protein_factor(1.0);\newline			dExpect = (double)m_vSpectra[a].m_hHyper.expect_protein(m_pScore-&gthconvert(m_vSpectra[a].m_fHyper));\newline			dExpectLast = (double)m_vSpectra[a].m_hHyper.expect_protein(m_pScore-&gthconvert(_v[a].m_fHyper));\newline			if(dExpect &gt _m)	{\newline				m_vSpectra[a] *= _v[a];\newline				bDone = true;\newline			}\newline			else if(dExpect &lt= _m  &amp&amp dExpect/dExpectLast &gt _f)	{\newline				m_vSpectra[a] *= _v[a];\newline				bDone = true;\newline			}\newline			else if(!bDone &amp&amp m_vSpectra[a].m_fHyper == _v[a].m_fHyper)	{\newline				m_vSpectra[a] *= _v[a];\newline			}\newline		}\newline		a++;\newline	}\newline	_v.clear();\newline	return true;\newline}\newline","\newline rollback is a method that is used to reverse changes that have been made to the\newline m_vSpectra vector during the refinement process. If a new result, discovered during\newline the refinement process, is not sufficiently significant (as determined by _f), then\newline the m_vSpectra entry is &quotrolled back&quot to the value it had after the initial \newline survey round.\newline \newline",5983577,wrapper.c,"void wrapperResumeProcess(int actionSourceCode) {\newline    TCHAR msgBuffer[10];\newline\newline    if ((wrapperData-&gtwState == WRAPPER_WSTATE_STOPPING) ||\newline        (wrapperData-&gtwState == WRAPPER_WSTATE_STOPPED)) {\newline        /* If we are already shutting down, then ignore and continue to do so. */\newline\newline        if (wrapperData-&gtisDebugging) {\newline            log_printf(WRAPPER_SOURCE_WRAPPER, LEVEL_DEBUG, TEXT(\newline                &quotwrapperResumeProcess() called while stopping.  (IGNORED)&quot));\newline        }\newline    } else if (wrapperData-&gtwState == WRAPPER_WSTATE_STARTING) {\newline        /* If we are currently being started, then ignore and continue to do so. */\newline\newline        if (wrapperData-&gtisDebugging) {\newline            log_printf(WRAPPER_SOURCE_WRAPPER, LEVEL_DEBUG, TEXT(\newline                &quotwrapperResumeProcess() called while starting.  (IGNORED)&quot));\newline        }\newline    } else if (wrapperData-&gtwState == WRAPPER_WSTATE_STARTED) {\newline        /* If we are currently started, then ignore and continue to do so. */\newline\newline        if (wrapperData-&gtisDebugging) {\newline            log_printf(WRAPPER_SOURCE_WRAPPER, LEVEL_DEBUG, TEXT(\newline                &quotwrapperResumeProcess() called while started.  (IGNORED)&quot));\newline        }\newline    } else if (wrapperData-&gtwState == WRAPPER_WSTATE_RESUMING) {\newline        /* If we are currently being continued, then ignore and continue to do so. */\newline\newline        if (wrapperData-&gtisDebugging) {\newline            log_printf(WRAPPER_SOURCE_WRAPPER, LEVEL_DEBUG, TEXT(\newline                &quotwrapperResumeProcess() called while resuming.  (IGNORED)&quot));\newline        }\newline    } else {\newline        if (wrapperData-&gtisDebugging) {\newline            log_printf(WRAPPER_SOURCE_WRAPPER, LEVEL_DEBUG, TEXT(\newline                &quotwrapperResumeProcess() called.&quot));\newline        }\newline\newline        /* If we were configured to stop the JVM then we want to reset its failed\newline         *  invocation count as the current stoppage was expected. */\newline        if (wrapperData-&gtpausableStopJVM) {\newline            wrapperData-&gtfailedInvocationCount = 0;\newline        }\newline\newline        wrapperSetWrapperState(WRAPPER_WSTATE_RESUMING);\newline\newline        if (!wrapperData-&gtpausableStopJVM) {\newline            /* Notify the Java process. */\newline            _sntprintf(msgBuffer, 10, TEXT(&quot%d&quot), actionSourceCode);\newline            wrapperProtocolFunction(WRAPPER_MSG_RESUME, msgBuffer);\newline        }\newline    }\newline}\newline",\newline Used to ask the state engine to resume a paused the JVM.\newline \newline @param actionSourceCode Tracks where the action originated.\newline \newline,346925,tree.c,"EXPORT Tree wrap_elt(Node *n, const conststring elem, pairlist attr)\newline{\newline  Node *h, *k;\newline\newline  new(h);\newline  h-&gttp = Element;\newline  h-&gtname = newstring(elem);\newline  h-&gtattribs = attr;\newline  h-&gtsister = n-&gtsister;\newline  h-&gtparent = n-&gtparent;\newline  h-&gtchildren = n;\newline  n-&gtsister = NULL;\newline  n-&gtparent = h;\newline  if (h-&gtparent-&gtchildren == n) {\newline    h-&gtparent-&gtchildren = h;\newline  } else {\newline    k = h-&gtparent-&gtchildren;\newline    while (k-&gtsister != n) {assert(k-&gtsister-&gtsister); k = k-&gtsister;}\newline    k-&gtsister = h;\newline  }\newline  return h;\newline}\newline","wrap_elt -- wrap an element in a new element, return the new element \newline",3964316,vmfs_lvm.c,bool vmfs_device_is_lvm(vmfs_device_t *dev)\newline{\newline   return (dev-&gtread == vmfs_lvm_read);\newline}\newline,Returns whether a given device is a vmfs_lvm \newline,5267433,common.c,"int padd(packet_idl * current)\newline{\newline	if (track_size &lt= packets_list.length) {\newline		log_area_printf(DEBUG_AREA_PACKET, DEBUG_LEVEL_WARNING,\newline				&quotWarning: queue is full, dropping element&quot);\newline		IPQ_SET_VERDICT(current-&gtid, NF_DROP);\newline		return -1;\newline	}\newline\newline	packets_list.length++;\newline	current-&gtnext = NULL;\newline\newline	if (current-&gttimestamp == 0) {\newline		current-&gttimestamp = time(NULL);\newline	}\newline\newline	if (packets_list.end != NULL)\newline		packets_list.end-&gtnext = current;\newline	packets_list.end = current;\newline	if (packets_list.start == NULL)\newline		packets_list.start = current;\newline	return 0;\newline}\newline","\newline Try to add a packet to the end of ::packets_list. If we exceed max length\newline (::track_size), just drop the packet.\newline \newline \\return 0 if ok, -1 if list is full. \newline \newline",896921,ospstatistics.c,unsigned OSPPStatsGetPktSent(\newline    OSPT_STATS *ospvStats)\newline{\newline    unsigned pktssent = 0;\newline\newline    if ((ospvStats != OSPC_OSNULL) &amp&amp ((ospvStats-&gtLossSent.hasvalue &amp OSPC_SVALUE_PACKETS) != 0)) {\newline        pktssent = ospvStats-&gtLossSent.packets;\newline    }\newline\newline    return pktssent;\newline}\newline,Get value for packetssent \newline,5705506,fortune.c,"int is_existant(char *file)\newline{\newline    struct stat staat;\newline\newline    if (stat(file, &ampstaat) == 0)\newline	return TRUE;\newline    switch(errno)\newline    {\newline	case ENOENT:\newline	case ENOTDIR:\newline	    return FALSE;\newline	default:\newline	    perror(&quotfortune: bad juju in is_existant&quot);\newline	    exit(1);\newline    }\newline}\newline","\newline is_existant:\newline Return TRUE if the file exists, FALSE otherwise.\newline \newline",4945153,tab.c,"int mnt_table_last_fs(struct libmnt_table *tb, struct libmnt_fs **fs)\newline{\newline	if (!tb || !fs)\newline		return -EINVAL;\newline	if (list_empty(&amptb-&gtents))\newline		return 1;\newline	*fs = list_last_entry(&amptb-&gtents, struct libmnt_fs, ents);\newline	return 0;\newline}\newline","\newline mnt_table_last_fs:\newline @tb: tab pointer\newline @fs: returns the last tab entry\newline \newline Returns: 0 on success, negative number in case of error or 1 at the end of list.\newline \newline",2945086,showimage.c,"static unsigned cached_area_size(GdkRectangle *area, struct map_cache *cache)\newline{\newline	int psize;\newline\newline	psize = cache-&gttype == MAP_CACHE_GRAY ? 1 : 3;\newline	return psize * (area-&gtwidth + 2 * MAX_ZOOM) * (area-&gtheight + 2 * MAX_ZOOM);\newline}\newline",\newline compute the size a cache needs to be so that the give area can fit\newline \newline,4949261,powernow-k8-decode.c,static uint32_t find_freq_from_fid(uint32_t fid)\newline{\newline	return 800 + (fid * 100);\newline}\newline,"Return a frequency in MHz, given an input fid \newline",2628232,reduce.c,"static void BoxStats(Box *box)\newline{\newline	register int i, color;\newline	unsigned long *freq;\newline	float mean, var;\newline\newline	if (box-&gtweight == 0) {\newline		box-&gtweightedvar = 0.0;\newline		return;\newline	}\newline	box-&gtweightedvar = 0.;\newline	for (color = 0; color &lt 3; color++) {\newline		var = mean = 0;\newline		i = box-&gtlow[color];\newline		freq = &ampbox-&gtfreq[color][i];\newline		for (; i &lt box-&gthigh[color]; i++, freq++) {\newline			mean += i * *freq;\newline			var += i * i * *freq;\newline		}\newline		box-&gtmean[color] = mean / (float) box-&gtweight;\newline		box-&gtweightedvar += var - box-&gtmean[color] * box-&gtmean[color] *\newline		    (float) box-&gtweight;\newline	}\newline	box-&gtweightedvar /= NPixels;\newline}\newline",Compute mean and weighted variance of the given box. \newline,1673674,fetchmail.c,"int fetchMail(int account)\newline{\newline	CURL *mail_handle;\newline	const struct MACCOUNT *a = accounts + account - 1;\newline	const char *login = a-&gtlogin;\newline	const char *pass = a-&gtpassword;\newline	int nfetch = 0;		/* number of messages actually fetched */\newline	CURLcode res = CURLE_OK;\newline	const char *url_for_error;\newline	int message_count = 0, message_number;\newline\newline	get_mailbox_url(a);\newline	url_for_error = mailbox_url;\newline\newline	if (!mailDir)\newline		i_printfExit(MSG_NoMailDir);\newline	if (chdir(mailDir))\newline		i_printfExit(MSG_NoDirChange, mailDir);\newline\newline	if (!umf) {\newline		umf = allocMem(strlen(mailUnread) + 12);\newline		sprintf(umf, &quot%s/&quot, mailUnread);\newline		umf_end = umf + strlen(umf);\newline	}\newline	unreadBase = 0;\newline	unreadStats();\newline\newline	mailstring = initString(&ampmailstring_l);\newline	mail_handle = newFetchmailHandle(login, pass);\newline	res = count_messages(mail_handle, &ampmessage_count);\newline	if (res != CURLE_OK)\newline		goto fetchmail_cleanup;\newline\newline	for (message_number = 1; message_number &lt= message_count;\newline	     message_number++) {\newline		if (asprintf(&ampmessage_url, &quot%s%u&quot, mailbox_url, message_number)\newline		    == -1) {\newline/* Again, the byte count in the error message is a bit of a fib. */\newline			i_printfExit(MSG_MemAllocError,\newline				     strlen(mailbox_url) + 11);\newline		}\newline		nzFree(mailstring);\newline		res = fetchOneMessage(mail_handle, message_number);\newline		if (res != CURLE_OK)\newline			goto fetchmail_cleanup;\newline		nfetch++;\newline		res = deleteOneMessage(mail_handle);\newline		if (res != CURLE_OK)\newline			goto fetchmail_cleanup;\newline		nzFree(message_url);\newline		message_url = NULL;\newline	}\newline\newlinefetchmail_cleanup:\newline	if (message_url)\newline		url_for_error = message_url;\newline	if (res != CURLE_OK) {\newline		ebcurl_setError(res, url_for_error);\newline		showError();\newline	}\newline	curl_easy_cleanup(mail_handle);\newline	nzFree(message_url);\newline	nzFree(mailbox_url);\newline	nzFree(mailstring);\newline	mailstring = initString(&ampmailstring_l);\newline	return nfetch;\newline}				/* fetchMail */\newline",Returns number of messages fetched \newline,on,on,,,,,,,,on,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,{},{},actionSourceCode Tracks where the action originated.,"wrap an element in a new element, return the new element",Returns whether a given device is a vmfs_lvm,"If we exceed max length
(::track_size), just drop the packet.",Get value for packetssent,"Return TRUE if the file exists, FALSE otherwise.",returns the last tab entry,{},"Return a frequency in MHz,",Returns 0 upon success. Negative upon error.,{},Returns number of messages fetched,Load an image from the named file.,\brief start the PluginManager,parsing the data for UT structure,parser when the start tag is inferred,"Test whether this object is active,",explicitly add a hash that will be matched or not matched.,"helper function to advance to the ""next"" record.",x,
3CESM1J3EI3VBRRMJUZT6VAGN6L6WK,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:48 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:48 PDT 2019,,,39LNWE0K4UW0ZRUBGXYIATBDTCNIUT,AITP2LUW8GPB,Submitted,Fri Apr 26 12:49:05 PDT 2019,Fri Apr 26 13:25:30 PDT 2019,Sun Apr 28 13:25:30 PDT 2019,,,,2185,100% (62/62),100% (62/62),0% (0/0),311728,commands.c,"int cmd_remove_acknowledgement(int cmd, char *args) {\newline	service *temp_service = NULL;\newline	host *temp_host = NULL;\newline	char *host_name = NULL;\newline	char *svc_description = NULL;\newline\newline	/* get the host name */\newline	if ((host_name = my_strtok(args, &quot;&quot)) == NULL)\newline		return ERROR;\newline\newline	/* verify that the host is valid */\newline	if ((temp_host = find_host(host_name)) == NULL) {\newline		logit(NSLOG_RUNTIME_ERROR, TRUE, &quotError: Could not find host &#039%s&#039 provided in external command!\\n&quot, host_name);\newline		return ERROR;\newline	}\newline\newline	/* we are removing a service acknowledgement */\newline	if (cmd == CMD_REMOVE_SVC_ACKNOWLEDGEMENT) {\newline\newline		/* get the service name */\newline		if ((svc_description = my_strtok(NULL, &quot;&quot)) == NULL)\newline			return ERROR;\newline\newline		/* verify that the service is valid */\newline		if ((temp_service = find_service(temp_host-&gtname, svc_description)) == NULL) {\newline			logit(NSLOG_RUNTIME_ERROR, TRUE, &quotError: Could not find host &#039%s&#039 and service &#039%s&#039 provided in external command!\\n&quot, host_name, svc_description);\newline			return ERROR;\newline		}\newline	}\newline\newline	/* acknowledge the host problem */\newline	if (cmd == CMD_REMOVE_HOST_ACKNOWLEDGEMENT)\newline		remove_host_acknowledgement(temp_host);\newline\newline	/* acknowledge the service problem */\newline	else\newline		remove_service_acknowledgement(temp_service);\newline\newline	return OK;\newline}\newline",removes a host or service acknowledgement \newline,1223113,mod_vroot.c,"MODRET set_vrootlog(cmd_rec *cmd) {\newline  CHECK_ARGS(cmd, 1);\newline  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\newline\newline  if (pr_fs_valid_path(cmd-&gtargv[1]) &lt 0)\newline    CONF_ERROR(cmd, &quotmust be an absolute path&quot);\newline\newline  (void) add_config_param_str(cmd-&gtargv[0], 1, cmd-&gtargv[1]);\newline  return PR_HANDLED(cmd);\newline}\newline",usage: VRootLog path|&quotnone&quot \newline,2841131,xltenc.c,"Ret_t xltEncTerminate(const XltEncoderPtr_t pEncoder,\newline                      const MemPtr_t pBufEnd,\newline                      MemPtr_t *ppBufPos)\newline{\newline  // Return variable\newline  Ret_t _err;\newline\newline  // encoding type\newline  SmlEncoding_t _enc;\newline\newline  //Structure containing buffer pointers, length and written bytes\newline  BufferMgmtPtr_t _pBufMgr;\newline\newline  //get the encoding type\newline  _enc = pEncoder-&gtenc;\newline\newline  //Initialize buffer variables\newline  if ((_pBufMgr = smlLibMalloc(sizeof(BufferMgmt_t))) == NULL) {\newline    smlLibFree(pEncoder);\newline    return SML_ERR_NOT_ENOUGH_SPACE;\newline   }\newline\newline  _pBufMgr-&gtvers = pEncoder-&gtvers; // %%% luz:2003-07-31: pass SyncML version to bufmgr\newline  _pBufMgr-&gtsmlXltWrittenBytes = 0;\newline  _pBufMgr-&gtsmlXltBufferP = *ppBufPos;\newline  _pBufMgr-&gtsmlXltStoreBufP = _pBufMgr-&gtsmlXltBufferP;\newline  _pBufMgr-&gtsmlXltBufferLen = pBufEnd - *ppBufPos;\newline  _pBufMgr-&gtsmlCurExt = pEncoder-&gtcur_ext;\newline  _pBufMgr-&gtsmlLastExt = pEncoder-&gtlast_ext;\newline  _pBufMgr-&gtsmlActiveExt = pEncoder-&gtcur_ext;\newline  _pBufMgr-&gtswitchExtTag = TN_UNDEF;\newline  _pBufMgr-&gtspaceEvaluation = ((pEncoder-&gtspace_evaluation == NULL) ? 0 : 1);\newline  _pBufMgr-&gtendTagSize =0;\newline\newline  if (pEncoder-&gtfinal == 1)\newline  {\newline    // Final Flag\newline      if ((_err = xltGenerateTag(TN_FINAL, TT_ALL, _enc, _pBufMgr, SML_EXT_UNDEFINED)) != SML_ERR_OK)\newline    {\newline      smlLibFree(_pBufMgr);\newline      xltEncReset(pEncoder);\newline      return _err;\newline    }\newline  }\newline\newline  // SyncBody End Tag\newline  if ((_err = xltGenerateTag(TN_SYNCBODY, TT_END, _enc, _pBufMgr, SML_EXT_UNDEFINED)) != SML_ERR_OK)\newline  {\newline    smlLibFree(_pBufMgr);\newline    xltEncReset(pEncoder);\newline    return _err;\newline  }\newline\newline  // SyncML End Tag\newline  if ((_err = xltGenerateTag(TN_SYNCML, TT_END, _enc, _pBufMgr, SML_EXT_UNDEFINED)) != SML_ERR_OK)\newline  {\newline    smlLibFree(_pBufMgr);\newline    xltEncReset(pEncoder);\newline    return _err;\newline  }\newline\newline  pEncoder-&gtcur_ext = _pBufMgr-&gtsmlCurExt;\newline  pEncoder-&gtlast_ext = _pBufMgr-&gtsmlLastExt;\newline\newline  *ppBufPos = _pBufMgr-&gtsmlXltBufferP;\newline\newline  smlLibFree(_pBufMgr);\newline\newline  xltEncReset(pEncoder);\newline\newline  return SML_ERR_OK;\newline}\newline","\newline Filnalizes the (WB)XML document and returns the size of written bytes to\newline the workspace module\newline \newline @pre pEncoder holds the initialized encoder structure.\newline the initialization takes place in the xltEncAppend function\newline pBufEnd must point to the end of the (WB)XML buffer\newline ppBufPos has to be initialized to the start point of the\newline (WB)XML buffer.\newline @post After the function call ppBufPos points to the\newline first free byte in the buffer behind the (WB)XML document\newline @param pEncoder (IN)\newline the encoder object\newline @param pBufEnd (IN)\newline pointer to the end of the buffer to write on\newline @param ppBufPos (IN/OUT)\newline current position of the bufferpointer\newline @return shows error codes of function,\\n\newline 0, if OK\\n\newline Possible Error Codes:\newline - SML_ERR_XLT_BUF_ERR\newline - SML_ERR_XLT_MISSING_CONT\newline - SML_ERR_XLT_INVAL_ELEM_TYPE\newline - SML_ERR_XLT_INVAL_LIST_TYPE\newline - SML_ERR_XLT_INVAL_TAG_TYPE\newline - SML_ERR_XLT_ENC_UNK\newline - SML_ERR_XLT_INVAL_PROTO_ELEM\newline \newline",4366333,tcompound.cpp,"static void test_compound_5()\newline{\newline    typedef struct {\newline        char    name[16];\newline        short   tdim;\newline        short   coll_ids[4];\newline    } src_typ_t;\newline\newline    typedef struct {\newline        char    name[16];\newline        short   tdim;\newline        int     coll_ids[4];\newline    } dst_typ_t;\newline\newline    hsize_t      dims[1] = {4};\newline    src_typ_t  src[2] = {{&quotone&quot, 102, {104, 105, 106, 107}},\newline                          {&quottwo&quot, 202, {204, 205, 206, 207}}};\newline    dst_typ_t  *dst;\newline    void        *buf = HDcalloc(2, sizeof(dst_typ_t));\newline    void        *bkg = HDcalloc(2, sizeof(dst_typ_t));\newline    ArrayType* array_dt = NULL;\newline\newline    // Output message about test being performed\newline    SUBTEST(&quotOptimized Struct Converter&quot);\newline    try {\newline\newline	/* Build datatypes */\newline	array_dt = new ArrayType(PredType::NATIVE_SHORT, 1, dims);\newline	CompType short_array(4*sizeof(short));\newline	short_array.insertMember(&quot_&quot, 0, *array_dt);\newline	array_dt-&gtclose();\newline        delete array_dt;\newline\newline	CompType int_array(4*sizeof(int));\newline	array_dt = new ArrayType(PredType::NATIVE_INT, 1, dims);\newline	int_array.insertMember(&quot_&quot, 0, *array_dt);\newline	array_dt-&gtclose();\newline\newline	StrType strg(PredType::C_S1, 16);\newline	CompType src_type(sizeof(src_typ_t));\newline	src_type.insertMember(&quotname&quot, HOFFSET(src_typ_t, name), strg);\newline	src_type.insertMember(&quottdim&quot, HOFFSET(src_typ_t, tdim), PredType::NATIVE_SHORT);\newline	src_type.insertMember(&quotcoll_ids&quot, HOFFSET(src_typ_t, coll_ids), short_array);\newline\newline	CompType dst_type(sizeof(dst_typ_t));\newline	dst_type.insertMember(&quotname&quot, HOFFSET(dst_typ_t, name), strg);\newline	dst_type.insertMember(&quottdim&quot, HOFFSET(dst_typ_t, tdim), PredType::NATIVE_SHORT);\newline	dst_type.insertMember(&quotcoll_ids&quot, HOFFSET(dst_typ_t, coll_ids), int_array);\newline\newline	/* Convert data */\newline	memcpy(buf, src, sizeof(src));\newline	src_type.convert(dst_type, (size_t)2, buf, bkg);\newline	dst = (dst_typ_t*)buf;\newline\newline	/* Cleanup */\newline	src_type.close();\newline	dst_type.close();\newline	strg.close();\newline	short_array.close();\newline	int_array.close();\newline\newline	/* Check results */\newline	if (memcmp(src[1].name, dst[1].name, sizeof(src[1].name)) ||\newline	    src[1].tdim!=dst[1].tdim ||\newline	    src[1].coll_ids[0]!=dst[1].coll_ids[0] ||\newline	    src[1].coll_ids[1]!=dst[1].coll_ids[1] ||\newline	    src[1].coll_ids[2]!=dst[1].coll_ids[2] ||\newline	    src[1].coll_ids[3]!=dst[1].coll_ids[3])\newline	{ H5_FAILED(); }\newline\newline	/* Free memory buffers */\newline	HDfree(buf);\newline	HDfree(bkg);\newline	dst = NULL;\newline	PASSED();\newline    }   // end of try block\newline\newline    catch (Exception E) {\newlinecerr &lt&lt &quottest_compound_5 in catch&quot &lt&lt endl;\newline        issue_fail_msg(E.getCFuncName(), __LINE__, __FILE__, E.getCDetailMsg());\newline    }\newline\newline    if(array_dt)\newline        delete array_dt;\newline}   // test_compound_5()\newline","-------------------------------------------------------------------------\newline Function: test_compound_5\newline \newline Purpose: Many versions of HDF5 have a bug in the optimized compound\newline datatype conversion function, H5T_conv_struct_opt(), which\newline is triggered when the top-level type contains a struct\newline which must undergo a conversion.\newline \newline Return: None\newline \newline Programmer: Binh-Minh Ribler (use C version)\newline January, 2007\newline \newline Modifications:\newline \newline -------------------------------------------------------------------------\newline \newline",3007753,util.c,"int ARMCII_Log2(unsigned int val) {\newline  unsigned int v16, v8;\newline  int lg = 0;\newline\newline  if (val == 0) return -1;\newline\newline  if ((v16 = val &gt&gt 16))\newline    lg = (v8 = v16 &gt&gt 8) ? log2_table[v8] + 24 : log2_table[v16] + 16;\newline  else\newline    lg = (v8 = val &gt&gt 8) ? log2_table[v8] + 8 : log2_table[val];\newline\newline  return lg;\newline}\newline",Calculate the base 2 logarithm of a given integer.\newline \newline,5898289,kmclipm_test_priv_functions.c,"void test_kmclipm_priv_create_patrol_view()\newline{\newline    float        *img_data  = NULL;\newline\newline    cpl_image    *img       = NULL,\newline                 *img2      = NULL,\newline                 *ret_ptr   = NULL;\newline\newline    cpl_imagelist *img_list = NULL;\newline\newline    int           i         = 0,\newline                  j         = 0;\newline\newline    const int     ifu_id_zero[] = {-1,\newline                                   0,0,0,0,0,0,0,0,0,0,0,0,\newline                                   0,0,0,0,0,0,0,0,0,0,0,0},\newline                  ifu_id_mixed[] = {-1,\newline                                   1,0,1,0,1,0,1,0,1,0,1,1,\newline                                   0,1,0,0,0,0,0,0,0,0,0,0};\newline\newline    const double  nominal_pos[] = {-1.0, -1.0,\newline                                   -111.66474, 31.4259,   /* IFU_1_x, IFU_1_y */\newline                                   -71.01666, 46.6983,    /* IFU_2*/\newline                                   -28.72386, 13.56894,   /* IFU_3 */\newline                                   -15.33114, 0.64614,    /* IFU_4 */\newline                                   111.54726, 16.85838,   /* IFU_5 */\newline                                   34.83282, 93.1029,     /* IFU_6 */\newline                                   -10.39698, -113.42694, /* IFU_7 */\newline                                   50.10522, -112.25214,  /* IFU_8 */\newline                                   -50, -30,              /* IFU_9 */\newline                                   -10, -80,              /* IFU_10 */\newline                                   -50, 15,               /* IFU_11 */\newline                                   10, -100,              /* IFU_12 */\newline                                   15, 15,                /* IFU_13 */\newline                                   126, 0,                /* IFU_14 */\newline                                   -10, -10,              /* IFU_15 */\newline                                   89.716577, 89.716577,  /* IFU_16 */\newline                                   50, -40,               /* IFU_17 */\newline                                   40, -20,               /* IFU_18 */\newline                                   70, -10,               /* IFU_19 */\newline                                   -10, 50,               /* IFU_20 */\newline                                   -40, 80,               /* IFU_21 */\newline                                   -70, 0,                /* IFU_22 */\newline                                   60, 10,                /* IFU_23 */\newline                                   70, 50 };              /* IFU_24 */    \newline\newline    /* ----- test with wrong values ----- */\newline    /* 3 NULL pointers */\newline    ret_ptr = kmclipm_priv_create_patrol_view(NULL, NULL, NULL);\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    /* empty image list and 2 NULL pointers */\newline    img_list = cpl_imagelist_new();\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, NULL, NULL);\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    /* empty image list, nominal_pos and 1 NULL pointer */\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, nominal_pos, NULL);\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    /* too large img_list ( greater than KMOS_NR_IFUS) */\newline    for (j = 0; j &lt= KMOS_NR_IFUS; j++) {\newline        img2 = cpl_image_new(KMOS_SLITLET_X, KMOS_SLITLET_Y, CPL_TYPE_FLOAT);\newline        cpl_imagelist_set(img_list, img2, j);\newline    }\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, nominal_pos,\newline                                              ifu_id_zero);\newline    cpl_test_error(CPL_ERROR_ILLEGAL_INPUT);\newline\newline    cpl_imagelist_delete(img_list);\newline\newline    /* empty image list, nominal_pos is ok and ifu_id is mixed*/\newline    img_list = cpl_imagelist_new();\newline\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, nominal_pos,\newline                                              ifu_id_mixed);\newline    cpl_test_error(CPL_ERROR_ILLEGAL_INPUT);\newline    cpl_imagelist_delete(img_list);\newline\newline    /* empty image list, nominal_pos and ifu_id is zero */\newline    img_list = cpl_imagelist_new();\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, nominal_pos,\newline                                              ifu_id_zero);\newline    cpl_test_error(CPL_ERROR_ILLEGAL_INPUT);\newline\newline    /* ----- test with correct values ----- */\newline\newline    /* non-empty image list, nominal_pos is ok and ifu_id is zero*/\newline\newline    for (j = 0; j &lt KMOS_NR_DETECTORS * KMOS_IFUS_PER_DETECTOR; j++) {\newline        img = cpl_image_new(KMOS_SLITLET_X, KMOS_SLITLET_Y, CPL_TYPE_FLOAT);\newline        img_data = cpl_image_get_data_float(img);\newline        for (i = 0; i &lt KMOS_SLITLET_X * KMOS_SLITLET_Y; i++) {\newline            img_data[i] = 66.0;\newline        }\newline        cpl_imagelist_set(img_list, img, j);\newline    }\newline\newline    ret_ptr = kmclipm_priv_create_patrol_view(img_list, nominal_pos,\newline                                              ifu_id_zero);\newline    cpl_test_nonnull(ret_ptr);\newline\newline    cpl_image_delete(ret_ptr); ret_ptr = NULL;\newline    cpl_imagelist_delete(img_list); img_list = NULL;\newline\newline    cpl_test_error(CPL_ERROR_NONE);\newline}\newline",\newline@brief Routine to test kmclipm_priv_create_patrol_view()\newline \newline,1228513,maxsat.c,void del_bool_var_array(Z3_ast * arr) \newline{\newline    free(arr);\newline}\newline,\newline\\brief Delete array of boolean variables.\newline \newline,4578795,fintegrate.c,"void NormConstT(double *t, int n, void *param)\newline{\newline  int ii;\newline  int dim=2;\newline  double *mu=doubleArray(dim);\newline  double **Sigma=doubleMatrix(dim,dim);\newline  double *W1,*W1p,*W2,*W2p;\newline  double X, Y, rho;\newline  double dtemp, inp, pfact;\newline  int imposs;\newline\newline  W1 = doubleArray(n);\newline  W1p = doubleArray(n);\newline  W2 = doubleArray(n);\newline  W2p = doubleArray(n);\newline\newline  Param *pp=(Param *)param;\newline  mu[0]= pp-&gtcaseP.mu[0];\newline  mu[1]= pp-&gtcaseP.mu[1];\newline  Sigma[0][0]=pp-&gtsetP-&gtSigma[0][0];\newline  Sigma[1][1]=pp-&gtsetP-&gtSigma[1][1];\newline  Sigma[0][1]=pp-&gtsetP-&gtSigma[0][1];\newline  Sigma[1][0]=pp-&gtsetP-&gtSigma[1][0];\newline  rho=Sigma[0][1]/sqrt(Sigma[0][0]*Sigma[1][1]);\newline  //Rprintf(&quotTESTING: %4g %4g %4g %4g&quot, pp-&gtcaseP.mu[0], pp-&gtcaseP.mu[1], pp-&gtsetP-&gtSigma[0][0],pp-&gtsetP-&gtSigma[0][1]);\newline  X=pp-&gtcaseP.X;\newline  Y=pp-&gtcaseP.Y;\newline  imposs=0;\newline\newline  dtemp=1/(2*M_PI*sqrt(Sigma[0][0]*Sigma[1][1]*(1-rho*rho)));\newline\newline  for (ii=0; ii&ltn; ii++) {\newline    imposs=0; inp=t[ii];\newline    W1[ii]=getW1starFromT(t[ii],pp,&ampimposs);\newline    if (!imposs) W2[ii]=getW2starFromT(t[ii],pp,&ampimposs);\newline    if (imposs==1) t[ii]=0;\newline    else {\newline        W1p[ii]=getW1starPrimeFromT(t[ii],pp);\newline        W2p[ii]=getW2starPrimeFromT(t[ii],pp);\newline        pfact=sqrt(W1p[ii]*W1p[ii]+W2p[ii]*W2p[ii]);\newline        t[ii]=exp(-1/(2*(1-rho*rho))*\newline              ((W1[ii]-mu[0])*(W1[ii]-mu[0])/Sigma[0][0]+\newline               (W2[ii]-mu[1])*(W2[ii]-mu[1])/Sigma[1][1]-\newline                2*rho*(W1[ii]-mu[0])*(W2[ii]-mu[1])\newline              /sqrt(Sigma[0][0]*Sigma[1][1])))*dtemp*pfact;\newline  //if (pp-&gtsetP-&gtweirdness)\newline   //   Rprintf(&quotNormc... %d %d %5g -&gt %5g %5g =&gt %5g with %5g imposs %d\\n&quot, ii, n, inp, W1[ii], W2[ii],t[ii],pfact,imposs);\newline      //char ch;\newline      //scanf(&quot %c&quot, &ampch );\newline    }\newline  }\newline  Free(W1);\newline  Free(W1p);\newline  Free(W2);\newline  Free(W2p);\newline  Free(mu);\newline  FreeMatrix(Sigma,dim);\newline}\newline","\newline Bivariate normal distribution, with parameterization\newline see: http://mathworld.wolfram.com/BivariateNormalDistribution.html\newline see for param: http://www.math.uconn.edu/~binns/reviewII210.pdf\newline \newline",816807,giza-cpgplot.c,"void cpgmtxt(const char *side, float disp, float coord, \\\newline float fjust, const char *text)\newline{\newline  giza_annotate_float(side, disp, coord, fjust, text);\newline}\newline",\newline cpgmtxt -- write text at position relative to viewport\newline Status: IMPLEMENTED\newline \newline,208312,brlapi_server.c,"int api_flush(BrailleDisplay *brl) {\newline  Connection *c;\newline  static Connection *displayed_last;\newline  int ok = 1;\newline  int drain = 0;\newline  int update = 0;\newline\newline  lockMutex(&ampapiConnectionsMutex);\newline  lockMutex(&ampapiRawMutex);\newline  if (suspendConnection) {\newline    unlockMutex(&ampapiRawMutex);\newline    goto out;\newline  }\newline  setCurrentRootTty();\newline  c = whoFillsTty(&ampttys);\newline  if (!offline &amp&amp c) {\newline    lockMutex(&ampc-&gtbrailleWindowMutex);\newline    lockMutex(&ampapiDriverMutex);\newline    if (!driverConstructed) {\newline      if (!resumeDriver(brl)) {\newline	unlockMutex(&ampapiDriverMutex);\newline	unlockMutex(&ampc-&gtbrailleWindowMutex);\newline        unlockMutex(&ampapiRawMutex);\newline	goto out;\newline      }\newline    }\newline\newline    if (c-&gtbrailleWindow.cursor) {\newline      unsigned char newCursorOverlay = getCursorOverlay(brl);\newline\newline      if (newCursorOverlay != cursorOverlay) {\newline        cursorOverlay = newCursorOverlay;\newline        update = 1;\newline      }\newline    }\newline\newline    if (c != displayed_last || c-&gtbrlbufstate==TODISPLAY || update) {\newline      unsigned char *oldbuf = disp-&gtbuffer, buf[displaySize];\newline      disp-&gtbuffer = buf;\newline      getDots(&ampc-&gtbrailleWindow, buf);\newline      brl-&gtcursor = c-&gtbrailleWindow.cursor-1;\newline      ok = trueBraille-&gtwriteWindow(brl, c-&gtbrailleWindow.text);\newline      drain = 1;\newline      disp-&gtbuffer = oldbuf;\newline      displayed_last = c;\newline    }\newline    unlockMutex(&ampapiDriverMutex);\newline    unlockMutex(&ampc-&gtbrailleWindowMutex);\newline  } else {\newline    /* no RAW, no connection filling tty, hence suspend if needed */\newline    lockMutex(&ampapiDriverMutex);\newline    if (!coreActive) {\newline      if (driverConstructed) {\newline	/* Put back core output before suspending */\newline	unsigned char *oldbuf = disp-&gtbuffer;\newline	disp-&gtbuffer = coreWindowDots;\newline	brl-&gtcursor = coreWindowCursor;\newline	lockMutex(&ampapiDriverMutex);\newline	trueBraille-&gtwriteWindow(brl, coreWindowText);\newline	unlockMutex(&ampapiDriverMutex);\newline	disp-&gtbuffer = oldbuf;\newline	suspendDriver(brl);\newline      }\newline      unlockMutex(&ampapiDriverMutex);\newline      unlockMutex(&ampapiRawMutex);\newline      goto out;\newline    }\newline    unlockMutex(&ampapiDriverMutex);\newline  }\newline  if (!ok) {\newline    unlockMutex(&ampapiRawMutex);\newline    goto out;\newline  }\newline  if (drain)\newline    drainBrailleOutput(brl, 0);\newline  unlockMutex(&ampapiRawMutex);\newlineout:\newline  unlockMutex(&ampapiConnectionsMutex);\newline  return ok;\newline}\newline",Function : api_flush\newline Flush writes to the braille device.\newline \newline,4333273,camera_v4l2.c,"int v4l2_get_control (int fd, int id, int *value)\newline{\newline    struct v4l2_control control;\newline    CLEAR(control);\newline    \newline    control.id = id;\newline    \newline    if (-1 == v4l2_xioctl (fd, VIDIOC_G_CTRL, &ampcontrol)) {\newline        return 0;\newline    }\newline    \newline    *value = control.value;\newline    return 1;\newline}\newline",gets the value of a specific camera control if available \newline,101529,string.c,bool i3string_is_markup(i3String *str) {\newline    return str-&gtpango_markup;\newline}\newline,\newline Whether the given i3String is in Pango markup.\newline \newline,2144187,util.c,"char *oidc_util_escape_string(const request_rec *r, const char *str) {\newline	CURL *curl = curl_easy_init();\newline	if (curl == NULL) {\newline		oidc_error(r, &quotcurl_easy_init() error&quot);\newline		return NULL;\newline	}\newline	char *result = curl_easy_escape(curl, str, 0);\newline	if (result == NULL) {\newline		oidc_error(r, &quotcurl_easy_escape() error&quot);\newline		return NULL;\newline	}\newline	char *rv = apr_pstrdup(r-&gtpool, result);\newline	curl_free(result);\newline	curl_easy_cleanup(curl);\newline	return rv;\newline}\newline",\newline escape a string\newline \newline,4515296,wap-appl.c,"static void indicate_push_connection(WAPEvent *e)\newline{\newline    WAPEvent *ppg_event;\newline    List *push_headers, *application_headers, *bearer_headers;\newline\newline    push_headers = http_header_duplicate(e-&gtu.S_Connect_Ind.client_headers);\newline    application_headers = http_create_empty_headers();\newline    bearer_headers = http_create_empty_headers();\newline    \newline    ppg_event = wap_event_create(Pom_Connect_Ind);\newline    ppg_event-&gtu.Pom_Connect_Ind.addr_tuple = \newline        wap_addr_tuple_duplicate(e-&gtu.S_Connect_Ind.addr_tuple);\newline    ppg_event-&gtu.Pom_Connect_Ind.requested_capabilities = \newline        wsp_cap_duplicate_list(e-&gtu.S_Connect_Ind.requested_capabilities);\newline\newline    check_application_headers(&amppush_headers, &ampapplication_headers);\newline    ppg_event-&gtu.Pom_Connect_Ind.accept_application = application_headers;\newline\newline    decode_bearer_indication(&amppush_headers, &ampbearer_headers);\newline\newline    if (gwlist_len(bearer_headers) == 0) {\newline        http_destroy_headers(bearer_headers);\newline        ppg_event-&gtu.Pom_Connect_Ind.bearer_indication = NULL;\newline    } else\newline        ppg_event-&gtu.Pom_Connect_Ind.bearer_indication = bearer_headers;\newline\newline    ppg_event-&gtu.Pom_Connect_Ind.push_headers = push_headers;\newline    ppg_event-&gtu.Pom_Connect_Ind.session_id = e-&gtu.S_Connect_Ind.session_id;\newline    debug(&quotwap.appl&quot, 0, &quotAPPL: making OTA connection indication to PPG&quot);\newline\newline    wap_push_ppg_dispatch_event(ppg_event);\newline}\newline","\newline Find headers Accept-Application and Bearer-Indication amongst push headers,\newline decode them and add them to their proper field. \newline \newline",3761960,libmac.c,"int macaddrstruct_to_string(const ipv6calc_macaddr *macaddrp, char *resultstring, const size_t resultstring_length, const uint32_t formatoptions) {\newline	char tempstring[NI_MAXHOST];\newline\newline	/* address */\newline	snprintf(tempstring, sizeof(tempstring), &quot%02x:%02x:%02x:%02x:%02x:%02x&quot, (unsigned int) macaddrp-&gtaddr[0], (unsigned int) macaddrp-&gtaddr[1], (unsigned int) macaddrp-&gtaddr[2], (unsigned int) macaddrp-&gtaddr[3], (unsigned int) macaddrp-&gtaddr[4], (unsigned int) macaddrp-&gtaddr[5]);\newline\newline	if ( (formatoptions &amp FORMATOPTION_machinereadable) != 0 ) {\newline		snprintf(resultstring, resultstring_length, &quotMAC=%s&quot, tempstring);\newline	} else {\newline		snprintf(resultstring, resultstring_length, &quot%s&quot, tempstring);\newline	};\newline\newline	return(0);\newline};\newline","\newline stores the macaddr structure in a string\newline \newline in: macaddr = MAC address structure\newline out: resultstring = MAC address string\newline ret: ==0: ok, !=0: error\newline \newline",4905495,sonogram~.c,"static void sonogram_average(t_sonogram *x, t_floatarg fnbblocks)\newline{\newline    t_int samplestart, sampleend, fi, si, ssi;\newline    t_float fraverage, fiaverage;\newline\newline    if (fnbblocks &lt 1)\newline    {\newline        post( &quotsonogram~ : error : bad average factor&quot );\newline        return;\newline    }\newline    samplestart=(x-&gtx_modstart*(x-&gtx_size-1))/100;\newline    sampleend=(x-&gtx_modend*(x-&gtx_size-1))/100;\newline\newline    fraverage=fiaverage=0.0;\newline    for ( fi=0; fi&ltx-&gtx_blocksize; fi++ )\newline    {\newline        for ( si=samplestart; si&lt=sampleend-fnbblocks; si+=fnbblocks )\newline        {\newline            fraverage=fiaverage=0.0;\newline            for ( ssi=0; ssi&ltfnbblocks; ssi++ )\newline            {\newline                fraverage += *(x-&gtx_rdata+((int)(si+ssi)*x-&gtx_blocksize)+fi);\newline                fiaverage += *(x-&gtx_idata+((int)(si+ssi)*x-&gtx_blocksize)+fi);\newline            }\newline            fraverage /= fnbblocks;\newline            fiaverage /= fnbblocks;\newline            for ( ssi=0; ssi&ltfnbblocks; ssi++ )\newline            {\newline                *(x-&gtx_rdata+((int)(si+ssi)*x-&gtx_blocksize)+fi)=fraverage;\newline                *(x-&gtx_idata+((int)(si+ssi)*x-&gtx_blocksize)+fi)=fiaverage;\newline            }\newline        }\newline    }\newline    sonogram_update_part(x, x-&gtx_glist, samplestart, sampleend, 0, 1, 1);\newline}\newline",average blocks according to a factor \newline,19462,tridpars.cpp,"void TransliteratorIDParser::IDtoSTV(const UnicodeString&amp id,\newline                                     UnicodeString&amp source,\newline                                     UnicodeString&amp target,\newline                                     UnicodeString&amp variant,\newline                                     UBool&amp isSourcePresent) {\newline    source.setTo(ANY, 3);\newline    target.truncate(0);\newline    variant.truncate(0);\newline\newline    int32_t sep = id.indexOf(TARGET_SEP);\newline    int32_t var = id.indexOf(VARIANT_SEP);\newline    if (var &lt 0) {\newline        var = id.length();\newline    }\newline    isSourcePresent = FALSE;\newline\newline    if (sep &lt 0) {\newline        // Form: T/V or T (or /V)\newline        id.extractBetween(0, var, target);\newline        id.extractBetween(var, id.length(), variant);\newline    } else if (sep &lt var) {\newline        // Form: S-T/V or S-T (or -T/V or -T)\newline        if (sep &gt 0) {\newline            id.extractBetween(0, sep, source);\newline            isSourcePresent = TRUE;\newline        }\newline        id.extractBetween(++sep, var, target);\newline        id.extractBetween(var, id.length(), variant);\newline    } else {\newline        // Form: (S/V-T or /V-T)\newline        if (var &gt 0) {\newline            id.extractBetween(0, var, source);\newline            isSourcePresent = TRUE;\newline        }\newline        id.extractBetween(var, sep++, variant);\newline        id.extractBetween(sep, id.length(), target);\newline    }\newline\newline    if (variant.length() &gt 0) {\newline        variant.remove(0, 1);\newline    }\newline}\newline","\newline Parse an ID into pieces. Take IDs of the form T, T/V, S-T,\newline S-T/V, or S/V-T. If the source is missing, return a source of\newline ANY.\newline @param id the id string, in any of several forms\newline @return an array of 4 strings: source, target, variant, and\newline isSourcePresent. If the source is not present, ANY will be\newline given as the source, and isSourcePresent will be NULL. Otherwise\newline isSourcePresent will be non-NULL. The target may be empty if the\newline id is not well-formed. The variant may be empty.\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1786694,cmodel.c,"int CM_PointLeafnum_r (vec3_t p, int num)\newline{\newline	float		d;\newline	cnode_t		*node;\newline	cplane_t	*plane;\newline\newline	while (num &gt= 0)\newline	{\newline		node = map_nodes + num;\newline		plane = node-&gtplane;\newline\newline		if (plane-&gttype &lt 3)\newline			d = p[plane-&gttype] - plane-&gtdist;\newline		else\newline			d = DotProduct (plane-&gtnormal, p) - plane-&gtdist;\newline		if (d &lt 0)\newline			num = node-&gtchildren[1];\newline		else\newline			num = node-&gtchildren[0];\newline	}\newline\newline	c_pointcontents++;		// optimize counter\newline\newline	return -1 - num;\newline}\newline",\newline==================\newlineCM_PointLeafnum_r\newline==================\newline \newline,2630351,sefcontext_compile.c,"static int write_binary_file(struct saved_data *data, int fd)\newline{\newline	struct spec *specs = data-&gtspec_arr;\newline	FILE *bin_file;\newline	size_t len;\newline	uint32_t magic = SELINUX_MAGIC_COMPILED_FCONTEXT;\newline	uint32_t section_len;\newline	uint32_t i;\newline	int rc;\newline\newline	bin_file = fdopen(fd, &quotw&quot);\newline	if (!bin_file) {\newline		perror(&quotfopen output_file&quot);\newline		exit(EXIT_FAILURE);\newline	}\newline\newline	/* write some magic number */\newline	len = fwrite(&ampmagic, sizeof(uint32_t), 1, bin_file);\newline	if (len != 1)\newline		goto err;\newline\newline	/* write the version */\newline	section_len = SELINUX_COMPILED_FCONTEXT_MAX_VERS;\newline	len = fwrite(&ampsection_len, sizeof(uint32_t), 1, bin_file);\newline	if (len != 1)\newline		goto err;\newline\newline	/* write the pcre version */\newline	section_len = strlen(pcre_version());\newline	len = fwrite(&ampsection_len, sizeof(uint32_t), 1, bin_file);\newline	if (len != 1)\newline		goto err;\newline	len = fwrite(pcre_version(), sizeof(char), section_len, bin_file);\newline	if (len != section_len)\newline		goto err;\newline\newline	/* write the number of stems coming */\newline	section_len = data-&gtnum_stems;\newline	len = fwrite(&ampsection_len, sizeof(uint32_t), 1, bin_file);\newline	if (len != 1)\newline		goto err;\newline\newline	for (i = 0; i &lt section_len; i++) {\newline		char *stem = data-&gtstem_arr[i].buf;\newline		uint32_t stem_len = data-&gtstem_arr[i].len;\newline\newline		/* write the strlen (aka no nul) */\newline		len = fwrite(&ampstem_len, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* include the nul in the file */\newline		stem_len += 1;\newline		len = fwrite(stem, sizeof(char), stem_len, bin_file);\newline		if (len != stem_len)\newline			goto err;\newline	}\newline\newline	/* write the number of regexes coming */\newline	section_len = data-&gtnspec;\newline	len = fwrite(&ampsection_len, sizeof(uint32_t), 1, bin_file);\newline	if (len != 1)\newline		goto err;\newline\newline	for (i = 0; i &lt section_len; i++) {\newline		char *context = specs[i].lr.ctx_raw;\newline		char *regex_str = specs[i].regex_str;\newline		mode_t mode = specs[i].mode;\newline		size_t prefix_len = specs[i].prefix_len;\newline		int32_t stem_id = specs[i].stem_id;\newline		pcre *re = specs[i].regex;\newline		pcre_extra *sd = get_pcre_extra(&ampspecs[i]);\newline		uint32_t to_write;\newline		size_t size;\newline\newline		/* length of the context string (including nul) */\newline		to_write = strlen(context) + 1;\newline		len = fwrite(&ampto_write, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* original context strin (including nul) */\newline		len = fwrite(context, sizeof(char), to_write, bin_file);\newline		if (len != to_write)\newline			goto err;\newline\newline		/* length of the original regex string (including nul) */\newline		to_write = strlen(regex_str) + 1;\newline		len = fwrite(&ampto_write, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* original regex string */\newline		len = fwrite(regex_str, sizeof(char), to_write, bin_file);\newline		if (len != to_write)\newline			goto err;\newline\newline		/* binary F_MODE bits */\newline		to_write = mode;\newline		len = fwrite(&ampto_write, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* stem for this regex (could be -1) */\newline		len = fwrite(&ampstem_id, sizeof(stem_id), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* does this spec have a metaChar? */\newline		to_write = specs[i].hasMetaChars;\newline		len = fwrite(&ampto_write, sizeof(to_write), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* For SELINUX_COMPILED_FCONTEXT_PREFIX_LEN */\newline		to_write = prefix_len;\newline		len = fwrite(&ampto_write, sizeof(to_write), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* determine the size of the pcre data in bytes */\newline		rc = pcre_fullinfo(re, NULL, PCRE_INFO_SIZE, &ampsize);\newline		if (rc &lt 0)\newline			goto err;\newline\newline		/* write the number of bytes in the pcre data */\newline		to_write = size;\newline		len = fwrite(&ampto_write, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* write the actual pcre data as a char array */\newline		len = fwrite(re, 1, to_write, bin_file);\newline		if (len != to_write)\newline			goto err;\newline\newline		/* determine the size of the pcre study info */\newline		rc = pcre_fullinfo(re, sd, PCRE_INFO_STUDYSIZE, &ampsize);\newline		if (rc &lt 0)\newline			goto err;\newline\newline		/* write the number of bytes in the pcre study data */\newline		to_write = size;\newline		len = fwrite(&ampto_write, sizeof(uint32_t), 1, bin_file);\newline		if (len != 1)\newline			goto err;\newline\newline		/* write the actual pcre study data as a char array */\newline		len = fwrite(sd-&gtstudy_data, 1, to_write, bin_file);\newline		if (len != to_write)\newline			goto err;\newline	}\newline\newline	rc = 0;\newlineout:\newline	fclose(bin_file);\newline	return rc;\newlineerr:\newline	rc = -1;\newline	goto out;\newline}\newline",\newline File Format\newline \newline u32 - magic number\newline u32 - version\newline u32 - length of pcre version EXCLUDING nul\newline char - pcre version string EXCLUDING nul\newline u32 - number of stems\newline Stems\newline u32 - length of stem EXCLUDING nul\newline char - stem char array INCLUDING nul\newline u32 - number of regexs\newline Regexes\newline u32 - length of upcoming context INCLUDING nul\newline char - char array of the raw context\newline u32 - length of the upcoming regex_str\newline char - char array of the original regex string including the stem.\newline u32 - mode bits for &gt= SELINUX_COMPILED_FCONTEXT_MODE\newline mode_t for &lt= SELINUX_COMPILED_FCONTEXT_PCRE_VERS\newline s32 - stemid associated with the regex\newline u32 - spec has meta characters\newline u32 - The specs prefix_len if &gt= SELINUX_COMPILED_FCONTEXT_PREFIX_LEN\newline u32 - data length of the pcre regex\newline char - a bufer holding the raw pcre regex info\newline u32 - data length of the pcre regex study daya\newline char - a buffer holding the raw pcre regex study data\newline \newline,2274732,stream.c,"void\newlinestream_fifo_push (struct stream_fifo *fifo, struct stream *s)\newline{\newline  if (fifo-&gttail)\newline    fifo-&gttail-&gtnext = s;\newline  else\newline    fifo-&gthead = s;\newline     \newline  fifo-&gttail = s;\newline\newline  fifo-&gtcount++;\newline}\newline",Add new stream to fifo. \newline,,,,on,,,,,on,,on,on,on,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,removes a host or service acknowledgement,Flush writes to the braille device.,gets the value of a specific camera control if available,{},escape a string,Find headers Accept-Application,stores the macaddr structure in a string,average blocks according to a factor,{},Load an image from the named file.,{},{},{},Add new stream to fifo.,Filnalizes the (WB)XML document,"Many versions of HDF5 have a bug in the optimized compound
datatype",Calculate the base 2 logarithm of a given integer.,Routine to test kmclipm_priv_create_patrol_view(),Delete array of boolean variables.,{},write text at position relative to viewport,x,
3M0556243SK17QBJSMBA4IA2NTJFN4,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:19 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:19 PDT 2019,,,3RGU30DZTA8DHU98PDSWVK9JT58MJG,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:45 PDT 2019,Fri Apr 26 13:06:43 PDT 2019,Sun Apr 28 13:06:43 PDT 2019,,,,1138,100% (62/62),100% (62/62),0% (0/0),3466629,grid.c,"SEXP L_setDLelt(SEXP value)\newline{\newline    /* Get the current device \newline     */\newline    pGEDevDesc dd = getDevice();\newline    SEXP dl;\newline    PROTECT(dl = gridStateElement(dd, GSS_DL));\newline    SET_VECTOR_ELT(dl, INTEGER(gridStateElement(dd, GSS_DLINDEX))[0], value);\newline    UNPROTECT(1);\newline    return R_NilValue;\newline}\newline",Add an element to the display list at the current location\newline Location is maintained in R code\newline \newline,2561249,xmlrpc.c,XMLRPC_CASE XMLRPC_SetDefaultIdCase(XMLRPC_CASE id_case) {\newline   XMLRPC_OPTIONS options = XMLRPC_GetDefaultOptions();\newline   options-&gtid_case = id_case;\newline   return options-&gtid_case;\newline}\newline,"f VALUE/XMLRPC_SetDefaultIdCase\newline NAME\newline XMLRPC_SetDefaultIdCase\newline SYNOPSIS\newline XMLRPC_CASE XMLRPC_SetDefaultIdCase(XMLRPC_CASE id_case)\newline FUNCTION\newline Sets default case options used by XMLRPC_VALUE funcs\newline INPUTS\newline id_case case options as enumerated by XMLRPC_CASE\newline RESULT\newline XMLRPC_CASE -- newly set option\newline BUGS\newline Nasty and gross. Should be server specific, but that requires changing all\newline the XMLRPC_VALUE api&#039s.\newline SEE ALSO\newline XMLRPC_GetDefaultIdCase ()\newline SOURCE\newline \newline",5853323,cf_ip6_proto_p.c,CAMLprim value cf_ip6_proto_domain(value unit)\newline{\newline    CAMLparam0();\newline    CAMLreturn(cf_ip6_proto_domain_val);\newline}\newline,---\newlineexternal domain_: unit -&gt &#039a Cf_socket.domain_t = &quotcf_ip6_proto_domain&quot\newline--- \newline,6427193,pi.cpp,"static double pi_device()\newline{\newline    array x = randu(samples,f32), y = randu(samples,f32);\newline    return 4.0 * sum&ltfloat&gt(sqrt(x*x + y*y) &lt 1) / samples;\newline}\newline","Self-contained code to run host and device estimates of PI. Note that\newlineeach is generating its own random values, so the estimates of PI\newlinewill differ. \newline",5940648,prefs_gui.c,"static void cb_serial_port_menu(GtkWidget *widget,\newline                                gpointer   data)\newline{\newline   if (!widget)\newline      return;\newline   if (!(GTK_CHECK_MENU_ITEM(widget))-&gtactive) {\newline      return;\newline   }\newline\newline   const char *port_str = port_choices[GPOINTER_TO_INT(data)]; \newline   gtk_entry_set_text(GTK_ENTRY(port_entry), port_str);\newline   if (! strcmp(port_str, &quotusb:&quot)) {\newline      gtk_widget_set_sensitive(rate_menu, FALSE);\newline   } else {\newline      gtk_widget_set_sensitive(rate_menu, TRUE);\newline   }\newline\newline\newline   return;\newline}\newline",Sync Port menu code \newline,3703271,ksysguardd.c,"int addClient( int client )\newline{\newline  int i;\newline  FILE* out;\newline\newline  for ( i = 0; i &lt MAX_CLIENTS; i++ ) {\newline    if ( ClientList[ i ].socket == -1 ) {\newline      ClientList[ i ].socket = client;\newline      if ( ( out = fdopen( client, &quotw+&quot ) ) == NULL ) {\newline        log_error( &quotfdopen()&quot );\newline        return -1;\newline      }\newline      /* We use unbuffered IO */\newline      fcntl( fileno( out ), F_SETFL, O_NDELAY );\newline      ClientList[ i ].out = out;\newline      printWelcome( out );\newline      fprintf( out, &quotksysguardd&gt &quot );\newline      fflush( out );\newline\newline      return 0;\newline    }\newline  }\newline\newline  return -1;\newline}\newline",\newlineaddClient adds a new client to the ClientList.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,3730150,expire-tiles.cpp,"void expire_tiles::from_nodes_poly(const nodelist_t &ampnodes, osmid_t osm_id)\newline{\newline    if (maxzoom &lt 0 || nodes.empty())\newline        return;\newline\newline    double min_lon = nodes[0].lon;\newline    double min_lat = nodes[0].lat;\newline    double max_lon = nodes[0].lon;\newline    double max_lat = nodes[0].lat;\newline\newline    for (size_t i = 1; i &lt nodes.size(); ++i) {\newline        if (nodes[i].lon &lt min_lon) min_lon = nodes[i].lon;\newline        if (nodes[i].lat &lt min_lat) min_lat = nodes[i].lat;\newline        if (nodes[i].lon &gt max_lon) max_lon = nodes[i].lon;\newline        if (nodes[i].lat &gt max_lat) max_lat = nodes[i].lat;\newline    }\newline\newline    if (from_bbox(min_lon, min_lat, max_lon, max_lat)) {\newline        /* Bounding box too big - just expire tiles on the line */\newline        fprintf(stderr, &quot\\rLarge polygon (%.0f x %.0f metres, OSM ID %&quot PRIdOSMID &quot) - only expiring perimeter\\n&quot, max_lon - min_lon, max_lat - min_lat, osm_id);\newline        from_nodes_line(nodes);\newline    }\newline}\newline",\newline Calculate a bounding box from a list of nodes and expire all tiles within it\newline \newline,6306051,stoken.c,"static int request_stoken_pin(struct openconnect_info *vpninfo)\newline{\newline	struct oc_auth_form form;\newline	struct oc_form_opt opts[1], *opt = opts;\newline	int ret = 0;\newline\newline	if (!vpninfo-&gtstoken_concat_pin &amp&amp !stoken_pin_required(vpninfo-&gtstoken_ctx))\newline		return 0;\newline\newline	memset(&ampform, 0, sizeof(form));\newline	memset(&ampopts, 0, sizeof(opts));\newline\newline	form.opts = opts;\newline	form.message = _(&quotEnter software token PIN.&quot);\newline\newline	opt-&gttype = OC_FORM_OPT_PASSWORD;\newline	opt-&gtname = (char *)&quotpassword&quot;\newline	opt-&gtlabel = _(&quotPIN:&quot);\newline	opt-&gtflags = OC_FORM_OPT_NUMERIC;\newline\newline	while (1) {\newline		char *pin;\newline\newline		nuke_opt_values(opts);\newline\newline		/* &lt 0 for error; 1 if cancelled */\newline		ret = process_auth_form(vpninfo, &ampform);\newline		if (ret)\newline			break;\newline\newline		pin = opt-&gt_value;\newline		if (!pin || !strlen(pin)) {\newline			/* in some cases there really is no PIN */\newline			if (vpninfo-&gtstoken_concat_pin)\newline				return 0;\newline\newline			vpn_progress(vpninfo, PRG_INFO,\newline				     _(&quotAll fields are required; try again.\\n&quot));\newline			continue;\newline		}\newline\newline		if (!vpninfo-&gtstoken_concat_pin &amp&amp\newline		    stoken_check_pin(vpninfo-&gtstoken_ctx, pin) != 0) {\newline			vpn_progress(vpninfo, PRG_INFO,\newline				     _(&quotInvalid PIN format; try again.\\n&quot));\newline			continue;\newline		}\newline\newline		free(vpninfo-&gtstoken_pin);\newline		vpninfo-&gtstoken_pin = strdup(pin);\newline		if (!vpninfo-&gtstoken_pin)\newline			ret = -ENOMEM;\newline		break;\newline	}\newline\newline	nuke_opt_values(opts);\newline	return ret;\newline}\newline","\newline Return value:\newline &lt 0, on error\newline = 0, on success\newline = 1, if the user cancelled the form submission\newline \newline",3832800,function.c,"static int function_setxattr(const char *path, const char *name,\newline			    const char *value, size_t size, int flags){\newline    DPRINTF(5, &quot(%s, name=%s, value=%s, size=%zd, flags=%o)\\n&quot, path,\newline	name, value, size, flags);\newline    if (smbitem_what_is(path) != SMBITEM_SMB_SHARE_ITEM) return -ENOTSUP;\newline    if (!function_check_xattr_name(name)) return -ENOTSUP;\newline    if (samba_setxattr(path, name, value, size, flags) != 0) return -errno;\newline    return 0;\newline}\newline","libfuse does not support lsetxattr() and fsetxattr(), but samba does \newline",5051506,bi_gmp.c,"unsigned char *bi_2_nbin( int *length, const bi_ptr i) {\newline	unsigned char *buffer = (unsigned char *)bi_alloc( bi_nbin_size( i));\newline\newline	if( buffer == NULL) return NULL;\newline	mpz_export(buffer, length, 1, 1, 1, 0, i);\newline	return buffer;\newline}\newline",return a BYTE - in network byte order - and update the length &ltlength&gt \newline,1193540,settings.c,"gchar *settings_get_string(enum settings_item item)\newline{\newline	START_FUNC\newline	gchar *ret=NULL;\newline	GVariant *val=settings_value_get(item);\newline	if (!val) {\newline		ret=g_strdup(settings_defaults[item].default_value.vstring);\newline	} else {\newline		ret=g_strdup(g_variant_get_string(val, NULL));\newline		g_variant_unref(val);\newline	}\newline	END_FUNC\newline	return ret;\newline}\newline",get a string from gsettings \newline,5965850,pymadfile.c,"static PyObject *py_madfile_bitrate(PyObject *self, PyObject *args) {\newline  return PyInt_FromLong(PYMAD_FRAME(self).header.bitrate);\newline}\newline",return the stream bitrate \newline,1576414,trace.c,DLLEXPORT void trace_destroy_packet(libtrace_packet_t *packet) {\newline	if (packet-&gtbuf_control == TRACE_CTRL_PACKET &amp&amp packet-&gtbuffer) {\newline		free(packet-&gtbuffer);\newline	}\newline	packet-&gtbuf_control=(buf_control_t)&#039\\0&#039; \newline				/* A &quotbad&quot value to force an assert\newline				 * if this packet is ever reused\newline				 */\newline	free(packet);\newline}	\newline,Destroy a packet object\newline \newline,3115714,libnetfilter_log.c,"int nflog_snprintf_xml(char *buf, size_t rem, struct nflog_data *tb, int flags)\newline{\newline	struct nfulnl_msg_packet_hdr *ph;\newline	struct nfulnl_msg_packet_hw *hwph;\newline	u_int32_t mark, ifi;\newline	int size, offset = 0, len = 0, ret;\newline	char *data;\newline\newline	size = snprintf(buf + offset, rem, &quot&ltlog&gt&quot);\newline	SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline	if (flags &amp NFLOG_XML_TIME) {\newline		time_t t;\newline		struct tm tm;\newline\newline		t = time(NULL);\newline		if (localtime_r(&ampt, &amptm) == NULL)\newline			return -1;\newline\newline		size = snprintf(buf + offset, rem, &quot&ltwhen&gt&quot);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem,\newline				&quot&lthour&gt%d&lt/hour&gt&quot, tm.tm_hour);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset,\newline				rem, &quot&ltmin&gt%02d&lt/min&gt&quot, tm.tm_min);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset,\newline				rem, &quot&ltsec&gt%02d&lt/sec&gt&quot, tm.tm_sec);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem, &quot&ltwday&gt%d&lt/wday&gt&quot,\newline				tm.tm_wday + 1);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem, &quot&ltday&gt%d&lt/day&gt&quot, tm.tm_mday);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem, &quot&ltmonth&gt%d&lt/month&gt&quot,\newline				tm.tm_mon + 1);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem, &quot&ltyear&gt%d&lt/year&gt&quot,\newline				1900 + tm.tm_year);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		size = snprintf(buf + offset, rem, &quot&lt/when&gt&quot);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	data = nflog_get_prefix(tb);\newline	if (data &amp&amp (flags &amp NFLOG_XML_PREFIX)) {\newline		size = snprintf(buf + offset, rem, &quot&ltprefix&gt%s&lt/prefix&gt&quot, data);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ph = nflog_get_msg_packet_hdr(tb);\newline	if (ph) {\newline		size = snprintf(buf + offset, rem, &quot&lthook&gt%u&lt/hook&gt&quot, ph-&gthook);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		hwph = nflog_get_packet_hw(tb);\newline		if (hwph &amp&amp (flags &amp NFLOG_XML_HW)) {\newline			int i, hlen = ntohs(hwph-&gthw_addrlen);\newline\newline			size = snprintf(buf + offset, rem, &quot&lthw&gt&ltproto&gt%04x&quot\newline							   &quot&lt/proto&gt&quot,\newline					ntohs(ph-&gthw_protocol));\newline			SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline			size = snprintf(buf + offset, rem, &quot&ltsrc&gt&quot);\newline			SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline			for (i=0; i&lthlen; i++) {\newline				size = snprintf(buf + offset, rem, &quot%02x&quot,\newline						hwph-&gthw_addr[i]);\newline				SNPRINTF_FAILURE(size, rem, offset, len);\newline			}\newline\newline			size = snprintf(buf + offset, rem, &quot&lt/src&gt&lt/hw&gt&quot);\newline			SNPRINTF_FAILURE(size, rem, offset, len);\newline		} else if (flags &amp NFLOG_XML_HW) {\newline			size = snprintf(buf + offset, rem, &quot&lthw&gt&ltproto&gt%04x&quot\newline						    &quot&lt/proto&gt&lt/hw&gt&quot,\newline				 ntohs(ph-&gthw_protocol));\newline			SNPRINTF_FAILURE(size, rem, offset, len);\newline		}\newline	}\newline\newline	mark = nflog_get_nfmark(tb);\newline	if (mark &amp&amp (flags &amp NFLOG_XML_MARK)) {\newline		size = snprintf(buf + offset, rem, &quot&ltmark&gt%u&lt/mark&gt&quot, mark);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ifi = nflog_get_indev(tb);\newline	if (ifi &amp&amp (flags &amp NFLOG_XML_DEV)) {\newline		size = snprintf(buf + offset, rem, &quot&ltindev&gt%u&lt/indev&gt&quot, ifi);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ifi = nflog_get_outdev(tb);\newline	if (ifi &amp&amp (flags &amp NFLOG_XML_DEV)) {\newline		size = snprintf(buf + offset, rem, &quot&ltoutdev&gt%u&lt/outdev&gt&quot, ifi);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ifi = nflog_get_physindev(tb);\newline	if (ifi &amp&amp (flags &amp NFLOG_XML_PHYSDEV)) {\newline		size = snprintf(buf + offset, rem,\newline				&quot&ltphysindev&gt%u&lt/physindev&gt&quot, ifi);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ifi = nflog_get_physoutdev(tb);\newline	if (ifi &amp&amp (flags &amp NFLOG_XML_PHYSDEV)) {\newline		size = snprintf(buf + offset, rem,\newline				&quot&ltphysoutdev&gt%u&lt/physoutdev&gt&quot, ifi);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	ret = nflog_get_payload(tb, &ampdata);\newline	if (ret &gt= 0 &amp&amp (flags &amp NFLOG_XML_PAYLOAD)) {\newline		int i;\newline\newline		size = snprintf(buf + offset, rem, &quot&ltpayload&gt&quot);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline		for (i=0; i&ltret; i++) {\newline			size = snprintf(buf + offset, rem, &quot%02x&quot,\newline					data[i] &amp 0xff);\newline			SNPRINTF_FAILURE(size, rem, offset, len);\newline		}\newline\newline		size = snprintf(buf + offset, rem, &quot&lt/payload&gt&quot);\newline		SNPRINTF_FAILURE(size, rem, offset, len);\newline	}\newline\newline	size = snprintf(buf + offset, rem, &quot&lt/log&gt&quot);\newline	SNPRINTF_FAILURE(size, rem, offset, len);\newline\newline	return len;\newline}\newline","\newline nflog_snprintf_xml - print the logged packet in XML format into a buffer\newline \\param buf The buffer that you want to use to print the logged packet\newline \\param rem The size of the buffer that you have passed\newline \\param tb Netlink packet data handle passed to callback function\newline \\param flags The flag that tell what to print into the buffer\newline \newline This function supports the following flags:\newline \newline - NFLOG_XML_PREFIX: include the string prefix\newline - NFLOG_XML_HW: include the hardware link layer address\newline - NFLOG_XML_MARK: include the packet mark\newline - NFLOG_XML_DEV: include the device information\newline - NFLOG_XML_PHYSDEV: include the physical device information\newline - NFLOG_XML_PAYLOAD: include the payload (in hexadecimal)\newline - NFLOG_XML_TIME: include the timestamp\newline - NFLOG_XML_ALL: include all the logging information (all flags set)\newline \newline You can combine this flags with an binary OR.\newline \newline \\return -1 in case of failure, otherwise the length of the string that\newline would have been printed into the buffer (in case that there is enough\newline room in it). See snprintf() return value for more information.\newline \newline",4188442,macjoy.c,"static void joy_read_device(io_object_t dev)    {\newline    CFMutableDictionaryRef props = 0;\newline\newline    /* Create a dictionary to read the device&#039s properties. */\newline    if(IORegistryEntryCreateCFProperties(dev, &ampprops, kCFAllocatorDefault,\newline                                         kNilOptions) == KERN_SUCCESS)  {\newline        CFTypeRef inf;\newline        SInt32 page, usage;\newline        void *ptr;\newline\newline        /* Grab the primary usage page of the device. */\newline        inf = CFDictionaryGetValue(props, CFSTR(kIOHIDPrimaryUsagePageKey));\newline\newline        if(!inf || !CFNumberGetValue((CFNumberRef)inf, kCFNumberSInt32Type,\newline                                     &amppage))    {\newline            goto out;\newline        }\newline\newline        /* Ignore devices that are not in the Generic Desktop page. */\newline        if(page != kHIDPage_GenericDesktop) {\newline            goto out;\newline        }\newline\newline        /* Grab the primary device usage. */\newline        inf = CFDictionaryGetValue(props, CFSTR(kIOHIDPrimaryUsageKey));\newline\newline        if(!inf || !CFNumberGetValue((CFNumberRef)inf, kCFNumberSInt32Type,\newline                                     &ampusage))   {\newline            goto out;\newline        }\newline\newline        /* Ignore devices that are not either a Game Pad or Joystick. */\newline        if(usage != kHIDUsage_GD_GamePad &amp&amp usage != kHIDUsage_GD_Joystick) {\newline            goto out;\newline        }\newline\newline        /* Allocate space for the new joystick structure. */\newline        ptr = realloc(joys, (joy_count + 1) * sizeof(joydata_t));\newline\newline        if(ptr == NULL) {\newline            goto out;\newline        }\newline\newline        joys = (joydata_t *)ptr;\newline        memset(joys + joy_count, 0, sizeof(joydata_t));\newline\newline        /* Grab and store the name of the device. */\newline        inf = CFDictionaryGetValue(props, CFSTR(kIOHIDProductKey));\newline\newline        if(!CFStringGetCString((CFStringRef)inf, joys[joy_count].name, 256,\newline                               kCFStringEncodingUTF8))  {\newline            goto out;\newline        }\newline\newline        /* Create the device interface needed to interact with the device. */\newline        if(!joy_create_interface(dev, joys + joy_count))    {\newline            goto out;\newline        }\newline\newline        /* Find all elements of the device. */\newline        joy_find_elements(props, joys + joy_count);\newline\newline        qsort(joys[joy_count].buttons, joys[joy_count].buttons_count,\newline              sizeof(joy_elemdata_t), &ampjoy_cmp_buttons);\newline\newline        ++joy_count;\newline    }\newline\newlineout:\newline    CFRelease(props);\newline}\newline","Read the device passed in, and add it to our joystick list if appropriate. \newline",6008161,genrcfun.c,"globle int RemoveAllExplicitMethods(\newline  void *theEnv,\newline  DEFGENERIC *gfunc)\newline  {\newline   register unsigned i,j;\newline   unsigned systemMethodCount = 0;\newline   DEFMETHOD *narr;\newline\newline   if (MethodsExecuting(gfunc) == FALSE)\newline     {\newline      for (i = 0 ; i &lt gfunc-&gtmcnt ; i++)\newline        {\newline         if (gfunc-&gtmethods[i].system)\newline           systemMethodCount++;\newline         else\newline           DeleteMethodInfo(theEnv,gfunc,&ampgfunc-&gtmethods[i]);\newline        }\newline      if (systemMethodCount != 0)\newline        {\newline         narr = (DEFMETHOD *) gm2(theEnv,(systemMethodCount * sizeof(DEFMETHOD)));\newline         i = 0;\newline         j = 0;\newline         while (i &lt gfunc-&gtmcnt)\newline           {\newline            if (gfunc-&gtmethods[i].system)\newline              GenCopyMemory(DEFMETHOD,1,&ampnarr[j++],&ampgfunc-&gtmethods[i]);\newline            i++;\newline           }\newline         rm(theEnv,(void *) gfunc-&gtmethods,(sizeof(DEFMETHOD) * gfunc-&gtmcnt));\newline         gfunc-&gtmcnt = systemMethodCount;\newline         gfunc-&gtmethods = narr;\newline        }\newline      else\newline        {\newline         if (gfunc-&gtmcnt != 0)\newline           rm(theEnv,(void *) gfunc-&gtmethods,(sizeof(DEFMETHOD) * gfunc-&gtmcnt));\newline         gfunc-&gtmcnt = 0;\newline         gfunc-&gtmethods = NULL;\newline        }\newline      return(TRUE);\newline     }\newline   return(FALSE);\newline  }\newline","\newlineNAME : RemoveAllExplicitMethods\newlineDESCRIPTION : Deletes all explicit defmethods - generic headers\newlineare left intact (as well as a method for an\newlineoverloaded system function)\newlineINPUTS : None\newlineRETURNS : TRUE if all methods deleted, FALSE otherwise\newlineSIDE EFFECTS : Explicit defmethods deleted\newlineNOTES : None\newline \newline",3394172,recom.c,"void computeTraversalInfoStlen(nodeptr p, int maxTips, recompVectors *rvec, int *count) \newline{\newline  if(isTip(p-&gtnumber, maxTips))\newline    return;\newline  else\newline  {          \newline    nodeptr \newline      q = p-&gtnext-&gtback,\newline        r = p-&gtnext-&gtnext-&gtback;\newline\newline    *count += 1;\newline    /* set xnode info at this point */     \newline\newline    if(isTip(r-&gtnumber, maxTips) &amp&amp isTip(q-&gtnumber, maxTips))  \newline    {\newline      rvec-&gtstlen[p-&gtnumber - maxTips - 1] = 2;	\newline\newline#ifdef _DEBUG_RECOMPUTATION\newline      assert(rvec-&gtstlen[p-&gtnumber - maxTips - 1] == subtreeSize(p, maxTips));\newline#endif\newline    }\newline    else\newline    {\newline      if(isTip(r-&gtnumber, maxTips) || isTip(q-&gtnumber, maxTips))\newline      {	     \newline        nodeptr \newline          tmp;\newline\newline        if(isTip(r-&gtnumber, maxTips))\newline        {\newline          tmp = r;\newline          r = q;\newline          q = tmp;\newline        }\newline\newline        if(!r-&gtx)\newline          computeTraversalInfoStlen(r, maxTips, rvec, count);\newline\newline        rvec-&gtstlen[p-&gtnumber - maxTips - 1] = rvec-&gtstlen[r-&gtnumber - maxTips - 1] + 1;\newline\newline#ifdef _DEBUG_RECOMPUTATION	      \newline        assert(rvec-&gtstlen[p-&gtnumber - maxTips - 1] == subtreeSize(p, maxTips));\newline#endif\newline      }\newline      else\newline      {		 \newline        if(!r-&gtx)\newline          computeTraversalInfoStlen(r, maxTips, rvec, count);\newline        if(!q-&gtx)\newline          computeTraversalInfoStlen(q, maxTips, rvec, count); \newline\newline        rvec-&gtstlen[p-&gtnumber - maxTips - 1] = rvec-&gtstlen[q-&gtnumber - maxTips - 1] + rvec-&gtstlen[r-&gtnumber - maxTips - 1];	\newline\newline#ifdef _DEBUG_RECOMPUTATION\newline        assert(rvec-&gtstlen[p-&gtnumber - maxTips - 1] == subtreeSize(p, maxTips));\newline#endif\newline      }\newline    }\newline  }\newline}\newline",@brief Annotes unoriented tree nodes \\a tr with their subtree size \newline \newline This function recursively updates the subtree size of each inner node.\newline @note The subtree size of node \\a p-&gtnumber is the number of nodes included in the subtree where node record \\a p is the virtual root. \newline \newline @param p\newline Pointer to node \newline \newline @param maxTips\newline Number of tips in the tree\newline \newline @param rvec \newline Recomputation info\newline \newline @param count\newline Number of visited nodes \newline \newline,287653,ust-consumer.c,"static int send_stream_to_thread(struct lttng_consumer_stream *stream,\newline		struct lttng_consumer_local_data *ctx)\newline{\newline	int ret;\newline	struct lttng_pipe *stream_pipe;\newline\newline	/* Get the right pipe where the stream will be sent. */\newline	if (stream-&gtmetadata_flag) {\newline		ret = consumer_add_metadata_stream(stream);\newline		if (ret) {\newline			ERR(&quotConsumer add metadata stream %&quot PRIu64 &quot failed.&quot,\newline					stream-&gtkey);\newline			goto error;\newline		}\newline		stream_pipe = ctx-&gtconsumer_metadata_pipe;\newline	} else {\newline		ret = consumer_add_data_stream(stream);\newline		if (ret) {\newline			ERR(&quotConsumer add stream %&quot PRIu64 &quot failed.&quot,\newline					stream-&gtkey);\newline			goto error;\newline		}\newline		stream_pipe = ctx-&gtconsumer_data_pipe;\newline	}\newline\newline	/*\newline	 * From this point on, the stream&#039s ownership has been moved away from\newline	 * the channel and becomes globally visible.\newline	 */\newline	stream-&gtglobally_visible = 1;\newline\newline	ret = lttng_pipe_write(stream_pipe, &ampstream, sizeof(stream));\newline	if (ret &lt 0) {\newline		ERR(&quotConsumer write %s stream to pipe %d&quot,\newline				stream-&gtmetadata_flag ? &quotmetadata&quot : &quotdata&quot,\newline				lttng_pipe_get_writefd(stream_pipe));\newline		if (stream-&gtmetadata_flag) {\newline			consumer_del_stream_for_metadata(stream);\newline		} else {\newline			consumer_del_stream_for_data(stream);\newline		}\newline	}\newlineerror:\newline	return ret;\newline}\newline",\newline Send the given stream pointer to the corresponding thread.\newline \newline Returns 0 on success else a negative value.\newline \newline,5097534,main_loop.c,"static const char * get_filename( const char ** const ibufpp )\newline  {\newline  static char * buf = 0;\newline  static int bufsz = 0;\newline  const int pmax = path_max( 0 );\newline  int n;\newline\newline  *ibufpp = skip_blanks( *ibufpp );\newline  if( **ibufpp != &#039\\n&#039 )\newline    {\newline    int size = 0;\newline    if( !get_extended_line( ibufpp, &ampsize, true ) ) return 0;\newline    if( **ibufpp == &#039!&#039 )\newline      {\newline      ++*ibufpp;\newline      return get_shell_command( ibufpp );\newline      }\newline    else if( size &gt pmax )\newline      { set_error_msg( &quotFilename too long&quot ); return 0; }\newline    }\newline  else if( !traditional() &amp&amp !def_filename[0] )\newline    { set_error_msg( &quotNo current filename&quot ); return 0; }\newline  if( !resize_buffer( &ampbuf, &ampbufsz, pmax + 1 ) ) return 0;\newline  for( n = 0; **ibufpp != &#039\\n&#039; ++n, ++*ibufpp ) buf[n] = **ibufpp;\newline  buf[n] = 0;\newline  while( **ibufpp == &#039\\n&#039 ) ++*ibufpp;			/* skip newline */\newline  return ( may_access_filename( buf ) ? buf : 0 );\newline  }\newline",Return pointer to copy of filename in the command buffer \newline,1040524,find_new_gid.c,"int find_new_gid (bool sys_group,\newline                  gid_t *gid,\newline                  /*@null@*/gid_t const *preferred_gid)\newline{\newline	const struct group *grp;\newline	gid_t gid_min, gid_max, group_id;\newline	bool *used_gids;\newline\newline	assert (gid != NULL);\newline\newline	if (!sys_group) {\newline		gid_min = (gid_t) getdef_ulong (&quotGID_MIN&quot, 1000UL);\newline		gid_max = (gid_t) getdef_ulong (&quotGID_MAX&quot, 60000UL);\newline		if (gid_max &lt gid_min) {\newline			(void) fprintf (stderr,\newline			                _(&quot%s: Invalid configuration: GID_MIN (%lu), GID_MAX (%lu)\\n&quot),\newline			                Prog, (unsigned long) gid_min, (unsigned long) gid_max);\newline			return -1;\newline		}\newline	} else {\newline		gid_min = (gid_t) getdef_ulong (&quotSYS_GID_MIN&quot, 101UL);\newline		gid_max = (gid_t) getdef_ulong (&quotGID_MIN&quot, 1000UL) - 1;\newline		gid_max = (gid_t) getdef_ulong (&quotSYS_GID_MAX&quot, (unsigned long) gid_max);\newline		if (gid_max &lt gid_min) {\newline			(void) fprintf (stderr,\newline			                _(&quot%s: Invalid configuration: SYS_GID_MIN (%lu), GID_MIN (%lu), SYS_GID_MAX (%lu)\\n&quot),\newline			                Prog, (unsigned long) gid_min, getdef_ulong (&quotGID_MIN&quot, 1000UL), (unsigned long) gid_max);\newline			return -1;\newline		}\newline	}\newline	used_gids = malloc (sizeof (bool) * (gid_max +1));\newline	if (NULL == used_gids) {\newline		fprintf (stderr,\newline		         _(&quot%s: failed to allocate memory: %s\\n&quot),\newline		         Prog, strerror (errno));\newline		return -1;\newline	}\newline	memset (used_gids, false, sizeof (bool) * (gid_max + 1));\newline\newline	if (   (NULL != preferred_gid)\newline	    &amp&amp (*preferred_gid &gt= gid_min)\newline	    &amp&amp (*preferred_gid &lt= gid_max)\newline	    /* Check if the user exists according to NSS */\newline	    &amp&amp (getgrgid (*preferred_gid) == NULL)\newline	    /* Check also the local database in case of uncommitted\newline	     * changes */\newline	    &amp&amp (gr_locate_gid (*preferred_gid) == NULL)) {\newline		*gid = *preferred_gid;\newline		free (used_gids);\newline		return 0;\newline	}\newline\newline\newline	/*\newline	 * Search the entire group file,\newline	 * looking for the largest unused value.\newline	 *\newline	 * We check the list of groups according to NSS (setgrent/getgrent),\newline	 * but we also check the local database (gr_rewind/gr_next) in case\newline	 * some groups were created but the changes were not committed yet.\newline	 */\newline	if (sys_group) {\newline		gid_t id;\newline		/* setgrent / getgrent / endgrent can be very slow with\newline		 * LDAP configurations (and many accounts).\newline		 * Since there is a limited amount of IDs to be tested\newline		 * for system accounts, we just check the existence\newline		 * of IDs with getgrgid.\newline		 */\newline		group_id = gid_max;\newline		for (id = gid_max; id &gt= gid_min; id--) {\newline			if (getgrgid (id) != NULL) {\newline				group_id = id - 1;\newline				used_gids[id] = true;\newline			}\newline		}\newline\newline		(void) gr_rewind ();\newline		while ((grp = gr_next ()) != NULL) {\newline			if ((grp-&gtgr_gid &lt= group_id) &amp&amp (grp-&gtgr_gid &gt= gid_min)) {\newline				group_id = grp-&gtgr_gid - 1;\newline			}\newline			/* create index of used GIDs */\newline			if (grp-&gtgr_gid &lt= gid_max) {\newline				used_gids[grp-&gtgr_gid] = true;\newline			}\newline		}\newline	} else {\newline		group_id = gid_min;\newline		setgrent ();\newline		while ((grp = getgrent ()) != NULL) {\newline			if ((grp-&gtgr_gid &gt= group_id) &amp&amp (grp-&gtgr_gid &lt= gid_max)) {\newline				group_id = grp-&gtgr_gid + 1;\newline			}\newline			/* create index of used GIDs */\newline			if (grp-&gtgr_gid &lt= gid_max) {\newline				used_gids[grp-&gtgr_gid] = true;\newline			}\newline		}\newline		endgrent ();\newline\newline		(void) gr_rewind ();\newline		while ((grp = gr_next ()) != NULL) {\newline			if ((grp-&gtgr_gid &gt= group_id) &amp&amp (grp-&gtgr_gid &lt= gid_max)) {\newline				group_id = grp-&gtgr_gid + 1;\newline			}\newline			/* create index of used GIDs */\newline			if (grp-&gtgr_gid &lt= gid_max) {\newline				used_gids[grp-&gtgr_gid] = true;\newline			}\newline		}\newline	}\newline\newline	/*\newline	 * If a group (resp. system group) with GID equal to GID_MAX (resp.\newline	 * GID_MIN) exists, the above algorithm will give us GID_MAX+1\newline	 * (resp. GID_MIN-1) even if not unique. Search for the first free\newline	 * GID starting with GID_MIN (resp. GID_MAX).\newline	 */\newline	if (sys_group) {\newline		if (group_id &lt gid_min) {\newline			for (group_id = gid_max; group_id &gt= gid_min; group_id--) {\newline				if (false == used_gids[group_id]) {\newline					break;\newline				}\newline			}\newline			if (group_id &lt gid_min) {\newline				fprintf (stderr,\newline				         _(&quot%s: Can&#039t get unique system GID (no more available GIDs)\\n&quot),\newline				         Prog);\newline				SYSLOG ((LOG_WARN,\newline				         &quotno more available GID on the system&quot));\newline				free (used_gids);\newline				return -1;\newline			}\newline		}\newline	} else {\newline		if (group_id &gt gid_max) {\newline			for (group_id = gid_min; group_id &lt= gid_max; group_id++) {\newline				if (false == used_gids[group_id]) {\newline					break;\newline				}\newline			}\newline			if (group_id &gt gid_max) {\newline				fprintf (stderr,\newline				         _(&quot%s: Can&#039t get unique GID (no more available GIDs)\\n&quot),\newline				         Prog);\newline				SYSLOG ((LOG_WARN, &quotno more available GID on the system&quot));\newline				free (used_gids);\newline				return -1;\newline			}\newline		}\newline	}\newline\newline	free (used_gids);\newline	*gid = group_id;\newline	return 0;\newline}\newline","\newline find_new_gid - Find a new unused GID.\newline \newline If successful, find_new_gid provides an unused group ID in the\newline [GID_MIN:GID_MAX] range.\newline This ID should be higher than all the used GID, but if not possible,\newline the lowest unused ID in the range will be returned.\newline \newline Return 0 on success, -1 if no unused GIDs are available.\newline \newline",,,,,,,,,,,,,,,on,,,,,,on,,,,,,,,,,,,,,,,,,,,,,Add an element to the display list at the current location,libfuse does not support lsetxattr(),return a BYTE,get a string from gsettings,return the stream bitrate,Destroy a packet object,The size of the buffer that you have passed,"Read the device passed in,",Deletes all explicit defmethods,This function recursively updates the subtree size of each inner node.,Send the given stream pointer to the corresponding thread.,"Sets default case options used by XMLRPC_VALUE funcs
INPUTS",Return pointer to copy of filename in the command buffer,find_new_gid provides an unused group ID in the,{},Self-contained code to run host and device estimates of PI.,Sync Port menu code,addClient adds a new client to the ClientList.,Load an image from the named file.,Calculate a bounding box from a list of nodes,{},x,
31ODACBENUFVESTXEY3QFBOMHU0QSL,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:31 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:31 PDT 2019,,,3W92K5RLWUHO0IOWE3PTH69R2XPV5K,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:22 PDT 2019,Fri Apr 26 13:17:28 PDT 2019,Sun Apr 28 13:17:28 PDT 2019,,,,1746,100% (62/62),100% (62/62),0% (0/0),3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,9350,envelope_circles.cpp,void print_diagram (const Diagram_1&amp diag)\newline{\newline  Diagram_1::Edge_const_handle     e = diag.leftmost();\newline  Diagram_1::Vertex_const_handle   v;\newline\newline  while (e != diag.rightmost())\newline  {\newline    std::cout &lt&lt &quotEdge: &quot;\newline    if (! e-&gtis_empty())\newline    {\newline      Circle_2      circ = e-&gtcurve().supporting_circle();\newline      std::cout &lt&lt &quot (x - &quot &lt&lt CGAL::to_double(circ.center().x()) &lt&lt &quot)^2 +&quot\newline                &lt&lt &quot (y - &quot &lt&lt CGAL::to_double(circ.center().y()) &lt&lt &quot)^2 = &quot\newline                &lt&lt CGAL::to_double(circ.squared_radius()) &lt&lt std::endl;\newline    }\newline    else\newline      std::cout &lt&lt &quot [empty]&quot &lt&lt std::endl;\newline\newline    v = e-&gtright();\newline    std::cout &lt&lt &quotVertex (&quot &lt&lt CGAL::to_double(v-&gtpoint().x()) &lt&lt &#039 &#039\newline              &lt&lt CGAL::to_double(v-&gtpoint().y()) &lt&lt &#039)&#039 &lt&lt std::endl;\newline\newline    e = v-&gtright();\newline  }\newline  CGAL_assertion (e-&gtis_empty());\newline  std::cout &lt&lt &quotEdge: [empty]&quot &lt&lt std::endl;\newline\newline  return;\newline}\newline,! Print the given envelope diagram. \newline,1418488,cro.c,"char* getRegularOutputFilename(int wks_id, const char* file_name, const char* envVar, const char* suffix) {\newline    /* get a root name */\newline    const char* root = getFileNameRoot(wks_id, file_name, envVar);\newline    int rootLen = strlen(root);\newline\newline    /* we append a suffix below, but file_name may already have it */\newline    int suffixLen = (suffix) ? strlen(suffix) : 0;\newline    if (rootLen &gt= suffixLen &amp&amp strncmp(root + strlen(root) - suffixLen, suffix, suffixLen) == 0)\newline        rootLen -= suffixLen;\newline\newline    char* name = (char*) calloc(rootLen + suffixLen+1, 1); /* room for suffix + null */\newline    strncpy(name, root, rootLen);\newline    strcat(name, suffix);\newline\newline    return name;\newline\newline}\newline","\newline getRegularOutputFilename()\newline \newline A utility function to create appropriate filenames for formats such as\newline postscript/PDF, which support multiple pages in a single file.\newline \newline \newline",2160825,master.c,"static struct centry *centry_alloc(void)\newline{\newline    struct centry *t;\newline\newline    t = xzmalloc(sizeof(*t));\newline    t-&gtsi = SERVICE_NONE;\newline    gettimeofday(&ampt-&gtspawntime, NULL);\newline    t-&gtsighuptime = (time_t)-1;\newline\newline    return t;\newline}\newline","Return a new &#039centry&#039, by malloc&#039ing it. \newline",2209580,loadsurface.h,"static int upload_surface_yuv(VADisplay va_dpy, VASurfaceID surface_id,\newline                              int src_fourcc, int src_width, int src_height,\newline                              unsigned char *src_Y, unsigned char *src_U, unsigned char *src_V)\newline{\newline    VAImage surface_image;\newline    unsigned char *surface_p=NULL, *Y_start=NULL, *U_start=NULL;\newline    int Y_pitch=0, U_pitch=0, row;\newline    VAStatus va_status;\newline    \newline    va_status = vaDeriveImage(va_dpy,surface_id, &ampsurface_image);\newline    CHECK_VASTATUS(va_status,&quotvaDeriveImage&quot);\newline\newline    vaMapBuffer(va_dpy,surface_image.buf,(void **)&ampsurface_p);\newline    assert(VA_STATUS_SUCCESS == va_status);\newline\newline    Y_start = surface_p;\newline    Y_pitch = surface_image.pitches[0];\newline    switch (surface_image.format.fourcc) {\newline    case VA_FOURCC_NV12:\newline        U_start = (unsigned char *)surface_p + surface_image.offsets[1];\newline        U_pitch = surface_image.pitches[1];\newline        break;\newline    case VA_FOURCC_IYUV:\newline        U_start = (unsigned char *)surface_p + surface_image.offsets[1];\newline        U_pitch = surface_image.pitches[1];\newline        break;\newline    case VA_FOURCC_YV12:\newline        U_start = (unsigned char *)surface_p + surface_image.offsets[2];\newline        U_pitch = surface_image.pitches[2];\newline        break;\newline    case VA_FOURCC_YUY2:\newline        U_start = surface_p + 1;\newline        U_pitch = surface_image.pitches[0];\newline        break;\newline    default:\newline        assert(0);\newline    }\newline\newline    /* copy Y plane */\newline    for (row=0;row&ltsrc_height;row++) {\newline        unsigned char *Y_row = Y_start + row * Y_pitch;\newline        memcpy(Y_row, src_Y + row*src_width, src_width);\newline    }\newline  \newline    for (row =0; row &lt src_height/2; row++) {\newline        unsigned char *U_row = U_start + row * U_pitch;\newline        unsigned char *u_ptr = NULL, *v_ptr=NULL;\newline        int j;\newline        switch (surface_image.format.fourcc) {\newline        case VA_FOURCC_NV12:\newline            if (src_fourcc == VA_FOURCC_NV12) {\newline                memcpy(U_row, src_U + row * src_width, src_width);\newline                break;\newline            } else if (src_fourcc == VA_FOURCC_IYUV) {\newline                u_ptr = src_U + row * (src_width/2);\newline                v_ptr = src_V + row * (src_width/2);\newline            } else if (src_fourcc == VA_FOURCC_YV12) {\newline                v_ptr = src_U + row * (src_width/2);\newline                u_ptr = src_V + row * (src_width/2);\newline            }\newline            if ((src_fourcc == VA_FOURCC_IYUV) ||\newline                (src_fourcc == VA_FOURCC_YV12)) {\newline                for(j = 0; j &lt src_width/2; j++) {\newline                    U_row[2*j] = u_ptr[j];\newline                    U_row[2*j+1] = v_ptr[j];\newline                }\newline            }\newline            break;\newline        case VA_FOURCC_IYUV:\newline        case VA_FOURCC_YV12:\newline        case VA_FOURCC_YUY2:\newline        default:\newline            printf(&quotunsupported fourcc in load_surface_yuv\\n&quot);\newline            assert(0);\newline        }\newline    }\newline    \newline    vaUnmapBuffer(va_dpy,surface_image.buf);\newline\newline    vaDestroyImage(va_dpy,surface_image.image_id);\newline\newline    return 0;\newline}\newline","\newline Upload YUV data from memory into a surface\newline if src_fourcc == NV12, assume the buffer pointed by src_U\newline is UV interleaved (src_V is ignored)\newline \newline",4367079,h5diff_main.c,void h5diff_exit(int status)\newline{\newline    exit(status);\newline}\newline,"-------------------------------------------------------------------------\newline Function: h5diff_exit\newline \newline Purpose: dismiss phdiff worker processes and exit\newline \newline Return: none\newline \newline Programmer: Albert Cheng\newline Date: Feb 6, 2005\newline \newline Comments:\newline \newline Modifications:\newline \newline -------------------------------------------------------------------------\newline \newline",5898452,kmo_priv_copy.c,"cpl_image*   kmo_copy_image_F2I(cpl_image *data,\newline                            int x1, int x2,\newline                            int y1, int y2)\newline{\newline    cpl_image       *img            = NULL;\newline    float           *d_data         = NULL,\newline                    *d_img          = NULL;\newline    int             i               = 0,\newline                    j               = 0,\newline                    offset          = 0,\newline                    size_x          = 0;\newline\newline    KMO_TRY\newline    {\newline        KMO_TRY_ASSURE(data != NULL,\newline                       CPL_ERROR_NULL_INPUT,\newline                       &quotNot all input data is provided!&quot);\newline\newline        size_x = cpl_image_get_size_x(data);\newline\newline        KMO_TRY_ASSURE((cpl_image_get_size_y(data) &gt= y1) &amp&amp\newline                       (y1 &gt 0),\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quoty1 &lt 1 or y1 &gt size of image! y1 = %d&quot, y1);\newline\newline        KMO_TRY_ASSURE((cpl_image_get_size_y(data) &gt= y2) &amp&amp\newline                       (y2 &gt 0),\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quoty2 &lt 1 or y2 &gt size of image! y2 = %d&quot, y2);\newline\newline        KMO_TRY_ASSURE((size_x &gt= x1) &amp&amp\newline                       (x1 &gt 0),\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quotx1 &lt 1 or x1 &gt size of image! x1 = %d&quot, x1);\newline\newline        KMO_TRY_ASSURE((size_x &gt= x2) &amp&amp\newline                       (x2 &gt 0),\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quotx2 &lt 1 or x2 &gt size of image! x2 = %d&quot, x2);\newline\newline        KMO_TRY_ASSURE(x1 &lt= x2,\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quotx1 &gt x2! x1 = %d, x2 = %d&quot, x1, x2);\newline\newline        KMO_TRY_ASSURE(y1 &lt= y2,\newline                       CPL_ERROR_ILLEGAL_INPUT,\newline                       &quoty1 &gt y2! y1 = %d, y2 = %d&quot, y1, y2);\newline\newline        if ((x2 - x1 + 1 == size_x) &amp&amp\newline            (y2 - y1 + 1 == cpl_image_get_size_y(data))) {\newline            img = cpl_image_duplicate(data);\newline        } else {\newline            KMO_TRY_EXIT_IF_NULL(\newline                img = cpl_image_new(x2 - x1 + 1, y2 - y1 + 1,\newline                                    CPL_TYPE_FLOAT));\newline\newline            KMO_TRY_EXIT_IF_NULL(\newline                d_data = cpl_image_get_data_float(data));\newline\newline            KMO_TRY_EXIT_IF_NULL(\newline                d_img = cpl_image_get_data_float(img));\newline\newline            for (j = y1 - 1; j &lt y2; j++) {\newline                for (i = x1 - 1; i &lt x2; i++) {\newline                    d_img[offset++] = d_data[i + j * size_x];\newline                }\newline            }\newline        }\newline    }\newline    KMO_CATCH\newline    {\newline        KMO_CATCH_MSG();\newline    }\newline\newline    return img;\newline}\newline",\newline@brief\newlineCopies an image from an image.\newline@param data The input image.\newline@param x1 The 1st position in the 1st dimension.\newline@param x2 The 2nd position in the 1st dimension.\newline@param x1 The 1st position in the 2nd dimension.\newline@param x2 The 2nd position in the 2nd dimension.\newline@return The copied image.\newline \newline,4335945,modbus-rtu.c,"int _modbus_rtu_check_integrity(modbus_t *ctx, uint8_t *msg,\newline                                const int msg_length)\newline{\newline    uint16_t crc_calculated;\newline    uint16_t crc_received;\newline\newline    crc_calculated = crc16(msg, msg_length - 2);\newline    crc_received = (msg[msg_length - 2] &lt&lt 8) | msg[msg_length - 1];\newline\newline    /* Check CRC of msg */\newline    if (crc_calculated == crc_received) {\newline        return msg_length;\newline    } else {\newline        if (ctx-&gtdebug) {\newline            fprintf(stderr, &quotERROR CRC received %0X != CRC calculated %0X\\n&quot,\newline                    crc_received, crc_calculated);\newline        }\newline        if (ctx-&gterror_recovery &amp MODBUS_ERROR_RECOVERY_PROTOCOL) {\newline            _modbus_rtu_flush(ctx);\newline        }\newline        errno = EMBBADCRC;\newline        return -1;\newline    }\newline}\newline",The check_crc16 function shall return the message length if the CRC is\newlinevalid. Otherwise it shall return -1 and set errno to EMBADCRC. \newline,918710,create-diff-object.c,"void kpatch_correlate_static_local_variables(struct kpatch_elf *base,\newline					     struct kpatch_elf *patched)\newline{\newline	struct symbol *sym, *patched_sym;\newline	struct section *sec;\newline	struct rela *rela, *rela2;\newline	int bundled, patched_bundled, found;\newline\newline	/*\newline	 * First undo the correlations for all static locals.  Two static\newline	 * locals can have the same numbered suffix in the base and patched\newline	 * objects by coincidence.\newline	 */\newline	list_for_each_entry(sym, &ampbase-&gtsymbols, list) {\newline\newline		if (!kpatch_is_normal_static_local(sym))\newline			continue;\newline\newline		if (sym-&gttwin) {\newline			sym-&gttwin-&gttwin = NULL;\newline			sym-&gttwin = NULL;\newline		}\newline\newline		bundled = sym == sym-&gtsec-&gtsym;\newline		if (bundled &amp&amp sym-&gtsec-&gttwin) {\newline			sym-&gtsec-&gttwin-&gttwin = NULL;\newline			sym-&gtsec-&gttwin = NULL;\newline\newline			sym-&gtsec-&gtsecsym-&gttwin-&gttwin = NULL;\newline			sym-&gtsec-&gtsecsym-&gttwin = NULL;\newline\newline			if (sym-&gtsec-&gtrela) {\newline				sym-&gtsec-&gtrela-&gttwin-&gttwin = NULL;\newline				sym-&gtsec-&gtrela-&gttwin = NULL;\newline			}\newline		}\newline	}\newline\newline	/*\newline	 * Do the correlations: for each section reference to a static local,\newline	 * look for a corresponding reference in the section&#039s twin.\newline	 */\newline	list_for_each_entry(sec, &ampbase-&gtsections, list) {\newline\newline		if (!is_rela_section(sec) ||\newline		    is_debug_section(sec))\newline			continue;\newline\newline		list_for_each_entry(rela, &ampsec-&gtrelas, list) {\newline\newline			sym = rela-&gtsym;\newline			if (!kpatch_is_normal_static_local(sym))\newline				continue;\newline\newline			if (sym-&gttwin)\newline				continue;\newline\newline			bundled = sym == sym-&gtsec-&gtsym;\newline			if (bundled &amp&amp sym-&gtsec == sec-&gtbase) {\newline				/*\newline				 * A rare case where a static local data\newline				 * structure references itself.  There&#039s no\newline				 * reliable way to correlate this.  Hopefully\newline				 * there&#039s another reference to the symbol\newline				 * somewhere that can be used.\newline				 */\newline				log_debug(&quotcan&#039t correlate static local %s&#039s reference to itself\\n&quot,\newline					  sym-&gtname);\newline				continue;\newline			}\newline\newline			patched_sym = kpatch_find_static_twin(sec, sym);\newline			if (!patched_sym)\newline				DIFF_FATAL(&quotreference to static local variable %s in %s was removed&quot,\newline					   sym-&gtname,\newline					   kpatch_section_function_name(sec));\newline\newline			patched_bundled = patched_sym == patched_sym-&gtsec-&gtsym;\newline			if (bundled != patched_bundled)\newline				ERROR(&quotbundle mismatch for symbol %s&quot, sym-&gtname);\newline			if (!bundled &amp&amp sym-&gtsec-&gttwin != patched_sym-&gtsec)\newline				ERROR(&quotsections %s and %s aren&#039t correlated&quot,\newline				      sym-&gtsec-&gtname, patched_sym-&gtsec-&gtname);\newline\newline			log_debug(&quotrenaming and correlating static local %s to %s\\n&quot,\newline				  patched_sym-&gtname, sym-&gtname);\newline\newline			patched_sym-&gtname = strdup(sym-&gtname);\newline			sym-&gttwin = patched_sym;\newline			patched_sym-&gttwin = sym;\newline\newline			if (bundled) {\newline				sym-&gtsec-&gttwin = patched_sym-&gtsec;\newline				patched_sym-&gtsec-&gttwin = sym-&gtsec;\newline\newline				sym-&gtsec-&gtsecsym-&gttwin = patched_sym-&gtsec-&gtsecsym;\newline				patched_sym-&gtsec-&gtsecsym-&gttwin = sym-&gtsec-&gtsecsym;\newline\newline				if (sym-&gtsec-&gtrela &amp&amp patched_sym-&gtsec-&gtrela) {\newline					sym-&gtsec-&gtrela-&gttwin = patched_sym-&gtsec-&gtrela;\newline					patched_sym-&gtsec-&gtrela-&gttwin = sym-&gtsec-&gtrela;\newline				}\newline			}\newline		}\newline	}\newline\newline	/*\newline	 * Make sure that:\newline	 *\newline	 * 1. all the base object&#039s referenced static locals have been\newline	 *    correlated; and\newline	 *\newline	 * 2. each reference to a static local in the base object has a\newline	 *    corresponding reference in the patched object (because a static\newline	 *    local can be referenced by more than one section).\newline	 */\newline	list_for_each_entry(sec, &ampbase-&gtsections, list) {\newline\newline		if (!is_rela_section(sec) ||\newline		    is_debug_section(sec))\newline			continue;\newline\newline		list_for_each_entry(rela, &ampsec-&gtrelas, list) {\newline\newline			sym = rela-&gtsym;\newline			if (!kpatch_is_normal_static_local(sym))\newline				continue;\newline\newline			if (!sym-&gttwin || !sec-&gttwin)\newline				DIFF_FATAL(&quotreference to static local variable %s in %s was removed&quot,\newline					   sym-&gtname,\newline					   kpatch_section_function_name(sec));\newline\newline			found = 0;\newline			list_for_each_entry(rela2, &ampsec-&gttwin-&gtrelas, list) {\newline				if (rela2-&gtsym == sym-&gttwin) {\newline					found = 1;\newline					break;\newline				}\newline			}\newline\newline			if (!found)\newline				DIFF_FATAL(&quotstatic local %s has been correlated with %s, but patched %s is missing a reference to it&quot,\newline					   sym-&gtname, sym-&gttwin-&gtname,\newline					   kpatch_section_function_name(sec-&gttwin));\newline		}\newline	}\newline\newline	/*\newline	 * Now go through the patched object and look for any uncorrelated\newline	 * static locals to see if we need to print any warnings about new\newline	 * variables.\newline	 */\newline	list_for_each_entry(sec, &amppatched-&gtsections, list) {\newline\newline		if (!is_rela_section(sec) ||\newline		    is_debug_section(sec))\newline			continue;\newline\newline		list_for_each_entry(rela, &ampsec-&gtrelas, list) {\newline\newline			sym = rela-&gtsym;\newline			if (!kpatch_is_normal_static_local(sym))\newline				continue;\newline\newline			if (sym-&gttwin)\newline				continue;\newline\newline			log_normal(&quotWARNING: unable to correlate static local variable %s used by %s, assuming variable is new\\n&quot,\newline				   sym-&gtname,\newline				   kpatch_section_function_name(sec));\newline			return;\newline		}\newline	}\newline}\newline","\newline gcc renames static local variables by appending a period and a number. For\newline example, __foo could be renamed to __foo.31452. Unfortunately this number\newline can arbitrarily change. Correlate them by comparing which functions\newline reference them, and rename the patched symbols to match the base symbol\newline names.\newline \newline Some surprising facts about static local variable symbols:\newline \newline - It&#039s possible for multiple functions to use the same\newline static local variable if the variable is defined in an\newline inlined function.\newline \newline - It&#039s also possible for multiple static local variables\newline with the same name to be used in the same function if they\newline have different scopes. (We have to assume that in such\newline cases, the order in which they&#039re referenced remains the\newline same between the base and patched objects, as there&#039s no\newline other way to distinguish them.)\newline \newline - Static locals are usually referenced by functions, but\newline they can occasionally be referenced by data sections as\newline well.\newline \newline",4065243,standard.c,"void show_not_online(char *user)\newline{\newline    BOOL can_show = FALSE, can_show_lasttime = FALSE;\newline\newline    NOBODY_PRIVS;\newline\newline    if (local_finger) {\newline	if (prog_config.local_config_bits1 &amp SHOW_IFON)\newline	    can_show = TRUE;\newline    } else {\newline	if (prog_config.config_bits1 &amp SHOW_IFON)\newline	    can_show = TRUE;\newline    }\newline\newline    if (local_finger) {\newline	if (prog_config.local_config_bits1 &amp SHOW_LTON)\newline	    can_show_lasttime = TRUE;\newline    } else {\newline	if (prog_config.config_bits1 &amp SHOW_LTON)\newline	    can_show_lasttime = TRUE;\newline    }\newline\newline    if (can_show) {\newline	if (can_show_lasttime)\newline	    show_lasttime_on(user);\newline	else {\newline	    printf(&quotThis user is not currently logged in.\\n&quot);\newline	    fflush(stdout);\newline	}\newline    }\newline}\newline",\newline SHOW_NOT_ONLINE\newline \newline This shows whether or not the user is online.\newline \newline,2163877,times.c,"EXPORTED int time_to_rfc3501(time_t date, char *buf, size_t len)\newline{\newline    struct tm *tm = localtime(&ampdate);\newline    long gmtoff = gmtoff_of(tm, date);\newline    int gmtnegative = 0;\newline\newline    /*assert(date &gt 0); - it turns out these can happen, annoyingly enough */\newline    assert(tm-&gttm_year &gt= 69);\newline\newline    if (gmtoff &lt 0) {\newline	gmtoff = -gmtoff;\newline	gmtnegative = 1;\newline    }\newline    gmtoff /= 60;\newline    return snprintf(buf, len,\newline	    &quot%2u-%s-%u %.2u:%.2u:%.2u %c%.2lu%.2lu&quot,\newline	    tm-&gttm_mday, monthname[tm-&gttm_mon], tm-&gttm_year+1900,\newline	    tm-&gttm_hour, tm-&gttm_min, tm-&gttm_sec,\newline	    gmtnegative ? &#039-&#039 : &#039+&#039, gmtoff/60, gmtoff%60);\newline}\newline","\newline Convert a time_t date to an IMAP-style date\newline datebuf needs to be &gt= 30 bytes.\newline \newline Returns: number of characters in @buf generated, or -1 on error.\newline \newline",1003634,lp_lib.c,"STATIC int identify_GUB(lprec *lp, MYBOOL mark)\newline{\newline  int    i, j, jb, je, k, knint, srh;\newline  REAL   rh, mv, tv, bv;\newline  MATrec *mat = lp-&gtmatA;\newline\newline  if((lp-&gtequalities == 0) || !mat_validate(mat))\newline    return( 0 );\newline\newline  k = 0;\newline  for(i = 1; i &lt= lp-&gtrows; i++) {\newline\newline    /* Check if it is an equality constraint */\newline    if(!is_constr_type(lp, i, EQ))\newline      continue;\newline\newline    rh = get_rh(lp, i);\newline    srh = my_sign(rh);\newline    knint = 0;\newline    je = mat-&gtrow_end[i];\newline    for(jb = mat-&gtrow_end[i-1]; jb &lt je; jb++) {\newline      j = ROW_MAT_COLNR(jb);\newline\newline      /* Check for validity of the equation elements */\newline      if(!is_int(lp, j))\newline        knint++;\newline      if(knint &gt 1)\newline        break;\newline\newline      mv = get_mat_byindex(lp, jb, TRUE, FALSE);\newline      if(fabs(my_reldiff(mv, rh)) &gt lp-&gtepsprimal)\newline        break;\newline\newline      tv = mv*get_upbo(lp, j);\newline      bv = get_lowbo(lp, j);\newline#if 0 /* Requires 1 as upper bound */\newline      if((fabs(my_reldiff(tv, rh)) &gt lp-&gtepsprimal) || (bv != 0))\newline#else /* Can handle any upper bound &gt= 1 */\newline      if((srh*(tv-rh) &lt -lp-&gtepsprimal) || (bv != 0))\newline#endif\newline        break;\newline    }\newline\newline    /* Update GUB count and optionally mark the GUB */\newline    if(jb == je) {\newline      k++;\newline      if(mark == TRUE)\newline        lp-&gtrow_type[i] |= ROWTYPE_GUB;\newline      else if(mark == AUTOMATIC)\newline        break;\newline    }\newline\newline  }\newline  return( k );\newline}\newline",Preprocessing and postprocessing functions \newline,28472,update-passwd.c,"int read_passwd(struct _node** list, const char* file) {\newline    FILE*		input;\newline    struct _node*	node;\newline    struct passwd*	result;\newline\newline    if (opt_verbose&gt2)\newline	printf(&quotReading passwd from %s\\n&quot, file);\newline\newline    if ((input=fopen(file, &quotr&quot))==NULL) {\newline	fprintf(stderr, &quotError opening passwd file %s: %s\\n&quot, file, strerror(errno));\newline	return 1;\newline    }\newline\newline    while ((result=fgetpwent(input))!=NULL) {\newline	node=create_node();\newline	copy_passwd(node, result);\newline	node-&gtt=t_passwd;\newline	node-&gtname=node-&gtd.pw.pw_name;\newline	if (!node-&gtname)\newline	    break;\newline	if (node-&gtname[0]==&#039+&#039)\newline	    node-&gtid=0;\newline	else\newline	    node-&gtid=node-&gtd.pw.pw_uid;\newline	add_node(list, node, 0);\newline    }\newline\newline    if ((result==NULL) &amp&amp (errno!=ENOENT)) {\newline	fprintf(stderr, &quotError reading passwd file %s: %s\\n&quot, file, strerror(errno));\newline	return 2;\newline    }\newline\newline    fclose(input);\newline\newline    return 0;\newline}\newline",Function to read passwd database \newline,1274738,infcover.c,"local void cover_inflate(void)\newline{\newline    try(&quot0 0 0 0 0&quot, &quotinvalid stored block lengths&quot, 1);\newline    try(&quot3 0&quot, &quotfixed&quot, 0);\newline    try(&quot6&quot, &quotinvalid block type&quot, 1);\newline    try(&quot1 1 0 fe ff 0&quot, &quotstored&quot, 0);\newline    try(&quotfc 0 0&quot, &quottoo many length or distance symbols&quot, 1);\newline    try(&quot4 0 fe ff&quot, &quotinvalid code lengths set&quot, 1);\newline    try(&quot4 0 24 49 0&quot, &quotinvalid bit length repeat&quot, 1);\newline    try(&quot4 0 24 e9 ff ff&quot, &quotinvalid bit length repeat&quot, 1);\newline    try(&quot4 0 24 e9 ff 6d&quot, &quotinvalid code -- missing end-of-block&quot, 1);\newline    try(&quot4 80 49 92 24 49 92 24 71 ff ff 93 11 0&quot,\newline        &quotinvalid literal/lengths set&quot, 1);\newline    try(&quot4 80 49 92 24 49 92 24 f b4 ff ff c3 84&quot, &quotinvalid distances set&quot, 1);\newline    try(&quot4 c0 81 8 0 0 0 0 20 7f eb b 0 0&quot, &quotinvalid literal/length code&quot, 1);\newline    try(&quot2 7e ff ff&quot, &quotinvalid distance code&quot, 1);\newline    try(&quotc c0 81 0 0 0 0 0 90 ff 6b 4 0&quot, &quotinvalid distance too far back&quot, 1);\newline\newline    /* also trailer mismatch just in inflate() */\newline    try(&quot1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1&quot, &quotincorrect data check&quot, -1);\newline    try(&quot1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1&quot,\newline        &quotincorrect length check&quot, -1);\newline    try(&quot5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c&quot, &quotpull 17&quot, 0);\newline    try(&quot5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f&quot,\newline        &quotlong code&quot, 0);\newline    try(&quoted c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f&quot, &quotlength extra&quot, 0);\newline    try(&quoted cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c&quot,\newline        &quotlong distance and extra&quot, 0);\newline    try(&quoted c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 &quot\newline        &quot0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6&quot, &quotwindow end&quot, 0);\newline    inf(&quot2 8 20 80 0 3 0&quot, &quotinflate_fast TYPE return&quot, 0, -15, 258,\newline        Z_STREAM_END);\newline    inf(&quot63 18 5 40 c 0&quot, &quotwindow wrap&quot, 3, -8, 300, Z_OK);\newline}\newline",cover deflate data cases in both inflate() and inflateBack() \newline,5790584,ppl_test.c,"ap_linexpr0_t* random_linexpr_inter(int dim)\newline{\newline  ap_linexpr0_t* l = random_linexpr(dim);\newline  int n1 = rand()%20-10;\newline  int n2 = n1 + rand()%20;\newline  int d  = rand()%4+1;\newline  ap_linexpr0_set_cst_interval_frac(l,n1,d,n2,d);\newline  return l;\newline}\newline",random affine expression with scalar constant coefficient \newline,2947471,main.c,"static void chld_signal_handler(const int signo)\newline{\newline  pid_t pid;\newline  int status;\newline\newline  status = signo; /* don&#039t like gcc warnings :) */\newline\newline  while ((pid = waitpid(-1, &ampstatus, WNOHANG)) &gt 0)\newline    if (opt.log_level &gt= 3)\newline      syslog(LOG_INFO, &quotchild %d terminated&quot, pid);\newline}\newline",Catch terminated childs \newline,5211910,dynar.cpp,"void xbt_dynar_sort(xbt_dynar_t dynar, int_f_cpvoid_cpvoid_t compar_fn)\newline{\newline  if (dynar-&gtdata != nullptr)\newline    qsort(dynar-&gtdata, dynar-&gtused, dynar-&gtelmsize, compar_fn);\newline}\newline","@brief Sorts a dynar according to the function &lttt&gtcompar_fn&lt/tt&gt\newline \newline This function simply apply the classical qsort(3) function to the data stored in the dynar.\newline You should thus refer to the libc documentation, or to some online tutorial on how to write\newline a comparison function. Here is a quick example if you have integers in your dynar:\newline \newline @verbatim\newline int cmpfunc (const void a, const void b) {\newline int intA = (int )a;\newline int intB = (int )b;\newline return intA - intB;\newline }\newline @endverbatim\newline \newline and now to sort a dynar of MSG hosts depending on their speed:\newline @verbatim\newline int cmpfunc(const MSG_host_t a, const MSG_host_t b) {\newline MSG_host_t hostA = (MSG_host_t )a;\newline MSG_host_t hostB = (MSG_host_t )b;\newline return MSG_host_get_speed(hostA) - MSG_host_get_speed(hostB);\newline }\newline @endverbatim\newline \newline \\param dynar the dynar to sort\newline \\param compar_fn comparison function of type (int (compar_fn ) (const void ) (const void )).\newline \newline",3761854,addrconf.c,"int addrconf_set_dstaddr(void *arg)\newline{\newline	struct in6_ifreq ireq;\newline	struct device *dev;\newline	int err = -EINVAL;\newline\newline	rtnl_lock();\newline\newline	err = -EFAULT;\newline	if (copy_from_user(&ampireq, arg, sizeof(struct in6_ifreq)))\newline		goto err_exit;\newline\newline	dev = dev_get_by_index(ireq.ifr6_ifindex);\newline\newline	err = -ENODEV;\newline	if (dev == NULL)\newline		goto err_exit;\newline\newline	if (dev-&gttype == ARPHRD_SIT) {\newline		struct ifreq ifr;\newline		mm_segment_t	oldfs;\newline		struct ip_tunnel_parm p;\newline\newline		err = -EADDRNOTAVAIL;\newline		if (!(ipv6_addr_type(&ampireq.ifr6_addr) &amp IPV6_ADDR_COMPATv4))\newline			goto err_exit;\newline\newline		memset(&ampp, 0, sizeof(p));\newline		p.iph.daddr = ireq.ifr6_addr.s6_addr32[3];\newline		p.iph.saddr = 0;\newline		p.iph.version = 4;\newline		p.iph.ihl = 5;\newline		p.iph.protocol = IPPROTO_IPV6;\newline		p.iph.ttl = 64;\newline		ifr.ifr_ifru.ifru_data = (void*)&ampp;\newline\newline		oldfs = get_fs(); set_fs(KERNEL_DS);\newline		err = dev-&gtdo_ioctl(dev, &ampifr, SIOCADDTUNNEL);\newline		set_fs(oldfs);\newline\newline		if (err == 0) {\newline			err = -ENOBUFS;\newline			if ((dev = dev_get(p.name)) == NULL)\newline				goto err_exit;\newline			err = dev_open(dev);\newline		}\newline	}\newline\newlineerr_exit:\newline	rtnl_unlock();\newline	return err;\newline}\newline",\newline Set destination address.\newline Special case for SIT interfaces where we create a new &quotvirtual&quot\newline device.\newline \newline,231771,bsd-getopt_long.c,"static int pure_gcd(int a, int b)\newline{\newline    int c;\newline\newline    c = a % b;\newline    while (c != 0) {\newline        a = b;\newline        b = c;\newline        c = a % b;\newline    }\newline    return b;\newline}\newline",\newline Compute the greatest common divisor of a and b.\newline \newline,4284407,shinstance.c,"static void sh_int_lazy_init_sigaction(shinstance *psh, int signo)\newline{\newline    if (psh-&gtsigactions[signo].sh_handler == SH_SIG_UNK)\newline    {\newline        shmtxtmp tmp;\newline        shmtx_enter(&ampg_sh_mtx, &amptmp);\newline\newline        if (psh-&gtsigactions[signo].sh_handler == SH_SIG_UNK)\newline        {\newline            shsigaction_t shold;\newline            shinstance *cur;\newline#ifndef _MSC_VER\newline            struct sigaction old;\newline            if (!sigaction(signo, NULL, &ampold))\newline            {\newline                /* convert */\newline                shold.sh_flags = old.sa_flags;\newline                shold.sh_mask = old.sa_mask;\newline                if (old.sa_handler == SIG_DFL)\newline                    shold.sh_handler = SH_SIG_DFL;\newline                else\newline                {\newline                    assert(old.sa_handler == SIG_IGN);\newline                    shold.sh_handler = SH_SIG_IGN;\newline                }\newline            }\newline            else\newline#endif\newline            {\newline                /* fake */\newline#ifndef _MSC_VER\newline                assert(0);\newline                old.sa_handler = SIG_DFL;\newline                old.sa_flags = 0;\newline                sigemptyset(&ampshold.sh_mask);\newline                sigaddset(&ampshold.sh_mask, signo);\newline#endif\newline                shold.sh_flags = 0;\newline                sh_sigemptyset(&ampshold.sh_mask);\newline                sh_sigaddset(&ampshold.sh_mask, signo);\newline                shold.sh_handler = SH_SIG_DFL;\newline            }\newline\newline            /* update globals */\newline#ifndef _MSC_VER\newline            g_sig_state[signo].sa = old;\newline#else\newline            g_sig_state[signo].sa.sa_handler = SIG_DFL;\newline            g_sig_state[signo].sa.sa_flags = 0;\newline            g_sig_state[signo].sa.sa_mask = shold.sh_mask;\newline#endif\newline            TRACE2((psh, &quotsh_int_lazy_init_sigaction: signo=%d:%s sa_handler=%p sa_flags=%#x\\n&quot,\newline                    signo, sys_signame[signo], g_sig_state[signo].sa.sa_handler, g_sig_state[signo].sa.sa_flags));\newline\newline            /* update all shells */\newline            for (cur = g_sh_head; cur; cur = cur-&gtnext)\newline            {\newline                assert(cur-&gtsigactions[signo].sh_handler == SH_SIG_UNK);\newline                cur-&gtsigactions[signo] = shold;\newline            }\newline        }\newline\newline        shmtx_leave(&ampg_sh_mtx, &amptmp);\newline    }\newline}\newline","\newline Lazy initialization of a signal state, globally.\newline \newline @param psh The shell doing the lazy work.\newline @param signo The signal (valid).\newline \newline",311660,checks.c,"void check_host_result_freshness(void) {\newline	host *temp_host = NULL;\newline	time_t current_time = 0L;\newline\newline\newline	log_debug_info(DEBUGL_FUNCTIONS, 0, &quotcheck_host_result_freshness()\\n&quot);\newline	log_debug_info(DEBUGL_CHECKS, 2, &quotAttempting to check the freshness of host check results...\\n&quot);\newline\newline	/* bail out if we&#039re not supposed to be checking freshness */\newline	if (check_host_freshness == FALSE) {\newline		log_debug_info(DEBUGL_CHECKS, 2, &quotHost freshness checking is disabled.\\n&quot);\newline		return;\newline	}\newline\newline	/* get the current time */\newline	time(&ampcurrent_time);\newline\newline	/* check all hosts... */\newline	for (temp_host = host_list; temp_host != NULL; temp_host = temp_host-&gtnext) {\newline\newline		/* skip hosts we shouldn&#039t be checking for freshness */\newline		if (temp_host-&gtcheck_freshness == FALSE)\newline			continue;\newline\newline		/* skip hosts that have both active and passive checks disabled */\newline		if (temp_host-&gtchecks_enabled == FALSE &amp&amp temp_host-&gtaccept_passive_host_checks == FALSE)\newline			continue;\newline\newline		/* skip hosts that are currently executing (problems here will be caught by orphaned host check) */\newline		if (temp_host-&gtis_executing == TRUE)\newline			continue;\newline\newline		/* skip hosts that are already being freshened */\newline		if (temp_host-&gtis_being_freshened == TRUE)\newline			continue;\newline\newline		/* see if the time is right... */\newline		if (check_time_against_period(current_time, temp_host-&gtcheck_period_ptr) == ERROR)\newline			continue;\newline\newline		/* the results for the last check of this host are stale */\newline		if (is_host_result_fresh(temp_host, current_time, TRUE) == FALSE) {\newline\newline			/* set the freshen flag */\newline			temp_host-&gtis_being_freshened = TRUE;\newline\newline			/* schedule an immediate forced check of the host */\newline			schedule_host_check(temp_host, current_time, CHECK_OPTION_FORCE_EXECUTION | CHECK_OPTION_FRESHNESS_CHECK);\newline		}\newline	}\newline\newline	return;\newline}\newline",check freshness of host results \newline,,,,,,,,on,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,Load an image from the named file.,This shows whether or not the user is online.,Convert a time_t date to an IMAP-style date,Preprocessing and postprocessing functions,Function to read passwd database,cover deflate data cases in both inflate() and inflateBack(),random affine expression with scalar constant coefficient,{},a dynar according to the function,Set destination address.,Compute the greatest common divisor of a and b.,Print the given envelope diagram.,"Lazy initialization of a signal state, globally.",check freshness of host results,{},"Return a new 'centry', by malloc'ing it.",Upload YUV data from memory into a surface,dismiss phdiff worker processes and exit,Copies an image from an image.,Otherwise it shall return -1 and set errno to EMBADCRC.,renames static local variables by appending a period and a number.,x,
33Q5P9PUSPMOL35S48W3RZW80UZZCU,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:48 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:48 PDT 2019,,,3WEV0KO0OMS3C3MLZE274VDCGBLSDE,AITP2LUW8GPB,Submitted,Fri Apr 26 14:24:36 PDT 2019,Fri Apr 26 14:25:47 PDT 2019,Sun Apr 28 14:25:47 PDT 2019,,,,71,100% (62/62),100% (62/62),0% (0/0),3437191,otr.c,"static void add_peer_context_cb(void *data, ConnContext *context)\newline{\newline	struct otr_peer_context *opc;\newline\newline	opc = otr_create_peer_context();\newline	if (!opc) {\newline		return;\newline	}\newline\newline	opc-&gtactive_fingerprint = context-&gtactive_fingerprint;\newline\newline	context-&gtapp_data = opc;\newline	context-&gtapp_data_free = destroy_peer_context_cb;\newline\newline	IRSSI_DEBUG(&quotPeer context created for %s&quot, context-&gtusername);\newline}\newline",\newline Allocate otr peer context. Callback passed to libotr.\newline \newline,1526254,plotscreen.cpp,void PlotScreen::setMouseEnabled(bool inputStat)\newline{\newline  pw-&gtmouseEnabled = inputStat;\newline}\newline,"This function will enable/disbale mouse press, release and movement \newline",1885039,graph.c,"static int get_cgnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {\newline#if FCN_OLD\newline	RAnalFunction *f = r_anal_get_fcn_in (core-&gtanal, core-&gtoffset, 0);\newline	RANode *node, *fcn_anode;\newline	RListIter *iter;\newline	RAnalRef *ref;\newline	char *title, *body;\newline\newline	if (!f) return false;\newline\newline	r_core_seek (core, f-&gtaddr, 1);\newline\newline	title = get_title (fcn-&gtaddr);\newline	fcn_anode = r_agraph_add_node (g, title, &quot&quot);\newline\newline	free (title);\newline	if (!fcn_anode) {\newline		return false;\newline	}\newline\newline	fcn_anode-&gtx = 10;\newline	fcn_anode-&gty = 3;\newline\newline	r_list_foreach (fcn-&gtrefs, iter, ref) {\newline		/* XXX: something is broken, why there are duplicated\newline		 *      nodes here?! goto check fcn-&gtrefs!! */\newline		/* avoid dups wtf */\newline		title = get_title (ref-&gtaddr);\newline		if (r_agraph_get_node (g, title) != NULL)\newline				continue;\newline		free (title);\newline\newline		int size = 0;\newline		RAnalBlock *bb = r_anal_bb_from_offset (core-&gtanal, ref-&gtaddr);\newline		if (bb) size = bb-&gtsize;\newline\newline		body = get_body (core, ref-&gtaddr, size, mode2opts (g));\newline		title = get_title (ref-&gtaddr);\newline\newline		node = r_agraph_add_node (g, title, body);\newline		if (!node) return false;\newline\newline		free (title);\newline		free (body);\newline\newline		node-&gtx = 10;\newline		node-&gty = 10;\newline\newline		r_agraph_add_edge (g, fcn_anode, node);\newline	}\newline#else\newline	eprintf (&quotMust be sdbized\\n&quot);\newline#endif\newline\newline	return true;\newline}\newline","build the RGraph inside the RAGraph g, starting from the Call Graph\newline information \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2152712,fselect.c,"static void _drawCDKFselect (CDKOBJS *object, boolean Box GCC_UNUSED)\newline{\newline   CDKFSELECT *fselect = (CDKFSELECT *)object;\newline\newline   /* Draw in the shadow if we need to. */\newline   if (fselect-&gtshadowWin != 0)\newline   {\newline      drawShadow (fselect-&gtshadowWin);\newline   }\newline\newline   /* Draw in the entry field. */\newline   drawCDKEntry (fselect-&gtentryField, ObjOf (fselect-&gtentryField)-&gtbox);\newline\newline   /* Draw in the scroll field. */\newline   drawMyScroller (fselect);\newline}\newline",\newline This draws the file selector widget.\newline \newline,675694,read-dict.c,"static int is_equal(Dictionary dict, char c)\newline{\newline	return (dict-&gtis_special &amp&amp\newline	        c == dict-&gttoken[0] &amp&amp\newline	        dict-&gttoken[1] == &#039\\0&#039);\newline}\newline",\newline Returns true if this token is a special token and it is equal to c\newline \newline,2323547,dtimer.c,"static INLINE long dzdos_read_timer()\newline{\newline   long x;\newline\newline   outportb(0x43, 0x00);\newline   x = inportb(0x40);\newline   x += inportb(0x40) &lt&lt 8;\newline\newline   return (0xFFFF - x + 1) &amp 0xFFFF;\newline}\newline",read_timer:\newline Reads the elapsed time from PIT channel 1.\newline \newline,286763,snapshot.c,"void snapshot_destroy(struct snapshot *obj)\newline{\newline	struct lttng_ht_iter iter;\newline	struct snapshot_output *output;\newline\newline	assert(obj);\newline\newline	rcu_read_lock();\newline	cds_lfht_for_each_entry(obj-&gtoutput_ht-&gtht, &ampiter.iter, output,\newline			node.node) {\newline		snapshot_delete_output(obj, output);\newline		snapshot_output_destroy(output);\newline	}\newline	rcu_read_unlock();\newline	ht_cleanup_push(obj-&gtoutput_ht);\newline}\newline",\newline Destroy snapshot object but the pointer is not freed so it&#039s safe to pass a\newline static reference.\newline \newline,1304059,java.c,"static int cjni_read(user_data_t *ud) /* {{{ */\newline{\newline  JNIEnv *jvm_env;\newline  cjni_callback_info_t *cbi;\newline  int ret_status;\newline\newline  if (jvm == NULL) {\newline    ERROR(&quotjava plugin: cjni_read: jvm == NULL&quot);\newline    return (-1);\newline  }\newline\newline  if ((ud == NULL) || (ud-&gtdata == NULL)) {\newline    ERROR(&quotjava plugin: cjni_read: Invalid user data.&quot);\newline    return (-1);\newline  }\newline\newline  jvm_env = cjni_thread_attach();\newline  if (jvm_env == NULL)\newline    return (-1);\newline\newline  cbi = (cjni_callback_info_t *)ud-&gtdata;\newline\newline  ret_status = (*jvm_env)-&gtCallIntMethod(jvm_env, cbi-&gtobject, cbi-&gtmethod);\newline\newline  cjni_thread_detach();\newline  return (ret_status);\newline} /* }}} int cjni_read */\newline",Call the CB_TYPE_READ callback pointed to by the `user_data_t&#039 pointer. \newline,4616443,main.cpp,"int main(int argc, char *argv[]) {\newline    KNullHash = Hash() ;\newline#ifdef WIN32\newline    WSADATA wsaData;\newline    int nResult = WSAStartup(MAKEWORD(2,2), &ampwsaData);\newline    if(nResult != NO_ERROR) {\newline        QLOG_STR( &quotWSAStartup() failed.&quot);\newline    } else {\newline        QLOG_STR( &quotWSAStartup() success&quot);\newline    }\newline#endif\newline#if !(defined(WIN32)||defined(Q_OS_OSX))\newline#if QT_VERSION &gt= 0x050000\newline    QString platform ( QGuiApplication::platformName() ) ;\newline    bool have_xcb ( platform.compare(&quotxcb&quot) == 0 || platform.length()==0) ;\newline    QLOG_STR(&quotPlatform: &quot + QGuiApplication::platformName() +\newline             &quot len = &quot +\newline             QString::number(platform.length())) ;\newline    bool have_display ( getenv(&quotDISPLAY&quot) != NULL  ) ;\newline    bool have_wayland ( getenv(&quotWAYLAND_DISPLAY&quot) != NULL ) ;\newline    if ( have_xcb &amp&amp (\newline                have_display==false &amp&amp\newline                have_wayland==false ) ) {\newline        // so, we have &quotxcb&quot that is normal linux. and we have no $DISPLAY\newline        // nor $WAYLAND_DISPLAY -&gt this spells some problems..\newline        fprintf(stderr,&quotNo $DISPLAY/WAYLAND_DISPLAY environment variable set, cant continue\\n&quot) ;\newline        return 0 ;\newline    }\newline#endif // qt version\newline#endif // check of $DISPLAY or $WAYLAND_DISPLAY\newline\newline    app = new QApplication (argc, argv);\newline\newline    CATranslator caTranslator;\newline\newline    if ( caTranslator.load( &quotqt_&quot + QLocale::system().name()) == false )  {\newline        QLOG_STR(&quotTrying translations from &quot + QLibraryInfo::location(QLibraryInfo::TranslationsPath)) ;\newline        if ( caTranslator.load(&quotqt_&quot + QLocale::system().name(),\newline                               QLibraryInfo::location(QLibraryInfo::TranslationsPath)) == true ) {\newline            QLOG_STR(&quotQt translation loaded from &quot  +\newline                     QLibraryInfo::location(QLibraryInfo::TranslationsPath)) ;\newline        } else {\newline#ifndef WIN32\newline            if ( caTranslator.load(QLibraryInfo::location(QLibraryInfo::TranslationsPath) + &quot/qt_&quot + QLocale::system().name())  ) {\newline                QLOG_STR(&quotQt translation found from &quot+QLibraryInfo::location(QLibraryInfo::TranslationsPath) + &quot using direct file naming&quot) ;\newline            } else {\newline                QLOG_STR(&quotQt translation not found&quot) ;\newline            }\newline#else\newline            QLOG_STR(&quotQt translation not found&quot) ;\newline#endif\newline        }\newline    } else {\newline        QLOG_STR(&quotQt translation found from current directory&quot) ;\newline    }\newline    app-&gtinstallTranslator(&ampcaTranslator);\newline\newline    // controller will actually start launching the application\newline    c = new Controller(*app) ;\newline#if QT_VERSION &lt 0x050000\newline    // without this qt4+qjson does not handle utf-8 well ; every\newline    // byte in multi-byte unicode-sequences appears as separate\newline    // character after the string is parsed back in windows environment.\newline    // linux does some magick tricks to not fail due to broken utf-8.\newline    QTextCodec *codec = QTextCodec::codecForName(&quotUTF-8&quot);\newline    QTextCodec::setCodecForCStrings(codec);\newline    QTextCodec::setCodecForTr(codec);\newline#endif\newline#ifndef WIN32\newline    signal(SIGINT,sigINThandler); // if user presses CTRL-C\newline    signal(SIGHUP,sigINThandler); // if user closed the terminal..\newline    signal(SIGUSR1,sigUSR1handler);\newline    signal(SIGUSR2,sigUSR2handler);\newline#endif\newline\newline    // check for possible command line arguments relevant to\newline    // us:\newline    QRegExp rx(&quot^(caprofile|caad|cacomment|cablob)://[a-fA-F0-9]{40}/{0,1}$&quot);\newline    QRegExpValidator validator (rx);\newline    for ( int i = 1 ; i &lt argc ; i++ ) {\newline        QString argumentCandidate(argv[i] );\newline        int position ( 0 ) ;\newline        if ( validator.validate(argumentCandidate,position) == QValidator::Acceptable ) {\newline            QUrl commandLineUrl ( argumentCandidate ) ;\newline            QLOG_STR(&quotscheme &quot + commandLineUrl.scheme() ) ;\newline            QLOG_STR(&quothost &quot + commandLineUrl.host() ) ;\newline            c-&gtaddObjectToOpen(commandLineUrl) ;\newline            break ; // out of the loop, process only one\newline        }\newline    }\newline    int retval ( 0 ) ;\newline    if ( c-&gtinit() ) { // 2nd stage of constructor\newline        retval = app-&gtexec() ;\newline    }\newline    QLOG_STR(&quotdeleting controller&quot) ;\newline    delete c ;\newline    delete app ;\newline    return retval ;\newline}\newline",\newline FZ - in the night of the iron sausage\newline \newline,1209216,jsint.c,"int js_upcall_get_image_border(void *chuligane, long document_id, long image_id)\newline{\newline#ifdef G\newline	struct f_data_c *fd;\newline	struct f_data_c *js_ctx=(struct f_data_c*)chuligane;\newline	struct g_object_image *gi;\newline\newline	if (F)\newline	{\newline		if (!js_ctx)internal(&quotjs_upcall_get_image_border called with NULL context pointer\\n&quot);\newline		if ((image_id&ampJS_OBJ_MASK)!=JS_OBJ_T_IMAGE)return -1;\newline		fd=jsint_find_document(document_id);\newline		if (!fd||!jsint_can_access(js_ctx,fd))return -1;\newline\newline		gi=jsint_find_object(fd,image_id);\newline\newline		if (!gi)return -1;\newline\newline		return gi-&gtborder;\newline	}else\newline#endif\newline	{\newline		document_id=document_id;\newline		image_id=image_id;\newline		return -1;\newline	}\newline}\newline",returns border of given image or -1 on error \newline,3100410,depca.c,"static int get_hw_addr(struct device *dev)\newline{\newline  u_long ioaddr = dev-&gtbase_addr;\newline  int i, k, tmp, status = 0;\newline  u_short j, x, chksum;\newline\newline  x = (((adapter == de100) || (adapter == de101)) ? 1 : 0);\newline\newline  for (i=0,k=0,j=0;j&lt3;j++) {\newline    k &lt&lt= 1 ;\newline    if (k &gt 0xffff) k-=0xffff;\newline\newline    k += (u_char) (tmp = inb(DEPCA_PROM + x));\newline    dev-&gtdev_addr[i++] = (u_char) tmp;\newline    k += (u_short) ((tmp = inb(DEPCA_PROM + x)) &lt&lt 8);\newline    dev-&gtdev_addr[i++] = (u_char) tmp;\newline\newline    if (k &gt 0xffff) k-=0xffff;\newline  }\newline  if (k == 0xffff) k=0;\newline\newline  chksum = (u_char) inb(DEPCA_PROM + x);\newline  chksum |= (u_short) (inb(DEPCA_PROM + x) &lt&lt 8);\newline  if (k != chksum) status = -1;\newline\newline  return status;\newline}\newline",\newline The DE100 and DE101 PROM accesses were made non-standard for some bizarre\newline reason: access the upper half of the PROM with x=0; access the lower half\newline with x=1.\newline \newline,800993,pack.c,"git_off_t get_delta_base(\newline	struct git_pack_file *p,\newline	git_mwindow **w_curs,\newline	git_off_t *curpos,\newline	git_otype type,\newline	git_off_t delta_obj_offset)\newline{\newline	unsigned int left = 0;\newline	unsigned char *base_info;\newline	git_off_t base_offset;\newline	git_oid unused;\newline\newline	base_info = pack_window_open(p, w_curs, *curpos, &ampleft);\newline	/* Assumption: the only reason this would fail is because the file is too small */\newline	if (base_info == NULL)\newline		return GIT_EBUFS;\newline	/* pack_window_open() assured us we have [base_info, base_info + 20)\newline	 * as a range that we can look at without walking off the\newline	 * end of the mapped window. Its actually the hash size\newline	 * that is assured. An OFS_DELTA longer than the hash size\newline	 * is stupid, as then a REF_DELTA would be smaller to store.\newline	 */\newline	if (type == GIT_OBJ_OFS_DELTA) {\newline		unsigned used = 0;\newline		unsigned char c = base_info[used++];\newline		base_offset = c &amp 127;\newline		while (c &amp 128) {\newline			if (left &lt= used)\newline				return GIT_EBUFS;\newline			base_offset += 1;\newline			if (!base_offset || MSB(base_offset, 7))\newline				return 0; /* overflow */\newline			c = base_info[used++];\newline			base_offset = (base_offset &lt&lt 7) + (c &amp 127);\newline		}\newline		base_offset = delta_obj_offset - base_offset;\newline		if (base_offset &lt= 0 || base_offset &gt= delta_obj_offset)\newline			return 0; /* out of bound */\newline		*curpos += used;\newline	} else if (type == GIT_OBJ_REF_DELTA) {\newline		/* If we have the cooperative cache, search in it first */\newline		if (p-&gthas_cache) {\newline			khiter_t k;\newline			git_oid oid;\newline\newline			git_oid_fromraw(&ampoid, base_info);\newline			k = kh_get(oid, p-&gtidx_cache, &ampoid);\newline			if (k != kh_end(p-&gtidx_cache)) {\newline				*curpos += 20;\newline				return ((struct git_pack_entry *)kh_value(p-&gtidx_cache, k))-&gtoffset;\newline			} else {\newline				/* If we&#039re building an index, don&#039t try to find the pack\newline				 * entry; we just haven&#039t seen it yet.  We&#039ll make\newline				 * progress again in the next loop.\newline				 */\newline				return GIT_PASSTHROUGH;\newline			}\newline		}\newline\newline		/* The base entry _must_ be in the same pack */\newline		if (pack_entry_find_offset(&ampbase_offset, &ampunused, p, (git_oid *)base_info, GIT_OID_HEXSZ) &lt 0)\newline			return packfile_error(&quotbase entry delta is not in the same pack&quot);\newline		*curpos += 20;\newline	} else\newline		return 0;\newline\newline	return base_offset;\newline}\newline","\newline curpos is where the data starts, delta_obj_offset is the where the\newline header starts\newline \newline",4854439,expr.c,"inline static void expression_set_tf_preclear(\newline  expression* expr,    /*!&lt Pointer to expression to set true/false indicators of */\newline  bool        changed  /*!&lt Set to TRUE if the expression changed value */\newline) {\newline\newline  /* If the expression changed value or it has never been set, calculate coverage information */\newline  if( changed || (expr-&gtvalue-&gtsuppl.part.set == 0) ) {\newline\newline    /* Clear current TRUE/FALSE indicators */\newline    expr-&gtsuppl.part.eval_t = 0;\newline    expr-&gtsuppl.part.eval_f = 0;\newline      \newline    /* Set TRUE/FALSE bits to indicate value */\newline    if( !vector_is_unknown( expr-&gtvalue ) ) {\newline      if( vector_is_not_zero( expr-&gtvalue ) ) {\newline        expr-&gtsuppl.part.true   = 1;\newline        expr-&gtsuppl.part.eval_t = 1;\newline      } else {\newline        expr-&gtsuppl.part.false  = 1;\newline        expr-&gtsuppl.part.eval_f = 1;\newline      }\newline    }\newline\newline    /* Indicate that the vector has been evaluated */\newline    expr-&gtvalue-&gtsuppl.part.set = 1;\newline\newline  }\newline\newline}\newline",!\newlineThis function sets the true/false indicators in the expression supplemental field as\newlineneeded. This function should only be called by expression_op_func__ functions that\newlineare NOT events AND whose return value is TRUE AND whose op type is not STATIC or\newlinePARAM.\newline \newline,2129860,dgami.c,"doublereal dgami_(doublereal *a, doublereal *x)\newline{\newline    /* System generated locals */\newline    doublereal ret_val;\newline\newline    /* Builtin functions */\newline    double log(doublereal), exp(doublereal);\newline\newline    /* Local variables */\newline    extern doublereal dlngam_(doublereal *), dgamit_(doublereal *, doublereal\newline            *);\newline    doublereal factor;\newline    extern /* Subroutine */ int xermsg_(const char *, const char *, const char *, integer *,\newline            integer *, ftnlen, ftnlen, ftnlen);\newline\newline/* ***BEGIN PROLOGUE  DGAMI */\newline/* ***PURPOSE  Evaluate the incomplete Gamma function. */\newline/* ***LIBRARY   SLATEC (FNLIB) */\newline/* ***CATEGORY  C7E */\newline/* ***TYPE      DOUBLE PRECISION (GAMI-S, DGAMI-D) */\newline/* ***KEYWORDS  FNLIB, INCOMPLETE GAMMA FUNCTION, SPECIAL FUNCTIONS */\newline/* ***AUTHOR  Fullerton, W., (LANL) */\newline/* ***DESCRIPTION */\newline\newline/* Evaluate the incomplete gamma function defined by */\newline\newline/* DGAMI = integral from T = 0 to X of EXP(-T) * T**(A-1.0) . */\newline\newline/* DGAMI is evaluated for positive values of A and non-negative values */\newline/* of X.  A slight deterioration of 2 or 3 digits accuracy will occur */\newline/* when DGAMI is very large or very small, because logarithmic variables */\newline/* are used.  The function and both arguments are double precision. */\newline\newline/* ***REFERENCES  (NONE) */\newline/* ***ROUTINES CALLED  DGAMIT, DLNGAM, XERMSG */\newline/* ***REVISION HISTORY  (YYMMDD) */\newline/*   770701  DATE WRITTEN */\newline/*   890531  Changed all specific intrinsics to generic.  (WRB) */\newline/*   890531  REVISION DATE from Version 3.2 */\newline/*   891214  Prologue converted to Version 4.0 format.  (BAB) */\newline/*   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ) */\newline/* ***END PROLOGUE  DGAMI */\newline/* ***FIRST EXECUTABLE STATEMENT  DGAMI */\newline    if (*a &lt= 0.) {\newline        xermsg_(&quotSLATEC&quot, &quotDGAMI&quot, &quotA MUST BE GT ZERO&quot, &ampc__1, &ampc__2, (ftnlen)\newline                6, (ftnlen)5, (ftnlen)17);\newline    }\newline    if (*x &lt 0.) {\newline        xermsg_(&quotSLATEC&quot, &quotDGAMI&quot, &quotX MUST BE GE ZERO&quot, &ampc__2, &ampc__2, (ftnlen)\newline                6, (ftnlen)5, (ftnlen)17);\newline    }\newline\newline    ret_val = 0.;\newline    if (*x == 0.) {\newline        return ret_val;\newline    }\newline\newline/* THE ONLY ERROR POSSIBLE IN THE EXPRESSION BELOW IS A FATAL OVERFLOW. */\newline    factor = exp(dlngam_(a) + *a * log(*x));\newline\newline    ret_val = factor * dgamit_(a, x);\newline\newline    return ret_val;\newline} /* dgami_ */\newline",DECK DGAMI \newline,3964283,vmfs_inode.c,"void vmfs_inode_release(vmfs_inode_t *inode)\newline{\newline   assert(inode-&gtref_count &gt 0);\newline \newline   if (--inode-&gtref_count == 0) {\newline      if (inode-&gtupdate_flags)\newline         vmfs_inode_update(inode,inode-&gtupdate_flags &amp VMFS_INODE_SYNC_BLK);\newline\newline      if (inode-&gtpprev != NULL) {\newline         /* remove the inode from hash table */\newline         if (inode-&gtnext != NULL)\newline            inode-&gtnext-&gtpprev = inode-&gtpprev;\newline\newline         *(inode-&gtpprev) = inode-&gtnext;\newline\newline         free(inode);\newline      }\newline   }\newline}\newline",Release an inode \newline,1818346,menu1.c,"void band_settings(void *arg, int from_ctest)\newline{\newline    struct dialog *d;\newline    int i,found;\newline    char *pband;\newline    struct config_band *confb=NULL;\newline    struct band *band=NULL;\newline    static char ss[1024];\newline\newline    found=0;\newline	pband = (char *)arg;\newline\newline    if (!from_ctest)\newline        for (i=0;i&ltcfg-&gtbands-&gtlen; i++){\newline\newline            confb = (struct config_band*)g_ptr_array_index(cfg-&gtbands,i);\newline            if (!confb) break;\newline            if (strcasecmp(pband, confb-&gtpband)==0){\newline                found=1;\newline                break;\newline            }\newline        }\newline    else\newline        for (i=0;i&ltctest-&gtbands-&gtlen; i++){\newline\newline            band = (struct band*)g_ptr_array_index(ctest-&gtbands,i);\newline            if (!band) break;\newline            if (strcasecmp(pband, band-&gtpband)==0){\newline                found=1;\newline                break;\newline            }\newline        }\newline\newline    \newline    if (!found){ zinternal(&quotband_settings() !found&quot); }\newline    \newline    if (confb){\newline        qrvnow=confb-&gtqrvnow;\newline        psect=confb-&gtpsect;\newline		LOAD_STR(confb, opsect);\newline        isqrv=confb-&gtqrv;\newline        readonly=confb-&gtreadonly;\newline        dbg(&quotband_settings readonly=%d\\n&quot, readonly);\newline        safe_strncpy0(stxeq,confb-&gtstxeq,RESP_LEN);\newline        safe_strncpy0(spowe,confb-&gtspowe,RESP_LEN);\newline        safe_strncpy0(srxeq,confb-&gtsrxeq,RESP_LEN);\newline        safe_strncpy0(sante,confb-&gtsante,RESP_LEN);\newline        safe_strncpy0(santh,confb-&gtsanth,RESP_LEN);\newline        safe_strncpy0(mope1,confb-&gtmope1,RESP_LEN);    z_str_uc(mope1);\newline        safe_strncpy0(mope2,confb-&gtmope2,RESP_LEN);    z_str_uc(mope2);\newline        safe_strncpy0(remarks,confb-&gtremarks,RESP_LEN);\newline        safe_strncpy0(ok_section_single,confb-&gtok_section_single,RESP_LEN);\newline        safe_strncpy0(ok_section_multi,confb-&gtok_section_multi,RESP_LEN);\newline        g_snprintf(qrg_min_str, RESP_LEN, &quot%d&quot, confb-&gtqrg_min);\newline        g_snprintf(qrg_max_str, RESP_LEN, &quot%d&quot, confb-&gtqrg_max);\newline        safe_strncpy0(adifband,confb-&gtadifband,RESP_LEN);\newline        safe_strncpy0(skedqrg,confb-&gtskedqrg,RESP_LEN);\newline        g_snprintf(band_lo_str, RESP_LEN, &quot%1.1f&quot, confb-&gtband_lo);\newline        g_snprintf(band_sw_str, RESP_LEN, &quot0x%02x&quot, confb-&gtband_sw);\newline        g_snprintf(wwlradius_str, RESP_LEN, &quot%d&quot, confb-&gtwwlradius);\newline    }else{\newline        qrvnow=1;\newline        psect=band-&gtpsect;\newline		LOAD_STR(band, opsect);\newline        isqrv=1;\newline        readonly=band-&gtreadonly;\newline        safe_strncpy0(stxeq,band-&gtstxeq,RESP_LEN);\newline        safe_strncpy0(spowe,band-&gtspowe,RESP_LEN);\newline        safe_strncpy0(srxeq,band-&gtsrxeq,RESP_LEN);\newline        safe_strncpy0(sante,band-&gtsante,RESP_LEN);\newline        safe_strncpy0(santh,band-&gtsanth,RESP_LEN);\newline        safe_strncpy0(mope1,band-&gtmope1,RESP_LEN);    z_str_uc(mope1);\newline        safe_strncpy0(mope2,band-&gtmope2,RESP_LEN);    z_str_uc(mope2);\newline        safe_strncpy0(remarks,band-&gtremarks,RESP_LEN);\newline        /*safe_strncpy0(ok_section_single,band-&gtok_section_single,RESP_LEN);\newline        safe_strncpy0(ok_section_multi,band-&gtok_section_multi,RESP_LEN);\newline        g_snprintf(qrg_min, RESP_LEN, &quot%d&quot, band-&gtqrg_min);\newline        g_snprintf(qrg_max, RESP_LEN, &quot%d&quot, band-&gtqrg_max);\newline        safe_strncpy0(adifband,band-&gtadifband,RESP_LEN);\newline        safe_strncpy0(skedqrg,band-&gtskedqrg,RESP_LEN);\newline        g_snprintf(band_lo, RESP_LEN, &quot%1.1f&quot, band-&gtband_lo);\newline        band_sw\newline        wwlradius \newline         */\newline\newline    }\newline\newline    if (!(d = (struct dialog *)g_malloc(sizeof(struct dialog) + 55 * sizeof(struct dialog_item)))) return;\newline    memset(d, 0, sizeof(struct dialog) + 55 * sizeof(struct dialog_item));\newline    d-&gttitle = ss;\newline	d-&gtfn = dlg_pf_fn;\newline	d-&gty0 = 1;\newline\newline    if (confb){\newline        g_snprintf(ss,1000,VTEXT(T_BAND_SETTINGS_SC), confb-&gtbandchar,pband);\newline        d-&gtrefresh = (void (*)(void *))refresh_band_confb;\newline        d-&gtrefresh_data = confb;\newline    }else{\newline        g_snprintf(ss,1000,VTEXT(T_BAND_SETTINGS_SC), band-&gtbandchar,pband);\newline        d-&gtrefresh = (void (*)(void *))refresh_band;\newline        d-&gtrefresh_data = band;\newline    }\newline    \newline\newline    d-&gtitems[i=0].type = D_CHECKBOX;    /* 0 */\newline    d-&gtitems[i].gid  = 0;\newline    d-&gtitems[i].gnum = 1;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&ampisqrv;\newline	d-&gtitems[i].msg = CTEXT(T_QRV_ON_THIS_BAND);\newline    \newline    d-&gtitems[++i].type = D_CHECKBOX;\newline    d-&gtitems[i].gid  = 0;\newline    d-&gtitems[i].gnum = 1;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&ampqrvnow;\newline    d-&gtitems[i].msg = CTEXT(T_QRV_IN_THIS_CTEST);\newline\newline    d-&gtitems[++i].type = D_CHECKBOX;\newline    d-&gtitems[i].gid  = 0;\newline    d-&gtitems[i].gnum = 1;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&ampreadonly;\newline    d-&gtitems[i].msg = CTEXT(T_READ_ONLY);\newline   	d-&gtitems[i].wrap = 1;  \newline\newline    d-&gtitems[++i].type = D_CHECKBOX;\newline    d-&gtitems[i].gid  = 1;\newline    d-&gtitems[i].gnum = 0;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&amppsect;\newline    d-&gtitems[i].msg =  CTEXT(T_MULTI);\newline\newline    d-&gtitems[++i].type = D_CHECKBOX;\newline    d-&gtitems[i].gid  = 1;\newline    d-&gtitems[i].gnum = 1;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&amppsect;\newline    d-&gtitems[i].msg = CTEXT(T_SINGLE);\newline\newline    d-&gtitems[++i].type = D_CHECKBOX;   \newline    d-&gtitems[i].gid  = 1;\newline    d-&gtitems[i].gnum = 2;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&amppsect;\newline    d-&gtitems[i].msg =  CTEXT(T_CHECK);  \newline\newline    d-&gtitems[++i].type = D_CHECKBOX;   \newline    d-&gtitems[i].gid  = 1;\newline    d-&gtitems[i].gnum = 3;\newline    d-&gtitems[i].dlen = sizeof(int);\newline    d-&gtitems[i].data = (char *)&amppsect;\newline    d-&gtitems[i].msg =  CTEXT(T_OTHER);  \newline   		\newline	d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline	d-&gtitems[i].maxl = 15;\newline    d-&gtitems[i].data = opsect;\newline    d-&gtitems[i].msg = &quot&quot;\newline    d-&gtitems[i].wrap = 2;\newline	\newline	d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = stxeq;\newline    d-&gtitems[i].msg = CTEXT(T_TXEQUIP);\newline    d-&gtitems[i].wrap = 1;\newline            \newline    d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = 10;\newline    d-&gtitems[i].data = spowe;\newline	d-&gtitems[i].msg = CTEXT(T_POWER);\newline   	d-&gtitems[i].wrap = 1;\newline  \newline    d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = srxeq;\newline    d-&gtitems[i].msg = CTEXT(T_RXEQUIP);\newline   	d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = sante;\newline    d-&gtitems[i].msg = CTEXT(T_ANTENNA);\newline    d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_FIELD;   \newline    d-&gtitems[i].dlen = 10;\newline    d-&gtitems[i].data = santh;\newline    d-&gtitems[i].msg = CTEXT(T_AGLASL);    \newline    d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = mope1;\newline    d-&gtitems[i].msg = CTEXT(T_OPS);\newline    d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_FIELD;\newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = mope2;\newline    d-&gtitems[i].msg = CTEXT(T_SPACES1);\newline    d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_FIELD;  \newline    d-&gtitems[i].dlen = RESP_LEN;\newline    d-&gtitems[i].data = remarks;\newline    d-&gtitems[i].msg = CTEXT(T_REMARKS);   \newline    d-&gtitems[i].wrap = 2;\newline\newline    if (confb){\newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 4;\newline        d-&gtitems[i].data = ok_section_single;\newline        d-&gtitems[i].msg = CTEXT(T_OK_SECTION_SINGLE); \newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 4;\newline        d-&gtitems[i].data = ok_section_multi;\newline		d-&gtitems[i].msg = CTEXT(T_OK_SECTION_MULTI); \newline    	d-&gtitems[i].wrap = 1;\newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 10;\newline        d-&gtitems[i].data = qrg_min_str;\newline        d-&gtitems[i].fn   = check_number;\newline        d-&gtitems[i].gid  = 0;\newline        d-&gtitems[i].gnum = 250000000;\newline        d-&gtitems[i].msg = CTEXT(T_QRG_MIN);\newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 10;\newline        d-&gtitems[i].data = qrg_max_str;\newline        d-&gtitems[i].fn   = check_number;\newline        d-&gtitems[i].gid  = 0;\newline        d-&gtitems[i].gnum = 250000000;\newline		d-&gtitems[i].msg = CTEXT(T_QRG_MAX);\newline    	d-&gtitems[i].wrap = 1;\newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 8;\newline        d-&gtitems[i].data = adifband;\newline        d-&gtitems[i].msg = CTEXT(T_ADIFBAND);\newline\newline        d-&gtitems[++i].type = D_FIELD;\newline        d-&gtitems[i].dlen = 11;\newline        d-&gtitems[i].data = skedqrg;\newline        d-&gtitems[i].msg = CTEXT(T_SKEDQRG);\newline    	d-&gtitems[i].wrap = 1;\newline\newline        d-&gtitems[++i].type = D_FIELD;     \newline        d-&gtitems[i].dlen = 16;\newline        d-&gtitems[i].data = band_lo_str;\newline        d-&gtitems[i].fn   = check_qrg;\newline		d-&gtitems[i].msg = CTEXT(T_BAND_LO);     \newline		d-&gtitems[i].wrap = 1;\newline\newline        d-&gtitems[++i].type = D_FIELD;      \newline        d-&gtitems[i].dlen = 6;\newline        d-&gtitems[i].data = band_sw_str;\newline		d-&gtitems[i].msg = CTEXT(T_BANDSW);\newline	    //d-&gtitems[i].wrap = 2;\newline\newline        d-&gtitems[++i].type = D_FIELD;      \newline        d-&gtitems[i].dlen = 6;\newline        d-&gtitems[i].data = wwlradius_str;\newline		d-&gtitems[i].msg = TRANSLATE(&quotStats WWL radius:&quot);\newline	    d-&gtitems[i].wrap = 2;\newline\newline    }\newline    d-&gtitems[++i].type = D_BUTTON;        \newline    d-&gtitems[i].gid = B_ENTER;\newline    d-&gtitems[i].fn = ok_dialog;\newline    d-&gtitems[i].text = VTEXT(T_OK);\newline\newline    d-&gtitems[++i].type = D_BUTTON;\newline    d-&gtitems[i].gid = B_ESC;\newline    d-&gtitems[i].fn = cancel_dialog;\newline    d-&gtitems[i].text = VTEXT(T_CANCEL);\newline    d-&gtitems[i].align = AL_BUTTONS;\newline	d-&gtitems[i].wrap = 1;\newline\newline    d-&gtitems[++i].type = D_END;\newline    do_dialog(d, getml(d, NULL));\newline}\newline",xxx is char band \newline,4570204,test_classad_put.cpp,"bool putOldClassAd ( DummyStream *sock, classad::ClassAd&amp ad, bool excludeTypes )\newline{\newline	classad::ClassAdUnParser	unp;\newline	string						buf;\newline	const classad::ExprTree		*expr;\newline    bool send_server_time = false;\newline\newline	int numExprs=0;\newline\newline	classad::ClassAdIterator itor(ad);\newline\newline    bool haveChainedAd = false;\newline    \newline    classad::ClassAd *chainedAd = ad.GetChainedParentAd();\newline    \newline    if(chainedAd){\newline        haveChainedAd = true;\newline    }\newline\newline    for(int pass = 0; pass &lt 2; pass++){\newline\newline        /* \newline        * Count the number of chained attributes on the first\newline        *   pass (if any!), then the number of attrs in this classad on\newline        *   pass number 2.\newline        */\newline        if(pass == 0){\newline            if(!haveChainedAd){\newline                continue;\newline            }\newline            itor.Initialize(*chainedAd);\newline        }\newline        else {\newline            itor.Initialize(ad);\newline        }\newline\newline        while( !itor.IsAfterLast( ) ) {\newline            itor.CurrentAttribute( buf, expr );\newline\newline\newline            if(!compat_classad::ClassAdAttributeIsPrivate(buf.c_str()))\newline            {\newline                if(excludeTypes)\newline                {\newline                    if(strcasecmp( &quotMyType&quot, buf.c_str() ) != 0 &amp&amp\newline                        strcasecmp( &quotTargetType&quot, buf.c_str() ) != 0)\newline                    {\newline                        numExprs++;\newline                    }\newline                }\newline                else { numExprs++; }\newline            }\newline            itor.NextAttribute( buf, expr );\newline        }\newline    }\newline\newline    if( publish_server_timeMangled ){\newline        //add one for the ATTR_SERVER_TIME expr\newline        numExprs++;\newline        send_server_time = true;\newline    }\newline\newline	sock-&gtencode( );\newline	if( !sock-&gtcode( numExprs ) ) {\newline		return false;\newline	}\newline    \newline    classad::ClassAdIterator attrItor; \newline    for(int pass = 0; pass &lt 2; pass++){\newline        if(pass == 0) {\newline            /* need to copy the chained attrs first, so if\newline             *  there are duplicates, the non-chained attrs\newline             *  will override them\newline             */\newline            if(!haveChainedAd){\newline                continue;\newline            }\newline            attrItor.Initialize(*chainedAd);\newline        } \newline        else {\newline            attrItor.Initialize(ad);\newline        }\newline\newline        char *exprString;\newline        for( attrItor.ToFirst();\newline            !attrItor.IsAfterLast();\newline            attrItor.NextAttribute(buf, expr) ) {\newline\newline            attrItor.CurrentAttribute( buf, expr );\newline\newline            if(compat_classad::ClassAdAttributeIsPrivate(buf.c_str())){\newline                continue;\newline            }\newline\newline            if(excludeTypes){\newline                if(strcasecmp( &quotMyType&quot, buf.c_str( ) ) == 0 || \newline                        strcasecmp( &quotTargetType&quot, buf.c_str( ) ) == 0 ){\newline                    continue;\newline                }\newline            }\newline\newline            //store the name for later\newline            string tmpAttrName(buf);\newline            buf += &quot = &quot;\newline            unp.Unparse( buf, expr );\newline            \newline            //get buf&#039s c_str in an editable format\newline            exprString = (char*)malloc(buf.size() + 1);\newline            strncpy(exprString, buf.c_str(),buf.size() + 1 ); \newline            //ConvertDefaultIPToSocketIP(tmpAttrName.c_str(),&ampexprString,*sock);\newline            /*\newline            if( ! sock-&gtprepare_crypto_for_secret_is_noop() &amp&amp\newline                    compat_classad::ClassAdAttributeIsPrivate(tmpAttrName.c_str())) {\newline                sock-&gtput(SECRET_MARKER);\newline\newline                sock-&gtput_secret(exprString);\newline            }\newline            else */ if (!sock-&gtput(exprString) ){\newline                free(exprString);\newline                return false;\newline            }\newline            free(exprString);\newline        }\newline    }\newline\newline    if(send_server_time) {\newline        //insert in the current time from the server&#039s (Schedd) point of\newline        //view. this is used so condor_q can compute some time values \newline        //based upon other attribute values without worrying about \newline        //the clocks being different on the condor_schedd machine\newline        // -vs- the condor_q machine\newline\newline        char* serverTimeStr;\newline        serverTimeStr = (char *) malloc(strlen(ATTR_SERVER_TIME)\newline                                        + 3     //for &quot = &quot\newline                                        + 12    // for integer\newline                                        +1);    //for null termination\newline        sprintf(serverTimeStr, &quot%s = %ld&quot, ATTR_SERVER_TIME, (long)time(NULL) );\newline        if(!sock-&gtput(serverTimeStr)){\newline            free(serverTimeStr);\newline            return 0;\newline        }\newline        free(serverTimeStr);\newline    }\newline\newline    //ok, so we&#039re not really excluding it here, but...\newline    if(excludeTypes)\newline    {\newline        // Send the type\newline        if (!ad.EvaluateAttrString(&quotMyType&quot,buf)) {\newline            buf=&quot(unknown type)&quot;\newline        }\newline        if (!sock-&gtput(buf.c_str())) {\newline            return false;\newline        }\newline\newline        if (!ad.EvaluateAttrString(&quotTargetType&quot,buf)) {\newline            buf=&quot(unknown type)&quot;\newline        }\newline        if (!sock-&gtput(buf.c_str())) {\newline            return false;\newline        }\newline    }\newline\newline	return true;\newline}\newline",need to free exprString every time. Whatever put() does can deal with it\newline \newline \newline,3330728,swephlib.c,"void swi_polcart(double *l, double *x) \newline{\newline  double xx[3];\newline  double cosl1;\newline  cosl1 = cos(l[1]);\newline  xx[0] = l[2] * cosl1 * cos(l[0]);\newline  xx[1] = l[2] * cosl1 * sin(l[0]);\newline  xx[2] = l[2] * sin(l[1]);\newline  x[0] = xx[0];\newline  x[1] = xx[1];\newline  x[2] = xx[2];\newline}\newline",conversion from polar (l[3]) to cartesian coordinates (x[3]).\newline x = l is allowed.\newline \newline,4199970,qformatscheme.cpp,QFormat&amp QFormatScheme::formatRef(int ifid)\newline{\newline	return m_formatValues[ifid];\newline}\newline,!\newline \\return The text format associated with format key \\a fid\newline \newline \\warning Use at your own risks : if there are no format associated\newline with the requested id this function will crash\newline \newline,1418364,ncarlogo2ps.c,"void from_ps(float angle, float size, float xpos, float ypos, FILE *ifile, FILE *ofile)\newline{\newline\newline/*\newline *  Insert the logos.\newline */\newline  fseek(ifile,0L,SEEK_SET);\newline  while (fgets(line, LINEL, ifile)) {\newline    if (!strncmp(&quotS\\n&quot,line,2)) {\newline      fgets(line, LINEL, ifile);\newline      if (!strncmp(&quot%%Page:&quot,line,7) || !strncmp(&quot%%Trailer&quot,line,9)) {\newline        InsertLogo(angle, size, xpos, ypos, ofile); \newline        fputs(&quotS\\n&quot,ofile);\newline      }\newline    }\newline    fputs(line,ofile);\newline  }\newline}\newline",\newline Insert logos into PostScript from NCAR GKS.\newline \newline,,on,,on,on,on,on,,on,,,,on,,,,,on,,,on,,,,,,,,,,,,,,,,,,,,,,Callback passed to libotr.,{},returns border of given image or -1 on error,{},{},{},{},Release an inode,{},need to free exprString every time.,conversion from polar (l[3]) to cartesian coordinates,"This function will enable/disbale mouse press,",{},Insert logos into PostScript from NCAR GKS.,"build the RGraph inside the RAGraph g,",Load an image from the named file.,This draws the file selector widget.,{},Reads the elapsed time from PIT channel 1.,Destroy snapshot object,{},x,
3X0EMNLXEPPQ689M8GT6QTIJB28PVY,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:22 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:22 PDT 2019,,,3OVHNO1VE610DF8ZU6WF0OAF3QKDZ3,AITP2LUW8GPB,Submitted,Fri Apr 26 14:08:07 PDT 2019,Fri Apr 26 14:11:41 PDT 2019,Sun Apr 28 14:11:41 PDT 2019,,,,214,100% (62/62),100% (62/62),0% (0/0),287087,ust-app.c,"int ust_app_enable_event_pid(struct ltt_ust_session *usess,\newline		struct ltt_ust_channel *uchan, struct ltt_ust_event *uevent, pid_t pid)\newline{\newline	int ret = 0;\newline	struct lttng_ht_iter iter;\newline	struct lttng_ht_node_str *ua_chan_node;\newline	struct ust_app *app;\newline	struct ust_app_session *ua_sess;\newline	struct ust_app_channel *ua_chan;\newline	struct ust_app_event *ua_event;\newline\newline	DBG(&quotUST app enabling event %s for PID %d&quot, uevent-&gtattr.name, pid);\newline\newline	rcu_read_lock();\newline\newline	app = ust_app_find_by_pid(pid);\newline	if (app == NULL) {\newline		ERR(&quotUST app enable event per PID %d not found&quot, pid);\newline		ret = -1;\newline		goto end;\newline	}\newline\newline	if (!app-&gtcompatible) {\newline		ret = 0;\newline		goto end;\newline	}\newline\newline	ua_sess = lookup_session_by_app(usess, app);\newline	if (!ua_sess) {\newline		/* The application has problem or is probably dead. */\newline		ret = 0;\newline		goto end;\newline	}\newline\newline	pthread_mutex_lock(&ampua_sess-&gtlock);\newline\newline	if (ua_sess-&gtdeleted) {\newline		ret = 0;\newline		goto end_unlock;\newline	}\newline\newline	/* Lookup channel in the ust app session */\newline	lttng_ht_lookup(ua_sess-&gtchannels, (void *)uchan-&gtname, &ampiter);\newline	ua_chan_node = lttng_ht_iter_get_node_str(&ampiter);\newline	/* If the channel is not found, there is a code flow error */\newline	assert(ua_chan_node);\newline\newline	ua_chan = caa_container_of(ua_chan_node, struct ust_app_channel, node);\newline\newline	ua_event = find_ust_app_event(ua_chan-&gtevents, uevent-&gtattr.name,\newline			uevent-&gtfilter, uevent-&gtattr.loglevel, uevent-&gtexclusion);\newline	if (ua_event == NULL) {\newline		ret = create_ust_app_event(ua_sess, ua_chan, uevent, app);\newline		if (ret &lt 0) {\newline			goto end_unlock;\newline		}\newline	} else {\newline		ret = enable_ust_app_event(ua_sess, ua_event, app);\newline		if (ret &lt 0) {\newline			goto end_unlock;\newline		}\newline	}\newline\newlineend_unlock:\newline	pthread_mutex_unlock(&ampua_sess-&gtlock);\newlineend:\newline	rcu_read_unlock();\newline	return ret;\newline}\newline",\newline Enable event for a channel from a UST session for a specific PID.\newline \newline,5211902,dynar.cpp,"void *xbt_dynar_push_ptr(xbt_dynar_t const dynar)\newline{\newline  return xbt_dynar_insert_at_ptr(dynar, dynar-&gtused);\newline}\newline","@brief Make room at the end of the dynar for a new element, and return a pointer to it.\newline \newline You can then use regular affectation to set its value instead of relying on the slow memcpy. This is what\newline xbt_dynar_push_as() does.\newline \newline",3518470,vnc.c,"static void kbd_handle_ptr(int buttonMask, int x, int y, rfbClientPtr cl)\newline{\newline	int dx, dy;\newline	char b1 = 0x8;\newline\newline	/* The VNC mask and the PS/2 button encoding are the same */\newline	b1 |= buttonMask;\newline\newline	if (xlast &gt= 0 &amp&amp ylast &gt= 0) {\newline		/* The PS/2 mouse sends deltas, not absolutes */\newline		dx = x - xlast;\newline		dy = ylast - y;\newline\newline		/* Set overflow bits if needed */\newline		if (dy &gt 255)\newline			b1 |= 0x80;\newline		if (dx &gt 255)\newline			b1 |= 0x40;\newline\newline		/* Set negative bits if needed */\newline		if (dy &lt 0)\newline			b1 |= 0x20;\newline		if (dx &lt 0)\newline			b1 |= 0x10;\newline\newline		mouse_queue(b1);\newline		mouse_queue(dx);\newline		mouse_queue(dy);\newline	}\newline\newline	xlast = x;\newline	ylast = y;\newline	rfbDefaultPtrAddEvent(buttonMask, x, y, cl);\newline}\newline",\newline This function is called by the VNC server whenever a mouse event occurs.\newline \newline,6641341,installwatch.c,static int instw_new(instw_t *instw) {\newline	int rcod=0;\newline\newline	*instw=__instw;\newline\newline	instw-&gterror=0;\newline	instw-&gtstatus=0;\newline	instw-&gtpath[0]=&#039\\0&#039;\newline	instw-&gtreslvpath[0]=&#039\\0&#039;\newline	instw-&gttruepath[0]=&#039\\0&#039;\newline	instw-&gttranslpath[0]=&#039\\0&#039;\newline	instw-&gtequivpaths=NULL;\newline	instw-&gtmtranslpath[0]=&#039\\0&#039;\newline	instw-&gtmdirlspath[0]=&#039\\0&#039;\newline\newline	return rcod;\newline}\newline,\newline procedure = / rc:=instw_new(instw) /\newline \newline task = / Initializes a new instw_t structure before any work on it /\newline \newline returns = / 0 ok. ready to be used\newline -1 failed. /\newline \newline,4854570,lxt.c,static char* vcdid(\newline  int value  /*!&lt Unique ID for a specific signal */\newline) { PROFILE(VCDID);\newline\newline  static char buf[16];\newline  int         i;\newline\newline  for( i=0; i&lt15; i++ ) {\newline    buf[i] = (char)((value % 94) + 33); /* for range 33..126 */\newline    value  = value / 94;\newline    if( !value ) {\newline      buf[i+1] = 0;\newline      break;\newline    }\newline  }\newline\newline  PROFILE_END;\newline\newline  return( buf );\newline\newline}\newline,!\newline\\return Returns a unique string ID for the given value\newline \newline,4385377,asteroid.c,"static void print_date(char *title, struct ln_zonedate *date)\newline{\newline	fprintf(stdout, &quot\\n%s\\n&quot,title);\newline	fprintf(stdout, &quot Year    : %d\\n&quot, date-&gtyears);\newline	fprintf(stdout, &quot Month   : %d\\n&quot, date-&gtmonths);\newline	fprintf(stdout, &quot Day     : %d\\n&quot, date-&gtdays);\newline	fprintf(stdout, &quot Hours   : %d\\n&quot, date-&gthours);\newline	fprintf(stdout, &quot Minutes : %d\\n&quot, date-&gtminutes);\newline	fprintf(stdout, &quot Seconds : %f\\n&quot, date-&gtseconds);\newline}\newline",just prints the date \newline,3832268,planner.c,"static double fftw_measure_runtime(fftw_plan plan,\newline				   fftw_complex *in, int istride,\newline				   fftw_complex *out, int ostride)\newline{\newline     fftw_time begin, end, start;\newline     double t, tmax, tmin;\newline     int i, iter;\newline     int n;\newline     int repeat;\newline     int howmany = plan-&gtvector_size;\newline\newline     n = plan-&gtn;\newline\newline     iter = 1;\newline\newline     for (;;) {\newline	  tmin = 1.0E10;\newline	  tmax = -1.0E10;\newline	  init_test_array(in, istride, n * howmany);\newline\newline	  start = fftw_get_time();\newline	  /* repeat the measurement FFTW_TIME_REPEAT times */\newline	  for (repeat = 0; repeat &lt FFTW_TIME_REPEAT; ++repeat) {\newline	       begin = fftw_get_time();\newline	       for (i = 0; i &lt iter; ++i) {\newline		    fftw(plan, howmany, in, istride, istride,\newline			 out, ostride, ostride);\newline	       }\newline	       end = fftw_get_time();\newline\newline	       t = fftw_time_to_sec(fftw_time_diff(end, begin));\newline	       if (t &lt tmin)\newline		    tmin = t;\newline	       if (t &gt tmax)\newline		    tmax = t;\newline\newline	       /* do not run for too long */\newline	       t = fftw_time_to_sec(fftw_time_diff(end, start));\newline	       if (t &gt FFTW_TIME_LIMIT)\newline		    break;\newline	  }\newline\newline	  if (tmin &gt= FFTW_TIME_MIN)\newline	       break;\newline\newline	  iter *= 2;\newline     }\newline\newline     tmin /= (double) iter;\newline     tmax /= (double) iter;\newline\newline     return tmin;\newline}\newline",\newline The timer keeps doubling the number of iterations\newline until the program runs for more than FFTW_TIME_MIN\newline \newline,5833185,lxlogic.c,static int stopanimationat(int pos)\newline{\newline    creature   *anim;\newline\newline    for (anim = creaturelist() ; anim-&gtid ; ++anim) {\newline	if (!anim-&gthidden &amp&amp anim-&gtpos == pos &amp&amp isanimation(anim-&gtid)) {\newline	    removeanimation(anim);\newline	    return TRUE;\newline	}\newline    }\newline    return FALSE;\newline}\newline,Abort the animation sequence occuring at the given location.\newline \newline,5833223,mslogic.c,"static creature *prependtosliplist(creature *cr, int dir)\newline{\newline    int	n;\newline\newline    if (slipcount &amp&amp slips[0].cr == cr) {\newline	slips[0].dir = dir;\newline	return cr;\newline    }\newline\newline    if (slipcount &gt= slipsallocated) {\newline	slipsallocated = slipsallocated ? slipsallocated * 2 : 16;\newline	slips = realloc(slips, slipsallocated * sizeof *slips);\newline	if (!slips)\newline	    memerrexit();\newline    }\newline    for (n = slipcount ; n ; --n)\newline	slips[n] = slips[n - 1];\newline    ++slipcount;\newline    slips[0].cr = cr;\newline    slips[0].dir = dir;\newline    return cr;\newline}\newline",Add the given creature to the start of the slip list.\newline \newline,279870,redactval.c,"static p_redact_val redact_val_init( const char* name, \newline                                     const uint32_t len,\newline                                     const char* value )\newline{\newline    p_redact_val res = NULL;\newline    if ( name == NULL ) return res;\newline    if ( name[0] == 0 ) return res;\newline    res = calloc( 1, sizeof( redact_val ) );\newline    if ( res == NULL ) return res;\newline    res-&gtname = string_dup_measure ( name, NULL );\newline    res-&gtlen = len;\newline    res-&gtvalue = NULL;\newline    if ( value != NULL )\newline    {\newline        if ( value[0] == &#039\\&#039&#039 &amp&amp value[2] == &#039\\&#039&#039 )\newline        {\newline            res-&gtvalue = malloc( sizeof value[0] );\newline            if ( res-&gtvalue )\newline            {\newline                res-&gtlen = 1;\newline                *( ( char * )res-&gtvalue ) = value[1];\newline            }\newline        }\newline        else\newline        {\newline            char *endptr;\newline            uint64_t x = strtou64( value, &ampendptr, 0 );\newline            if ( res-&gtlen &gt sizeof x )\newline                res-&gtlen = sizeof x;\newline            res-&gtvalue = malloc( len );\newline            if ( res-&gtvalue )\newline                memmove( res-&gtvalue, &ampx, res-&gtlen );\newline        }\newline    }\newline    return res;\newline}\newline",allocate a redact-value \newline,637978,tcp_illinois.c,static inline u32 max_delay(const struct illinois *ca)\newline{\newline	return ca-&gtmax_rtt - ca-&gtbase_rtt;\newline}\newline,Maximum queuing delay \newline,4524578,linux-cuda.c,"static int papicuda_init_component( int cidx )\newline{\newline    SUBDBG( &quotEntering with cidx: %d\\n&quot, cidx );\newline    int err;\newline\newline    /* link in all the cuda libraries and resolve the symbols we need to use */\newline    if( papicuda_linkCudaLibraries() != PAPI_OK ) {\newline        SUBDBG (&quotDynamic link of CUDA libraries failed, component will be disabled.\\n&quot);\newline        SUBDBG (&quotSee disable reason in papi_component_avail output for more details.\\n&quot);\newline        return (PAPI_ENOSUPP);\newline    }\newline\newline    /* Create the structure */\newline    if ( !global_papicuda_context )\newline        global_papicuda_context = ( papicuda_context_t* ) papi_calloc( 1, sizeof( papicuda_context_t ) );\newline\newline    /* Get list of all native CUDA events supported */\newline    err = papicuda_list_all_events( global_papicuda_context );\newline    if ( err!=0 ) return( err );\newline\newline    /* Export some information */\newline    _cuda_vector.cmp_info.CmpIdx = cidx;\newline    _cuda_vector.cmp_info.num_native_events = global_papicuda_context-&gtavailEventSize;\newline    _cuda_vector.cmp_info.num_cntrs = _cuda_vector.cmp_info.num_native_events;\newline    _cuda_vector.cmp_info.num_mpx_cntrs = _cuda_vector.cmp_info.num_native_events;\newline\newline    //SUBDBG( &quotExiting PAPI_OK\\n&quot );\newline    return ( PAPI_OK );\newline}\newline","NOTE: only called by main thread (not by every thread) !!! Starting\newlinein CUDA 4.0, multiple CPU threads can access the same CUDA\newlinecontext. This is a much easier programming model then pre-4.0 as\newlinethreads - using the same context - can share memory, data,\newlineetc. It&#039s possible to create a different context for each thread.\newlineThat&#039s why CUDA context creation is done in CUDA_init_component()\newline(called only by main thread) rather than CUDA_init() or\newlineCUDA_init_control_state() (both called by each thread). \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4500387,world.c,"static void register_world( World *wld )\newline{\newline	worlds_list = xrealloc( worlds_list,\newline			( worlds_count + 1 ) * sizeof( World * ) );\newline\newline	worlds_list[worlds_count] = wld;\newline	worlds_count++;\newline}\newline",Add a world to the global list of worlds. \newline,2840953,mgrutil.c,SML_API void smlFreeDevInfDevInf(SmlDevInfDevInfPtr_t data) {\newline    if (!data) return;\newline    smlFreePcdata(data-&gtverdtd);\newline    smlFreePcdata(data-&gtman);\newline    smlFreePcdata(data-&gtmod);\newline    smlFreePcdata(data-&gtoem);\newline    smlFreePcdata(data-&gtfwv);\newline    smlFreePcdata(data-&gthwv);\newline    smlFreePcdata(data-&gtswv);\newline    smlFreePcdata(data-&gtdevid);\newline    smlFreePcdata(data-&gtdevtyp);\newline    smlFreeDevInfDatastoreList(data-&gtdatastore);\newline    smlFreeDevInfExtList(data-&gtext);\newline    smlFreeDevInfCtcapList(data-&gtctcap);\newline    smlLibFree(data);\newline}\newline,"Subfunctions to smlFreePcdata, to freeup DevInf DTD structures \newline",4474700,my_con.c,"struct my_con* db_sqlite_new_connection(const struct db_id* id)\newline{\newline\newline	struct my_con* ptr;\newline\newline	if (!id) {\newline		LM_ERR(&quotinvalid parameter value\\n&quot);\newline		return 0;\newline	}\newline\newline	ptr = (struct my_con*)pkg_malloc(sizeof(struct my_con));\newline	if (!ptr) {\newline		LM_ERR(&quotno private memory left\\n&quot);\newline		return 0;\newline	}\newline\newline	memset(ptr, 0, sizeof(struct my_con));\newline	ptr-&gtref = 1;\newline\newline	ptr-&gtid = (struct db_id*)id;\newline\newline	if (db_sqlite_connect(ptr)!=0) {\newline		LM_ERR(&quotinitial connect failed\\n&quot);\newline		goto err;\newline	}\newline	return ptr;\newlineerr:\newline	if (ptr &amp&amp ptr-&gtcon) pkg_free(ptr-&gtcon);\newline	if (ptr) pkg_free(ptr);\newline	return 0;\newline}\newline","\newline Create a new connection structure,\newline open the sqlite connection and set reference count to 1\newline \newline",5262358,win32_print.c,"char *GetSystemFontDir(void)\newline{\newline  char path[MAX_PATH];\newline  const char *key =\newline    &quotSoftware\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders&quot;\newline  const char *option = &quotFonts&quot;\newline  HRESULT hr = S_OK;\newline\newline  if (SUCCEEDED(hr = ReadRegistry(key, option, path, sizeof(path))))\newline  {\newline    remove_slash(path);\newline    return strdup(path);\newline  }\newline  return strdup(&quotC:\\\\WINDOWS\\\\FONTS&quot);\newline}\newline",\newlineReturns heap string containing system font directory.\newlineE.g. &#039C:\\Windows\\Fonts&#039\newline \newline,6407310,server.cpp,IBMSClientConn::~IBMSClientConn()\newline{\newline    MSG_ENTER_FUNC;\newline    /* NOTE: each mad processor will lock the node */\newline    for(list_pmad_proc::iterator lI = madProcessors.begin();\newline            lI != madProcessors.end(); ++lI) {\newline        delete *lI;\newline    }\newline    MSG_EXIT_FUNC;\newline}\newline,destructor - needs to cleanup any binding done through this conn \newline,6164973,formdata.c,"static curl_off_t VmsSpecialSize(const char * name,\newline                                 const struct_stat * stat_buf)\newline{\newline  switch(stat_buf-&gtst_fab_rfm) {\newline  case FAB$C_VAR:\newline  case FAB$C_VFC:\newline    return VmsRealFileSize(name, stat_buf);\newline    break;\newline  default:\newline    return stat_buf-&gtst_size;\newline  }\newline}\newline",\newline \newline VmsSpecialSize checks to see if the stat st_size can be trusted and\newline if not to call a routine to get the correct size.\newline \newline \newline,1836433,gba_nds_fat.c,"u8 FAT_GetFileAttributes (void)\newline{\newline	// Read in the last accessed directory entry\newline	disc_ReadSector ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector, globalBuffer);\newline\newline	return 	((DIR_ENT*)globalBuffer)[wrkDirOffset].attrib;\newline}\newline",-----------------------------------------------------------------\newlineFAT_GetFileAttributes\newlineGet the attributes of the last file found or openned.\newlineu8 return OUT: the file&#039s attributes\newline----------------------------------------------------------------- \newline,1248375,pcap-rpcap.c,"static int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog)\newline{\newline	struct rpcap_filter *filter;\newline	struct rpcap_filterbpf_insn *insn;\newline	struct bpf_insn *bf_insn;\newline	struct bpf_program fake_prog;		/* To be used just in case the user forgot to set a filter */\newline	unsigned int i;\newline\newline\newline	if (prog-&gtbf_len == 0)	/* No filters have been specified; so, let&#039s apply a &quotfake&quot filter */\newline	{\newline		if (pcap_compile(fp, &ampfake_prog, NULL /* buffer */, 1, 0) == -1)\newline			return -1;\newline\newline		prog = &ampfake_prog;\newline	}\newline\newline	filter = (struct rpcap_filter *) sendbuf;\newline\newline	if (sock_bufferize(NULL, sizeof(struct rpcap_filter), NULL, sendbufidx,\newline		RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gterrbuf, PCAP_ERRBUF_SIZE))\newline		return -1;\newline\newline	filter-&gtfiltertype = htons(RPCAP_UPDATEFILTER_BPF);\newline	filter-&gtnitems = htonl((int32)prog-&gtbf_len);\newline\newline	if (sock_bufferize(NULL, prog-&gtbf_len * sizeof(struct rpcap_filterbpf_insn),\newline		NULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp-&gterrbuf, PCAP_ERRBUF_SIZE))\newline		return -1;\newline\newline	insn = (struct rpcap_filterbpf_insn *) (filter + 1);\newline	bf_insn = prog-&gtbf_insns;\newline\newline	for (i = 0; i &lt prog-&gtbf_len; i++)\newline	{\newline		insn-&gtcode = htons(bf_insn-&gtcode);\newline		insn-&gtjf = bf_insn-&gtjf;\newline		insn-&gtjt = bf_insn-&gtjt;\newline		insn-&gtk = htonl(bf_insn-&gtk);\newline\newline		insn++;\newline		bf_insn++;\newline	}\newline\newline	return 0;\newline}\newline","\newline \\brief Takes a bpf program and sends it to the other host.\newline \newline This function can be called in two cases:\newline - the pcap_startcapture() is called (we have to send the filter along with\newline the &#039start capture&#039 command)\newline - we want to udpate the filter during a capture (i.e. the pcap_setfilter()\newline is called when the capture is still on)\newline \newline This function serializes the filter into the sending buffer (&#039sendbuf&#039, passed\newline as a parameter) and return back. It does not send anything on the network.\newline \newline \\param fp: the pcap_t descriptor of the device currently opened.\newline \newline \\param sendbuf: the buffer on which the serialized data has to copied.\newline \newline \\param sendbufidx: it is used to return the abounf of bytes copied into the buffer.\newline \newline \\param prog: the bpf program we have to copy.\newline \newline \\return &#0390&#039 if everything is fine, &#039-1&#039 otherwise. The error message (if one)\newline is returned into the &#039errbuf&#039 field of the pcap_t structure.\newline \newline",,,,on,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Enable event for a channel,allocate a redact-value,Maximum queuing delay,{},Load an image from the named file.,Add a world to the global list of worlds.,"Subfunctions to smlFreePcdata,","Create a new connection structure,",Returns heap string containing system font directory.,needs to cleanup any binding done through this conn,checks to see if the stat st_size can be trusted,You can then use regular affectation,Get the attributes of the last file found or openned.,{},This function is called by the VNC server,Initializes a new instw_t structure before any work on it,Returns a unique string ID for the given value,just prints the date,The timer keeps doubling the number of iterations,Abort the animation sequence,Add the given creature,x,
3IWA71V4TIGA0RWCTZVF8EONW8R6XD,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:48 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:48 PDT 2019,,,3G0WWMR1UVK0LZYLW4R550A5CQBNQ9,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:54 PDT 2019,Fri Apr 26 13:22:58 PDT 2019,Sun Apr 28 13:22:58 PDT 2019,,,,2044,100% (62/62),100% (62/62),0% (0/0),3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,5964548,im.c,"faim_export int aim_im_sendch2_sendfile_ask(aim_session_t *sess, struct aim_oft_info *oft_info)\newline{\newline	aim_conn_t *conn;\newline	aim_frame_t *fr;\newline	aim_snacid_t snacid;\newline	aim_tlvlist_t *tl=NULL, *subtl=NULL;\newline	int i;\newline\newline	if (!sess || !(conn = aim_conn_findbygroup(sess, 0x0004)) || !oft_info)\newline		return -EINVAL;\newline\newline	/* XXX - Should be like &quot21CBF95&quot and null terminated */\newline	for (i = 0; i &lt 7; i++)\newline		oft_info-&gtcookie[i] = 0x30 + ((fu8_t)rand() % 10);\newline	oft_info-&gtcookie[7] = &#039\\0&#039;\newline\newline	{ /* Create the subTLV chain */\newline		fu8_t *buf;\newline		int buflen;\newline		aim_bstream_t bs;\newline\newline		aim_tlvlist_add_16(&ampsubtl, 0x000a, 0x0001);\newline		aim_tlvlist_add_noval(&ampsubtl, 0x000f);\newline/*		aim_tlvlist_add_raw(&ampsubtl, 0x000e, 2, &quoten&quot);\newline		aim_tlvlist_add_raw(&ampsubtl, 0x000d, 8, &quotus-ascii&quot);\newline		aim_tlvlist_add_raw(&ampsubtl, 0x000c, 24, &quotPlease accept this file.&quot); */\newline		/* XXX - Change oft_info-&gtclientip to an array of 4 bytes */\newline		if (oft_info-&gtclientip) {\newline			fu8_t ip[4];\newline			char *nexttoken;\newline			int i = 0;\newline			nexttoken = strtok(oft_info-&gtclientip, &quot.&quot);\newline			while (nexttoken &amp&amp i&lt4) {\newline				ip[i] = atoi(nexttoken);\newline				nexttoken = strtok(NULL, &quot.&quot);\newline				i++;\newline			}\newline			aim_tlvlist_add_raw(&ampsubtl, 0x0003, 4, ip);\newline		}\newline		aim_tlvlist_add_16(&ampsubtl, 0x0005, oft_info-&gtport);\newline\newline		/* TLV t(2711) */\newline		buflen = 2+2+4+strlen(oft_info-&gtfh.name)+1;\newline		buf = malloc(buflen);\newline		aim_bstream_init(&ampbs, buf, buflen);\newline		aimbs_put16(&ampbs, (oft_info-&gtfh.totfiles &gt 1) ? 0x0002 : 0x0001);\newline		aimbs_put16(&ampbs, oft_info-&gtfh.totfiles);\newline		aimbs_put32(&ampbs, oft_info-&gtfh.totsize);\newline\newline		/* Filename - NULL terminated, for some odd reason */\newline		aimbs_putraw(&ampbs, oft_info-&gtfh.name, strlen(oft_info-&gtfh.name));\newline		aimbs_put8(&ampbs, 0x00);\newline\newline		aim_tlvlist_add_raw(&ampsubtl, 0x2711, bs.len, bs.data);\newline		free(buf);\newline	}\newline\newline	{ /* Create the main TLV chain */\newline		fu8_t *buf;\newline		int buflen;\newline		aim_bstream_t bs;\newline\newline		/* TLV t(0005) - Encompasses everything from above. Gee. */\newline		buflen = 2+8+16+aim_tlvlist_size(&ampsubtl);\newline		buf = malloc(buflen);\newline		aim_bstream_init(&ampbs, buf, buflen);\newline		aimbs_put16(&ampbs, AIM_RENDEZVOUS_PROPOSE);\newline		aimbs_putraw(&ampbs, oft_info-&gtcookie, 8);\newline		aim_putcap(&ampbs, AIM_CAPS_SENDFILE);\newline		aim_tlvlist_write(&ampbs, &ampsubtl);\newline		aim_tlvlist_free(&ampsubtl);\newline		aim_tlvlist_add_raw(&amptl, 0x0005, bs.len, bs.data);\newline		free(buf);\newline\newline		/* TLV t(0003) - Request an ack */\newline		aim_tlvlist_add_noval(&amptl, 0x0003);\newline	}\newline\newline	if (!(fr = aim_tx_new(sess, conn, AIM_FRAMETYPE_FLAP, 0x02, 10 + 11+strlen(oft_info-&gtsn) + aim_tlvlist_size(&amptl))))\newline		return -ENOMEM;\newline\newline	snacid = aim_cachesnac(sess, 0x0004, 0x0006, AIM_SNACFLAGS_DESTRUCTOR, oft_info-&gtcookie, sizeof(oft_info-&gtcookie));\newline	aim_putsnac(&ampfr-&gtdata, 0x0004, 0x0006, 0x0000, snacid);\newline\newline	/* ICBM header */\newline	aim_im_puticbm(&ampfr-&gtdata, oft_info-&gtcookie, 0x0002, oft_info-&gtsn);\newline\newline	/* All that crap from above (the 0x0005 TLV and the 0x0003 TLV) */\newline	aim_tlvlist_write(&ampfr-&gtdata, &amptl);\newline	aim_tlvlist_free(&amptl);\newline\newline	aim_tx_enqueue(sess, fr);\newline\newline	return 0;\newline}\newline",\newline Subtype 0x0006 - Send an &quotI want to send you this file&quot message\newline \newline \newline,2668286,optimize.c,"int add_parents(ParseTreeNode *node,ParseTreeNode *parent)\newline{\newline    int nodes=1; /* This node */\newline    node-&gtparent=parent;\newline\newline    assert(node-&gtlabel_right==LABEL_NOTKNOWN);\newline	\newline    node-&gtrefcount=0;\newline    if (node-&gtoper==PHRASE)\newline    {\newline	node-&gtleaf-&gtparent=node;\newline    } else\newline    {\newline	assert(node-&gtleft!=NULL);\newline	nodes+=add_parents(node-&gtleft,node);\newline	if (node-&gtright!=NULL)\newline	{\newline	    nodes+=add_parents(node-&gtright,node);\newline	}\newline    }\newline    return nodes;\newline}\newline",\newline Recursively adds pointers to parents to every tree and phrase node \newline counts also operator tree size\newline \newline,5584056,amule-remote-gui.cpp,"CUpDownClientListRem::CUpDownClientListRem(CRemoteConnect *conn)\newline:\newlineCRemoteContainer&ltCClientRef, uint32, CEC_UpDownClient_Tag&gt(conn, true)\newline{\newline}\newline",\newline List of uploading and waiting clients.\newline \newline,429713,coordinate.cpp,"void rotate_ecliptic_to_equator(double obl, struct rectangular_coordinates *pos)\newline{\newline	double co,so;\newline	struct rectangular_coordinates tmp;\newline\newline	sincos(obl, &ampso, &ampco);\newline\newline	tmp.y = pos-&gty * co - pos-&gtz * so;\newline	tmp.z = pos-&gty * so + pos-&gtz * co;\newline\newline	pos-&gty = tmp.y;\newline	pos-&gtz = tmp.z;\newline}",\newline Rotates rectangular coordinates in the ecliptic frame to the equatorial frame.\newline \newline obl -- The obliquity of the ecliptic in radians.\newline pos -- The coordinates to be rotated in-place.\newline \newline,1195130,cleankey.c,"int dedupsubkeys(struct openpgp_publickey *key)\newline{\newline	struct openpgp_signedpacket_list *cursubkey = NULL;\newline	struct openpgp_signedpacket_list *dup = NULL;\newline	struct openpgp_signedpacket_list *tmp = NULL;\newline	int                               merged = 0;\newline	uint64_t                          subkeyid;\newline\newline	log_assert(key != NULL);\newline	cursubkey = key-&gtsubkeys;\newline	while (cursubkey != NULL) {\newline		dup = find_signed_packet(cursubkey-&gtnext, cursubkey-&gtpacket);\newline		while (dup != NULL) {\newline			get_packetid(cursubkey-&gtpacket, &ampsubkeyid);\newline			logthing(LOGTHING_INFO,\newline				&quotFound duplicate subkey: 0x%016&quot PRIX64,\newline				subkeyid);\newline			merged++;\newline			merge_packet_sigs(cursubkey, dup);\newline			/*\newline			 * Remove the duplicate uid.\newline			 */\newline			tmp = cursubkey;\newline			while (tmp != NULL &amp&amp tmp-&gtnext != dup) {\newline				tmp = tmp-&gtnext;\newline			}\newline			log_assert(tmp != NULL);\newline			tmp-&gtnext = dup-&gtnext;\newline			dup-&gtnext = NULL;\newline			free_signedpacket_list(dup);\newline\newline			dup = find_signed_packet(cursubkey-&gtnext,\newline				cursubkey-&gtpacket);\newline		}\newline		cursubkey = cursubkey-&gtnext;\newline	}\newline\newline	return merged;\newline}\newline","\newline dedupsubkeys - Merge duplicate subkeys on a key.\newline @key: The key to de-dup subkeys on.\newline \newline This function attempts to merge duplicate subkeys on a key. It returns\newline 0 if the key is unchanged, otherwise the number of dups merged.\newline \newline",1763936,tomarkedtext.cpp,"QMenu *toMarkedText::createPopupMenu(const QPoint&amp pos)\newline{\newline    Q_UNUSED(pos);\newline\newline    const bool isEmptyDocument = (lines() == 0);\newline\newline    // create menu\newline    QMenu   *popup = new QMenu(this);\newline    QAction *action;\newline\newline    if (!isReadOnly())\newline    {\newline        action = popup-&gtaddAction(QIcon(undo_xpm),\newline                                  tr(&quot&ampUndo&quot),\newline                                  this,\newline                                  SLOT(undo()));\newline        action-&gtsetShortcut(QKeySequence::Undo);\newline        action-&gtsetEnabled(isUndoAvailable());\newline\newline        action = popup-&gtaddAction(QIcon(redo_xpm),\newline                                  tr(&quot&ampRedo&quot),\newline                                  this,\newline                                  SLOT(redo()));\newline        action-&gtsetShortcut(QKeySequence::Redo);\newline        action-&gtsetEnabled(isRedoAvailable());\newline\newline        popup-&gtaddSeparator();\newline\newline        action = popup-&gtaddAction(QIcon(cut_xpm),\newline                                  tr(&quotCu&ampt&quot),\newline                                  this,\newline                                  SLOT(cut()));\newline        action-&gtsetShortcut(QKeySequence::Cut);\newline        action-&gtsetToolTip(tr(&quotCut to clipboard&quot));\newline        action-&gtsetEnabled(hasSelectedText());\newline\newline        action = popup-&gtaddAction(QIcon(copy_xpm),\newline                                  tr(&quot&ampCopy&quot),\newline                                  this,\newline                                  SLOT(copy()));\newline        action-&gtsetShortcut(QKeySequence::Copy);\newline        action-&gtsetToolTip(tr(&quotCopy to clipboard&quot));\newline        action-&gtsetEnabled(hasSelectedText());\newline\newline        action = popup-&gtaddAction(QIcon(paste_xpm),\newline                                  tr(&quot&ampPaste&quot),\newline                                  this,\newline                                  SLOT(paste()));\newline        action-&gtsetShortcut(QKeySequence::Paste);\newline        action-&gtsetToolTip(tr(&quotPaste from clipboard&quot));\newline        action-&gtsetEnabled(!QApplication::clipboard()-&gttext(\newline                               QClipboard::Clipboard).isEmpty());\newline\newline        action = popup-&gtaddAction(tr(&quotClear&quot),\newline                                  this,\newline                                  SLOT(clear()));\newline        action-&gtsetToolTip(tr(&quotClear editor&quot));\newline        action-&gtsetEnabled(!isEmptyDocument);\newline\newline        popup-&gtaddSeparator();\newline    }\newline\newline    action = popup-&gtaddAction(tr(&quotSelect &ampAll&quot),\newline                              this,\newline                              SLOT(selectAll()));\newline    action-&gtsetShortcut(QKeySequence::SelectAll);\newline    action-&gtsetEnabled(!isEmptyDocument);\newline\newline    return popup;\newline}\newline","\newline This function is called to create a right mouse button popup menu\newline at the specified position. If you want to create a custom popup menu,\newline reimplement this function and return the created popup menu. Ownership\newline of the popup menu is transferred to the caller.\newline \newline",3954519,file.cpp,"File *load_file(const char * const filename)\newline{\newline	char fname[256];\newline	sprintf(fname, &quotdata/%s&quot, filename);\newline\newline#if !DEMOLIB_SILENT\newline	printf(&quot%s\\n&quot, fname);\newline#endif\newline	\newline#if DEMOLIB_DATA_ZLIB\newline	if (strlen(filename) &gt 6 &amp&amp\newline	    strncmp(filename, &quotzlib:&quot, 5) == 0) {\newline		File *tempfile = load_file(filename + 5);\newline		ZFile *zf = new ZFile(tempfile);\newline		delete tempfile;\newline		return zf;\newline	}\newline#endif\newline	\newline#if DEMOLIB_DATA_DIR_NONMMAP\newline	try {\newline		return new MemFile(fname);\newline	} catch (NonFatalException *e) {}\newline#endif\newline\newline#if DEMOLIB_DATA_PAKFILE\newline	try {\newline		return new PakFile(fname);\newline	} catch (NonFatalException *e) {}\newline#endif\newline	\newline	sprintf(fname, &quot%s not found&quot, filename);	\newline	throw new FileNotFoundException(fname);\newline}\newline","\newline Gives a File (from data/, data.tar or the `demodata&#039 symbol from the exe).\newline \newline",4486657,cg_playerstate.c,"void CG_CheckChangedPredictableEvents( playerState_t *ps ) {\newline	int i;\newline	int event;\newline	centity_t	*cent;\newline\newline	cent = &ampcg.predictedPlayerEntity;\newline	for ( i = ps-&gteventSequence - MAX_PS_EVENTS ; i &lt ps-&gteventSequence ; i++ ) {\newline		//\newline		if (i &gt= cg.eventSequence) {\newline			continue;\newline		}\newline		// if this event is not further back in than the maximum predictable events we remember\newline		if (i &gt cg.eventSequence - MAX_PREDICTED_EVENTS) {\newline			// if the new playerstate event is different from a previously predicted one\newline			if ( ps-&gtevents[i &amp (MAX_PS_EVENTS-1)] != cg.predictableEvents[i &amp (MAX_PREDICTED_EVENTS-1) ] ) {\newline\newline				event = ps-&gtevents[ i &amp (MAX_PS_EVENTS-1) ];\newline				cent-&gtcurrentState.event = event;\newline				cent-&gtcurrentState.eventParm = ps-&gteventParms[ i &amp (MAX_PS_EVENTS-1) ];\newline				CG_EntityEvent( cent, cent-&gtlerpOrigin );\newline\newline				cg.predictableEvents[ i &amp (MAX_PREDICTED_EVENTS-1) ] = event;\newline\newline				if ( cg_showmiss.integer ) {\newline					CG_Printf(&quotWARNING: changed predicted event\\n&quot);\newline				}\newline			}\newline		}\newline	}\newline}\newline",\newline==================\newlineCG_CheckChangedPredictableEvents\newline==================\newline \newline,1241070,ml1.c,"void optexternalbranch(Node *op)\newline{\newline	double arc, fx, f2x;\newline\newline	partiali = op-&gtisop-&gtpartials;\newline	seqchi = op-&gtkinp-&gteprob;\newline	arc = op-&gtlength; /* nonclocklike branch lengths */\newline	if (arc &lt= MINARC) arc = MINARC+1.0;\newline	if (arc &gt= MAXARC) arc = MAXARC-1.0;\newline	arc = onedimenmin(MINARC, arc, MAXARC, extlkl, EPSILON_BRANCH, &ampfx, &ampf2x);\newline	op-&gtkinp-&gtlength = arc;\newline	op-&gtlength = arc;\newline	\newline	 /* variance of branch length */\newline	f2x = fabs(f2x);\newline	if (1.0/(MAXARC*MAXARC) &lt f2x)\newline		op-&gtvarlen = 1.0/f2x;\newline	else\newline		op-&gtvarlen = MAXARC*MAXARC;\newline} /* optexternalbranch */\newline",optimize external branch \newline,5201549,gsm-bitmaps.c,"GNOKII_API int gn_bmp_sms_encode(gn_bmp *bitmap, unsigned char *message)\newline{\newline	unsigned int current = 0;\newline\newline	switch (bitmap-&gttype) {\newline	case GN_BMP_OperatorLogo:\newline		/* Set the network code */\newline		dprintf(&quotOperator Logo\\n&quot);\newline		message[current++] = ((bitmap-&gtnetcode[1] &amp 0x0f) &lt&lt 4) | (bitmap-&gtnetcode[0] &amp 0xf);\newline		message[current++] = 0xf0 | (bitmap-&gtnetcode[2] &amp 0x0f);\newline		message[current++] = ((bitmap-&gtnetcode[5] &amp 0x0f) &lt&lt 4) | (bitmap-&gtnetcode[4] &amp 0xf);\newline		break;\newline	case GN_BMP_PictureMessage:\newline		dprintf(&quotPicture Image\\n&quot);\newline\newline		/* Set the logo size */\newline		message[current++] = 0x00;\newline		message[current++] = bitmap-&gtwidth;\newline		message[current++] = bitmap-&gtheight;\newline		message[current++] = 0x01;\newline\newline		memcpy(message + current, bitmap-&gtbitmap, bitmap-&gtsize);\newline		current = current + bitmap-&gtsize;\newline		return current;\newline	case GN_BMP_EMSPicture:\newline		dprintf(&quotEMS picture\\n&quot);\newline		if (bitmap-&gtwidth % 8) {\newline			dprintf(&quotEMS needs bitmap size 8, 16, 24, ... \\n&quot);\newline			return GN_ERR_NOTSUPPORTED;\newline		}\newline		message[current++] = bitmap-&gtwidth / 8 * bitmap-&gtheight + 5;\newline		message[current++] = 0x12;              /* Picture code */\newline		message[current++] = bitmap-&gtwidth / 8 * bitmap-&gtheight + 3; /* Picture size */;\newline		message[current++] = 0;		        /* Position in text this picture is at */\newline		message[current++] = bitmap-&gtwidth / 8; /* Horizontal size / 8 */\newline		message[current++] = bitmap-&gtheight;\newline		break;\newline	case GN_BMP_EMSAnimation:\newline		dprintf(&quotEMS animation\\n&quot);\newline		message[current++] = 128 + 3;\newline		message[current++] = 0x0e; 	/* Animation code */\newline		message[current++] = 128 + 1;   /* Picture size */;\newline		message[current++] = 0x00; 	/* Position where to display */\newline	case GN_BMP_EMSAnimation2:\newline		dprintf(&quot(without header)\\n&quot);\newline		if (bitmap-&gtwidth != 16) {\newline			dprintf(&quotEMS animation needs bitmap 16x16 ... \\n&quot);\newline			return GN_ERR_NOTSUPPORTED;\newline		}\newline		break;\newline	default: /* error */\newline		dprintf(&quotgulp?\\n&quot);\newline		break;\newline	}\newline\newline	switch (bitmap-&gttype) {\newline	case GN_BMP_EMSPicture:\newline	case GN_BMP_EMSAnimation:\newline	case GN_BMP_EMSAnimation2:\newline		break;\newline	default:			/* Add common nokia headers */\newline		/* Info field */\newline		message[current++] = 0x00;\newline\newline		/* Logo size */\newline		message[current++] = bitmap-&gtwidth;\newline		message[current++] = bitmap-&gtheight;\newline\newline		/* Number of colors */\newline		message[current++] = 0x01;\newline	}\newline\newline	memcpy(message + current, bitmap-&gtbitmap, bitmap-&gtsize);\newline	current += bitmap-&gtsize;\newline\newline	return current;\newline}\newline",Returns message length \newline,681227,aaio.c,"void GET_FILE_NAME(char *strin, char *strout)\newline{\newline	/* check length of string */\newline	long len;\newline	long i, c;\newline	for (i=0; strin[i]!=&#039\\0&#039; i++);\newline	len = i;\newline	/* check only path */\newline	c = 0;\newline	i = len-1;\newline	while ((i &gt= 0) &amp&amp (strin[i] != slsh)) { c++; i--; }\newline	/*if (i &gt= 0) { */\newline		for (i=0; i&ltc; i++) {\newline			if (i &lt max_char) {\newline				strout[i] = strin[i+len-c]; }\newline		}\newline		strout[i] = 0;\newline	/*} */\newline}\newline",get file name from path \newline,6581002,sndfile.c,"static int name_to_format(const char *name)\newline{\newline  int k;\newline#define FILE_TYPE_BUFLEN (size_t)15\newline  char buffer[FILE_TYPE_BUFLEN + 1], *cptr;\newline\newline  if ((cptr = strrchr(name, &#039.&#039)) != NULL) {\newline    strncpy(buffer, cptr + 1, FILE_TYPE_BUFLEN);\newline    buffer[FILE_TYPE_BUFLEN] = &#039\\0&#039;\newline\newline    for (k = 0; buffer[k]; k++)\newline      buffer[k] = tolower((buffer[k]));\newline  } else {\newline    strncpy(buffer, name, FILE_TYPE_BUFLEN);\newline    buffer[FILE_TYPE_BUFLEN] = &#039\\0&#039;\newline  }\newline\newline  for (k = 0; k &lt (int)(sizeof(format_map) / sizeof(format_map [0])); k++) {\newline    if (strcmp(buffer, format_map[k].ext) == 0)\newline      return format_map[k].format;\newline  }\newline\newline  return 0;\newline}\newline",Convert file name or type to libsndfile format \newline,5833374,series.c,"static int readseriesheader(gameseries *series)\newline{\newline    unsigned short	val16;\newline    int			ruleset;\newline\newline    if (!filereadint16(&ampseries-&gtmapfile, &ampval16, &quotnot a valid data file&quot))\newline	return FALSE;\newline    if (val16 != SIG_DATFILE)\newline	return fileerr(&ampseries-&gtmapfile, &quotnot a valid data file&quot);\newline    if (!filereadint16(&ampseries-&gtmapfile, &ampval16, &quotnot a valid data file&quot))\newline	return FALSE;\newline    switch (val16) {\newline      case SIG_DATFILE_MS:	ruleset = Ruleset_MS;		break;\newline      case SIG_DATFILE_LYNX:	ruleset = Ruleset_Lynx;		break;\newline      default:\newline	fileerr(&ampseries-&gtmapfile, &quotdata file uses an unrecognized ruleset&quot);\newline	return FALSE;\newline    }\newline    if (series-&gtruleset == Ruleset_None)\newline	series-&gtruleset = ruleset;\newline    if (!filereadint16(&ampseries-&gtmapfile, &ampval16, &quotnot a valid data file&quot))\newline	return FALSE;\newline    series-&gtcount = val16;\newline    if (!series-&gtcount) {\newline	fileerr(&ampseries-&gtmapfile, &quotfile contains no maps&quot);\newline	return FALSE;\newline    }\newline\newline    return TRUE;\newline}\newline",Examine the top of a data file and identify its type. FALSE is\newline returned if any header bytes appear to be invalid.\newline \newline,717482,unixfile.c,"JNIEXPORT jint JNICALL Java_org_eclipse_core_internal_filesystem_local_unix_UnixFileNatives_lstat\newline  (JNIEnv *env, jclass clazz, jbyteArray path, jobject buf)\newline{\newline	jint code;\newline	char *name;\newline	struct stat info;\newline\newline	name = (char*) getByteArray(env, path);\newline	code = lstat(name, &ampinfo);\newline	free(name);\newline	if (code != -1)\newline		return convertStatToObject(env, info, buf);\newline	else\newline		return code;\newline}\newline",\newline Class: org_eclipse_core_internal_filesystem_local_unix_UnixFileNatives\newline Method: lstat\newline Signature: ([BLorg/eclipse/core/internal/filesystem/local/unix/StructStat;)I\newline \newline,6369773,gfx.c,void flip_it(void)\newline{\newline  /* We work directly on either lpDDSBack (no lpDDSPrimary as in\newline     the original game): the double buffer (Back) is directly\newline     managed by SDL; SDL_Flip is used to refresh the physical\newline     screen. */\newline\newline  if (!truecolor)\newline    gfx_palette_apply_phys();\newline  \newline  if (truecolor_fade_brightness &lt 256)\newline    gfx_fade_apply(truecolor_fade_brightness);\newline\newline  SDL_Flip(GFX_lpDDSBack);\newline}\newline,"\newline Refresh the physical screen, and apply a new palette or fade effect\newline if needed\newline \newline",5465517,xshm-input.c,"static int_fast32_t xshm_update_geometry(struct xshm_data *data)\newline{\newline	int_fast32_t old_width = data-&gtwidth;\newline	int_fast32_t old_height = data-&gtheight;\newline\newline	if (data-&gtuse_xinerama) {\newline		if (xinerama_screen_geo(data-&gtxcb, data-&gtscreen_id,\newline			&ampdata-&gtx_org, &ampdata-&gty_org,\newline			&ampdata-&gtwidth, &ampdata-&gtheight) &lt 0) {\newline			return -1;\newline		}\newline		data-&gtxcb_screen = xcb_get_screen(data-&gtxcb, 0);\newline	}\newline	else {\newline		data-&gtx_org = 0;\newline		data-&gty_org = 0;\newline		if (x11_screen_geo(data-&gtxcb, data-&gtscreen_id,\newline			&ampdata-&gtwidth, &ampdata-&gtheight) &lt 0) {\newline			return -1;\newline		}\newline		data-&gtxcb_screen = xcb_get_screen(data-&gtxcb, data-&gtscreen_id);\newline	}\newline\newline	if (!data-&gtwidth || !data-&gtheight) {\newline		blog(LOG_ERROR, &quotFailed to get geometry&quot);\newline		return -1;\newline	}\newline\newline	blog(LOG_INFO, &quotGeometry %&quotPRIdFAST32&quotx%&quotPRIdFAST32\newline		&quot @ %&quotPRIdFAST32&quot,%&quotPRIdFAST32,\newline		data-&gtwidth, data-&gtheight, data-&gtx_org, data-&gty_org);\newline\newline	if (old_width == data-&gtwidth &amp&amp old_height == data-&gtheight)\newline		return 0;\newline\newline	return 1;\newline}\newline","\newline Update the capture\newline \newline @return &lt 0 on error, 0 when size is unchanged, &gt 1 on size change\newline \newline",689099,s9core.c,cell s9_unsave(int k) {\newline	cell	n = NIL; /*LINT*/\newline\newline	while (k) {\newline		if (Stack == NIL)\newline			s9_fatal(&quots9_unsave: stack underflow&quot);\newline		n = car(Stack);\newline		Stack = cdr(Stack);\newline		k--;\newline	}\newline	return n;\newline}\newline,"Pop K nodes off the Stack, return last one. \newline",4522582,watch.c,"int watch(int fd, const char *watch_file)\newline{\newline	char buf[BUF_LEN];\newline	int len, i = 0;\newline	if (firstDir == NULL) return 0;\newline\newline	len = read(fd, buf, BUF_LEN);\newline	if (len &lt 0) {\newline		if (terminate == 0) {\newline			syslog(LOG_ERR, &quotRead error (%s)&quot, strerror(errno));\newline			return 0;\newline		}\newline		syslog(LOG_ERR, &quotterminated&quot);\newline		return -1;\newline	} else if (!len)\newline		/* BUF_LEN too small? */\newline		return -1;\newline	while (i &lt len) {\newline		struct inotify_event *event;\newline		event = (struct inotify_event *)&ampbuf[i];\newline		if (debug_mode)\newline			printf(&quotwd=%d mask=%u cookie=%u len=%u\\n&quot,\newline			       event-&gtwd, event-&gtmask,\newline			       event-&gtcookie, event-&gtlen);\newline		if (event-&gtmask &amp ~IN_IGNORED) {\newline			if (event-&gtwd == master_wd)\newline				read_config(fd, watch_file);\newline			else {\newline				switch (utmpwatcher_handle(fd, event-&gtwd)) {\newline				case -1:	/* Message was not for utmpwatcher */\newline					if (event-&gtlen)\newline						watch_list_find(event-&gtwd, event-&gtname);\newline					break;\newline				case 1:	/* utmp has changed need to reload */\newline					read_config(fd, watch_file);\newline					break;\newline\newline				default:	/* No users logged in or out */\newline					break;\newline				}\newline			}\newline		}\newline\newline		i += EVENT_SIZE + event-&gtlen;\newline	}\newline	return 0;\newline}\newline",\newlineInotify watch loop\newline \newline,3415705,dhp-object.c,"void devhelp_plugin_toggle_search_tab(DevhelpPlugin *self)\newline{\newline	devhelp_plugin_toggle_sidebar_tab(self, 1);\newline}\newline",\newline Toggle&#039s between the Devhelp plugin&#039s search tab and the previous Geany\newline sidebar tab.\newline \newline @param self Devhelp plugin.\newline \newline,1328985,wmccc.c,"int read_prefs() {\newline  char *err;\newline  if (Prefs &amp&amp glob.nb_selected_sites) { \newline    quick_message(&quotyou should not be able to do that!&quot); exit(1); \newline  }\newline  if (Prefs) wmcc_prefs_destroy(Prefs);\newline  Prefs = g_new0(GeneralPrefs, 1);\newline  wmcc_prefs_set_default(Prefs);\newline\newline  err = wmcc_prefs_read_options(Prefs, glob.options_file,1);\newline  if (err || Prefs-&gtnb_sites == 0) {\newline    if (!err &amp&amp Prefs-&gtnb_sites == 0) err = &quotno site..&quot;\newline    quick_message(&quoterror reading %s: %s&quot, glob.options_file, err); return 2;\newline  }\newline  bidouille_prefs_site_names();\newline  return 0;\newline}\newline",lit out relit les prefs \newline,,,,,,on,on,,,,,,,on,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,Load an image from the named file.,optimize external branch,Returns message length,get file name from path,Convert file name or type to libsndfile format,{},{},"Refresh the physical screen,",Update the capture,"Pop K nodes off the Stack,",Inotify watch loop,"Send an ""I want to send you this file"" message",Toggle's between the Devhelp plugin's search tab,{},Recursively adds pointers,List of uploading and waiting clients.,The obliquity of the ecliptic in radians.,This function attempts to merge duplicate subkeys on a key.,This function is called to create a right mouse button,Gives a File,{},x,
32TMVRKDGNY663RQ23Q8VHNG98C84M,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:33 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:33 PDT 2019,,,3907X2AHF05JW18DA8EWD7HXWZXP2S,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:51 PDT 2019,Fri Apr 26 13:11:17 PDT 2019,Sun Apr 28 13:11:17 PDT 2019,,,,1406,100% (62/62),100% (62/62),0% (0/0),105036,inputdata.cpp,"void InputData::terminateAllParsers( )\newline{\newline	/* FIXME: a proper token is needed here. Suppose we should use the\newline	 * location of EOF in the last file that the parser was referenced in. */\newline	InputLoc loc;\newline	loc.fileName = &quot&ltEOF&gt&quot;\newline	loc.line = 0;\newline	loc.col = 0;\newline	for ( ParserDict::Iter pdel = parserDict; pdel.lte(); pdel++ )\newline		pdel-&gtvalue-&gttoken( loc, Parser_tk_eof, 0, 0 );\newline}\newline",Send eof to all parsers. \newline,3178430,cid_jp.cpp,"static int cid_jp_decode ( VPB_CID_JP *cid,           // JP Caller ID struct\newline                           short      *in,            // Wave input\newline                           int        n )             // Sample count\newline{\newline	char	pres[MAX_JPRAW];\newline	int	npres, bc=0;\newline	int	error = 0;\newline	int	i =0;\newline	int	state= 1;\newline\newline	float *demod = new float[n]; 		// allocate space to decode\newline\newline	// Demodulate audiosample to bit stream\newline	demodulate_jp(demod, in, n, JP_F1, JP_F2 );\newline\newline	// display demodulated signal\newline	//for(i=0; i&lt(n/2); i++)\newline	//{\newline	//	printf(&quot%1d,&quot,sgn(demod[i]));\newline	//}	\newline\newline\newline	// Convert bit stream to byte stream of presentation layer only\newline	// and return byte count	\newline	error = extract_jp_pres(pres, &ampnpres, demod, n);\newline		//errors returned range 1..20 indicating point of fail\newline\newline	// clean up temp varible, \newline	delete [] demod;\newline\newline	//printf(&quot \\nerror= %d\\n&quot,error);\newline	//printf(&quotnpres=%d\\n&quot,npres);\newline 	//for(i=0; i&ltnpres; i++)\newline	//         {\newline	//		printf(&quot%2x,&quot,pres[i]);\newline	//         }\newline\newline	memcpy(cid-&gtraw, pres, npres);\newline        cid-&gtraw_size = npres;\newline\newline	//	Empty any old data before proceeding\newline	cid-&gtcnd[0] = 0;\newline	cid-&gtcndexp[0] = 0;\newline	cid-&gtotn[0] = 0;\newline	cid-&gtotnra[0] = 0;\newline	cid-&gtotnexp[0] = 0;\newline\newline	//printf(&quot \\nenter while\\n&quot);\newline	i=0;\newline\newline	state = 1;	// go till =0 or error\newline	while((state == 1) &amp&amp (0 == error))\newline	{\newline	    	switch(pres[i])\newline	        {\newline		    case DID_CND:	// Called Number Data \newline			if((bc= pres[i+1]) &lt OTN_L )\newline			{\newline			    memcpy(cid-&gtcnd, &amppres[i+2], bc);\newline			    cid-&gtcnd[bc] = 0; // Null Terminate\newline			}\newline			else\newline			{\newline			    cid-&gtcnd[0] = 0; // Zero length string\newline			    error = -2;\newline			}\newline			break;\newline\newline		    case DID_CNDEXP:	// Called Number Data Expansion\newline			if((bc=pres[i+1]) == 3)\newline			{\newline			    memcpy(cid-&gtcndexp, &amppres[i+2], bc);\newline			    cid-&gtcndexp[bc] = 0; // Null Terminate\newline			}\newline			else\newline			{\newline			    cid-&gtcndexp[0] = 0;	// Zero length string\newline			    error = -3;		// Inconsistent	\newline			}\newline			break;\newline\newline		    case BIN_OTN:	// Origenators Tel. Number\newline			if((bc=pres[i+1]) &lt= 20)\newline			{\newline			    memcpy(cid-&gtotn, &amppres[i+2], bc);\newline			    cid-&gtotn[bc] = 0;	// Null Term.\newline			}\newline			break;\newline\newline		    case BIN_OTNRA:	// OTN Reason for Absence\newline			if((bc=pres[i+1]) == 1)\newline			{\newline			    memcpy(cid-&gtotnra, &amppres[i+2], bc);\newline			    cid-&gtotnra[bc] = 0;	// Null Term.\newline			}\newline			else\newline			{\newline			    cid-&gtotnra[0] = 0;	// Zero length string\newline			    error = -4;		// Inconsistent	\newline			}\newline			break;\newline\newline		    case BIN_OTNEXP:	// OTN Expansion Signal\newline			if((bc=pres[i+1]) == 3)\newline			{\newline			    memcpy(cid-&gtotnexp, &amppres[i+2], pres[i+1]);\newline			    cid-&gtotnexp[(int)(pres[i+1])] = 0;	// Null Term.\newline			}\newline			else\newline			{\newline			    cid-&gtotnexp[0] = 0;	// Zero length string\newline			    error = -5;		// Inconsistent	\newline			}\newline			break;\newline	        } // end: switch(pres[i])\newline	        i += bc + 2;\newline	        if( npres &lt= i)\newline			state = 0;	// we are done\newline	}	// end: while((state == 1) &amp&amp (0 == error))\newline\newline	if(error != 0)\newline		return(error);\newline	else\newline		return(VPB_OK);	// VPB_OK = No error if all ok\newline}\newline",--------------------------------------------------------------------------- \\\newline FUNCTION: cid_jp_decode()\newline AUTHOR..: Peter Wintulich\newline DATE....: 22 MAR 2004\newline Takes Raw Audio sample and decodes to DID and BIN information\newline Valid data if filled into VPB_JP_CID structure passed to the Fn.\newline return()\newline Return VPB_OK if sucess.\newline Returns error code if fail to decode (use to identify point\newline of fail in debug and test). Error will normaly indicate absence\newline of DID and BIN information.\newline error ==0 No error\newline &gt 0 error from extract_jp_pres()\newline &lt 0 error from cid_jp_decode ()\newline\\ --------------------------------------------------------------------------- \newline,1057116,mixerwatch.c,char *mynameis() {\newline	char *a = MYNAME;\newline	return a;\newline}\newline,Return a pointer to the name of the plugin \newline,4854604,sys_tasks.c,int sys_task_rtoi(\newline  double real  /*!&lt Real value to convert to integer */\newline) { PROFILE(SYS_TASK_RTOI);\newline\newline  int ival = (int)real;\newline\newline  PROFILE_END;\newline\newline  return( ival );\newline\newline}\newline,!\newline\\return Returns an integer representation of the specified real value (value is truncated).\newline \newline,292476,graph.cpp,void Graph::insert(const Edge&amp E)\newline{\newline  // check if the id&#039s are inside\newline  //  if((E.i&ltm_data.size()) &amp&amp (E.j&ltm_data.size())){\newline    m_data[E.i].push_back(E.j);\newline    m_data[E.j].push_back(E.i);\newline    //  }\newline}\newline,!\newlineinsert a new edge\newline\\param E the edge\newline \newline,6655744,dbus-gtype-specialized.c,"const DBusGTypeSpecializedCollectionVtable* dbus_g_type_collection_peek_vtable (GType collection_type)\newline{\newline  DBusGTypeSpecializedData *data;\newline  g_return_val_if_fail (dbus_g_type_is_collection(collection_type), NULL);\newline\newline  data = lookup_specialization_data (collection_type);\newline  g_assert (data != NULL);\newline\newline  return (DBusGTypeSpecializedCollectionVtable *)(data-&gtklass-&gtvtable);\newline}\newline",\newline dbus_g_type_collection_peek_vtable:\newline @collection_type: a gtype of a collection specialization\newline \newline Peek the vtable for a given collection specialization\newline \newline Returns: the vtable\newline \newline Deprecated: New code should use GDBus instead.\newline \newline,2285030,rrd_graph.c,"int scan_for_col(\newline    const char *const input,\newline    int len,\newline    char *const output)\newline{\newline    int       inp, outp = 0;\newline\newline    for (inp = 0; inp &lt len &amp&amp input[inp] != &#039:&#039 &amp&amp input[inp] != &#039\\0&#039; inp++) {\newline        if (input[inp] == &#039\\\\&#039\newline            &amp&amp input[inp + 1] != &#039\\0&#039\newline            &amp&amp (input[inp + 1] == &#039\\\\&#039 || input[inp + 1] == &#039:&#039)) {\newline            output[outp++] = input[++inp];\newline        } else {\newline            output[outp++] = input[inp];\newline        }\newline    }\newline    output[outp] = &#039\\0&#039;\newline    return inp;\newline}\newline",copies input untill the first unescaped colon is found\newlineor until input ends. backslashes have to be escaped as well \newline,1785782,collision_trimesh_distance.cpp,"dReal SqrDistanceSegTri( const dVector3 segOrigin, const dVector3 segEnd, \newline                         const dVector3 triOrigin, \newline                         const dVector3 triEdge0, const dVector3 triEdge1,\newline                         dReal* pfSegP, dReal* pfTriP0, dReal* pfTriP1 )\newline{\newline  const dReal gs_fTolerance = 1e-06f;\newline  dVector3 segDirection, segNegDirection, kDiff, kNegDiff;\newline  Vector3Subtract( segEnd, segOrigin, segDirection );\newline  Vector3Negate( segDirection, segNegDirection );\newline  Vector3Subtract( triOrigin, segOrigin, kDiff );\newline  Vector3Negate( kDiff, kNegDiff );\newline  dReal fA00 = dDOT( segDirection, segDirection );\newline  dReal fA01 = dDOT( segNegDirection, triEdge0 );\newline  dReal fA02 = dDOT( segNegDirection, triEdge1 );\newline  dReal fA11 = dDOT( triEdge0, triEdge0 );\newline  dReal fA12 = dDOT( triEdge0, triEdge1 );\newline  dReal fA22 = dDOT( triEdge1, triEdge1 );\newline  dReal fB0  = dDOT( kNegDiff, segDirection );\newline  dReal fB1  = dDOT( kDiff, triEdge0 );\newline  dReal fB2  = dDOT( kDiff, triEdge1 );\newline\newline  dVector3 kTriSegOrigin, kTriSegDirection, kPt;\newline  dReal fSqrDist, fSqrDist0, fR, fS, fT, fR0, fS0, fT0;\newline\newline  // Set up for a relative error test on the angle between ray direction\newline  // and triangle normal to determine parallel/nonparallel status.\newline  dVector3 kN;\newline  dCROSS( kN, =, triEdge0, triEdge1 );\newline  dReal fNSqrLen = dDOT( kN, kN );\newline  dReal fDot = dDOT( segDirection, kN );\newline  bool bNotParallel = (fDot*fDot &gt= gs_fTolerance*fA00*fNSqrLen);\newline\newline  if ( bNotParallel )\newline  {\newline    dReal fCof00 = fA11*fA22-fA12*fA12;\newline    dReal fCof01 = fA02*fA12-fA01*fA22;\newline    dReal fCof02 = fA01*fA12-fA02*fA11;\newline    dReal fCof11 = fA00*fA22-fA02*fA02;\newline    dReal fCof12 = fA02*fA01-fA00*fA12;\newline    dReal fCof22 = fA00*fA11-fA01*fA01;\newline    dReal fInvDet = REAL(1.0)/(fA00*fCof00+fA01*fCof01+fA02*fCof02);\newline    dReal fRhs0 = -fB0*fInvDet;\newline    dReal fRhs1 = -fB1*fInvDet;\newline    dReal fRhs2 = -fB2*fInvDet;\newline\newline    fR = fCof00*fRhs0+fCof01*fRhs1+fCof02*fRhs2;\newline    fS = fCof01*fRhs0+fCof11*fRhs1+fCof12*fRhs2;\newline    fT = fCof02*fRhs0+fCof12*fRhs1+fCof22*fRhs2;\newline\newline    if ( fR &lt REAL(0.0) )\newline    {\newline      if ( fS+fT &lt= REAL(1.0) )\newline      {\newline        if ( fS &lt REAL(0.0) )\newline        {\newline          if ( fT &lt REAL(0.0) )  // region 4m\newline          {\newline            // min on face s=0 or t=0 or r=0\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection, \newline                                            kTriSegOrigin, kTriSegDirection, \newline                                            &ampfR, &ampfT );\newline            fS = REAL(0.0);\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge0, kTriSegDirection );\newline            fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection, \newline                                             kTriSegOrigin, kTriSegDirection, \newline                                             &ampfR0, &ampfS0 );\newline            fT0 = REAL(0.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline            fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1, \newline                                             &ampfS0, &ampfT0 );\newline            fR0 = REAL(0.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline          }\newline          else  // region 3m\newline          {\newline            // min on face s=0 or r=0\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection, \newline                                            kTriSegOrigin, kTriSegDirection,\newline                                            &ampfR,&ampfT );\newline            fS = REAL(0.0);\newline            fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1,\newline                                             &ampfS0, &ampfT0 );\newline            fR0 = REAL(0.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 5m\newline        {\newline          // min on face t=0 or r=0\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection, \newline                                          kTriSegOrigin, kTriSegDirection, \newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline          fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(0.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else  // region 0m\newline        {\newline          // min on face r=0\newline          fSqrDist = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1, \newline                                          &ampfS, &ampfT );\newline          fR = REAL(0.0);\newline        }\newline      }\newline      else\newline      {\newline        if ( fS &lt REAL(0.0) )  // region 2m\newline        {\newline          // min on face s=0 or s+t=1 or r=0\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge1, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection, \newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline          fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(0.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 6m\newline        {\newline          // min on face t=0 or s+t=1 or r=0\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection, \newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline          fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(0.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else  // region 1m\newline        {\newline          // min on face s+t=1 or r=0\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(1.0) - fT;\newline          fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(0.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline      }\newline    }\newline    else if ( fR &lt= REAL(1.0) )\newline    {\newline      if ( fS+fT &lt= REAL(1.0) )\newline      {\newline        if ( fS &lt REAL(0.0) )\newline        {\newline          if ( fT &lt REAL(0.0) )  // region 4\newline          {\newline            // min on face s=0 or t=0\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                            kTriSegOrigin, kTriSegDirection,\newline                                            &ampfR, &ampfT );\newline            fS = REAL(0.0);\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge0, kTriSegDirection );\newline            fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection, \newline                                             kTriSegOrigin, kTriSegDirection,\newline                                             &ampfR0, &ampfS0 );\newline            fT0 = REAL(0.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline          }\newline          else  // region 3\newline          {\newline            // min on face s=0\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                            kTriSegOrigin, kTriSegDirection,\newline                                            &ampfR, &ampfT );\newline            fS = REAL(0.0);\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 5\newline        {\newline          // min on face t=0\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline        }\newline        else  // region 0\newline        {\newline          // global minimum is interior, done\newline          fSqrDist = REAL(0.0);\newline        }\newline      }\newline      else\newline      {\newline        if ( fS &lt REAL(0.0) )  // region 2\newline        {\newline          // min on face s=0 or s+t=1\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge1, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 6\newline        {\newline          // min on face t=0 or s+t=1\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else  // region 1\newline        {\newline          // min on face s+t=1\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(1.0) - fT;\newline        }\newline      }\newline    }\newline    else  // fR &gt 1\newline    {\newline      if ( fS+fT &lt= REAL(1.0) )\newline      {\newline        if ( fS &lt REAL(0.0) )\newline        {\newline          if ( fT &lt REAL(0.0) )  // region 4p\newline          {\newline            // min on face s=0 or t=0 or r=1\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                            kTriSegOrigin, kTriSegDirection,\newline                                            &ampfR, &ampfT );\newline            fS = REAL(0.0);\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge0, kTriSegDirection );\newline            fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                             kTriSegOrigin, kTriSegDirection,\newline                                             &ampfR0, &ampfS0 );\newline            fT0 = REAL(0.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline            Vector3Add( segOrigin, segDirection, kPt );\newline            fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                             &ampfS0, &ampfT0 );\newline            fR0 = REAL(1.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline          }\newline          else  // region 3p\newline          {\newline            // min on face s=0 or r=1\newline            Vector3Copy( triOrigin, kTriSegOrigin );\newline            Vector3Copy( triEdge1, kTriSegDirection );\newline            fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                            kTriSegOrigin, kTriSegDirection,\newline                                            &ampfR, &ampfT );\newline            fS = REAL(0.0);\newline            Vector3Add( segOrigin, segDirection, kPt );\newline            fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                             &ampfS0, &ampfT0 );\newline            fR0 = REAL(1.0);\newline            if ( fSqrDist0 &lt fSqrDist )\newline            {\newline              fSqrDist = fSqrDist0;\newline              fR = fR0;\newline              fS = fS0;\newline              fT = fT0;\newline            }\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 5p\newline        {\newline          // min on face t=0 or r=1\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline          Vector3Add( segOrigin, segDirection, kPt );\newline          fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(1.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else  // region 0p\newline        {\newline          // min face on r=1\newline          Vector3Add( segOrigin, segDirection, kPt );\newline          fSqrDist = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                          &ampfS, &ampfT );\newline          fR = REAL(1.0);\newline        }\newline      }\newline      else\newline      {\newline        if ( fS &lt REAL(0.0) )  // region 2p\newline        {\newline          // min on face s=0 or s+t=1 or r=1\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge1, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline          Vector3Add( segOrigin, segDirection, kPt );\newline          fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(1.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else if ( fT &lt REAL(0.0) )  // region 6p\newline        {\newline          // min on face t=0 or s+t=1 or r=1\newline          Vector3Copy( triOrigin, kTriSegOrigin );\newline          Vector3Copy( triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfS );\newline          fT = REAL(0.0);\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                           kTriSegOrigin, kTriSegDirection,\newline                                           &ampfR0, &ampfT0 );\newline          fS0 = REAL(1.0) - fT0;\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline          Vector3Add( segOrigin, segDirection, kPt );\newline          fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1,\newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(1.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline        else  // region 1p\newline        {\newline          // min on face s+t=1 or r=1\newline          Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline          Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline          fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                          kTriSegOrigin, kTriSegDirection,\newline                                          &ampfR, &ampfT );\newline          fS = REAL(1.0) - fT;\newline          Vector3Add( segOrigin, segDirection, kPt );\newline          fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1, \newline                                           &ampfS0, &ampfT0 );\newline          fR0 = REAL(1.0);\newline          if ( fSqrDist0 &lt fSqrDist )\newline          {\newline            fSqrDist = fSqrDist0;\newline            fR = fR0;\newline            fS = fS0;\newline            fT = fT0;\newline          }\newline        }\newline      }\newline    }\newline  }\newline  else\newline  {\newline    // segment and triangle are parallel\newline    Vector3Copy( triOrigin, kTriSegOrigin );\newline    Vector3Copy( triEdge0, kTriSegDirection );\newline    fSqrDist = SqrDistanceSegments( segOrigin, segDirection,\newline                                    kTriSegOrigin, kTriSegDirection, &ampfR, &ampfS );\newline    fT = REAL(0.0);\newline\newline    Vector3Copy( triEdge1, kTriSegDirection );\newline    fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                     kTriSegOrigin, kTriSegDirection,\newline                                     &ampfR0, &ampfT0 );\newline    fS0 = REAL(0.0);\newline    if ( fSqrDist0 &lt fSqrDist )\newline    {\newline      fSqrDist = fSqrDist0;\newline      fR = fR0;\newline      fS = fS0;\newline      fT = fT0;\newline    }\newline\newline    Vector3Add( triOrigin, triEdge0, kTriSegOrigin );\newline    Vector3Subtract( triEdge1, triEdge0, kTriSegDirection );\newline    fSqrDist0 = SqrDistanceSegments( segOrigin, segDirection,\newline                                     kTriSegOrigin, kTriSegDirection, &ampfR0, &ampfT0 );\newline    fS0 = REAL(1.0) - fT0;\newline    if ( fSqrDist0 &lt fSqrDist )\newline    {\newline      fSqrDist = fSqrDist0;\newline      fR = fR0;\newline      fS = fS0;\newline      fT = fT0;\newline    }\newline\newline    fSqrDist0 = SqrDistancePointTri( segOrigin, triOrigin, triEdge0, triEdge1, \newline                                     &ampfS0, &ampfT0 );\newline    fR0 = REAL(0.0);\newline    if ( fSqrDist0 &lt fSqrDist )\newline    {\newline      fSqrDist = fSqrDist0;\newline      fR = fR0;\newline      fS = fS0;\newline      fT = fT0;\newline    }\newline\newline    Vector3Add( segOrigin, segDirection, kPt );\newline    fSqrDist0 = SqrDistancePointTri( kPt, triOrigin, triEdge0, triEdge1, \newline                                     &ampfS0, &ampfT0 );\newline    fR0 = REAL(1.0);\newline    if ( fSqrDist0 &lt fSqrDist )\newline    {\newline      fSqrDist = fSqrDist0;\newline      fR = fR0;\newline      fS = fS0;\newline      fT = fT0;\newline    }\newline  }\newline\newline  if ( pfSegP )\newline    *pfSegP = fR;\newline\newline  if ( pfTriP0 )\newline    *pfTriP0 = fS;\newline\newline  if ( pfTriP1 )\newline    *pfTriP1 = fT;\newline\newline  return fSqrDist;\newline}\newline","\newline@brief Finds the shortest distance squared between a line segment and \newlinea triangle.\newline\newline@param pfSegP t value for the line segment where the shortest distance between\newlinethe segment and the triangle occurs.\newlineSo the point along the segment that is the shortest distance\newlineaway from the triangle can be obtained by (seg.end - seg.start) t.\newline@param pfTriP0 Barycentric coordinate of triangle at point closest to seg (u)\newline@param pfTriP1 Barycentric coordinate of triangle at point closest to seg (v)\newline@return Shortest distance squared.\newline\newlineThe third Barycentric coordinate is implicit, ie. w = 1.0 - u - v\newline\newlineTaken from:\newlineMagic Software, Inc.\newlinehttp://www.magic-software.com\newline \newline",3675643,kmeans-pthread.c,"void *calc_means(void *arg)\newline{\newline   int i, j, grp_size;\newline   int *sum;\newline   thread_arg *t_arg = (thread_arg *)arg;\newline   int start_idx = t_arg-&gtstart_idx;\newline   int end_idx = start_idx + t_arg-&gtnum_pts;\newline   \newline   sum = t_arg-&gtsum;\newline   \newline   for (i = start_idx; i &lt end_idx; i++) \newline   {\newline      memset(sum, 0, dim * sizeof(int));\newline      grp_size = 0;\newline      \newline      for (j = 0; j &lt num_points; j++)\newline      {\newline         if (clusters[j] == i) \newline         {\newline            add_to_sum(sum, points[j]);\newline            grp_size++;\newline         }   \newline      }\newline      \newline      for (j = 0; j &lt dim; j++)\newline      {\newline         //dprintf(&quotdiv sum = %d, grp size = %d\\n&quot, sum[j], grp_size);\newline         if (grp_size != 0)\newline         { \newline            means[i][j] = sum[j] / grp_size;\newline         }\newline      }\newline   }\newline   free(sum);\newline   return (void *)0;\newline}\newline",calc_means()\newline Compute the means for the various clusters\newline \newline,3057287,nexustoken.cpp,void NexusToken::GetCurlyBracketedToken()\newline{\newline	// Set level to 1 initially.  Every &#039}&#039 encountered reduces\newline,\newline @method GetCurlyBracketedToken [void:protected]\newline \newline Reads rest of a token surrounded with curly brackets (the starting &#039{&#039\newline has already been input) up to and including the matching &#039}&#039 character.\newline All nested curly-bracketed phrases will be included.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2815792,dlq.c,void  *dlq_prevEntry (const void *nodeP)\newline{\newline    void    *retP;\newline    \newline#ifdef CPP_ICHK\newline    if (nodeP==NULL)   \newline    {\newline        err_msg(ERR_INTERNAL_PTR);\newline        return NULL;\newline    }\newline#endif\newline    ENTER_CRIT;\newline    /* get prev entry in list -- maybe  (hdr_node==start of list) */\newline    nodeP = ((dlq_hdrT *) nodeP)-&gtprev;\newline\newline#ifdef CPP_ICHK\newline    if (!(_data_node(nodeP) || _hdr_node(nodeP)))\newline    {\newline        EXIT_CRIT;\newline        err_msg(ERR_BAD_QLINK);\newline        return NULL;\newline    }\newline#endif\newline    \newline    retP = _data_node( ((dlq_hdrT *) nodeP) ) ? nodeP : NULL;\newline    EXIT_CRIT;\newline\newline    return retP;\newline    \newline}   /* END function dlq_prevEntry */\newline,\newline FUNCTION dlq_prevEntry\newline \newline get the previous queue entry before the current entry\newline \newline INPUTS:\newline nodeP == pointer to current queue entry to use\newline \newline RETURNS:\newline pointer to previous queue entry\newline NULL if the no previous entry was found\newline \newline,5136406,gim_trimesh.cpp,"void gim_trimesh_copy(GIM_TRIMESH * source_trimesh,\newline	GBUFFER_MANAGER_DATA dest_buffer_managers[], GIM_TRIMESH * dest_trimesh, \newline	char copy_by_reference, char transformed_reply)\newline{\newline/* -- trimesh can not be copied by reference until GBUFFER_MANAGER_DATA is rewritten\newline	to be thread safe and until it is moved back to global variables.\newline    if(copy_by_reference==1)\newline    {\newline        gim_trimesh_create_from_arrays(dest_trimesh, &ampsource_trimesh-&gtm_source_vertex_buffer, &ampsource_trimesh-&gtm_tri_index_buffer,transformed_reply);\newline    }\newline    else\newline*/\newline    {\newline        GBUFFER_ARRAY buffer_vertex_array;\newline        GBUFFER_ARRAY buffer_triindex_array;\newline\newline        gim_buffer_array_copy_value(&ampsource_trimesh-&gtm_source_vertex_buffer,\newline			dest_buffer_managers,&ampbuffer_vertex_array,G_BUFFER_MANAGER_SYSTEM,G_MU_DYNAMIC_READ_WRITE);\newline\newline        gim_buffer_array_copy_value(&ampsource_trimesh-&gtm_tri_index_buffer,\newline			dest_buffer_managers,&ampbuffer_triindex_array,G_BUFFER_MANAGER_SYSTEM,G_MU_DYNAMIC_READ_WRITE);\newline\newline        gim_trimesh_create_from_arrays(dest_buffer_managers, dest_trimesh, \newline			&ampbuffer_vertex_array, &ampbuffer_triindex_array,transformed_reply);\newline\newline        ///always call this after create a buffer_array\newline        GIM_BUFFER_ARRAY_DESTROY(buffer_vertex_array);\newline        GIM_BUFFER_ARRAY_DESTROY(buffer_triindex_array);\newline    }\newline}\newline","!\newline\\pre dest_trimesh shouldn&#039t be created\newline\\post dest_trimesh will be created\newline\\param source_trimesh\newline\\param dest_trimesh\newline\\param copy_by_reference If 1, it attach a reference to the source vertices, else it copies the vertices\newline\\param transformed_reply IF 1, then it forces the m_trasnformed_vertices to be a reply of the source vertices\newline \newline",3104241,cirbuf.c,int getc(struct cirbuf *cb)\newline{\newline	unsigned char *nr;\newline	int	c;\newline\newline	nr = (unsigned char *)cb-&gtc_cf;\newline	if (nr == (unsigned char *)cb-&gtc_cl) {\newline	    CB_CHECK(cb);\newline	    return -1;		/* empty */\newline	}\newline	c = *nr;\newline	nr++;\newline	if (nr == (unsigned char *)cb-&gtc_end)\newline	    nr = (unsigned char *)cb-&gtc_start;\newline	cb-&gtc_cf = (char *)nr;\newline\newline	cb-&gtc_cc--;\newline\newline	CB_CHECK(cb);\newline\newline	return c;\newline}\newline,\newline Get one character from circular buffer.\newline \newline,4932002,prvm_edict.c,"ddef_t *PRVM_ED_FieldAtOfs (prvm_prog_t *prog, int ofs)\newline{\newline	ddef_t		*def;\newline	int			i;\newline\newline	for (i = 0;i &lt prog-&gtnumfielddefs;i++)\newline	{\newline		def = &ampprog-&gtfielddefs[i];\newline		if (def-&gtofs == ofs)\newline			return def;\newline	}\newline	return NULL;\newline}\newline",\newline============\newlinePRVM_ED_FieldAtOfs\newline============\newline \newline,5833225,mslogic.c,static void removefromsliplist(creature *cr)\newline{\newline    int	n;\newline\newline    for (n = 0 ; n &lt slipcount ; ++n)\newline	if (slips[n].cr == cr)\newline	    break;\newline    if (n == slipcount)\newline	return;\newline    --slipcount;\newline    for ( ; n &lt slipcount ; ++n)\newline	slips[n] = slips[n + 1];\newline}\newline,Remove the given creature from the slip list.\newline \newline,286858,cmd.c,"static int start_kernel_session(struct ltt_kernel_session *ksess, int wpipe)\newline{\newline	int ret;\newline	struct ltt_kernel_channel *kchan;\newline\newline	/* Open kernel metadata */\newline	if (ksess-&gtmetadata == NULL &amp&amp ksess-&gtoutput_traces) {\newline		ret = kernel_open_metadata(ksess);\newline		if (ret &lt 0) {\newline			ret = LTTNG_ERR_KERN_META_FAIL;\newline			goto error;\newline		}\newline	}\newline\newline	/* Open kernel metadata stream */\newline	if (ksess-&gtmetadata &amp&amp ksess-&gtmetadata_stream_fd &lt 0) {\newline		ret = kernel_open_metadata_stream(ksess);\newline		if (ret &lt 0) {\newline			ERR(&quotKernel create metadata stream failed&quot);\newline			ret = LTTNG_ERR_KERN_STREAM_FAIL;\newline			goto error;\newline		}\newline	}\newline\newline	/* For each channel */\newline	cds_list_for_each_entry(kchan, &ampksess-&gtchannel_list.head, list) {\newline		if (kchan-&gtstream_count == 0) {\newline			ret = kernel_open_channel_stream(kchan);\newline			if (ret &lt 0) {\newline				ret = LTTNG_ERR_KERN_STREAM_FAIL;\newline				goto error;\newline			}\newline			/* Update the stream global counter */\newline			ksess-&gtstream_count_global += ret;\newline		}\newline	}\newline\newline	/* Setup kernel consumer socket and send fds to it */\newline	ret = init_kernel_tracing(ksess);\newline	if (ret != 0) {\newline		ret = LTTNG_ERR_KERN_START_FAIL;\newline		goto error;\newline	}\newline\newline	/* This start the kernel tracing */\newline	ret = kernel_start_session(ksess);\newline	if (ret &lt 0) {\newline		ret = LTTNG_ERR_KERN_START_FAIL;\newline		goto error;\newline	}\newline\newline	/* Quiescent wait after starting trace */\newline	kernel_wait_quiescent(kernel_tracer_fd);\newline\newline	ksess-&gtactive = 1;\newline\newline	ret = LTTNG_OK;\newline\newlineerror:\newline	return ret;\newline}\newline",\newline Start a kernel session by opening all necessary streams.\newline \newline,292463,slip2vtk2d.cpp,"void slip2vtk2d(const string&amp infilebase_up,\newline		const string&amp infilebase_down,\newline		const string&amp outfilename,\newline		int t0,\newline		int nt,\newline		int dt,\newline		double tlen,\newline		double x0,\newline		double x1,\newline		int nx)\newline{\newline  std::cout &lt&lt &quotslip2vtk2d&quot  &lt&lt std::endl;\newline  map&ltdouble,double&gt upper_map,lower_map;\newline  ostringstream infilename_up,infilename_down;\newline  vector&ltdouble&gt disp_old(nx);\newline  // open output file\newline  ofstream outfile(outfilename.c_str());\newline  // write header\newline  write_vtk_header(outfile,nx,((nt-t0)/dt)-1 ,x0,(x1-x0)/double(nx),tlen/(double(nt)));\newline  // first ts -&gt fill up disp_old\newline  infilename_up &lt&lt infilebase_up &lt&lt &quot.&quot &lt&lt t0 &lt&lt &quot.dat&quot;  \newline  infilename_down &lt&lt infilebase_down &lt&lt &quot.&quot &lt&lt t0 &lt&lt &quot.dat&quot;  \newline  upper_map=read_file_to_map(infilename_up.str());\newline  lower_map=read_file_to_map(infilename_down.str());\newline  double dx=(x1-x0)/double(nx);\newline  for(int i=0;i&ltnx;i++){\newline    double px=x0+double(i)*dx; // current sample point\newline    double disp_up,disp_down;\newline    disp_up=get_disp_from_map_linear(upper_map,px);\newline    disp_down=get_disp_from_map_linear(lower_map,px);\newline    disp_old[i]=disp_up-disp_down;\newline  }\newline  // clean up\newline  lower_map.clear();\newline  upper_map.clear();\newline  infilename_up.seekp(0,ios_base::beg);\newline  infilename_down.seekp(0,ios_base::beg);\newline  \newline  // ---- further steps ----\newline  for(int t=t0+1;t&ltnt;t+=dt){\newline    \newline    // generate input filenames\newline    infilename_up &lt&lt infilebase_up &lt&lt &quot.&quot &lt&lt t0+t*dt &lt&lt &quot.dat&quot;  \newline    infilename_down &lt&lt infilebase_down &lt&lt &quot.&quot &lt&lt t0+t*dt &lt&lt &quot.dat&quot;  \newline    std::cout &lt&lt infilename_up.str()  &lt&lt std::endl;\newline    upper_map=read_file_to_map(infilename_up.str());\newline    lower_map=read_file_to_map(infilename_down.str());\newline    // --- calc \newline    // get x-step\newline    double dx=(x1-x0)/double(nx);\newline    for(int i=0;i&ltnx;i++){\newline      double px=x0+double(i)*dx; // current sample point\newline      double disp_up,disp_down;\newline      disp_up=get_disp_from_map_linear(upper_map,px);\newline      disp_down=get_disp_from_map_linear(lower_map,px);\newline      double disp=disp_up-disp_down;\newline      outfile &lt&lt disp-disp_old[i] &lt&lt &quot &quot;\newline    }\newline    outfile &lt&lt std::endl;\newline    // clean up\newline    lower_map.clear();\newline    upper_map.clear();\newline    infilename_up.seekp(0,ios_base::beg);\newline    infilename_down.seekp(0,ios_base::beg);\newline  }  \newline  // close output file\newline  outfile.close();\newline}\newline",!\newlineconvert a number of file pairs containing particle displacements above/below a 1D fault\newlinein a 2D medium to a vtk-file (rect. grid) of the relative displacement\newline\\param infilebase_up base file name for data above the fault \newline\\param infilebase_down base file name for data below the fault \newline\\param outfilename file name for the putput file\newline\\param t0\newline\\param nt\newline\\param dt\newline\\param tlen length of the output data in t-direction \newline\\param x0 minimum x-value\newline\\param x1 maximum x-value\newline\\param nx nr. of grid points in x\newline \newline,6214188,linux.c,"static int32_t device_open(struct usbi_device *idev)\newline{\newline	int32_t fd;\newline\newline	/* Validate... */\newline	if (!idev)\newline		return OPENUSB_BADARG;\newline\newline	fd = open(idev-&gtsys_path, O_RDWR);\newline	if (fd &lt 0) {\newline		fd = open(idev-&gtsys_path, O_RDONLY);\newline		if (fd &lt 0) {\newline			usbi_debug(NULL, 1, &quotfailed to open %s: %s&quot, idev-&gtsys_path,\newline								 strerror(errno));\newline			return translate_errno(errno);\newline		}\newline	}\newline\newline	return fd;\newline}\newline","\newline device_open\newline \newline Opens the device, by opening a file descriptor for it\newline \newline",2752503,miacamera.c,"MiaCamera *mia_camera_dup(MiaCamera *orig)\newline{\newline	return mia_camera_new(mia_vector3d_dup(orig-&gtlocation),\newline			      mia_quaternion_dup(orig-&gtrotation),\newline			      orig-&gtzoom);\newline}\newline",\newline mia_camera_dup:\newline @orig: camera to be copied \newline \newline Create a newly created duplicate of a MiaCamera. The returned camera \newline must be freed by calling g_object_unref()\newline \newline Returns: the copy of the camera\newline \newline,1081830,video_out_vaapi.c,"static void vaapi_destroy_subpicture(vo_driver_t *this_gen) {\newline  vaapi_driver_t        *this = (vaapi_driver_t *) this_gen;\newline  ff_vaapi_context_t    *va_context = this-&gtva_context;\newline  VAStatus              vaStatus;\newline\newline  lprintf(&quotdestroy sub 0x%08x 0x%08x 0x%08x\\n&quot, va_context-&gtva_subpic_id, \newline      va_context-&gtva_subpic_image.image_id, va_context-&gtva_subpic_image.buf);\newline\newline  if(va_context-&gtva_subpic_id != VA_INVALID_ID) {\newline    vaStatus = vaDestroySubpicture(va_context-&gtva_display, va_context-&gtva_subpic_id);\newline    vaapi_check_status(this_gen, vaStatus, &quotvaDeassociateSubpicture()&quot);\newline  }\newline  va_context-&gtva_subpic_id = VA_INVALID_ID;\newline\newline  vaapi_destroy_image(this_gen, &ampva_context-&gtva_subpic_image);\newline\newline}\newline",Deassociate and free subpicture \newline,,,,,on,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Send eof to all parsers.,Reads rest of a token surrounded with curly brackets,Load an image from the named file.,get the previous queue entry before the current entry,{},Get one character from circular buffer.,{},Remove the given creature from the slip list.,Start a kernel session by opening all necessary streams.,convert a number of file pairs,"Opens the device, by opening a file descriptor for it",Takes Raw Audio sample and decodes to DID and BIN information,Create a newly created duplicate of a MiaCamera.,Deassociate and free subpicture,Return a pointer to the name of the plugin,Returns an integer representation,insert a new edge,Peek the vtable for a given collection specialization,copies input untill the first unescaped colon is found,"The third Barycentric coordinate is implicit,",Compute the means for the various clusters,x,
34R3P23QHS1B8GB3FDQX3MZ6WK0WHA,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:34 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:34 PDT 2019,,,3JV9LGBJWTERQV4JUNM6QB68WD7OGU,AITP2LUW8GPB,Submitted,Fri Apr 26 12:49:09 PDT 2019,Fri Apr 26 13:27:12 PDT 2019,Sun Apr 28 13:27:12 PDT 2019,,,,2283,100% (62/62),100% (62/62),0% (0/0),555938,graphics.c,"static void graphics_scroll() {\newline    int i, j, k;\newline\newline    /* we don&#039t want to scroll recursively... that would be bad */\newline    if (no_scroll)\newline        return;\newline    no_scroll = 1;\newline\newline    /* disable pager temporarily */\newline    k = count_lines;\newline    count_lines = -1;\newline    \newline    /* move everything up a line */\newline    for (j = view_y0 + 1; j &lt view_y1; j++) {\newline        graphics_gotoxy(view_x0, j - 1);\newline        for (i = view_x0; i &lt view_x1; i++) {\newline            graphics_putchar(text[j * 80 + i]);\newline        }\newline    }\newline\newline    /* last line should be blank */\newline    graphics_gotoxy(view_x0, view_y1 - 1);\newline    for (i = view_x0; i &lt view_x1; i++)\newline        graphics_putchar(&#039 &#039);\newline    graphics_setxy(view_x0, view_y1 - 1);\newline\newline    count_lines = k;\newline\newline    no_scroll = 0;\newline}\newline",scroll the screen \newline,3838848,netssl.c,"void net_starttls(nut_ctype_t *client, int numarg, const char **arg)\newline{\newline	send_err(client, NUT_ERR_FEATURE_NOT_SUPPORTED);\newline	return;\newline}\newline",stubs for non-ssl compiles \newline,3069128,nxsblock.cpp,void NxsBlock::SkippingCommand(\newline  NxsString )	/* the name of the command being skipped */\newline	{\newline	}\newline,"!\newline This function is called when an unknown command named commandName is about to be skipped. This version of the\newline function does nothing (i.e., no warning is issued that a command was unrecognized). Override this virtual function\newline in a derived class to provide such warnings to the user.\newline \newline",4738120,dtype_transfer.c,static void _wrap_copy_swap_data_free(NpyAuxData *data)\newline{\newline    _wrap_copy_swap_data *d = (_wrap_copy_swap_data *)data;\newline    Py_DECREF(d-&gtarr);\newline    PyArray_free(data);\newline}\newline,wrap copy swap data free function \newline,892999,script_functions.c,"int c_set_window_size(lua_State *lua)\newline{\newline	int top = lua_gettop(lua);\newline\newline	if (top != 2) {\newline		luaL_error(lua,&quotset_window_size: %s&quot, two_indata_expected_error);\newline		return 0;\newline	}\newline\newline	int type1 = lua_type(lua, 1);\newline	int type2 = lua_type(lua, 2);\newline\newline	if ((type1 != LUA_TNUMBER) || (type2 != LUA_TNUMBER)) {\newline		luaL_error(lua,&quotset_window_size: %s&quot, two_indata_expected_error);\newline		return 0;\newline	}\newline\newline	int x = lua_tonumber(lua,1);\newline	int y = lua_tonumber(lua,2);\newline\newline	if (!devilspie2_emulate) {\newline\newline		WnckWindow *window = get_current_window();\newline\newline		if (window) {\newline\newline			devilspie2_error_trap_push();\newline			wnck_window_set_geometry(window,\newline			                         WNCK_WINDOW_GRAVITY_CURRENT,\newline			                         WNCK_WINDOW_CHANGE_WIDTH + WNCK_WINDOW_CHANGE_HEIGHT,\newline			                         -1, -1, x, y);\newline\newline			if (devilspie2_error_trap_pop()) {\newline				gchar *temperror=\newline				    g_strdup_printf(&quotset_window_size: %s&quot, failed_string);\newline				g_printerr(&quot%s&quot, temperror);\newline\newline				g_free(temperror);\newline			}\newline		}\newline	}\newline\newline	return 0;\newline}\newline",\newline Sets the size of the window\newline \newline,101492,main.c,"static int handle_expose(xcb_connection_t *conn, xcb_expose_event_t *event) {\newline    /* re-draw the background */\newline    xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND, (uint32_t[]){color_background.colorpixel});\newline    xcb_poly_fill_rectangle(conn, pixmap, pixmap_gc, 1, &amprect);\newline\newline    /* restore font color */\newline    set_font_colors(pixmap_gc, color_text, color_background);\newline    draw_text(prompt, pixmap, pixmap_gc, NULL,\newline              logical_px(4) + logical_px(4),\newline              logical_px(4) + logical_px(4),\newline              rect.width - logical_px(4) - logical_px(4));\newline\newline    /* render close button */\newline    const char *close_button_label = &quotX&quot;\newline    int line_width = logical_px(4);\newline    /* set width to the width of the label */\newline    int w = predict_text_width(i3string_from_utf8(close_button_label));\newline    /* account for left/right padding, which seems to be set to 8px (total) below */\newline    w += logical_px(8);\newline    int y = rect.width;\newline    uint32_t values[3];\newline    values[0] = color_button_background.colorpixel;\newline    values[1] = line_width;\newline    xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH, values);\newline\newline    xcb_rectangle_t close = {y - w - (2 * line_width), 0, w + (2 * line_width), rect.height};\newline    xcb_poly_fill_rectangle(conn, pixmap, pixmap_gc, 1, &ampclose);\newline\newline    xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND, (uint32_t[]){color_border.colorpixel});\newline    xcb_point_t points[] = {\newline        {y - w - (2 * line_width), line_width / 2},\newline        {y - (line_width / 2), line_width / 2},\newline        {y - (line_width / 2), (rect.height - (line_width / 2)) - logical_px(2)},\newline        {y - w - (2 * line_width), (rect.height - (line_width / 2)) - logical_px(2)},\newline        {y - w - (2 * line_width), line_width / 2}};\newline    xcb_poly_line(conn, XCB_COORD_MODE_ORIGIN, pixmap, pixmap_gc, 5, points);\newline\newline    values[0] = 1;\newline    set_font_colors(pixmap_gc, color_text, color_button_background);\newline    /* the x term here seems to set left/right padding */\newline    draw_text_ascii(close_button_label, pixmap, pixmap_gc,\newline                    y - w - line_width + w / 2 - logical_px(4),\newline                    logical_px(4) + logical_px(3),\newline                    rect.width - y + w + line_width - w / 2 + logical_px(4));\newline    y -= w;\newline\newline    y -= logical_px(20);\newline\newline    /* render custom buttons */\newline    line_width = 1;\newline    for (int c = 0; c &lt buttoncnt; c++) {\newline        /* set w to the width of the label */\newline        w = predict_text_width(buttons[c].label);\newline        /* account for left/right padding, which seems to be set to 12px (total) below */\newline        w += logical_px(12);\newline        y -= logical_px(30);\newline        xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND, (uint32_t[]){color_button_background.colorpixel});\newline        close = (xcb_rectangle_t){y - w - (2 * line_width), logical_px(2), w + (2 * line_width), rect.height - logical_px(6)};\newline        xcb_poly_fill_rectangle(conn, pixmap, pixmap_gc, 1, &ampclose);\newline\newline        xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND, (uint32_t[]){color_border.colorpixel});\newline        buttons[c].x = y - w - (2 * line_width);\newline        buttons[c].width = w;\newline        xcb_point_t points2[] = {\newline            {y - w - (2 * line_width), (line_width / 2) + logical_px(2)},\newline            {y - (line_width / 2), (line_width / 2) + logical_px(2)},\newline            {y - (line_width / 2), (rect.height - logical_px(4) - (line_width / 2))},\newline            {y - w - (2 * line_width), (rect.height - logical_px(4) - (line_width / 2))},\newline            {y - w - (2 * line_width), (line_width / 2) + logical_px(2)}};\newline        xcb_poly_line(conn, XCB_COORD_MODE_ORIGIN, pixmap, pixmap_gc, 5, points2);\newline\newline        values[0] = color_text.colorpixel;\newline        values[1] = color_button_background.colorpixel;\newline        set_font_colors(pixmap_gc, color_text, color_button_background);\newline        /* the x term seems to set left/right padding */\newline        draw_text(buttons[c].label, pixmap, pixmap_gc, NULL,\newline                  y - w - line_width + logical_px(6),\newline                  logical_px(4) + logical_px(3),\newline                  rect.width - y + w + line_width - logical_px(6));\newline\newline        y -= w;\newline    }\newline\newline    /* border line at the bottom */\newline    line_width = logical_px(2);\newline    values[0] = color_border_bottom.colorpixel;\newline    values[1] = line_width;\newline    xcb_change_gc(conn, pixmap_gc, XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH, values);\newline    xcb_point_t bottom[] = {\newline        {0, rect.height - 0},\newline        {rect.width, rect.height - 0}};\newline    xcb_poly_line(conn, XCB_COORD_MODE_ORIGIN, pixmap, pixmap_gc, 2, bottom);\newline\newline    /* Copy the contents of the pixmap to the real window */\newline    xcb_copy_area(conn, pixmap, win, pixmap_gc, 0, 0, 0, 0, rect.width, rect.height);\newline    xcb_flush(conn);\newline\newline    return 1;\newline}\newline",\newline Handles expose events (redraws of the window) and rendering in general. Will\newline be called from the code with event == NULL or from X with event != NULL.\newline \newline \newline,3102587,ahci.c,"void ahci_probe_pci(void)\newline{\newline	unsigned char bus, device;\newline	unsigned short index;\newline	int ret;\newline	unsigned nports, unit, nminors;\newline	struct port *port;\newline	struct gendisk *gd, **gdp;\newline	int *bs;\newline\newline	for (index = 0;\newline		(ret = pcibios_find_class(PCI_CLASS_STORAGE_SATA_AHCI, index, &ampbus, &ampdevice)) == PCIBIOS_SUCCESSFUL;\newline		index++)\newline	{\newline		/* Note: this prevents from also having a SCSI controler.\newline		 * It shouldn&#039t harm too much until we have proper hardware\newline		 * enumeration.\newline		 */\newline		if (register_blkdev(MAJOR_NR, &quotsd&quot, &ampahci_fops) &lt 0)\newline			printk(&quotcould not register ahci\\n&quot);\newline		ahci_probe_dev(bus, device);\newline	}\newline\newline	for (nports = 0, port = &ampports[0]; port &lt &ampports[MAX_PORTS]; port++)\newline		if (port-&gtahci_port)\newline			nports++;\newline\newline	nminors = nports * (1&lt&ltPARTN_BITS);\newline\newline	gd              = kmalloc(sizeof(*gd), GFP_KERNEL);\newline	gd-&gtsizes       = kmalloc(nminors * sizeof(*gd-&gtsizes), GFP_KERNEL);\newline	gd-&gtpart        = kmalloc(nminors * sizeof(*gd-&gtpart), GFP_KERNEL);\newline	bs              = kmalloc(nminors * sizeof(*bs), GFP_KERNEL);\newline\newline	blksize_size[MAJOR_NR] = bs;\newline	for (unit = 0; unit &lt nminors; unit++)\newline		/* We prefer to transfer whole pages */\newline		*bs++ = PAGE_SIZE;\newline\newline	memset(gd-&gtpart, 0, nminors * sizeof(*gd-&gtpart));\newline\newline	for (unit = 0; unit &lt nports; unit++) {\newline		ports[unit].gd = gd;\newline		ports[unit].part = &ampgd-&gtpart[unit &lt&lt PARTN_BITS];\newline	}\newline\newline	gd-&gtmajor       = MAJOR_NR;\newline	gd-&gtmajor_name  = &quotsd&quot;\newline	gd-&gtminor_shift = PARTN_BITS;\newline	gd-&gtmax_p       = 1&lt&ltPARTN_BITS;\newline	gd-&gtmax_nr      = nports;\newline	gd-&gtnr_real     = nports;\newline	gd-&gtinit        = ahci_geninit;\newline	gd-&gtnext        = NULL;\newline\newline	for (gdp = &ampgendisk_head; *gdp; gdp = &amp((*gdp)-&gtnext))\newline		;\newline	*gdp = gd;\newline\newline	blk_dev[MAJOR_NR].request_fn = ahci_do_request;\newline}\newline",Probe all AHCI PCI devices \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,895401,vltest.c,"int runwrite(int argc, char **argv){\newline  char *name, *rstr;\newline  int i, rnum, ii, cmode, lrecmax, nidxmax, lcnum, ncnum, fbp, rv;\newline  name = NULL;\newline  rstr = NULL;\newline  rnum = 0;\newline  ii = FALSE;\newline  cmode = 0;\newline  lrecmax = -1;\newline  nidxmax = -1;\newline  lcnum = -1;\newline  ncnum = -1;\newline  fbp = -1;\newline  for(i = 2; i &lt argc; i++){\newline    if(!name &amp&amp argv[i][0] == &#039-&#039){\newline      if(!strcmp(argv[i], &quot-int&quot)){\newline        ii = TRUE;\newline      } else if(!strcmp(argv[i], &quot-cz&quot)){\newline        cmode |= VL_OZCOMP;\newline      } else if(!strcmp(argv[i], &quot-cy&quot)){\newline        cmode |= VL_OYCOMP;\newline      } else if(!strcmp(argv[i], &quot-cx&quot)){\newline        cmode |= VL_OXCOMP;\newline      } else if(!strcmp(argv[i], &quot-tune&quot)){\newline        if(++i &gt= argc) usage();\newline        lrecmax = atoi(argv[i]);\newline        if(++i &gt= argc) usage();\newline        nidxmax = atoi(argv[i]);\newline        if(++i &gt= argc) usage();\newline        lcnum = atoi(argv[i]);\newline        if(++i &gt= argc) usage();\newline        ncnum = atoi(argv[i]);\newline      } else if(!strcmp(argv[i], &quot-fbp&quot)){\newline        if(++i &gt= argc) usage();\newline        fbp = atoi(argv[i]);\newline      } else {\newline        usage();\newline      }\newline    } else if(!name){\newline      name = argv[i];\newline    } else if(!rstr){\newline      rstr = argv[i];\newline    } else {\newline      usage();\newline    }\newline  }\newline  if(!name || !rstr) usage();\newline  rnum = atoi(rstr);\newline  if(rnum &lt 1) usage();\newline  rv = dowrite(name, rnum, ii, cmode, lrecmax, nidxmax, lcnum, ncnum, fbp);\newline  return rv;\newline}\newline",parse arguments of write command \newline,117002,cram_io.c,"int itf8_put(char *cp, int32_t val) {\newline    if        (!(val &amp ~0x00000007f)) { // 1 byte\newline	*cp = val;\newline	return 1;\newline    } else if (!(val &amp ~0x00003fff)) { // 2 byte\newline	*cp++ = (val &gt&gt 8 ) | 0x80;\newline	*cp   = val &amp 0xff;\newline	return 2;\newline    } else if (!(val &amp ~0x01fffff)) { // 3 byte\newline	*cp++ = (val &gt&gt 16) | 0xc0;\newline	*cp++ = (val &gt&gt 8 ) &amp 0xff;\newline	*cp   = val &amp 0xff;\newline	return 3;\newline    } else if (!(val &amp ~0x0fffffff)) { // 4 byte\newline	*cp++ = (val &gt&gt 24) | 0xe0;\newline	*cp++ = (val &gt&gt 16) &amp 0xff;\newline	*cp++ = (val &gt&gt 8 ) &amp 0xff;\newline	*cp   = val &amp 0xff;\newline	return 4;\newline    } else {                           // 5 byte\newline	*cp++ = 0xf0 | ((val&gt&gt28) &amp 0xff);\newline	*cp++ = (val &gt&gt 20) &amp 0xff;\newline	*cp++ = (val &gt&gt 12) &amp 0xff;\newline	*cp++ = (val &gt&gt 4 ) &amp 0xff;\newline	*cp = val &amp 0x0f;\newline	return 5;\newline    }\newline}\newline",\newline Stores a value to memory in ITF-8 format.\newline \newline Returns the number of bytes required to store the number.\newline This is a maximum of 5 bytes.\newline \newline,3628218,g15stats.c,"void draw_cpu_screen_unicore_logic(g15canvas *canvas, glibtop_cpu cpu, char *tmpstr, int drawgraph, int printlabels, int cpuandmemory) {\newline    int total,user,nice,sys,idle;\newline    int b_total,b_user,b_nice,b_sys,b_idle,b_irq,b_iowait;\newline    static int last_total,last_user,last_nice,last_sys,last_idle,last_iowait,last_irq;\newline\newline    g15r_clearScreen (canvas, G15_COLOR_WHITE);\newline\newline    total = ((unsigned long) cpu.total) ? ((double) cpu.total) : 1.0;\newline    user  = ((unsigned long) cpu.user)  ? ((double) cpu.user)  : 1.0;\newline    nice  = ((unsigned long) cpu.nice)  ? ((double) cpu.nice)  : 1.0;\newline    sys   = ((unsigned long) cpu.sys)   ? ((double) cpu.sys)   : 1.0;\newline    idle  = ((unsigned long) cpu.idle)  ? ((double) cpu.idle)  : 1.0;\newline\newline    b_total = total - last_total;\newline    b_user  = user  - last_user;\newline    b_nice  = nice  - last_nice;\newline    b_sys   = sys   - last_sys;\newline    b_idle  = idle  - last_idle;\newline    b_irq   = cpu.irq - last_irq;\newline    b_iowait= cpu.iowait - last_iowait;\newline\newline    last_total  = total;\newline    last_user   = user;\newline    last_nice   = nice;\newline    last_sys    = sys;\newline    last_idle   = idle;\newline    last_irq    = cpu.irq;\newline    last_iowait = cpu.iowait;\newline\newline    if(printlabels) {\newline        sprintf(tmpstr,&quotUsr %2.f%%&quot,((float)b_user/(float)b_total)*100);\newline        g15r_renderString (canvas, (unsigned char*)tmpstr, 0, G15_TEXT_MED, 1, 2);\newline        sprintf(tmpstr,&quotSys %2.f%%&quot,((float)b_sys/(float)b_total)*100);\newline        g15r_renderString (canvas, (unsigned char*)tmpstr, 0, G15_TEXT_MED, 1, 14);\newline        sprintf(tmpstr,&quotNce %2.f%%&quot,((float)b_nice/(float)b_total)*100);\newline        g15r_renderString (canvas, (unsigned char*)tmpstr, 0, G15_TEXT_MED, 1, 26);\newline    }\newline    if(drawgraph) {\newline        g15r_drawBar(canvas,BAR_START,1,BAR_END,10,G15_COLOR_BLACK,b_user+1,b_total,4);\newline        g15r_drawBar(canvas,BAR_START,12,BAR_END,21,G15_COLOR_BLACK,b_sys+1,b_total,4);\newline        g15r_drawBar(canvas,BAR_START,23,BAR_END,BAR_BOTTOM,G15_COLOR_BLACK,b_nice+1,b_total,4);\newline        drawBar_reversed(canvas,BAR_START,1,BAR_END,BAR_BOTTOM,G15_COLOR_BLACK,b_idle+1,b_total,5);\newline\newline        drawLine_both(canvas, 1, BAR_BOTTOM);\newline    }\newline    if (cpuandmemory) {\newline        print_vert_label(canvas, &quotTOTAL&quot);\newline\newline        sprintf(tmpstr,&quotCPU %3.f%%&quot,((float)(b_total-b_idle)/(float)b_total)*100);\newline        print_label(canvas, tmpstr, 0);\newline    } else if ((cycle == SCREEN_FREQ) &amp&amp (mode[SCREEN_FREQ]) &amp&amp (have_freq)) {\newline        print_vert_label(canvas, &quotFREQ&quot);\newline    } else {\newline        print_vert_label(canvas, &quotIdle&quot);\newline    }\newline}\newline",draw cpu screen. if drawgraph = 0 then no graph is drawn \newline,6412954,dat.h,"_LOGICAL_C_STATIC BYTE *ARCH_DEP(logical_to_main) (VADR addr, int arn,\newline                                    REGS *regs, int acctype, BYTE akey)\newline{\newline    return ARCH_DEP(logical_to_main_l)(addr,arn,regs,acctype,akey,1);\newline}\newline",Original logical_to_main() for compatiblity purpose \newline,1271695,safe.c,"int safe_lutimens (const char *pathname, struct timespec const times[2])\newline{\newline  int dirfd;\newline\newline  dirfd = traverse_path (&amppathname);\newline  if (dirfd &lt 0 &amp&amp dirfd != AT_FDCWD)\newline    return dirfd;\newline  return utimensat (dirfd, pathname, times, AT_SYMLINK_NOFOLLOW);\newline}\newline",Replacement for lutimens() \newline,4051149,prevision.cpp,"void Prevision::CalculEphemSoleilObservateur(const Conditions &ampconditions, Observateur &ampobservateur)\newline{\newline    /* Declarations des variables locales */\newline    bool svis;\newline    QVector&ltdouble&gt tab;\newline    Soleil soleil;\newline\newline    /* Initialisations */\newline    svis = true;\newline    const double pas = NB_JOUR_PAR_MIN;\newline\newline    /* Corps de la methode */\newline    Date date(conditions.jj1(), 0., false);\newline    do {\newline\newline        // Position ECI de l&#039observateur\newline        observateur.CalculPosVit(date);\newline\newline        // Position ECI du Soleil\newline        soleil.CalculPosition(date);\newline\newline        // Position topocentrique du Soleil\newline        soleil.CalculCoordHoriz(observateur, false);\newline\newline        if (soleil.hauteur() &lt= conditions.crep()) {\newline\newline            svis = false;\newline            tab.clear();\newline\newline            // Remplissage du tableau d&#039ephemerides\newline            tab.push_back(date.jourJulienUTC());\newline\newline            tab.push_back(observateur.position().x());\newline            tab.push_back(observateur.position().y());\newline            tab.push_back(observateur.position().z());\newline            tab.push_back(observateur.rotHz().vecteur1().x());\newline            tab.push_back(observateur.rotHz().vecteur1().y());\newline            tab.push_back(observateur.rotHz().vecteur1().z());\newline            tab.push_back(observateur.rotHz().vecteur2().x());\newline            tab.push_back(observateur.rotHz().vecteur2().y());\newline            tab.push_back(observateur.rotHz().vecteur2().z());\newline            tab.push_back(observateur.rotHz().vecteur3().x());\newline            tab.push_back(observateur.rotHz().vecteur3().y());\newline            tab.push_back(observateur.rotHz().vecteur3().z());\newline\newline            tab.push_back(soleil.position().x());\newline            tab.push_back(soleil.position().y());\newline            tab.push_back(soleil.position().z());\newline\newline            tabEphem.append(tab);\newline\newline        } else {\newline            if (!svis) {\newline                svis = true;\newline                if (conditions.crep() &lt= EPSDBL100)\newline                    date = Date(date.jourJulienUTC() + 0.375, 0., false);\newline            }\newline        }\newline\newline        date = Date(date.jourJulienUTC() + pas, 0., false);\newline    } while (date.jourJulienUTC() &lt= conditions.jj2());\newline\newline    tab.clear();\newline\newline    /* Retour */\newline    return;\newline}\newline",\newline Calcul des ephemerides du Soleil et de la position de l&#039observateur\newline \newline,6412733,shared.c,"int shared_ckd_init (DEVBLK *dev, int argc, char *argv[] )\newline{\newlineint      rc;                            /* Return code               */\newlineint      i;                             /* Loop index                */\newlineint      retry;                         /* 1=Connection being retried*/\newlinechar    *ipname;                        /* Remote name or address    */\newlinechar    *port = NULL;                   /* Remote port               */\newlinechar    *rmtnum = NULL;                 /* Remote device number      */\newlinestruct   hostent *he;                   /* -&gt hostent structure      */\newlinechar    *kw;                            /* Argument keyword          */\newlinechar    *op;                            /* Argument operand          */\newlineBYTE     c;                             /* Used for parsing          */\newlinechar    *cu = NULL;                     /* Specified control unit    */\newlineFWORD    cyls;                          /* Remote number cylinders   */\newlinechar    *p, buf[1024];                  /* Work buffer               */\newline\newline    retry = dev-&gtconnecting;\newline\newline    /* Process the arguments */\newline    if (!retry)\newline    {\newline        if (argc &lt 1 || strlen(argv[0]) &gt= sizeof(buf))\newline            return -1;\newline        strcpy (buf, argv[0]);\newline\newline        /* First argument is `ipname:port:devnum&#039 */\newline        ipname = buf;\newline        if (strchr(ipname,&#039/&#039) || strchr(ipname,&#039\\\\&#039))\newline            return -1;\newline        p = strchr (buf, &#039:&#039);\newline        if (p)\newline        {\newline            *p = &#039\\0&#039;\newline            port = p + 1;\newline            p = strchr (port, &#039:&#039);\newline        }\newline        if (p)\newline        {\newline            *p = &#039\\0&#039;\newline            rmtnum = p + 1;\newline        }\newline\newline#if defined( HAVE_SYS_UN_H )\newline        if ( strcmp (ipname, &quotlocalhost&quot) == 0)\newline            dev-&gtlocalhost = 1;\newline        else\newline#endif\newline        {\newline            if ( (he = gethostbyname (ipname)) == NULL )\newline                return -1;\newline            memcpy(&ampdev-&gtrmtaddr, he-&gth_addr_list[0], sizeof(dev-&gtrmtaddr));\newline        }\newline\newline        if (port &amp&amp strlen(port))\newline        {\newline            if (sscanf(port, &quot%hu%c&quot, &ampdev-&gtrmtport, &ampc) != 1)\newline                return -1;\newline        }\newline        else\newline            dev-&gtrmtport = SHARED_DEFAULT_PORT;\newline\newline        if (rmtnum &amp&amp strlen(rmtnum))\newline        {\newline            if (strlen (rmtnum) &gt 4\newline             || sscanf (rmtnum, &quot%hx%c&quot, &ampdev-&gtrmtnum, &ampc) != 1)\newline                return -1;\newline        }\newline        else\newline            dev-&gtrmtnum = dev-&gtdevnum;\newline\newline        /* Process the remaining arguments */\newline        for (i = 1; i &lt argc; i++)\newline        {\newline            if (strcasecmp (&quotreadonly&quot, argv[i]) == 0 ||\newline                strcasecmp (&quotrdonly&quot,   argv[i]) == 0 ||\newline                strcasecmp (&quotro&quot,       argv[i]) == 0)\newline            {\newline                dev-&gtckdrdonly = 1;\newline                continue;\newline            }\newline            if (strcasecmp (&quotfakewrite&quot, argv[i]) == 0 ||\newline                strcasecmp (&quotfakewrt&quot,   argv[i]) == 0 ||\newline                strcasecmp (&quotfw&quot,        argv[i]) == 0)\newline            {\newline                dev-&gtckdfakewr = 1;\newline                continue;\newline            }\newline            if (strlen (argv[i]) &gt 3\newline             &amp&amp memcmp(&quotcu=&quot, argv[i], 3) == 0)\newline            {\newline                kw = strtok (argv[i], &quot=&quot);\newline                op = strtok (NULL, &quot \\t&quot);\newline                cu = op;\newline                continue;\newline            }\newline#ifdef HAVE_LIBZ\newline            if (strlen (argv[i]) &gt 5\newline             &amp&amp memcmp(&quotcomp=&quot, argv[i], 5) == 0)\newline            {\newline                kw = strtok (argv[i], &quot=&quot);\newline                op = strtok (NULL, &quot \\t&quot);\newline                dev-&gtrmtcomp = atoi (op);\newline                if (dev-&gtrmtcomp &lt 0 || dev-&gtrmtcomp &gt 9)\newline                    dev-&gtrmtcomp = 0;\newline                continue;\newline            }\newline#endif\newline            logmsg (_(&quotHHCSH001S parameter %d is invalid: %s\\n&quot),\newline                    i + 1, argv[i]);\newline            return -1;\newline        }\newline    }\newline\newline    /* Set suported compression */\newline    dev-&gtrmtcomps = 0;\newline#ifdef HAVE_LIBZ\newline    dev-&gtrmtcomps |= SHRD_LIBZ;\newline#endif\newline#ifdef CCKD_BZIP2\newline    dev-&gtrmtcomps |= SHRD_BZIP2;\newline#endif\newline\newline    /* Update the device handler vector */\newline    dev-&gthnd = &ampshared_ckd_device_hndinfo;\newline\newline    dev-&gtconnecting = 1;\newline\newlineinit_retry:\newline\newline    do {\newline        rc = clientConnect (dev, retry);\newline        if (rc &lt 0)\newline        {\newline            logmsg (_(&quotHHCSH002W %4.4X connect pending to %s\\n&quot),\newline                    dev-&gtdevnum, dev-&gtfilename);\newline            if (retry) SLEEP(5);\newline        }\newline    } while (retry &amp&amp rc &lt 0);\newline\newline    /* Return if unable to connect */\newline    if (rc &lt 0) return 0;\newline\newline    dev-&gtckdnumfd = 1;\newline    dev-&gtckdfd[0] = dev-&gtfd;\newline\newline    /* Get the number of cylinders */\newline    rc = clientRequest (dev, cyls, 4, SHRD_QUERY, SHRD_CKDCYLS, NULL, NULL);\newline    if (rc &lt 0)\newline        goto init_retry;\newline    else if (rc != 4)\newline    {\newline        logmsg (_(&quotHHCSH003S %4.4X Error retrieving cylinders\\n&quot),\newline                dev-&gtdevnum);\newline        return -1;\newline    }\newline    dev-&gtckdcyls = fetch_fw (cyls);\newline\newline    /* Get the device characteristics */\newline    rc = clientRequest (dev, dev-&gtdevchar, sizeof(dev-&gtdevchar),\newline                        SHRD_QUERY, SHRD_DEVCHAR, NULL, NULL);\newline    if (rc &lt 0)\newline        goto init_retry;\newline    else if (rc == 0 || rc &gt (int)sizeof(dev-&gtdevchar))\newline    {\newline        logmsg (_(&quotHHCSH004S %4.4X Error retrieving device&quot\newline                  &quot characteristics\\n&quot), dev-&gtdevnum);\newline        return -1;\newline    }\newline    dev-&gtnumdevchar = rc;\newline\newline    /* Get number of heads from devchar */\newline    dev-&gtckdheads = fetch_hw (dev-&gtdevchar + 14);\newline\newline    /* Calculate number of tracks */\newline    dev-&gtckdtrks = dev-&gtckdcyls * dev-&gtckdheads;\newline    dev-&gtckdhitrk[0] = dev-&gtckdtrks;\newline\newline    /* Check the device type */\newline    if (dev-&gtdevtype == 0)\newline        dev-&gtdevtype = fetch_hw (dev-&gtdevchar + 3);\newline    else if (dev-&gtdevtype != fetch_hw (dev-&gtdevchar + 3))\newline    {\newline        logmsg (_(&quotHHCSH005S %4.4X Remote device %4.4X is a %4.4X\\n&quot),\newline                dev-&gtdevnum, dev-&gtrmtnum, fetch_hw (dev-&gtdevchar + 3));\newline        return -1;\newline    }\newline\newline    /* Get the device id */\newline    rc = clientRequest (dev, dev-&gtdevid, sizeof(dev-&gtdevid),\newline                        SHRD_QUERY, SHRD_DEVID, NULL, NULL);\newline    if (rc &lt 0)\newline        goto init_retry;\newline    else if (rc == 0 || rc &gt (int)sizeof(dev-&gtdevid))\newline    {\newline        logmsg (_(&quotHHCSH006S %4.4X Error retrieving device id\\n&quot),\newline                dev-&gtdevnum);\newline        return -1;\newline    }\newline    dev-&gtnumdevid = rc;\newline\newline    /* Indicate no active track */\newline    dev-&gtcache = dev-&gtbufcur = -1;\newline    dev-&gtbuf = NULL;\newline\newline    /* Set number of sense bytes */\newline    dev-&gtnumsense = 32;\newline\newline    /* Locate the CKD dasd table entry */\newline    dev-&gtckdtab = dasd_lookup (DASD_CKDDEV, NULL, dev-&gtdevtype, dev-&gtckdcyls);\newline    if (dev-&gtckdtab == NULL)\newline    {\newline        logmsg (_(&quotHHCSH007S %4.4X device type %4.4X not found in dasd table\\n&quot),\newline                dev-&gtdevnum, dev-&gtdevtype);\newline        return -1;\newline    }\newline\newline    /* Set the track size */\newline    dev-&gtckdtrksz = (dev-&gtckdtab-&gtr1 + 511) &amp ~511;\newline\newline    /* Locate the CKD control unit dasd table entry */\newline    dev-&gtckdcu = dasd_lookup (DASD_CKDCU, cu ? cu : dev-&gtckdtab-&gtcu, 0, 0);\newline    if (dev-&gtckdcu == NULL)\newline    {\newline        logmsg (_(&quotHHCSH008S %4.4X control unit %s not found in dasd table\\n&quot),\newline                dev-&gtdevnum, cu ? cu : dev-&gtckdtab-&gtcu);\newline        return -1;\newline    }\newline\newline    /* Set flag bit if 3990 controller */\newline    if (dev-&gtckdcu-&gtdevt == 0x3990)\newline        dev-&gtckd3990 = 1;\newline\newline    /* Clear the DPA */\newline    memset(dev-&gtpgid, 0, sizeof(dev-&gtpgid));\newline\newline    /* Request the channel to merge data chained write CCWs into\newline       a single buffer before passing data to the device handler */\newline    dev-&gtcdwmerge = 1;\newline\newline    /* Purge the cache */\newline    clientPurge (dev, 0, NULL);\newline\newline    /* Log the device geometry */\newline    if (!dev-&gtbatch)\newline    logmsg (_(&quotHHCSH009I %s cyls=%d heads=%d tracks=%d trklen=%d\\n&quot),\newline            dev-&gtfilename, dev-&gtckdcyls,\newline            dev-&gtckdheads, dev-&gtckdtrks, dev-&gtckdtrksz);\newline\newline    dev-&gtconnecting = 0;\newline\newline    return 0;\newline} /* shared_ckd_init */\newline",-------------------------------------------------------------------\newline CKD init exit (client side)\newline ------------------------------------------------------------------- \newline,3612069,tiff.c,"imagestruct *create_tiff(char *filename, int width, int height,\newline			int nchan, int bpp, int tilesize,\newline			double *minvalue, double *maxvalue,\newline			int big_type, int compress_type, int compress_quality,\newline			char *copyright, char *description)\newline  {\newline   TIFF		*tiff;\newline   imagestruct	*image;\newline   char		flagstr[8];\newline\newline/* Handle BigTIFF format */\newline  strcpy(flagstr, &quotw&quot);\newline  if (atof(TIFFGetVersion() + 16) &gt= 4.0)\newline    {\newline    if (big_type==BIGTIFF_ALWAYS)\newline      strcpy(flagstr, &quotw8&quot);\newline    else if ((big_type==BIGTIFF_AUTO)\newline	&amp&amp ((size_t)width*(size_t)height*(size_t)(nchan*abs(bpp)/8))/(size_t)16\newline	&gt=134217728)\newline      {\newline      warning(&quotVery large TIFF file: &quot, &quotswitching to BigTIFF format&quot);\newline      strcpy(flagstr, &quotw8&quot);\newline      }\newline    }\newline  else\newline    {\newline    if (big_type==BIGTIFF_ALWAYS)\newline      warning(&quotThis version of libtiff does not support &quot, &quotBigTIFF format&quot);\newline    else if ((big_type==BIGTIFF_AUTO)\newline	&amp&amp ((size_t)width*(size_t)height*(size_t)(nchan*abs(bpp)/8))/(size_t)16\newline	&gt=134217728)\newline      warning(&quotVery large TIFF file, &quot,\newline	&quotbut no BigTIFF support in this version of libtiff&quot);\newline    }\newline\newline  if ((tiff = TIFFOpen(filename, flagstr)) == NULL)\newline    error(EXIT_FAILURE, &quot*Error*: cannot open for writing &quot, filename);\newline  QCALLOC(image, imagestruct, 1);\newline  strcpy(image-&gtfilename, filename);\newline  image-&gttiff = tiff;\newline\newline  create_tiffdir(image, width, height, nchan, bpp, tilesize, minvalue,\newline	maxvalue, compress_type, compress_quality, copyright, description);\newline\newline  return image;\newline  }\newline","create_tiff \newlinePROTO imagestruct create_tiff(char filename, int width, int height,\newline int nchan, int bpp, int tilesize,\newline double minvalue, double maxvalue,\newline int big_type, int compress_type, float compress_quality,\newline char copyright, char description)\newlinePURPOSE Create a TIFF image (write a TIFF header and return an imagestruct).\newlineINPUT Output filename,\newline image width in pixels,\newline image height in pixels,\newline number of channels (bytes),\newline tilesize (pixels, 0 for stripped),\newline TIFF compression type,\newline JPEG compression quality,\newline copyright string,\newline description string.\newlineOUTPUT Pointer to an imagestruct.\newlineNOTES -.\newlineAUTHOR E. Bertin (IAP)\newlineVERSION 06/02/2014\newline \newline",5209225,mtest.c,"static void *MTestTypeContigInit( MTestDatatype *mtype )\newline{\newline    MPI_Aint size;\newline    int merr;\newline\newline    if (mtype-&gtcount &gt 0) {\newline	signed char *p;\newline	int  i, totsize;\newline	merr = MPI_Type_extent( mtype-&gtdatatype, &ampsize );\newline	if (merr) MTestPrintError( merr );\newline	totsize = size * mtype-&gtcount;\newline	if (!mtype-&gtbuf) {\newline	    mtype-&gtbuf = (void *) malloc( totsize );\newline	}\newline	p = (signed char *)(mtype-&gtbuf);\newline	if (!p) {\newline	    /* Error - out of memory */\newline	    MTestError( &quotOut of memory in type buffer init&quot );\newline	}\newline	for (i=0; i&lttotsize; i++) {\newline	    p[i] = 0xff ^ (i &amp 0xff);\newline	}\newline    }\newline    else {\newline	if (mtype-&gtbuf) {\newline	    free( mtype-&gtbuf );\newline	}\newline	mtype-&gtbuf = 0;\newline    }\newline    return mtype-&gtbuf;\newline}\newline",\newline Setup contiguous buffers of n copies of a datatype.\newline \newline,1786723,common.c,"void Com_Error (int code, char *fmt, ...)\newline{\newline	va_list		argptr;\newline	static char		msg[MAXPRINTMSG];\newline	static	qboolean	recursive = false;\newline\newline	if (recursive)\newline		Sys_Error (&quotrecursive error after: %s&quot, msg);\newline	recursive = true;\newline\newline	va_start (argptr,fmt);\newline	vsnprintf(msg, sizeof(msg), fmt, argptr);\newline	va_end (argptr);\newline\newline	if (code == ERR_DISCONNECT)\newline	{\newline		CL_Drop ();\newline		recursive = false;\newline		longjmp (abortframe, -1);\newline	}\newline	else if (code == ERR_DROP)\newline	{\newline		Com_Printf (&quot********************\\nERROR: %s\\n********************\\n&quot, msg);\newline		SV_Shutdown (va(&quotServer crashed: %s\\n&quot, msg), false);\newline		CL_Drop ();\newline		recursive = false;\newline		longjmp (abortframe, -1);\newline	}\newline	else\newline	{\newline		SV_Shutdown (va(&quotServer fatal crashed: %s\\n&quot, msg), false);\newline		CL_Shutdown ();\newline	}\newline\newline	if (logfile)\newline	{\newline		fclose (logfile);\newline		logfile = NULL;\newline	}\newline\newline	Sys_Error (&quot%s&quot, msg);\newline}\newline","\newline=============\newlineCom_Error\newlineBoth client and server can use this, and it will\newlinedo the apropriate things.\newline=============\newline \newline",777244,pv_map.c,"struct dm_list *create_pv_maps(struct dm_pool *mem, struct volume_group *vg,\newline			    struct dm_list *allocatable_pvs)\newline{\newline	struct dm_list *pvms;\newline\newline	if (!(pvms = dm_pool_zalloc(mem, sizeof(*pvms)))) {\newline		log_error(&quotcreate_pv_maps alloc failed&quot);\newline		return NULL;\newline	}\newline\newline	dm_list_init(pvms);\newline\newline	if (!_create_maps(mem, allocatable_pvs, pvms)) {\newline		log_error(&quotCouldn&#039t create physical volume maps in %s&quot,\newline			  vg-&gtname);\newline		dm_pool_free(mem, pvms);\newline		return NULL;\newline	}\newline\newline	return pvms;\newline}\newline",\newline Create list of PV areas available for this particular allocation\newline \newline,1813056,files.cpp,"void state::md5deep_load_match_file(const char *fn) \newline{\newline    uint64_t line_number = 0;\newline    uint32_t expected_hashes=0;\newline\newline    FILE *f= fopen(fn,&quotrb&quot);\newline    if (f == NULL) {\newline	ocb.error(&quot%s: %s&quot, fn,strerror(errno));\newline	return;\newline    }\newline\newline    int ftype = identify_hash_file_type(f,&ampexpected_hashes);\newline    if (ftype == TYPE_UNKNOWN)  {\newline	ocb.error(&quot%s: Unable to find any hashes in file, skipped.&quot, fn);\newline	fclose(f); f = 0;\newline	return;\newline    }\newline\newline    if (TYPE_ENCASE == ftype)  {\newline	// We can&#039t use the normal file reading code which is based on\newline	// a one-line-at-a-time approach. Encase files are binary records \newline        parse_encase_file(fn,f,expected_hashes);\newline	fclose(f); f = 0;\newline	return;\newline    }\newline\newline    // We skip the first line in every file type except plain files. \newline    // All other file types have a header line that we need to ignore.\newline    if (file_type_without_header(ftype)){\newline	rewind(f);\newline    }\newline    else {\newline	++line_number;\newline    }\newline  \newline    char buf[MAX_STRING_LENGTH + 1];\newline    while (fgets(buf,MAX_STRING_LENGTH,f)) {\newline	char *cc;\newline	char known_fn[PATH_MAX+1];		     // set to be the filename from the buffer\newline	if((cc=strchr(buf,&#039\\n&#039))!=0) *cc = 0;	     // remove \\n at end of line\newline	if((cc=strchr(buf,&#039\\r&#039))!=0) *cc = 0;	     // remove \\r at end of line\newline	++line_number;\newline	memset(known_fn,0,PATH_MAX);\newline\newline	/* This looks odd. The function find_hash_in_line modifies &#039buf&#039 so that it\newline	 * begins with the hash, and copies the filename to known_fn.\newline	 */\newline	if (!find_hash_in_line(buf,ftype,known_fn)) {\newline	    if ((!ocb.opt_silent) || (mode_warn_only)) {\newline		std::cerr &lt&lt progname &lt&lt &quot: &quot &lt&lt fn &lt&lt &quot: No hash found in line &quot &lt&lt line_number &lt&lt std::endl;\newline	    }\newline	} else {\newline	    // Invalid hashes are caught above\newline	    file_data_t *fdt = new file_data_t();\newline	    fdt-&gthash_hex[opt_md5deep_mode_algorithm] = buf; // the hex hash\newline	    fdt-&gtfile_name = known_fn;		    // the filename\newline	    ocb.add_fdt(fdt);\newline	}\newline    }\newline    fclose(f);\newline    f = 0;\newline}\newline","\newline Load an md5deep-style match file.\newline Previously this returned FALSE if failure and TRUE if success.\newline The return value was always ignored, so now we don&#039t return anything.\newline \newline",4224624,vo_s3fb.c,"static void flip_page(void)\newline{\newline  if(vo_doublebuffering) {\newline    vo_draw_text(in_width, in_height, draw_alpha);\newline    yuv_on(in_s3_format, in_width, in_height, vidx, vidy, vidwidth, vidheight, 0, screenwidth, screenheight, screenstride, page);\newline    page ^= offset;\newline    inpage = inpage0 + page;\newline  }\newline}\newline",Render onto the screen \newline,,,,,,on,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,scroll the screen,Stores a value to memory in ITF-8 format.,draw cpu screen.,for compatiblity purpose,Replacement for lutimens(),{},{},Pointer to an imagestruct.,Setup contiguous buffers of n copies of a datatype.,"Both client and server can use this,",Create list of PV areas available for this particular allocation,stubs for non-ssl compiles,Load an md5deep-style match file.,Render onto the screen,called when an unknown command named commandName is about to be skipped.,wrap copy swap data free function,Sets the size of the window,Handles expose events,Probe all AHCI PCI devices,Load an image from the named file.,parse arguments of write command,x,
3T2EL38U0MK3A9FW889DEJ5EW92QXT,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:34 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:34 PDT 2019,,,3Z9WI9EOZZOM00EFG1CV4U10R89KH4,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:59 PDT 2019,Fri Apr 26 13:14:48 PDT 2019,Sun Apr 28 13:14:48 PDT 2019,,,,1609,100% (62/62),100% (62/62),0% (0/0),3395534,nxsstring.h,"inline NxsString &ampNxsString::NumberThenWord(\newline  unsigned i,			/* the number */\newline  const NxsString s)	/* the string needing to be pluralized */\newline  	{\newline	(*this).erase();\newline  	*this &lt&lt i &lt&lt &#039 &#039 &lt&lt s;\newline  	if (i != 1)\newline  		*this &lt&lt &#039s&#039;\newline  	return *this;\newline  	}\newline","--------------------------------------------------------------------------------------------------------------------------\newline| Creates a new string (and returns a reference to the new string) composed of the integer `i&#039 followed by a space and\newline| then the string `s&#039. If `i&#039 is not 1, then an &#039s&#039 character is appended to make `s&#039 plural. For example, if `i&#039 were 0,\newline| 1, or 2, and `s&#039 is &quotcharacter&quot, then the returned string would be &quot0 characters&quot, &quot1 character&quot or &quot2 characters&quot, \newline| respectively. Obviously this only works if adding an &#039s&#039 to the supplied string makes it plural.\newline \newline",2937154,lcas_db_read.c,"static int lcas_db_read_entries(\newline        FILE * dbstream\newline)\newline{\newline    char               line[1024];\newline    int                nlines=0;\newline    int                no_entries=0;\newline    lcas_db_entry_t *  entry=NULL;\newline\newline    nlines=0;\newline    no_entries=0;\newline/*    lcas_db_fill_entry(no_entries,NULL); */\newline    while (fgets(line, sizeof(line), dbstream))\newline    {\newline        ++nlines;\newline\newline        if (! lcas_db_parse_line(line, &ampentry))\newline        {\newline            /* parse error, return line number */\newline            if (entry != NULL) free(entry);\newline            return -(nlines);\newline        }\newline        if (entry != NULL)\newline        {\newline            lcas_log_debug(3,&quotline %d: %s, %s\\n&quot,nlines,entry-&gtpluginname,entry-&gtpluginargs);\newline            /* entry found */\newline            ++no_entries;\newline            if (no_entries &gt MAXDBENTRIES)\newline            {\newline                if (entry != NULL) free(entry);\newline                return no_entries;\newline            }\newline            if ( lcas_db_fill_entry(&amplcas_db_list, entry)==NULL )\newline            {\newline                /* error filling lcas_db */\newline                if (entry != NULL) free(entry);\newline                return -(nlines);\newline            }\newline            if (entry != NULL) free(entry);\newline            entry=NULL;\newline        }\newline        else\newline        {\newline            /* no entry found, but no error */\newline            continue;\newline        }\newline    }\newline    if (entry != NULL) free(entry);\newline    return no_entries;\newline}\newline",!\newline\\fn lcas_db_read_entries(\newlineFILE dbstream\newline)\newline\\brief Read db entries from stream and fill a lsit of db entries\newline\\param dbstream database stream\newline\\return the number of entries found (failure --&gt negative number)\newline\\internal\newline \newline,197424,lempar.c,"static void yyGrowStack(yyParser *p){\newline  int newSize;\newline  yyStackEntry *pNew;\newline\newline  newSize = p-&gtyystksz*2 + 100;\newline  pNew = realloc(p-&gtyystack, newSize*sizeof(pNew[0]));\newline  if( pNew ){\newline    p-&gtyystack = pNew;\newline    p-&gtyystksz = newSize;\newline#ifndef NDEBUG\newline    if( yyTraceFILE ){\newline      fprintf(yyTraceFILE,&quot%sStack grows to %d entries!\\n&quot,\newline              yyTracePrompt, p-&gtyystksz);\newline    }\newline#endif\newline  }\newline}\newline",\newline Try to increase the size of the parser stack.\newline \newline,3440224,wave.cpp,"void FCEU_WriteWaveData(int32 *Buffer, int Count)\newline{\newline	//mbg merge 7/17/06 changed to alloca\newline //int16 temp[Count];  /* Yay.  Is this the first use of this &quotfeature&quot of C in FCE Ultra? */\newline int16 *temp = (int16*)alloca(Count*2);\newline\newline int16 *dest;\newline int x;\newline\newline#ifndef WIN32\newline if(!soundlog) return;\newline#else\newline if(!soundlog &amp&amp !FCEUI_AviIsRecording()) return;\newline#endif\newline\newline dest=temp;\newline x=Count;\newline\newline //mbg 7/28/06 - we appear to be guaranteeing little endian\newline while(x--)\newline {\newline  int16 tmp=*Buffer;\newline\newline  *(uint8 *)dest=(((uint16)tmp)&amp255);\newline  *(((uint8 *)dest)+1)=(((uint16)tmp)&gt&gt8);\newline  dest++;\newline  Buffer++;\newline }\newline if(soundlog)\newline	 wsize+=fwrite(temp,1,Count*sizeof(int16),soundlog);\newline\newline	#ifdef WIN32\newline	if(FCEUI_AviIsRecording())\newline	{\newline		FCEUI_AviSoundUpdate((void*)temp, Count);\newline	}\newline	#endif\newline}\newline","Checking whether the file exists before wiping it out is left up to the\newlinereader..err...I mean, the driver code, if it feels so inclined(I don&#039t feel\newlineso).\newline \newline",6153701,dummy_usb.c,int init_hotplug(void)\newline{\newline	return -1;\newline}\newline,the hotplug functions will also be missing on unsupported platforms \newline,675382,disjunct-utils.c,"Disjunct * catenate_disjuncts(Disjunct *d1, Disjunct *d2)\newline{\newline	Disjunct * dis = d1;\newline\newline	if (d1 == NULL) return d2;\newline	if (d2 == NULL) return d1;\newline	while (dis-&gtnext != NULL) dis = dis-&gtnext;\newline	dis-&gtnext = d2;\newline	return d1;\newline}\newline","\newline Destructively catenates the two disjunct lists d1 followed by d2.\newline Doesn&#039t change the contents of the disjuncts.\newline Traverses the first list, but not the second.\newline \newline",6434835,send.c,"void sendcmdto_one(struct Client *from, const char *cmd, const char *tok,\newline		   struct Client *to, const char *pattern, ...)\newline{\newline  struct VarData vd;\newline  struct MsgBuf *mb;\newline\newline  to = cli_from(to);\newline\newline  vd.vd_format = pattern; /* set up the struct VarData for %v */\newline  va_start(vd.vd_args, pattern);\newline\newline  mb = msgq_make(to, &quot%:#C %s %v&quot, from, IsServer(to) || IsMe(to) ? tok : cmd,\newline		 &ampvd);\newline\newline  va_end(vd.vd_args);\newline\newline  send_buffer(to, mb, 0);\newline\newline  msgq_clean(mb);\newline}\newline",Send a (prefixed) command to a single client.\newline @param[in] from Client sending the command.\newline @param[in] cmd Long name of command (used if \\a to is a user).\newline @param[in] tok Short name of command (used if \\a to is a server).\newline @param[in] to Destination of command.\newline @param[in] pattern Format string for command arguments.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,5958197,arrayc.c,"HIDE SEXP getSimpleClassNames_asSEXP( jobject o, jboolean addConditionClasses ){\newline	if( !o ){\newline		SEXP res = PROTECT( allocVector( STRSXP, 4) ) ;\newline		SET_STRING_ELT( res, 0, mkChar( &quotException&quot ) ) ; \newline		SET_STRING_ELT( res, 1, mkChar( &quotThrowable&quot ) ) ; \newline		SET_STRING_ELT( res, 2, mkChar( &quoterror&quot ) ) ; \newline		SET_STRING_ELT( res, 3, mkChar( &quotcondition&quot ) ) ; \newline		UNPROTECT(1);\newline		return res ;\newline	} else{\newline		return getStringArrayCont( getSimpleClassNames( o, addConditionClasses ) );\newline	}\newline}\newline","\newline Get the list of class names of a java object, and\newline structure it as a STRSXP vector\newline \newline",2175551,ncdf3.c,"void R_ncu4_calc_start_count( int ncid, int varid, int *start_arg, int len_start, \newline	int *count_arg, int len_count, size_t *varsize,\newline	int ndims, size_t *start, size_t *count )\newline{\newline	int i, j, tmp[MAX_NC_DIMS], n_nondegen_dims;	\newline\newline	/*\newline	Rprintf( &quotPassed count: [&quot );\newline	for( i=0; i&ltlen_count; i++ ) {\newline		Rprintf( &quot%d&quot, count_arg[i] );\newline		if( i &lt (len_count-1))\newline			Rprintf( &quot,&quot );\newline		}\newline	Rprintf( &quot]\\n&quot );\newline	*/\newline\newline	/*---------------------------------------------------------------- \newline	 * If start is a single &#039-1&#039, then figure out actual start to use.\newline	 * Note: &#039start_arg&#039 is what was passed to this routine.\newline	 * &#039start&#039 is the actual start to use, which may be somewhat \newline	 * different.\newline	 *---------------------------------------------------------------*/\newline	if( (len_start == 1) &amp&amp (start_arg[0] == -1)) {\newline		/*----------------------------------------------------\newline		 * User did not specify a start arg -- just start at 0\newline		 *---------------------------------------------------*/\newline		for( i=0; i&ltndims; i++ )\newline			start[i] = 0L;\newline		}\newline	else\newline		{\newline		/*-------------------------------------------------------\newline		 * User specified start ... switch from R to C convention.\newline		 * R convention is (xyzt) order with 1-based counting. C\newline		 * convention is (tzyx) order with 0-based counting.\newline		 *------------------------------------------------------*/\newline		for( i=0; i&ltlen_start; i++ )\newline			tmp[i] = start_arg[len_start-i-1] - 1;\newline		for( i=0; i&ltlen_start; i++ )\newline			start_arg[i] = tmp[i];\newline\newline		/*-------------------------------------------\newline		 * Make sure passed start arg has enough dims \newline		 *------------------------------------------*/\newline		if( len_start != ndims ) {\newline			/*-------------------------------------------------------------- \newline			 * Well, allow 1 special case ... user can specify values just\newline			 * for non-degenerate dims (ones that have length&gt1).  To figure\newline			 * this out we need to get the vector of dimlengths for this var.\newline			 *-------------------------------------------------------------*/\newline			if( R_ncu4_get_varsize( ncid, varid, ndims, varsize ) == -1 )\newline				error(&quotread of netcdf file failed when getting variable size&quot);\newline			n_nondegen_dims = 0;\newline			for( i=0; i&ltndims; i++ )\newline				if( varsize[i] &gt 1 )\newline					n_nondegen_dims++;\newline			if( len_start != n_nondegen_dims ) {\newline				error( &quotError, passed argument &#039start&#039 has length %d, but must either have a length equal to the number of dimensions (%d) OR the number of non-degenerate dimensions (%d)\\n&quot,\newline					len_start, ndims, n_nondegen_dims );\newline				}\newline			/*-----------------------------------------------------------------\newline			 * If we get here, user has specified non-degen dimensions only ... \newline			 * translate this to a start string we can use.\newline			 *----------------------------------------------------------------*/\newline			j = 0;\newline			for( i=0; i&ltndims; i++ ) {\newline				if( varsize[i] == 1 )\newline					start[i] = 0L;\newline				else\newline					start[i] = start_arg[j++];\newline				}\newline			}\newline		else\newline			{\newline			/*---------------------------------------------------\newline			 * user specified enough dims ... just copy them over\newline			 *--------------------------------------------------*/\newline			for( i=0; i&ltndims; i++ )\newline				start[i] = (size_t)start_arg[i];\newline			}\newline		}\newline\newline	/*---------------------------------------------------------------- \newline	 * If count is a single &#039-1&#039, then figure out actual count to use.\newline	 * Note: &#039count_arg&#039 is what was passed to this routine.\newline	 * &#039count&#039 is the actual count to use, which may be somewhat \newline	 * different.\newline	 *---------------------------------------------------------------*/\newline	if( (len_count == 1) &amp&amp (count_arg[0] == -1)) {\newline		/*----------------------------------------------------\newline		 * User did not specify a count arg -- do entire var, \newline		 * taking start into account.\newline		 *---------------------------------------------------*/\newline		for( i=0; i&ltndims; i++ )\newline			count[i] = varsize[i] - start[i];\newline		}\newline	else\newline		{\newline		/*-------------------------------------------------------\newline		 * User specified count ... switch from R to C convention.\newline		 * R convention is (xyzt) order, C convention is (tzyx).\newline		 *------------------------------------------------------*/\newline		for( i=0; i&ltlen_count; i++ )\newline			tmp[i] = count_arg[len_count-i-1];\newline		for( i=0; i&ltlen_count; i++ )\newline			count_arg[i] = tmp[i];\newline\newline		/*-------------------------------------------\newline		 * Make sure passed count arg has enough dims \newline		 *------------------------------------------*/\newline		if( len_count != ndims ) {\newline			/*-------------------------------------------------------------- \newline			 * Well, allow 1 special case ... user can specify values just\newline			 * for non-degenerate dims (ones that have length&gt1).  To figure\newline			 * this out we need to get the vector of dimlengths for this var.\newline			 *-------------------------------------------------------------*/\newline			n_nondegen_dims = 0;\newline			for( i=0; i&ltndims; i++ )\newline				if( varsize[i] &gt 1 )\newline					n_nondegen_dims++;\newline			if( len_count != n_nondegen_dims ) {\newline				error( &quotError, passed argument &#039count&#039 has length %d, but must either have a length equal to the number of dimensions (%d) OR the number of non-degenerate dimensions (%d)\\n&quot,\newline					len_count, ndims, n_nondegen_dims );\newline				}\newline			/*-----------------------------------------------------------------\newline			 * If we get here, user has specified non-degen dimensions only ... \newline			 * translate this to a count string we can use.\newline			 *----------------------------------------------------------------*/\newline			j = 0;\newline			for( i=0; i&ltndims; i++ ) {\newline				if( varsize[i] == 1 )\newline					count[i] = 1L;\newline				else\newline					count[i] = count_arg[j++];\newline				}\newline			}\newline		else\newline			{\newline			/*---------------------------------------------------\newline			 * user specified enough dims ... just copy them over\newline			 *--------------------------------------------------*/\newline			for( i=0; i&ltndims; i++ )\newline				if( count_arg[i] == -1 )\newline					count[i] = varsize[i] - start[i];\newline				else\newline					count[i] = (size_t)count_arg[i];\newline			}\newline		}\newline\newline	/*\newline	Rprintf( &quotFinal count to use: [&quot );\newline	for( i=0; i&ltlen_count; i++ ) {\newline		Rprintf( &quot%ld&quot, count[i] );\newline		if( i &lt (len_count-1))\newline			Rprintf( &quot,&quot );\newline		}\newline	Rprintf( &quot]\\n&quot );\newline	*/\newline}\newline","================================================================================================================\newline Given as inputs start_arg and count_arg (which can be -1&#039s for example) this calculates\newline the actual start and count to use, and returns them.\newline \newline",6225628,xcf.cpp,"bool XCFImageFormat::loadLayerProperties(QDataStream &ampxcf_io, Layer &amplayer)\newline{\newline    while (true) {\newline        PropType type;\newline        QByteArray bytes;\newline\newline        if (!loadProperty(xcf_io, type, bytes)) {\newline//          qDebug() &lt&lt &quotXCF: error loading layer properties&quot;\newline            return false;\newline        }\newline\newline        QDataStream property(bytes);\newline\newline        switch (type) {\newline        case PROP_END:\newline            return true;\newline\newline        case PROP_ACTIVE_LAYER:\newline            layer.active = true;\newline            break;\newline\newline        case PROP_OPACITY:\newline            property &gt&gt layer.opacity;\newline            break;\newline\newline        case PROP_VISIBLE:\newline            property &gt&gt layer.visible;\newline            break;\newline\newline        case PROP_LINKED:\newline            property &gt&gt layer.linked;\newline            break;\newline\newline        case PROP_PRESERVE_TRANSPARENCY:\newline            property &gt&gt layer.preserve_transparency;\newline            break;\newline\newline        case PROP_APPLY_MASK:\newline            property &gt&gt layer.apply_mask;\newline            break;\newline\newline        case PROP_EDIT_MASK:\newline            property &gt&gt layer.edit_mask;\newline            break;\newline\newline        case PROP_SHOW_MASK:\newline            property &gt&gt layer.show_mask;\newline            break;\newline\newline        case PROP_OFFSETS:\newline            property &gt&gt layer.x_offset &gt&gt layer.y_offset;\newline            break;\newline\newline        case PROP_MODE:\newline            property &gt&gt layer.mode;\newline            break;\newline\newline        case PROP_TATTOO:\newline            property &gt&gt layer.tattoo;\newline            break;\newline\newline        default:\newline//              qDebug() &lt&lt &quotXCF: unimplemented layer property &quot &lt&lt type\newline//                      &lt&lt &quot, size &quot &lt&lt bytes.size() &lt&lt endl;\newline            break;\newline        }\newline    }\newline}\newline",!\newline An XCF file can contain an arbitrary number of properties associated\newline with a layer.\newline \\param xcf_io the data stream connected to the XCF image.\newline \\param layer layer to collect the properties.\newline \\return true if there were no I/O errors.\newline \newline,5006485,database.c,"void xcb_xrm_database_put_resource(xcb_xrm_database_t **database, const char *resource, const char *value) {\newline    char *escaped;\newline    char *line;\newline\newline    assert(resource != NULL);\newline    assert(value != NULL);\newline\newline    if (*database == NULL)\newline        *database = xcb_xrm_database_from_string(&quot&quot);\newline\newline    escaped = __xcb_xrm_entry_escape_value(value);\newline    if (escaped == NULL)\newline        return;\newline    if (asprintf(&ampline, &quot%s: %s&quot, resource, escaped) &lt 0) {\newline        FREE(escaped);\newline        return;\newline    }\newline    FREE(escaped);\newline    xcb_xrm_database_put_resource_line(database, line);\newline    FREE(line);\newline}\newline","\newline Inserts a new resource into the database.\newline If the resource already exists, the current value will be replaced.\newline If NULL is passed for database, a new and empty database will be created and\newline returned in the pointer.\newline \newline Note that this is not the equivalent of @ref\newline xcb_xrm_database_put_resource_line when concatenating the resource name and\newline value with a colon. For example, if the value starts with a leading space,\newline this must (and will) be replaced with the special &#039\\ &#039 sequence.\newline \newline @param database The database to modify.\newline @param resource The fully qualified or partial resource specifier.\newline @param value The value of the resource.\newline \newline",4460872,wordexp.c,"static int w_addword(wordexp_t * pwordexp, char *word)\newline{\newline	size_t num_p;\newline	char **new_wordv;\newline\newline	/* Internally, NULL acts like &quot&quot.  Convert NULLs to &quot&quot before\newline	 * the caller sees them.\newline	 */\newline	if (word == NULL) {\newline		word = strdup(&quot&quot);\newline		if (word == NULL)\newline			goto no_space;\newline	}\newline\newline	num_p = 2 + pwordexp-&gtwe_wordc + pwordexp-&gtwe_offs;\newline	new_wordv = realloc(pwordexp-&gtwe_wordv, sizeof(char *) * num_p);\newline	if (new_wordv != NULL) {\newline		pwordexp-&gtwe_wordv = new_wordv;\newline		pwordexp-&gtwe_wordv[pwordexp-&gtwe_offs + pwordexp-&gtwe_wordc++] = word;\newline		pwordexp-&gtwe_wordv[pwordexp-&gtwe_offs + pwordexp-&gtwe_wordc] = NULL;\newline		return 0;\newline	}\newline\newline  no_space:\newline	return WRDE_NOSPACE;\newline}\newline",Add a word to the wordlist \newline,4890547,vcom.c,"VPUBLIC int Vcom_recv(Vcom *thee, int src, void *buf, int len, int type,\newline    int block)\newline{\newline    int err = 0;             /* Error flag (success = 1) */\newline\newline#if defined(HAVE_MPI_H)\newline    int tag = VCOM_MPI_TAG;  /* MPI tag */\newline    MPI_Datatype datatype;\newline    Vcom_core *core = thee-&gtcore;\newline#endif\newline\newline    /* Bail if we&#039ve received any errors */\newline    VASSERT(thee != VNULL);\newline    if (thee-&gterror != 0) {\newline        Vnm_print(2, &quotVcom_send:  Have non-zero error state (%d)!\\n&quot,\newline          thee-&gterror);\newline        return 0;\newline    }\newline\newline\newline#if defined(HAVE_MPI_H)\newline    switch(type) {\newline        case 0:\newline            datatype = MPI_BYTE;\newline            break;\newline        case 1:\newline            datatype = MPI_INT;\newline            break;\newline        case 2:\newline            datatype = MPI_DOUBLE;\newline            break;\newline        case 3:\newline            datatype = MPI_CHAR;\newline            break;\newline        default:\newline            Vnm_print(2, &quotVcom_recv: Bogus datatype (%d), bailing!\\n&quot, type);\newline            return 0;\newline    }\newline#endif\newline\newline    /* Send routine depends on comm object type */\newline    switch(thee-&gttype) {\newline\newline      case 1: /* MPI 1.1 */\newline#if defined(HAVE_MPI_H)\newline        if (core-&gtmpi_comm == MPI_COMM_NULL) return 1;\newline        /* To block or not to block... */\newline        if (block == 1) {\newline            err = MPI_Recv(buf, len, datatype, src, tag, \newline                  core-&gtmpi_comm, &amp(core-&gtmpi_status));\newline            err = (MPI_SUCCESS == err);\newline        } else {\newline            Vnm_print(2, &quotVcom_recv: WARNING! Non-blocking receive not implemented!\\n&quot);\newline            return 0;\newline        }\newline#else\newline        Vnm_print(2, &quotVcom_recv: Vcom not compiled with MPI!\\n&quot);\newline        return 0;\newline#endif\newline\newline        break; \newline      default:\newline        Vnm_print(2, &quotVcom_recv: Invalid communications type!\\n&quot);\newline        return 0;\newline    }\newline    return err;\newline}\newline","\newline \newline Routine: Vcom_recv\newline \newline Purpose: Receive a (character) buffer. Returns 1 on success. \newline \newline Args: src = rank of sending processor\newline buf = pointer to buffer of previously allocated memory\newline len = number of items (of declared type) in buffer\newline type = type of items in message\newline 0 =&gt MPI_BYTE\newline 1 =&gt MPI_INT\newline 2 =&gt MPI_DOUBLE\newline 3 =&gt MPI_CHAR\newline block = toggles blocking on (=1) and off (=0)\newline \newline Returns: 1 if successful\newline \newline Notes: The blocking flag is present, but not used. All receives are\newline assumed to be blocking. A non-blocking receive would be very \newline ugly to implement (signals or something?).\newline \newline Author: Nathan Baker and Michael Holst\newline \newline \newline",346730,selector.c,"static void strappc(string *s, char c)\newline{\newline  int len = strlen(*s);\newline  renewarray(*s, len + 2);\newline  (*s)[len] = c;\newline  (*s)[len+1] = &#039\\0&#039;\newline}\newline",strappc -- append a character to a malloc&#039ed string \newline,897347,ospusageind.c,OSPE_ROLE OSPPUsageIndGetRole(      /* returns the role (OGW/TGW) */\newline    OSPT_USAGE_IND *ospvUsageInd)   /* usage indication */\newline{\newline    OSPE_ROLE role = OSPC_ROLE_UNDEFINED;\newline\newline    if (ospvUsageInd != OSPC_OSNULL) {\newline        role = ospvUsageInd-&gtRole;\newline    }\newline\newline    return role;\newline}\newline,\newline OSPPUsageIndGetRole() - returns role for an usage indication\newline \newline,3840774,common.c,"void chroot_start(const char *path)\newline{\newline	if (chdir(path))\newline		fatal_with_errno(EXIT_FAILURE, &quotchdir(%s)&quot, path);\newline\newline	if (chroot(path))\newline		fatal_with_errno(EXIT_FAILURE, &quotchroot(%s)&quot, path);\newline\newline	if (chdir(&quot/&quot))\newline		fatal_with_errno(EXIT_FAILURE, &quotchdir(/)&quot);\newline\newline	upsdebugx(1, &quotchrooted into %s&quot, path);\newline}\newline",drop down into a directory and throw away pointers to the old path \newline,4153316,eurephiadm.c,"int cmd_ShowCfg(eurephiaCTX *ctx, eurephiaSESSION *sess, eurephiaVALUES *cfg, int argc, char **argv) {\newline        void dump_values(eurephiaVALUES *vls) {\newline                eurephiaVALUES *ptr = NULL;\newline                fprintf(stdout, &quot----------------------------------------------------------------------\\n&quot);\newline                for( ptr = vls; ptr != NULL; ptr = ptr-&gtnext) {\newline                        if( ptr-&gtkey != NULL ) {\newline                                fprintf(stdout, &quot%20s = %s\\n&quot, ptr-&gtkey, ptr-&gtval);\newline                        }\newline                }\newline                fprintf(stdout, &quot----------------------------------------------------------------------\\n&quot);\newline        }\newline\newline        if( cfg != NULL ) {\newline                fprintf(stdout, &quot\\n** eurephiadm configuration settings (config file) **\\n&quot);\newline                dump_values(cfg);\newline                fprintf(stdout, &quot\\n&quot);\newline        }\newline        if( ctx != NULL ) {\newline                fprintf(stdout, &quot** eurephia configuration settings (set in database) **\\n&quot);\newline                dump_values(ctx-&gtdbc-&gtconfig);\newline                fprintf(stdout, &quot\\n&quot);\newline        }\newline        return 0;\newline}\newline","\newline eurephiadm show-config command. Dumps configuration to stdout. If the user is logged in, the\newline configuration saved in the database is also dumped.\newline \newline @param ctx eurephiaCTX\newline @param sess eurephiaSESSION of the current logged in user\newline @param cfg eurephiaVALUES struct of the current configuration\newline @param argc argument count for the show-config command\newline @param argv argument table for the show-config command\newline \newline @return returns 0 on success, otherwise 1.\newline \newline",3512042,tun6.c,"tun6 *tun6_create (const char *req_name)\newline{\newline	(void)bindtextdomain (PACKAGE_NAME, LOCALEDIR);\newline	tun6 *t = (tun6 *)malloc (sizeof (*t));\newline	if (t == NULL)\newline		return NULL;\newline	memset (t, 0, sizeof (*t));\newline\newline	int reqfd = t-&gtreqfd = socket (AF_INET6, SOCK_DGRAM, 0);\newline	if (reqfd == -1)\newline	{\newline		free (t);\newline		return NULL;\newline	}\newline\newline	fcntl (reqfd, F_SETFD, FD_CLOEXEC);\newline\newline#if defined (USE_LINUX)\newline	/*\newline	 * TUNTAP (Linux) tunnel driver initialization\newline	 */\newline	static const char tundev[] = &quot/dev/net/tun&quot;\newline	struct ifreq req =\newline	{\newline		.ifr_flags = IFF_TUN\newline	};\newline\newline	if ((req_name != NULL) &amp&amp safe_strcpy (req.ifr_name, req_name))\newline	{\newline		free (t);\newline		return NULL;\newline	}\newline\newline	int fd = open (tundev, O_RDWR);\newline	if (fd == -1)\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot), tundev);\newline		(void)close (reqfd);\newline		free (t);\newline		return NULL;\newline	}\newline\newline	// Allocates the tunneling virtual network interface\newline	if (ioctl (fd, TUNSETIFF, (void *)&ampreq))\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot), &quotTUNSETIFF&quot);\newline		if (errno == EBUSY)\newline			syslog (LOG_INFO,\newline			        _(&quotPlease make sure another instance of the program is &quot\newline	        	          &quotnot already running.&quot));\newline		goto error;\newline	}\newline\newline	int id = if_nametoindex (req.ifr_name);\newline	if (id == 0)\newline		goto error;\newline#elif defined (USE_BSD)\newline# ifdef HAVE_KLDLOAD\newline	kldload (&quotif_tun&quot);\newline# endif\newline	/*\newline	 * BSD tunnel driver initialization\newline	 * (see BSD src/sys/net/if_tun.{c,h})\newline	 */\newline	int fd = open (&quot/dev/tun&quot, O_RDWR);\newline	if ((fd == -1) &amp&amp (errno == ENOENT))\newline	{\newline		/*\newline		 * Some BSD variants or older kernel versions do not support /dev/tun,\newline		 * so fallback to the old scheme.\newline		 */\newline		int saved_errno = 0;\newline		for (unsigned i = 0; fd == -1; i++)\newline		{\newline			char tundev[5 + IFNAMSIZ];\newline			snprintf (tundev, sizeof (tundev), &quot/dev/tun%u&quot, i);\newline\newline			fd = open (tundev, O_RDWR);\newline			if ((fd == -1) &amp&amp (errno == ENOENT))\newline				// If /dev/tun&lti&gt does not exist,\newline				// /dev/tun&lti+1&gt won&#039t exist either\newline				break;\newline\newline			saved_errno = errno;\newline		}\newline		errno = saved_errno;\newline	}\newline\newline	if (fd == -1)\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot), &quot/dev/tun*&quot);\newline		goto error;\newline	}\newline	else\newline	{\newline		struct stat st;\newline		fstat (fd, &ampst);\newline# ifdef HAVE_DEVNAME_R\newline		devname_r (st.st_rdev, S_IFCHR, t-&gtorig_name, sizeof (t-&gtorig_name));\newline# else\newline		const char *name = devname (st.st_rdev, S_IFCHR);\newline		if (safe_strcpy (t-&gtorig_name, name))\newline			goto error;\newline# endif		\newline	}\newline\newline	int id = if_nametoindex (t-&gtorig_name);\newline	if (id == 0)\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot),\newline		        t-&gtorig_name);\newline		goto error;\newline	}\newline\newline# ifdef TUNSIFMODE\newline	/* Sets sensible tunnel type (broadcast rather than point-to-point) */\newline	(void)ioctl (fd, TUNSIFMODE, &amp(int){ IFF_BROADCAST });\newline# endif\newline\newline# if defined (TUNSIFHEAD)\newline	/* Enables TUNSIFHEAD */\newline	if (ioctl (fd, TUNSIFHEAD, &amp(int){ 1 }))\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot),\newline		        &quotTUNSIFHEAD&quot);\newline#  if defined (__APPLE__)\newline		if (errno == EINVAL)\newline			syslog (LOG_NOTICE,\newline			        &quot*** Ignoring tun-tap-osx spurious error ***&quot);\newline		else\newline#  endif\newline		goto error;\newline	}\newline# elif defined (TUNSLMODE)\newline	/* Disables TUNSLMODE (deprecated opposite of TUNSIFHEAD) */\newline	if (ioctl (fd, TUNSLMODE, &amp(int){ 0 }))\newline	{\newline		syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot),\newline		        &quotTUNSLMODE&quot);\newline		goto error;\newline	}\newline#endif\newline\newline	/* Customizes interface name */\newline	if (req_name != NULL)\newline	{\newline		struct ifreq req;\newline		memset (&ampreq, 0, sizeof (req));\newline\newline		if (if_indextoname (id, req.ifr_name) == NULL)\newline		{\newline			syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot),\newline			        &quotif_indextoname&quot);\newline			goto error;\newline		}\newline		else\newline		if (strcmp (req.ifr_name, req_name))\newline		{\newline#ifdef SIOCSIFNAME\newline			char ifname[IFNAMSIZ];\newline			req.ifr_data = ifname;\newline\newline			errno = ENAMETOOLONG;\newline			if (safe_strcpy (ifname, req_name)\newline			 || ioctl (reqfd, SIOCSIFNAME, &ampreq))\newline#else\newline			syslog (LOG_DEBUG,\newline&quotTunnel interface renaming is not supported on your operating system.\\n&quot\newline&quotTo run miredo properly, you need to remove the InterfaceName directive\\n&quot\newline&quotfrom its configuration file.\\n&quot);\newline			errno = ENOSYS;\newline#endif\newline			{\newline				syslog (LOG_ERR, _(&quotTunneling driver error (%s): %m&quot),\newline				        &quotSIOCSIFNAME&quot);\newline				goto error;\newline			}\newline		}\newline	}\newline#else\newline# error No tunneling driver implemented on your platform!\newline#endif /* HAVE_os */\newline\newline	fcntl (fd, F_SETFD, FD_CLOEXEC);\newline	/*int val = fcntl (fd, F_GETFL);\newline	fcntl (fd, F_SETFL, ((val != -1) ? val : 0) | O_NONBLOCK);*/\newline\newline	t-&gtid = id;\newline	t-&gtfd = fd;\newline	return t;\newline\newlineerror:\newline	(void)close (reqfd);\newline	if (fd != -1)\newline		(void)close (fd);\newline	syslog (LOG_ERR, _(&quot%s tunneling interface creation failure&quot), os_driver);\newline	free (t);\newline	return NULL;\newline}\newline","\newline Tries to allocate a tunnel interface from the kernel.\newline \newline @param req_name may be an interface name for the virtual network device\newline (it might be ignored on some OSes).\newline If NULL, an internal default will be used.\newline \newline @return NULL on error.\newline \newline",4489104,ui_rankings.c,"void Rankings_MenuInit( void ) {\newline	grank_status_t	status;\newline	int				y;\newline\newline	memset( &amps_rankings, 0, sizeof(s_rankings) );\newline\newline	Rankings_Cache();\newline\newline	s_rankings.menu.wrapAround = qtrue;\newline	s_rankings.menu.fullscreen = qfalse;\newline\newline	s_rankings.frame.generic.type		= MTYPE_BITMAP;\newline	s_rankings.frame.generic.flags		= QMF_INACTIVE;\newline	s_rankings.frame.generic.name		= RANKINGS_FRAME;\newline	s_rankings.frame.generic.x			= 142;\newline	s_rankings.frame.generic.y			= 118;\newline	s_rankings.frame.width				= 359;\newline	s_rankings.frame.height				= 256;\newline\newline	y = 194;\newline\newline	s_rankings.login.generic.type		= MTYPE_PTEXT;\newline	s_rankings.login.generic.flags		= QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.login.generic.id			= ID_LOGIN;\newline	s_rankings.login.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.login.generic.x			= 320;\newline	s_rankings.login.generic.y			= y;\newline	s_rankings.login.string				= &quotLOGIN&quot;\newline	s_rankings.login.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.login.color				= colorRed;\newline	y += 20;\newline\newline	s_rankings.logout.generic.type		= MTYPE_PTEXT;\newline	s_rankings.logout.generic.flags		= QMF_HIDDEN|QMF_INACTIVE|QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.logout.generic.id		= ID_LOGOUT;\newline	s_rankings.logout.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.logout.generic.x			= 320;\newline	s_rankings.logout.generic.y			= y;\newline	s_rankings.logout.string				= &quotLOGOUT&quot;\newline	s_rankings.logout.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.logout.color				= colorRed;\newline\newline	s_rankings.create.generic.type		= MTYPE_PTEXT;\newline	s_rankings.create.generic.flags		= QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.create.generic.id		= ID_CREATE;\newline	s_rankings.create.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.create.generic.x			= 320;\newline	s_rankings.create.generic.y			= y;\newline	s_rankings.create.string			= &quotSIGN UP&quot;\newline	s_rankings.create.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.create.color				= colorRed;\newline	y += 20;\newline\newline	s_rankings.spectate.generic.type		= MTYPE_PTEXT;\newline	s_rankings.spectate.generic.flags		= QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.spectate.generic.id			= ID_SPECTATE;\newline	s_rankings.spectate.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.spectate.generic.x			= 320;\newline	s_rankings.spectate.generic.y			= y;\newline	s_rankings.spectate.string				= &quotSPECTATE&quot;\newline	s_rankings.spectate.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.spectate.color				= colorRed;\newline	y += 20;\newline\newline	s_rankings.setup.generic.type		= MTYPE_PTEXT;\newline	s_rankings.setup.generic.flags		= QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.setup.generic.id			= ID_SETUP;\newline	s_rankings.setup.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.setup.generic.x			= 320;\newline	s_rankings.setup.generic.y			= y;\newline	s_rankings.setup.string				= &quotSETUP&quot;\newline	s_rankings.setup.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.setup.color				= colorRed;\newline	y += 20;\newline\newline	s_rankings.leave.generic.type		= MTYPE_PTEXT;\newline	s_rankings.leave.generic.flags		= QMF_CENTER_JUSTIFY|QMF_PULSEIFFOCUS;\newline	s_rankings.leave.generic.id			= ID_LEAVE;\newline	s_rankings.leave.generic.callback	= Rankings_MenuEvent;\newline	s_rankings.leave.generic.x			= 320;\newline	s_rankings.leave.generic.y			= y;\newline	s_rankings.leave.string				= &quotLEAVE ARENA&quot;\newline	s_rankings.leave.style				= UI_CENTER|UI_SMALLFONT;\newline	s_rankings.leave.color				= colorRed;\newline	y += 20;\newline\newline	status = (grank_status_t)trap_Cvar_VariableValue(&quotclient_status&quot);\newline	if( (status != QGR_STATUS_NEW) &amp&amp (status != QGR_STATUS_SPECTATOR) )\newline	{\newline		s_rankings.login.generic.flags |= QMF_HIDDEN | QMF_INACTIVE;	\newline		s_rankings.create.generic.flags |= QMF_HIDDEN | QMF_INACTIVE;\newline		s_rankings.spectate.generic.flags |= QMF_HIDDEN | QMF_INACTIVE;\newline\newline		s_rankings.logout.generic.flags &amp= ~(QMF_HIDDEN | QMF_INACTIVE);\newline	}\newline	\newline	if ( (status == QGR_STATUS_VALIDATING) ||\newline		 (status == QGR_STATUS_PENDING) ||\newline		 (status == QGR_STATUS_LEAVING) )\newline	{\newline		s_rankings.login.generic.flags  |= QMF_GRAYED;\newline		s_rankings.create.generic.flags |= QMF_GRAYED;\newline		s_rankings.logout.generic.flags |= QMF_GRAYED;\newline	}\newline	\newline	//GRank FIXME -- don&#039t need setup option any more\newline	s_rankings.setup.generic.flags |= QMF_HIDDEN | QMF_INACTIVE;\newline\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.frame );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.login );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.logout );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.create );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.spectate );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.setup );\newline	Menu_AddItem( &amps_rankings.menu, (void*) &amps_rankings.leave );\newline}\newline",\newline===============\newlineRankings_MenuInit\newline===============\newline \newline,5072234,menuitem.c,"static void clear_menu_item_background(\newline	MenuPaintItemParameters *mpip, int x, int y, int w, int h)\newline{\newline	MenuStyle *ms = mpip-&gtms;\newline\newline	if (!ST_HAS_MENU_CSET(ms) &amp&amp\newline	    ST_FACE(ms).type == GradientMenu &amp&amp\newline	    (ST_FACE(ms).gradient_type == D_GRADIENT ||\newline	     ST_FACE(ms).gradient_type == B_GRADIENT))\newline	{\newline		XEvent e;\newline\newline		e.xexpose.x = x;\newline		e.xexpose.y = y;\newline		e.xexpose.width = w;\newline		e.xexpose.height = h;\newline		mpip-&gtcb_reset_bg(mpip-&gtcb_mr, &ampe);\newline	}\newline	else\newline	{\newline		XClearArea(dpy, mpip-&gtw, x, y, w, h, False);\newline	}\newline}\newline",---------------------------- local functions ---------------------------- \newline,,,on,,,,,,,,,,on,on,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,Creates a new string,Given as inputs start_arg and count_arg,{},Inserts a new resource into the database.,Add a word to the wordlist,Receive a (character) buffer. Returns 1 on success.,append a character to a malloc'ed string,returns role for an usage indication,drop down into a directory,Dumps configuration to stdout.,Tries to allocate a tunnel interface from the kernel.,Read db entries from stream and fill a lsit of db entries,{},{},Try to increase the size of the parser stack.,{},the hotplug functions will also be missing on unsupported platforms,Doesn't change the contents of the disjuncts.,Send a (prefixed) command to a single client.,Load an image from the named file.,"Get the list of class names of a java object,",x,
3E9ZFLPWOYSQTBRDV0445HES5ZLXIX,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:20 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:20 PDT 2019,,,3TAYZSBPLL8G9TO52PIQ8CM8JJ32SK,AITP2LUW8GPB,Submitted,Fri Apr 26 13:04:23 PDT 2019,Fri Apr 26 13:34:40 PDT 2019,Sun Apr 28 13:34:40 PDT 2019,,,,1817,100% (62/62),100% (62/62),0% (0/0),503104,qcustomplot.cpp,void QCPAbstractLegendItem::setSelectedFont(const QFont &ampfont)\newline{\newline  mSelectedFont = font;\newline}\newline,"!\newlineWhen this legend item is selected, \\a font is used to draw generic text, instead of the normal\newlinefont set with \\ref setFont.\newline\newline\\see setFont, QCPLegend::setSelectedFont\newline \newline",1419331,nnculls.c,"int cull_striples(int tnum, float *data) {\newline  int i,ic,icm1,kout=0,msgmx=0,fmsg=0;\newline  float *out,*xtmp; \newline\newline  ic   = 3*sizeof(float);\newline  icm1 = 2*sizeof(float);\newline  out  = (float *) malloc(tnum*ic);\newline\newline/*\newline *  Copy over the first data triple.\newline */\newline  kout++;\newline  memcpy( (void *) out, (void *) data, ic);\newline  \newline/*\newline *  Test for duplicate points and copy non-duplicates to out.  All\newline *  full duplicates (coordinates plus data values) will be culled,\newline *  but duplicate coordinates having different data values will \newline *  produce a fatal error.\newline */\newline  for (i = 1; i &lt tnum; i++) {\newline/*\newline *  Test for duplicate triples - do not copy them to &quotout&quot.\newline */\newline    if (memcmp((void *)(data+3*(i-1)), (void *)(data+3*i), ic) == 0) {\newline      if (msgmx &gt= maxmsg &amp&amp fmsg == 0 &amp&amp maxmsg &gt 0) {\newline        printf(&quotNatgrid - maximum number of messages about duplicate input coordinates \\n&quot);\newline        printf(&quot          has been reached - no more such messages will be issued\\n&quot);\newline        printf(&quot          for this Natgrid call.\\n&quot);\newline        fmsg = 1;\newline      } \newline      else if (msgmx &lt maxmsg &amp&amp fmsg == 0) {\newline        printf(&quotNatgrid info message - duplicate coordinate found, and culled,\\n&quot);\newline        printf(&quot                       in the input data for coordinate (%f,%f)\\n&quot,\newline               data[3*(i-1)], data[3*(i-1)+1]);\newline        msgmx++;\newline      }\newline    }\newline\newline/*\newline *  In the case of Natgrid the test for duplicate coordinates with \newline *  different data values has already been done in the call to\newline *  qsort_triples.  If this were not the case, the following \newline *  commented lines would be appropriate to uncomment.\newline * \newline *  else if ( (memcmp((void *)(data+3*(i-1)), \newline *                    (void *)(data+3*i), \newline *                    2*sizeof(float);) == 0) &amp&amp\newline *            (memcmp((void *)(data+3*(i-1)), \newline *                    (void *)(data+3*i), \newline *                    ic  ) != 0) ) {\newline *      printf(&quotError: duplicate coordinates found in the input data, at \\\newline *              coordinate (%f,%f), having different data values.&quot, \\\newline *              data[i*ic],data[i*ic+1]);\newline *  }\newline */\newline\newline/*\newline *  Copy non-duplicate value to output.\newline */\newline    else {\newline        memcpy((void *)(out+3*kout), (void *)(data+3*i), ic);\newline        kout++;\newline    }\newline  }\newline\newline/*  \newline *  Copy unique values back to the input array and free memory.\newline */\newline  memcpy((void *)data, (void *)out, kout*ic);\newline  free (out);\newline  return kout;\newline}\newline",\newline This function culls duplicate single precision triples \newline from an array of &quottnum&quot such in &quotdata&quot. The triples\newline in &quotdata&quot are assumed to have been sorted into\newline ascending order. The number of distinct triples\newline is returned and the distinct triples themselves\newline are stored back in data.\newline \newline,4617558,mcu.c,"void InitMcuTable (int numMCU,int compsInScan)\newline{\newline    int i, mcuSize;\newline    char *buffer;\newline\newline    /*\newline     * Compute size of on MCU (in bytes).  Round up so it&#039s on a\newline     * boundary for any alignment.  In this code, we assume this\newline     * is a whole multiple of sizeof(double).\newline     */\newline    mcuSize = compsInScan * sizeof(ComponentType);\newline    mcuSize = JroundUp(mcuSize,sizeof(double));\newline\newline    /*\newline     * Allocate the MCU table, and a buffer which will contain all\newline     * the data.  Then carve up the buffer by hand.  Note that\newline     * mcuTable[0] points to the buffer, in case we want to free\newline     * it up later.\newline     */\newline    mcuTable = (MCU *)malloc(numMCU * sizeof(MCU));\newline    if (mcuTable==NULL)\newline       fprintf(stderr,&quotNot enough memory for mcuTable\\n&quot);\newline    buffer = (char *)malloc((unsigned)(numMCU * mcuSize));\newline    if (buffer==NULL)\newline       fprintf(stderr,&quotNot enough memory for buffer\\n&quot);\newline    for (i=0; i&ltnumMCU; i++) {\newline        mcuTable[i] = (MCU)(buffer + i*mcuSize);\newline    }\newline}\newline","\newline --------------------------------------------------------------\newline \newline MakeMCU, InitMcuTable --\newline \newline InitMcuTable does a big malloc to get the amount of memory\newline we&#039ll need for storing MCU&#039s, once we know the size of our\newline input and output images.\newline MakeMCU returns an MCU for input parsing.\newline \newline Results:\newline A new MCU\newline \newline Side effects:\newline None.\newline \newline --------------------------------------------------------------\newline \newline",3693560,igtl_bind.c,igtl_uint64 igtl_bind_get_size_request(igtl_bind_info * info)\newline{\newline  igtl_uint64 size;\newline  igtl_uint32 ntable_size;\newline  igtl_uint16 i;\newline  igtl_uint16 nc;\newline  \newline  nc = info-&gtncmessages;\newline\newline  /* Size of NCMESSAGES section */\newline  size = sizeof(igtl_uint16);\newline\newline  /* Add size of BIND header section */\newline  size += (IGTL_HEADER_TYPE_SIZE+sizeof(igtl_uint64)) * nc;\newline\newline  /* Add size of table size field*/\newline  size += sizeof(igtl_uint16);\newline\newline  /* Calculate size of name table */\newline  ntable_size = 0;\newline  for (i = 0; i &lt nc; i ++)\newline    {\newline    /* string length + NULL separator */\newline    ntable_size += strlen(info-&gtchild_info_array[i].name) + 1;\newline    }\newline\newline  return size;\newline\newline}\newline,\newline Function to calculate size of GET_BIND/STT_BIND messages\newline \newline,4587659,layout_file.c,"static int process_enum (FILE *f, int skip_add)\newline { static const size_t N_MATCHES = 4;\newline   char line[LINE_BUF_SIZE];\newline   regmatch_t match[N_MATCHES];\newline   cmos_enum_t cmos_enum;\newline   int result;\newline\newline   result = 1;\newline\newline   for (; ; line_num++)\newline    { if (get_layout_file_line(f, line, LINE_BUF_SIZE))\newline       { fprintf(stderr,\newline                 &quot%s: Unexpected end of CMOS layout file reached while &quot\newline                 &quotreading \\&quotenumerations\\&quot section.\\n&quot, prog_name);\newline         exit(1);\newline       }\newline\newline      if (!regexec(&ampblank_or_comment_expr, line, 0, NULL, 0))\newline         continue;\newline\newline      if (regexec(&ampenums_line_expr, line, N_MATCHES, match, 0))\newline       { if (regexec(&ampstart_checksums_expr, line, 0, NULL, 0))\newline          { fprintf(stderr, &quot%s: Syntax error on line %d of CMOS layout &quot\newline                    &quotfile.\\n&quot, prog_name, line_num);\newline            exit(1);\newline          }\newline\newline         break;  /* start of checksums reached: no more enumerations */\newline       }\newline\newline      result = 0;  /* next layout enumeration found */\newline\newline      if (skip_add)\newline         break;\newline\newline      line[match[1].rm_eo] = &#039\\0&#039;\newline      line[match[2].rm_eo] = &#039\\0&#039;\newline      line[match[3].rm_eo] = &#039\\0&#039;\newline      create_enum(&ampcmos_enum, &ampline[match[1].rm_so], &ampline[match[2].rm_so],\newline                  &ampline[match[3].rm_so]);\newline      try_add_cmos_enum(&ampcmos_enum);\newline      break;\newline    }\newline\newline   line_num++;\newline   return result;\newline }\newline",\newline process_enum\newline \newline Get an enuneration from &quotenumerations&quot section of file and add it to our\newline repository of layout information. Return 0 if an enumeration was found\newline and processed. Return 1 if there are no more enumerations.\newline \newline,2666020,hash.c,"int MMG_hashFace(Hface *hash,int iel,int *v) {\newline  int        key,mins,maxs,sum;\newline  hface     *ht;\newline\newline  mins = M_MIN(v[0],v[1]);\newline  mins = M_MIN(mins,v[2]);\newline  maxs = M_MAX(v[0],v[1]);\newline  maxs = M_MAX(maxs,v[2]);\newline\newline  /* compute key */\newline  sum = v[0] + v[1] + v[2];\newline  key = KTA*mins + KTB*maxs + KTC*sum;\newline  key = key % hash-&gtsize;\newline\newline  ht = &amphash-&gtitem[key];\newline\newline  if ( ht-&gtmin ) {\newline    if ( ht-&gtmin == mins &amp&amp ht-&gtmax == maxs &amp&amp ht-&gtsum == sum )\newline      return(ht-&gtiel);\newline    else\newline      while ( ht-&gtnxt &amp&amp ht-&gtnxt &lt hash-&gtnhmax ) {\newline        ht = &amphash-&gtitem[ht-&gtnxt];\newline	if ( ht-&gtmin == mins &amp&amp ht-&gtmax == maxs &amp&amp ht-&gtsum == sum )\newline	  return(ht-&gtiel);\newline      }\newline    ht-&gtnxt = hash-&gthnxt;\newline    ht      = &amphash-&gtitem[hash-&gthnxt];\newline    ++hash-&gthnxt;\newline    if ( hash-&gthnxt == hash-&gtnhmax ) {\newline      fprintf(stdout,&quot  ## memory alloc problem (hash)\\n&quot);\newline      return(0);\newline    }\newline  }\newline\newline  ht-&gtmin = mins;\newline  ht-&gtmax = maxs;\newline  ht-&gtsum = sum;\newline  ht-&gtiel = iel;\newline  ht-&gtnxt = 0;\newline\newline  return(iel);\newline}\newline","hash triangles and return\newlineiel: face stored, 0 problem \newline",2700177,xenstat_freebsd.c,void xenstat_uninit_vbds(xenstat_handle * handle)\newline{\newline}\newline,Free VBD information in handle \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2033913,chs.c,"u_int part_updatechs(part_t *part, partinfo_t *pinfo)\newline{\newline  geometry_t geo;\newline  u_int ret = 0;\newline\newline  assert(part != NULL);\newline  assert(pinfo != NULL);\newline\newline  dbg_printf(&quotpart_updatechs([bs=0x%X, be=0x%X, type=0x%X])&quot,\newline             pinfo-&gtblk_start, pinfo-&gtblk_end, pinfo-&gttype);\newline  dbg_level_up();\newline\newline  if (pinfo-&gtchs_valid == 0) {\newline    if (!blkio_getgeometry(part-&gtblkio, &ampgeo))\newline      set_error(&quotunable to get geometry&quot);\newline    else {\newline      part_calcchs(&amppinfo-&gtchs_start, &ampgeo, pinfo-&gtblk_start);\newline      part_calcchs(&amppinfo-&gtchs_end, &ampgeo, pinfo-&gtblk_end);\newline      pinfo-&gtchs_valid = 1;\newline      ret = 1;\newline    }\newline  } else\newline    ret = 1;\newline\newline  dbg_printf(&quotstart=[C=%d,H=%d,S=%d] end=[C=%d,H=%d,S=%d]&quot,\newline             pinfo-&gtchs_start.cylinder, pinfo-&gtchs_start.head, pinfo-&gtchs_start.sector,\newline             pinfo-&gtchs_end.cylinder, pinfo-&gtchs_end.head, pinfo-&gtchs_end.sector);\newline\newline  dbg_level_down();\newline  dbg_printf(&quotret %s&quot, ret ? &quotok&quot : &quoterror&quot);\newline\newline  return ret;\newline}\newline","Prototype: u_int part_updatechs(part_t part, partinfo_t pinfo)\newline Purpose : Update CHS values if they have become invalid\newline Params : part - partitionable device\newline : pinfo - partition to update\newline Returns : FALSE on error\newline \newline",101426,commands.c,"void cmd_move_con_to_output(I3_CMD, const char *name) {\newline    DLOG(&quotShould move window to output \\&quot%s\\&quot.\\n&quot, name);\newline    HANDLE_EMPTY_MATCH;\newline\newline    owindow *current;\newline    bool had_error = false;\newline    TAILQ_FOREACH(current, &ampowindows, owindows) {\newline        DLOG(&quotmatching: %p / %s\\n&quot, current-&gtcon, current-&gtcon-&gtname);\newline\newline        Output *current_output = get_output_for_con(current-&gtcon);\newline        assert(current_output != NULL);\newline\newline        Output *output = get_output_from_string(current_output, name);\newline        if (output == NULL) {\newline            ELOG(&quotCould not find output \\&quot%s\\&quot, skipping.\\n&quot, name);\newline            had_error = true;\newline            continue;\newline        }\newline\newline        Con *ws = NULL;\newline        GREP_FIRST(ws, output_get_content(output-&gtcon), workspace_is_visible(child));\newline        if (ws == NULL) {\newline            ELOG(&quotCould not find a visible workspace on output %p.\\n&quot, output);\newline            had_error = true;\newline            continue;\newline        }\newline\newline        con_move_to_workspace(current-&gtcon, ws, true, false, false);\newline    }\newline\newline    cmd_output-&gtneeds_tree_render = true;\newline    ysuccess(!had_error);\newline}\newline",\newline Implementation of &#039move [window|container] [to] output &ltstr&gt&#039.\newline \newline \newline,90851,nbase_misc.c,"int dup_socket(int sd) {\newline#ifdef WIN32\newline  HANDLE copy;\newline\newline  if (DuplicateHandle(GetCurrentProcess(), (HANDLE) sd,\newline                      GetCurrentProcess(), &ampcopy,\newline                      0, FALSE, DUPLICATE_SAME_ACCESS) == 0) {\newline    return -1;\newline  }\newline\newline  return (int) copy;\newline#else\newline  return dup(sd);\newline#endif\newline}\newline","The dup function on Windows works only on file descriptors, not socket\newlinehandles. This function accomplishes the same thing for sockets. \newline",201773,tonegen.c,"static void writeSamples (float * buf,\newline			  size_t sampleLength,\newline			  double ap [],\newline			  size_t apLen,\newline			  double attenuation,\newline			  double f1Hz)\newline{\newline  const double fullCircle = 2.0 * M_PI;\newline  double apl[MAX_PARTIALS];\newline  double plHz[MAX_PARTIALS];\newline  double aplSum;\newline  double U;\newline  float * yp = buf;\newline  unsigned int i;\newline\newline  for (i = 0, aplSum = 0.0; i &lt MAX_PARTIALS; i++) {\newline    /* Select absolute amplitude */\newline    apl[i] = (i &lt apLen) ? ap[i] : 0.0;\newline    /* Accumulate normalization base */\newline    aplSum += fabs (apl[i]);\newline    /* Compute harmonic frequency */\newline    plHz[i] = f1Hz * ((double) (i + 1));\newline    /* Prevent aliasing; mute just below the Nyquist rate */\newline    if ((SampleRateD * 0.5) &lt= plHz[i]) {\newline      apl[i] = 0.0;\newline    }\newline  }\newline\newline  /* Normalise amplitudes */\newline\newline  U = attenuation / aplSum;\newline\newline  for (i = 0; i &lt sampleLength; i++) {\newline\newline    int j;\newline    double s = 0.0;\newline\newline    for (j = 0; j &lt MAX_PARTIALS; j++) {\newline      s +=\newline	apl[j] * sin (remainder ((plHz[j] * fullCircle * (double) i) / SampleRateD,\newline			    fullCircle));\newline    }\newline\newline    /* 24-sep-2003/FK\newline     * Noise-shaping in an attempt to diffuse the quantization artifacts.\newline     * It did not work of course, but may add some analogue credibility\newline     * so it can be in for the moment. We add one bit of noise to the\newline     * least significant bit of the sample.\newline     */\newline\newline#if 1\newline      *yp = (rand () &lt (RAND_MAX &gt&gt 1)) ? 1.0/32767.0 : 0;\newline      *yp++ += (U * s);\newline#else\newline      *yp++ = (U * s);\newline#endif\newline\newline  } /* for */\newline}\newline","\newline This routine writes the sample buffer for a simulated tone wheel.\newline In addition to the sine wave of the fundamental frequency, the routine\newline also allows the specification of chromatic harmonics.\newline There is no specification of phase.\newline This is an attempt to simulate the effect of transformer distortion and\newline generally make the output more &#039warm&#039. If that really is the shape\newline generated by the real tonewheels remains to be seen (or heard). Anyway,\newline it is my current best guess as to the direction to go. Remember, the\newline chromatic harmonics are different from the harmonics added by the\newline drawbar system. The tonewheels are tuned to the tempered scale, and\newline thus will &#039beat&#039 very subtly against the chromatics.\newline \newline @param buf Pointer to wave buffer\newline @param sampleLength The number of 16-bit samples in the buffer\newline @param ap Array of partial amplitudes\newline @param apLen Nof elements in ap[]\newline @param attenuation Final volume of wave (0.0 -- 1.0).\newline @param f1Hz Frequency of the fundamental.\newline \newline Please note that the amplitudes of the fundamental and harmonic frequencies\newline are normalised so that the volume of the composite curve is 1.0. This\newline means that if you supply f1a=1.0, f2a=0.1 and f3a=0.05 the actual\newline proportions will be:\newline \newline f1a = 1.00 / 1.15 = 0.8695652173913044\newline f2a = 0.10 / 1.15 = 0.08695652173913045\newline f3a = 0.05 / 1.15 = 0.04347826086956522\newline \newline Be aware of this, or make sure that the arguments sum to 1.\newline \newline",5161708,apcupsd.c,"void apcupsd_error_out(const char *file, int line, const char *fmt, va_list arg_ptr)\newline{\newline   char buf[256];\newline   int i;\newline\newline   asnprintf(buf, sizeof(buf),\newline      &quotapcupsd FATAL ERROR in %s at line %d\\n&quot, file, line);\newline\newline   i = strlen(buf);\newline   avsnprintf((char *)&ampbuf[i], sizeof(buf) - i, (char *)fmt, arg_ptr);\newline\newline   fprintf(stderr, &quot%s&quot, buf);\newline   log_event(core_ups, LOG_ERR, &quot%s&quot, buf);\newline   apcupsd_error_cleanup(core_ups);     /* finish the work */\newline}\newline","\newline Subroutine error_out prints FATAL ERROR with file,\newline line number, and the error message then cleans up \newline and exits. It is normally called from the Error_abort\newline define, which inserts the file and line number.\newline \newline",4932001,prvm_edict.c,"static ddef_t *PRVM_ED_GlobalAtOfs (prvm_prog_t *prog, int ofs)\newline{\newline	ddef_t		*def;\newline	int			i;\newline\newline	for (i = 0;i &lt prog-&gtnumglobaldefs;i++)\newline	{\newline		def = &ampprog-&gtglobaldefs[i];\newline		if (def-&gtofs == ofs)\newline			return def;\newline	}\newline	return NULL;\newline}\newline",\newline============\newlinePRVM_ED_GlobalAtOfs\newline============\newline \newline,282074,row-set.c,"RowSetIterator *TablePairMakeRowSetIterator ( struct TablePair *self, const ctx_t *ctx,\newline    struct MapFile const *sort_idx, bool pairs, bool large )\newline{\newline    FUNC_ENTRY ( ctx );\newline\newline    if ( sort_idx != NULL )\newline    {\newline        if ( pairs )\newline            return MapFileMakeMappingRowSetIterator ( sort_idx, ctx, large );\newline\newline        return MapFileMakeSortingRowSetIterator ( sort_idx, ctx, large );\newline    }\newline\newline    if ( pairs )\newline        return TablePairMakeMappingRowSetIterator ( self, ctx, large );\newline\newline    return TablePairMakeSimpleRowSetIterator ( self, ctx );\newline}\newline","MakeRowSetIterator\newline make RowSet iterator based upon parameters\newline each RowSet will generate row-ids in src order\newline \newline &quotsort_idx&quot [ IN ]\newline if NULL, the RowSet objects will auto-generate row-ids\newline otherwise, src row-ids will be selected from MapFile\newline \newline &quotpairs&quot [ IN ]\newline if true, the row-ids will be generated into an IdxMapping pair\newline if false but &quotidx&quot is not NULL, the src row-ids will be generated\newline into a single-id map, and new ordering preserved in parallel\newline if false and &quotidx&quot is NULL, no additional structure will be generated\newline \newline",5289578,libtommath.c,"static int mp_lshd (mp_int * a, int b)\newline{\newline  int     x, res;\newline\newline  /* if its less than zero return */\newline  if (b &lt= 0) {\newline    return MP_OKAY;\newline  }\newline\newline  /* grow to fit the new digits */\newline  if (a-&gtalloc &lt a-&gtused + b) {\newline     if ((res = mp_grow (a, a-&gtused + b)) != MP_OKAY) {\newline       return res;\newline     }\newline  }\newline\newline  {\newline    register mp_digit *top, *bottom;\newline\newline    /* increment the used by the shift amount then copy upwards */\newline    a-&gtused += b;\newline\newline    /* top */\newline    top = a-&gtdp + a-&gtused - 1;\newline\newline    /* base */\newline    bottom = a-&gtdp + a-&gtused - 1 - b;\newline\newline    /* much like mp_rshd this is implemented using a sliding window\newline     * except the window goes the otherway around.  Copying from\newline     * the bottom to the top.  see bn_mp_rshd.c for more info.\newline     */\newline    for (x = a-&gtused - 1; x &gt= b; x--) {\newline      *top-- = *bottom--;\newline    }\newline\newline    /* zero the lower digits */\newline    top = a-&gtdp;\newline    for (x = 0; x &lt b; x++) {\newline      *top++ = 0;\newline    }\newline  }\newline  return MP_OKAY;\newline}\newline",shift left a certain amount of digits \newline,1563109,aaip_0_2.c,"int aaip_add_acl_st_mode(char *acl_text, mode_t st_mode, int flag)\newline{\newline char *wpt;\newline int tag_types= 0;\newline\newline tag_types = aaip_cleanout_st_mode(acl_text, &ampst_mode, 1);\newline if(!(tag_types &amp (4 | 32))) {\newline   wpt= acl_text + strlen(acl_text);\newline   sprintf(wpt, &quotuser::%c%c%c\\n&quot,\newline           st_mode &amp S_IRUSR ? &#039r&#039 : &#039-&#039,\newline           st_mode &amp S_IWUSR ? &#039w&#039 : &#039-&#039,\newline           st_mode &amp S_IXUSR ? &#039x&#039 : &#039-&#039);\newline }\newline if(!(tag_types &amp (2 | 16 | 1024))) {\newline   wpt= acl_text + strlen(acl_text);\newline   sprintf(wpt, &quotgroup::%c%c%c\\n&quot,\newline         st_mode &amp S_IRGRP ? &#039r&#039 : &#039-&#039,\newline         st_mode &amp S_IWGRP ? &#039w&#039 : &#039-&#039,\newline         st_mode &amp S_IXGRP ? &#039x&#039 : &#039-&#039);\newline }\newline if(!(tag_types &amp (1 | 8))) {\newline   wpt= acl_text + strlen(acl_text);\newline   sprintf(wpt, &quotother::%c%c%c\\n&quot,\newline         st_mode &amp S_IROTH ? &#039r&#039 : &#039-&#039,\newline         st_mode &amp S_IWOTH ? &#039w&#039 : &#039-&#039,\newline         st_mode &amp S_IXOTH ? &#039x&#039 : &#039-&#039);\newline }\newline if((tag_types &amp (128 | 256)) &amp&amp !(tag_types &amp 512)) {\newline   wpt= acl_text + strlen(acl_text);\newline   sprintf(wpt, &quotmask::%c%c%c\\n&quot,\newline         st_mode &amp S_IRGRP ? &#039r&#039 : &#039-&#039,\newline         st_mode &amp S_IWGRP ? &#039w&#039 : &#039-&#039,\newline         st_mode &amp S_IXGRP ? &#039x&#039 : &#039-&#039);\newline }\newline return(1); \newline}\newline",Important: acl_text must provide 42 bytes more than its current length !\newline \newline,1195037,getcgi.c,"void unescape_url(char *url) \newline{\newline	register int i,j;\newline\newline	for(i=0,j=0; url[j]; ++i,++j) {\newline		if((url[i] = url[j]) == &#039%&#039) {\newline			url[i]=x2c(&ampurl[j+1]);\newline			j+=2;\newline		}\newline	}\newline	\newline	url[i] = &#039\\0&#039;\newline}\newline",Reduce any %xx escape sequences to the characters they represent \newline,111115,crypto.c,"int x509_crt_issuer_info(struct x509_crt *x509_crt,\newline    struct crt_issuer_info *cii)\newline/* ========================================================================= */\newline{\newline	const X509_NAME *subject;\newline	int num_entries, i;\newline	X509_NAME_ENTRY *entry;\newline	ASN1_OBJECT *object;\newline	int nid;\newline	ASN1_STRING *str;\newline	char **out_str;\newline\newline	debug_func_call();\newline\newline	if (NULL == x509_crt) {\newline		assert(0);\newline		goto fail;\newline	}\newline	if (NULL == cii) {\newline		assert(0);\newline		goto fail;\newline	}\newline\newline	subject = X509_get_subject_name((X509 *) x509_crt);\newline	if (NULL == subject) {\newline		goto fail;\newline	}\newline\newline	num_entries = _X509_NAME_entry_count(subject);\newline\newline	for (i = 0; i &lt num_entries; ++i) {\newline		entry = _X509_NAME_get_entry(subject, i);\newline		object = X509_NAME_ENTRY_get_object(entry);\newline		/* Reading object-&gtnid doesn&#039t work. */\newline		nid = OBJ_obj2nid(object);\newline		str = X509_NAME_ENTRY_get_data(entry);\newline\newline		out_str = NULL;\newline\newline		switch (nid) {\newline		case NID_organizationName:\newline			out_str = &ampcii-&gto;\newline			break;\newline		case NID_organizationalUnitName:\newline			out_str = &ampcii-&gtou;\newline			break;\newline		case NID_commonName:\newline			out_str = &ampcii-&gtn;\newline			break;\newline		case NID_countryName:\newline			out_str = &ampcii-&gtc;\newline			break;\newline		default:\newline			break;\newline		}\newline\newline		if (NULL != out_str) {\newline			*out_str = malloc(ASN1_STRING_length(str) + 1);\newline			if (NULL != *out_str) {\newline				memcpy(*out_str, _ASN1_STRING_get0_data(str),\newline				    ASN1_STRING_length(str));\newline				(*out_str)[ASN1_STRING_length(str)] = &#039\\0&#039;\newline			}\newline		}\newline	}\newline\newline	return 0;\newline\newlinefail:\newline	return -1;\newline}\newline",\newline Get information about the certificate issuer.\newline \newline,1649098,miniserver.c,"static UPNP_INLINE void handle_error(\newline	/*! [in] Socket Information object. */\newline	SOCKINFO *info,\newline	/*! [in] HTTP Error Code. */\newline	int http_error_code,\newline	/*! [in] Major Version Number. */\newline	int major,\newline	/*! [in] Minor Version Number. */\newline	int minor)\newline{\newline	http_SendStatusResponse(info, http_error_code, major, minor);\newline}\newline",!\newline \\brief Send Error Message.\newline \newline,5282894,lj_tab.c,"static LJ_AINLINE void clearhpart(GCtab *t)\newline{\newline  uint32_t i, hmask = t-&gthmask;\newline  Node *node = noderef(t-&gtnode);\newline  lua_assert(t-&gthmask != 0);\newline  for (i = 0; i &lt= hmask; i++) {\newline    Node *n = &ampnode[i];\newline    setmref(n-&gtnext, NULL);\newline    setnilV(&ampn-&gtkey);\newline    setnilV(&ampn-&gtval);\newline  }\newline}\newline",Clear hash part of table. \newline,,,,on,on,on,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,"setFont, QCPLegend::setSelectedFont",Implementation of 'move [window|container] [to] output <str>'.,"The dup function on Windows works only on file descriptors,",{},{},{},"if NULL, the RowSet objects will auto-generate row-ids",shift left a certain amount of digits,Important: acl_text must provide 42 bytes more than its current length,Reduce any %xx escape sequences to the characters they represent,Get information about the certificate issuer.,This function culls duplicate single precision triples,Send Error Message.,Clear hash part of table.,MakeMCU returns an MCU for input parsing.,Function to calculate size of GET_BIND/STT_BIND messages,{},hash triangles and return,Free VBD information in handle,Load an image from the named file.,Update CHS values if they have become invalid,x,
3Z33IC0JC0M5ELTFRRX943I46YQV99,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:22 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:22 PDT 2019,,,3SKEMFQBZ35T7PDMDXIPRH81OPKK8Q,AITP2LUW8GPB,Submitted,Fri Apr 26 13:49:54 PDT 2019,Fri Apr 26 13:51:42 PDT 2019,Sun Apr 28 13:51:42 PDT 2019,,,,108,100% (62/62),100% (62/62),0% (0/0),4961473,qftp.cpp,"bool QFtpPI::processReply()\newline{\newline#if defined(QFTPPI_DEBUG)\newline//    qDebug(&quotQFtpPI state: %d [processReply() begin]&quot, state);\newline    if (replyText.length() &lt 400) {\newline        qDebug(&quotQFtpPI recv: %d %s&quot, 100 * replyCode[0] + 10 * replyCode[1] + replyCode[2], replyText.toLatin1().constData());\newline    }\newline    else {\newline        qDebug(&quotQFtpPI recv: %d (text skipped)&quot, 100 * replyCode[0] + 10 * replyCode[1] + replyCode[2]);\newline    }\newline#endif\newline\newline    int replyCodeInt = 100 * replyCode[0] + 10 * replyCode[1] + replyCode[2];\newline\newline    // process 226 replies (&quotClosing Data Connection&quot) only when the data\newline    // connection is really closed to avoid short reads of the DTP\newline    if (replyCodeInt == 226 || (replyCodeInt == 250 &amp&amp currentCmd.startsWith(QLatin1String(&quotRETR&quot)))) {\newline        if (dtp.state() != QTcpSocket::UnconnectedState) {\newline            waitForDtpToClose = true;\newline            return false;\newline        }\newline    }\newline\newline    switch (abortState) {\newline    case AbortStarted:\newline        abortState = WaitForAbortToFinish;\newline        break;\newline    case WaitForAbortToFinish:\newline        abortState = None;\newline        return true;\newline    default:\newline        break;\newline    }\newline\newline    // get new state\newline    static const State table[5] = {\newline        /* 1yz   2yz      3yz   4yz      5yz */\newline        Waiting, Success, Idle, Failure, Failure\newline    };\newline    switch (state) {\newline    case Begin:\newline        if (replyCode[0] == 1) {\newline            return true;\newline        }\newline        else if (replyCode[0] == 2) {\newline            state = Idle;\newline            emit finished(QFtp::tr(&quotConnected to host %1&quot).arg(commandSocket.peerName()));\newline            break;\newline        }\newline        // reply codes not starting with 1 or 2 are not handled.\newline        return true;\newline    case Waiting:\newline        if (static_cast&ltsigned char&gt(replyCode[0]) &lt 0 || replyCode[0] &gt 5) {\newline            state = Failure;\newline        }\newline        else\newline#if defined(Q_OS_IRIX) &amp&amp defined(Q_CC_GNU)\newline        {\newline            // work around a crash on 64 bit gcc IRIX\newline            State* t = (State*) table;\newline            state = t[replyCode[0] - 1];\newline        }\newline#else\newline            if (replyCodeInt == 202) {\newline                state = Failure;\newline            }\newline            else {\newline                state = table[replyCode[0] - 1];\newline            }\newline#endif\newline        break;\newline    default:\newline        // ignore unrequested message\newline        return true;\newline    }\newline#if defined(QFTPPI_DEBUG)\newline//    qDebug(&quotQFtpPI state: %d [processReply() intermediate]&quot, state);\newline#endif\newline\newline    // special actions on certain replies\newline    emit rawFtpReply(replyCodeInt, replyText);\newline    if (rawCommand) {\newline        rawCommand = false;\newline    }\newline    else if (replyCodeInt == 227) {\newline        // 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)\newline        // rfc959 does not define this response precisely, and gives\newline        // both examples where the parenthesis are used, and where\newline        // they are missing. We need to scan for the address and host\newline        // info.\newline        QRegExp addrPortPattern(QLatin1String(&quot(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)&quot));\newline        if (addrPortPattern.indexIn(replyText) == -1) {\newline#if defined(QFTPPI_DEBUG)\newline            qDebug(&quotQFtp: bad 227 response -- address and port information missing&quot);\newline#endif\newline            // this error should be reported\newline        }\newline        else {\newline            QStringList lst = addrPortPattern.capturedTexts();\newline            QString host = lst[1] + QLatin1Char(&#039.&#039) + lst[2] + QLatin1Char(&#039.&#039) + lst[3] + QLatin1Char(&#039.&#039) + lst[4];\newline            quint16 port = (lst[5].toUInt() &lt&lt 8) + lst[6].toUInt();\newline            waitForDtpToConnect = true;\newline            dtp.connectToHost(host, port);\newline        }\newline    }\newline    else if (replyCodeInt == 229) {\newline        // 229 Extended Passive mode OK (|||10982|)\newline        int portPos = replyText.indexOf(QLatin1Char(&#039(&#039));\newline        if (portPos == -1) {\newline#if defined(QFTPPI_DEBUG)\newline            qDebug(&quotQFtp: bad 229 response -- port information missing&quot);\newline#endif\newline            // this error should be reported\newline        }\newline        else {\newline            ++portPos;\newline            QChar delimiter = replyText.at(portPos);\newline            QStringList epsvParameters = replyText.mid(portPos).split(delimiter);\newline\newline            waitForDtpToConnect = true;\newline            dtp.connectToHost(commandSocket.peerAddress().toString(),\newline                              epsvParameters.at(3).toInt());\newline        }\newline\newline    }\newline    else if (replyCodeInt == 230) {\newline        if (currentCmd.startsWith(QLatin1String(&quotUSER &quot)) &amp&amp pendingCommands.count() &gt 0 &amp&amp\newline                pendingCommands.first().startsWith(QLatin1String(&quotPASS &quot))) {\newline            // no need to send the PASS -- we are already logged in\newline            pendingCommands.pop_front();\newline        }\newline        // 230 User logged in, proceed.\newline        emit connectState(QFtp::LoggedIn);\newline    }\newline    else if (replyCodeInt == 213) {\newline        // 213 File status.\newline        if (currentCmd.startsWith(QLatin1String(&quotSIZE &quot))) {\newline            dtp.setBytesTotal(replyText.simplified().toLongLong());\newline        }\newline    }\newline    else if (replyCode[0] == 1 &amp&amp currentCmd.startsWith(QLatin1String(&quotSTOR &quot))) {\newline        dtp.waitForConnection();\newline        dtp.writeData();\newline    }\newline\newline    // react on new state\newline    switch (state) {\newline    case Begin:\newline        // should never happen\newline        break;\newline    case Success:\newline        // success handling\newline        state = Idle;\newline        // no break!\newline    case Idle:\newline        if (dtp.hasError()) {\newline            emit error(QFtp::UnknownError, dtp.errorMessage());\newline            dtp.clearError();\newline        }\newline        startNextCmd();\newline        break;\newline    case Waiting:\newline        // do nothing\newline        break;\newline    case Failure:\newline        // If the EPSV or EPRT commands fail, replace them with\newline        // the old PASV and PORT instead and try again.\newline        if (currentCmd.startsWith(QLatin1String(&quotEPSV&quot))) {\newline            transferConnectionExtended = false;\newline            pendingCommands.prepend(QLatin1String(&quotPASV\\r\\n&quot));\newline        }\newline        else if (currentCmd.startsWith(QLatin1String(&quotEPRT&quot))) {\newline            transferConnectionExtended = false;\newline            pendingCommands.prepend(QLatin1String(&quotPORT\\r\\n&quot));\newline        }\newline        else {\newline            emit error(QFtp::UnknownError, replyText);\newline        }\newline        if (state != Waiting) {\newline            state = Idle;\newline            startNextCmd();\newline        }\newline        break;\newline    }\newline#if defined(QFTPPI_DEBUG)\newline//    qDebug(&quotQFtpPI state: %d [processReply() end]&quot, state);\newline#endif\newline    return true;\newline}\newline",\newlineProcess a reply from the FTP server.\newlineReturns true if the reply was processed or false if the reply has to be\newlineprocessed at a later point.\newline \newline,2696558,event_fifo.c,"static bool_t evtchn_fifo_set_link(const struct domain *d, event_word_t *word,\newline                                   uint32_t link)\newline{\newline    event_word_t w;\newline    unsigned int try;\newline    int ret;\newline\newline    w = read_atomic(word);\newline\newline    ret = try_set_link(word, &ampw, link);\newline    if ( ret &gt= 0 )\newline        return ret;\newline\newline    /* Lock the word to prevent guest unmasking. */\newline    set_bit(EVTCHN_FIFO_BUSY, word);\newline\newline    w = read_atomic(word);\newline\newline    for ( try = 0; try &lt 4; try++ )\newline    {\newline        ret = try_set_link(word, &ampw, link);\newline        if ( ret &gt= 0 )\newline        {\newline            if ( ret == 0 )\newline                clear_bit(EVTCHN_FIFO_BUSY, word);\newline            return ret;\newline        }\newline    }\newline    gdprintk(XENLOG_WARNING, &quotdomain %d, port %d not linked\\n&quot,\newline             d-&gtdomain_id, link);\newline    clear_bit(EVTCHN_FIFO_BUSY, word);\newline    return 1;\newline}\newline","\newline Atomically set the LINK field iff it is still LINKED.\newline \newline The guest is only permitted to make the following changes to a\newline LINKED event.\newline \newline - set MASKED\newline - clear MASKED\newline - clear PENDING\newline - clear LINKED (and LINK)\newline \newline We block unmasking by the guest by marking the tail word as BUSY,\newline therefore, the cmpxchg() may fail at most 4 times.\newline \newline",2526622,fts3_unicodesn.c,static int unicodeClose(sqlite3_tokenizer_cursor *pCursor){\newline  unicode_cursor *pCsr = (unicode_cursor *) pCursor;\newline  if ( pCsr-&gtpStemmer != NULL ) {\newline     unicode_tokenizer *p = ((unicode_tokenizer *)pCsr-&gtbase.pTokenizer);\newline     p-&gtstemmer.close(pCsr-&gtpStemmer);\newline  }\newline  sqlite3_free(pCsr-&gtzToken);\newline  sqlite3_free(pCsr);\newline  return SQLITE_OK;\newline}\newline,\newline Close a tokenization cursor previously opened by a call to\newline simpleOpen() above.\newline \newline,5046742,csound.cpp,"static char* makeDescription(int numa, int numk=0)\newline{\newline    char* str = (char*)malloc(numa+numk+1); // NEED TO BE CHANGED ?\newline    if (str) {\newline        for (int i=0; i&ltnuma; i++) str[i] = &#039a&#039;\newline        for (int i=0; i&ltnumk; i++) str[numa+i] = &#039k&#039;\newline        str[numa+numk] = 0;\newline    }\newline    return str;\newline}\newline",\newline Creates a &quotaaakkkk&quot CSound description string. Note that\newline these string will never be released. Potential memory leak\newline \newline,4492625,vpfquery.c,"static void return_token( char *expr, char *token )\newline{\newline   register int i,j,n,found=0,stopflag;\newline\newline   n = 0;\newline   stopflag=0;\newline   while (expr[0] == &#039 &#039) {\newline      for (i=0;i&ltndelim;i++)\newline	 if (ossim_strncasecmp(expr,delimstr[i],(unsigned int)strlen(delimstr[i])) == 0) {\newline	    stopflag=1;\newline	    break;\newline	 }\newline      if (stopflag) break;\newline      expr++;\newline   }\newline   strcpy(token,expr);\newline   for (i=0;(unsigned int)i&ltstrlen(token);i++) {\newline      for (j=0;j&ltndelim;j++) {\newline	 if (ossim_strncasecmp(expr,delimstr[j],(unsigned int)strlen(delimstr[j]))==0) {\newline	    if (n&gt0)\newline	       token[i] = &#039\\0&#039;\newline	    else\newline	       token[strlen(delimstr[j])] = &#039\\0&#039;\newline	    found = 1;\newline	    break;\newline	 }\newline      }\newline      if ((found) || (!is_white(*expr))) n++;\newline      if ((!found)&amp&amp(*expr)) expr++;\newline/*      if (!is_white(*expr)) n++;  */\newline/*      if ((found) || (!is_white(*expr))) n++; */\newline      if (found) break;\newline   }\newline}\newline",\newline \newline N return_token\newline \newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Purpose:\newline P\newline This function returns the first token string found in the\newline expression string.\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Parameters:\newline A\newline expr &ltinput&gt==(char ) selection expression string.\newline token &ltoutput&gt==(char ) first token in the string.\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline History:\newline H\newline Barry Michaels May 1991 DOS Turbo C\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline External Variables:\newline X\newline None\newline E\newline ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\newline \newline Functions Called:\newline F\newline None\newline E\newline \newline,777736,dev-md.c,"unsigned long dev_md_stripe_width(struct dev_types *dt, struct device *dev)\newline{\newline	unsigned long chunk_size_sectors = 0UL;\newline	unsigned long stripe_width_sectors = 0UL;\newline	int level, raid_disks, data_disks;\newline\newline	chunk_size_sectors = dev_md_chunk_size(dt, dev);\newline	if (!chunk_size_sectors)\newline		return 0;\newline\newline	level = dev_md_level(dt, dev);\newline	if (level &lt 0)\newline		return 0;\newline\newline	raid_disks = dev_md_raid_disks(dt, dev);\newline	if (!raid_disks)\newline		return 0;\newline\newline	/* The raid level governs the number of data disks. */\newline	switch (level) {\newline	case 0:\newline		/* striped md does not have any parity disks */\newline		data_disks = raid_disks;\newline		break;\newline	case 1:\newline	case 10:\newline		/* mirrored md effectively has 1 data disk */\newline		data_disks = 1;\newline		break;\newline	case 4:\newline	case 5:\newline		/* both raid 4 and 5 have a single parity disk */\newline		data_disks = raid_disks - 1;\newline		break;\newline	case 6:\newline		/* raid 6 has 2 parity disks */\newline		data_disks = raid_disks - 2;\newline		break;\newline	default:\newline		log_error(&quotDevice %s has an unknown md raid level: %d&quot,\newline			  dev_name(dev), level);\newline		return 0;\newline	}\newline\newline	stripe_width_sectors = chunk_size_sectors * data_disks;\newline\newline	log_very_verbose(&quotDevice %s stripe-width is %lu bytes.&quot,\newline			 dev_name(dev),\newline			 stripe_width_sectors &lt&lt SECTOR_SHIFT);\newline\newline	return stripe_width_sectors;\newline}\newline",\newline Calculate stripe width of md device using its sysfs files.\newline \newline,11834,memory.c,"int init_memory( tsd_t *TSD )\newline{\newline   mem_tsd_t *mt;\newline\newline   if (TSD-&gtmem_tsd != NULL)\newline      return(1);\newline\newline   if ( ( TSD-&gtmem_tsd = TSD-&gtMTMalloc( TSD, sizeof(mem_tsd_t) ) ) == NULL )\newline      return(0);\newline   mt = (mem_tsd_t *)TSD-&gtmem_tsd;\newline   memset( mt, 0, sizeof(mem_tsd_t) );\newline   /*\newline    * Don&#039t register this chunk of memory! It contains the list of all\newline    * other blocks of memory to be freed!\newline    */\newline#ifdef FLISTS\newline   init_hash_table( mt ) ;\newline#endif\newline   return(1);\newline}\newline","\newline This function initiates the &#039mem_tsd&#039. This might have been\newline done initially, since the values in this will never change. But\newline since the size is rather big. it is more efficient to spend some\newline CPU on initiating it. The startup time might be decreased by swapping\newline this routine for a pre-defined variable. Perhaps it should be\newline rewritten to use two arrays, one for large pieces of memory and\newline one for small pieces. That would save space in &#039hash&#039\newline \newline The values put into the array has been described above.\newline The function returns 1 on success, 0 if memory is short.\newline \newline",6427118,binary_thresholding.cpp,"array otsu(const array&amp in)\newline{\newline    array gray;\newline    int channels = in.dims(2);\newline    if (channels&gt1)\newline        gray = colorSpace(in, AF_GRAY, AF_RGB);\newline    else\newline        gray = in;\newline    unsigned total = gray.elements();\newline    array hist = histogram(gray, 256, 0.0f, 255.0f);\newline    array wts = range(256);\newline\newline    array wtB = accum(hist);\newline    array wtF = total - wtB;\newline    array sumB = accum(wts*hist);\newline    array meanB = sumB / wtB;\newline    float lastElemInSumB;\newline    sumB(seq(255, 255, 1)).host((void*)&amplastElemInSumB);\newline    array meanF = (lastElemInSumB - sumB) / wtF;\newline    array mDiff = meanB - meanF;\newline\newline    array interClsVar = wtB * wtF * mDiff * mDiff;\newline\newline    float max = af::max&ltfloat&gt(interClsVar);\newline    float threshold2 = where(interClsVar == max).scalar&ltunsigned&gt();\newline    array threshIdx = where(interClsVar &gt= max);\newline    float threshold1 = threshIdx.elements()&gt0 ? threshIdx.scalar&ltunsigned&gt() : 0.0f;\newline\newline    return threshold(gray, (threshold1 + threshold2) / 2.0f);\newline}\newline",\newline Note:\newline suffix B indicates subset of all graylevels before current gray level\newline suffix F indicates subset of all graylevels after current gray level\newline \newline,311763,commands.c,"void disable_passive_service_checks(service *svc) {\newline	unsigned long attr = MODATTR_PASSIVE_CHECKS_ENABLED;\newline\newline	/* no change */\newline	if (svc-&gtaccept_passive_service_checks == FALSE)\newline		return;\newline\newline	/* set the attribute modified flag */\newline	svc-&gtmodified_attributes |= attr;\newline\newline	/* set the passive check flag */\newline	svc-&gtaccept_passive_service_checks = FALSE;\newline\newline#ifdef USE_EVENT_BROKER\newline	/* send data to event broker */\newline	broker_adaptive_service_data(NEBTYPE_ADAPTIVESERVICE_UPDATE, NEBFLAG_NONE, NEBATTR_NONE, svc, CMD_NONE, attr, svc-&gtmodified_attributes, NULL);\newline#endif\newline\newline	/* update the status log with the service info */\newline	update_service_status(svc, FALSE);\newline\newline	return;\newline}\newline",disables passive service checks for a particular service \newline,885111,string.c,"static char	*sh_fmtcsv(const char *string)\newline{\newline	register const char *cp = string;\newline	register int c;\newline	int offset;\newline	if(!cp)\newline		return((char*)0);\newline	offset = staktell();\newline	while((c=mbchar(cp)),isaname(c));\newline	if(c==0)\newline		return((char*)string);\newline	stakputc(&#039&quot&#039);\newline	stakwrite(string,cp-string);\newline	if(c==&#039&quot&#039)\newline		stakputc(&#039&quot&#039);\newline	string = cp;\newline	while(c=mbchar(cp))\newline	{\newline		if(c==&#039&quot&#039)\newline		{\newline			stakwrite(string,cp-string);\newline			string = cp;\newline			stakputc(&#039&quot&#039);\newline		}\newline	}\newline	if(--cp&gtstring)\newline		stakwrite(string,cp-string);\newline	stakputc(&#039&quot&#039);\newline	stakputc(0);\newline	return(stakptr(offset));\newline}\newline",\newline format string as a csv field\newline \newline,2285482,rrd_daemon.c,"static int open_listen_sockets_systemd(void) /* {{{ */\newline{\newline  listen_socket_t *temp;\newline  struct sockaddr_un sa;\newline  socklen_t l;\newline  int sd_fd;\newline  const char *env;\newline  unsigned long n;\newline\newline  /* check if it for us */\newline  env = getenv(&quotLISTEN_PID&quot);\newline  if (!env)\newline    return 0;\newline\newline  n = strtoul(env, NULL, 10);\newline  if (!n || n == ULONG_MAX || (pid_t)n != getpid())\newline    return 0;\newline\newline  /* get the number of passed descriptors */\newline  env = getenv(&quotLISTEN_FDS&quot);\newline  if (!env)\newline    return 0;\newline\newline  n = strtoul(env, NULL, 10);\newline  if (!n || n == ULONG_MAX)\newline    return 0;\newline\newline  temp = (listen_socket_t *) rrd_realloc (listen_fds,\newline     sizeof (listen_fds[0]) * (listen_fds_num + n));\newline  if (temp == NULL)\newline  {\newline    fprintf (stderr, &quotrrdcached: open_listen_socket_systemd: realloc failed.\\n&quot);\newline    return 0;\newline  }\newline  listen_fds = temp;\newline\newline  for (unsigned int i = 0; i &lt n; i++)\newline  {\newline    sd_fd = SD_LISTEN_FDS_START + i;\newline\newline    l = sizeof(sa);\newline    memset(&ampsa, 0, l);\newline    if (getsockname(sd_fd, (struct sockaddr *)&ampsa, &ampl) &lt 0)\newline    {\newline      fprintf(stderr, &quotopen_listen_sockets_systemd: problem getting fd %d: %s\\n&quot, sd_fd, rrd_strerror (errno));\newline      return i;\newline    }\newline\newline    listen_fds[listen_fds_num].fd = sd_fd;\newline    listen_fds[listen_fds_num].family = sa.sun_family;\newline    /* Add permissions to the socket */\newline    if (default_socket.permissions != 0)\newline      socket_permission_copy(&amplisten_fds[listen_fds_num], &ampdefault_socket);\newline    else\newline      /* Add permission for ALL commands to the socket. */\newline      socket_permission_set_all(&amplisten_fds[listen_fds_num]);\newline    listen_fds_num++;\newline  }\newline\newline  return n;\newline} /* }}} open_listen_sockets_systemd */\newline",\newline returns number of descriptors passed from systemd\newline \newline,2924720,edgeobject.c,"PyObject* igraphmodule_Edge_attributes(igraphmodule_EdgeObject* self) {\newline  igraphmodule_GraphObject *o = self-&gtgref;\newline  PyObject *names, *dict;\newline  long int i, n;\newline\newline  if (!igraphmodule_Edge_Validate((PyObject*)self))\newline    return 0;\newline\newline  dict=PyDict_New();\newline  if (!dict)\newline    return NULL;\newline\newline  names=igraphmodule_Graph_edge_attributes(o);\newline  if (!names) {\newline    Py_DECREF(dict);\newline    return NULL;\newline  }\newline\newline  n = PyList_Size(names);\newline  for (i=0; i&ltn; i++) {\newline    PyObject *name = PyList_GetItem(names, i);\newline    if (name) {\newline      PyObject *dictit;\newline      dictit = PyDict_GetItem(((PyObject**)o-&gtg.attr)[ATTRHASH_IDX_EDGE], name);\newline      if (dictit) {\newline        PyObject *value = PyList_GetItem(dictit, self-&gtidx);\newline        if (value) {\newline          /* no need to Py_INCREF, PyDict_SetItem will do that */\newline          PyDict_SetItem(dict, name, value);\newline        }\newline      }\newline    }\newline  }\newline\newline  Py_DECREF(names);\newline\newline  return dict;\newline}\newline",\\ingroup python_interface_edge\newline \\brief Returns a dict with attribute names and values\newline \newline,3250528,gzlog.c,"local int recomp(gz_log *log)\newline{\newline    z_stream strm;\newline    size_t len, max;\newline    unsigned char *in;\newline    unsigned char *out;\newline    unsigned char temp[16];\newline\newline    /* allocate space and read it all in (it&#039s around 1 MB) */\newline    len = log-&gtlast_off - log-&gtmark_off;\newline    max = len + (len &gt&gt 12) + (len &gt&gt 14) + 11;\newline    out = malloc(max);\newline    if (out == NULL)\newline        return 1;\newline    in = malloc(len);\newline    if (in == NULL) {\newline        free(out);\newline        return 1;\newline    }\newline    (void)lseek(log-&gtfd, log-&gtmark_off, SEEK_SET);\newline    if (read(log-&gtfd, in, len) != len) {\newline        free(in);\newline        free(out);\newline        return 1;\newline    }\newline\newline    /* recompress in memory, decoding stored data as we go */\newline    /* note: this assumes that unsigned is four bytes or more */\newline    /*       consider not making that assumption */\newline    strm.zalloc = Z_NULL;\newline    strm.zfree = Z_NULL;\newline    strm.opaque = Z_NULL;\newline    if (deflateInit2(&ampstrm, Z_BEST_COMPRESSION, Z_DEFLATED, -15, 8,\newline        Z_DEFAULT_STRATEGY) != Z_OK) {\newline        free(in);\newline        free(out);\newline        return 1;\newline    }\newline    strm.next_in = in;\newline    strm.avail_out = max;\newline    strm.next_out = out;\newline    while (len &gt= 5) {\newline        if (strm.next_in[0] != 0)\newline            break;\newline        strm.avail_in = strm.next_in[1] + (strm.next_in[2] &lt&lt 8);\newline        strm.next_in += 5;\newline        len -= 5;\newline        if (strm.avail_in != 0) {\newline            if (len &lt strm.avail_in)\newline                break;\newline            len -= strm.avail_in;\newline            (void)deflate(&ampstrm, Z_NO_FLUSH);\newline            if (strm.avail_in != 0 || strm.avail_out == 0)\newline                break;\newline        }\newline    }\newline    (void)deflate(&ampstrm, Z_SYNC_FLUSH);\newline    (void)deflateEnd(&ampstrm);\newline    free(in);\newline    if (len != 0 || strm.avail_out == 0) {\newline        free(out);\newline        return 1;\newline    }\newline\newline    /* overwrite stored data with compressed data */\newline    (void)lseek(log-&gtfd, log-&gtmark_off, SEEK_SET);\newline    len = max - strm.avail_out;\newline    if (write(log-&gtfd, out, len) != len) {\newline        free(out);\newline        return 1;\newline    }\newline    free(out);\newline\newline    /* write last empty block, crc, and length */\newline    log-&gtmark_off = log-&gtlast_off = lseek(log-&gtfd, 0, SEEK_CUR);\newline    temp[0] = 1;\newline    dice_ulg(0xffffL &lt&lt 16, temp + 1);\newline    dice_ulg(log-&gtcrc, temp + 5);\newline    dice_ulg(log-&gtlen, temp + 9);\newline    if (write(log-&gtfd, temp, 13) != 13)\newline        return 1;\newline\newline    /* truncate file to discard remaining stored data and old trailer */\newline    ftruncate(log-&gtfd, lseek(log-&gtfd, 0, SEEK_CUR));\newline\newline    /* update extra field to point to new last empty block */\newline    (void)lseek(log-&gtfd, log-&gtextra, SEEK_SET);\newline    dice_off(log-&gtmark_off, temp);\newline    dice_off(log-&gtlast_off, temp + 8);\newline    if (write(log-&gtfd, temp, 16) != 16)\newline        return 1;\newline    return 0;\newline}\newline",recompress the remaining stored deflate data in place \newline,4378154,di.c,"static gchar * get_question_value(struct frontend * fe, const char * template)\newline{\newline    struct question * question = fe-&gtqdb-&gtmethods.get(fe-&gtqdb, template);\newline    const char * result = NULL;\newline\newline    if (NULL != question) {\newline        result = question_getvalue(question, &quot&quot /* no language */);\newline    }\newline    if (NULL == result) {\newline        result = &quot&quot;\newline    }\newline    return g_strdup(result);\newline}\newline","Get the current value for a given template.\newline \newline The caller needs to free the returned string.\newline \newline @param fe cdebconf frontend\newline @param template name of the template\newline @return a newly allocated string containing the value, or an empty string\newline if the template was not found\newline \newline",2806845,parser.c,"static PData* parser_parse_file( FILE *file )\newline{\newline    char token[PARSER_MAX_TOKEN_LENGTH];\newline    PData *pd = 0, *sub = 0;\newline    \newline    /* get name */\newline    if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) )\newline        return 0;\newline    if ( is_symbol( token[0], PARSER_SYMBOLS ) ) {\newline        sprintf( parser_sub_error, &quotparse error before &#039%s&#039&quot, token );\newline        return 0;\newline    }\newline    pd = calloc( 1, sizeof( PData ) );\newline    pd-&gtname = parser_remove_quotes( token );\newline    /* check type */\newline    if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) )\newline        goto failure;\newline    switch ( token[0] ) {\newline        case PARSER_SET:\newline            /* assign single value or list */\newline            pd-&gtvalues = list_create( LIST_AUTO_DELETE, LIST_NO_CALLBACK );\newline            if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) ) \newline                goto failure;\newline            if ( token[0] != PARSER_LIST_BEGIN ) {\newline                if ( is_symbol( token[0], PARSER_SYMBOLS ) ) {\newline                    sprintf( parser_sub_error, &quotparse error before &#039%s&#039&quot, token );\newline                    goto failure;\newline                }\newline                else\newline                    list_add( pd-&gtvalues, parser_remove_quotes( token ) );\newline            }\newline            else {\newline                if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) )\newline                    goto failure;\newline                while ( token[0] != PARSER_LIST_END ) {\newline                    if ( is_symbol( token[0], PARSER_SYMBOLS ) ) {\newline                        sprintf( parser_sub_error, &quotparse error before &#039%s&#039&quot, token );\newline                        goto failure;\newline                    }\newline                    else\newline                        list_add( pd-&gtvalues, parser_remove_quotes( token ) );\newline                    if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) )\newline                        goto failure;\newline                }\newline            }\newline            break;\newline        case PARSER_GROUP_BEGIN:\newline            /* check all entries until PARSER_GROUP_END */\newline            pd-&gtentries = list_create( LIST_NO_AUTO_DELETE, LIST_NO_CALLBACK );\newline            while ( 1 ) {\newline                if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) ) \newline                    goto failure;\newline                if ( token[0] == PARSER_GROUP_END )\newline                    break;\newline                fseek( file, -strlen( token ), SEEK_CUR );\newline                sub = parser_parse_file( file );\newline                if ( sub ) \newline                    list_add( pd-&gtentries, sub );\newline                else\newline                    goto failure;\newline            }\newline            break;\newline        default:\newline            sprintf( parser_sub_error, &quotparse error before &#039%s&#039&quot, token );\newline            goto failure;\newline    }\newline    return pd;\newlinefailure:\newline    parser_free( &amppd );\newline    return 0;\newline}\newline",\newline====================================================================\newlineThis function searches file from the current position for the next\newlinepdata entry.\newline====================================================================\newline \newline,2689411,time.c,"static void timer_interrupt(int irq, void *dev_id, struct cpu_user_regs *regs)\newline{\newline    if ( irq == (timer_irq[TIMER_HYP_PPI]) &amp&amp\newline         READ_SYSREG32(CNTHP_CTL_EL2) &amp CNTx_CTL_PENDING )\newline    {\newline        perfc_incr(hyp_timer_irqs);\newline        /* Signal the generic timer code to do its work */\newline        raise_softirq(TIMER_SOFTIRQ);\newline        /* Disable the timer to avoid more interrupts */\newline        WRITE_SYSREG32(0, CNTHP_CTL_EL2);\newline    }\newline\newline    if ( irq == (timer_irq[TIMER_PHYS_NONSECURE_PPI]) &amp&amp\newline         READ_SYSREG32(CNTP_CTL_EL0) &amp CNTx_CTL_PENDING )\newline    {\newline        perfc_incr(phys_timer_irqs);\newline        /* Signal the generic timer code to do its work */\newline        raise_softirq(TIMER_SOFTIRQ);\newline        /* Disable the timer to avoid more interrupts */\newline        WRITE_SYSREG32(0, CNTP_CTL_EL0);\newline    }\newline}\newline",Handle the firing timer \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4316491,libvirt-sandbox-builder.c,GVirConnection *gvir_sandbox_builder_get_connection(GVirSandboxBuilder *builder)\newline{\newline    GVirSandboxBuilderPrivate *priv = builder-&gtpriv;\newline    g_object_ref(priv-&gtconnection);\newline    return priv-&gtconnection;\newline}\newline,\newline gvir_sandbox_builder_get_connection:\newline @builder: (transfer none): the sandbox builder\newline \newline Retrieves the sandbox connection\newline \newline Returns: (transfer full): the current connection\newline \newline,1807341,regress.c,void\newlineregress_test_glist_nothing_in (const GList *in)\newline{\newline  regress_assert_test_sequence_list (in);\newline}\newline,\newline regress_test_glist_nothing_in:\newline @in: (element-type utf8):\newline \newline,3285229,locationdb-test.c,"void parse(pi_file_t *pf)\newline{\newline  int result;\newline  int nentries;\newline  char *buf;\newline  int attrs, cat;\newline  size_t size;\newline  recordid_t uid;\newline  Location_t loc;\newline  int entnum;\newline  pi_buffer_t *pi_buf;\newline  pi_buffer_t *test;\newline  \newline  pi_file_get_entries(pf, &ampnentries);\newline  printf(&quotNumber of entries: %d\\n&quot, nentries);\newline  \newline  for (entnum = 0; entnum &lt nentries; entnum++) {\newline    if (pi_file_read_record(pf, entnum, (void **) &ampbuf, &ampsize,\newline                            &ampattrs, &ampcat, &ampuid) &lt 0) {\newline      printf(&quotError reading record number %d\\n&quot, entnum);\newline      return;\newline    }\newline\newline    /* Skip deleted records */\newline    if ((attrs &amp dlpRecAttrDeleted)\newline        || (attrs &amp dlpRecAttrArchived)) {\newline      continue;\newline    }\newline\newline    printf(&quotoriginal record %d\\n&quot, entnum);\newline    dump(buf, size);\newline\newline    pi_buf = pi_buffer_new(size);\newline    pi_buffer_append(pi_buf, buf, size);\newline      \newline    result = unpack_Location(&amploc, pi_buf);\newline    if(result == -1) {\newline      printf(&quotError unpacking record %d!\\n&quot, entnum);\newline    } else {\newline      printf(&quotTimezone name: %s\\n&quot, loc.tz.name);\newline      printf(&quot\\tOffset from GMT: %d minutes\\n&quot, loc.tz.offset);\newline      printf(&quot\\tDST observed: %d\\n&quot, loc.tz.dstObserved);\newline      printf(&quot\\tNote is: %s\\n&quot, loc.note);\newline\newline      printf(&quot\\tlat: %d degrees %d minutes\\n&quot, loc.latitude.degrees, loc.latitude.minutes);\newline      printf(&quot\\tlon: %d degrees %d minutes\\n&quot, loc.longitude.degrees, loc.longitude.minutes);\newline      \newline    }\newline\newline\newline    /* now try and pack the record and see if we get the same data */\newline    test = pi_buffer_new(0);\newline    result = pack_Location(&amploc, test);\newline    if(result == -1) {\newline      printf(&quotError packing record %d!\\n&quot, entnum);\newline    } else {\newline      printf(&quotpacked record\\n&quot);\newline      dump(test-&gtdata, test-&gtused);\newline      \newline      if(pi_buf-&gtused != test-&gtused) {\newline        int i;\newline        printf(&quotError: Different record sizes unpack: %d pack: %d last byte unpack: 0x%02X pack: 0x%02X\\n&quot, pi_buf-&gtused, test-&gtused, pi_buf-&gtdata[pi_buf-&gtused-1], test-&gtdata[test-&gtused-1]);\newline        for(i=0; i&ltpi_buf-&gtused; ++i) {\newline          if(pi_buf-&gtdata[i] != test-&gtdata[i]) {\newline            printf(&quotError: Byte %d is different unpack: 0x%02X pack: 0x%02X\\n&quot, i, pi_buf-&gtdata[i], test-&gtdata[i]);\newline          }\newline        }\newline      }\newline    }\newline    \newline      \newline    pi_buffer_free(test);\newline    \newline    pi_buffer_free(pi_buf);\newline    free_Location(&amploc);\newline  }\newline}\newline",\newline Test parsing database.\newline \newline,1345728,server_common.c,static bool PathIsAbsolute(const char *s)\newline{\newline    bool result = false;\newline\newline#if defined(__MINGW32__)\newline    if (isalpha(s[0]) &amp&amp (s[1] == &#039:&#039) &amp&amp (s[2] == FILE_SEPARATOR))\newline    {\newline        result = true;                                          /* A:\\ */\newline    }\newline    else                                                        /* \\\\ */\newline    {\newline        result = (s[0] == FILE_SEPARATOR &amp&amp s[1] == FILE_SEPARATOR);\newline    }\newline#else\newline    if (s[0] == FILE_SEPARATOR)                                 /* / */\newline    {\newline        result = true;\newline    }\newline#endif\newline\newline    return result;\newline}\newline,We use this instead of IsAbsoluteFileName() which also checks for\newline quotes. There is no meaning in receiving quoted strings over the\newline network. \newline,,,,,,,,,,,on,,on,on,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,Process a reply from the FTP server.,format string as a csv field,returns number of descriptors passed from systemd,Returns a dict with attribute names and values,recompress the remaining stored deflate data in place,The caller needs to free the returned string.,This function searches file,Handle the firing timer,Load an image from the named file.,Retrieves the sandbox connection,{},Atomically set the LINK field iff it is still LINKED.,{},{},Close a tokenization cursor previously,"Creates a ""aaakkkk"" CSound description string.","This function returns the first token string found in the
expression string.",Calculate stripe width of md device using its sysfs files.,This function initiates the 'mem_tsd'.,{},disables passive service checks for a particular service,x,
3W1K7D6QSBH5BYDMQ808GFQQI90BZ0,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:49 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:49 PDT 2019,,,3Q5C1WP23M18E68Y7P54AI2BDUA51Z,AITP2LUW8GPB,Submitted,Fri Apr 26 14:14:01 PDT 2019,Fri Apr 26 14:19:02 PDT 2019,Sun Apr 28 14:19:02 PDT 2019,,,,301,100% (62/62),100% (62/62),0% (0/0),1321309,ppc_fpu.c,"void ppc_opc_faddx()\newline{\newline	int frD, frA, frB, frC;\newline	PPC_OPC_TEMPL_A(gCPU.current_opc, frD, frA, frB, frC);\newline	PPC_OPC_ASSERT(frC==0);\newline	ppc_double A, B, D;\newline	ppc_fpu_unpack_double(&ampA, gCPU.fpr[frA]);\newline	ppc_fpu_unpack_double(&ampB, gCPU.fpr[frB]);\newline	if (A.s != B.s &amp&amp A.type == ppc_fpr_Inf &amp&amp B.type == ppc_fpr_Inf) {\newline		gCPU.fpscr |= FPSCR_VXISI;\newline	}\newline	ppc_fpu_add(&ampD, &ampA, &ampB);\newline	gCPU.fpscr |= ppc_fpu_pack_double(&ampD, &amp(gCPU.fpr[frD]));\newline	if (gCPU.current_opc &amp PPC_OPC_Rc) {\newline		// update cr1 flags\newline		PPC_FPU_ERR(&quotfadd.\\n&quot);\newline	}\newline}\newline",\newline faddx Floating Add (Double-Precision)\newline .485\newline \newline,1429984,away.c,"short authenticate(char *username) {\newline  short error;\newline  pam_handle_t *pamh = NULL;\newline\newline  /* start PAM session for &#039away&#039.          *\newline   * the session name is what PAM looks for *\newline   * in /etc/pam.d/ or /etc/pam.config      */\newline  error = pam_start(&quotaway&quot, username, &ampconv, &amppamh);\newline\newline  /* authenticate user */\newline  if (!error) error = pam_authenticate(pamh, 0);\newline\newline  /* close PAM session */\newline  if (pam_end(pamh,error) != PAM_SUCCESS) {\newline    pamh = NULL;\newline    fprintf(stderr,&quotaway: ** failed to release PAM authenticator\\n&quot);\newline    error = 1;\newline  }\newline  return error;\newline}\newline",Authenticate Password \newline,4047286,generate.c,"static void puturl(char *s, int size, MMIOT *f, int display)\newline{\newline	unsigned char c;\newline\newline	while (size-- &gt 0) {\newline		c = *s++;\newline\newline		if (c == &#039\\\\&#039 &amp&amp size-- &gt 0) {\newline			c = *s++;\newline\newline			if (!(ispunct(c) || isspace(c)))\newline				Qchar(&#039\\\\&#039, f);\newline		}\newline\newline		if (c == &#039&amp&#039)\newline			Qstring(&quot&ampamp;&quot, f);\newline		else if (c == &#039&lt&#039)\newline			Qstring(&quot&amplt;&quot, f);\newline		else if (c == &#039&quot&#039)\newline			Qstring(&quot%22&quot, f);\newline		else if (isalnum(c) || ispunct(c) || (display &amp&amp isspace(c)))\newline			Qchar(c, f);\newline		else if (c == 003) /* untokenize ^C */\newline			Qstring(&quot  &quot, f);\newline		else\newline			Qprintf(f, &quot%%%02X&quot, c);\newline	}\newline}\newline","\newline write out a url, escaping problematic characters\newline \newline",4236719,ftnq.c,"void q_get_sizes (FTNQ *q, uintmax_t *netsize, uintmax_t *filessize)\newline{\newline  FTNQ *curr;\newline  struct stat st;\newline  char *p;\newline\newline  *netsize = *filessize = 0;\newline  for (curr = q; curr; curr = curr-&gtnext)\newline  {\newline    if (curr-&gttype == &#039l&#039)\newline    { FILE *f;\newline      char str[MAXPATHLEN+2];\newline\newline      if (curr-&gtsize)\newline        *filessize += curr-&gtsize;\newline      else if ((f = fopen(curr-&gtpath, &quotr&quot)) != NULL)\newline      {\newline        curr-&gtsize = curr-&gttime = 0;\newline        while (fgets (str, sizeof(str), f))\newline        {\newline          if (*str == &#039~&#039 || *str == &#039$&#039) continue;\newline          if ((p = strchr(str, &#039\\n&#039)) != NULL) *p=&#039\\0&#039;\newline          p=str;\newline          if (*str == &#039#&#039 || *str == &#039^&#039) p++;\newline          if (stat(p, &ampst) == 0) {\newline            *filessize += st.st_size;\newline            curr-&gtsize += st.st_size;\newline            if (st.st_mtime &gt curr-&gttime) curr-&gttime = st.st_mtime;\newline          }\newline        }\newline        fclose(f);\newline      }\newline    }\newline    else if (curr-&gttype == &#039s&#039)\newline      *filessize += curr-&gtsize;\newline    else\newline    {\newline      if (curr-&gtsize == 0)\newline      {\newline        if (stat(curr-&gtpath, &ampst) == 0) {\newline          curr-&gtsize = st.st_size;\newline          curr-&gttime = st.st_mtime;\newline        }\newline      }\newline      *(curr-&gttype == &#039m&#039 ? netsize : filessize) += curr-&gtsize;\newline    }\newline  }\newline}\newline",\newline get size of files in the queue\newline \newline,4943751,partitions.c,blkid_parttable blkid_partition_get_table(blkid_partition par)\newline{\newline	return par-&gttab;\newline}\newline,"\newline blkid_partition_get_table:\newline @par: partition\newline \newline The &quotparttable&quot describes partition table. The table is usually the same for\newline all partitions -- except nested partition tables.\newline \newline For example bsd, solaris, etc. use a nested partition table within\newline standard primary dos partition:\newline \newline &ltinformalexample&gt\newline &ltprogramlisting&gt\newline \newline -- dos partition table\newline 0: sda1 dos primary partition\newline 1: sda2 dos primary partition\newline -- bsd partition table (with in sda2)\newline 2: sda5 bds partition\newline 3: sda6 bds partition\newline \newline &lt/programlisting&gt\newline &lt/informalexample&gt\newline \newline The library does not to use a separate partition table object for dos logical\newline partitions (partitions within extended partition). It&#039s possible to\newline differentiate between logical, extended and primary partitions by\newline \newline blkid_partition_is_{extended,primary,logical}().\newline \newline Returns: partition table object or NULL in case of error.\newline \newline",5212374,host.cpp,int sg_host_get_nb_pstates(sg_host_t host) {\newline  return host-&gtpstatesCount();\newline}\newline,@brief Returns the number of power states for a host.\newline \newline See also @ref SURF_plugin_energy.\newline \newline,3101127,gdth.c,int gdth_eh_abort(Scsi_Cmnd *scp)\newline{\newline    TRACE2((&quotgdth_eh_abort()\\n&quot));\newline    return FAILED;\newline}\newline,new error handling \newline,2469818,audio.c,"static int OssOpenPCM(int passthrough)\newline{\newline    const char *device;\newline    int fildes;\newline\newline    // &amp&amp|| hell\newline    if (!(passthrough &amp&amp ((device = AudioPassthroughDevice)\newline		|| (device = getenv(&quotOSS_PASSTHROUGHDEV&quot))))\newline	&amp&amp !(device = AudioPCMDevice) &amp&amp !(device = getenv(&quotOSS_AUDIODEV&quot))) {\newline	device = &quot/dev/dsp&quot;\newline    }\newline    if (!AudioDoingInit) {\newline	Info(_(&quotaudio/oss: using %sdevice &#039%s&#039\\n&quot),\newline	    passthrough ? &quotpass-through &quot : &quot&quot, device);\newline    }\newline\newline    if ((fildes = open(device, O_WRONLY)) &lt 0) {\newline	Error(_(&quotaudio/oss: can&#039t open dsp device &#039%s&#039: %s\\n&quot), device,\newline	    strerror(errno));\newline	return -1;\newline    }\newline    return fildes;\newline}\newline","\newline Open OSS pcm device.\newline \newline @param passthrough use pass-through (AC-3, ...) device\newline \newline",2265251,util_constraints_list.c,"Constraint_list * filter_constraint_list (Constraint_list *CL,int field, int T)\newline{\newline	int s1,r1,b,c,d;\newline	Sequence *S;\newline\newline	if (!CL || !CL-&gtresidue_index || !CL-&gtS)return CL;\newline	S=CL-&gtS;\newline	CL-&gtne=0;\newline	for (s1=0; s1&ltS-&gtnseq; s1++)\newline	{\newline		for ( r1=1; r1&lt=S-&gtlen[s1]; r1++)\newline		{\newline			int *r=CL-&gtresidue_index[s1][r1];\newline			for (d=1,b=1; b&ltr[0]; b+=ICHUNK)\newline			{\newline				if (r[b+field]&gtT)\newline				{\newline					if (d!=b)for (c=0; c&ltICHUNK; c++){r[d+c]=r[b+c];}\newline					d+=ICHUNK;\newline					CL-&gtne++;\newline				}\newline			}\newline			r[0]=d;\newline			CL-&gtresidue_index[s1][r1]=(int*)vrealloc (r, d*sizeof(int));;\newline		}\newline	}\newline\newline	return CL;\newline}\newline","\newline Deletes unimportant edges from the Constraint_list.\newline \newline This function reduces the size of th eConstraint_list, which is useful to speed\newline up calculations such as the extension step, by kicking out all constraints/edges\newline with a weight smaller or equal to a given threshold.\newline Currently there is a hardcoded value of 10 in ::fork_relax_constraint_list, but it\newline can also be invokled before the relaxation by setting the \\c -filter_lib parameter.\newline \newline \\param[in,out] CL The global Constraint_list object.\newline \\param[in] field Internal, constant number to access the CHUNKS of Constraint_list::residue_index correctly.\newline \\param[in] T threshold: Edges with weight smaller or equal to T will be removed.\newline \newline",6018659,fillplugins.h,"static void add_vp3(avm::vector&ltCodecInfo&gt&amp ci)\newline{\newline    /* The On2 copyright message taken from the Windows project\newline       resource file */\newline    const char* vp3_about =\newline	&quot&lta href=\\&quothttp://www.vp3.com/\\&quot&gtVP3 Codec&lt/a&gt &quot\newline	&quot- Version 3.2.1.0&ltbr&gtCopyright (c) 2001 On2 Technologies. &quot\newline	&quotAll Rights Reserved. &quot\newline	&quot&lta href=\\&quothttp://www.on2.com/\\&quot&gt&quot\newline	&quothttp://www.on2.com&lt/a&gt&quot;\newline    const GUID CLSID_on2 =\newline    {\newline	0x4cb63e61, 0xc611, 0x11d0,\newline	{ 0x83, 0xaa, 0x00, 0x00, 0x92, 0x90, 0x01, 0x84 }\newline    };\newline    const fourcc_t apxx_codecs[] = {\newline	fccVP31, fccvp31, fccVP30, fccVP30,\newline	mmioFOURCC(&#039V&#039, &#039P&#039, &#0394&#039, &#0390&#039), mmioFOURCC(&#039T&#039, &#039M&#039, &#0392&#039, &#039X&#039), 0\newline    };\newline\newline    avm::vector&ltAttributeInfo&gt vs_empty;\newline    avm::vector&ltAttributeInfo&gt ds;\newline    ds.push_back(AttributeInfo(&quotstrPostProcessingLevel&quot, &quotPostprocessing&quot,\newline			       AttributeInfo::Integer, 0, 8));\newline    /* vp3 codec contains a bug in ICDECOMPRESSEX initializer\newline    ( Codecs/vp31vfw/Win32/vp31vfw.h ) that breaks decoding upside-down\newline    images in &#039normal&#039 mode ( ICDECOMPRESS ) */\newline#if 1\newline    /* crashing somewhere after IsRect == TRUE */\newline    ci.push_back(CodecInfo(apxx_codecs, &quotW32 VP31(r) DirectShow&quot, &quoton2.ax&quot,\newline			   vp3_about, CodecInfo::DShow_Dec, &quotvp3ds&quot,\newline			   CodecInfo::Video, CodecInfo::Decode,\newline			   &ampCLSID_on2));\newline#endif\newline    ci.push_back(CodecInfo(apxx_codecs, &quotW32 VP31(r) Codec&quot, &quotvp31vfw.dll&quot,\newline			   vp3_about, CodecInfo::Win32Ex, &quotvp3&quot,\newline			   CodecInfo::Video, CodecInfo::Both, 0, vs_empty, ds));\newline}\newline",On2 Truemotion VP3.x support \newline,4514294,smsc_cimd2.c,"static void packet_add_address_parm(struct packet *packet, int parmno, Octstr *value, SMSCConn *conn)\newline{\newline    gw_assert(octstr_check_range(value, 0, octstr_len(value), isphonedigit));\newline    packet_add_parm(packet, P_ADDRESS, parmno, value, conn);\newline}\newline",Add an Address parameter to the packet \newline,2691147,common.c,"static int sh_skip_sync(struct vcpu *v, mfn_t gl1mfn)\newline{\newline    struct page_info *pg = mfn_to_page(gl1mfn);\newline    if ( pg-&gtshadow_flags &amp SHF_L1_32 )\newline        return SHADOW_INTERNAL_NAME(sh_safe_not_to_sync, 2)(v, gl1mfn);\newline    else if ( pg-&gtshadow_flags &amp SHF_L1_PAE )\newline        return SHADOW_INTERNAL_NAME(sh_safe_not_to_sync, 3)(v, gl1mfn);\newline    else if ( pg-&gtshadow_flags &amp SHF_L1_64 )\newline        return SHADOW_INTERNAL_NAME(sh_safe_not_to_sync, 4)(v, gl1mfn);\newline    SHADOW_ERROR(&quotgmfn %#lx was OOS but not shadowed as an l1.\\n&quot,\newline                 mfn_x(gl1mfn));\newline    BUG();\newline}\newline","Figure out whether it&#039s definitely safe not to sync this l1 table,\newline by making a call out to the mode in which that shadow was made. \newline",1892219,light.c,"gboolean visu_gl_lights_apply(VisuGlLights *env)\newline{\newline  gint nb;\newline  float lmodel_ambient[4] = {0.2f, 0.2f, 0.2f, 1.0f};\newline\newline  g_return_val_if_fail(env, FALSE);\newline\newline  if (env-&gtnbEnabledVisuGlLights == 0 &amp&amp !env-&gtlist)\newline    return FALSE;\newline\newline  /* glPushMatrix(); */\newline  /* glLoadIdentity(); */\newline\newline  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);\newline  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);\newline  glEnable(GL_LIGHTING);\newline\newline  for (nb = 0; nb &lt env-&gtnbEnabledVisuGlLights; nb++)\newline    glDisable(GL_LIGHT0 + nb);\newline    \newline  g_list_foreach(env-&gtlist, lighting_set, (gpointer)env);\newline\newline  env-&gtnbEnabledVisuGlLights = env-&gtnbStoredVisuGlLights;\newline   \newline  /* glPopMatrix(); */\newline\newline  return TRUE;\newline}\newline",\newline visu_gl_lights_apply:\newline @env: a #VisuGlLights object.\newline \newline Apply all stored informations about lights to the current OpenGL context.\newline \newline Returns: TRUE if the &quotOpenGLAskForReDraw&quot signal should be\newline emitted after a call to this method.\newline \newline,6430099,replace.c,"static int replace_chars (int n, char *neew) /*{{{*/\newline{\newline   int len;\newline#if USE_PRESERVE_CASE\newline   int preserve_case;\newline   char *old = NULL;\newline   int i;\newline#endif\newline   \newline   CHECK_READ_ONLY\newline   if (n &lt 0) return 0;\newline   len = strlen (neew);\newline#if USE_PRESERVE_CASE\newline   preserve_case = (Replace_Preserve_Case &amp&amp (len == n));\newline#endif\newline   jed_push_mark ();\newline#if USE_PRESERVE_CASE\newline   if (preserve_case) jed_push_mark ();\newline#endif\newline   n = jed_right (n);\newline#if USE_PRESERVE_CASE\newline   if (preserve_case)\newline     {\newline	if (n == len)\newline	  {\newline	     if (NULL == (old = make_buffer_substring(&ampn))) return 0;\newline	  }\newline	else \newline	  {\newline	     preserve_case = 0;\newline	     jed_pop_mark (&ampNumber_Zero);\newline	  }\newline     }\newline#endif\newline\newline   delete_region ();\newline#if USE_PRESERVE_CASE   \newline   if (preserve_case)\newline     {\newline	unsigned char ch;\newline	\newline	for (i = 0; i &lt len; i++)\newline	  {\newline	     ch = (unsigned char) old[i];\newline	     if (ch == UPPER_CASE(ch))\newline	       {\newline		  if (ch == LOWER_CASE(ch))\newline		    old[i] = neew[i];\newline		  else\newline		    old[i] = UPPER_CASE(neew[i]);\newline	       }\newline	     else old[i] = LOWER_CASE(neew[i]);\newline	  }\newline	neew = old;\newline     }\newline#endif\newline   (void) jed_insert_nbytes ((unsigned char *) neew, len);\newline#if USE_PRESERVE_CASE\newline   if (preserve_case) SLfree (old);\newline#endif\newline   return len;\newline}\newline\newline/*}}}*/\newline",returns the length of the region inserted. \newline,4964519,ring_buffer_frontend.c,"void lib_ring_buffer_switch_slow(struct lttng_ust_lib_ring_buffer *buf, enum switch_mode mode,\newline				 struct lttng_ust_shm_handle *handle)\newline{\newline	struct channel *chan;\newline	const struct lttng_ust_lib_ring_buffer_config *config;\newline	struct switch_offsets offsets;\newline	unsigned long oldidx;\newline	uint64_t tsc;\newline\newline	chan = shmp(handle, buf-&gtbackend.chan);\newline	if (!chan)\newline		return;\newline	config = &ampchan-&gtbackend.config;\newline\newline	offsets.size = 0;\newline\newline	/*\newline	 * Perform retryable operations.\newline	 */\newline	do {\newline		if (lib_ring_buffer_try_switch_slow(mode, buf, chan, &ampoffsets,\newline						    &amptsc, handle))\newline			return;	/* Switch not needed */\newline	} while (v_cmpxchg(config, &ampbuf-&gtoffset, offsets.old, offsets.end)\newline		 != offsets.old);\newline\newline	/*\newline	 * Atomically update last_tsc. This update races against concurrent\newline	 * atomic updates, but the race will always cause supplementary full TSC\newline	 * records, never the opposite (missing a full TSC record when it would\newline	 * be needed).\newline	 */\newline	save_last_tsc(config, buf, tsc);\newline\newline	/*\newline	 * Push the reader if necessary\newline	 */\newline	lib_ring_buffer_reserve_push_reader(buf, chan, offsets.old);\newline\newline	oldidx = subbuf_index(offsets.old, chan);\newline	lib_ring_buffer_clear_noref(config, &ampbuf-&gtbackend, oldidx, handle);\newline\newline	/*\newline	 * May need to populate header start on SWITCH_FLUSH.\newline	 */\newline	if (offsets.switch_old_start) {\newline		lib_ring_buffer_switch_old_start(buf, chan, &ampoffsets, tsc, handle);\newline		offsets.old += config-&gtcb.subbuffer_header_size();\newline	}\newline\newline	/*\newline	 * Switch old subbuffer.\newline	 */\newline	lib_ring_buffer_switch_old_end(buf, chan, &ampoffsets, tsc, handle);\newline}\newline","\newline Force a sub-buffer switch. This operation is completely reentrant : can be\newline called while tracing is active with absolutely no lock held.\newline \newline Note, however, that as a v_cmpxchg is used for some atomic\newline operations, this function must be called from the CPU which owns the buffer\newline for a ACTIVE flush.\newline \newline",710577,theft.c,"void theft_set_output_stream(struct theft *t, FILE *out) { t-&gtout = out; }\newline",Change T&#039s output stream handle to OUT. (Default: stdout.) \newline,4705103,util.cpp,"int create_socket(const char *name, int type, mode_t perm, uid_t uid,\newline                  gid_t gid, const char *socketcon)\newline{\newline    struct sockaddr_un addr;\newline    int fd, ret, savederrno;\newline    char *filecon;\newline\newline    if (socketcon) {\newline        if (setsockcreatecon(socketcon) == -1) {\newline            ERROR(&quotsetsockcreatecon(\\&quot%s\\&quot) failed: %s\\n&quot, socketcon, strerror(errno));\newline            return -1;\newline        }\newline    }\newline\newline    fd = socket(PF_UNIX, type, 0);\newline    if (fd &lt 0) {\newline        ERROR(&quotFailed to open socket &#039%s&#039: %s\\n&quot, name, strerror(errno));\newline        return -1;\newline    }\newline\newline    if (socketcon)\newline        setsockcreatecon(NULL);\newline\newline    memset(&ampaddr, 0 , sizeof(addr));\newline    addr.sun_family = AF_UNIX;\newline    snprintf(addr.sun_path, sizeof(addr.sun_path), ANDROID_SOCKET_DIR&quot/%s&quot,\newline             name);\newline\newline    ret = unlink(addr.sun_path);\newline    if (ret != 0 &amp&amp errno != ENOENT) {\newline        ERROR(&quotFailed to unlink old socket &#039%s&#039: %s\\n&quot, name, strerror(errno));\newline        goto out_close;\newline    }\newline\newline    filecon = NULL;\newline    if (sehandle) {\newline        ret = selabel_lookup(sehandle, &ampfilecon, addr.sun_path, S_IFSOCK);\newline        if (ret == 0)\newline            setfscreatecon(filecon);\newline    }\newline\newline    ret = bind(fd, (struct sockaddr *) &ampaddr, sizeof (addr));\newline    savederrno = errno;\newline\newline    setfscreatecon(NULL);\newline    freecon(filecon);\newline\newline    if (ret) {\newline        ERROR(&quotFailed to bind socket &#039%s&#039: %s\\n&quot, name, strerror(savederrno));\newline        goto out_unlink;\newline    }\newline\newline    ret = lchown(addr.sun_path, uid, gid);\newline    if (ret) {\newline        ERROR(&quotFailed to lchown socket &#039%s&#039: %s\\n&quot, addr.sun_path, strerror(errno));\newline        goto out_unlink;\newline    }\newline    ret = fchmodat(AT_FDCWD, addr.sun_path, perm, AT_SYMLINK_NOFOLLOW);\newline    if (ret) {\newline        ERROR(&quotFailed to fchmodat socket &#039%s&#039: %s\\n&quot, addr.sun_path, strerror(errno));\newline        goto out_unlink;\newline    }\newline\newline    INFO(&quotCreated socket &#039%s&#039 with mode &#039%o&#039, user &#039%d&#039, group &#039%d&#039\\n&quot,\newline         addr.sun_path, perm, uid, gid);\newline\newline    return fd;\newline\newlineout_unlink:\newline    unlink(addr.sun_path);\newlineout_close:\newline    close(fd);\newline    return -1;\newline}\newline",\newline create_socket - creates a Unix domain socket in ANDROID_SOCKET_DIR\newline (&quot/dev/socket&quot) as dictated in init.rc. This socket is inherited by the\newline daemon. We communicate the file descriptor&#039s value via the environment\newline variable ANDROID_SOCKET_ENV_PREFIX&ltname&gt (&quotANDROID_SOCKET_foo&quot).\newline \newline,1563099,aaip_0_2.c,"ssize_t aaip_encode(size_t num_attrs, char **names,\newline                    size_t *value_lengths, char **values, \newline                    size_t *result_len, unsigned char **result, int flag)\newline{\newline size_t mem_size= 0, comp_size;\newline ssize_t ret;\newline unsigned int number_of_fields, i, num_recs;\newline\newline /* Predict memory needs, number of SUSP fields and component records */\newline *result = NULL;\newline *result_len= 0;\newline for(i= 0; i &lt num_attrs; i++) {\newline   ret= aaip_encode_pair(names[i], value_lengths[i], values[i],\newline                         &ampnum_recs, &ampcomp_size, NULL, (size_t) 0, 1);\newline   if(ret &lt 0)\newline     return(ret);\newline   mem_size+= comp_size;\newline }\newline number_of_fields= mem_size / 250 + !!(mem_size % 250);\newline if(number_of_fields == 0)\newline   return(0);\newline mem_size+= number_of_fields * 5;\newline\newline#ifdef Aaip_encode_debuG\newline *result= (unsigned char *) calloc(1, mem_size + 1024000);\newline                                          /* generous honeypot for overflows */\newline#else\newline *result= (unsigned char *) calloc(1, mem_size);\newline#endif\newline\newline if(*result == NULL)\newline   return ISO_OUT_OF_MEM;\newline\newline /* Encode pairs into result */\newline for(i= 0; i &lt num_attrs; i++) {\newline   ret= aaip_encode_pair(names[i], value_lengths[i], values[i],\newline                         &ampnum_recs, &ampcomp_size, *result, *result_len, 0);\newline   if(ret &lt 0) {\newline     free(*result);\newline     *result = NULL;\newline     *result_len = 0;\newline     return(ret);\newline   }\newline   (*result_len)+= comp_size;\newline }\newline\newline /* write the field headers */\newline for(i= 0; i &lt number_of_fields; i++) {\newline   (*result)[i * 255 + 0]= &#039A&#039;\newline   (*result)[i * 255 + 1]= &#039L&#039;\newline   if(i &lt number_of_fields - 1 || (mem_size % 255) == 0)\newline     (*result)[i * 255 + 2]= 255;\newline   else \newline     (*result)[i * 255 + 2]= mem_size % 255;\newline   (*result)[i * 255 + 3]= 1;\newline   (*result)[i * 255 + 4]= (flag &amp 1) || (i &lt number_of_fields - 1);\newline }\newline (*result_len)+= number_of_fields * 5;\newline\newline#ifdef Aaip_encode_debuG\newline if(*result_len != mem_size) {\newline   fprintf(stderr, &quotaaip_encode(): MEMORY MISMATCH BY %d BYTES\\n&quot,\newline           (int) (mem_size - *result_len));\newline } else {\newline   unsigned char *hpt;\newline   hpt= malloc(*result_len);\newline   if(hpt != NULL) {\newline     memcpy(hpt, *result, *result_len);\newline     free(*result);\newline     *result= hpt;\newline   }\newline }\newline ret= 0;\newline for(i= 0; i &lt *result_len; i+= ((unsigned char *) (*result))[i + 2])\newline   ret++;\newline if(ret != (int) number_of_fields) {\newline   fprintf(stderr, &quotaaip_encode(): WRONG NUMBER OF FIELDS %d &lt&gt %d\\n&quot,\newline           (int) number_of_fields, ret);\newline }\newline#endif /* Aaip_encode_debuG */\newline\newline return(number_of_fields);\newline}\newline","Convert an array of Arbitrary Attributes into a series of AAIP fields.\newline@param num_attrs Number of attributes\newline@param names Array of pointers to 0 terminated name strings\newline@param value_lengths Array of byte lengths for each value\newline@param values Array of pointers to the value bytes\newline@param result_len Number of bytes in the resulting SUSP field string\newline@param result result will point to the start of the result string.\newlineThis is malloc() memory which needs to be freed when\newlineno longer needed \newline@param flag Bitfield for control purposes\newlinebit0= set CONTINUE bit of last AAIP field to 1\newline@return &gt= 0 is the number of SUSP fields generated,\newline&lt 0 means error \newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2961343,mhfixmsg.c,"static int\newlineremove_file (char *file) {\newline    if (rmmproc) {\newline        char *rmm_command = concat (rmmproc, &quot &quot, file, NULL);\newline        int status = system (rmm_command);\newline\newline        free (rmm_command);\newline        return WIFEXITED (status)  ?  WEXITSTATUS (status)  :  NOTOK;\newline    } else {\newline        /* This is OK for a non-message file, it still uses the\newline           BACKUP_PREFIX form.  The backup file will be in the same\newline           directory as file. */\newline        return rename (file, m_backup (file));\newline    }\newline}\newline","\newline If &quotrmmproc&quot is defined, call that to remove the file. Otherwise,\newline use the standard MH backup file.\newline \newline",5831219,botcmd.c,"static void bot_part(int idx, char *par)\newline{\newline  char *bot, *nick, *etc;\newline  struct userrec *u;\newline  int sock, partyidx;\newline  int silent = 0;\newline\newline  if (bot_flags(dcc[idx].user) &amp BOT_ISOLATE)\newline    return;\newline  bot = newsplit(&amppar);\newline  if (bot[0] == &#039!&#039) {\newline    silent = 1;\newline    bot++;\newline  }\newline  nick = newsplit(&amppar);\newline  etc = newsplit(&amppar);\newline#ifndef NO_OLD_BOTNET\newline  if (b_numver(idx) &lt NEAT_BOTNET) {\newline    sock = atoi(etc);\newline    silent = 1;\newline  } else\newline#endif\newline    sock = base64_to_int(etc);\newline  if (sock == 0)\newline    sock = partysock(bot, nick);\newline  u = get_user_by_handle(userlist, nick);\newline  if (u) {\newline    sprintf(TBUF, &quot@%s&quot, bot);\newline    touch_laston(u, TBUF, now);\newline  }\newline  if ((partyidx = getparty(bot, sock)) != -1) {\newline    if (party[partyidx].chan &gt= 0)\newline      check_tcl_chpt(bot, nick, sock, party[partyidx].chan);\newline    if ((b_numver(idx) &gt= NEAT_BOTNET) &amp&amp !silent) {\newline      register int chan = party[partyidx].chan;\newline\newline      if (par[0])\newline        chanout_but(-1, chan, &quot*** (%s) %s %s %s (%s).\\n&quot, bot, nick,\newline                    NET_LEFTTHE, chan ? &quotchannel&quot : &quotparty line&quot, par);\newline      else\newline        chanout_but(-1, chan, &quot*** (%s) %s %s %s.\\n&quot, bot, nick,\newline                    NET_LEFTTHE, chan ? &quotchannel&quot : &quotparty line&quot);\newline    }\newline    botnet_send_part_party(idx, partyidx, par, silent);\newline    remparty(bot, sock);\newline  }\newline}\newline",part &ltbot&gt &ltnick&gt &ltsock&gt [etc..]\newline \newline,,on,,,,,,,,,,,,on,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,Floating Add,{},Add an Address parameter to the packet,"Figure out whether it's definitely safe not to sync this l1 table,",Apply all stored informations,returns the length of the region inserted.,This operation is completely reentrant,Change T's output stream handle to OUT.,creates a Unix domain socket in ANDROID_SOCKET_DIR,Convert an array of Arbitrary Attributes into a series of AAIP fields.,Load an image from the named file.,Authenticate Password,call that to remove the file.,{},"write out a url, escaping problematic characters",get size of files in the queue,{},Returns the number of power states for a host.,new error handling,Open OSS pcm device.,"This function reduces the size of th eConstraint_list,",x,
3J6BHNX0U9SCNC3XTX27KV27VP0NKE,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:22 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:22 PDT 2019,,,39O5D9O87TSPNUVS936VCHNI3UIC3C,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:30 PDT 2019,Fri Apr 26 12:50:24 PDT 2019,Sun Apr 28 12:50:24 PDT 2019,,,,174,100% (62/62),100% (62/62),0% (0/0),3101056,qlogicfas.c,int	qlogicfas_abort(Scsi_Cmnd * cmd)\newline{\newline	qabort = 1;\newline	ql_zap();\newline	return 0;\newline}\newline,abort command in progress \newline,284580,cache.c,"int nl_cache_move(struct nl_cache *cache, struct nl_object *obj)\newline{\newline	if (cache-&gtc_ops-&gtco_obj_ops != obj-&gtce_ops)\newline		return -NLE_OBJ_MISMATCH;\newline\newline	NL_DBG(3, &quotMoving object %p from cache %p to cache %p\\n&quot,\newline	       obj, obj-&gtce_cache, cache);\newline	\newline	/* Acquire reference, if already in a cache this will be\newline	 * reverted during removal */\newline	nl_object_get(obj);\newline\newline	if (!nl_list_empty(&ampobj-&gtce_list))\newline		nl_cache_remove(obj);\newline\newline	return __cache_add(cache, obj);\newline}\newline","\newline Move object from one cache to another\newline @arg cache Cache to move object to.\newline @arg obj Object subject to be moved\newline \newline Removes the the specified object \\p obj from its associated cache\newline and moves it to another cache.\newline \newline If the object is not associated with a cache, the function behaves\newline just like nl_cache_add().\newline \newline The type of the object and cache must match, otherwise an error is\newline returned (-NLE_OBJ_MISMATCH).\newline \newline @see nl_cache_add()\newline \newline @return 0 on success or a negative error code.\newline \newline",2162645,mboxname.c,"static int mboxname_tointernal(struct namespace *namespace, const char *name,\newline			       const char *userid, char *result)\newline{\newline    char *cp;\newline    char *atp;\newline    char *mbresult;\newline    int userlen, domainlen = 0, namelen;\newline\newline    /* Blank the result, just in case */\newline    result[0] = &#039\\0&#039;\newline    result[MAX_MAILBOX_BUFFER-1] = &#039\\0&#039;\newline\newline    userlen = userid ? strlen(userid) : 0;\newline    namelen = strlen(name);\newline\newline    if (config_virtdomains) {\newline	if (userid &amp&amp (cp = strrchr(userid, &#039@&#039))) {\newline	    /* user logged in as user@domain */\newline	    userlen = cp - userid;\newline	    /* don&#039t prepend default domain */\newline	    if (!(config_defdomain &amp&amp !strcasecmp(config_defdomain, cp+1))) {\newline		domainlen = strlen(cp+1)+1;\newline		snprintf(result, MAX_MAILBOX_BUFFER, &quot%s!&quot, cp+1);\newline	    }\newline	}\newline	if ((cp = strrchr(name, &#039@&#039))) {\newline	    /* mailbox specified as mbox@domain */\newline	    namelen = cp - name;\newline\newline	    if (config_defdomain &amp&amp !strcasecmp(config_defdomain, cp+1)) {\newline		if (domainlen) {\newline		    /* don&#039t allow cross-domain access */\newline		    return IMAP_MAILBOX_BADNAME;\newline		}\newline		/* don&#039t prepend default domain */\newline	    }\newline	    else {\newline		if ((!domainlen &amp&amp !namespace-&gtisadmin) ||\newline		    (domainlen &amp&amp strcasecmp(userid+userlen, cp))) {\newline		    /* don&#039t allow cross-domain access\newline		       (except for global admin) */\newline		    return IMAP_MAILBOX_BADNAME;\newline		}\newline		domainlen = strlen(cp+1)+1;\newline		snprintf(result, MAX_MAILBOX_BUFFER, &quot%s!&quot, cp+1);\newline	    }\newline\newline	    atp = strchr(name, &#039@&#039);\newline	    if (atp &amp&amp atp != cp) {\newline		/* don&#039t allow multiple &#039@&#039 in name */\newline		return IMAP_MAILBOX_BADNAME;\newline	    }\newline	}\newline\newline	/* if no domain specified, we&#039re in the default domain */\newline    }\newline\newline    mbresult = result + domainlen;\newline\newline    /* Personal (INBOX) namespace */\newline    if ((name[0] == &#039i&#039 || name[0] == &#039I&#039) &amp&amp\newline	!strncasecmp(name, &quotinbox&quot, 5) &amp&amp\newline	(namelen == 5 || name[5] == namespace-&gthier_sep)) {\newline\newline	if (!userid || ((cp = strchr(userid, namespace-&gthier_sep)) &amp&amp\newline			(cp - userid &lt userlen))) {\newline	    return IMAP_MAILBOX_BADNAME;\newline	}\newline\newline	snprintf(mbresult, MAX_MAILBOX_BUFFER - domainlen,\newline		 &quotuser.%.*s%.*s&quot, userlen, userid, namelen-5, name+5);\newline\newline	/* Translate any separators in userid+mailbox */\newline	mboxname_hiersep_tointernal(namespace, mbresult+5+userlen, 0);\newline    }\newline\newline    else {\newline	/* Other Users &amp Shared namespace */\newline	snprintf(mbresult, MAX_MAILBOX_BUFFER - domainlen,\newline		 &quot%.*s&quot, namelen, name);\newline\newline	/* Translate any separators in mailboxname */\newline	mboxname_hiersep_tointernal(namespace, mbresult, 0);\newline    }\newline\newline    if (result[MAX_MAILBOX_BUFFER-1] != &#039\\0&#039) {\newline	syslog(LOG_ERR, &quotIOERROR: long mailbox name attempt: %s&quot, name);\newline	return IMAP_MAILBOX_BADNAME;\newline    }\newline    return 0;\newline}\newline",Handle conversion from the standard namespace to the internal namespace \newline,4499737,sh_tools.c,"char * sh_tools_makePack (unsigned char * header, int flag,\newline			  char * payload, unsigned long payload_size,\newline			  keyInstance * keyInstE)\newline{\newline  BYTE            inBlock[B_SIZ]; \newline  BYTE            outBlock[B_SIZ];\newline  char            ivBlock[B_SIZ];\newline\newline  UINT32          rpad[3];\newline  unsigned char   head[16];\newline  double          epad;\newline  unsigned long   i_epad = 0;\newline  unsigned long   i_blk = payload_size / 16;\newline  unsigned long   i_blkmax = SH_V2_FULLSIZE / 16;\newline  unsigned long   pads = 0;\newline  size_t          full_size;\newline  char          * full_ret;\newline\newline  unsigned char * p;\newline  int             j;\newline  cipherInstance  cipherInst;\newline  int             err_num;\newline  int             blkfac;\newline  int             oflow = 0;\newline  char expbuf[SH_ERRBUF_SIZE];\newline\newline  /* \newline     SL_REQUIRE (i_blk*16 == payload_size, _(&quotpayload_size % 16 != 0&quot));\newline  */\newline  if ((i_blk * 16) != payload_size) ++i_blk;\newline\newline  /* random_pad\newline   */\newline  rpad[1] = taus_get ();\newline  memcpy (head,      &amprpad[1],    4);\newline  rpad[0] = taus_get ();\newline  memcpy (&amphead[4],  &amprpad[0],    4);\newline  rpad[2] = taus_get ();\newline  memcpy (&amphead[8],  &amprpad[2],    4);\newline\newline  /* size (payload)\newline   */ \newline  head[12] = header[1];\newline  head[13] = header[2];\newline  head[14] = &#039\\0&#039;\newline  head[15] = &#039\\0&#039;\newline\newline  if (i_blk &lt i_blkmax) \newline  {\newline    pads   = i_blkmax - i_blk;\newline    epad   = taus_get_double (&amprpad);\newline    i_epad = (unsigned long) (pads * epad);\newline  }\newline\newline  full_size =  16;                        /* head     */\newline  if (sl_ok_muls(i_blk, 16) &amp&amp sl_ok_adds(full_size, (i_blk*16)))\newline    full_size =  full_size + (i_blk*16);  /* payload  */\newline  else\newline    oflow = 1;\newline  if (sl_ok_adds(full_size, (i_epad*16)))\newline    full_size =  full_size + (i_epad*16); /* pad      */\newline  else\newline    i_epad = 0;\newline\newline  if (oflow)\newline    {\newline      sh_error_handle((-1), FIL__, __LINE__, -1, MSG_E_SUBGEN,\newline		      _(&quotinteger overflow&quot), \newline		      _(&quotsh_tools_makePack&quot));\newline    }\newline\newline  full_ret = SH_ALLOC(full_size);\newline\newline  memcpy(full_ret,                   head,    16);\newline  if (payload != NULL &amp&amp !oflow)\newline    memcpy(&ampfull_ret[16],              payload, payload_size);\newline\newline  if ((i_blk*16) &gt payload_size &amp&amp !oflow) \newline    {\newline      memset(&ampfull_ret[16+payload_size], &#039\\0&#039, (i_blk*16) - payload_size);\newline      payload_size = i_blk * 16;\newline    }\newline  memset(&ampfull_ret[16+payload_size], &#039\\0&#039, i_epad*16);\newline\newline  /* rewrite header\newline   */\newline  header[1]   = (unsigned int)(full_size/256);\newline  header[2]   = (unsigned int)(full_size - (256 * header[1]));\newline\newline  p      = (unsigned char *) full_ret; \newline  blkfac = full_size / B_SIZ;\newline\newline  err_num = rijndael_cipherInit (&ampcipherInst, MODE_CBC, NULL);\newline  \newline  if (err_num &lt 0) {\newline    sh_error_handle((-1), FIL__, __LINE__, -1, MSG_E_SUBGEN,\newline		    errorExplain(err_num, expbuf, sizeof(expbuf)), \newline		    _(&quotsh_tools_makePack: rijndael_cipherInit&quot)); }\newline\newline  if (probe_ok(flag)) {\newline    memcpy(inBlock, p, B_SIZ);\newline    err_num = rijndael_blockEncrypt(&ampcipherInst, keyInstE, \newline				    inBlock, 128, outBlock);\newline    if (err_num &gt= 0) {\newline      memcpy(p, outBlock, B_SIZ); p += B_SIZ;\newline      memcpy(ivBlock, outBlock, sizeof(ivBlock));\newline      err_num = rijndael_cipherInit (&ampcipherInst, MODE_CBC, ivBlock);\newline      if (err_num &gt= 0) {\newline	err_num = rijndael_blockEncrypt(&ampcipherInst, keyInstE, \newline					p, 128*(blkfac-1), p);\newline      }\newline    }\newline  }\newline\newline  else {\newline    for (j = 0; j &lt blkfac; ++j) {\newline      memcpy(inBlock, p, B_SIZ);\newline      err_num = rijndael_blockEncrypt(&ampcipherInst, keyInstE, \newline				      inBlock, 128, outBlock);\newline      \newline      if (err_num &lt 0) {\newline	sh_error_handle((-1), FIL__, __LINE__, -1, MSG_E_SUBGEN,\newline			errorExplain(err_num, expbuf, sizeof(expbuf)), \newline			_(&quotsh_tools_makePack: rijndael_blockEncrypt&quot));\newline	break; }\newline      \newline      memcpy(p, outBlock, B_SIZ);\newline      p += B_SIZ;\newline    }\newline  }\newline\newline  return full_ret;\newline}\newline","\newline #define DEBUG_EN2\newline \newline ingest version 1 7-byte header and payload, return version2 header/payload\newline last 4 bytes of outgoing header are set to dummy value\newline \newline",1778102,aligner_seed_policy.cpp,"void SeedAlignmentPolicy::parseString(\newline                                      const       std::string&amp s,\newline                                      bool        local,\newline                                      bool        noisyHpolymer,\newline                                      bool        ignoreQuals,\newline                                      int&amp        bonusMatchType,\newline                                      int&amp        bonusMatch,\newline                                      int&amp        penMmcType,\newline                                      int&amp        penMmcMax,\newline                                      int&amp        penMmcMin,\newline                                      int&amp        penScMax,\newline                                      int&amp        penScMin,\newline                                      int&amp        penNType,\newline                                      int&amp        penN,\newline                                      int&amp        penRdExConst,\newline                                      int&amp        penRfExConst,\newline                                      int&amp        penRdExLinear,\newline                                      int&amp        penRfExLinear,\newline                                      SimpleFunc&amp costMin,\newline                                      SimpleFunc&amp nCeil,\newline                                      bool&amp       nCatPair,\newline                                      int&amp        multiseedMms,\newline                                      int&amp        multiseedLen,\newline                                      SimpleFunc&amp multiseedIval,\newline                                      size_t&amp     failStreak,\newline                                      size_t&amp     seedRounds,\newline                                      SimpleFunc* penCanIntronLen,\newline                                      SimpleFunc* penNoncanIntronLen)\newline{\newline\newline	bonusMatchType    = local ? DEFAULT_MATCH_BONUS_TYPE_LOCAL : DEFAULT_MATCH_BONUS_TYPE;\newline	bonusMatch        = local ? DEFAULT_MATCH_BONUS_LOCAL : DEFAULT_MATCH_BONUS;\newline	penMmcType        = ignoreQuals ? DEFAULT_MM_PENALTY_TYPE_IGNORE_QUALS :\newline	                                  DEFAULT_MM_PENALTY_TYPE;\newline	penMmcMax         = DEFAULT_MM_PENALTY_MAX;\newline	penMmcMin         = DEFAULT_MM_PENALTY_MIN;\newline	penNType          = DEFAULT_N_PENALTY_TYPE;\newline	penN              = DEFAULT_N_PENALTY;\newline    \newline    penScMax          = DEFAULT_SC_PENALTY_MAX;\newline    penScMin          = DEFAULT_SC_PENALTY_MIN;\newline	\newline	const double DMAX = std::numeric_limits&ltdouble&gt::max();\newline    costMin.init(\newline		local ? SIMPLE_FUNC_LOG : SIMPLE_FUNC_LINEAR,\newline		local ? DEFAULT_MIN_CONST_LOCAL  : 0.0f,\newline		local ? DEFAULT_MIN_LINEAR_LOCAL : -0.2f);\newline	nCeil.init(\newline		SIMPLE_FUNC_LINEAR, 0.0f, DMAX,\newline		DEFAULT_N_CEIL_CONST, DEFAULT_N_CEIL_LINEAR);\newline	multiseedIval.init(\newline		DEFAULT_IVAL, 1.0f, DMAX,\newline		DEFAULT_IVAL_B, DEFAULT_IVAL_A);\newline	nCatPair          = DEFAULT_N_CAT_PAIR;\newline\newline	if(!noisyHpolymer) {\newline		penRdExConst  = DEFAULT_READ_GAP_CONST;\newline		penRdExLinear = DEFAULT_READ_GAP_LINEAR;\newline		penRfExConst  = DEFAULT_REF_GAP_CONST;\newline		penRfExLinear = DEFAULT_REF_GAP_LINEAR;\newline	} else {\newline		penRdExConst  = DEFAULT_READ_GAP_CONST_BADHPOLY;\newline		penRdExLinear = DEFAULT_READ_GAP_LINEAR_BADHPOLY;\newline		penRfExConst  = DEFAULT_REF_GAP_CONST_BADHPOLY;\newline		penRfExLinear = DEFAULT_REF_GAP_LINEAR_BADHPOLY;\newline	}\newline	\newline	multiseedMms      = DEFAULT_SEEDMMS;\newline	multiseedLen      = DEFAULT_SEEDLEN;\newline	\newline	EList&ltstring&gt toks(MISC_CAT);\newline	string tok;\newline	istringstream ss(s);\newline	int setting = 0;\newline	// Get each ;-separated token\newline	while(getline(ss, tok, &#039;&#039)) {\newline		setting++;\newline		EList&ltstring&gt etoks(MISC_CAT);\newline		string etok;\newline		// Divide into tokens on either side of =\newline		istringstream ess(tok);\newline		while(getline(ess, etok, &#039=&#039)) {\newline			etoks.push_back(etok);\newline		}\newline		// Must be exactly 1 =\newline		if(etoks.size() != 2) {\newline			cerr &lt&lt &quotError parsing alignment policy setting &quot &lt&lt setting\newline			     &lt&lt &quot; must be bisected by = sign&quot &lt&lt endl\newline				 &lt&lt &quotPolicy: &quot &lt&lt s.c_str() &lt&lt endl;\newline			assert(false); throw 1;\newline		}\newline		// LHS is tag, RHS value\newline		string tag = etoks[0], val = etoks[1];\newline		// Separate value into comma-separated tokens\newline		EList&ltstring&gt ctoks(MISC_CAT);\newline		string ctok;\newline		istringstream css(val);\newline		while(getline(css, ctok, &#039,&#039)) {\newline			ctoks.push_back(ctok);\newline		}\newline		if(ctoks.size() == 0) {\newline			cerr &lt&lt &quotError parsing alignment policy setting &quot &lt&lt setting\newline			     &lt&lt &quot; RHS must have at least 1 token&quot &lt&lt endl\newline				 &lt&lt &quotPolicy: &quot &lt&lt s.c_str() &lt&lt endl;\newline			assert(false); throw 1;\newline		}\newline		for(size_t i = 0; i &lt ctoks.size(); i++) {\newline			if(ctoks[i].length() == 0) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot &lt&lt setting\newline				     &lt&lt &quot; token &quot &lt&lt i+1 &lt&lt &quot on RHS had length=0&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &quot &lt&lt s.c_str() &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline		}\newline		// Bonus for a match\newline		// MA=xx (default: MA=0, or MA=10 if --local is set)\newline		if(tag == &quotMA&quot) {\newline			if(ctoks.size() != 1) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot &lt&lt setting\newline				     &lt&lt &quot; RHS must have 1 token&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &quot &lt&lt s.c_str() &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			string tmp = ctoks[0];\newline			istringstream tmpss(tmp);\newline			tmpss &gt&gt bonusMatch;\newline		}\newline		// Scoring for mismatches\newline		// MMP={Cxx|Q|RQ}\newline		//        Cxx = constant, where constant is integer xx\newline		//        Qxx = equal to quality, scaled\newline		//        R   = equal to maq-rounded quality value (rounded to nearest\newline		//              10, can&#039t be greater than 30)\newline		else if(tag == &quotMMP&quot) {\newline			if(ctoks.size() &gt 3) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot\newline				     &lt&lt &quot; RHS must have at most 3 tokens&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks[0][0] == &#039C&#039) {\newline				string tmp = ctoks[0].substr(1);\newline				// Parse constant penalty\newline				istringstream tmpss(tmp);\newline				tmpss &gt&gt penMmcMax;\newline				penMmcMin = penMmcMax;\newline				// Parse constant penalty\newline				penMmcType = COST_MODEL_CONSTANT;\newline			} else if(ctoks[0][0] == &#039Q&#039) {\newline				if(ctoks.size() &gt= 2) {\newline					string tmp = ctoks[1];\newline					istringstream tmpss(tmp);\newline					tmpss &gt&gt penMmcMax;\newline				} else {\newline					penMmcMax = DEFAULT_MM_PENALTY_MAX;\newline				}\newline				if(ctoks.size() &gt= 3) {\newline					string tmp = ctoks[2];\newline					istringstream tmpss(tmp);\newline					tmpss &gt&gt penMmcMin;\newline				} else {\newline					penMmcMin = DEFAULT_MM_PENALTY_MIN;\newline				}\newline				if(penMmcMin &gt penMmcMax) {\newline					cerr &lt&lt &quotError: Maximum mismatch penalty (&quot &lt&lt penMmcMax\newline					     &lt&lt &quot) is less than minimum penalty (&quot &lt&lt penMmcMin\newline						 &lt&lt endl;\newline					throw 1;\newline				}\newline				// Set type to =quality\newline				penMmcType = COST_MODEL_QUAL;\newline			} else if(ctoks[0][0] == &#039R&#039) {\newline				// Set type to=Maq-quality\newline				penMmcType = COST_MODEL_ROUNDED_QUAL;\newline			} else {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot\newline				     &lt&lt &quot; RHS must start with C, Q or R&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline		}\newline        else if(tag == &quotSCP&quot) {\newline            if(ctoks.size() &gt 3) {\newline                cerr &lt&lt &quotError parsing alignment policy setting &quot\newline                &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot\newline                &lt&lt &quot; SCP must have at most 3 tokens&quot &lt&lt endl\newline                &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline                assert(false); throw 1;\newline            }\newline            istringstream tmpMax(ctoks[1]);\newline            tmpMax &gt&gt penScMax;\newline            istringstream tmpMin(ctoks[1]);\newline            tmpMin &gt&gt penScMin;\newline            if(penScMin &gt penScMax) {\newline                cerr &lt&lt &quotmax (&quot &lt&lt penScMax &lt&lt &quot) should be &gt= min (&quot &lt&lt penScMin &lt&lt &quot)&quot &lt&lt endl;\newline                assert(false); throw 1;\newline            }\newline            if(penScMin &lt 1) {\newline                cerr &lt&lt &quotmin (&quot &lt&lt penScMin &lt&lt &quot) should be greater than 0&quot &lt&lt endl;\newline                assert(false); throw 1;\newline            }\newline        }\newline		// Scoring for mismatches where read char=N\newline		// NP={Cxx|Q|RQ}\newline		//        Cxx = constant, where constant is integer xx\newline		//        Q   = equal to quality\newline		//        R   = equal to maq-rounded quality value (rounded to nearest\newline		//              10, can&#039t be greater than 30)\newline		else if(tag == &quotNP&quot) {\newline			if(ctoks.size() != 1) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot\newline				     &lt&lt &quot; RHS must have 1 token&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks[0][0] == &#039C&#039) {\newline				string tmp = ctoks[0].substr(1);\newline				// Parse constant penalty\newline				istringstream tmpss(tmp);\newline				tmpss &gt&gt penN;\newline				// Parse constant penalty\newline				penNType = COST_MODEL_CONSTANT;\newline			} else if(ctoks[0][0] == &#039Q&#039) {\newline				// Set type to =quality\newline				penNType = COST_MODEL_QUAL;\newline			} else if(ctoks[0][0] == &#039R&#039) {\newline				// Set type to=Maq-quality\newline				penNType = COST_MODEL_ROUNDED_QUAL;\newline			} else {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot\newline				     &lt&lt &quot; RHS must start with C, Q or R&quot &lt&lt endl\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline		}\newline		// Scoring for read gaps\newline		// RDG=xx,yy,zz\newline		//        xx = read gap open penalty\newline		//        yy = read gap extension penalty constant coefficient\newline		//             (defaults to open penalty)\newline		//        zz = read gap extension penalty linear coefficient\newline		//             (defaults to 0)\newline		else if(tag == &quotRDG&quot) {\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt penRdExConst;\newline			} else {\newline				penRdExConst = noisyHpolymer ?\newline					DEFAULT_READ_GAP_CONST_BADHPOLY :\newline					DEFAULT_READ_GAP_CONST;\newline			}\newline			if(ctoks.size() &gt= 2) {\newline				istringstream tmpss(ctoks[1]);\newline				tmpss &gt&gt penRdExLinear;\newline			} else {\newline				penRdExLinear = noisyHpolymer ?\newline					DEFAULT_READ_GAP_LINEAR_BADHPOLY :\newline					DEFAULT_READ_GAP_LINEAR;\newline			}\newline		}\newline		// Scoring for reference gaps\newline		// RFG=xx,yy,zz\newline		//        xx = ref gap open penalty\newline		//        yy = ref gap extension penalty constant coefficient\newline		//             (defaults to open penalty)\newline		//        zz = ref gap extension penalty linear coefficient\newline		//             (defaults to 0)\newline		else if(tag == &quotRFG&quot) {\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt penRfExConst;\newline			} else {\newline				penRfExConst = noisyHpolymer ?\newline					DEFAULT_REF_GAP_CONST_BADHPOLY :\newline					DEFAULT_REF_GAP_CONST;\newline			}\newline			if(ctoks.size() &gt= 2) {\newline				istringstream tmpss(ctoks[1]);\newline				tmpss &gt&gt penRfExLinear;\newline			} else {\newline				penRfExLinear = noisyHpolymer ?\newline					DEFAULT_REF_GAP_LINEAR_BADHPOLY :\newline					DEFAULT_REF_GAP_LINEAR;\newline			}\newline		}\newline		// Minimum score as a function of read length\newline		// MIN=xx,yy\newline		//        xx = constant coefficient\newline		//        yy = linear coefficient\newline		else if(tag == &quotMIN&quot) {\newline			PARSE_FUNC(costMin);\newline		}\newline		// Per-read N ceiling as a function of read length\newline		// NCEIL=xx,yy\newline		//        xx = N ceiling constant coefficient\newline		//        yy = N ceiling linear coefficient (set to 0 if unspecified)\newline		else if(tag == &quotNCEIL&quot) {\newline			PARSE_FUNC(nCeil);\newline		}\newline		/*\newline		 * Seeds\newline		 * -----\newline		 *\newline		 * SEED=mm,len,ival (default: SEED=0,22)\newline		 *\newline		 *   mm   = Maximum number of mismatches allowed within a seed.\newline		 *          Must be &gt= 0 and &lt= 2.  Note that 2-mismatch mode is\newline		 *          not fully sensitive; i.e. some 2-mismatch seed\newline		 *          alignments may be missed.\newline		 *   len  = Length of seed.\newline		 *   ival = Interval between seeds.  If not specified, seed\newline		 *          interval is determined by IVAL.\newline		 */\newline		else if(tag == &quotSEED&quot) {\newline			if(ctoks.size() &gt 2) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039; RHS must have 1 or 2 tokens, &quot\newline					 &lt&lt &quothad &quot &lt&lt ctoks.size() &lt&lt &quot.  &quot\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt multiseedMms;\newline				if(multiseedMms &gt 1) {\newline					cerr &lt&lt &quotError: -N was set to &quot &lt&lt multiseedMms &lt&lt &quot, but cannot be set greater than 1&quot &lt&lt endl;\newline					throw 1;\newline				}\newline				if(multiseedMms &lt 0) {\newline					cerr &lt&lt &quotError: -N was set to a number less than 0 (&quot &lt&lt multiseedMms &lt&lt &quot)&quot &lt&lt endl;\newline					throw 1;\newline				}\newline			}\newline			if(ctoks.size() &gt= 2) {\newline				istringstream tmpss(ctoks[1]);\newline				tmpss &gt&gt multiseedLen;\newline			} else {\newline				multiseedLen = DEFAULT_SEEDLEN;\newline			}\newline		}\newline		else if(tag == &quotSEEDLEN&quot) {\newline			if(ctoks.size() &gt 1) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039; RHS must have 1 token, &quot\newline					 &lt&lt &quothad &quot &lt&lt ctoks.size() &lt&lt &quot.  &quot\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt multiseedLen;\newline			}\newline		}\newline		else if(tag == &quotDPS&quot) {\newline			if(ctoks.size() &gt 1) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039; RHS must have 1 token, &quot\newline					 &lt&lt &quothad &quot &lt&lt ctoks.size() &lt&lt &quot.  &quot\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt failStreak;\newline			}\newline		}\newline		else if(tag == &quotROUNDS&quot) {\newline			if(ctoks.size() &gt 1) {\newline				cerr &lt&lt &quotError parsing alignment policy setting &quot\newline				     &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039; RHS must have 1 token, &quot\newline					 &lt&lt &quothad &quot &lt&lt ctoks.size() &lt&lt &quot.  &quot\newline					 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline				assert(false); throw 1;\newline			}\newline			if(ctoks.size() &gt= 1) {\newline				istringstream tmpss(ctoks[0]);\newline				tmpss &gt&gt seedRounds;\newline			}\newline		}\newline		/*\newline		 * Seed interval\newline		 * -------------\newline		 *\newline		 * IVAL={L|S|C},a,b (default: IVAL=S,1.0,0.0)\newline		 *\newline		 *   L  = let interval between seeds be a linear function of the\newline		 *        read length.  xx and yy are the constant and linear\newline		 *        coefficients respectively.  In other words, the interval\newline		 *        equals a * len + b, where len is the read length.\newline		 *        Intervals less than 1 are rounded up to 1.\newline		 *   S  = let interval between seeds be a function of the sqaure\newline		 *        root of the  read length.  xx and yy are the\newline		 *        coefficients.  In other words, the interval equals\newline		 *        a * sqrt(len) + b, where len is the read length.\newline		 *        Intervals less than 1 are rounded up to 1.\newline		 *   C  = Like S but uses cube root of length instead of square\newline		 *        root.\newline		 */\newline		else if(tag == &quotIVAL&quot) {\newline			PARSE_FUNC(multiseedIval);\newline		}\newline        else if(tag == &quotCANINTRONLEN&quot) {\newline            assert(penCanIntronLen != NULL);\newline			PARSE_FUNC((*penCanIntronLen));\newline		}\newline        else if(tag == &quotNONCANINTRONLEN&quot) {\newline            assert(penNoncanIntronLen != NULL);\newline            PARSE_FUNC((*penNoncanIntronLen));\newline        }\newline		else {\newline			// Unknown tag\newline			cerr &lt&lt &quotUnexpected alignment policy setting &quot\newline				 &lt&lt &quot&#039&quot &lt&lt tag.c_str() &lt&lt &quot&#039&quot &lt&lt endl\newline				 &lt&lt &quotPolicy: &#039&quot &lt&lt s.c_str() &lt&lt &quot&#039&quot &lt&lt endl;\newline			assert(false); throw 1;\newline		}\newline	}\newline}\newline","\newline Parse alignment policy when provided in this format:\newline &ltlab&gt=&ltval&gt;&ltlab&gt=&ltval&gt;&ltlab&gt=&ltval&gt...\newline \newline And label=value possibilities are:\newline \newline Bonus for a match\newline -----------------\newline \newline MA=xx (default: MA=0, or MA=2 if --local is set)\newline \newline xx = Each position where equal read and reference characters match up\newline in the alignment contriubtes this amount to the total score.\newline \newline Penalty for a mismatch\newline ----------------------\newline \newline MMP={Cxx|Q|RQ} (default: MMP=C6)\newline \newline Cxx = Each mismatch costs xx. If MMP=Cxx is specified, quality\newline values are ignored when assessing penalities for mismatches.\newline Q = Each mismatch incurs a penalty equal to the mismatched base&#039s\newline value.\newline R = Each mismatch incurs a penalty equal to the mismatched base&#039s\newline rounded quality value. Qualities are rounded off to the\newline nearest 10, and qualities greater than 30 are rounded to 30.\newline \newline Penalty for position with N (in either read or reference)\newline ---------------------------------------------------------\newline \newline NP={Cxx|Q|RQ} (default: NP=C1)\newline \newline Cxx = Each alignment position with an N in either the read or the\newline reference costs xx. If NP=Cxx is specified, quality values are\newline ignored when assessing penalities for Ns.\newline Q = Each alignment position with an N in either the read or the\newline reference incurs a penalty equal to the read base&#039s quality\newline value.\newline R = Each alignment position with an N in either the read or the\newline reference incurs a penalty equal to the read base&#039s rounded\newline quality value. Qualities are rounded off to the nearest 10,\newline and qualities greater than 30 are rounded to 30.\newline \newline Penalty for a read gap\newline ----------------------\newline \newline RDG=xx,yy (default: RDG=5,3)\newline \newline xx = Read gap open penalty.\newline yy = Read gap extension penalty.\newline \newline Total cost incurred by a read gap = xx + (yy gap length)\newline \newline Penalty for a reference gap\newline ---------------------------\newline \newline RFG=xx,yy (default: RFG=5,3)\newline \newline xx = Reference gap open penalty.\newline yy = Reference gap extension penalty.\newline \newline Total cost incurred by a reference gap = xx + (yy gap length)\newline \newline Minimum score for valid alignment\newline ---------------------------------\newline \newline MIN=xx,yy (defaults: MIN=-0.6,-0.6, or MIN=0.0,0.66 if --local is set)\newline \newline xx,yy = For a read of length N, the total score must be at least\newline xx + (read length yy) for the alignment to be valid. The\newline total score is the sum of all negative penalties (from\newline mismatches and gaps) and all positive bonuses. The minimum\newline can be negative (and is by default in global alignment mode).\newline \newline Score floor for local alignment\newline -------------------------------\newline \newline FL=xx,yy (defaults: FL=-Infinity,0.0, or FL=0.0,0.0 if --local is set)\newline \newline xx,yy = If a cell in the dynamic programming table has a score less\newline than xx + (read length yy), then no valid alignment can go\newline through it. Defaults are highly recommended.\newline \newline N ceiling\newline ---------\newline \newline NCEIL=xx,yy (default: NCEIL=0.0,0.15)\newline \newline xx,yy = For a read of length N, the number of alignment\newline positions with an N in either the read or the\newline reference cannot exceed\newline ceiling = xx + (read length yy). If the ceiling is\newline exceeded, the alignment is considered invalid.\newline \newline Seeds\newline -----\newline \newline SEED=mm,len,ival (default: SEED=0,22)\newline \newline mm = Maximum number of mismatches allowed within a seed.\newline Must be &gt= 0 and &lt= 2. Note that 2-mismatch mode is\newline not fully sensitive; i.e. some 2-mismatch seed\newline alignments may be missed.\newline len = Length of seed.\newline ival = Interval between seeds. If not specified, seed\newline interval is determined by IVAL.\newline \newline Seed interval\newline -------------\newline \newline IVAL={L|S|C},xx,yy (default: IVAL=S,1.0,0.0)\newline \newline L = let interval between seeds be a linear function of the\newline read length. xx and yy are the constant and linear\newline coefficients respectively. In other words, the interval\newline equals a len + b, where len is the read length.\newline Intervals less than 1 are rounded up to 1.\newline S = let interval between seeds be a function of the sqaure\newline root of the read length. xx and yy are the\newline coefficients. In other words, the interval equals\newline a sqrt(len) + b, where len is the read length.\newline Intervals less than 1 are rounded up to 1.\newline C = Like S but uses cube root of length instead of square\newline root.\newline \newline Example 1:\newline \newline SEED=1,10,5 and read sequence is TGCTATCGTACGATCGTAC:\newline \newline The following seeds are extracted from the forward\newline representation of the read and aligned to the reference\newline allowing up to 1 mismatch:\newline \newline Read: TGCTATCGTACGATCGTACA\newline \newline Seed 1+: TGCTATCGTA\newline Seed 2+: TCGTACGATC\newline Seed 3+: CGATCGTACA\newline \newline ...and the following are extracted from the reverse-complement\newline representation of the read and align to the reference allowing\newline up to 1 mismatch:\newline \newline Seed 1-: TACGATAGCA\newline Seed 2-: GATCGTACGA\newline Seed 3-: TGTACGATCG\newline \newline Example 2:\newline \newline SEED=1,20,20 and read sequence is TGCTATCGTACGATC. The seed\newline length is 20 but the read is only 15 characters long. In this\newline case, Bowtie2 automatically shrinks the seed length to be equal\newline to the read length.\newline \newline Read: TGCTATCGTACGATC\newline \newline Seed 1+: TGCTATCGTACGATC\newline Seed 1-: GATCGTACGATAGCA\newline \newline Example 3:\newline \newline SEED=1,10,10 and read sequence is TGCTATCGTACGATC. Only one seed\newline fits on the read; a second seed would overhang the end of the read\newline by 5 positions. In this case, Bowtie2 extracts one seed.\newline \newline Read: TGCTATCGTACGATC\newline \newline Seed 1+: TGCTATCGTA\newline Seed 1-: TACGATAGCA\newline \newline",2750033,tarraybind.c,"static int tolua_get_array(lua_State* tolua_S)\newline{\newline tolua_pushusertype(tolua_S,(void*)&amparray,&quotArray&quot);\newline return 1;\newline}\newline",get function: array \newline,4257624,matrix_addon.c,"void Matrix_oppose(Matrix * M) {\newline  int i,j;\newline  for (i=0; i&ltM-&gtNbRows; i++) {\newline    for (j=0; j&lt M-&gtNbColumns; j++) {\newline      value_oppose(M-&gtp[i][j], M-&gtp[i][j]);\newline    }\newline  }\newline}\newline",\newline transforms a matrix M into -M\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4459868,cast5.c,"int cast5_test(void)\newline{\newline #ifndef LTC_TEST\newline    return CRYPT_NOP;\newline #else    \newline   static const struct {\newline       int keylen;\newline       unsigned char key[16];\newline       unsigned char pt[8];\newline       unsigned char ct[8];\newline   } tests[] = {\newline     { 16,\newline       {0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45, 0x67, 0x89, 0x34, 0x56, 0x78, 0x9A},\newline       {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\newline       {0x23, 0x8B, 0x4F, 0xE5, 0x84, 0x7E, 0x44, 0xB2}\newline     },\newline     { 10,\newline       {0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78, 0x23, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\newline       {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\newline       {0xEB, 0x6A, 0x71, 0x1A, 0x2C, 0x02, 0x27, 0x1B},\newline     },\newline     { 5,\newline       {0x01, 0x23, 0x45, 0x67, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\newline       {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\newline       {0x7A, 0xC8, 0x16, 0xD1, 0x6E, 0x9B, 0x30, 0x2E}\newline     }\newline   };\newline   int i, y, err;\newline   symmetric_key key;\newline   unsigned char tmp[2][8];\newline\newline   for (i = 0; i &lt (int)(sizeof(tests) / sizeof(tests[0])); i++) {\newline       if ((err = cast5_setup(tests[i].key, tests[i].keylen, 0, &ampkey)) != CRYPT_OK) {\newline          return err;\newline       }\newline       cast5_ecb_encrypt(tests[i].pt, tmp[0], &ampkey);\newline       cast5_ecb_decrypt(tmp[0], tmp[1], &ampkey);\newline       if ((XMEMCMP(tmp[0], tests[i].ct, 8) != 0) || (XMEMCMP(tmp[1], tests[i].pt, 8) != 0)) {\newline          return CRYPT_FAIL_TESTVECTOR;\newline       }\newline      /* now see if we can encrypt all zero bytes 1000 times, decrypt and come back where we started */\newline      for (y = 0; y &lt 8; y++) tmp[0][y] = 0;\newline      for (y = 0; y &lt 1000; y++) cast5_ecb_encrypt(tmp[0], tmp[0], &ampkey);\newline      for (y = 0; y &lt 1000; y++) cast5_ecb_decrypt(tmp[0], tmp[0], &ampkey);\newline      for (y = 0; y &lt 8; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;\newline   \newline   }\newline   return CRYPT_OK;\newline #endif\newline}\newline","\newlinePerforms a self-test of the LTC_CAST5 block cipher\newline@return CRYPT_OK if functional, CRYPT_NOP if self-test has been disabled\newline \newline",101117,restore_layout.c,"void restore_open_placeholder_windows(Con *parent) {\newline    Con *child;\newline    TAILQ_FOREACH(child, &amp(parent-&gtnodes_head), nodes) {\newline        open_placeholder_window(child);\newline    }\newline    TAILQ_FOREACH(child, &amp(parent-&gtfloating_head), floating_windows) {\newline        open_placeholder_window(child);\newline    }\newline\newline    xcb_flush(restore_conn);\newline}\newline","\newline Open placeholder windows for all children of parent. The placeholder window\newline will vanish as soon as a real window is swallowed by the container. Until\newline then, it exposes the criteria that must be fulfilled for a window to be\newline swallowed by this container.\newline \newline \newline",4525506,virtual.c,static inline void vperfctr_resume(struct vperfctr *perfctr)\newline{\newline	debug_resume(perfctr);\newline	perfctr_cpu_resume(&ampperfctr-&gtcpu_state);\newline	vperfctr_reset_sampling_timer(perfctr);\newline	debug_set_smp_id(perfctr);\newline}\newline,PRE: perfctr == current-&gtthread.perfctr &amp&amp IS_RUNNING(perfctr)\newline Restart the counters.\newline \newline,414494,xmcombo.c,"static XtGeometryResult QueryGeometry(XmComboBoxWidget w, \newline                                      XtWidgetGeometry *Request, \newline			              XtWidgetGeometry *Reply)\newline{\newline    XtGeometryResult result = XtGeometryYes;\newline    Dimension        minW, minH, editW, labelW;\newline    \newline/* Elternteil will nichts weiter aendern, also ist uns das\newline * recht so.\newline */\newline    Request-&gtrequest_mode &amp= CWWidth | CWHeight;\newline    if ( Request-&gtrequest_mode == 0 ) return result;\newline\newline    DefaultGeometry(w, &ampminW, &ampminH, &ampeditW, &amplabelW);\newline\newline/* Ueberpruefe, ob uns das in der Breite passt, was Pappi moechte... */\newline    if ( Request-&gtrequest_mode &amp CWWidth ) {\newline	if ( Request-&gtwidth &lt minW ) {\newline/* Wenn Pappi uns etwas vorschlaegt, was im wahrsten Sinne des Wortes \newline * vorn und hinten nicht reicht, dann versuchen wir ihn entsprechend\newline * zu korrigieren. (&quotVersuchen&quot deshalb, weil er diesen Vorschlag auch\newline * voellig ignorieren kann.)\newline */\newline	    result               = XtGeometryAlmost;\newline	    Reply-&gtwidth         = minW;\newline	    Reply-&gtrequest_mode |= CWWidth;\newline	}\newline    }\newline/* Die ganze Chose nun noch vertikal */\newline    if ( Request-&gtrequest_mode &amp CWHeight ) {\newline	if ( Request-&gtheight &lt minH ) {\newline	    result               = XtGeometryAlmost;\newline	    Reply-&gtheight        = minH;\newline	    Reply-&gtrequest_mode |= CWHeight;\newline	}\newline    }\newline    return result;\newline} /* QueryGeometry */\newline","--------------------------------------------------------------------\newline Pappi fragt nach, wie gross wir denn sein wollen.\newline Die hier benutzte Vorgehensweise zur Ermittlung der Groesse:\newline Sobald der Vater uns eine Breite (oder aber Hoehe) vorschlaegt, \newline die fuer uns eigentlich zu klein ist, meckern wir und schlagen\newline die von uns benoetigte Breite (Hoehe) vor.\newline Soweit also zur Theorie... leider sieht es beispielsweise das\newline Motif Form-Widget ueberhaupt nicht ein, uns auch nur ein einziges\newline Mal nach unseren Wuenschen zu fragen! Damit es bei derart unum-\newline gaenglichen Widgets dann doch noch geht, muss ChangedManaged die\newline Kohlen wieder aus dem Feuer holen mit einer Sondertour.\newline Parameter:\newline Request Vom Vater vorgeschlagene Geometrie\newline Ergebnis:\newline Reply Unsere Antwort auf die vorgeschlagene Geometrie\newline sowie XtGeometryYes oder XtGeometryAlmost, je nachdem, wie gut\newline uns Pappis Vorschlag in den Kram passt.\newline \newline",3196959,log.c,"void log_streamed_channels(char *log_module,int number_of_channels, mumudvb_channel_t *channels, int multicast_ipv4,int multicast_ipv6, int unicast, int unicast_master_port, char *unicastipOut)\newline{\newline  int curr_channel;\newline  int curr_pid;\newline\newline  log_message( log_module,  MSG_INFO, &quotDiffusion %d channel%s\\n&quot, number_of_channels,\newline	       (number_of_channels &lt= 1 ? &quot&quot : &quots&quot));\newline  for (curr_channel = 0; curr_channel &lt number_of_channels; curr_channel++)\newline  {\newline    log_message( log_module,  MSG_INFO, &quotChannel number : %3d, name : \\&quot%s\\&quot  service id %d \\n&quot, curr_channel, channels[curr_channel].name, channels[curr_channel].service_id);\newline    if(multicast_ipv4)\newline      {\newline	log_message( log_module,  MSG_INFO, &quot\\tMulticast4 ip : %s:%d\\n&quot, channels[curr_channel].ip4Out, channels[curr_channel].portOut);\newline      }\newline    if(multicast_ipv6)\newline      {\newline	log_message( log_module,  MSG_INFO, &quot\\tMulticast6 ip : [%s]:%d\\n&quot, channels[curr_channel].ip6Out, channels[curr_channel].portOut);\newline      }\newline    if(unicast)\newline    {\newline      log_message( log_module,  MSG_INFO, &quot\\tUnicast : Channel accessible via the master connection, %s:%d\\n&quot,unicastipOut, unicast_master_port);\newline      if(channels[curr_channel].unicast_port)\newline        log_message( log_module,  MSG_INFO, &quot\\tUnicast : Channel accessible directly via %s:%d\\n&quot,unicastipOut, channels[curr_channel].unicast_port);\newline    }\newline    mumu_string_t string=EMPTY_STRING;\newline    char lang[5];\newline    if((Interrupted=mumu_string_append(&ampstring, &quot        pids : &quot)))return;\newline    for (curr_pid = 0; curr_pid &lt channels[curr_channel].num_pids; curr_pid++)\newline    {\newline      strncpy(lang+1,channels[curr_channel].pids_language[curr_pid],4);\newline      lang[0]=(lang[1]==&#039-&#039) ? &#039\\0&#039: &#039 &#039;\newline      if((Interrupted=mumu_string_append(&ampstring, &quot%d (%s%s), &quot, channels[curr_channel].pids[curr_pid], pid_type_to_str(channels[curr_channel].pids_type[curr_pid]), lang)))\newline        return;\newline    }\newline    log_message( log_module, MSG_DETAIL,&quot%s\\n&quot,string.string);\newline    mumu_free_string(&ampstring);\newline  }\newline}\newline",\newline @brief Display the list of the streamed channels\newline \newline @param number_of_channels the number of channels\newline @param channels : the channels array\newline \newline,4319297,parse_exec.c,"int Xorriso_cmd_sorting_rank(struct XorrisO *xorriso,\newline                        int argc, char **argv, int idx, int flag)\newline{\newline int ret, i, cmd_data_size= 2 * SfileadrL;\newline char *cmd, *cmd_data= NULL;\newline static char *commands[]= {\newline\newline   &quot* Execution order of program arguments with option -x:&quot,\newline   &quotx&quot,\newline\newline   &quot* Support for frontend programs via stdin and stdout (1):&quot,\newline   &quotprog&quot, &quotprog_help&quot,\newline\newline   &quot* Exception processing:&quot,\newline   &quotabort_on&quot, &quotreturn_with&quot, &quotreport_about&quot, &quotsignal_handling&quot,\newline   &quoterror_behavior&quot,\newline\newline   &quot* Scripting, dialog and program control features (1):&quot,\newline   &quotno_rc&quot, &quothelp&quot, &quotversion&quot, &quotlist_extras&quot, &quotlist_arg_sorting&quot,\newline   &quottemp_mem_limit&quot, &quotbackslash_codes&quot,\newline   &quoterrfile_log&quot, &quotsession_log&quot, &quotscsi_log&quot,\newline   &quotoptions_from_file&quot, &quotlist_delimiter&quot,\newline   &quotprint&quot, &quotprint_info&quot, &quotprint_mark&quot, &quotprompt&quot, &quotsleep&quot,\newline   &quotsh_style_result&quot,\newline\newline   &quot* Drive and media related inquiry actions (1):&quot,\newline   &quotdevices&quot, &quotdevice_links&quot,\newline   &quotmount_opts&quot, &quotmount_cmd&quot, &quotsession_string&quot,\newline\newline   &quot* Influencing the behavior of image loading:&quot,\newline   &quotread_speed&quot, &quotload&quot, &quotdisplacement&quot, &quotread_fs&quot,\newline   &quotdrive_class&quot, &quotassert_volid&quot, &quotin_charset&quot,\newline   &quotauto_charset&quot, &quothardlinks&quot, &quotacl&quot, &quotxattr&quot, &quotmd5&quot, &quotfor_backup&quot,\newline   &quotecma119_map&quot,\newline   &quotdisk_dev_ino&quot, &quotrom_toc_scan&quot, &quotcalm_drive&quot, &quotban_stdio_write&quot,\newline   &quotearly_stdio_test&quot, &quotdata_cache_size&quot,\newline   &quotscsi_dev_family&quot,\newline\newline   &quot* Character sets:&quot,\newline   &quotcharset&quot, &quotlocal_charset&quot,\newline\newline   &quot* Acquiring source and target drive:&quot,\newline   &quotdev&quot, &quotindev&quot, &quotoutdev&quot,\newline\newline   &quot* Drive and media related inquiry actions (2):&quot,\newline   &quotlist_profiles&quot, &quotlist_formats&quot, &quotlist_speeds&quot,\newline   &quottoc&quot, &quottoc_of&quot, &quotpvd_info&quot, &quotreport_system_area&quot, &quotreport_el_torito&quot,\newline\newline   &quot* Settings for file insertion:&quot,\newline   &quotfile_name_limit&quot, &quotfile_size_limit&quot,\newline   &quotnot_mgt&quot, &quotnot_paths&quot, &quotnot_leaf&quot, &quotnot_list&quot,\newline   &quotquoted_not_list&quot, &quotfollow&quot, &quotpathspecs&quot, &quotoverwrite&quot, &quotsplit_size&quot,\newline\newline   &quot* Navigation in ISO image and disk filesystem (1):&quot,\newline   &quotcd&quot, &quotcdx&quot, &quotpwd&quot, &quotpwdx&quot,\newline\newline   &quot* Inserting files into ISO image:&quot,\newline   &quotdisk_pattern&quot, &quotadd_plainly&quot,\newline   &quotmkdir&quot, &quotlns&quot, &quotadd&quot, &quotpath_list&quot, &quotquoted_path_list&quot,\newline   &quotmap&quot, &quotmap_single&quot, &quotmap_l&quot, &quotupdate&quot, &quotupdate_r&quot, &quotupdate_l&quot,\newline   &quotcut_out&quot, &quotcpr&quot, \newline   &quotclone&quot, &quotcp_clone&quot,\newline\newline   &quot* Navigation in ISO image and disk filesystem (2):&quot,\newline   &quotls&quot, &quotlsd&quot, &quotlsl&quot, &quotlsdl&quot, &quotlsx&quot, &quotlsdx&quot, &quotlslx&quot, &quotlsdlx&quot,\newline   &quotgetfacl&quot, &quotgetfacl_r&quot, &quotgetfattr&quot, &quotgetfattr_r&quot, &quotdu&quot, &quotdus&quot,\newline   &quotdux&quot, &quotdusx&quot, &quotfindx&quot,\newline   &quotcompare&quot, &quotcompare_r&quot, &quotcompare_l&quot, &quotshow_stream&quot, &quotshow_stream_r&quot,\newline\newline   &quot* File manipulations:&quot,\newline   &quotiso_rr_pattern&quot,\newline   &quotrm&quot, &quotrm_r&quot, &quotrmdir&quot, &quotmove&quot, &quotmv&quot,\newline   &quotchown&quot, &quotchown_r&quot, &quotchgrp&quot, &quotchgrp_r&quot, &quotchmod&quot, &quotchmod_r&quot, &quotsetfacl&quot,\newline   &quotsetfacl_r&quot, &quotsetfacl_list&quot, &quotsetfattr&quot, &quotsetfattr_r&quot, &quotsetfattr_list&quot,\newline   &quotalter_date&quot, &quotalter_date_r&quot, &quothide&quot,\newline\newline   &quot* Filters for data file content:&quot,\newline   &quotexternal_filter&quot, &quotunregister_filter&quot, &quotclose_filter_list&quot,\newline   &quotset_filter&quot, &quotset_filter_r&quot, \newline\newline   &quot* Tree traversal command -find:&quot,\newline   &quotfind&quot,\newline\newline   &quot* osirrox ISO-to-disk restore options:&quot,\newline   &quotosirrox&quot, &quotextract&quot, &quotextract_single&quot, &quotextract_l&quot, &quotextract_cut&quot,\newline   &quotcpx&quot, &quotcpax&quot, &quotcp_rx&quot, &quotcp_rax&quot, &quotpaste_in&quot, &quotconcat&quot,\newline   &quotmount&quot,\newline\newline   &quot* Settings for result writing:&quot,\newline   &quotrockridge&quot, &quotjoliet&quot, &quothfsplus&quot,&quotcompliance&quot, &quotrr_reloc_dir&quot,\newline   &quotvolid&quot, &quotvolset_id&quot, &quotpublisher&quot,\newline   &quotapplication_id&quot, &quotsystem_id&quot, &quotvolume_date&quot, &quotcopyright_file&quot,\newline   &quotabstract_file&quot, &quotbiblio_file&quot, &quotpreparer_id&quot, &quotapplication_use&quot,\newline   &quotout_charset&quot, &quotread_mkisofsrc&quot,\newline   &quotuid&quot, &quotgid&quot, &quotzisofs&quot, &quotspeed&quot, &quotstream_recording&quot, &quotdvd_obs&quot,\newline   &quotmodesty_on_drive&quot, &quotuse_immed_bit&quot,\newline   &quotstdio_sync&quot, &quotdummy&quot, &quotfs&quot, &quotclose&quot, &quotpadding&quot, &quotwrite_type&quot,\newline   &quotgrow_blindly&quot, &quotpacifier&quot, &quotscdbackup_tag&quot,\newline\newline   &quot* Bootable ISO images:&quot,\newline   &quotboot_image&quot, &quotappend_partition&quot,\newline\newline   &quot* Jigdo Template Extraction:&quot,\newline   &quotjigdo&quot,\newline\newline   &quot* Command compatibility emulations:&quot,\newline   &quotas&quot,\newline\newline   &quot* Scripting, dialog and program control features (2):&quot,\newline   &quothistory&quot, &quotstatus_history_max&quot, &quotstatus&quot,\newline\newline   &quot* Drive and media related inquiry actions (3):&quot,\newline   &quotprint_size&quot, &quottell_media_space&quot,\newline\newline   &quot* Writing the result, drive control:&quot,\newline   &quotformat&quot, &quotblank&quot, &quotclose_damaged&quot,\newline   &quotrollback&quot, &quotchanges_pending&quot, &quotcommit&quot, &quotcommit_eject&quot,\newline   &quoteject&quot,\newline\newline   &quot* Evaluation of readability and recovery:&quot,\newline   &quotcheck_media_defaults&quot, &quotcheck_media&quot, &quotcheck_md5&quot, &quotcheck_md5_r&quot,\newline\newline   &quot* Support for frontend programs via stdin and stdout (2):&quot,\newline   &quotpkt_output&quot, &quotlogfile&quot, &quotmark&quot, &quotmsg_op&quot,\newline\newline   &quot* Dialog mode control:&quot,\newline   &quotdialog&quot, &quotpage&quot, &quotuse_readline&quot, &quotreassure&quot,\newline\newline   &quot* Support for frontend programs via stdin and stdout (3):&quot,\newline   &quotlaunch_frontend&quot, &quotnamed_pipe_loop&quot,\newline\newline   &quot* Scripting, dialog and program control features (3):&quot,\newline   &quotrollback_end&quot, &quotend&quot,\newline\newline   &quot&quot\newline };\newline\newline if(flag &amp 1) {\newline   for(i= 0; commands[i][0] !=0; i++) {\newline     if(commands[i][0] == &#039*&#039)\newline       sprintf(xorriso-&gtresult_line, &quot#%s\\n&quot, commands[i] + 1);\newline     else\newline       sprintf(xorriso-&gtresult_line, &quot-%s\\n&quot, commands[i]);\newline     Xorriso_result(xorriso, 0);\newline   }\newline   ret= 1; goto ex;\newline }\newline if(argc &lt= 0)\newline   {ret= -1; goto ex;}\newline\newline Xorriso_alloc_meM(cmd_data, char, cmd_data_size);\newline ret= Xorriso_normalize_command(xorriso, argv[idx], -1,\newline                                cmd_data, cmd_data_size, &ampcmd, 0);\newline if(ret &lt 0)\newline   goto ex;\newline\newline if(cmd[0] == &#039#&#039 || cmd[0] == 0 ||\newline    strcmp(cmd, xorriso-&gtlist_delimiter) == 0) {\newline   /* Move to end: comment line , empty option , orphaned list delimiter */\newline   ret= 0x7fffffff; goto ex;\newline }\newline for(i= 0; commands[i][0] !=0; i++) {\newline   if(commands[i][0] == &#039*&#039) /* headline in command list */\newline continue;\newline   if(strcmp(commands[i], cmd) != 0)\newline continue;\newline   ret= i + 1; goto ex;\newline }\newline\newline ret= 1;\newlineex:\newline Xorriso_free_meM(cmd_data);\newline return(ret);\newline}\newline",@param flag bit0= list sorting order rather than looking for argv[idx]\newline \newline,1765960,vif.c,"vifi_t find_vif_direct(uint32_t src)\newline{\newline    vifi_t vifi;\newline    struct uvif *v;\newline    struct phaddr *p;\newline\newline    for (vifi = 0, v = uvifs; vifi &lt numvifs; ++vifi, ++v) {\newline	if (v-&gtuv_flags &amp (VIFF_DISABLED | VIFF_DOWN | VIFF_REGISTER | VIFF_TUNNEL))\newline	    continue;\newline\newline	if (src == v-&gtuv_lcl_addr)\newline	    return NO_VIF;	/* src is one of our IP addresses */\newline\newline	if (is_uv_subnet(src, v))\newline	    return vifi;\newline\newline	/* Check the extra subnets for this vif */\newline	/* TODO: don&#039t think currently pimd can handle extra subnets */\newline	for (p = v-&gtuv_addrs; p; p = p-&gtpa_next) {\newline	    if (is_pa_subnet(src, v))\newline		return vifi;\newline	}\newline\newline	/* POINTOPOINT but not VIFF_TUNNEL interface (e.g., GRE) */\newline	if ((v-&gtuv_flags &amp VIFF_POINT_TO_POINT) &amp&amp (src == v-&gtuv_rmt_addr))\newline	    return vifi;\newline    }\newline\newline    return NO_VIF;\newline}\newline","\newline If the source is directly connected to us, find the vif number for\newline the corresponding physical interface (Register and tunnels excluded).\newline Local addresses are excluded.\newline Return the vif number or NO_VIF if not found.\newline \newline",3500627,chg.c,"static int runinstructions(struct cmdserveropts *opts, const char **insts)\newline{\newline	int needreconnect = 0;\newline	if (!insts)\newline		return needreconnect;\newline\newline	assert(insts);\newline	opts-&gtredirectsockname[0] = &#039\\0&#039;\newline	const char **pinst;\newline	for (pinst = insts; *pinst; pinst++) {\newline		debugmsg(&quotinstruction: %s&quot, *pinst);\newline		if (strncmp(*pinst, &quotunlink &quot, 7) == 0) {\newline			unlink(*pinst + 7);\newline		} else if (strncmp(*pinst, &quotredirect &quot, 9) == 0) {\newline			int r = snprintf(opts-&gtredirectsockname,\newline					 sizeof(opts-&gtredirectsockname),\newline					 &quot%s&quot, *pinst + 9);\newline			if (r &lt 0 || r &gt= (int)sizeof(opts-&gtredirectsockname))\newline				abortmsg(&quotredirect path is too long (%d)&quot, r);\newline			needreconnect = 1;\newline		} else if (strncmp(*pinst, &quotexit &quot, 5) == 0) {\newline			int n = 0;\newline			if (sscanf(*pinst + 5, &quot%d&quot, &ampn) != 1)\newline				abortmsg(&quotcannot read the exit code&quot);\newline			exit(n);\newline		} else if (strcmp(*pinst, &quotreconnect&quot) == 0) {\newline			needreconnect = 1;\newline		} else {\newline			abortmsg(&quotunknown instruction: %s&quot, *pinst);\newline		}\newline	}\newline	return needreconnect;\newline}\newline","Run instructions sent from the server like unlink and set redirect path\newline Return 1 if reconnect is needed, otherwise 0 \newline",3272340,oping.c,"static int post_loop_hook (pingobj_t *ping) /* {{{ */\newline{\newline	pingobj_iter_t *iter;\newline	int failure_count = 0;\newline\newline#if USE_NCURSES\newline	endwin ();\newline#endif\newline\newline	for (iter = ping_iterator_get (ping);\newline			iter != NULL;\newline			iter = ping_iterator_next (iter))\newline	{\newline		ping_context_t *context;\newline\newline		context = ping_iterator_get_context (iter);\newline\newline		printf (&quot\\n--- %s ping statistics ---\\n&quot\newline				&quot%i packets transmitted, %i received, %.2f%% packet loss, time %.1fms\\n&quot,\newline				context-&gthost, context-&gtreq_sent, context-&gtreq_rcvd,\newline				context_get_packet_loss (context),\newline				context-&gtlatency_total);\newline\newline		{\newline			double pct_failed = 1.0 - (((double) context-&gtreq_rcvd)\newline					/ ((double) context-&gtreq_sent));\newline			if (pct_failed &gt opt_exit_status_threshold)\newline				failure_count++;\newline		}\newline\newline		if (context-&gtreq_rcvd != 0)\newline		{\newline			double min;\newline			double median;\newline			double max;\newline			double percentile;\newline\newline			min = percentile_to_latency (context, 0.0);\newline			median = percentile_to_latency (context, 50.0);\newline			max = percentile_to_latency (context, 100.0);\newline			percentile = percentile_to_latency (context, opt_percentile);\newline\newline			printf (&quotRTT[ms]: min = %.0f, median = %.0f, p(%.0f) = %.0f, max = %.0f\\n&quot,\newline					min, median, opt_percentile, percentile, max);\newline		}\newline\newline		ping_iterator_set_context (iter, NULL);\newline		context_destroy (context);\newline	}\newline\newline	return (failure_count);\newline} /* }}} int post_loop_hook */\newline","Prints statistics for each host, cleans up the contexts and returns the\newline number of hosts which failed to return more than the fraction\newline opt_exit_status_threshold of pings. \newline",3977381,mesch_core.c,"VEC	*_v_copy(const VEC *in, VEC *out, unsigned int i0)\newline{\newline	/* unsigned int	i,j; */\newline\newline	if ( in==VNULL )\newline		g_assert_not_reached();\newline	if ( in==out )\newline		return (out);\newline	if ( out==VNULL || out-&gtdim &lt in-&gtdim )\newline		out = v_resize(out,in-&gtdim);\newline\newline	MEM_COPY(&amp(in-&gtve[i0]),&amp(out-&gtve[i0]),(in-&gtdim - i0)*sizeof(Real));\newline	/* for ( i=i0; i &lt in-&gtdim; i++ )\newline		out-&gtve[i] = in-&gtve[i]; */\newline\newline	return (out);\newline}\newline",_v_copy -- copies vector into new area\newline -- out(i0:dim) &lt- in(i0:dim) \newline,4764102,sysfs.c,"int sysfs_isci_driver(const char *path)\newline{\newline	char buf[PATH_MAX];\newline	char *link;\newline	int found = 0;\newline	str_cpy(buf, path, PATH_MAX);\newline	str_cat(buf, &quot/driver&quot, PATH_MAX);\newline\newline	link = realpath(buf, NULL);\newline	if (link &amp&amp strstr(link, &quot/isci&quot))\newline		found = 1;\newline	free(link);\newline	return found;\newline}\newline",\newline This function checks if driver type is isci.\newline \newline,3491744,tableau.cpp,void Tableau::forward()\newline{\newline  if (history-&gtmovesToExecute())\newline  {\newline    history-&gtforward();\newline    history-&gtcurrent()-&gtexecute();\newline\newline    unselect();\newline    changed = true;\newline  }\newline}\newline,Go one move forward in the history \newline,6141294,list.c,"void list_destroy(struct list *list) {\newline    struct list_node *node, *next;\newline\newline    if (!list)\newline	return;\newline\newline    for (node = list-&gtfirst; node; node = next) {\newline	free(node-&gtdata);\newline	next = node-&gtnext;\newline	free(node);\newline    }\newline    free(list);\newline}\newline",frees all memory associated with the list \newline,,,,on,,on,,,,,,,on,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,abort command in progress,Open placeholder windows for all children of parent.,Restart the counters.,{},Display the list of the streamed channels,{},Local addresses are excluded.,Run instructions sent from the server like unlink and set redirect path,"Prints statistics for each host,",copies vector into new area,This function checks if driver type is isci.,Removes the the specified object,{},frees all memory associated with the list,Handle conversion,{},Bonus for a match,get function: array,transforms a matrix M into -M,Load an image from the named file.,Performs a self-test of the LTC_CAST5 block cipher,x,
3E6L1VR4XWMT055RT5PT27OGS3V6FM,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:42 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:42 PDT 2019,,,3WETL7AQWT84O9MDUTJNYBH8BDY35X,AITP2LUW8GPB,Submitted,Fri Apr 26 12:50:27 PDT 2019,Fri Apr 26 13:30:30 PDT 2019,Sun Apr 28 13:30:30 PDT 2019,,,,2403,100% (62/62),100% (62/62),0% (0/0),2585029,echo.c,"void mymain(int n, int e, int E, const char** strings, int nstrings)\newline    {\newline    int j;\newline\newline    printf(&quotoption -n = %s\\n&quot, ((n)?&quotYES&quot:&quotNO&quot));\newline    printf(&quotoption -e = %s\\n&quot, ((e)?&quotYES&quot:&quotNO&quot));\newline    printf(&quotoption -E = %s\\n&quot, ((E)?&quotYES&quot:&quotNO&quot));\newline    for (j=0; j&ltnstrings; j++)\newline        printf(&quot%s &quot, strings[j]);\newline    printf(&quot\\n&quot);\newline    }\newline",Here we only approximate the echo functionality \newline,5767222,attach.c,"static void write_firstcmd(SSL* ssl, char* cmd)\newline{\newline	char pre[10];\newline	if(!ssl) return;\newline	snprintf(pre, sizeof(pre), &quotDNSTRIG%d &quot, CONTROL_VERSION);\newline	if(SSL_write(ssl, pre, (int)strlen(pre)) &lt= 0)\newline		fatal_exit(&quotcould not SSL_write&quot);\newline	if(SSL_write(ssl, cmd, (int)strlen(cmd)) &lt= 0)\newline		fatal_exit(&quotcould not SSL_write&quot);\newline}\newline","write the first command over SSL, blocking \newline",5935704,decoder_amr_wb.cpp,OSCL_EXPORT_REF CDecoder_AMR_WB::~CDecoder_AMR_WB()\newline{\newline    st = NULL;\newline    ScratchMem = NULL;\newline\newline    if (pt_st != NULL)\newline    {\newline        OSCL_ARRAY_DELETE((uint8*)pt_st);\newline        pt_st = NULL;\newline    }\newline\newline    if (iInputBuf)\newline    {\newline        OSCL_ARRAY_DELETE(iInputBuf);\newline        iInputBuf = NULL;\newline    }\newline\newline    if (iOutputBuf)\newline    {\newline        OSCL_ARRAY_DELETE(iOutputBuf);\newline        iOutputBuf = NULL;\newline    }\newline}\newline,\newline-----------------------------------------------------------------------------\newlineCDecoder_AMR_WB\newline~CDecoder_AMR_WB\newlineEmpty decoder destructor.\newlineParameters: none\newlineReturn Values: none\newline-----------------------------------------------------------------------------\newline \newline,1491900,mesh.cpp,"void __gl_meshZapFace( GLUface *fZap )\newline{\newline  GLUhalfEdge *eStart = fZap-&gtanEdge;\newline  GLUhalfEdge *e, *eNext, *eSym;\newline  GLUface *fPrev, *fNext;\newline\newline  /* walk around face, deleting edges whose right face is also NULL */\newline  eNext = eStart-&gtLnext;\newline  do {\newline    e = eNext;\newline    eNext = e-&gtLnext;\newline\newline    e-&gtLface = NULL;\newline    if( e-&gtRface == NULL ) {\newline      /* delete the edge -- see __gl_MeshDelete above */\newline\newline      if( e-&gtOnext == e ) {\newline	KillVertex( e-&gtOrg, NULL );\newline      } else {\newline	/* Make sure that e-&gtOrg points to a valid half-edge */\newline	e-&gtOrg-&gtanEdge = e-&gtOnext;\newline	Splice( e, e-&gtOprev );\newline      }\newline      eSym = e-&gtSym;\newline      if( eSym-&gtOnext == eSym ) {\newline	KillVertex( eSym-&gtOrg, NULL );\newline      } else {\newline	/* Make sure that eSym-&gtOrg points to a valid half-edge */\newline	eSym-&gtOrg-&gtanEdge = eSym-&gtOnext;\newline	Splice( eSym, eSym-&gtOprev );\newline      }\newline      KillEdge( e );\newline    }\newline  } while( e != eStart );\newline\newline  /* delete from circular doubly-linked list */\newline  fPrev = fZap-&gtprev;\newline  fNext = fZap-&gtnext;\newline  fNext-&gtprev = fPrev;\newline  fPrev-&gtnext = fNext;\newline\newline  memFree( fZap );\newline}\newline","__gl_meshZapFace( fZap ) destroys a face and removes it from the\newline global face list. All edges of fZap will have a NULL pointer as their\newline left face. Any edges which also have a NULL pointer as their right face\newline are deleted entirely (along with any isolated vertices this produces).\newline An entire mesh can be deleted by zapping its faces, one at a time,\newline in any order. Zapped faces cannot be used in further mesh operations!\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,6010065,coords.c,"private int VisibleTraces()\newline  {\newline    register Trptr  t;\newline    register int    Ysize, n, i, busHeight, logicHeight;\newline\newline    Ysize = TracesHeight();\newline\newline    Ysize -= TRACEGAP;\newline    busHeight = MINBUSHEIGHT;\newline    logicHeight = MINSIGHEIGHT;\newline\newline    for( i = 0, n = traces.total, t = traces.first; i &lt n; i++, t = t-&gtnext )\newline      {\newline	Ysize -= ( IsVector( t ) ) ? busHeight : logicHeight;\newline	if( Ysize &lt 0 )\newline	    return( i );\newline      }\newline    return( n );\newline  }\newline",\newline Calculate the number of traces that will fit (vertically).\newline \newline,5046251,faust-poly-engine.h,"        const char* getVoiceParamAddress(int id, long voice)\newline        {\newline            return reinterpret_cast&ltMapUI*&gt(voice)-&gtgetParamAddress(id).c_str();\newline        }\newline","\newline getVoiceParamAddress(id, voice)\newline Returns the address of a parameter for a specific voice \newline in function of its &quotid&quot.\newline \newline",5663169,packet.c,"int packet_recv(struct netdev *dev, struct iovec *iov, int iov_len)\newline{\newline	struct iphdr *ip, iph;\newline	struct udphdr *udp;\newline	struct msghdr msg = {\newline		.msg_name	= NULL,\newline		.msg_namelen	= 0,\newline		.msg_iov	= iov,\newline		.msg_iovlen	= iov_len,\newline		.msg_control	= NULL,\newline		.msg_controllen = 0,\newline		.msg_flags	= 0\newline	};\newline	int ret, iphl;\newline	struct sockaddr_ll sll;\newline	socklen_t sllen = sizeof(sll);\newline\newline	sll.sll_ifindex = dev-&gtifindex;\newline	msg.msg_name = &ampsll;\newline	msg.msg_namelen = sllen;\newline\newline	ret = recvfrom(pkt_fd, &ampiph, sizeof(struct iphdr),\newline		       MSG_PEEK, (struct sockaddr *)&ampsll, &ampsllen);\newline	if (ret == -1)\newline		return -1;\newline\newline	if (iph.ihl &lt 5 || iph.version != IPVERSION)\newline		goto discard_pkt;\newline\newline	iphl = iph.ihl * 4;\newline\newline	ip = malloc(iphl + sizeof(struct udphdr));\newline	if (!ip)\newline		goto discard_pkt;\newline\newline	udp = (struct udphdr *)((char *)ip + iphl);\newline\newline	iov[0].iov_base = ip;\newline	iov[0].iov_len = iphl + sizeof(struct udphdr);\newline\newline	ret = recvmsg(pkt_fd, &ampmsg, 0);\newline	if (ret == -1)\newline		goto free_pkt;\newline\newline	dprintf(&quot&lt- bytes %d &quot, ret);\newline\newline	if (ip_checksum((uint16_t *) ip, ip-&gtihl) != 0)\newline		goto free_pkt;\newline\newline	dprintf(&quot\\n   ip src %s &quot, ntoa(ip-&gtsaddr));\newline	dprintf(&quotdst %s &quot, ntoa(ip-&gtdaddr));\newline\newline	if (ntohs(ip-&gttot_len) &gt ret || ip-&gtprotocol != IPPROTO_UDP)\newline		goto free_pkt;\newline\newline	ret -= 4 * ip-&gtihl;\newline\newline	dprintf(&quot\\n   udp src %d dst %d &quot, ntohs(udp-&gtsource),\newline		ntohs(udp-&gtdest));\newline\newline	if (udp-&gtsource != htons(cfg_remote_port) ||\newline	    udp-&gtdest != htons(cfg_local_port))\newline		goto free_pkt;\newline\newline	if (ntohs(udp-&gtlen) &gt ret)\newline		goto free_pkt;\newline\newline	ret -= sizeof(struct udphdr);\newline\newline	free(ip);\newline\newline	return ret;\newline\newlinefree_pkt:\newline	dprintf(&quotfreed\\n&quot);\newline	free(ip);\newline	return 0;\newline\newlinediscard_pkt:\newline	dprintf(&quotdiscarded\\n&quot);\newline	packet_discard(dev);\newline	return 0;\newline}\newline","\newline Receive a bootp packet. The options are listed in iov[1...iov_len].\newline iov[0] must point to the bootp packet header.\newline Returns:\newline -1 = Error, try again later\newline 0 = Discarded packet (non-DHCP/BOOTP traffic)\newline &gt0 = Size of packet\newline \newline",3626615,tables.c,"int yytbl_write16 (struct yytbl_writer *wr, flex_uint16_t v)\newline{\newline	flex_uint16_t vnet;\newline	size_t  bytes, rv;\newline\newline	vnet = htons (v);\newline	bytes = sizeof (flex_uint16_t);\newline	rv = fwrite (&ampvnet, bytes, 1, wr-&gtout);\newline	if (rv != 1)\newline		return -1;\newline	wr-&gttotal_written += bytes;\newline	return bytes;\newline}\newline",Write two bytes in network byte order.\newline @param wr the table writer\newline @param v a word in host byte order\newline @return -1 on error. number of bytes written on success.\newline \newline,2776488,usage.c,"void Licence(void)\newline{\newline    printf(\newline&quotMscgen, a message sequence chart renderer.\\n&quot\newline&quotCopyright (C) 2010 Michael C McTernan, Michael.McTernan.2001@cs.bris.ac.uk\\n&quot\newline&quot\\n&quot\newline&quotTTPCom Ltd., hereby disclaims all copyright interest in the program `mscgen&#039\\n&quot\newline&quot(which renders message sequence charts) written by Michael McTernan.\\n&quot\newline&quot\\n&quot\newline&quotRob Meades of TTPCom Ltd, 1 August 2005\\n&quot\newline&quotRob Meades, director of Software\\n&quot\newline&quot\\n&quot\newline&quotThis program is free software; you can redistribute it and/or modify\\n&quot\newline&quotit under the terms of the GNU General Public License as published by\\n&quot\newline&quotthe Free Software Foundation; either version 2 of the License, or\\n&quot\newline&quot(at your option) any later version.\\n&quot\newline&quot\\n&quot\newline&quotThis program is distributed in the hope that it will be useful,\\n&quot\newline&quotbut WITHOUT ANY WARRANTY; without even the implied warranty of\\n&quot\newline&quotMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n&quot\newline&quotGNU General Public License for more details.\\n&quot\newline&quot\\n&quot\newline&quotYou should have received a copy of the GNU General Public License\\n&quot\newline&quotalong with this program; if not, write to the Free Software\\n&quot\newline&quotFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\\n&quot);\newline}\newline",Print program licence and return.\newline \newline,2187596,bookmarks.c,"static int Bmsrv_send_modify_page_add_section(Dsh *sh)\newline{\newline   /* send modify page2 */\newline   if (a_Dpip_dsh_write_str(sh, 1, modifypage_add_section_page))\newline      return 1;\newline\newline   return 2;\newline}\newline","\newline Send the HTML for the modify page for &quotadd section&quot\newline Return code: { 0:OK, 1:Abort, 2:Close }\newline \newline",1058020,htable.c,"static void ht_add(struct htable *ht, const void *new, size_t h)\newline{\newline	size_t i;\newline	uintptr_t perfect = ht-&gtperfect_bit;\newline\newline	i = hash_bucket(ht, h);\newline\newline	while (entry_is_valid(ht-&gttable[i])) {\newline		perfect = 0;\newline		i = (i + 1) &amp ((1 &lt&lt ht-&gtbits)-1);\newline	}\newline	ht-&gttable[i] = make_hval(ht, new, get_hash_ptr_bits(ht, h)|perfect);\newline}\newline","This does not expand the hash table, that&#039s up to caller. \newline",3206172,sisusb_dac.c,"int SiSUSBMemBandWidth(ScrnInfoPtr pScrn, Bool IsForCRT2)\newline{\newline        SISUSBPtr pSiSUSB = SISUSBPTR(pScrn);\newline\newline        int          bus = pSiSUSB-&gtBusWidth;\newline        int          mclk = pSiSUSB-&gtMemClock;\newline	int          bpp = pSiSUSB-&gtCurrentLayout.bitsPerPixel;\newline	int	     max = 0;\newline	float        magic = 0.0, total;\newline#ifdef __SUNPRO_C\newline#define const\newline#endif\newline        const float  magicDED[4] = { 1.2,      1.368421, 2.263158, 1.2};\newline#ifdef __SUNPRO_C\newline#undef const\newline#endif\newline\newline        magic = magicDED[bus/64];\newline	max = 780000;\newline\newline        total = mclk * bus / bpp;\newline\newline        xf86DrvMsg(pScrn-&gtscrnIndex, X_PROBED,\newline			&quotMemory bandwidth at %d bpp is %g MHz\\n&quot, bpp, total/1000);\newline\newline	total /= magic;\newline	if(total &gt (max / 2)) total = max / 2;\newline\newline	return(int)(total);\newline}\newline",Calculate the maximum dotclock \newline,2691029,paging.c,static mfn_t paging_new_log_dirty_leaf(struct domain *d)\newline{\newline    mfn_t mfn = paging_new_log_dirty_page(d);\newline\newline    if ( mfn_valid(mfn) )\newline        clear_domain_page(mfn);\newline\newline    return mfn;\newline}\newline,Alloc and init a new leaf node \newline,5980387,cdbg_dump.c,"void cdbg_dump_operand(int indent, oprtype *opr, int opnum)\newline{\newline	triple	*rtrip;\newline	int	offset;\newline        int	len;\newline	char	*buff;\newline	char 	mid[(SIZEOF(mident_fixed) * 2) + 1];	/* Sized to hold an labels name rtn.lbl */\newline\newline	if (opr)\newline		PRINTF(&quot%s %s  [0x&quotlvaddr&quot]  Type: %s\\n&quot, cdbg_indent(indent), oprtype_names[opnum], (long unsigned int)opr,\newline		       oprtype_type_names[opr-&gtoprclass]);\newline	else\newline		PRINTF(&quot%s ** Warning ** Null opr passed as operand\\n&quot, cdbg_indent(indent));\newline	if (!opr-&gtoprclass)\newline	{\newline		FFLUSH(stdout);\newline		return;\newline	}\newline	/* We have a real oprclass, dump it&#039s info */\newline	switch(opr-&gtoprclass)\newline	{\newline		case TVAR_REF:\newline			PRINTF(&quot%s  Temporary variable index %d\\n&quot, cdbg_indent(indent), opr-&gtoprval.temp);\newline			break;\newline		case TCAD_REF:\newline		case TVAD_REF:\newline			PRINTF(&quot%s  %s reference - whatever it means: value is %d\\n&quot, cdbg_indent(indent),\newline			       ((TCAD_REF == opr-&gtoprclass) ? &quotTCAD_REF&quot : &quotTVAD_REF&quot), opr-&gtoprval.temp);\newline			break;\newline		case MVAR_REF:\newline			if (opr-&gtoprval.vref)\newline			{\newline				PRINTF(&quot%s   LS vref: 0x&quotlvaddr&quot  RS vref: 0x&quotlvaddr&quot  index: %d  varname: %s  last triple: &quot\newline				       &quot0x&quotlvaddr&quot\\n&quot,\newline				       cdbg_indent(indent),(long unsigned int)opr-&gtoprval.vref-&gtlson,\newline				       (long unsigned int)opr-&gtoprval.vref-&gtrson, opr-&gtoprval.vref-&gtmvidx,\newline				       cdbg_makstr(opr-&gtoprval.vref-&gtmvname.addr, &ampbuff, opr-&gtoprval.vref-&gtmvname.len),\newline				       (long unsigned int)opr-&gtoprval.vref-&gtlast_fetch);\newline				free(buff);	/* allocated by cdbg_makstr */\newline			}\newline			else\newline				PRINTF(&quot%s   ** Warning ** oprval.vref is NULL\\n&quot, cdbg_indent(indent));\newline			break;\newline		case TINT_REF:\newline		case TVAL_REF:\newline			offset = sa_temps_offset[opr-&gtoprclass];\newline			offset -= (sa_temps[opr-&gtoprclass] - opr-&gtoprval.temp) * sa_class_sizes[opr-&gtoprclass];\newline			PRINTF(&quot%s   temp index: %d  offset: 0x%08x\\n&quot, cdbg_indent(indent), opr-&gtoprval.temp, offset);\newline			break;\newline		case ILIT_REF:\newline			PRINTF(&quot%s   ilit value: %d [0x%08x]\\n&quot, cdbg_indent(indent), opr-&gtoprval.ilit, opr-&gtoprval.ilit);\newline			break;\newline		case MLIT_REF:\newline			if (opr-&gtoprval.mlit)\newline				PRINTF(&quot%s   lit-ref fwdptr: 0x&quotlvaddr&quot  bkwdptr: 0x&quotlvaddr&quot  rtaddr: 0x&quotlvaddr&quot\\n&quot,\newline				       cdbg_indent(indent), (long unsigned int)opr-&gtoprval.mlit-&gtque.fl,\newline				       (long unsigned int)opr-&gtoprval.mlit-&gtque.bl, opr-&gtoprval.mlit-&gtrt_addr);\newline			else\newline				PRINTF(&quot%s   ** Warning ** oprval.mlit is NULL\\n&quot, cdbg_indent(indent));\newline			cdbg_dump_mval(indent, &ampopr-&gtoprval.mlit-&gtv);\newline			break;\newline		case TJMP_REF:\newline			if (opr-&gtoprval.tref)\newline				PRINTF(&quot%s   tjmp-ref jump list ptr: 0x&quotlvaddr&quot\\n&quot, cdbg_indent(indent),\newline						(long unsigned int)&ampopr-&gtoprval.tref-&gtjmplist);\newline			else\newline				PRINTF(&quot%s   ** Warning ** oprval.tref is NULL\\n&quot, cdbg_indent(indent));\newline			break;\newline		case TRIP_REF:\newline			rtrip = opr-&gtoprval.tref;\newline			PRINTF(&quot%s   Trip reference:\\n&quot, cdbg_indent(indent));\newline			cdbg_dump_triple(rtrip, indent + 1);\newline			break;\newline		case INDR_REF:\newline			cdbg_dump_operand(indent, opr-&gtoprval.indr, opnum);\newline			break;\newline		case TSIZ_REF:\newline			if (opr-&gtoprval.tsize)\newline				PRINTF(&quot%s   triple at 0x&quotlvaddr&quot has size %d\\n&quot, cdbg_indent(indent),\newline						(long unsigned int)opr-&gtoprval.tsize-&gtct, opr-&gtoprval.tsize-&gtsize);\newline			else\newline				PRINTF(&quot%s   ** Warning ** oprval.tsize is NULL\\n&quot, cdbg_indent(indent));\newline			break;\newline		case OCNT_REF:\newline			PRINTF(&quot%s   offset from call to next triple: %d\\n&quot, cdbg_indent(indent), opr-&gtoprval.offset);\newline			break;\newline		case MLAB_REF:\newline		case MFUN_REF:\newline			if (opr-&gtoprval.lab)\newline			{\newline				len = opr-&gtoprval.lab-&gtmvname.len;\newline				memcpy(mid, opr-&gtoprval.lab-&gtmvname.addr, len);\newline				mid[len] = &#039\\0&#039;\newline				PRINTF(&quot%s   ref type: %s  mlabel name: %s\\n&quot, cdbg_indent(indent),\newline				       oprtype_type_names[opr-&gtoprclass], mid);\newline			} else\newline				PRINTF(&quot%s   ref type: %s  ** Warning ** oprval.lab is NULL\\n&quot, cdbg_indent(indent),\newline				       oprtype_type_names[opr-&gtoprclass]);\newline			break;\newline		case CDLT_REF:\newline			if (opr-&gtoprval.cdlt)\newline			{\newline				len = opr-&gtoprval.cdlt-&gtlen;\newline				memcpy(mid, opr-&gtoprval.cdlt-&gtaddr, len);\newline				mid[len] = &#039\\0&#039;\newline				PRINTF(&quot%s   cdlt-ref mstr-&gt%s&quot, cdbg_indent(indent), mid);\newline			} else\newline				PRINTF(&quot%s   ref type: %s  ** Warning ** oprval.cdlt is NULL\\n&quot, cdbg_indent(indent),\newline				       oprtype_type_names[opr-&gtoprclass]);\newline			break;\newline		case CDIDX_REF:\newline			if (opr-&gtoprval.cdidx)\newline			{\newline				len = opr-&gtoprval.cdidx-&gtlen;\newline				memcpy(mid, opr-&gtoprval.cdidx-&gtaddr, len);\newline				mid[len] = &#039\\0&#039;\newline				PRINTF(&quot%s   cdidx-ref mstr-&gt%s&quot, cdbg_indent(indent), mid);\newline			} else\newline				PRINTF(&quot%s   ref type: %s  ** Warning ** oprval.cdidx is NULL\\n&quot, cdbg_indent(indent),\newline				       oprtype_type_names[opr-&gtoprclass]);\newline			break;\newline		default:\newline			PRINTF(&quot%s   %s bogus reference\\n&quot, cdbg_indent(indent), oprtype_type_names[opr-&gtoprclass]);\newline	}\newline	FFLUSH(stdout);\newline}\newline",Routine to dump a triple operand (note possible recursion) \newline,1133375,swigutil_pl.c,"static apr_array_header_t *svn_swig_pl_to_array(SV *source,\newline                                                pl_element_converter_t cv,\newline                                                void *ctx, apr_pool_t *pool)\newline{\newline    int targlen;\newline    apr_array_header_t *temp;\newline    AV* array;\newline\newline    if (SvROK(source) &amp&amp SvTYPE(SvRV(source)) == SVt_PVAV) {\newline      array = (AV *)SvRV(source);\newline      targlen = av_len(array) + 1;\newline      temp = apr_array_make(pool, targlen, sizeof(const char *));\newline        temp-&gtnelts = targlen;\newline\newline        while (targlen--) {\newline            /* more error handling here */\newline          SV **item = av_fetch(array, targlen, 0);\newline          APR_ARRAY_IDX(temp, targlen, const char *) = cv(*item, ctx, pool);\newline        }\newline    } else if (SvOK(source)) {\newline        targlen = 1;\newline        temp = apr_array_make(pool, targlen, sizeof(const char *));\newline        temp-&gtnelts = targlen;\newline        APR_ARRAY_IDX(temp, 0, const char *) = cv(source, ctx, pool);\newline    } else {\newline        croak(&quotMust pass a single value or an array reference&quot);\newline    }\newline\newline    return temp;\newline}\newline",perl -&gt c array convertors \newline,5814143,http.c,"static char *urldecode(const char *url)\newline{\newline    size_t i, len = strlen(url);\newline    char *out = xmalloc(len+1);\newline    int pos;\newline\newline    for (i=0, pos=0; i&ltlen; i++)\newline    {\newline        if (url[i] == &#039%&#039 &amp&amp i+2 &lt len &amp&amp\newline            isxdigit(url[i+1]) &amp&amp isxdigit(url[i+2]))\newline        {\newline            /* decode %XX */\newline            #define HEX_TO_DIGIT(hex) ( \\\newline                ((hex) &gt= &#039A&#039 &amp&amp (hex) &lt= &#039F&#039) ? ((hex)-&#039A&#039+10): \\\newline                ((hex) &gt= &#039a&#039 &amp&amp (hex) &lt= &#039f&#039) ? ((hex)-&#039a&#039+10): \\\newline                ((hex)-&#0390&#039) )\newline\newline            out[pos++] = HEX_TO_DIGIT(url[i+1]) * 16 +\newline                         HEX_TO_DIGIT(url[i+2]);\newline            i += 2;\newline\newline            #undef HEX_TO_DIGIT\newline        }\newline        else\newline        {\newline            /* straight copy */\newline            out[pos++] = url[i];\newline        }\newline    }\newline    out[pos] = 0;\newline#if 0\newline    /* don&#039t really need to realloc here - it&#039s probably a performance hit */\newline    out = xrealloc(out, strlen(out)+1);  /* dealloc what we don&#039t need */\newline#endif\newline    return (out);\newline}\newline",---------------------------------------------------------------------------\newline Decode URL by converting %XX (where XX are hexadecimal digits) to the\newline character it represents. Don&#039t forget to free the return value.\newline \newline,5410698,matpow.c,"void matpow(double *x, int n, int k, double *z)\newline{\newline    if (k == 0) { /* return identity matrix */\newline	int i, j;\newline	for (i = 0; i &lt n; i++)\newline	    for (j = 0; j &lt n; j++)\newline		z[i * n + j] = (i == j) ? 1.0 : 0.0;\newline	return;\newline    }\newline    else if (k &lt 0) {\newline	error(_(&quotpower must be a positive integer; use solve() directly for negative powers&quot));\newline    }\newline    else { /* k &gt= 1 */\newline	static const char *transa = &quotN&quot;\newline	static const double one = 1.0, zero = 0.0;\newline	int nSqr = n * n;\newline	double /* temporary matrix */\newline	    *tmp  = (double *) R_alloc(nSqr, sizeof(double));\newline\newline	/* Take powers in multiples of 2 until there is only one\newline	 * product left to make. That is, if k = 5, compute (x * x),\newline	 * then ((x * x) * (x * x)) and finally ((x * x) * (x * x)) * x.\newline	 */\newline	Memcpy(z, x, (size_t) nSqr);\newline\newline	k--;\newline	while (k &gt 0) {\newline	    if (k &amp 1) {	/* z := z * x */\newline		F77_CALL(dgemm)(transa, transa, &ampn, &ampn, &ampn, &ampone,\newline				z, &ampn, x, &ampn, &ampzero, tmp, &ampn);\newline		Memcpy(z, tmp, (size_t) nSqr);\newline	    }\newline	    if(k == 1)\newline		break;\newline	    k &gt&gt= 1; /* efficient division by 2; now have k &gt= 1 */\newline\newline	    /* x := x * x */\newline	    F77_CALL(dgemm)(transa, transa, &ampn, &ampn, &ampn, &ampone,\newline			    x, &ampn, x, &ampn, &ampzero, tmp, &ampn);\newline	    Memcpy(x, tmp, (size_t) nSqr);\newline	}\newline    }\newline}\newline","Compute z := x %^% k, x an (n x n) square &quotmatrix&quot in column-order;\newline NB: x will be altered! The caller must make a copy if needed \newline",5141552,tilda.c,"static void migrate_config_files(char *old_config_path) {\newline    gchar* old_lock_dir = g_build_filename(old_config_path, &quotlocks&quot, NULL);\newline    gchar* new_lock_dir = g_build_filename(g_get_user_cache_dir (), &quottilda&quot, &quotlocks&quot, NULL);\newline    gchar* new_config_dir = g_build_filename(g_get_user_config_dir (), &quottilda&quot, NULL);\newline\newline    if(!g_file_test(new_lock_dir, G_FILE_TEST_IS_DIR)) {\newline           g_mkdir_with_parents(new_lock_dir, 0700);\newline    }\newline\newline    //we basically need to move the files from old_config_path to config and cache\newline    g_rename(old_lock_dir, new_lock_dir);\newline    //we must move the config files after we have moved the locks directory, otherwise it gets moved aswell\newline    g_rename(old_config_path, new_config_dir);\newline    g_free(old_lock_dir);\newline    g_free(new_lock_dir);\newline    g_free(new_config_dir);\newline}\newline",\newline This is to do the migration of config files from ~/.tilda to the\newline XDG_ _HOME folders\newline \newline,3571516,sfcontrol.cpp,"void SFControl::startServer(int port, string device, int baudrate)\newline{\newline    pthread_testcancel();\newline    pthread_mutex_lock(&ampsfControlInfo.lock);\newline    sfServer_t newSFServer;\newline    newSFServer.serial2tcp = new PacketBuffer();\newline    newSFServer.tcp2serial = new PacketBuffer();\newline    newSFServer.TcpServer = new TCPComm(port, *(newSFServer.tcp2serial), *(newSFServer.serial2tcp), sfControlInfo);\newline    newSFServer.SerialDevice = new SerialComm(device.c_str(), baudrate, *(newSFServer.serial2tcp), *(newSFServer.tcp2serial), sfControlInfo);\newline    newSFServer.id = ++uniqueId;\newline    servers.push_back(newSFServer);\newline    pthread_mutex_unlock(&ampsfControlInfo.lock);\newline}\newline",starts a sf-server \newline,4157072,instance.c,"static inline void set_connection_props(connection_t *connection_prop) {\newline    char a[12];//Gets the value\newline    //Obtains the connection header, writing it into the a buffer, and sets connection=true if the header is present\newline    bool connection=get_param_value(connection_prop-&gthttp_param,&quotConnection&quot, a,sizeof(a),strlen(&quotConnection&quot));\newline\newline    //Setting the connection type, using protocol version\newline    if (connection_prop-&gthttp_param[7]==&#0391&#039 &amp&amp connection_prop-&gthttp_param[5]==&#0391&#039) {//Keep alive by default (protocol 1.1)\newline        connection_prop-&gtprotocol_version=HTTP_1_1;\newline        connection_prop-&gtkeep_alive=(connection &amp&amp strncmp(a,&quotclose&quot,5)==0)?false:true;\newline    } else {//Not http1.1\newline        //Constants are set to make this line work\newline        connection_prop-&gtprotocol_version=connection_prop-&gthttp_param[7];\newline        connection_prop-&gtkeep_alive=(connection &amp&amp strncmp(a,&quotKeep&quot,4)==0)?true:false;\newline    }\newline\newline    modURL(connection_prop-&gtpage);//Operations on the url string\newline    split_get_params(connection_prop);//Splits URI into page and parameters\newline    connection_prop-&gtbasedir=get_basedir(connection_prop-&gthttp_param);\newline}\newline",\newlineSets keep_alive and protocol_version fields of connection_t\newline \newline,on,,,,,,,on,,on,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,,,,{},Print program licence and return.,"Send the HTML for the modify page for ""add section""","This does not expand the hash table, that's up to caller.",Calculate the maximum dotclock,Alloc and init a new leaf node,Routine to dump a triple operand,{},Decode URL by converting %XX,{},{},"write the first command over SSL,",starts a sf-server,Sets keep_alive and protocol_version fields of connection_t,{},"An entire mesh can be deleted by zapping its faces,",Load an image from the named file.,Calculate the number of traces that will fit (vertically).,Returns the address of a parameter,Receive a bootp packet.,Write two bytes in network byte order.,x,
3EKZL9T8Y8M2UI5YYMQWRSS344JHCN,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:50 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:50 PDT 2019,,,39OWYR0EPKRX69CQPQPMAH4Y994YFG,AITP2LUW8GPB,Submitted,Fri Apr 26 15:08:05 PDT 2019,Fri Apr 26 15:40:05 PDT 2019,Sun Apr 28 15:40:05 PDT 2019,,,,1920,100% (62/62),100% (62/62),0% (0/0),5134325,ui_utils.c,void refreshp() {\newline    pthread_mutex_lock( &amppanel_mutex );\newline    update_panels();\newline    doupdate();\newline    pthread_mutex_unlock( &amppanel_mutex );\newline}\newline,fake refresh code to use update logic for panels \newline,5282075,lj_crecord.c,"static void crec_alloc(jit_State *J, RecordFFData *rd, CTypeID id)\newline{\newline  CTState *cts = ctype_ctsG(J2G(J));\newline  CTSize sz;\newline  CTInfo info = lj_ctype_info(cts, id, &ampsz);\newline  CType *d = ctype_raw(cts, id);\newline  TRef trid;\newline  if (!sz || sz &gt 128 || (info &amp CTF_VLA) || ctype_align(info) &gt CT_MEMALIGN)\newline    lj_trace_err(J, LJ_TRERR_NYICONV);  /* NYI: large/special allocations. */\newline  trid = lj_ir_kint(J, id);\newline  /* Use special instruction to box pointer or 32/64 bit integer. */\newline  if (ctype_isptr(info) || (ctype_isinteger(info) &amp&amp (sz == 4 || sz == 8))) {\newline    TRef sp = J-&gtbase[1] ? crec_ct_tv(J, d, 0, J-&gtbase[1], &amprd-&gtargv[1]) :\newline	      ctype_isptr(info) ? lj_ir_kptr(J, NULL) :\newline	      sz == 4 ? lj_ir_kint(J, 0) :\newline	      (lj_needsplit(J), lj_ir_kint64(J, 0));\newline    J-&gtbase[0] = emitir(IRTG(IR_CNEWI, IRT_CDATA), trid, sp);\newline  } else {\newline    TRef trcd = emitir(IRTG(IR_CNEW, IRT_CDATA), trid, TREF_NIL);\newline    cTValue *fin;\newline    J-&gtbase[0] = trcd;\newline    if (J-&gtbase[1] &amp&amp !J-&gtbase[2] &amp&amp\newline	!lj_cconv_multi_init(cts, d, &amprd-&gtargv[1])) {\newline      goto single_init;\newline    } else if (ctype_isarray(d-&gtinfo)) {\newline      CType *dc = ctype_rawchild(cts, d);  /* Array element type. */\newline      CTSize ofs, esize = dc-&gtsize;\newline      TRef sp = 0;\newline      TValue tv;\newline      TValue *sval = &amptv;\newline      MSize i;\newline      tv.u64 = 0;\newline      if (!(ctype_isnum(dc-&gtinfo) || ctype_isptr(dc-&gtinfo)))\newline	lj_trace_err(J, LJ_TRERR_NYICONV);  /* NYI: init array of aggregates. */\newline      for (i = 1, ofs = 0; ofs &lt sz; ofs += esize) {\newline	TRef dp = emitir(IRT(IR_ADD, IRT_PTR), trcd,\newline			 lj_ir_kintp(J, ofs + sizeof(GCcdata)));\newline	if (J-&gtbase[i]) {\newline	  sp = J-&gtbase[i];\newline	  sval = &amprd-&gtargv[i];\newline	  i++;\newline	} else if (i != 2) {\newline	  sp = ctype_isnum(dc-&gtinfo) ? lj_ir_kint(J, 0) : TREF_NIL;\newline	}\newline	crec_ct_tv(J, dc, dp, sp, sval);\newline      }\newline    } else if (ctype_isstruct(d-&gtinfo)) {\newline      CTypeID fid = d-&gtsib;\newline      MSize i = 1;\newline      while (fid) {\newline	CType *df = ctype_get(cts, fid);\newline	fid = df-&gtsib;\newline	if (ctype_isfield(df-&gtinfo)) {\newline	  CType *dc;\newline	  TRef sp, dp;\newline	  TValue tv;\newline	  TValue *sval = &amptv;\newline	  setintV(&amptv, 0);\newline	  if (!gcref(df-&gtname)) continue;  /* Ignore unnamed fields. */\newline	  dc = ctype_rawchild(cts, df);  /* Field type. */\newline	  if (!(ctype_isnum(dc-&gtinfo) || ctype_isptr(dc-&gtinfo) ||\newline		ctype_isenum(dc-&gtinfo)))\newline	    lj_trace_err(J, LJ_TRERR_NYICONV);  /* NYI: init aggregates. */\newline	  if (J-&gtbase[i]) {\newline	    sp = J-&gtbase[i];\newline	    sval = &amprd-&gtargv[i];\newline	    i++;\newline	  } else {\newline	    sp = ctype_isptr(dc-&gtinfo) ? TREF_NIL : lj_ir_kint(J, 0);\newline	  }\newline	  dp = emitir(IRT(IR_ADD, IRT_PTR), trcd,\newline		      lj_ir_kintp(J, df-&gtsize + sizeof(GCcdata)));\newline	  crec_ct_tv(J, dc, dp, sp, sval);\newline	} else if (!ctype_isconstval(df-&gtinfo)) {\newline	  /* NYI: init bitfields and sub-structures. */\newline	  lj_trace_err(J, LJ_TRERR_NYICONV);\newline	}\newline      }\newline    } else {\newline      TRef dp;\newline    single_init:\newline      dp = emitir(IRT(IR_ADD, IRT_PTR), trcd, lj_ir_kintp(J, sizeof(GCcdata)));\newline      if (J-&gtbase[1]) {\newline	crec_ct_tv(J, d, dp, J-&gtbase[1], &amprd-&gtargv[1]);\newline      } else {\newline	TValue tv;\newline	tv.u64 = 0;\newline	crec_ct_tv(J, d, dp, lj_ir_kint(J, 0), &amptv);\newline      }\newline    }\newline    /* Handle __gc metamethod. */\newline    fin = lj_ctype_meta(cts, id, MM_gc);\newline    if (fin)\newline      crec_finalizer(J, trcd, fin);\newline  }\newline}\newline",Record cdata allocation. \newline,3702767,handler.c,"int run_handler(struct ticket_config *tk)\newline{\newline	int rv = 0;\newline	pid_t pid;\newline\newline	if (!tk_test.prog)\newline		return 0;\newline\newline	switch(pid=fork()) {\newline	case -1:\newline		log_error(&quotfork: %s&quot, strerror(errno));\newline		return RUNCMD_ERR;\newline	case 0: /* child */\newline		if (set_booth_env(tk)) {\newline			exit(1);\newline		}\newline		closefiles(); /* don&#039t leak open files */\newline		execv(tk_test.prog, tk_test.argv);\newline		tk_log_error(&quot%s: execv failed (%s)&quot, tk_test.prog, strerror(errno));\newline		exit(1);\newline	default: /* parent */\newline		tk_test.pid = pid;\newline		tk_test.progstate = EXTPROG_RUNNING;\newline		rv = RUNCMD_MORE; /* program runs */\newline	}\newline\newline	return rv;\newline}\newline","run some external program\newline return codes:\newline RUNCMD_ERR: executing program failed (or some other failure)\newline RUNCMD_MORE: program forked, results later\newline \newline",3922878,dicom_client_routines.c," int acr_connect_to_host(char *host, char *port,\newline                               FILE **fpin, FILE **fpout)\newline{\newline   struct servent *sp;\newline   struct hostent *hp;\newline   struct sockaddr_in server;\newline   int sock;\newline   int sockbuflen, oldsockbuflen;\newline   socklen_t sockoptlen;\newline\newline   /* Set default file pointers */\newline   *fpin = *fpout = NULL;\newline\newline   /* Initialize the address structure */\newline   bzero((char *) &ampserver, sizeof(server));\newline\newline   /* Get the port, either as a number or as a service name */\newline   if ((*port &gt= &#0390&#039) &amp&amp (*port &lt= &#0399&#039)) {\newline      server.sin_port = htons(atoi(port));\newline   }\newline   else if ((sp = getservbyname(port, &quottcp&quot)) != NULL) {\newline      server.sin_port = sp-&gts_port;\newline   }\newline   else {\newline      (void) fprintf(stderr, &quotService \\&quot%s\\&quot not found\\n&quot, port);\newline      return FALSE;\newline   }\newline\newline   /* Look up the host, either as a name or as an IP address */\newline   if ((*host &gt= &#0390&#039) &amp&amp (*host &lt= &#0399&#039)) {\newline      server.sin_addr.s_addr = inet_addr(host);\newline      server.sin_family = AF_INET;\newline      if (server.sin_addr.s_addr == INADDR_NONE) {\newline         (void) fprintf(stderr, &quotBadly formed IP address %s\\n&quot, host);\newline         return FALSE;\newline      }\newline   }\newline   else if ((hp = gethostbyname(host)) != NULL) {\newline      bcopy(hp-&gth_addr, (char *) &ampserver.sin_addr, hp-&gth_length);\newline      server.sin_family = hp-&gth_addrtype;\newline   }\newline   else {\newline      (void) fprintf(stderr, &quotUnknown host: %s\\n&quot, host);\newline      return FALSE;\newline   }\newline\newline   /* Open the connection */\newline   if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt 0) {\newline      perror(&quotError getting socket&quot);\newline      return FALSE;\newline   }\newline   (void) signal(SIGALRM, timeout_handler);\newline   (void) alarm(Initial_timeout_length);\newline   if (connect(sock, (struct sockaddr *) &ampserver, sizeof (server)) &lt 0) {\newline      (void) alarm(0);\newline      (void) fprintf(stderr, &quotUnable to connect to %s: &quot, host);\newline      if (Connection_timeout) {\newline         (void) fprintf(stderr, &quotconnection timed out\\n&quot);\newline      }\newline      else {\newline         perror(NULL);\newline      }\newline      return FALSE;\newline   }\newline   (void) alarm(0);\newline\newline   /* Get socket buffer size */\newline   sockbuflen = MIN_SOCK_BUFLEN;\newline   sockoptlen = sizeof(sockbuflen);\newline   if ((getsockopt(sock, SOL_SOCKET, SO_SNDBUF, \newline                   (char *) &ampsockbuflen, &ampsockoptlen) == 0) &amp&amp\newline       (sockbuflen &lt MIN_SOCK_BUFLEN) &amp&amp (sockbuflen &gt 0)) {\newline      oldsockbuflen = sockbuflen;\newline      sockbuflen = MIN_SOCK_BUFLEN;\newline      sockoptlen = sizeof(sockbuflen);\newline      while ((sockbuflen &gt oldsockbuflen) &amp&amp\newline             (setsockopt(sock, SOL_SOCKET, SO_SNDBUF, \newline                         (char *) &ampsockbuflen, sockoptlen) != 0)) {\newline         sockbuflen = (int) ((double) sockbuflen * 0.75);\newline      }\newline      if (sockbuflen &lt= oldsockbuflen) {\newline         (void) setsockopt(sock, SOL_SOCKET, SO_SNDBUF, \newline                           (char *) &ampoldsockbuflen, sockoptlen);\newline      }\newline   }\newline\newline   /* Open file handles */\newline   if ((*fpin = fdopen(sock, &quotr&quot)) == NULL) {\newline      (void) fprintf(stderr, &quotError opening socket for read\\n&quot);\newline      return FALSE;\newline   }\newline   if (((sock = dup(sock)) &lt 0) ||\newline       ((*fpout = fdopen(sock, &quotw&quot)) == NULL)) {\newline      (void) fclose(*fpin);\newline      if (sock &gt= 0) (void) close(sock);\newline      (void) fprintf(stderr, &quotError opening socket for write\\n&quot);\newline      return FALSE;\newline   }\newline\newline   /* Ignore SIGPIPES in case the output connection gets closed when\newline      we are doing output. */\newline   (void) signal(SIGPIPE, SIG_IGN);\newline\newline   return TRUE;\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : acr_connect_to_host\newline@INPUT : host - name of host to which we should connect\newlineport - string giving port number or name of service to which \newlinewe should connect\newline@OUTPUT : fpin - file handle for input\newlinefpout - file handle for output\newline@RETURNS : TRUE if successful connection is made, FALSE otherwise.\newline@DESCRIPTION: Routine to open a connection to a remote host.\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : May 9, 1997 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline",5932773,contig.c,"void initenv ( int argc, char ** argv )\newline{\newline	int copt;\newline	int inpseq, outseq;\newline	extern char * optarg;\newline	char temp[100];\newline	inpseq = outseq = repeatSolve = 0;\newline	optind = 1;\newline\newline	while ( ( copt = getopt ( argc, argv, &quotg:M:D:R&quot ) ) != EOF )\newline	{\newline		switch ( copt )\newline		{\newline			case &#039M&#039:\newline				sscanf ( optarg, &quot%s&quot, temp ); //\newline				M = atoi ( temp );\newline				continue;\newline			case &#039D&#039:\newline				sscanf ( optarg, &quot%s&quot, temp );\newline				deLowEdge = atoi ( temp ) &gt= 0 ? atoi ( temp ) : 0;\newline				continue;\newline			case &#039g&#039:\newline				inGraph = 1;\newline				sscanf ( optarg, &quot%s&quot, graphfile ); //\newline				continue;\newline			case &#039R&#039:\newline				repeatSolve = 1;\newline				continue;\newline			default:\newline\newline				if ( inGraph == 0 )       //\newline				{\newline					display_contig_usage();\newline					exit ( -1 );\newline				}\newline		}\newline	}\newline\newline	if ( inGraph == 0 )   //\newline	{\newline		display_contig_usage();\newline		exit ( -1 );\newline	}\newline}\newline",\newline Parse command line switches\newline \newline,4698816,sshfs.c,"static inline int translate_id(uint32_t *id, GHashTable *map)\newline{\newline	gpointer id_p;\newline	if (g_hash_table_lookup_extended(map, GUINT_TO_POINTER(*id), NULL, &ampid_p)) {\newline		*id = GPOINTER_TO_UINT(id_p);\newline		return 0;\newline	}\newline	switch (sshfs.nomap) {\newline	case NOMAP_ERROR: return -1;\newline	case NOMAP_IGNORE: return 0;\newline	default:\newline		fprintf(stderr, &quotinternal error\\n&quot);\newline		abort();\newline	}\newline}\newline","given a pointer to the uid/gid, and the mapping table, remap the\newline uid/gid, if necessary \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,4660028,screen.c,zword get_max_width (zword win)\newline{\newline    if (h_version == V6) {\newline\newline	if (win &gt= 8)\newline	    runtime_error (ERR_ILL_WIN);\newline\newline	return wp[win].x_size - wp[win].left - wp[win].right;\newline\newline    } else return 0xffff;\newline\newline}/* get_max_width */\newline,\newline get_max_width\newline \newline Return maximum width of a line in the given window. This is used in\newline connection with the extended output stream #3 call in V6.\newline \newline \newline,6670932,sqsh_sig.c,"int sig_save()\newline{\newline	++sg_depth;\newline\newline	DBG(sqsh_debug(DEBUG_SIG, &quotsig_save: Save depth now %d\\n&quot,\newline	    sg_depth);)\newline\newline	return sg_depth;\newline}\newline",\newline sig_save():\newline \newline Saves the current status of all of the installed signal handlers\newline for restoration following a call to sig_restore(). With this\newline all additions or removals of signal handlers made since a call\newline to sig_save() will be undone with a call to sig_restore().\newline \newline,6555177,sds.c,"sds sdscatfmt(sds s, char const *fmt, ...) {\newline    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));\newline    size_t initlen = sdslen(s);\newline    const char *f = fmt;\newline    int i;\newline    va_list ap;\newline\newline    va_start(ap,fmt);\newline    f = fmt;    /* Next format specifier byte to process. */\newline    i = initlen; /* Position of the next byte to write to dest str. */\newline    while(*f) {\newline        char next, *str;\newline        int l;\newline        long long num;\newline        unsigned long long unum;\newline\newline        /* Make sure there is always space for at least 1 char. */\newline        if (sh-&gtfree == 0) {\newline            s = sdsMakeRoomFor(s,1);\newline            sh = (void*) (s-(sizeof(struct sdshdr)));\newline        }\newline\newline        switch(*f) {\newline        case &#039%&#039:\newline            next = *(f+1);\newline            f++;\newline            switch(next) {\newline            case &#039s&#039:\newline            case &#039S&#039:\newline                str = va_arg(ap,char*);\newline                l = (next == &#039s&#039) ? strlen(str) : sdslen(str);\newline                if (sh-&gtfree &lt l) {\newline                    s = sdsMakeRoomFor(s,l);\newline                    sh = (void*) (s-(sizeof(struct sdshdr)));\newline                }\newline                memcpy(s+i,str,l);\newline                sh-&gtlen += l;\newline                sh-&gtfree -= l;\newline                i += l;\newline                break;\newline            case &#039i&#039:\newline            case &#039I&#039:\newline                if (next == &#039i&#039)\newline                    num = va_arg(ap,int);\newline                else\newline                    num = va_arg(ap,long long);\newline                {\newline                    char buf[SDS_LLSTR_SIZE];\newline                    l = sdsll2str(buf,num);\newline                    if (sh-&gtfree &lt l) {\newline                        s = sdsMakeRoomFor(s,l);\newline                        sh = (void*) (s-(sizeof(struct sdshdr)));\newline                    }\newline                    memcpy(s+i,buf,l);\newline                    sh-&gtlen += l;\newline                    sh-&gtfree -= l;\newline                    i += l;\newline                }\newline                break;\newline            case &#039u&#039:\newline            case &#039U&#039:\newline            case &#039T&#039:\newline                if (next == &#039u&#039)\newline                    unum = va_arg(ap,unsigned int);\newline                else if(next == &#039U&#039)\newline                    unum = va_arg(ap,unsigned long long);\newline                else\newline                    unum = (unsigned long long)va_arg(ap,size_t);\newline                {\newline                    char buf[SDS_LLSTR_SIZE];\newline                    l = sdsull2str(buf,unum);\newline                    if (sh-&gtfree &lt l) {\newline                        s = sdsMakeRoomFor(s,l);\newline                        sh = (void*) (s-(sizeof(struct sdshdr)));\newline                    }\newline                    memcpy(s+i,buf,l);\newline                    sh-&gtlen += l;\newline                    sh-&gtfree -= l;\newline                    i += l;\newline                }\newline                break;\newline            default: /* Handle %% and generally %&ltunknown&gt. */\newline                s[i++] = next;\newline                sh-&gtlen += 1;\newline                sh-&gtfree -= 1;\newline                break;\newline            }\newline            break;\newline        default:\newline            s[i++] = *f;\newline            sh-&gtlen += 1;\newline            sh-&gtfree -= 1;\newline            break;\newline        }\newline        f++;\newline    }\newline    va_end(ap);\newline\newline    /* Add null-term */\newline    s[i] = &#039\\0&#039;\newline    return s;\newline}\newline","This function is similar to sdscatprintf, but much faster as it does\newline not rely on sprintf() family functions implemented by the libc that\newline are often very slow. Moreover directly handling the sds string as\newline new data is concatenated provides a performance improvement.\newline \newline However this function only handles an incompatible subset of printf-alike\newline format specifiers:\newline \newline %s - C String\newline %S - SDS string\newline %i - signed int\newline %I - 64 bit signed integer (long long, int64_t)\newline %u - unsigned int\newline %U - 64 bit unsigned integer (unsigned long long, uint64_t)\newline %T - A size_t variable.\newline %% - Verbatim &quot%&quot character.\newline \newline",1427787,hdrl_imagelist_view.c,static void hdrl_image_imgview_delete(hdrl_image * view)\newline{\newline    if (view) {\newline        hdrl_image * himg = (hdrl_image*)view;\newline        cpl_mask_unwrap(cpl_image_unset_bpm(hdrl_image_get_image(himg)));\newline        cpl_image_unwrap(hdrl_image_get_image(himg));\newline        cpl_image_delete(hdrl_image_get_error(himg));\newline        hdrl_image_unwrap(himg);\newline    }\newline}\newline,destructor unwrapping data and deleting error \newline,4047577,image.c,"int associate_cache_entry(Cache_Entry *ce, int pixnum)\newline{\newline    pixmaps[pixnum] = ce-&gtimage_data;\newline    return 0;\newline}\newline","\newline This functions associates image_data in the cache entry with the specific\newline pixmap number. Currently, there is no failure condition, but there is the\newline potential that in the future, we want to more closely look at the data and\newline if it isn&#039t valid, return the failure code.\newline \newline @return 0 on success, -1 on failure.\newline \newline",5982800,exi_ch.c,"CONDITION_HANDLER(exi_ch)\newline{\newline	START_CH(TRUE);\newline	ESTABLISH(terminate_ch);\newline	exi_condition = SIGNAL;\newline	if (DUMPABLE)\newline	{\newline		PRN_ERROR;\newline		if (!SUPPRESS_DUMP)\newline			DUMP_CORE;\newline		PROCDIE(exi_condition);\newline	}\newline	REVERT;\newline	DEBUG_ONLY(ok_to_UNWIND_in_exit_handling = TRUE);\newline	UNWIND(NULL, NULL);\newline}\newline","This condition handler is currently only established by gtm_exit_handler. The latter does various types of\newline rundowns (gds_rundown, io_rundown etc.). And wants any error in one particular type of rundown to stop processing\newline that and move on to the next type of rundown. To effect that, this condition handler basically does an UNWIND to\newline return to gtm_exit_handler so it can move on to the next type of rundown.\newline \newline",6017387,avm_stl.h,"inline bool operator==(const char* s1, const string&amp s2) { return s2 == s1; }\newline",\newline without this operator attempt to compare const char with string will give quite unexpected\newline results because of implicit usage of operator const char () with the right operand\newline \newline,517669,major_gc.c,asize_t caml_round_heap_chunk_size (asize_t request)\newline{\newline  asize_t result = request;\newline  uintnat incr;\newline\newline  /* Compute the heap increment as a byte size. */\newline  if (caml_major_heap_increment &gt 1000){\newline    incr = Bsize_wsize (caml_major_heap_increment);\newline  }else{\newline    incr = caml_stat_heap_size / 100 * caml_major_heap_increment;\newline  }\newline\newline  if (result &lt incr){\newline    result = incr;\newline  }\newline  result = clip_heap_chunk_size (result);\newline\newline  if (result &lt request){\newline    caml_raise_out_of_memory ();\newline    return 0; /* not reached */\newline  }\newline  return result;\newline}\newline,"Compute the heap increment, make sure the request is at least that big,\newlinethen call clip_heap_chunk_size, then make sure the result is &gt= request.\newline \newline",279132,fastdump.c,"static rc_t single_threaded_make_lookup( fd_ctx * fd_ctx )\newline{\newline    sorter_params sp;\newline    struct raw_read_iter * iter;\newline    \newline    init_sorter_params( fd_ctx, &ampsp );\newline    rc_t rc = make_raw_read_iter( &ampfd_ctx-&gtcmn, &ampiter );\newline    if ( rc == 0 )\newline    {\newline        sp.src = iter; /* sorter takes ownership! */\newline        rc = run_sorter( &ampsp ); /* sorter.c */\newline    }\newline    return rc;\newline}\newline","--------------------------------------------------------------------------------------------\newlineproduce the lookup-table by iterating over the PRIMARY_ALIGNMENT - table:\newline-------------------------------------------------------------------------------------------- \newlinereading SEQ_SPOT_ID, SEQ_READ_ID and RAW_READ\newlineSEQ_SPOT_ID and SEQ_READ_ID is merged into a 64-bit-key\newlineRAW_READ is read as 4na-unpacked ( Schema does not provide 4na-packed for this column )\newlinethese key-pairs are temporarely stored in a KVector until a limit is reached\newlineafter that limit is reached they are writen sorted into the file-system as sub-files\newlinethis repeats until the requested row-range is exhausted ( row_range ... NULL -&gt all rows )\newlineThese sub-files are than merge-sorted into the final output-file.\newlineThis output-file is a binary data-file:\newlinecontent: [KEY][RAW_READ]\newlineKEY... 64-bit value as SEQ_SPOT_ID shifted left by 1 bit, zero-bit contains SEQ_READ_ID\newlineRAW_READ... 16-bit binary-chunk-lenght, followed by n bytes of packed 4na\newline-------------------------------------------------------------------------------------------- \newline",6420148,ircd.c,"static void _ircd_remote_user_gone(CLIENT *cl)\newline{\newline  register LINK **s;\newline  LINK *l;\newline\newline  dprint(2, &quotircd:ircd.c:_ircd_remote_user_gone: %s&quot, cl-&gtnick);\newline  /* remove it from lists but from Ircd-&gtclients */\newline  for (s = &ampcl-&gtcs-&gtc.lients; *s; s = &amp(*s)-&gtprev)\newline    if ((*s)-&gtcl == cl)\newline      break;\newline  if ((l = *s) != NULL)\newline    *s = l-&gtprev;\newline  if (l != NULL)\newline    dprint(2, &quotircd:CLIENT: removing client %s from %s: unshifted link %p prev %p&quot,\newline	   cl-&gtnick, cl-&gtcs-&gtlcnick, l, l-&gtprev);\newline  if (l == NULL) {\newline    cl-&gtpcl = NULL;\newline    cl-&gtx.rto = NULL;\newline    ERROR(&quotircd: client %s not found in client list on server %s&quot, cl-&gtnick,\newline	  cl-&gtcs-&gtlcnick);\newline  } else if (cl-&gtx.class == NULL) {\newline    cl-&gtpcl = NULL;\newline    ERROR(&quotircd: client %s from %s is not in class&quot, cl-&gtnick, cl-&gtcs-&gtlcnick);\newline  } else {\newline    _ircd_class_out(l);\newline    if (cl-&gtcs-&gtx.a.uc &gt 0)\newline    {\newline      cl-&gtcs-&gtx.a.uc--;\newline      DBG(&quotircd:updated users count on %s to %u&quot, cl-&gtcs-&gtlcnick, cl-&gtcs-&gtx.a.uc);\newline    }\newline    else\newline      ERROR(&quotircd:internal error with users count on %s&quot, cl-&gtcs-&gtlcnick);\newline  }\newline  _ircd_bt_client(cl, cl-&gtnick, NULL, cl-&gtcs-&gtlcnick); /* do bindtable */\newline  cl-&gtcs = cl;		/* abandon server */\newline  /* converts active user into phantom on hold for this second */\newline  cl-&gthold_upto = Time;\newline  cl-&gtaway[0] = &#039\\0&#039;	/* it&#039s used by nick change tracking */\newline  if (cl-&gtrfr != NULL &amp&amp cl-&gtrfr-&gtcs == cl) { /* it was a nick holder */\newline    cl-&gtpcl = cl-&gtrfr;\newline    cl-&gtrfr = NULL;\newline    dprint(2, &quotircd:CLIENT: converted holder %s (%p) into phantom, prev %p&quot,\newline	   cl-&gtnick, cl, cl-&gtpcl);\newline  }\newline  /* cl-&gtvia is already NULL for remotes */\newline  pthread_mutex_lock (&ampIrcdLock);\newline  if (l != NULL)	/* free structure */\newline    free_LINK(l);\newline  pthread_mutex_unlock (&ampIrcdLock);\newline}\newline",do the same as _ircd_peer_kill but for remote user and thread-unsafe \newline,2907314,otr-plugin.c,"int otrg_plugin_proto_supports_otr(const char *proto)\newline{\newline    /* Right now, OTR should work on all protocols, possibly\newline     * with the help of fragmentation. */\newline    return 1;\newline}\newline","Return 1 if the given protocol supports OTR, 0 otherwise. \newline",2530965,bignum.c,"int bignum_sub(const struct bignum *a, const struct bignum *b,\newline	       struct bignum *c)\newline{\newline	if (mp_sub((mp_int *) a, (mp_int *) b, (mp_int *) c) != MP_OKAY) {\newline		wpa_printf(MSG_DEBUG, &quotBIGNUM: %s failed&quot, __func__);\newline		return -1;\newline	}\newline	return 0;\newline}\newline","\newline bignum_sub - c = a - b\newline @a: Bignum from bignum_init()\newline @b: Bignum from bignum_init()\newline @c: Bignum from bignum_init(); used to store the result of a - b\newline Returns: 0 on success, -1 on failure\newline \newline",4221422,ie_imp.cpp,"IEFileType IE_Imp::fileTypeForDescription(const char * szDescription)\newline{\newline	IEFileType ieft = IEFT_Unknown;\newline\newline	if (!szDescription)\newline		return ieft;\newline	\newline	// we have to construct the loop this way because a\newline	// given filter could support more than one file type,\newline	// so we must query a mimetype match for all file types\newline	UT_uint32 nrElements = getImporterCount();\newline\newline	for (UT_uint32 k=0; k &lt nrElements; k++)\newline	{\newline		IE_ImpSniffer * pSniffer = static_cast&ltIE_ImpSniffer *&gt(IE_IMP_Sniffers.getNthItem(k));\newline\newline		const char * szDummy;\newline		const char * szDescription2 = 0;\newline\newline		if (pSniffer-&gtgetDlgLabels(&ampszDescription2,&ampszDummy,&ampieft))\newline		{\newline			if (!strcmp(szDescription,szDescription2))\newline				return ieft;\newline		}\newline		else\newline		{\newline			UT_ASSERT_HARMLESS(UT_SHOULD_NOT_HAPPEN);\newline		}\newline	}\newline\newline	return ieft;\newline}\newline",! \newlineFind the filetype for the given filetype description.\newline\\param szDescription Filetype description\newlineReturns IEFT_Unknown if no importer has this description.\newlineThis function should closely resemble IE_Exp::fileTypeForDescription()\newline \newline,1561278,ctfeexpr.c,"bool isSafePointerCast(Type *srcPointee, Type *destPointee)\newline{\newline    // It&#039s safe to cast S** to D** if it&#039s OK to cast S* to D*\newline    while (srcPointee-&gtty == Tpointer &amp&amp destPointee-&gtty == Tpointer)\newline    {\newline        srcPointee = srcPointee-&gtnextOf();\newline        destPointee = destPointee-&gtnextOf();\newline    }\newline\newline    // It&#039s OK if both are the same (modulo const)\newline    if (srcPointee-&gtconstConv(destPointee))\newline        return true;\newline\newline    // It&#039s OK if function pointers differ only in safe/pure/nothrow\newline    if (srcPointee-&gtty == Tfunction &amp&amp destPointee-&gtty == Tfunction)\newline        return srcPointee-&gtcovariant(destPointee) == 1;\newline\newline    // it&#039s OK to cast to void*\newline    if (destPointee-&gtty == Tvoid)\newline        return true;\newline\newline    // It&#039s OK to cast from V[K] to void*\newline    if (srcPointee-&gtty == Taarray &amp&amp destPointee == Type::tvoidptr)\newline        return true;\newline\newline    // It&#039s OK if they are the same size (static array of) integers, eg:\newline    //     int*     --&gt uint*\newline    //     int[5][] --&gt uint[5][]\newline    if (srcPointee-&gtty == Tsarray &amp&amp destPointee-&gtty == Tsarray)\newline    {\newline        if (srcPointee-&gtsize() != destPointee-&gtsize())\newline            return false;\newline        srcPointee = srcPointee-&gtbaseElemOf();\newline        destPointee = destPointee-&gtbaseElemOf();\newline    }\newline    return srcPointee-&gtisintegral() &amp&amp\newline           destPointee-&gtisintegral() &amp&amp\newline           srcPointee-&gtsize() == destPointee-&gtsize();\newline}\newline",Is it safe to convert from srcPointee to destPointee ?\newline srcPointee is the genuine type (never void).\newline destPointee may be void.\newline \newline,,,,,,on,,on,on,on,on,,,,,on,,,,on,,,,,,,,,,,,,,,,,,,,,,,fake refresh code to use update logic for panels,"This function is similar to sdscatprintf,",destructor unwrapping data and deleting error,This functions associates image_data,wants any error,{},"Compute the heap increment,",{},{},{},{},Record cdata allocation.,This function should closely resemble IE_Exp::fileTypeForDescription(),srcPointee is the genuine type (never void).,executing program failed (or some other failure),{},Parse command line switches,"given a pointer to the uid/gid, and the mapping table,",Load an image from the named file.,{},Saves the current status,x,
3X7837UUADY957RNCVGEH5G8LAC6JP,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:43 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:43 PDT 2019,,,3WAKVUDHUWG3A7DFX6ULJ4L4FWC7UN,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:32 PDT 2019,Fri Apr 26 13:20:21 PDT 2019,Sun Apr 28 13:20:21 PDT 2019,,,,1909,100% (62/62),100% (62/62),0% (0/0),2177756,i_general.c,"ButOut  but_dList(But *but)  {\newline  static But  **dlist = NULL;\newline  static int  dlist_len = 0, max_dlist_len = 0;\newline  But  **new_dlist;\newline  int  i;\newline  ButOut  result = 0;\newline\newline  if (but == NULL)  {\newline    if (dlist_len == 0)\newline      return(0);\newline    for (i = 0;  i &lt dlist_len;  ++i)  {\newline      result |= but_delete(dlist[i]) | BUTOUT_CAUGHT;\newline    }\newline    dlist_len = 0;\newline  } else  {\newline    if (dlist_len+1 &gt max_dlist_len)  {\newline      new_dlist = wms_malloc(sizeof(But *) * (dlist_len * 2 + 2));\newline      for (i = 0;  i &lt dlist_len;  ++i)\newline	new_dlist[i] = dlist[i];\newline      if (dlist != NULL)\newline	wms_free(dlist);\newline      dlist = new_dlist;\newline      max_dlist_len = (dlist_len * 2 + 2);\newline    }\newline    for (i = 0;  i &lt dlist_len;  ++i)\newline      if (dlist[i] == but)\newline	return(result);\newline    but_newFlags(but, 0);\newline    dlist[dlist_len++] = but;\newline    but-&gtflags |= BUT_DEAD;\newline  }\newline  return(result);\newline}\newline",If but is NULL it will execute all destroy commands built up. \newline,354400,infodlg.cpp,"void InfoDlg::closeEvent ( QCloseEvent * e ) {\newline\newline	// don&#039t close if submitting\newline	if(d-&gtbusy-&gtisActive() &amp&amp d-&gtactionType == 1) {\newline		e-&gtignore();\newline		return;\newline	}\newline\newline	if(d-&gttype == Self &amp&amp edited()) {\newline		int n = QMessageBox::information(this, tr(&quotWarning&quot), tr(&quotYou have not published your account information changes.\\nAre you sure you want to discard them?&quot), tr(&quotClose and discard&quot), tr(&quotDon&#039t close&quot));\newline		if(n != 0) {\newline			e-&gtignore();\newline			return;\newline		}\newline	}\newline\newline	// cancel active transaction (refresh only)\newline	if(d-&gtbusy-&gtisActive() &amp&amp d-&gtactionType == 0) {\newline		delete d-&gtjt;\newline		d-&gtjt = 0;\newline	}\newline\newline	e-&gtaccept();\newline}\newline",\newline Redefined so the window does not close when changes are not saved.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,3009132,hash.c,"void *aal_hash_table_lookup(aal_hash_table_t *table,\newline			    void *key)\newline{\newline	aal_hash_node_t *node;\newline\newline	node = *aal_hash_table_lookup_node(table, key);\newline	return node ? node-&gtvalue : NULL;\newline}\newline",Makes lookup for value by passed @key \newline,5211650,dict.cpp,int xbt_dict_is_empty(xbt_dict_t dict)\newline{\newline  return !dict || (xbt_dict_length(dict) == 0);\newline}\newline,\newline \\brief test if the dict is empty or not\newline \newline,6079048,backup_menu.c,"void show_dst_filesel(struct w *widgets)\newline{\newline    G_CONST_RETURN gchar *host, *path, *port, *user, *pass, *keytype, *keylen;\newline    gchar *info, *key_name_priv, *key_path_priv;\newline\newline    /* Destination is remote */\newline    if( global_backup_local_remote )\newline    {\newline	/* Show destination server selection */\newline	show_server_menu(&quotdest&quot, widgets);\newline\newline	if( GTK_IS_WINDOW(widgets-&gtbackup_menu_window) )\newline          gtk_widget_destroy(widgets-&gtbackup_menu_window);\newline          \newline        return;\newline    }\newline    \newline    /* Save source server selection */\newline    if( global_backup_remote_local )\newline    {\newline	/* Insert source server data into the treeview and upload keys */\newline	host    = gtk_entry_get_text(GTK_ENTRY(widgets-&gtremote_server_entry));\newline	path    = gtk_entry_get_text(GTK_ENTRY(widgets-&gtremote_path_entry));\newline	port    = gtk_entry_get_text(GTK_ENTRY(widgets-&gtremote_port_entry));\newline	user    = gtk_entry_get_text(GTK_ENTRY(widgets-&gtremote_user_entry));\newline	pass    = gtk_entry_get_text(GTK_ENTRY(widgets-&gtremote_password_entry));\newline	keytype = gtk_combo_box_get_active_text(GTK_COMBO_BOX(widgets-&gtkey_type_combo));\newline	keylen  = gtk_entry_get_text(GTK_ENTRY(widgets-&gtkey_length_spinbutton));\newline\newline	if( is_empty((gchar *)host)  ||  is_empty((gchar *)path)\newline	||  is_empty((gchar *)port)  ||  is_empty((gchar *)user)\newline	||  is_empty((gchar *)pass)  ||  is_empty((gchar *)keytype)\newline	||  is_empty((gchar *)keylen) )\newline	{\newline	    info = g_strdup_printf(_(&quotAll fields must be filled in correctly.\\n&quot));\newline	    show_info(info);\newline	    if( info!=NULL )\newline	      g_free(info);\newline\newline	    return;    \newline	}\newline\newline	/* Generate and setup keys if there are no keys for this host */\newline	if( ! setup_keys((char *)user, (char *)pass, (char *)host, (char *)port, (char *)keytype, (char *)keylen, widgets) )\newline	{\newline	    info = g_strdup_printf(_(&quotCould not upload public key to the remote host.\\nMake sure that the remote ssh server is started and that all settings are correct.\\n&quot));\newline	    show_info(info);\newline	    if( info!=NULL )\newline	      g_free(info);\newline\newline	    return;    \newline	}\newline\newline	key_name_priv = mk_key_name((char *)user, (char *)host, &quotpriv&quot);\newline	key_path_priv = g_strdup_printf(&quot%s/%s&quot, global_key_path, key_name_priv);\newline	g_free(key_name_priv);\newline\newline	/* Insert the backup source in the treeview row */\newline	gtk_list_store_append(GTK_LIST_STORE(widgets-&gtbackup_store), &ampiter_filesel);\newline\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 0, host, -1);\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 1, path, -1);\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 8, user, -1);\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 9, port, -1);\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 10, key_path_priv, -1);\newline\newline	/* Check the backup checkbutton in the treeview */\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 6, TRUE, -1);\newline\newline	g_free(key_path_priv);\newline\newline	/* Check the backup checkbutton in the treeview */\newline	gtk_list_store_set(widgets-&gtbackup_store, &ampiter_filesel, 6, TRUE, -1);\newline\newline	if( GTK_IS_WINDOW(widgets-&gtserver_menu_window) )\newline          gtk_widget_destroy(widgets-&gtserver_menu_window);\newline	/* Dont return */    \newline    }\newline\newline    /* Show the destination file selection */\newline    widgets-&gtdst_filesel = gtk_file_selection_new(&quotSelect destination directory or file.&quot);\newline    gtk_widget_show(widgets-&gtdst_filesel);\newline\newline    /* Connect the ok button to the file selection ok function */\newline    g_signal_connect_swapped(G_OBJECT(GTK_FILE_SELECTION(widgets-&gtdst_filesel)-&gtok_button), &quotclicked&quot,\newline                    	     G_CALLBACK(dst_filesel_ok), widgets);\newline                        	          \newline    /* Cancel button destroys the fileselection widget */\newline    g_signal_connect_swapped(G_OBJECT(GTK_FILE_SELECTION(widgets-&gtdst_filesel)-&gtcancel_button),\newline                        &quotclicked&quot, G_CALLBACK(dst_filesel_cancel), widgets);\newline}\newline",Show destination file selection \newline,3839992,optiups.c,"static inline int optireadline(void)\newline{\newline	int r;\newline	usleep(150000);\newline	r = ser_get_line(upsfd, _buf, sizeof(_buf), ENDCHAR, IGNCHARS, 0, 500000 );\newline	_buf[sizeof(_buf)-1] = 0;\newline	if ( r &gt 0 )\newline	{\newline		if ( r &lt (int)sizeof(_buf) )\newline			_buf[r] = 0;\newline		if ( _buf[0] == 0x15 )\newline		{\newline			r=-2;\newline			upsdebugx(1, &quotREAD: &ltunsupported command&gt&quot);\newline		}\newline		if ( _buf[0] == 0x06 )\newline		{\newline			upsdebugx(2, &quotREAD: &ltcommand done&gt&quot);\newline		}\newline		else\newline		{\newline			upsdebugx(2, &quotREAD: \\&quot%s\\&quot&quot, _buf );\newline		}\newline	}\newline	else\newline		upsdebugx(1, &quotREAD ERROR: %d&quot, r );\newline	return r;\newline}\newline",All serial reads of the OPTI-UPS go through here. We always expect a CR/LF terminated\newline response. Unknown/Unimplemented commands return ^U (0x15). Actions that complete\newline successfully return ^F (0x06). \newline,2236859,cache.c,"int cache_push_mapent(struct mapent *me, char *mapent)\newline{\newline	struct stack *s;\newline	char *new;\newline\newline	if (!me-&gtmapent)\newline		return CHE_FAIL;\newline\newline	if (!mapent)\newline		new = NULL;\newline	else {\newline		new = strdup(mapent);\newline		if (!new)\newline			return CHE_FAIL;\newline	}\newline\newline	s = malloc(sizeof(struct stack));\newline	if (!s) {\newline		if (new)\newline			free(new);\newline		return CHE_FAIL;\newline	}\newline	memset(s, 0, sizeof(*s));\newline\newline	s-&gtmapent = me-&gtmapent;\newline	s-&gtage = me-&gtage;\newline	me-&gtmapent = new;\newline\newline	if (me-&gtstack)\newline		s-&gtnext = me-&gtstack;\newline	me-&gtstack = s;\newline\newline	return CHE_OK;\newline}\newline",Save the cache entry mapent field onto a stack and set a new mapent \newline,5104193,nftree.c,"int RunFilter(FilterEngine_data_t *args) {\newlineuint32_t	index, offset;\newlineint	evaluate, invert;\newline\newline	index = args-&gtStartNode;\newline	evaluate = 0;\newline	invert = 0;\newline	while ( index ) {\newline		offset   = args-&gtfilter[index].offset;\newline		invert   = args-&gtfilter[index].invert;\newline		evaluate = ( args-&gtnfrecord[offset] &amp args-&gtfilter[index].mask ) == args-&gtfilter[index].value;\newline		index    = evaluate ?  args-&gtfilter[index].OnTrue : args-&gtfilter[index].OnFalse;\newline	}\newline	return invert ? !evaluate : evaluate;\newline\newline} /* End of RunFilter */\newline",fast filter engine \newline,1892992,surfaces.c,"int visu_surfaces_getPosition(VisuSurfaces *surf, int id)\newline{\newline  guint i;\newline\newline  g_return_val_if_fail(surf, -1);\newline\newline  for (i = 0; i &lt surf-&gtnsurf; i++)\newline    if (surf-&gtids[i] == id)\newline      return i;\newline\newline  g_warning(&quotUnfound surface with id %d.&quot, id);\newline  return -1;\newline}\newline","\newline visu_surfaces_getPosition:\newline @surf: the surface object ;\newline @id: the id of the surface.\newline \newline This returns for the given @id its number.\newline \newline Returns: the number of the surface or 0, if @id is invalid.\newline \newline",6515820,mate-rr-output-info.c,"void mate_rr_output_info_get_geometry (MateRROutputInfo *self, int *x, int *y, int *width, int *height)\newline{\newline    g_return_if_fail (MATE_IS_RR_OUTPUT_INFO (self));\newline\newline    if (x)\newline	*x = self-&gtpriv-&gtx;\newline    if (y)\newline	*y = self-&gtpriv-&gty;\newline    if (width)\newline	*width = self-&gtpriv-&gtwidth;\newline    if (height)\newline	*height = self-&gtpriv-&gtheight;\newline}\newline",\newline mate_rr_output_info_get_geometry:\newline @self: a #MateRROutputInfo\newline @x: (out) (allow-none):\newline @y: (out) (allow-none):\newline @width: (out) (allow-none):\newline @height: (out) (allow-none):\newline \newline,2841250,wsm.c,"static MemHandle_t nameToHandle(String_t name) {\newline  int i;\newline\newline  // first check cache\newline  if ( (wsmBuf[wsmIndex].bufName != NULL) &amp&amp\newline       (smlLibStrcmp(wsmBuf[wsmIndex].bufName, name) == 0) )\newline    return wsmBuf[wsmIndex].memH;\newline\newline  // search through buffer\newline  for ( i=0; ((i &lt MAX_WSM_BUFFERS) &amp&amp\newline        (wsmBuf[i].bufName == NULL ? 1 :\newline         smlLibStrcmp(wsmBuf[i].bufName, name) != 0)); ++i )\newline    ;\newline  if ( i &lt MAX_WSM_BUFFERS )\newline    return wsmBuf[i].memH;\newline  else {\newline    return WSM_MEMH_UNUSED;     // name not found\newline  }\newline}\newline","\newline Find memory handle corresponding to name.\newline Return WSM_MEMH_UNUSED, if name not found in wsmBuf.\newline \newline",2331928,mpdconnection.cpp,"void MPDConnection::playListChanges()\newline{\newline    DBUG &lt&lt &quotplayListChanges&quot &lt&lt lastUpdatePlayQueueVersion &lt&lt playQueueIds.size();\newline    if (0==lastUpdatePlayQueueVersion || 0==playQueueIds.size()) {\newline        playListInfo();\newline        return;\newline    }\newline\newline    QByteArray data = &quotplchangesposid &quot+quote(lastUpdatePlayQueueVersion);\newline    Response status=sendCommand(&quotstatus&quot); // We need an updated status so as to detect deletes at end of list...\newline    Response response=sendCommand(data, false);\newline    if (response.ok &amp&amp status.ok) {\newline        MPDStatusValues sv=MPDParseUtils::parseStatus(status.data);\newline        lastUpdatePlayQueueVersion=lastStatusPlayQueueVersion=sv.playlist;\newline        emitStatusUpdated(sv);\newline        QList&ltMPDParseUtils::IdPos&gt changes=MPDParseUtils::parseChanges(response.data);\newline        if (!changes.isEmpty()) {\newline            if (changes.count()&gtconstMaxPqChanges) {\newline                playListInfo();\newline                return;\newline            }\newline            bool first=true;\newline            quint32 firstPos=0;\newline            QList&ltSong&gt songs;\newline            QList&ltSong&gt newCantataStreams;\newline            QList&ltqint32&gt ids;\newline            QSet&ltqint32&gt prevIds=playQueueIds.toSet();\newline            QSet&ltqint32&gt strmIds;\newline\newline            foreach (const MPDParseUtils::IdPos &ampidp, changes) {\newline                if (first) {\newline                    first=false;\newline                    firstPos=idp.pos;\newline                    if (idp.pos!=0) {\newline                        for (quint32 i=0; i&ltidp.pos; ++i) {\newline                            Song s;\newline                            if (i&gt=(unsigned int)playQueueIds.count()) { // Just for safety...\newline                                playListInfo();\newline                                return;\newline                            }\newline                            s.id=playQueueIds.at(i);\newline                            songs.append(s);\newline                            ids.append(s.id);\newline                            if (streamIds.contains(s.id)) {\newline                                strmIds.insert(s.id);\newline                            }\newline                        }\newline                    }\newline                }\newline\newline                if (prevIds.contains(idp.id) &amp&amp !streamIds.contains(idp.id)) {\newline                    Song s;\newline                    s.id=idp.id;\newline//                     s.pos=idp.pos;\newline                    songs.append(s);\newline                } else {\newline                    // New song!\newline                    data = &quotplaylistinfo &quot;\newline                    data += quote(idp.pos);\newline                    response=sendCommand(data);\newline                    if (!response.ok) {\newline                        playListInfo();\newline                        return;\newline                    }\newline                    Song s=MPDParseUtils::parseSong(response.data, MPDParseUtils::Loc_PlayQueue);\newline                    s.id=idp.id;\newline//                     s.pos=idp.pos;\newline                    songs.append(s);\newline                    if (s.isCdda()) {\newline                        newCantataStreams.append(s);\newline                    } else if (s.isStream()) {\newline                        if (s.isCantataStream()) {\newline                            newCantataStreams.append(s);\newline                        } else {\newline                            strmIds.insert(s.id);\newline                        }\newline                    }\newline                }\newline                ids.append(idp.id);\newline            }\newline\newline            // Dont think this section is ever called, but leave here to be safe!!!\newline            // For some reason if we have 10 songs in our playlist and we move pos 2 to pos 1, MPD sends all ids from pos 1 onwards\newline            if (firstPos+changes.size()&lt=sv.playlistLength &amp&amp (sv.playlistLength&lt=(unsigned int)playQueueIds.length())) {\newline                for (quint32 i=firstPos+changes.size(); i&ltsv.playlistLength; ++i) {\newline                    Song s;\newline                    s.id=playQueueIds.at(i);\newline                    songs.append(s);\newline                    ids.append(s.id);\newline                    if (streamIds.contains(s.id)) {\newline                        strmIds.insert(s.id);\newline                    }\newline                }\newline            }\newline\newline            playQueueIds=ids;\newline            streamIds=strmIds;\newline            if (!newCantataStreams.isEmpty()) {\newline                emit cantataStreams(newCantataStreams, true);\newline            }\newline            QSet&ltqint32&gt removed=prevIds-playQueueIds.toSet();\newline            if (!removed.isEmpty()) {\newline                emit removedIds(removed);\newline            }\newline            emit playlistUpdated(songs, false);\newline            if (songs.isEmpty()) {\newline                stopVolumeFade();\newline            }\newline            return;\newline        }\newline    }\newline\newline    playListInfo();\newline}\newline","\newline Call &quotplchangesposid&quot to recieve a list of positions+ids that have been changed since the last update.\newline If we have ids in this list that we don&#039t know about, then these are new songs - so we call\newline &quotplaylistinfo &ltpos&gt&quot to get the song information.\newline \newline Any songs that are know about, will actually be sent with empty data - as the playqueue model will\newline already hold these songs.\newline \newline",5040602,lsdvd.c,"static void converttime(playback_time_t *pt, dvd_time_t *dt)\newline{\newline	double fps = frames_per_s[(dt-&gtframe_u &amp 0xc0) &gt&gt 6];\newline\newline	pt-&gtusec = pt-&gtusec + (((dt-&gtframe_u &amp 0x30) &gt&gt 3) * 5 + (dt-&gtframe_u &amp 0x0f)) * 1000.0 / fps;\newline	pt-&gtsecond = pt-&gtsecond + ((dt-&gtsecond &amp 0xf0) &gt&gt 3) * 5 + (dt-&gtsecond &amp 0x0f);\newline	pt-&gtminute = pt-&gtminute + ((dt-&gtminute &amp 0xf0) &gt&gt 3) * 5 + (dt-&gtminute &amp 0x0f);\newline	pt-&gthour = pt-&gthour + ((dt-&gthour &amp   0xf0) &gt&gt 3) * 5 + (dt-&gthour   &amp 0x0f);\newline\newline	if ( pt-&gtusec &gt= 1000 ) { pt-&gtusec -= 1000; pt-&gtsecond++; }\newline	if ( pt-&gtsecond &gt= 60 ) { pt-&gtsecond -= 60; pt-&gtminute++; }\newline	if ( pt-&gtminute &gt 59 ) { pt-&gtminute -= 60; pt-&gthour++; }\newline}\newline","\newline This is used to add up sets of times in the struct. it&#039s not elegant at all\newline but a quick way to easily add up 4 times at once. tracking the times in usec&#039s\newline constantly is easier, but without using math.h, it sucks to actually DO anything with it\newline also it has to be better to return the playback_time, not just mess with it like this\newline \newline",1480752,conn.c,const char *xmpp_conn_get_jid(const xmpp_conn_t * const conn)\newline{\newline    return conn-&gtjid;\newline}\newline,Get the JID which is or will be bound to the connection.\newline \newline @param conn a Strophe connection object\newline \newline @return a string containing the full JID or NULL if it has not been set\newline \newline @ingroup Connections\newline \newline,5745206,systask.c,"static void SysTask_monitoron(VGThread *t,Value *r,int numArgs,void **args,TaskContext *tc)\newline{\newline  EvQueue *Q = Circuit_getQueue(t-&gtt_modCtx-&gtmc_circuit);\newline  Q-&gteq_monitorOn = 1;\newline}\newline",\newline \newline $monitoron: Reenable display of $monitor reports\newline \newline Parameters:\newline t Thread in which system task is executed\newline r Optional return value \newline numArgs Number of arguments\newline args Array of argument values\newline taskContext Optional task context\newline \newline \newline,5245737,owlib.c,"GOOD_OR_BAD LibStart(void* v)\newline{\newline	/* Start configuration monitoring */\newline	Config_Monitor_Watch(v) ;\newline	\newline	/* Build device and filetype arrays (including externals) */\newline	DeviceSort();\newline\newline	Globals.zero = zero_none ;\newline#if OW_ZERO\newline	if ( OW_Load_dnssd_library() == 0 ) {\newline		Globals.zero = zero_bonjour ;\newline	}\newline#endif /* OW_ZERO */\newline\newline	/* Initialize random number generator, make sure fake devices get the same\newline	 * id each time */\newline	srand(1);\newline\newline	SetupTemperatureLimits() ;\newline	\newline	MONITOR_WLOCK ;\newline	SetupInboundConnections();\newline	MONITOR_WUNLOCK ;\newline\newline	// Signal handlers\newline	IgnoreSignals();\newline	\newline	if ( Inbound_Control.head_port == NULL ) {\newline		LEVEL_DEFAULT(&quotNo valid 1-wire buses found&quot);\newline		return gbBAD ;\newline	}\newline	return gbGOOD ;\newline}\newline",Start the owlib process -- already in background \newline,5179092,html_document.c,"static VALUE read_io( VALUE klass,\newline                      VALUE io,\newline                      VALUE url,\newline                      VALUE encoding,\newline                      VALUE options )\newline{\newline  const char * c_url    = NIL_P(url)      ? NULL : StringValueCStr(url);\newline  const char * c_enc    = NIL_P(encoding) ? NULL : StringValueCStr(encoding);\newline  VALUE error_list      = rb_ary_new();\newline  VALUE document;\newline  htmlDocPtr doc;\newline\newline  xmlResetLastError();\newline  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\newline\newline  doc = htmlReadIO(\newline      io_read_callback,\newline      io_close_callback,\newline      (void *)io,\newline      c_url,\newline      c_enc,\newline      (int)NUM2INT(options)\newline  );\newline  xmlSetStructuredErrorFunc(NULL, NULL);\newline\newline  /*\newline   * If EncodingFound has occurred in EncodingReader, make sure to do\newline   * a cleanup and propagate the error.\newline   */\newline  if (rb_respond_to(io, id_encoding_found)) {\newline    VALUE encoding_found = rb_funcall(io, id_encoding_found, 0);\newline    if (!NIL_P(encoding_found)) {\newline      xmlFreeDoc(doc);\newline      rb_exc_raise(encoding_found);\newline    }\newline  }\newline\newline  if(doc == NULL) {\newline    xmlErrorPtr error;\newline\newline    xmlFreeDoc(doc);\newline\newline    error = xmlGetLastError();\newline    if(error)\newline      rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));\newline    else\newline      rb_raise(rb_eRuntimeError, &quotCould not parse document&quot);\newline\newline    return Qnil;\newline  }\newline\newline  document = Nokogiri_wrap_xml_document(klass, doc);\newline  rb_iv_set(document, &quot@errors&quot, error_list);\newline  return document;\newline}\newline","\newline call-seq:\newline read_io(io, url, encoding, options)\newline \newline Read the HTML document from +io+ with given +url+, +encoding+,\newline and +options+. See Nokogiri::HTML.parse\newline \newline",4764194,ledmon.c,"static void _ledmon_wait(int seconds)\newline{\newline	fd_set rd;\newline	int fd;\newline	struct timespec timeout;\newline	sigset_t sigset;\newline\newline	sigprocmask(SIG_UNBLOCK, NULL, &ampsigset);\newline	sigdelset(&ampsigset, SIGTERM);\newline	timeout.tv_nsec = 0;\newline	timeout.tv_sec = seconds;\newline	FD_ZERO(&amprd);\newline	fd = open(&quot/proc/mdstat&quot, O_RDONLY);\newline	if (fd)\newline		FD_SET(fd, &amprd);\newline	pselect(fd + 1, NULL, NULL, &amprd, &amptimeout, &ampsigset);\newline	if (fd &gt= 0)\newline		close(fd);\newline}\newline",\newline @brief Puts the calling process into sleep.\newline \newline This is internal function of monitor service. The function puts the calling\newline process into a sleep for the given amount of time (expressed in seconds). The\newline function will give control back to the process as soon as time elapses or\newline SIGTERM occurs.\newline \newline @param[in] seconds - the time interval given in seconds.\newline \newline @return The function does not return a value.\newline \newline,4065198,parse.c,"int search_illegal(char *str)\newline{\newline    int i;\newline\newline    if (str != NULL) {\newline	for (i = 0; i &lt strlen(str); i++)\newline	    if (str[i] == &#039@&#039)\newline		return U_FORWARD;\newline	    else if (!isalpha(str[i]) &amp&amp !isdigit(str[i]) &amp&amp (str[i] != &#039.&#039) &amp&amp\newline		(str[i] != &#039_&#039) &amp&amp (str[i] != &#039-&#039) &amp&amp (str[i] != &#039,&#039) &amp&amp\newline		(str[i] != &#039?&#039) &amp&amp (str[i] != &#039*&#039) &amp&amp (str[i] != &#039/&#039))\newline		return U_ILLEGAL;\newline    }\newline    return 0;\newline}\newline","\newline SEARCH_ILLEGAL\newline \newline This searches for any illegal characters in a user&#039s name. If there are\newline any found, it returns a U_ILLEGAL, otherwise it returns a 0.\newline \newline",3676390,send_packet_stdin.c,"SOCKET get_port(uint32_t ip, struct sockaddr_in *dns) {\newline        SOCKET sock;\newline        int len_inet;\newline\newline        /* Bind to port 53 */\newline        sock = socket(AF_INET,SOCK_STREAM,0);\newline        if(sock == -1) {\newline                perror(&quotsocket error&quot);\newline                exit(0);\newline        }\newline        memset(dns,0,sizeof(struct sockaddr_in));\newline        dns-&gtsin_family = AF_INET;\newline        dns-&gtsin_port = htons(53);\newline        dns-&gtsin_addr.s_addr = ip;\newline        if(dns-&gtsin_addr.s_addr == INADDR_NONE) {\newline                perror(&quotProblem with s_addr&quot);\newline                exit(0);\newline        }\newline        len_inet = sizeof(struct sockaddr_in);\newline        if(connect(sock,(struct sockaddr *)dns,len_inet) == -1) {\newline                perror(&quotconnect error&quot);\newline                exit(0);\newline        }\newline\newline        /* Linux kernel bug */\newline        /* fcntl(sock, F_SETFL, O_NONBLOCK); */\newline\newline        return sock;\newline}\newline",Get port: Connect to a remote machine via TCP \newline,on,,on,,on,,,,,on,,on,,,,,,,on,on,,,,,,,,,,,,,,,,,,,,,,,{},This returns for the given @id its number.,{},Find memory handle corresponding to name.,{},This is used to add up sets of times in the struct.,Get the JID which is or will be bound to the connection.,Reenable display of $monitor reports,Start the owlib process,{},"The function puts the calling
process into a sleep",{},This searches for any illegal characters in a user's name.,Connect to a remote machine via TCP,Load an image from the named file.,Makes lookup for value by passed,test if the dict is empty or not,Show destination file selection,{},{},fast filter engine,x,
335HHSX8CD5CZABCYIL7BYALP4VDHJ,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:37 PDT 2019,2,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:37 PDT 2019,,,3OXV7EAXLEQ07DMRZCTSQHV879R630,AITP2LUW8GPB,Submitted,Fri Apr 26 13:35:46 PDT 2019,Fri Apr 26 13:43:16 PDT 2019,Sun Apr 28 13:43:16 PDT 2019,,,,450,100% (62/62),100% (62/62),0% (0/0),2236833,parse_subs.c,"int check_colon(const char *str)\newline{\newline	char *ptr = (char *) str;\newline\newline	/* Colon escape */\newline	if (!strncmp(ptr, &quot:/&quot, 2))\newline		return 1;\newline\newline	while (*ptr &amp&amp strncmp(ptr, &quot:/&quot, 2))\newline		ptr++;\newline\newline	if (!*ptr)\newline		return 0;\newline\newline	return 1;\newline}\newline",\newline Check a string to see if a colon appears before the next &#039/&#039.\newline \newline,1058700,patternparser.c,"int patternParse(void)\newline  {\newline    int                 error = 0,\newline                        i;\newline\newline    TRACE(99, &quotpatternParse()&quot, NULL);\newline\newline    patterncount = listCount(runtime -&gt searchpatterns);\newline    patterndata = memAlloc(__FILE__, __LINE__,\newline        sizeof(SEARCHPATTERN*) * patterncount);\newline    resultdata = memAlloc(__FILE__, __LINE__,\newline        sizeof(SEARCHPATTERN*) * patterncount);\newline\newline    for (i = 0; i &lt patterncount; i++)\newline      {\newline        patterndata[i] = memAlloc(__FILE__, __LINE__,\newline            sizeof(SEARCHPATTERN));\newline        patterndata[i] -&gt type = PATTERN_UNDEF;\newline        patterndata[i] -&gt templateid = -1;\newline        patterndata[i] -&gt string = NULL;\newline        patterndata[i] -&gt next = NULL;\newline\newline        if (patternCreate(runtime -&gt searchpatterns[i], patterndata[i]))\newline          { error = 1; }\newline\newline        resultdata[i] = memAlloc(__FILE__, __LINE__,\newline            sizeof(SEARCHPATTERN));\newline        resultdata[i] -&gt type = PATTERN_UNDEF;\newline        resultdata[i] -&gt templateid = -1;\newline        resultdata[i] -&gt string = NULL;\newline        resultdata[i] -&gt next = NULL;\newline\newline        if (patternCreate(runtime -&gt resultpatterns[i], resultdata[i]))\newline          { error = 1; }\newline      }\newline\newline    return error;\newline  }\newline","#############################################################################\newline \newline Description parse the defined patterns for later use\newline Author Harry Brueckner\newline Date 2005-04-06\newline Arguments void\newline Return 0 if everything is ok, otherwise 1\newline \newline",3406030,bluetooth_packet.c,"int btbb_header_present(const btbb_packet* pkt)\newline{\newline	/* skip to last bit of sync word */\newline	const char *stream = pkt-&gtsymbols + 63;\newline	int be = 0; /* bit errors */\newline	char msb;   /* most significant (last) bit of sync word */\newline	int a, b, c;\newline\newline	/* check that we have enough symbols */\newline	if (pkt-&gtlength &lt 122)\newline		return 0;\newline\newline	/* check that the AC trailer is correct */\newline	msb = stream[0];\newline	be += stream[1] ^ !msb;\newline	be += stream[2] ^ msb;\newline	be += stream[3] ^ !msb;\newline	be += stream[4] ^ msb;\newline\newline	/*\newline	 * Each bit of the 18 bit header is repeated three times.  Without\newline	 * checking the correctness of any particular bit, just count the\newline	 * number of times three symbols in a row don&#039t all agree.\newline	 */\newline	stream += 5;\newline	for (a = 0; a &lt 54; a += 3) {\newline		b = a + 1;\newline		c = a + 2;\newline		be += ((stream[a] ^ stream[b]) |\newline			(stream[b] ^ stream[c]) | (stream[c] ^ stream[a]));\newline	}\newline\newline	/*\newline	 * Few bit errors indicates presence of a header.  Many bit errors\newline	 * indicates no header is present (i.e. it is an ID packet).\newline	 */\newline	return (be &lt ID_THRESHOLD);\newline}\newline",check to see if the packet has a header \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1765756,route.c,"static void process_cache_miss(struct igmpmsg *igmpctl)\newline{\newline    uint32_t source, mfc_source;\newline    uint32_t group;\newline    uint32_t rp_addr;\newline    vifi_t iif;\newline    mrtentry_t *mrt;\newline    mrtentry_t *mrp;\newline\newline    /* When there is a cache miss, we check only the header of the packet\newline     * (and only it should be sent up by the kernel. */\newline\newline    group  = igmpctl-&gtim_dst.s_addr;\newline    source = mfc_source = igmpctl-&gtim_src.s_addr;\newline    iif    = igmpctl-&gtim_vif;\newline\newline    IF_DEBUG(DEBUG_MRT)\newline	logit(LOG_DEBUG, 0, &quotCache miss, src %s, dst %s, iif %d&quot,\newline	      inet_fmt(source, s1, sizeof(s1)), inet_fmt(group, s2, sizeof(s2)), iif);\newline\newline    /* TODO: XXX: check whether the kernel generates cache miss for the LAN scoped addresses */\newline    if (ntohl(group) &lt= INADDR_MAX_LOCAL_GROUP)\newline	return; /* Don&#039t create routing entries for the LAN scoped addresses */\newline\newline    /* TODO: check if correct in case the source is one of my addresses */\newline    /* If I am the DR for this source, create (S,G) and add the register_vif\newline     * to the oifs. */\newline\newline    if ((uvifs[iif].uv_flags &amp VIFF_DR) &amp&amp (find_vif_direct_local(source) == iif)) {\newline	mrt = find_route(source, group, MRTF_SG, CREATE);\newline	if (!mrt)\newline	    return;\newline\newline	mrt-&gtflags &amp= ~MRTF_NEW;\newline	/* set reg_vif_num as outgoing interface ONLY if I am not the RP */\newline	if (mrt-&gtgroup-&gtrpaddr != my_cand_rp_address)\newline	    VIFM_SET(reg_vif_num, mrt-&gtjoined_oifs);\newline	change_interfaces(mrt,\newline			  mrt-&gtincoming,\newline			  mrt-&gtjoined_oifs,\newline			  mrt-&gtpruned_oifs,\newline			  mrt-&gtleaves,\newline			  mrt-&gtasserted_oifs, 0);\newline    } else {\newline	mrt = find_route(source, group, MRTF_SG | MRTF_WC | MRTF_PMBR, DONT_CREATE);\newline	switch_shortest_path(source, group);\newline	if (!mrt)\newline	    return;\newline    }\newline\newline    /* TODO: if there are too many cache miss for the same (S,G),\newline     * install negative cache entry in the kernel (oif==NULL) to prevent\newline     * too many upcalls. */\newline\newline    if (mrt-&gtincoming == iif) {\newline	if (!VIFM_ISEMPTY(mrt-&gtoifs)) {\newline	    if (mrt-&gtflags &amp MRTF_SG) {\newline		/* TODO: check that the RPbit is not set? */\newline		/* TODO: XXX: TIMER implem. dependency! */\newline		if (mrt-&gttimer &lt PIM_DATA_TIMEOUT)\newline		    SET_TIMER(mrt-&gttimer, PIM_DATA_TIMEOUT);\newline\newline		if (!(mrt-&gtflags &amp MRTF_SPT)) {\newline		    mrp = mrt-&gtgroup-&gtgrp_route;\newline		    if (!mrp)\newline			mrp = mrt-&gtgroup-&gtactive_rp_grp-&gtrp-&gtrpentry-&gtmrtlink;\newline\newline		    if (mrp) {\newline			/* Check if the (S,G) iif is different from\newline			 * the (*,G) or (*,*,RP) iif */\newline			if ((mrt-&gtincoming != mrp-&gtincoming) ||\newline			    (mrt-&gtupstream != mrp-&gtupstream)) {\newline			    mrt-&gtflags |= MRTF_SPT;\newline			    mrt-&gtflags &amp= ~MRTF_RP;\newline			}\newline		    }\newline		}\newline	    }\newline\newline	    if (mrt-&gtflags &amp MRTF_PMBR)\newline		rp_addr = mrt-&gtsource-&gtaddress;\newline	    else\newline		rp_addr = mrt-&gtgroup-&gtrpaddr;\newline\newline	    mfc_source = source;\newline#ifdef KERNEL_MFC_WC_G\newline	    if (mrt-&gtflags &amp (MRTF_WC | MRTF_PMBR))\newline		if (!(mrt-&gtflags &amp MRTF_MFC_CLONE_SG))\newline		    mfc_source = INADDR_ANY_N;\newline#endif /* KERNEL_MFC_WC_G */\newline\newline	    add_kernel_cache(mrt, mfc_source, group, MFC_MOVE_FORCE);\newline\newline#ifdef SCOPED_ACL\newline	    APPLY_SCOPE(group, mrt);\newline#endif\newline	    k_chg_mfc(igmp_socket, mfc_source, group, iif, mrt-&gtoifs, rp_addr);\newline\newline	    /* No need for RSRR message, because nothing has changed. */\newline	}\newline\newline	return;			/* iif match */\newline    }\newline\newline    /* The iif doesn&#039t match */\newline    if (mrt-&gtflags &amp MRTF_SG) {\newline	/* Arrived on wrong interface */\newline	if (mrt-&gtflags &amp MRTF_SPT)\newline	    return;\newline\newline	mrp = mrt-&gtgroup-&gtgrp_route;\newline	if (!mrp)\newline	    mrp = mrt-&gtgroup-&gtactive_rp_grp-&gtrp-&gtrpentry-&gtmrtlink;\newline\newline	if (mrp) {\newline	    /* Forward on (*,G) or (*,*,RP) */\newline	    if (mrp-&gtincoming == iif) {\newline#ifdef KERNEL_MFC_WC_G\newline		if (!(mrp-&gtflags &amp MRTF_MFC_CLONE_SG))\newline		    mfc_source = INADDR_ANY_N;\newline#endif /* KERNEL_MFC_WC_G */\newline\newline		add_kernel_cache(mrp, mfc_source, group, 0);\newline\newline#ifdef SCOPED_ACL\newline		/* marian: not sure if we reach here with our scoped traffic? */\newline		APPLY_SCOPE(group, mrt);\newline#endif\newline		k_chg_mfc(igmp_socket, mfc_source, group, iif,\newline			  mrp-&gtoifs, mrt-&gtgroup-&gtrpaddr);\newline#ifdef RSRR\newline		rsrr_cache_send(mrp, RSRR_NOTIFICATION_OK);\newline#endif /* RSRR */\newline	    }\newline	}\newline    }\newline}\newline","\newline TODO: when cache miss, check the iif, because probably ASSERTS\newline shoult take place\newline \newline",5246219,ow_usb_cycle.c,"GOOD_OR_BAD DS9490_root_dir( struct dirblob * db, struct connection_in * in )\newline{\newline	ASCII path[PATH_MAX] ;\newline	struct parsedname pn_root ;\newline\newline	UCLIBCLOCK;\newline		/* Force this adapter with bus.n path */\newline		snprintf(path, PATH_MAX, &quot/uncached/bus.%d&quot, in-&gtindex);\newline	UCLIBCUNLOCK;\newline\newline	if ( FS_ParsedName(path, &amppn_root) != 0 ) {\newline		LEVEL_DATA(&quotCannot get root directory on [%s] Parsing %s error.&quot, SAFESTRING(DEVICENAME(in)), path);\newline		return gbBAD ;\newline	}\newline	DirblobInit( db ) ;\newline	/* First time pretend there are devices */\newline	pn_root.selected_connection-&gtchanged_bus_settings |= CHANGED_USB_SPEED ;	// Trigger needing new configuration\newline	pn_root.selected_connection-&gtoverdrive = 0 ;	// not overdrive at start\newline	pn_root.selected_connection-&gtflex = Globals.usb_flextime ;\newline	\newline	SetReconnect(&amppn_root) ;\newline	FS_dir( DS9490_dir_callback, db, &amppn_root ) ;\newline	LEVEL_DEBUG(&quotFinished FS_dir&quot);\newline	FS_ParsedName_destroy(&amppn_root) ;\newline\newline	return gbGOOD ;\newline	// Dirblob must be cleared by recipient.\newline}\newline",Only error is if parsename fails \newline,2575208,ldif.c,"static void ldif_print_record( Ldif_ParsedRec *rec, FILE *stream ) {\newline	GSList *list;\newline\newline	fprintf( stream, &quotLDIF Parsed Record:\\n&quot );\newline	fprintf( stream, &quotcommon name:&quot );\newline	mgu_print_list( rec-&gtlistCName, stream );\newline	if( ! rec-&gtlistCName ) fprintf( stream, &quot\\n&quot );\newline	fprintf( stream, &quotfirst name:&quot );\newline	mgu_print_list( rec-&gtlistFName, stream );\newline	if( ! rec-&gtlistFName ) fprintf( stream, &quot\\n&quot );\newline	fprintf( stream, &quotlast name:&quot );\newline	mgu_print_list( rec-&gtlistLName, stream );\newline	if( ! rec-&gtlistLName ) fprintf( stream, &quot\\n&quot );\newline	fprintf( stream, &quotnick name:&quot );\newline	mgu_print_list( rec-&gtlistNName, stream );\newline	if( ! rec-&gtlistNName ) fprintf( stream, &quot\\n&quot );\newline	fprintf( stream, &quotaddress:&quot );\newline	mgu_print_list( rec-&gtlistAddress, stream );\newline	if( ! rec-&gtlistAddress ) fprintf( stream, &quot\\n&quot );\newline	fprintf( stream, &quotid:&quot );\newline	mgu_print_list( rec-&gtlistID, stream );\newline	if( ! rec-&gtlistID ) fprintf( stream, &quot\\n&quot );\newline\newline	list = rec-&gtuserAttr;\newline	while( list ) {\newline		Ldif_UserAttr *attr = list-&gtdata;\newline		fprintf( stream, &quotn/v:\\t%s:\\t:%s:\\n&quot, attr-&gtname, attr-&gtvalue );\newline		list = g_slist_next( list );\newline	}\newline	list = NULL;\newline}\newline",\newline Print parsed data.\newline \newline,3491738,tableau.cpp,int Tableau::autoMoveLeft(int p)\newline{\newline  int i = -1;\newline  if (!piles[p]-&gtempty())\newline  {\newline    if (selected != piles[p])\newline      select(p);\newline    for (i = p - 1; i &gt= 0; --i)\newline      if (piles[i]-&gtempty() || selected-&gtselectionMatchesTo(piles[i]))\newline        break;\newline    if (i &gt= 0)\newline      move(i);\newline    changed = true;\newline  }\newline  return i;\newline}\newline,"Search move from p-th pile to the next left pile, return destination \newline",384813,ib_cmrc.c,"static void ib_cmrc_changed ( struct ib_device *ibdev __unused,\newline			      struct ib_queue_pair *qp,\newline			      struct ib_connection *conn __unused, int rc_cm,\newline			      void *private_data, size_t private_data_len ) {\newline	struct ib_cmrc_connection *cmrc = ib_qp_get_ownerdata ( qp );\newline	int rc_xfer;\newline\newline	/* Record connection status */\newline	if ( rc_cm == 0 ) {\newline		DBGC ( cmrc, &quotCMRC %p connected\\n&quot, cmrc );\newline		cmrc-&gtconnected = 1;\newline	} else {\newline		DBGC ( cmrc, &quotCMRC %p disconnected: %s\\n&quot,\newline		       cmrc, strerror ( rc_cm ) );\newline		cmrc-&gtconnected = 0;\newline	}\newline\newline	/* Pass up any private data */\newline	DBGC2 ( cmrc, &quotCMRC %p received private data:\\n&quot, cmrc );\newline	DBGC2_HDA ( cmrc, 0, private_data, private_data_len );\newline	if ( private_data &amp&amp\newline	     ( rc_xfer = xfer_deliver_raw ( &ampcmrc-&gtxfer, private_data,\newline					    private_data_len ) ) != 0 ) {\newline		DBGC ( cmrc, &quotCMRC %p could not deliver private data: %s\\n&quot,\newline		       cmrc, strerror ( rc_xfer ) );\newline		ib_cmrc_close ( cmrc, rc_xfer );\newline		return;\newline	}\newline\newline	/* If we are disconnected, close the upper connection */\newline	if ( rc_cm != 0 ) {\newline		ib_cmrc_close ( cmrc, rc_cm );\newline		return;\newline	}\newline}\newline","\newline Handle change of CMRC connection status\newline \newline @v ibdev Infiniband device\newline @v qp Queue pair\newline @v conn Connection\newline @v rc_cm Connection status code\newline @v private_data Private data, if available\newline @v private_data_len Length of private data\newline \newline",2967014,talloc.c,static inline void *tc_next_chunk(struct talloc_chunk *tc)\newline{\newline	return (char *)tc + TC_ALIGN16(TC_HDR_SIZE + tc-&gtsize);\newline}\newline,"If tc is inside a pool, this gives the next neighbour. \newline",6567459,variables.c,"void prep_init_parm(char rqv[])\newline{\newline    int i;\newline    char *p;\newline\newline    for(p=strstr(rqv,&quot&amp+&quot); p!=NULL; p=strstr(++p,&quot&amp+&quot))\newline      ovlstrcpy(p+1,p+2);\newline    for(i=0;i&ltRO_NAME_NO;i++) elim_parm(rqv,ro_name[i]);\newline    if(strlen(rqv)&gt=MAX_LINELEN) rqv[0]=0;\newline    while(rqv[0]==&#039&amp&#039) ovlstrcpy(rqv,rqv+1);\newline    while(rqv[0]!=0 &amp&amp rqv[strlen(rqv)-1]==&#039&amp&#039) rqv[strlen(rqv)-1]=0;\newline}\newline",eliminate technical definitions form parameter string. \newline,507939,blosc.c,"void blosc_cbuffer_versions(const void *cbuffer, int *version,\newline                            int *versionlz)\newline{\newline  uint8_t *_src = (uint8_t *)(cbuffer);  /* current pos for source buffer */\newline\newline  /* Read the version info */\newline  *version = (int)_src[0];         /* blosc format version */\newline  *versionlz = (int)_src[1];       /* Lempel-Ziv compressor format version */\newline}\newline",Return version information from a compressed buffer. \newline,1091414,util.c,"char *encode_hex_own_buf(const unsigned char *in, long len,\newline				unsigned char terminator, char *buf)\newline{\newline	long i, j;\newline	char c;\newline\newline	if (len &lt 0) {\newline		i = 0;\newline\newline		while (in[i] != terminator)\newline			i++;\newline\newline		len = i;\newline	}\newline\newline	for (i = 0, j = 0; i &lt len; i++, j++) {\newline		c = (in[i] &gt&gt 4) &amp 0xf;\newline\newline		if (c &lt= 9)\newline			buf[j] = &#0390&#039 + c;\newline		else\newline			buf[j] = &#039A&#039 + c - 10;\newline\newline		j += 1;\newline\newline		c = (in[i]) &amp 0xf;\newline\newline		if (c &lt= 9)\newline			buf[j] = &#0390&#039 + c;\newline		else\newline			buf[j] = &#039A&#039 + c - 10;\newline	}\newline\newline	buf[j] = &#039\\0&#039;\newline\newline	return buf;\newline}\newline","!\newline Encodes the data using hexadecimal characters. len can be negative,\newline in that case the terminator is used to find the last character. This is\newline useful for handling GSM-encoded strings which allow ASCII NULL character\newline in the stream.\newline \newline",4318835,opts_p_z.c,"int Xorriso_option_stream_recording(struct XorrisO *xorriso, char *mode,\newline                                    int flag)\newline{\newline double num;\newline\newline if(strcmp(mode,&quoton&quot)==0 || mode[0]==0)\newline   xorriso-&gtdo_stream_recording= 32;\newline else if(strcmp(mode,&quotfull&quot)==0)\newline   xorriso-&gtdo_stream_recording= 1;\newline else if(strcmp(mode,&quotdata&quot)==0)\newline   xorriso-&gtdo_stream_recording= 2;\newline else if(mode[0] &gt= &#0390&#039 &amp&amp mode[0] &lt= &#0399&#039) {\newline   num= Scanf_io_size(mode, 0);\newline   num/= 2048.0;\newline   if(num &gt= 16 &amp&amp num &lt= 0x7FFFFFFF)\newline     xorriso-&gtdo_stream_recording= num;\newline   else\newline     xorriso-&gtdo_stream_recording= 0;\newline } else\newline   xorriso-&gtdo_stream_recording= 0;\newline return(1);\newline}\newline",Option -stream_recording \newline,6109003,playlistmodel.cpp,"bool PlaylistModel::removeRows(int position, int rows, const QModelIndex &amp /*parent*/) {\newline    beginRemoveRows(QModelIndex(), position, position+rows-1);\newline    for (int row = 0; row &lt rows; ++row) {\newline        videos.removeAt(position);\newline    }\newline    endRemoveRows();\newline    return true;\newline}\newline",\newline This function does not free memory\newline \newline,5143220,gateway_default_handler.c,"static void gw_default_lookup_gateway(bool ipv4, bool ipv6) {\newline  if (ipv4) {\newline    /* get a new IPv4 gateway if we use OLSRv4 or NIIT */\newline    gw_def_choose_new_ipv4_gw = (olsr_cnf-&gtip_version == AF_INET) || olsr_cnf-&gtuse_niit;\newline  }\newline  if (ipv6) {\newline    /* get a new IPv6 gateway if we use OLSRv6 */\newline    gw_def_choose_new_ipv6_gw = olsr_cnf-&gtip_version == AF_INET6;\newline  }\newline\newline  if (gw_def_choose_new_ipv4_gw || gw_def_choose_new_ipv6_gw) {\newline    gw_default_choose_gateway();\newline  }\newline}\newline",\newline Lookup a new gateway\newline \newline @param ipv4 lookup new v4 gateway\newline @param ipv6 lookup new v6 gateway\newline \newline,1058096,main-ban.c,"int remove_ip_from_ban_list(main_server_st *s, const uint8_t *ip, unsigned size)\newline{\newline	struct htable *db = s-&gtban_db;\newline	struct ban_entry_st *e;\newline	ban_entry_st t;\newline	char txt_ip[MAX_IP_STR];\newline\newline	if (db == NULL || ip == NULL || size == 0)\newline		return 0;\newline\newline	if (size == 4 || size == 16) {\newline		if (inet_ntop(size==16?AF_INET6:AF_INET, ip, txt_ip, sizeof(txt_ip)) != NULL)\newline			mslog(s, NULL, LOG_INFO,\newline				      &quotunbanning IP &#039%s&#039&quot, txt_ip);\newline\newline		t.ip.size = size;\newline		memcpy(&ampt.ip.ip, ip, size);\newline\newline		/* In IPv6 treat a /64 as a single address */\newline		massage_ipv6_address(&ampt);\newline\newline		e = htable_get(db, rehash(&ampt, NULL), ban_entry_cmp, &ampt);\newline		if (e != NULL) { /* new entry */\newline			e-&gtscore = 0;\newline			e-&gtexpires = 0;\newline			return 1;\newline		}\newline	}\newline\newline	return 0;\newline}\newline",returns non-zero if there is an IP removed \newline,6659656,cdw_disc.c,void cdw_disc_init(void)\newline{\newline	/* values returned by gettext() / _() are static strings\newline	   and they must not be free()d */\newline\newline	/* 2TRANS: &quotunknown&quot as in &quotDisc type: unknown&quot; keep short */\newline	cdw_disc_type_labels[CDW_DISC_TYPE_UNKNOWN] = _(&quotunknown&quot);\newline	/* 2TRANS: this string means &quotthere is no disc in drive&quot; keep short */\newline	cdw_disc_type_labels[CDW_DISC_NONE] = _(&quotNo disc&quot);\newline	/* 2TRANS: this string means &quotregular CD disc with music&quot; keep short */\newline	cdw_disc_type_labels[CDW_CD_AUDIO] = _(&quotAudio CD&quot);\newline\newline	/* 2TRANS: this is message printed in dialog window */\newline	disc_not_readable_reasons[CDW_DISC_NOT_READABLE_EMPTY].label = _(&quotcdw can&#039t read the disc because the disc is empty.&quot);\newline	/* 2TRANS: this is message printed in dialog window */\newline	disc_not_readable_reasons[CDW_DISC_NOT_READABLE_NO_ISO9660].label = _(&quotcdw can&#039t read the disc because your operating system does not support ISO9660 file system.&quot);\newline	/* 2TRANS: this is message printed in dialog window */\newline	disc_not_readable_reasons[CDW_DISC_NOT_READABLE_NO_UDF].label = _(&quotcdw can&#039t read the disc because your operating system does not support UDF file system.&quot);\newline	/* 2TRANS: this is message printed in dialog window;\newline	   &quotnot supported&quot means &quotcdw can&#039t handle it&quot */\newline	disc_not_readable_reasons[CDW_DISC_NOT_READABLE_UNSUPPORTED_FS].label = _(&quotcdw can&#039t read the disc because file system on the disc is not supported by cdw.&quot);\newline	/* 2TRANS: this is message printed in dialog window;\newline	   there is some generic/unknown issue/problem with\newline	   checking the disc */\newline	disc_not_readable_reasons[CDW_DISC_NOT_READABLE_OTHER].label = _(&quotcdw can&#039t read the disc.&quot);\newline\newline\newline\newline	return;\newline}\newline,\newline\\brief Initialize cdw_disc module\newline \newline,1065316,imputation.c,"void utinv(double *mat, const int N){\newline  if (N&lt2)\newline    return;\newline  for (int j=1, ij=0; j&ltN; j++) {\newline    for (int i=0, is=0; i&ltj; i++, ij++) {\newline      double w = mat[ij];\newline      if (ISNA(w))\newline	warning(&quotBug: NAs in triangular coefficients matrix&quot);\newline      for (int k=(i+1), k1=ij+1, k2=is; k&ltj; k++){ \newline	w += mat[k1]*mat[k2];\newline	k1++;\newline	k2+= (k+1);\newline      }\newline      mat[ij] = (-w);\newline      is += (i+2);\newline    }\newline  }\newline}\newline",Inverse of unit triangular matrix -- diagonal not stored \newline,5750907,gfal_srm_open.c,"gfal_file_handle gfal_srm_openG(plugin_handle ch, const char *path, int flag, mode_t mode,\newline    GError **err)\newline{\newline    gfal_file_handle ret = NULL;\newline    gfal_srmv2_opt *opts = (gfal_srmv2_opt *) ch;\newline    GError *tmp_err = NULL;\newline    char *p = (char *) path;\newline    char turl[GFAL_URL_MAX_LEN];\newline    char *reqtoken = NULL;\newline    srm_req_type req_type;\newline    int tmp_ret;\newline    gfal2_log(G_LOG_LEVEL_DEBUG, &quot  %s -&gt&quot, __func__);\newline\newline    // If endpoint is Castor, disable stat on open for GridFTP\newline    if (is_castor_endpoint(ch, path)) {\newline        gfal2_set_opt_boolean(opts-&gthandle, &quotGRIDFTP PLUGIN&quot, &quotSESSION_REUSE&quot, FALSE, NULL);\newline        gfal2_set_opt_boolean(opts-&gthandle, &quotGRIDFTP PLUGIN&quot, &quotSTAT_ON_OPEN&quot, FALSE, NULL);\newline    }\newline\newline    if (flag &amp O_CREAT) { // create turl if file is not existing else get one for this file\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quot   SRM PUT mode&quot, __func__);\newline        tmp_ret = gfal_srm_putTURLS_plugin(ch, p, turl, GFAL_URL_MAX_LEN, &ampreqtoken,\newline            &amptmp_err);\newline        req_type = SRM_PUT;\newline    }\newline    else {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quot   SRM GET mode&quot, __func__);\newline        tmp_ret = gfal_srm_getTURLS_plugin(ch, p, turl, GFAL_URL_MAX_LEN, &ampreqtoken,\newline            &amptmp_err);\newline        req_type = SRM_GET;\newline    }\newline\newline    if (tmp_ret == 0) {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quot  SRM RESOLUTION : %s -&gt %s &quot, path, turl);\newline        ret = gfal_plugin_openG(opts-&gthandle, turl, flag, mode, &amptmp_err);\newline        ret = gfal_srm_file_handle_create(ret, p, g_strdup(reqtoken), req_type);\newline    }\newline\newline    g_free(reqtoken);\newline\newline    if (tmp_err) {\newline        gfal2_propagate_prefixed_error(err, tmp_err, __func__);\newline    }\newline\newline    return ret;\newline\newline}\newline",\newline open function for the srm plugin\newline \newline,3271300,test.cpp,"int main(int argc, const char* argv[])\newline{\newline    const double RATE = 985248.4;\newline    const int RINGSIZE = 2048;\newline\newline    std::auto_ptr&ltreSIDfp::TwoPassSincResampler&gt r(new reSIDfp::TwoPassSincResampler(RATE, 48000.0, 20000.0));\newline\newline    std::map&ltdouble, double&gt results;\newline    clock_t start = clock();\newline\newline    for (double freq = 1000.; freq &lt RATE / 2.; freq *= 1.01)\newline    {\newline        /* prefill resampler buffer */\newline        int k = 0;\newline        double omega = 2 * M_PI * freq / RATE;\newline\newline        for (int j = 0; j &lt RINGSIZE; j ++)\newline        {\newline            int signal = static_cast&ltint&gt(32768.0 * sin(k++ * omega) * sqrt(2));\newline            r-&gtinput(signal);\newline        }\newline\newline        int n = 0;\newline        float pwr = 0;\newline\newline        /* Now, during measurement stage, put 100 cycles of waveform through filter. */\newline        for (int j = 0; j &lt 100000; j ++)\newline        {\newline            int signal = static_cast&ltint&gt(32768.0 * sin(k++ * omega) * sqrt(2));\newline\newline            if (r-&gtinput(signal))\newline            {\newline                float out = r-&gtoutput();\newline                pwr += out * out;\newline                n += 1;\newline            }\newline        }\newline\newline        results.insert(std::make_pair(freq, 10 * log10(pwr / n)));\newline    }\newline\newline    clock_t end = clock();\newline\newline    for (std::map&ltdouble, double&gt::iterator it = results.begin(); it != results.end(); ++it)\newline    {\newline        std::cout &lt&lt std::fixed &lt&lt std::setprecision(0) &lt&lt std::setw(6) &lt&lt (*it).first  &lt&lt &quot Hz &quot &lt&lt (*it).second &lt&lt &quot dB&quot &lt&lt std::endl;\newline    }\newline\newline    std::cout &lt&lt &quotFiltering time &quot &lt&lt (end - start) * 1000. / CLOCKS_PER_SEC &lt&lt &quot ms&quot &lt&lt std::endl;\newline}\newline","\newline Simple sin waveform in, power output measurement function.\newline It would be far better to use FFT.\newline \newline",on,,,,,on,,,,,,,,on,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,{},"If tc is inside a pool, this gives the next neighbour.",eliminate technical definitions form parameter string.,Return version information from a compressed buffer.,Encodes the data using hexadecimal characters.,{},This function does not free memory,Lookup a new gateway,returns non-zero if there is an IP removed,Initialize cdw_disc module,Inverse of unit triangular matrix -- diagonal not stored,Description parse the defined patterns for later use,open function for the srm plugin,{},check to see if the packet has a header,Load an image from the named file.,"when cache miss, check the iif, because probably ASSERTS
shoult take place",Only error is if parsename fails,Print parsed data.,{},Handle change of CMRC connection status,x,
34OWYT6U3WH0SF9FSKYQPESAYWV9IR,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:50 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:50 PDT 2019,,,3NL0RFNU0FNSOOQK1USCA5SWM3NK4I,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:49 PDT 2019,Fri Apr 26 13:09:19 PDT 2019,Sun Apr 28 13:09:19 PDT 2019,,,,1290,100% (62/62),100% (62/62),0% (0/0),5197981,php_apc.c,static PHP_MSHUTDOWN_FUNCTION(apcu)\newline{\newline	/* locks shutdown regardless of settings */\newline	apc_lock_cleanup();\newline\newline	/* only shut down if APC is enabled */\newline    if (APCG(enabled)) {\newline        if (APCG(initialized)) {\newline\newline			/* destroy cache pointer */\newline			apc_cache_destroy(apc_user_cache);\newline			/* cleanup shared memory */\newline			apc_sma.cleanup();\newline\newline			APCG(initialized) = 0;\newline		}\newline		\newline#if HAVE_SIGACTION\newline        apc_shutdown_signals();\newline#endif\newline    }\newline\newline    UNREGISTER_INI_ENTRIES();\newline    return SUCCESS;\newline} /* }}} */\newline\newline/* {{{ PHP_RINIT_FUNCTION(apcu) */\newline,{{{ PHP_MSHUTDOWN_FUNCTION(apcu) \newline,1025408,cwdaemon.c,"void cwdaemon_play_request(char *request)\newline{\newline	//cw_block_callback(true);\newline\newline	char *x = request;\newline\newline	while (*x) {\newline		switch ((int) *x) {\newline		case &#039+&#039:\newline		case &#039-&#039:\newline			/* Speed increase &amp decrease */\newline			/* Repeated &#039+&#039 and &#039-&#039 characters are allowed,\newline			   in such cases increase and decrease of speed is\newline			   multiple of 2 wpm. */\newline			do {\newline				current_morse_speed += (*x == &#039+&#039) ? 2 : -2;\newline				x++;\newline			} while (*x == &#039+&#039 || *x == &#039-&#039);\newline\newline			if (current_morse_speed &lt CW_SPEED_MIN) {\newline				current_morse_speed = CW_SPEED_MIN;\newline			} else if (current_morse_speed &gt CW_SPEED_MAX) {\newline				current_morse_speed = CW_SPEED_MAX;\newline			} else {\newline				;\newline			}\newline			cw_set_send_speed(current_morse_speed);\newline			break;\newline		case &#039~&#039:\newline			/* 2 dots time additional for the next char. The gap\newline			   is always reset after playing the char. */\newline			cw_set_gap(2);\newline			x++;\newline			break;\newline		case &#039^&#039:\newline			/* Send echo to main program when CW playing is done. */\newline			*x = &#039\\0&#039;     /* Remove &#039^&#039 and possible trailing garbage. */\newline			/* &#039^&#039 can be found at the end of request, and\newline			   it means &quotecho text of current request back\newline			   to client once you finish playing it&quot. */\newline			cwdaemon_prepare_reply(reply_buffer, request, strlen(request));\newline\newline			/* cwdaemon will wait for queue-empty callback\newline			   before sending the reply. */\newline			break;\newline		case &#039*&#039:\newline			/* TODO: what&#039s this? */\newline			*x = &#039+&#039;\newline		default:\newline			cwdaemon_set_ptt_on(global_cwdevice, &quotPTT (auto) on&quot);\newline			/* PTT is now in AUTO. It will be turned off on low\newline			   tone queue, in cwdaemon_tone_queue_low_callback(). */\newline\newline			cwdaemon_debug(CWDAEMON_VERBOSITY_I, __func__, __LINE__, &quotMorse character \\&quot%c\\&quot to be queued in libcw&quot, *x);\newline			cw_send_character(*x);\newline			cwdaemon_debug(CWDAEMON_VERBOSITY_D, __func__, __LINE__, &quotMorse character \\&quot%c\\&quot has been queued in libcw&quot, *x);\newline\newline			x++;\newline			if (cw_get_gap() == 2) {\newline				if (*x == &#039^&#039) {\newline					/* &#039^&#039 is supposed to be the\newline					   last character in the\newline					   message, meaning that all\newline					   that was before it should\newline					   be used as reply text. So\newline					   x++ will jump to ending\newline					   NUL. */\newline					x++;\newline				} else {\newline					cw_set_gap(0);\newline				}\newline			}\newline			break;\newline		}\newline	}\newline\newline	/* All characters processed, mark buffer as empty. */\newline	*request = &#039\\0&#039;\newline\newline	//cw_block_callback(false);\newline\newline	return;\newline}\newline","\newline\\brief Process received request, play relevant characters\newlineCheck every character in given request, act upon markers\newlinefor speed increase or decrease, and play other characters.\newlineFunction modifies contents of buffer \\p request.\newline\\param request - request to be processed\newline \newline",4587518,cominputcode.c,static void free_is_zero_breaker()\newline{\newline\newline  int locus;\newline  for (locus = 0; locus &lt mlocus; locus++) \newline    free(is_zero_breaker[locus]);\newline  free(is_zero_breaker);\newline  is_zero_breaker = NULL;\newline}\newline,free the memory associated with is_zero_breaker \newline,777073,lv_manip.c,"static int _split_parent_area(struct lv_segment *seg, uint32_t s,\newline			      struct dm_list *layer_seg_pvs)\newline{\newline	uint32_t parent_area_len, parent_le, layer_le;\newline	uint32_t area_multiple;\newline	struct seg_pvs *spvs;\newline\newline	if (seg_is_striped(seg))\newline		area_multiple = seg-&gtarea_count;\newline	else\newline		area_multiple = 1;\newline\newline	parent_area_len = seg-&gtarea_len;\newline	parent_le = seg-&gtle;\newline	layer_le = seg_le(seg, s);\newline\newline	while (parent_area_len &gt 0) {\newline		/* Find the layer segment pointed at */\newline		if (!(spvs = _find_seg_pvs_by_le(layer_seg_pvs, layer_le))) {\newline			log_error(&quotlayer segment for %s:&quot FMTu32 &quot not found.&quot,\newline				  display_lvname(seg-&gtlv), parent_le);\newline			return 0;\newline		}\newline\newline		if (spvs-&gtle != layer_le) {\newline			log_error(&quotIncompatible layer boundary: &quot\newline				  &quot%s:&quot FMTu32 &quot[&quot FMTu32 &quot] on %s:&quot FMTu32 &quot.&quot,\newline				  display_lvname(seg-&gtlv), parent_le, s,\newline				  display_lvname(seg_lv(seg, s)), layer_le);\newline			return 0;\newline		}\newline\newline		if (spvs-&gtlen &lt parent_area_len) {\newline			parent_le += spvs-&gtlen * area_multiple;\newline			if (!lv_split_segment(seg-&gtlv, parent_le))\newline				return_0;\newline		}\newline\newline		parent_area_len -= spvs-&gtlen;\newline		layer_le += spvs-&gtlen;\newline	}\newline\newline	return 1;\newline}\newline","\newline insert_layer_for_segments_on_pv() inserts a layer segment for a segment area.\newline However, layer modification could split the underlying layer segment.\newline This function splits the parent area according to keep the 1:1 relationship\newline between the parent area and the underlying layer segment.\newline Since the layer LV might have other layers below, build_parallel_areas()\newline is used to find the lowest-level segment boundaries.\newline \newline",2612298,qquickcalendarmodel.cpp,void QQuickCalendarModel1::setVisibleDate(const QDate &ampdate)\newline{\newline    if (date != mVisibleDate &amp&amp date.isValid()) {\newline        const QDate previousDate = mVisibleDate;\newline        mVisibleDate = date;\newline        populateFromVisibleDate(previousDate);\newline        emit visibleDateChanged(date);\newline    }\newline}\newline,"!\newlineSets the visible date to \\a visibleDate.\newlineIf \\a visibleDate is a valid date and is different than the previously\newlinevisible date, the visible date is changed and\newlinepopulateFromVisibleDate() called.\newline \newline",1480373,configdialog.cpp,void ConfigDialog::on_checkBoxUseTrayIcon_clicked() {\newline  if (ui-&gtcheckBoxUseTrayIcon-&gtisChecked()) {\newline    ui-&gtcheckBoxHideOnClose-&gtsetEnabled(true);\newline    ui-&gtcheckBoxStartMinimized-&gtsetEnabled(true);\newline  } else {\newline    ui-&gtcheckBoxStartMinimized-&gtsetEnabled(false);\newline    ui-&gtcheckBoxHideOnClose-&gtsetEnabled(false);\newline  }\newline}\newline,\newline @brief ConfigDialog::on_checkBoxUseTrayIcon_clicked enable and disable\newline related checkboxes.\newline \newline,3271446,mos6510.cpp,"void MOS6510::FetchLowPointerX()\newline{\newline    endian_16lo8(Cycle_Pointer, (Cycle_Pointer + Register_X) &amp 0xFF);\newline}\newline",\newline Add X to it&ltBR&gt\newline \newline Addressing Modes:\newline &ltUL&gt\newline &ltLI&gtIndexed Indirect (pre X)\newline &lt/UL&gt\newline \newline,529887,mhmain.c,"LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\newline{\newline	PNHMainWindow data;\newline\newline	switch (message) \newline	{\newline		case WM_CREATE:\newline			/* set window data */\newline			data = (PNHMainWindow)malloc(sizeof(NHMainWindow));\newline			if( !data ) panic(&quotout of memory&quot);\newline			ZeroMemory(data, sizeof(NHMainWindow));\newline			data-&gtmapAcsiiModeSave = MAP_MODE_ASCII12x16;\newline			SetWindowLong(hWnd, GWL_USERDATA, (LONG)data);\newline\newline			GetNHApp()-&gthMainWnd = hWnd;\newline		break;\newline\newline		case WM_MSNH_COMMAND:\newline			onMSNHCommand(hWnd, wParam, lParam);\newline		break;\newline\newline        case WM_KEYDOWN: \newline		{\newline			data = (PNHMainWindow)GetWindowLong(hWnd, GWL_USERDATA);\newline\newline			/* translate arrow keys into nethack commands */\newline            switch (wParam) \newline            { \newline			case VK_LEFT:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one line left */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_HSCROLL,\newline						MAKEWPARAM(SB_LINEUP, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_W));\newline				}\newline			return 0;\newline\newline			case VK_RIGHT:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one line right */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_HSCROLL,\newline						MAKEWPARAM(SB_LINEDOWN, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_E));\newline				}\newline			return 0;\newline\newline			case VK_UP:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one line up */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_LINEUP, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_N));\newline				}\newline			return 0;\newline\newline			case VK_DOWN:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one line down */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_LINEDOWN, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_S));\newline				}\newline			return 0;\newline\newline			case VK_HOME:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window to upper left corner */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_THUMBTRACK, 0),\newline						(LPARAM)NULL\newline					);\newline\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_HSCROLL,\newline						MAKEWPARAM(SB_THUMBTRACK, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_NW));\newline				}\newline			return 0;\newline\newline			case VK_END:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window to lower right corner */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_THUMBTRACK, ROWNO),\newline						(LPARAM)NULL\newline					);\newline\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_HSCROLL,\newline						MAKEWPARAM(SB_THUMBTRACK, COLNO),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_SW));\newline				}\newline			return 0;\newline\newline			case VK_PRIOR:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one page up */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_PAGEUP, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_NE));\newline				}\newline			return 0;\newline\newline			case VK_NEXT:\newline				if( STATEON(VK_CONTROL) ) {\newline					/* scroll map window one page down */\newline					SendMessage(\newline						mswin_hwnd_from_winid(WIN_MAP),\newline						WM_VSCROLL,\newline						MAKEWPARAM(SB_PAGEDOWN, 0),\newline						(LPARAM)NULL\newline					);\newline				} else {\newline					NHEVENT_KBD(KEYTABLE(KEY_SE));\newline				}\newline			return 0;\newline\newline			case VK_DECIMAL:\newline			case VK_DELETE:\newline				NHEVENT_KBD(KEYTABLE(KEY_WAITLOOK));\newline			return 0;\newline\newline			case VK_INSERT:\newline				NHEVENT_KBD(KEYTABLE(KEY_INV));\newline			return 0;\newline\newline			case VK_SUBTRACT:\newline				NHEVENT_KBD(KEYTABLE(KEY_MINUS));\newline			return 0;\newline\newline			case VK_ADD:\newline				NHEVENT_KBD(KEYTABLE(KEY_PLUS));\newline			return 0;\newline\newline			case VK_CLEAR: /* This is the &#0395&#039 key */\newline				NHEVENT_KBD(KEYTABLE(KEY_GOINTERESTING));\newline			return 0;\newline\newline			case VK_F4:\newline				if( IS_MAP_FIT_TO_SCREEN(iflags.wc_map_mode) ) {\newline					mswin_select_map_mode(\newline						IS_MAP_ASCII(iflags.wc_map_mode)? \newline							data-&gtmapAcsiiModeSave :\newline							MAP_MODE_TILES\newline					);\newline				} else {\newline					mswin_select_map_mode(\newline						IS_MAP_ASCII(iflags.wc_map_mode)?\newline							MAP_MODE_ASCII_FIT_TO_SCREEN :\newline							MAP_MODE_TILES_FIT_TO_SCREEN\newline					);\newline				}\newline			return 0;\newline\newline			case VK_F5:\newline				if( IS_MAP_ASCII(iflags.wc_map_mode) ) {\newline					if( IS_MAP_FIT_TO_SCREEN(iflags.wc_map_mode) ) {\newline						mswin_select_map_mode(MAP_MODE_TILES_FIT_TO_SCREEN);\newline					} else {\newline						mswin_select_map_mode(MAP_MODE_TILES);\newline					}\newline				} else {\newline					if( IS_MAP_FIT_TO_SCREEN(iflags.wc_map_mode) ) {\newline						mswin_select_map_mode(MAP_MODE_ASCII_FIT_TO_SCREEN);\newline					} else {\newline						mswin_select_map_mode(data-&gtmapAcsiiModeSave);\newline					}\newline				}\newline			return 0;\newline\newline			default: {\newline				WORD c;\newline				BYTE kbd_state[256];\newline\newline				c = 0;\newline				ZeroMemory(kbd_state, sizeof(kbd_state));\newline				GetKeyboardState(kbd_state);\newline\newline				if( ToAscii( wParam, (lParam&gt&gt16)&amp0xFF, kbd_state, &ampc, 0) ) {\newline					NHEVENT_KBD( c&amp0xFF );\newline					return 0;\newline				} else {\newline					return 1;\newline				}\newline			}\newline\newline			} /* end switch */\newline		} break;\newline\newline        case WM_SYSCHAR: /* Alt-char pressed */\newline        {\newline            /*\newline              If not nethackmode, don&#039t handle Alt-keys here.\newline              If no Alt-key pressed it can never be an extended command \newline            */\newline	    if (GetNHApp()-&gtregNetHackMode &amp&amp ((lParam &amp 1&lt&lt29) != 0))\newline            {\newline                unsigned char c = (unsigned char)(wParam &amp 0xFF);\newline		unsigned char scancode = (lParam &gt&gt 16) &amp 0xFF;\newline                if (index(extendedlist, tolower(c)) != 0)\newline		{\newline		    NHEVENT_KBD(M(tolower(c)));\newline		} else if (scancode == (SCANLO + SIZE(scanmap)) - 1) {\newline		    NHEVENT_KBD(M(&#039?&#039));\newline		}\newline		return 0;\newline            }\newline            return DefWindowProc(hWnd, message, wParam, lParam);\newline        } \newline        break;\newline\newline		case WM_COMMAND:\newline			/* process commands - menu commands mostly */\newline			if( onWMCommand(hWnd, wParam, lParam) )\newline				return DefWindowProc(hWnd, message, wParam, lParam);\newline			else\newline				return 0;\newline\newline		case WM_MOVE:\newline		case WM_SIZE:\newline        {\newline            WINDOWPLACEMENT wp;\newline\newline			mswin_layout_main_window(NULL);\newline            \newline            wp.length = sizeof(wp);\newline            if (GetWindowPlacement(hWnd, &ampwp)) {\newline                GetNHApp()-&gtregMainShowState = (wp.showCmd == SW_SHOWMAXIMIZED \newline		    ? SW_SHOWMAXIMIZED : SW_SHOWNORMAL);\newline\newline                GetNHApp()-&gtregMainMinX = wp.ptMinPosition.x;\newline                GetNHApp()-&gtregMainMinY = wp.ptMinPosition.y;\newline\newline                GetNHApp()-&gtregMainMaxX = wp.ptMaxPosition.x;\newline                GetNHApp()-&gtregMainMaxY = wp.ptMaxPosition.y;\newline\newline                GetNHApp()-&gtregMainLeft = wp.rcNormalPosition.left;\newline                GetNHApp()-&gtregMainTop = wp.rcNormalPosition.top;\newline                GetNHApp()-&gtregMainRight = wp.rcNormalPosition.right;\newline                GetNHApp()-&gtregMainBottom = wp.rcNormalPosition.bottom;\newline            }\newline			break;\newline        }\newline		case WM_SETFOCUS:\newline			/* if there is a menu window out there -\newline			   transfer input focus to it */\newline			if( IsWindow( GetNHApp()-&gthPopupWnd ) ) {\newline				SetFocus( GetNHApp()-&gthPopupWnd );\newline			}\newline			break;\newline\newline		case WM_CLOSE: \newline		{\newline			/* exit gracefully */\newline			if (program_state.gameover)\newline			{\newline			    /* assume the user really meant this, as the game is already over... */\newline			    /* to make sure we still save bones, just set stop printing flag */\newline			    program_state.stopprint++;\newline			    NHEVENT_KBD(&#039\\033&#039); /* and send keyboard input as if user pressed ESC */\newline			    /* additional code for this is done in menu and rip windows */\newline			}\newline			else if (!program_state.something_worth_saving)\newline			{\newline			    /* User exited before the game started, e.g. during splash display */\newline			    /* Just get out. */\newline			    bail((char *)0);\newline			}\newline			else\newline			{\newline			    switch (NHMessageBox(hWnd, TEXT(&quotSave?&quot), MB_YESNOCANCEL | MB_ICONQUESTION)) {\newline			    case IDYES: NHEVENT_KBD(&#039y&#039); dosave(); break;\newline			    case IDNO: NHEVENT_KBD(&#039q&#039); done(QUIT); break;\newline			    case IDCANCEL: break;\newline			    }\newline			}\newline		} return 0;\newline\newline		case WM_DESTROY:\newline			/* apparently we never get here \newline			   TODO: work on exit routines - need to send\newline			   WM_QUIT somehow */  \newline\newline			/* clean up */\newline			free( (PNHMainWindow)GetWindowLong(hWnd, GWL_USERDATA) );\newline			SetWindowLong(hWnd, GWL_USERDATA, (LONG)0);\newline\newline			// PostQuitMessage(0);\newline			exit(1); \newline			break;\newline\newline		default:\newline			return DefWindowProc(hWnd, message, wParam, lParam);\newline   }\newline   return 0;\newline}\newline","\newline// FUNCTION: WndProc(HWND, unsigned, WORD, LONG)\newline//\newline// PURPOSE: Processes messages for the main window.\newline \newline",3804099,testautomation_main.c,"static int main_testInitQuitJoystickHaptic (void *arg)\newline{\newline#if defined SDL_JOYSTICK_DISABLED || defined SDL_HAPTIC_DISABLED\newline    return TEST_SKIPPED;\newline#else\newline    int enabled_subsystems;\newline    int initialized_subsystems = SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC;\newline\newline    SDLTest_AssertCheck( SDL_Init(initialized_subsystems) == 0, &quotSDL_Init multiple systems.&quot );\newline\newline    enabled_subsystems = SDL_WasInit(initialized_subsystems);\newline    SDLTest_AssertCheck( enabled_subsystems == initialized_subsystems, &quotSDL_WasInit(SDL_INIT_EVERYTHING) contains all systems (%i)&quot, enabled_subsystems );\newline\newline    SDL_Quit();\newline\newline    enabled_subsystems = SDL_WasInit(initialized_subsystems);\newline    SDLTest_AssertCheck( enabled_subsystems == 0, &quotSDL_Quit should shut down everything (%i)&quot, enabled_subsystems );\newline\newline    return TEST_COMPLETED;\newline#endif\newline}\newline",!\newline \\brief Tests SDL_Init() and SDL_Quit() of Joystick and Haptic subsystems\newline \\sa\newline http://wiki.libsdl.org/moin.cgi/SDL_Init\newline http://wiki.libsdl.org/moin.cgi/SDL_Quit\newline \newline,4490356,rdlog2.c,"void print_error ( void )\newline{ \newline	fprintf ( stderr, &quotRead mrtg configuration files and convert them in gif format.\\n&quot );\newline	fprintf ( stderr, &quotUse :\\n&quot );\newline	fprintf ( stderr, &quot  rdlog -i cfile -o gfile [-m mapfile] -r rounds\\n&quot );\newline	fprintf ( stderr, &quot   ifile : input fig file name,\\n&quot );\newline	fprintf ( stderr, &quot   gfile : output gif file (will be overwritten),\\n&quot );\newline	fprintf ( stderr, &quot   mapfile : output map file (optional, will be overwritten),\\n&quot );\newline	fprintf ( stderr, &quot   rounds : number of 5 min intervals to take.\\n&quot );\newline}\newline",in case of trouble ... \newline,4475647,emergency_methods.c,"static int child_init(int rank) {\newline	LM_DBG(&quotInitializing child\\n&quot);\newline\newline	if (db_url.s &amp&amp rank&gtPROC_MAIN) {\newline		/* open a test connection */\newline\newline		if ((db_con = db_funcs.init(&ampdb_url)) == 0) {\newline			LM_ERR(&quotcannot init connection to DB\\n&quot);\newline			return -1;\newline		}\newline\newline		if (strcmp(inicialized, &quot0&quot) == 0){\newline			inicialized[0] = &#0391&#039;\newline			inicialized[1] = 0;\newline\newline			routing_timer(0, 0);\newline		}\newline\newline	}\newline	return 0;\newline}\newline",this function is responsible for:\newline - open database connection\newline - initialize polling routing timer\newline \newline,6146272,sock.c,"static int tcp_connect(struct sockaddr_in dst_addr) {\newline   int sock;\newline   int flags;\newline   int sts;\newline   int i;\newline   struct timeval timeout={0,0};\newline   fd_set fdset;\newline\newline   /* get socket and connect to remote site */\newline   sock=socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);\newline   if (sock &lt 0) {\newline      ERROR(&quotsocket() call failed: %s&quot,strerror(errno));\newline      return -1;\newline   }\newline\newline   /* non blocking */\newline   flags = fcntl(sock, F_GETFL);\newline   if (flags &lt 0) {\newline      ERROR(&quotfcntl(F_SETFL) failed: %s&quot,strerror(errno));\newline      close(sock);\newline      return -1;\newline   }\newline   if (fcntl(sock, F_SETFL, (long) flags | O_NONBLOCK) &lt 0) {\newline      ERROR(&quotfcntl(F_SETFL) failed: %s&quot,strerror(errno));\newline      close(sock);\newline      return -1;\newline   }\newline\newline   sts=connect(sock, (struct sockaddr *)&ampdst_addr, sizeof(struct sockaddr_in));\newline   if ((sts == -1 ) &amp&amp (errno == EINPROGRESS)) {\newline      /* if non-blocking connect(), wait until connection \newline         successful, discarded or timeout */\newline      DEBUGC(DBCLASS_NET, &quotconnection in progress, waiting %i msec to succeed&quot,\newline             configuration.tcp_connect_timeout);\newline\newline      /* timeout for connect */\newline      timeout.tv_sec  = (configuration.tcp_connect_timeout/1000);\newline      timeout.tv_usec = (configuration.tcp_connect_timeout%1000)*1000;\newline      \newline      do {\newline         /* prepare fd set */\newline         FD_ZERO(&ampfdset);\newline         FD_SET(sock, &ampfdset);\newline         sts = select(sock+1, NULL, &ampfdset, NULL, &amptimeout);\newline         if ((sts &lt 0) &amp&amp (errno == EINTR)) {\newline            /* select() has been interrupted, do it again */\newline            continue;\newline         } else if (sts &lt 0) {\newline            ERROR(&quotwaiting for TCP connect failed: %s&quot,strerror(errno));\newline            close(sock);\newline            return -1;\newline         } else if (sts &gt 0) {\newline            /* fd available for write */\newline            int valopt;\newline            socklen_t optlen=sizeof(valopt);\newline\newline            /* get error status from delayed connect() */\newline            if (getsockopt(sock, SOL_SOCKET, SO_ERROR, \newline                           &ampvalopt, &ampoptlen) &lt 0) {\newline               ERROR(&quotgetsockopt(SO_ERROR) failed: %s&quot,strerror(errno));\newline               close(sock);\newline               return -1;\newline            }\newline\newline            if (valopt == EINPROGRESS) {\newline               ERROR(&quotconnect() returned: %s&quot,strerror(valopt));\newline               continue;\newline            }\newline\newline            DEBUGC(DBCLASS_NET, &quotconnect() completed after %i msec&quot,\newline                   (int)(configuration.tcp_connect_timeout \newline                   - (timeout.tv_sec*1000) \newline                   - (timeout.tv_usec/1000)));\newline            \newline            /* check the returned error value from connect() */\newline            if (valopt) {\newline               ERROR(&quotdelayed TCP connect() failed : %s&quot,strerror(errno));\newline               close(sock);\newline               return -1;\newline            }\newline            /* all went fine, continue */\newline            break;\newline\newline         } else {\newline            DEBUGC(DBCLASS_NET, &quottcp_connect() timeout&quot);\newline            close(sock);\newline            return -1;\newline         }\newline      } while (1);\newline\newline   } else if (sts == -1 ) {\newline      if ((errno != ECONNREFUSED) &amp&amp (errno != ETIMEDOUT)) {\newline         ERROR(&quotconnect() [%s:%i] call failed: %s&quot,\newline               utils_inet_ntoa(dst_addr.sin_addr),\newline               ntohs(dst_addr.sin_port), strerror(errno));\newline         close(sock);\newline         return -1;\newline      }\newline      DEBUGC(DBCLASS_BABBLE,&quotconnect() [%s:%i] call failed: %s&quot,\newline             utils_inet_ntoa(dst_addr.sin_addr),\newline             ntohs(dst_addr.sin_port), strerror(errno));\newline   }\newline\newline   i=tcp_add(dst_addr, sock);\newline   if (i &lt 0) {\newline      ERROR(&quotout of space in TCP connection cache - rejecting&quot);\newline      close(sock);\newline      return -1;\newline   }\newline\newline   DEBUGC(DBCLASS_NET, &quotconnected TCP connection to [%s:%i] fd=%i&quot,\newline          utils_inet_ntoa(dst_addr.sin_addr),\newline          ntohs(dst_addr.sin_port), sock);\newline\newline   return i;\newline}\newline",\newline connect to a remote TCP target\newline \newline RETURNS: index into TCP cache or -1 on failure\newline \newline,1778301,shmem.cpp,"void notifySharedMem(void *mem, size_t len) {\newline	((volatile uint32_t*)((char*)mem + len))[0] = SHMEM_INIT;\newline}\newline",\newline Notify other users of a shared-memory chunk that the leader has\newline finished initializing it.\newline \newline,263761,emuwin.c,"void tilem_emulator_window_set_skin_disabled(TilemEmulatorWindow *ewin,\newline                                             gboolean disabled)\newline{\newline	g_return_if_fail(ewin != NULL);\newline\newline	if (ewin-&gtskin_disabled != !!disabled) {\newline		ewin-&gtskin_disabled = !!disabled;\newline		redraw_screen(ewin);\newline	}\newline}\newline",Switch between skin and LCD-only mode \newline,6006700,multifun.c,"globle int InsertMultiValueField(\newline  void *theEnv,\newline  DATA_OBJECT *dst,\newline  DATA_OBJECT *src,\newline  long theIndex,\newline  DATA_OBJECT *field,\newline  char *funcName)\newline  {\newline   register long i,j,k;\newline   register FIELD *deptr, *septr;\newline   unsigned long srclen,dstlen;\newline\newline   srclen = (unsigned long) ((src != NULL) ? (src-&gtend - src-&gtbegin + 1) : 0);\newline   if (theIndex &lt 1)\newline     {\newline      MVRangeError(theEnv,theIndex,theIndex,srclen+1,funcName);\newline      return(FALSE);\newline     }\newline   if (theIndex &gt (long) (srclen + 1))\newline     theIndex = (long) (srclen + 1);\newline   dst-&gttype = MULTIFIELD;\newline   dst-&gtbegin = 0;\newline   if (src == NULL)\newline     {\newline      if (field-&gttype == MULTIFIELD)\newline        {\newline         DuplicateMultifield(theEnv,dst,field);\newline         AddToMultifieldList(theEnv,(struct multifield *) dst-&gtvalue);\newline        }\newline      else\newline        {\newline         dst-&gtvalue = EnvCreateMultifield(theEnv,0L);\newline         dst-&gtend = 0;\newline         deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[0];\newline         deptr-&gttype = field-&gttype;\newline         deptr-&gtvalue = field-&gtvalue;\newline        }\newline      return(TRUE);\newline     }\newline   dstlen = (field-&gttype == MULTIFIELD) ? GetpDOLength(field) + srclen : srclen + 1;\newline   dst-&gtvalue = EnvCreateMultifield(theEnv,dstlen);\newline   SetpDOEnd(dst,dstlen);\newline   theIndex--;\newline   for (i = 0 , j = src-&gtbegin ; i &lt theIndex ; i++ , j++)\newline     {\newline      deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[i];\newline      septr = &amp((struct multifield *) src-&gtvalue)-&gttheFields[j];\newline      deptr-&gttype = septr-&gttype;\newline      deptr-&gtvalue = septr-&gtvalue;\newline     }\newline   if (field-&gttype != MULTIFIELD)\newline     {\newline      deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[theIndex];\newline      deptr-&gttype = field-&gttype;\newline      deptr-&gtvalue = field-&gtvalue;\newline      i++;\newline     }\newline   else\newline     {\newline      for (k = field-&gtbegin ; k &lt= field-&gtend ; k++ , i++)\newline        {\newline         deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[i];\newline         septr = &amp((struct multifield *) field-&gtvalue)-&gttheFields[k];\newline         deptr-&gttype = septr-&gttype;\newline         deptr-&gtvalue = septr-&gtvalue;\newline        }\newline     }\newline   for ( ; j &lt= src-&gtend ; i++ , j++)\newline     {\newline      deptr = &amp((struct multifield *) dst-&gtvalue)-&gttheFields[i];\newline      septr = &amp((struct multifield *) src-&gtvalue)-&gttheFields[j];\newline      deptr-&gttype = septr-&gttype;\newline      deptr-&gtvalue = septr-&gtvalue;\newline     }\newline   return(TRUE);\newline  }\newline","\newlineNAME : InsertMultiValueField\newlineDESCRIPTION : Performs an insert on the src multi-field value\newlinestoring the results in the dst multi-field value\newlineINPUTS : 1) The destination value buffer\newline2) The source value (can be NULL)\newline3) The index for the change\newline4) The new field value\newlineRETURNS : TRUE if successful, FALSE otherwise\newlineSIDE EFFECTS : Allocates and sets a ephemeral segment (even if new\newlinenumber of fields is 0)\newlineSrc value segment is not changed\newlineNOTES : index is NOT guaranteed to be valid\newlinesrc is guaranteed to be a multi-field variable or NULL\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2166572,capi_mod_std.c,"static int standardClearFlags( unsigned nApplId, unsigned nFlags ) {\newline	if ( ioctl(capi_applid2fd( nApplId ), CAPI_CLR_FLAGS, &ampnFlags) &lt 0) {\newline		return CapiMsgOSResourceErr;\newline	}\newline\newline	return CapiNoError;\newline}\newline",\newline \\brief Clear flags\newline \\param nApplId application id\newline \\param nFlags flags to clear\newline \\return error code\newline \newline,6659167,main.c,"int cdw_main_loop(void)\newline{\newline	MENU *menu = cdw_main_window_get_main_menu();\newline	WINDOW *window = cdw_main_window_get_main_window();\newline	int c = &#039a&#039;\newline\newline	while ((c = wgetch(window))\newline#ifdef CDW_MAIN_WINDOW_CAN_RESIZE\newline	        || cdw_main_window_resize\newline#endif\newline		  ) {\newline#ifdef CDW_MAIN_WINDOW_CAN_RESIZE\newline		/* yay! this works :)\newline		   I only need to add function that resizes all\newline		   widgets embedded in main window :/ */\newline		if (cdw_main_window_resize) {\newline			cdw_main_window_resize = 0;\newline			int lines, columns;\newline			getmaxyx(stdscr, lines, columns);\newline			resizeterm(lines, columns);\newline			continue;\newline		}\newline#endif\newline		switch (c) {\newline\newline		/* ****************************** *\newline		 * **********  HOT KEYS  ******** *\newline		 * ****************************** */\newline\newline\newline		case &#039i&#039:\newline		case &#039I&#039: /* write image to optical disc */\newline			cdw_burn_disc(CDW_TASK_BURN_FROM_IMAGE);\newline			break;\newline		case &#039f&#039:\newline		case &#039F&#039:\newline			/* write selected files to optical disc */\newline			cdw_burn_disc(CDW_TASK_BURN_FROM_FILES);\newline			break;\newline		case &#039e&#039:\newline		case &#039E&#039:\newline			cdw_drive_toggle_tray_with_ui_update2();\newline			break;\newline		case &#039g&#039:\newline		case &#039G&#039:\newline			/* Copy content of data CD or audio CD to your hard disc */\newline			cdw_read_disc();\newline			break;\newline		case &#039r&#039:\newline		case &#039R&#039:\newline			/* Read disc meta information and display basic\newline			   information in &#039Disc info&#039 area */\newline			{\newline				int rv = cdw_drive_update_ui_with_disc(true);\newline				if (rv == -1) {\newline					cdw_buttons_dialog(_(&quotInfo&quot),\newline							   /* 2TRANS: this is message in dialog window */\newline							   _(&quotNo disc in drive or drive tray is open.&quot),\newline							   CDW_BUTTONS_OK, CDW_COLORS_DIALOG);\newline				}\newline			}\newline\newline\newline			break;\newline		case &#039v&#039:\newline		case &#039V&#039:\newline			cdw_verify();\newline			break;\newline		case &#039q&#039:\newline		case &#039Q&#039:\newline			/* this function calls exit() only if user confirms closing appication */\newline			cdw_conditional_exit();\newline			break;\newline		case KEY_F(1):\newline		case &#039H&#039:\newline		case &#039h&#039:\newline		case &#039?&#039:\newline			/*  Show small help window */\newline			show_help_main();\newline			break;\newline		case &#039l&#039:\newline		case &#039L&#039:\newline			/* 2TRANS: this is a title of window displaying\newline			   content of log file */\newline			cdw_logging_display_log(_(&quotcdw log file&quot));\newline			break;\newline	        case &#039c&#039:\newline		case &#039C&#039:\newline			cdw_config_window();\newline			break;\newline		case &#039d&#039:\newline	        case &#039D&#039:\newline			cdw_read_and_display_disc_info();\newline		        break;\newline		case KEY_F(9):\newline		case KEY_F(10):\newline			/* on some terminals F10 may be used/broken, so\newline			   use F9 as well */\newline			cdw_main_window_show_license();\newline			break;\newline\newline#if 0 /* not in this release */\newline#ifdef HAVE_LIBMYSQLCLIENT\newline			case &#039c&#039:\newline			case &#039C&#039:\newline			/* CDDB */\newline			cddb_window();\newline			break;\newline#endif\newline#ifdef HAVE_LIBSQLITE\newline			case &#039c&#039:\newline			case &#039C&#039:\newline			/* CDDB */\newline			cddb_window();\newline			break;\newline#endif\newline#ifdef HAVE_LIBMYSQLCLIENT\newline		case &#039A&#039:\newline		case &#039a&#039:\newline			/* Add disk to dic database */\newline			add_to_dic();\newline			break;\newline#endif\newline#ifdef HAVE_LIBSQLITE\newline		case &#039A&#039:\newline		case &#039a&#039:\newline			/* Add disk to dic database */\newline			add_to_dic();\newline			break;\newline#endif\newline#endif\newline\newline		/* ****************************** *\newline	         * ******  LEFT-HAND MENU  ****** *\newline		 * ****************************** */\newline\newline\newline		case KEY_HOME:\newline			menu_driver(menu, REQ_FIRST_ITEM);\newline			display_tooltip(item_index(current_item(menu)));\newline			break;\newline		case KEY_END:\newline			menu_driver(menu, REQ_LAST_ITEM);\newline			display_tooltip(item_index(current_item(menu)));\newline			break;\newline		case KEY_DOWN:\newline			{\newline				int n = item_count(menu); /* n includes ending NULL element */\newline				int ind = item_index(current_item(menu));\newline				if (n - 1 == ind) {\newline					menu_driver(menu, REQ_FIRST_ITEM);\newline				} else {\newline					menu_driver(menu, REQ_DOWN_ITEM);\newline				}\newline				display_tooltip(item_index(current_item(menu)));\newline			}\newline			break;\newline		case KEY_UP:\newline			{\newline\newline				int ind = item_index(current_item(menu));\newline				if (ind == 0) {\newline					menu_driver(menu, REQ_LAST_ITEM);\newline				} else {\newline					menu_driver(menu, REQ_UP_ITEM);\newline				}\newline				display_tooltip(item_index(current_item(menu)));\newline			}\newline			break;\newline		case CDW_KEY_ENTER:\newline			{\newline			int ii = item_index(current_item(menu));\newline			/* UI_MENU* elements are numbered from 0, so they\newline			   neatly correspond with menu item numbers */\newline\newline			if (ii == CDW_MENU_ADD_FILES) { /* Add files to list of files to be written to cd/image */\newline				cdw_main_window_add_to_selected_files();\newline\newline			} else if (ii == CDW_MENU_DELETE_FILES) {\newline				/* Delete files from list of files to be\newline				written to cd/image; this function regenerates\newline				list of files and files info area */\newline				cdw_main_window_delete_from_selected_files();\newline\newline			} else if (ii == CDW_MENU_CREATE_IMAGE) {\newline				/* Create iso image using selected files */\newline				cdw_create_image();\newline			} else if (ii == CDW_MENU_RIP_DISC) {\newline				/* Copy content of audio / data CD or data DVD to your hard disc */\newline				cdw_read_disc();\newline			} else if (ii == CDW_MENU_BURN_FILES) {\newline				cdw_burn_disc(CDW_TASK_BURN_FROM_FILES);\newline			} else if (ii == CDW_MENU_BURN_IMAGE) {\newline				cdw_burn_disc(CDW_TASK_BURN_FROM_IMAGE);\newline			} else if (ii == CDW_MENU_ERASE_DISC) {\newline				cdw_erase_disc();\newline			} else if (ii == CDW_MENU_VERIFY) {\newline				cdw_verify();\newline			} else if (ii == CDW_MENU_CONFIG) {\newline				/* Edit cdw options */\newline				/* config_window() reads current\newline				 * configuration from global variable &#039struct\newline				 * conf config&#039, shows user a window that\newline				 * allows him modify the options, save options\newline				 * to global variable and to disk file */\newline				cdw_config_window();\newline			} else if (ii == CDW_MENU_ABOUT) {\newline				cdw_about();\newline			} else if (ii == CDW_MENU_EXIT_CDW) { /* Quit - Exit cdw */\newline				/* this function calls exit() only if user\newline				   confirms closing appication */\newline				cdw_conditional_exit();\newline			} else {\newline				;\newline#if 0 /* not in this release */\newline				/* Write Audio */\newline				if ((item_index(current_item(menu)) == 5)) {\newline					run_command_cdrecord_write_audio();\newline				}\newline					/* Copy data CD */\newline					/* watch out! config.cdrom is disabled in options.c */\newline					if ((item_index(current_item(menu)) == 6) &amp&amp (config.cdrom != config.cdrw_device)) {\newline					run_command_copy_disk();\newline				}\newline#endif\newline			}\newline			}\newline			break;\newline		default:\newline			break;\newline		} /* switch(c) */\newline		cdw_main_window_wrefresh();\newline	} /* while (c = wgetch(main_cdw_win)) */\newline\newline	return 0;\newline}\newline","\newline \\brief Main ncurses events loop - main loop handling keys\newline \newline Function that handles keys when cdw is started and user sits in front of\newline main cdw window: menu on the left, list of files in main area and\newline information area at the bottom. User can select items from left-hand menu\newline or use hotkeys.\newline \newline \\return 0\newline \newline",5108410,functions.c,static void fn_len(void) {\newline  basicstring descriptor;\newline  stackitem stringtype;\newline  (*factor_table[*basicvars.current])();\newline  stringtype = GET_TOPITEM;\newline  if (stringtype == STACK_STRING || stringtype == STACK_STRTEMP) {\newline    descriptor = pop_string();\newline    PUSH_INT(descriptor.stringlen);\newline    if (stringtype == STACK_STRTEMP) free_string(descriptor);\newline  }\newline  else {\newline    error(ERR_TYPESTR);\newline  }\newline}\newline,\newline &#039fn_len&#039 pushes the length of its string argument on to the Basic stack\newline \newline,3937719,register.c,"static void setOptions (String editorCmd) \newline{\newline  static CHAR options[4*_MAX_PATH]; \newline  \newline  sprintf(options, &quot-E%s -P%s&quot, editorCmd, HUGSPATH);	\newline  writeHugsRegString(&quotOptions&quot,options);\newline  writeWinhugsRegString(&quotOptions&quot,options);\newline\newline}\newline",Set an editor and path for hugs and winhugs \newline,4357620,import_cdf.c,"static void removeVar(Infovar *vp, int n)\newline{\newline   Infovar last,ptr;\newline   int i;\newline\newline   last = *vp;\newline   if (n==0){\newline      ptr = last;\newline      last = last-&gtnext;\newline      *vp = last;\newline   }\newline   else{\newline      for(i=0; i&ltn-1; i++)\newline         last = last-&gtnext;\newline      ptr = last-&gtnext;\newline      last-&gtnext = ptr-&gtnext;\newline   }\newline   DXFree(ptr);\newline}\newline",\newlineRemove nth Variable from vp\newline \newline,on,on,,,,,,,,,,,,,,,,,on,,on,,,,,,,,,,,,,,,,,,,,,,{},{},open database connection,connect to a remote TCP target,Notify other users of a shared-memory chunk,Switch between skin and LCD-only mode,"Performs an insert on the src multi-field value
storing",Load an image from the named file.,Clear flags,main loop handling keys,pushes the length of its string argument on to the Basic stack,Function modifies contents of buffer \p request.,Set an editor and path for hugs and winhugs,Remove nth Variable from vp,free the memory associated with is_zero_breaker,"However, layer modification could split the underlying layer segment.",Sets the visible date to \a visibleDate.,"enable and disable
related checkboxes.",{},Processes messages for the main window.,{},x,
39AYGO6AFFK5OXI8RT86ACXPUUH6NT,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:44 PDT 2019,2,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:44 PDT 2019,,,3CCZ6YKWR7JQ3BBTB2KXPOKUB6059A,AITP2LUW8GPB,Submitted,Fri Apr 26 14:36:34 PDT 2019,Fri Apr 26 15:05:57 PDT 2019,Sun Apr 28 15:05:57 PDT 2019,,,,1763,100% (62/62),100% (62/62),0% (0/0),3213691,setup.c,"void LibInit(Uint32 lib_flags)\newline{\newline  LOG( &quotLibInit():\\n-About to init SDL Library\\n&quot );\newline\newline  /* Initialize video: */\newline  if (SDL_Init(SDL_INIT_VIDEO) &lt 0)\newline  {\newline    fprintf(stderr, &quotCouldn&#039t initialize SDL: %s\\n&quot,\newline    SDL_GetError());\newline    exit(2);\newline  }\newline  /* Initialize audio if desired: */\newline  if (settings.sys_sound)\newline  {\newline    if (SDL_InitSubSystem(SDL_INIT_AUDIO) &lt 0)\newline    {\newline      fprintf(stderr, &quotCouldn&#039t initialize SDL Sound: %s\\n&quot,\newline              SDL_GetError());\newline      settings.sys_sound = 0;\newline    }\newline    else\newline      LOG(&quotSDL_InitSubSystem(SDL_INIT_AUDIO) succeeded\\n&quot);\newline  }\newline\newline// atexit(SDL_Quit); // fire and forget... \newline\newline  LOG( &quot-SDL Library init&#039d successfully\\n&quot );\newline\newline  DEBUGCODE\newline  { fprintf(stderr, &quotsettings.sys_sound = %d\\n&quot, settings.sys_sound); }\newline\newline  /* FIXME should read settings before we do this: */ \newline  if (settings.sys_sound) //can be turned off with &quot--nosound&quot runtime flag\newline  {\newline    int initted = 1;\newline\newline    /* For SDL_mixer 1.2.10 and later, we must call Mix_Init() before any */\newline    /* other SDL_mixer functions. We can see what types of audio files    */\newline    /* are supported at this time (ogg and mod are required):             */\newline\newline#ifdef HAVE_MIX_INIT\newline    int flags = MIX_INIT_OGG | MIX_INIT_MP3 | MIX_INIT_MOD | MIX_INIT_FLAC;\newline    initted = Mix_Init(flags);\newline\newline    /* Just give warnings if MP3 or FLAC not supported: */\newline    if((initted &amp MIX_INIT_MP3) != MIX_INIT_MP3)\newline      LOG(&quotNOTE - MP3 playback not supported\\n&quot);\newline    if((initted &amp MIX_INIT_FLAC) != MIX_INIT_FLAC)\newline      LOG(&quotNOTE - MP3 playback not supported\\n&quot);\newline\newline    /* We must have Ogg and Mod support to have sound: */\newline    if((initted &amp (MIX_INIT_OGG | MIX_INIT_MOD)) != (MIX_INIT_OGG | MIX_INIT_MOD))\newline    {\newline      fprintf(stderr, &quotMix_Init: Failed to init required ogg and mod support!\\n&quot);\newline      fprintf(stderr, &quotMix_Init: %s\\n&quot, Mix_GetError());\newline      settings.sys_sound = 0;\newline      initted = 0;\newline    }\newline    else\newline      LOG(&quotMix_Init() succeeded\\n&quot);\newline#endif\newline\newline    DOUT(initted);\newline\newline    /* If Mix_Init() succeeded (or wasn&#039t required), set audio parameters: */\newline    if(initted)\newline    {\newline      LOG(&quotAbout to call Mix_OpenAudio():\\n&quot);\newline//    if (Mix_OpenAudio(22050, AUDIO_S16, 1, 2048) == -1)\newline      if(Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 1, 2048) ==\newline		      -1)\newline      {\newline        fprintf(stderr, &quotWarning: Mix_OpenAudio() failed\\n - Reasons: %s\\n&quot, SDL_GetError());\newline        settings.sys_sound = 0;\newline      }\newline      else\newline        LOG(&quotMix_OpenAudio() successful\\n&quot);\newline    }\newline  }\newline\newline  LOG( &quot-about to init SDL text library (SDL_ttf or SDL_Pango\\n&quot );\newline\newline  if (!Setup_SDL_Text())\newline  {\newline    fprintf( stderr, &quotCouldn&#039t initialize desired SDL text libary\\n&quot );\newline    exit(2);\newline  }\newline//	atexit(TTF_Quit);\newline\newline  LOG( &quotLibInit():END\\n&quot );\newline}\newline",should just simplify all this: \newline,709310,eigenv.c,"int eigen2(double *mm,double *lambda,double vp[2][2]) {\newline  double   m[3],dd,a1,xn,ddeltb,rr1,rr2,ux,uy;\newline\newline  /* init */\newline  ux = 1.0;\newline  uy = 0.0;\newline\newline  /* normalize */\newline  memcpy(m,mm,3*sizeof(double));\newline  xn = fabs(m[0]);\newline  if ( fabs(m[1]) &gt xn )  xn = fabs(m[1]);\newline  if ( fabs(m[2]) &gt xn )  xn = fabs(m[2]);\newline  if ( xn &lt EPSD2 ) {\newline    lambda[0] = lambda[1] = 0.0;\newline    vp[0][0] = 1.0; \newline    vp[0][1] = 0.0;\newline    vp[1][0] = 0.0;\newline    vp[1][1] = 1.0;\newline    return(1);\newline  }\newline  xn = 1.0 / xn;\newline  m[0] *= xn;\newline  m[1] *= xn;\newline  m[2] *= xn;\newline\newline  if ( egal(m[1],0.0) ) {\newline    rr1 = m[0];\newline    rr2 = m[2];\newline    goto vect;\newline  }\newline\newline  /* eigenvalues of jacobian */\newline  a1	 = -(m[0] + m[2]);\newline  ddeltb = a1*a1 - 4.0 * (m[0]*m[2] - m[1]*m[1]);\newline\newline  if ( ddeltb &lt 0.0 ) {\newline    fprintf(stderr,&quot  Delta: %f\\n&quot,ddeltb);\newline    ddeltb = 0.0;\newline  }\newline  ddeltb = sqrt(ddeltb);\newline\newline  if ( fabs(a1) &lt EPS ) {\newline    rr1 = 0.5 * sqrt(ddeltb);\newline    rr2 = -rr1;\newline  } \newline  else if ( a1 &lt 0.0 ) {\newline    rr1 = 0.5 * (-a1 + ddeltb);\newline    rr2 = (-m[1]*m[1] + m[0]*m[2]) / rr1;\newline  }\newline  else if ( a1 &gt 0.0 ) {\newline    rr1 = 0.5 * (-a1 - ddeltb);\newline    rr2 = (-m[1]*m[1] + m[0]*m[2]) / rr1;\newline  }\newline  else {\newline    rr1 = 0.5 * ddeltb;\newline    rr2 = -rr1;\newline  }\newline\newlinevect:\newline  xn = 1.0 / xn;\newline  lambda[0] = rr1 * xn;\newline  lambda[1] = rr2 * xn;\newline\newline  /* eigenvectors */\newline  a1 = m[0] - rr1;\newline  if ( fabs(a1)+fabs(m[1]) &lt EPS ) {\newline    if (fabs(lambda[1]) &lt fabs(lambda[0]) ) {\newline      ux = 1.0;\newline      uy = 0.0;    \newline    }\newline    else {\newline      ux = 0.0;\newline      uy = 1.0;\newline    }\newline  }\newline  else if ( fabs(a1) &lt fabs(m[1]) ) {\newline    ux = 1.0;\newline    uy = -a1 / m[1];\newline  }\newline  else if ( fabs(a1) &gt fabs(m[1]) ) {\newline    ux = -m[1] / a1;\newline    uy = 1.0;\newline  }\newline  else if ( fabs(lambda[1]) &gt fabs(lambda[0]) ) {\newline    ux = 0.0;\newline    uy = 1.0;\newline  }\newline  else {\newline    ux = 1.0;\newline    uy = 0.0;\newline  }\newline\newline  dd = sqrt(ux*ux + uy*uy);\newline  dd = 1.0 / dd;\newline  if ( fabs(lambda[0]) &gt fabs(lambda[1]) ) {\newline    vp[0][0] =  ux * dd;\newline    vp[0][1] =  uy * dd;\newline  }\newline  else {\newline    vp[0][0] =  uy * dd;\newline    vp[0][1] = -ux * dd;\newline  }\newline\newline  /* orthogonal vector */\newline  vp[1][0] = -vp[0][1];\newline  vp[1][1] =  vp[0][0];\newline\newline  return(1);\newline}\newline",eigen value + vector extraction \newline,6009668,add_change_user.c,"void add_change_user(struct w *widgets)\newline{\newline    FILE *fp;\newline    gchar *info, *path, *cmd;\newline\newline    G_CONST_RETURN gchar *username;\newline    G_CONST_RETURN gchar *password;\newline    G_CONST_RETURN gchar *groupname;\newline    G_CONST_RETURN gchar *comment;\newline    G_CONST_RETURN gchar *homedir;\newline    G_CONST_RETURN gchar *shell;\newline\newline    /* Get the users settings */\newline    username  = gtk_entry_get_text(GTK_ENTRY(widgets-&gtuser_set_entry[0]));\newline    password  = gtk_entry_get_text(GTK_ENTRY(widgets-&gtuser_set_entry[1]));\newline    groupname = gtk_entry_get_text(GTK_ENTRY(widgets-&gtuser_set_entry[2]));\newline    comment   = gtk_entry_get_text(GTK_ENTRY(widgets-&gtuser_set_entry[3]));\newline    homedir   = gtk_entry_get_text(GTK_ENTRY(widgets-&gtuser_set_entry[4]));\newline    /* Its a gtk combo box entry new text */\newline    shell     = gtk_entry_get_text(GTK_ENTRY(GTK_BIN(widgets-&gtuser_set_combo[0])-&gtchild));\newline\newline\newline    /* Puts the pdbedit userlist as:\newline       /etc/gadmin-samba/gadmin_samba_users */\newline    get_gadmin_samba_users();\newline\newline\newline    if( ! smbuser_exists(username)\newline    &amp&amp  ( password == NULL || strlen(password) &lt atoi(MIN_PASS_LEN) ))\newline    {\newline	info = g_strdup_printf(_(&quotYou must specify a valid password for this new user.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;	\newline    }\newline\newline    path = g_strdup_printf(&quot%s&quot, GADMIN_SAMBA_USERS);\newline    if( ! file_exists(path) )\newline      make_file_chmod(path, &quot0600&quot);\newline\newline    if( ! file_exists(path) )\newline    {\newline	info = g_strdup_printf(_(&quotFailed to create missing samba password file:\\n%s\\n&quot), path);\newline	show_info(info);\newline	g_free(info);\newline	g_free(path);\newline	return;\newline    }\newline    g_free(path);\newline\newline\newline    /* Sanitychecks... */\newline    if( username == NULL || strlen(username) &lt 1 )\newline    {\newline	info = g_strdup_printf(_(&quotA username must be specified.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;    \newline    }\newline    if( groupname == NULL || strlen(groupname) &lt 1 )\newline    {\newline	info = g_strdup_printf(_(&quotA groupname must be specified.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;    \newline    }\newline    if( comment == NULL || strlen(comment) &lt 1 )\newline    {\newline	info = g_strdup_printf(_(&quotA comment must be specified.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;    \newline    }\newline    if( homedir == NULL || strlen(homedir) &lt 2 )\newline    {\newline	info = g_strdup_printf(_(&quotA home directory must be specified.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;    \newline    }\newline    if( shell == NULL || strlen(shell) &lt 2 )\newline    {\newline	info = g_strdup_printf(_(&quotA shell must be specified.\\n&quot));\newline	show_info(info);\newline	g_free(info);\newline	return;    \newline    }\newline\newline    /* Root user specified, only change its samba settings */\newline    if( strcmp(username, &quotroot&quot) == 0 )\newline    {\newline	/* If the root system user doesnt exist, tell the user and return. */	\newline	if( ! user_exists(username) )\newline	{\newline    	    info = g_strdup_printf(_(&quotThe root system user doesnt exist, nothing was done.\\n&quot));\newline    	    show_info(info);\newline    	    g_free(info);\newline    	    return;\newline	}\newline\newline	if( password!=NULL &amp&amp strlen(password) &gt= atoi(MIN_PASS_LEN) )\newline	{\newline    	    cmd = g_strdup_printf(&quot%s -t -a -u &#039%s&#039&quot, PDBEDIT_BINARY, username);\newline    	    if((fp=popen(cmd, &quotw&quot))==NULL)\newline    	    {\newline		perror(&quotpopen&quot);\newline    		info = g_strdup_printf(_(&quotFailed changing samba password or adding samba user: %s\\n&quot), username);\newline    		show_info(info);\newline    		g_free(info);\newline		g_free(cmd);\newline    		return;\newline	    }\newline	    fputs(password, fp);\newline	    fputs(&quot\\n&quot, fp);\newline	    fputs(password, fp);\newline	    fputs(&quot\\n&quot, fp);\newline	    pclose(fp);\newline	    g_free(cmd);\newline\newline    	    info = g_strdup_printf(_(&quotThe samba password for root was changed.\\nNothing else was changed for this user.\\n&quot));\newline    	    show_info(info);\newline    	    g_free(info);\newline    	    return;\newline	}\newline	else\newline	  {\newline	      info = g_strdup_printf(_(&quotThe password is too short, adding or changing samba user root failed.\\n&quot));\newline	      show_info(info);\newline	      g_free(info);\newline	      return;\newline	  }\newline\newline	/* End of modifications for samba user root */\newline	return;\newline    }\newline\newline    \newline    /* Non root user modification follows... */\newline\newline\newline    /* The system user doesnt exist, add it */\newline    if( ! user_exists(username) )\newline    {\newline	/* Add the system group if it doesnt exist */\newline	if( ! group_exists(groupname) )\newline	{    \newline	    cmd = g_strdup_printf(&quot%s %s&quot, &quotgroupadd&quot, groupname);\newline	    if( ! run_command(cmd) )\newline	    {\newline		printf(&quotError adding system group: %s\\n&quot, groupname);\newline		printf(&quotThe command was: %s\\n&quot, cmd);\newline		g_free(cmd);\newline		return;\newline	    }\newline	    g_free(cmd);\newline	}\newline\newline	/* Add the user to the specified group */\newline	cmd = g_strdup_printf(&quot%s &#039%s&#039 -d &#039%s&#039 -c &#039%s&#039 -s &#039%s&#039 -g &#039%s&#039&quot, &quotuseradd&quot, username, homedir, comment, shell, groupname);\newline	if( ! run_command(cmd) )\newline	{\newline	    info = g_strdup_printf(_(&quotError adding system user: %s\\nThe command was: %s\\n&quot), username, cmd);\newline	    show_info(info);\newline	    g_free(info);\newline	    g_free(cmd);\newline	    return;\newline	}\newline	g_free(cmd);\newline    }\newline\newline\newline    /* Make sure that the system user exists */\newline    if( ! user_exists(username) )\newline    {\newline	info = g_strdup_printf(_(&quotError adding system user: %s\\n&quot), username);\newline	show_info(info);\newline	g_free(info);\newline	return;\newline    }\newline    \newline\newline    /* The system user exists, modify its system and samba settings... */\newline\newline\newline    /* Add a new samba user with this password or change the old password. */\newline    if( password!=NULL &amp&amp strlen(password) &gt= atoi(MIN_PASS_LEN) )\newline    {\newline        cmd = g_strdup_printf(&quot%s -t -a -u &#039%s&#039&quot, PDBEDIT_BINARY, username);\newline        if((fp=popen(cmd, &quotw&quot))==NULL)\newline        {\newline	    perror(&quotpopen&quot);\newline    	    info = g_strdup_printf(_(&quotFailed changing password or adding samba user: %s\\n&quot), username);\newline    	    show_info(info);\newline    	    g_free(info);\newline	    g_free(cmd);\newline    	    return;\newline	}\newline	fputs(password, fp);\newline	fputs(&quot\\n&quot, fp);\newline	fputs(password, fp);\newline	fputs(&quot\\n&quot, fp);\newline	pclose(fp);\newline	g_free(cmd);\newline\newline	/* Also change the system accounts password. */\newline	password_user(username, password);\newline    }\newline\newline\newline    /* Change this users system comment */\newline    cmd = g_strdup_printf(&quot%s -c &#039%s&#039 &#039%s&#039\\n&quot, &quotusermod&quot, comment, username);\newline    if((fp=popen(cmd, &quotw&quot))==NULL)\newline    {\newline	perror(&quotpopen&quot);\newline    	info = g_strdup_printf(_(&quotFailed changing system comment for samba user: %s\\n&quot), username);\newline    	show_info(info);\newline    	g_free(info);\newline	g_free(cmd);\newline    	return;\newline    }\newline    pclose(fp);\newline    g_free(cmd);\newline\newline    /* Maybe fix: Change other settings as well */\newline    //    printf(&quotSelected group : %s\\n&quot, groupname);\newline    //    printf(&quotSelected home: %s\\n&quot, homedir);\newline    //    printf(&quotSelected Shell: %s\\n&quot, shell);\newline\newline\newline    /* Create directory: /var/samba/profiles/UserName */\newline    cmd = g_strdup_printf(&quotmkdir -p %s/samba/profiles/%s&quot, LOCALSTATEDIR, username);\newline    if( ! run_command(cmd) )\newline    {\newline    	info = g_strdup_printf(_(&quotError creating directory: %s/samba/profiles/%s\\n&quot), LOCALSTATEDIR, username);\newline    	show_info(info);\newline    	g_free(info);\newline	g_free(cmd);\newline	return;\newline    }\newline    g_free(cmd);\newline\newline    /* Chown directory: /var/samba/profiles/UserName to this user:group */\newline    cmd = g_strdup_printf(&quotchown %s:%s %s/samba/profiles/%s&quot, username, groupname, LOCALSTATEDIR, username);\newline    if( ! run_command(cmd) )\newline    {\newline    	info = g_strdup_printf(_(&quotError chowning directory: %s/samba/profiles/%s\\n&quot), LOCALSTATEDIR, username);\newline    	show_info(info);\newline    	g_free(info);\newline	g_free(cmd);\newline	return;\newline    }\newline    g_free(cmd);\newline\newline\newline    /* Clear the password field */\newline    gtk_entry_set_text(GTK_ENTRY(widgets-&gtuser_set_entry[1]), &quot&quot);\newline\newline    /* Update the user tab */\newline    populate_users(widgets);\newline    select_first_user(widgets); /* Fixme: Should be scroll to and select this user */\newline    populate_user_settings(widgets);\newline}\newline",Add or change the system and samba user \newline,5745687,modsym.c,"void GModSymbol_draw(GModSymbol *ms,int x,int y,int r,int isBold)\newline{\newline  Icon *I = GModSymbol_getIcon(ms,r,isBold);\newline  int ix,iy;\newline\newline  isBold = (isBold != 0);	/* Make sure isBold is only 0 or 1 */\newline\newline#if 0\newline  printf(&quotGModSymbol_draw(x=%d, y=%d, r=%d, b=%d)\\n&quot,x,y,r,isBold);\newline#endif\newline\newline  if (!ms-&gtms_finalized) GModSymbol_updateCenter(ms);\newline\newline  ix = ctow_x(x) + ms-&gtms_ix[isBold][r];\newline  iy = ctow_y(y) + ms-&gtms_iy[isBold][r];\newline\newline  Icon_draw(TkGate.D,TkGate.W,TkGate.moduleGC,ix,iy,I);\newline}\newline",\newline \newline Draw a symbol at the specified position.\newline \newline Parameters:\newline ms Symbol to draw\newline x x-coordinate at which to draw symbol\newline y y-coordinate at which to draw symbol\newline r rotation for symbol\newline isBold Non-zero for bold version of symbol\newline \newline \newline,161141,backend_dxf.c,"static void pseudo_quad(FILE *fout, const char *layer, dpoint_t A, dpoint_t C, dpoint_t B) {\newline  dpoint_t v, w;\newline  double v2, w2, vw, vxw, nvw;\newline  double a, b, c, y;\newline  dpoint_t G;\newline  double bulge1, bulge2;\newline\newline  v = sub(A, C);\newline  w = sub(B, C);\newline\newline  v2 = iprod(v, v);\newline  w2 = iprod(w, w);\newline  vw = iprod(v, w);\newline  vxw = xprod(v, w);\newline  nvw = sqrt(v2 * w2);\newline\newline  a = v2 + 2*vw + w2;\newline  b = v2 + 2*nvw + w2;\newline  c = 4*nvw;\newline  if (vxw == 0 || a == 0) {\newline    goto degenerate;\newline  }\newline  /* assert: a,b,c &gt= 0, b*b - a*c &gt= 0, and 0 &lt= b - sqrt(b*b - a*c) &lt= a */\newline  y = (b - sqrt(b*b - a*c)) / a;\newline  G = interval(y, C, interval(0.5, A, B));\newline\newline  bulge1 = bulge(sub(A,G), v);\newline  bulge2 = bulge(w, sub(B,G));\newline\newline  ship_vertex(fout, layer, A, -bulge1);\newline  ship_vertex(fout, layer, G, -bulge2);\newline  return;\newline\newline degenerate:\newline  ship_vertex(fout, layer, A, 0);\newline\newline  return;\newline}\newline","Output vertices (with bulges) corresponding to a smooth pair of\newlinecircular arcs from A to B, tangent to AC at A and to CB at\newlineB. Segments are meant to be concatenated, so don&#039t output the final\newlinevertex. \newline",2215026,detect.c,"static int lfs_detect_minutiae_V2(MINUTIAE **ominutiae,\newline                        int **odmap, int **olcmap, int **olfmap, int **ohcmap,\newline                        int *omw, int *omh,\newline                        unsigned char **obdata, int *obw, int *obh,\newline                        unsigned char *idata, const int iw, const int ih,\newline                        const LFSPARMS *lfsparms)\newline{\newline   unsigned char *pdata, *bdata;\newline   int pw, ph, bw, bh;\newline   DIR2RAD *dir2rad;\newline   DFTWAVES *dftwaves;\newline   ROTGRIDS *dftgrids;\newline   ROTGRIDS *dirbingrids;\newline   int *direction_map, *low_contrast_map, *low_flow_map, *high_curve_map;\newline   int mw, mh;\newline   int ret, maxpad;\newline   MINUTIAE *minutiae;\newline\newline   /******************/\newline   /* INITIALIZATION */\newline   /******************/\newline\newline   /* If LOG_REPORT defined, open log report file. */\newline   if((ret = open_logfile()))\newline      /* If system error, exit with error code. */\newline      return(ret);\newline\newline   /* Determine the maximum amount of image padding required to support */\newline   /* LFS processes.                                                    */\newline   maxpad = get_max_padding_V2(lfsparms-&gtwindowsize, lfsparms-&gtwindowoffset,\newline                          lfsparms-&gtdirbin_grid_w, lfsparms-&gtdirbin_grid_h);\newline\newline   /* Initialize lookup table for converting integer directions */\newline   /* to angles in radians.                                     */\newline   if((ret = init_dir2rad(&ampdir2rad, lfsparms-&gtnum_directions))){\newline      /* Free memory allocated to this point. */\newline      return(ret);\newline   }\newline\newline   /* Initialize wave form lookup tables for DFT analyses. */\newline   /* used for direction binarization.                             */\newline   if((ret = init_dftwaves(&ampdftwaves, g_dft_coefs, lfsparms-&gtnum_dft_waves,\newline                        lfsparms-&gtwindowsize))){\newline      /* Free memory allocated to this point. */\newline      free_dir2rad(dir2rad);\newline      return(ret);\newline   }\newline\newline   /* Initialize lookup table for pixel offsets to rotated grids */\newline   /* used for DFT analyses.                                     */\newline   if((ret = init_rotgrids(&ampdftgrids, iw, ih, maxpad,\newline                        lfsparms-&gtstart_dir_angle, lfsparms-&gtnum_directions,\newline                        lfsparms-&gtwindowsize, lfsparms-&gtwindowsize,\newline                        RELATIVE2ORIGIN))){\newline      /* Free memory allocated to this point. */\newline      free_dir2rad(dir2rad);\newline      free_dftwaves(dftwaves);\newline      return(ret);\newline   }\newline\newline   /* Pad input image based on max padding. */\newline   if(maxpad &gt 0){   /* May not need to pad at all */\newline      if((ret = pad_uchar_image(&amppdata, &amppw, &ampph, idata, iw, ih,\newline                             maxpad, lfsparms-&gtpad_value))){\newline         /* Free memory allocated to this point. */\newline         free_dir2rad(dir2rad);\newline         free_dftwaves(dftwaves);\newline         free_rotgrids(dftgrids);\newline         return(ret);\newline      }\newline   }\newline   else{\newline      /* If padding is unnecessary, then copy the input image. */\newline      pdata = (unsigned char *)malloc(iw*ih);\newline      if(pdata == (unsigned char *)NULL){\newline         /* Free memory allocated to this point. */\newline         free_dir2rad(dir2rad);\newline         free_dftwaves(dftwaves);\newline         free_rotgrids(dftgrids);\newline         fprintf(stderr, &quotERROR : lfs_detect_minutiae_V2 : malloc : pdata\\n&quot);\newline         return(-580);\newline      }\newline      memcpy(pdata, idata, iw*ih);\newline      pw = iw;\newline      ph = ih;\newline   }\newline\newline   /* Scale input image to 6 bits [0..63] */\newline   /* !!! Would like to remove this dependency eventualy !!!     */\newline   /* But, the DFT computations will need to be changed, and     */\newline   /* could not get this work upon first attempt. Also, if not   */\newline   /* careful, I think accumulated power magnitudes may overflow */\newline   /* doubles.                                                   */\newline   bits_8to6(pdata, pw, ph);\newline\newline   print2log(&quot\\nINITIALIZATION AND PADDING DONE\\n&quot);\newline\newline   /******************/\newline   /*      MAPS      */\newline   /******************/\newline\newline   /* Generate block maps from the input image. */\newline   if((ret = gen_image_maps(&ampdirection_map, &amplow_contrast_map,\newline                    &amplow_flow_map, &amphigh_curve_map, &ampmw, &ampmh,\newline                    pdata, pw, ph, dir2rad, dftwaves, dftgrids, lfsparms))){\newline      /* Free memory allocated to this point. */\newline      free_dir2rad(dir2rad);\newline      free_dftwaves(dftwaves);\newline      free_rotgrids(dftgrids);\newline      free(pdata);\newline      return(ret);\newline   }\newline   /* Deallocate working memories. */\newline   free_dir2rad(dir2rad);\newline   free_dftwaves(dftwaves);\newline   free_rotgrids(dftgrids);\newline\newline   print2log(&quot\\nMAPS DONE\\n&quot);\newline\newline   /******************/\newline   /* BINARIZARION   */\newline   /******************/\newline\newline   /* Initialize lookup table for pixel offsets to rotated grids */\newline   /* used for directional binarization.                         */\newline   if((ret = init_rotgrids(&ampdirbingrids, iw, ih, maxpad,\newline                        lfsparms-&gtstart_dir_angle, lfsparms-&gtnum_directions,\newline                        lfsparms-&gtdirbin_grid_w, lfsparms-&gtdirbin_grid_h,\newline                        RELATIVE2CENTER))){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      return(ret);\newline   }\newline\newline   /* Binarize input image based on NMAP information. */\newline   if((ret = binarize_V2(&ampbdata, &ampbw, &ampbh,\newline                      pdata, pw, ph, direction_map, mw, mh,\newline                      dirbingrids, lfsparms))){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      free_rotgrids(dirbingrids);\newline      return(ret);\newline   }\newline\newline   /* Deallocate working memory. */\newline   free_rotgrids(dirbingrids);\newline\newline   /* Check dimension of binary image.  If they are different from */\newline   /* the input image, then ERROR.                                 */\newline   if((iw != bw) || (ih != bh)){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      free(bdata);\newline      fprintf(stderr, &quotERROR : lfs_detect_minutiae_V2 :&quot);\newline      fprintf(stderr,&quotbinary image has bad dimensions : %d, %d\\n&quot,\newline              bw, bh);\newline      return(-581);\newline   }\newline\newline   print2log(&quot\\nBINARIZATION DONE\\n&quot);\newline\newline   /******************/\newline   /*   DETECTION    */\newline   /******************/\newline\newline   /* Convert 8-bit grayscale binary image [0,255] to */\newline   /* 8-bit binary image [0,1].                       */\newline   gray2bin(1, 1, 0, bdata, iw, ih);\newline\newline   /* Allocate initial list of minutia pointers. */\newline   if((ret = alloc_minutiae(&ampminutiae, MAX_MINUTIAE))){\newline      return(ret);\newline   }\newline\newline   /* Detect the minutiae in the binarized image. */\newline   if((ret = detect_minutiae_V2(minutiae, bdata, iw, ih,\newline                             direction_map, low_flow_map, high_curve_map,\newline                             mw, mh, lfsparms))){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      free(bdata);\newline      return(ret);\newline   }\newline\newline   if((ret = remove_false_minutia_V2(minutiae, bdata, iw, ih,\newline                       direction_map, low_flow_map, high_curve_map, mw, mh,\newline                       lfsparms))){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      free(bdata);\newline      free_minutiae(minutiae);\newline      return(ret);\newline   }\newline\newline   print2log(&quot\\nMINUTIA DETECTION DONE\\n&quot);\newline\newline   /******************/\newline   /*  RIDGE COUNTS  */\newline   /******************/\newline   if((ret = count_minutiae_ridges(minutiae, bdata, iw, ih, lfsparms))){\newline      /* Free memory allocated to this point. */\newline      free(pdata);\newline      free(direction_map);\newline      free(low_contrast_map);\newline      free(low_flow_map);\newline      free(high_curve_map);\newline      free_minutiae(minutiae);\newline      return(ret);\newline   }\newline\newline\newline   print2log(&quot\\nNEIGHBOR RIDGE COUNT DONE\\n&quot);\newline\newline   /******************/\newline   /*    WRAP-UP     */\newline   /******************/\newline\newline   /* Convert 8-bit binary image [0,1] to 8-bit */\newline   /* grayscale binary image [0,255].           */\newline   gray2bin(1, 255, 0, bdata, iw, ih);\newline\newline   /* Deallocate working memory. */\newline   free(pdata);\newline\newline   /* Assign results to output pointers. */\newline   *odmap = direction_map;\newline   *olcmap = low_contrast_map;\newline   *olfmap = low_flow_map;\newline   *ohcmap = high_curve_map;\newline   *omw = mw;\newline   *omh = mh;\newline   *obdata = bdata;\newline   *obw = bw;\newline   *obh = bh;\newline   *ominutiae = minutiae;\newline\newline   /* If LOG_REPORT defined, close log report file. */\newline   if((ret = close_logfile()))\newline      return(ret);\newline\newline   return(0);\newline}\newline","\newline#cat: lfs_detect_minutiae_V2 - Takes a grayscale fingerprint image (of\newline#cat: arbitrary size), and returns a set of image block maps,\newline#cat: a binarized image designating ridges from valleys,\newline#cat: and a list of minutiae (including position, reliability,\newline#cat: type, direction, neighbors, and ridge counts to neighbors).\newline#cat: The image maps include a ridge flow directional map,\newline#cat: a map of low contrast blocks, a map of low ridge flow blocks.\newline#cat: and a map of high-curvature blocks.\newlineInput:\newlineidata - input 8-bit grayscale fingerprint image data\newlineiw - width (in pixels) of the image\newlineih - height (in pixels) of the image\newlinelfsparms - parameters and thresholds for controlling LFS\newlineOutput:\newlineominutiae - resulting list of minutiae\newlineodmap - resulting Direction Map\newline{invalid (-1) or valid ridge directions}\newlineolcmap - resulting Low Contrast Map\newline{low contrast (TRUE), high contrast (FALSE)}\newlineolfmap - resulting Low Ridge Flow Map\newline{low ridge flow (TRUE), high ridge flow (FALSE)}\newlineohcmap - resulting High Curvature Map\newline{high curvature (TRUE), low curvature (FALSE)}\newlineomw - width (in blocks) of image maps\newlineomh - height (in blocks) of image maps\newlineobdata - resulting binarized image\newline{0 = black pixel (ridge) and 255 = white pixel (valley)}\newlineobw - width (in pixels) of the binary image\newlineobh - height (in pixels) of the binary image\newlineReturn Code:\newlineZero - successful completion\newlineNegative - system error\newline \newline",6347158,wfd.c,"int16_t wfd_mix(int16_t a, int16_t b) {\newline  int a_t;\newline  int b_t;\newline  int r1;\newline  int16_t ret=0;\newline\newline  a_t = ((int)a)+32768;\newline  b_t = ((int)b)+32768;\newline\newline  if (a_t &lt= 32768 &amp&amp b_t &lt= 32768) {\newline    r1 = (a_t * b_t) / 32768;\newline  } else {\newline    r1 = 2*(a_t+b_t) - (a_t*b_t)/32768 - 65536;\newline    if (r1&gt=65536) {\newline      r1 = 65535;\newline    }\newline  }\newline  r1 = r1 - 32768;\newline  ret = ((int16_t)r1);\newline  return ret;\newline}\newline",\newline mix sample A with sample B\newline \newline @param a sample A\newline @param b sample B\newline @return sample of A mix B\newline \newline,326638,main.cpp,"static int32_t engine_handle_input(struct android_app* app, AInputEvent* event) {\newline    struct engine* engine = (struct engine*)app-&gtuserData;\newline    if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {\newline        engine-&gtstate.x = AMotionEvent_getX(event, 0);\newline        engine-&gtstate.y = AMotionEvent_getY(event, 0);\newline        return 1;\newline    }\newline    return 0;\newline}\newline",\newline Process the next input event.\newline \newline,3923169,minclookup.c,"static void lookup_in_table(double index, Lookup_Table *lookup_table,\newline                            int discrete_values, double null_value[],\newline                            double output_value[])\newline{\newline   int vector_length, nentries;\newline   int start, length, mid;\newline   int offset, offset1, offset2, ivalue;\newline   double value1, value2, *result, frac, rfrac, denom;\newline\newline   /* Check for bad lookup table */\newline   nentries = lookup_table-&gtnentries;\newline   vector_length = lookup_table-&gtvector_length;\newline   if ((nentries &lt 1) || (vector_length &lt 1)) {\newline      (void) fprintf(stderr, &quotBad table size %d x %d\\n&quot, \newline                     nentries, vector_length);\newline      exit(EXIT_FAILURE);\newline   }\newline\newline   /* Round values if needed */\newline   if (discrete_values) index = rint(index);\newline\newline   /* Search the table for the value */\newline   start = 0;\newline   length = nentries;\newline   while (length &gt 1) {\newline      mid = start + length / 2;\newline      offset = mid*(vector_length+1);\newline      if (index &lt lookup_table-&gttable[offset]) {\newline         length = mid - start;\newline      }\newline      else {\newline         length = start + length - mid;\newline         start = mid;\newline      }\newline   }\newline\newline   /* Add a special check for the end of the table */\newline   if (nentries &gt 1) {\newline      offset1 = vector_length+1;\newline      offset2 = (nentries-2) * (vector_length+1);\newline      if ((start == 0) &amp&amp (index == lookup_table-&gttable[offset1]))\newline         start = 1;\newline      else if ((start == nentries-1) &amp&amp \newline               (index == lookup_table-&gttable[offset2]))\newline         start = nentries-2;\newline   }\newline\newline   /* Save the value */\newline   offset = start*(vector_length+1);\newline   if (discrete_values) {\newline      if (index == lookup_table-&gttable[offset])\newline         result = &amplookup_table-&gttable[offset+1];\newline      else\newline         result = null_value;\newline      for (ivalue=0; ivalue &lt vector_length; ivalue++) {\newline         if (result != NULL)\newline            output_value[ivalue] = result[ivalue];\newline         else \newline            output_value[ivalue] = 0.0;\newline      }\newline   }\newline   else {\newline      offset1 = offset;\newline      if (start &lt nentries - 1)\newline         offset2 = offset + vector_length + 1;\newline      else\newline         offset2 = offset;\newline      value1 = lookup_table-&gttable[offset1];\newline      value2 = lookup_table-&gttable[offset2];\newline      denom = value2 - value1;\newline      if (denom != 0.0)\newline         frac = (index - value1) / denom;\newline      else\newline         frac = 0.0;\newline      if (frac &lt 0.0) frac = 0.0;\newline      if (frac &gt 1.0) frac = 1.0;\newline      rfrac = 1.0 - frac;\newline      for (ivalue=0; ivalue &lt vector_length; ivalue++) {\newline         output_value[ivalue] = \newline            rfrac * lookup_table-&gttable[offset1 + 1 + ivalue] +\newline            frac  * lookup_table-&gttable[offset2 + 1 + ivalue];\newline      }\newline   }\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : lookup_in_table\newline@INPUT : index - value to look up in table\newlinelookup_table - the lookup table (big surprise!)\newlinediscrete_values - flag indicating whether the table should\newlinebe considered continuous in the range 0 to 1 (FALSE) or \newlinediscrete, with integer values that should be rounded (TRUE).\newlineIf the table is continuous, then interpolation between\newlinetable entries is done (the first and last values propagate\newlinebeyond the bounds). If the table is discrete, then the \newlinenull_value is used for indices that are not found.\newlinenull_value - array specifying the null values to use if\newlinethe index is not found in the table. Only applies to\newlinediscrete valued tables (may be NULL otherwise).\newline@OUTPUT : output_value - vector of output values.\newline@RETURNS : (nothing)\newline@DESCRIPTION: Routine to look up a value in the table.\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : December 8, 1994 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline",1480826,parser_libxml2.c,"static char **_convert_attrs(parser_t *parser, int nattrs,\newline                             const xmlChar **attrs)\newline{\newline    int c, i, o, len;\newline    char *value;\newline    char **ret;\newline\newline    if (!attrs) return NULL;\newline\newline    ret = xmpp_alloc(parser-&gtctx, (nattrs+1)*2*sizeof(char*));\newline    if (!ret) return NULL;\newline    memset(ret, 0, (nattrs+1)*2*sizeof(char*));\newline\newline    for (c = 0; c &lt nattrs; c++) {\newline        i = c * 5;\newline        o = c * 2;\newline\newline        len = attrs[i+4] - attrs[i+3];\newline        value = xmpp_alloc(parser-&gtctx, len + 1);\newline        if (value) {\newline            memcpy(value, attrs[i+3], len);\newline            value[len] = &#039\\0&#039;\newline            ret[o] = xmpp_strdup(parser-&gtctx, (char*)attrs[i]);\newline            ret[o+1] = value;\newline        }\newline    }\newline\newline    return ret;\newline}\newline","SAX2 gives us the attrs in an incredibly inconvenient array,\newline convert it to what the start callback is expecting \newline",3213765,playgame.c,"static void CheckFishies(int* fishies, int* splats)\newline{\newline  int forward, backward;\newline  struct fishypoo fish_temp;\newline  struct splatter splat_temp;\newline\newline  LOG( &quotEntering CheckFishies()\\n&quot );\newline\newline	/* move any fish from the rear to fill up gaps in the\newline	 * front\newline	 */\newline	forward = 0;\newline	backward = MAX_FISHIES_HARD;\newline	while (forward &lt backward) {\newline		while (backward &gt 0 &amp&amp !fish_object[backward].alive)\newline			backward--;\newline		while (forward &lt backward &amp&amp fish_object[forward].alive)\newline			forward++;\newline		if ((fish_object[backward].alive) &amp&amp (!fish_object[forward].alive)) {\newline			/* swap alive to be infront of dead */\newline			fish_temp = fish_object[backward];\newline			fish_object[backward] = fish_object[forward];\newline			fish_object[forward] = fish_temp;\newline		}\newline	}\newline	\newline	/* same thing for splats */\newline\newline	forward = 0;\newline	backward = MAX_FISHIES_HARD;\newline	while (forward &lt backward) {\newline		while (backward &gt 0 &amp&amp !splat_object[backward].alive)\newline			backward--;\newline		while (forward &lt backward &amp&amp splat_object[forward].alive)\newline			forward++;\newline		if ((splat_object[backward].alive) &amp&amp (!splat_object[forward].alive)) {\newline			/* swap alive to be infront of dead */\newline			splat_temp = splat_object[backward];\newline			splat_object[backward] = splat_object[forward];\newline			splat_object[forward] = splat_temp;\newline		}\newline	}\newline\newline	/* update the count for fishies &amp splats */\newline\newline	*splats = *fishies = 0;\newline\newline	for (forward = 0; forward &lt MAX_FISHIES_HARD; forward++)\newline		if (fish_object[forward].alive)\newline			*fishies+=1;\newline		else\newline			break;\newline\newline	for (forward = 0; forward &lt MAX_FISHIES_HARD; forward++)\newline		if (splat_object[forward].alive)\newline			*splats+=1;\newline		else\newline			break;\newline\newline  LOG(&quotLeaving CheckFishies()\\n&quot);\newline}\newline",\newlineCheckFishies : Check all the fishies and splats.\newlinesort the splats and fishies\newline \newline,5282901,lj_tab.c,"static void resizetab(lua_State *L, GCtab *t, uint32_t asize, uint32_t hbits)\newline{\newline  Node *oldnode = noderef(t-&gtnode);\newline  uint32_t oldasize = t-&gtasize;\newline  uint32_t oldhmask = t-&gthmask;\newline  if (asize &gt oldasize) {  /* Array part grows? */\newline    TValue *array;\newline    uint32_t i;\newline    if (asize &gt LJ_MAX_ASIZE)\newline      lj_err_msg(L, LJ_ERR_TABOV);\newline    if (LJ_MAX_COLOSIZE != 0 &amp&amp t-&gtcolo &gt 0) {\newline      /* A colocated array must be separated and copied. */\newline      TValue *oarray = tvref(t-&gtarray);\newline      array = lj_mem_newvec(L, asize, TValue);\newline      t-&gtcolo = (int8_t)(t-&gtcolo | 0x80);  /* Mark as separated (colo &lt 0). */\newline      for (i = 0; i &lt oldasize; i++)\newline	copyTV(L, &amparray[i], &ampoarray[i]);\newline    } else {\newline      array = (TValue *)lj_mem_realloc(L, tvref(t-&gtarray),\newline			  oldasize*sizeof(TValue), asize*sizeof(TValue));\newline    }\newline    setmref(t-&gtarray, array);\newline    t-&gtasize = asize;\newline    for (i = oldasize; i &lt asize; i++)  /* Clear newly allocated slots. */\newline      setnilV(&amparray[i]);\newline  }\newline  /* Create new (empty) hash part. */\newline  if (hbits) {\newline    newhpart(L, t, hbits);\newline    clearhpart(t);\newline  } else {\newline    global_State *g = G(L);\newline    setmref(t-&gtnode, &ampg-&gtnilnode);\newline    t-&gthmask = 0;\newline  }\newline  if (asize &lt oldasize) {  /* Array part shrinks? */\newline    TValue *array = tvref(t-&gtarray);\newline    uint32_t i;\newline    t-&gtasize = asize;  /* Note: This &#039shrinks&#039 even colocated arrays. */\newline    for (i = asize; i &lt oldasize; i++)  /* Reinsert old array values. */\newline      if (!tvisnil(&amparray[i]))\newline	copyTV(L, lj_tab_setinth(L, t, (int32_t)i), &amparray[i]);\newline    /* Physically shrink only separated arrays. */\newline    if (LJ_MAX_COLOSIZE != 0 &amp&amp t-&gtcolo &lt= 0)\newline      setmref(t-&gtarray, lj_mem_realloc(L, array,\newline	      oldasize*sizeof(TValue), asize*sizeof(TValue)));\newline  }\newline  if (oldhmask &gt 0) {  /* Reinsert pairs from old hash part. */\newline    global_State *g;\newline    uint32_t i;\newline    for (i = 0; i &lt= oldhmask; i++) {\newline      Node *n = &ampoldnode[i];\newline      if (!tvisnil(&ampn-&gtval))\newline	copyTV(L, lj_tab_set(L, t, &ampn-&gtkey), &ampn-&gtval);\newline    }\newline    g = G(L);\newline    lj_mem_freevec(g, oldnode, oldhmask+1, Node);\newline  }\newline}\newline",Resize a table to fit the new array/hash part sizes. \newline,1396351,c_interface.cpp,"extern &quotC&quot Expr vc_bvCreateMemoryArray(VC vc, char * arrayName) {\newline  Type bv8  = vc_bvType(vc,8);\newline  Type bv32 = vc_bvType(vc,32);\newline\newline  Type malloced_mem0 = vc_arrayType(vc,bv32,bv8);\newline  return vc_varExpr(vc, arrayName, malloced_mem0);\newline}\newline",C pointer support: C interface to support C memory arrays in CVC3 \newline,709773,inout_popenbinaire.c,"int loadSol_popen_bin(pMesh mesh,char *filename,int numsol) {\newline  pSolution    sol;\newline  double       dbuf[ GmfMaxTyp ];\newline  float        fbuf[ GmfMaxTyp ];\newline  double       m[6],lambda[3],eigv[3][3],vp[2][2];\newline  int          inm,k,i,key,nel,size,type,iord,off,typtab[GmfMaxTyp],ver,dim;\newline  char        *ptr,data[128];\newline\newline  // rajout pour popen\newline  int       NumberofSolAT;\newline  char       *natureread;\newline  // rajout binaire\newline  int       KwdCod;\newline  int       cod;\newline  int       NulPos;\newline  int retcode=0;\newline  NumberofSolAT=0;\newline#ifdef WIN32\newline  _setmode(fileno(stdin),O_BINARY);     \newline#endif\newline  // read code\newline  fread( (unsigned char *)&ampcod ,WrdSiz, 1, stdin);\newline  if(cod != 1 ){\newline    printf(&quoterror in reading the binary file .meshb with popen\\n&quot);\newline    exit(1);\newline  }\newline\newline  fread( (unsigned char *)&ampver ,WrdSiz, 1, stdin);\newline  fread( (unsigned char *)&ampKwdCod ,WrdSiz, 1, stdin);\newline  if(KwdCod != GmfDimension ){\newline    printf(&quoterror in reading the binary file .meshb with popen\\n&quot);\newline    exit(1);\newline  }\newline\newline  fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline  fread( (unsigned char *)&ampdim ,WrdSiz, 1, stdin);\newline  natureread=&quotDimension&quot;\newline  printf(&quot.sol: %s %i (mesh)%i (lecture)%i \\n&quot,natureread,dim,mesh-&gtdim,ver);\newline  /*control of the dimension*/\newline  if( dim != mesh-&gtdim ){\newline    fprintf(stderr,&quot  %%%% Wrong dimension %d.\\n&quot,dim);\newline    retcode=0;\newline    goto Lret; \newline    //    return(0);\newline  }\newline\newline  while( !feof(stdin) ){\newline   \newline    fread( (unsigned char *)&ampKwdCod ,WrdSiz, 1, stdin);\newline   \newline    if(KwdCod == GmfSolAtVertices){   \newline      fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline      fread( (unsigned char *)&ampnel ,WrdSiz, 1, stdin);\newline      natureread = &quotSolAtVertices&quot;\newline      if(debug) fprintf(stdout,&quotSolAtVertices : nel %i, mesh-&gtnp %i \\n&quot,nel,mesh-&gtnp);\newline      \newline      if ( nel != mesh-&gtnp ) {\newline	fprintf(stderr,&quot  %%%% Wrong number: %d Solutions discarded\\n&quot,nel-mesh-&gtnp);\newline	retcode=0;\newline	goto Lret; \newline	//	return(0);\newline      }\newline      mesh-&gttypage = 2;\newline      key = GmfSolAtVertices;\newline\newline      /*  type,size,typetab  */  \newline      read_TypeSizeTyptab_bin( &amptype, &ampsize, typtab);\newline      if(debug) printf(&quotsol: %s; type %i; size%i;\\n&quot,natureread, type, size); \newline      fflush(stdout);\newline      /* Reading solutions*/\newline      loadScaVecTen_bin( mesh, 1, dim, ver, nel, type, size, typtab, key);\newline    }\newline    \newline    if( mesh-&gtdim == 2 &amp&amp mesh-&gtnt ){\newline      if(KwdCod == GmfSolAtTriangles){\newline	natureread = &quotSolAtTriangles&quot;\newline	fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline	fread( (unsigned char *)&ampnel ,WrdSiz, 1, stdin);\newline	if(debug) printf(stdout,&quotSolAtTriangles : nel %d, mesh-&gtnt %d \\n&quot,nel,mesh-&gtnt);\newline	if ( nel &amp&amp nel != mesh-&gtnt ) {\newline	  fprintf(stderr,&quot  %%%% Wrong number %d.\\n&quot,nel);\newline	  retcode=0;\newline	  goto Lret; \newline	  // return(0);\newline        }\newline\newline	mesh-&gttypage = 1;\newline	key = GmfSolAtTriangles;\newline\newline	/*  type,size,typetab  */  \newline	read_TypeSizeTyptab_bin( &amptype, &ampsize, typtab);\newline	printf(&quotsol: %s; type %i; size%i;\\n&quot,natureread, type, size); \newline\newline	/* Reading solutions*/\newline	loadScaVecTen_bin( mesh, 1, dim, ver, nel, type, size, typtab, key);\newline\newline      }\newline      \newline    }\newline\newline    if( mesh-&gtdim == 2 &amp&amp mesh-&gtnq ){\newline      if( KwdCod == GmfSolAtQuadrilaterals ){	\newline	natureread = &quotSolAtQuadrilaterals&quot;\newline	fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline	fread( (unsigned char *)&ampnel ,WrdSiz, 1, stdin);\newline	if(debug)  fprintf(stdout,&quotSolAtQuadrilaterals : nel %i, mesh-&gtnq %i \\n&quot,nel,mesh-&gtnq);\newline	if ( nel &amp&amp nel != mesh-&gtnq ) {\newline	  fprintf(stderr,&quot  %%%% Wrong number %d.\\n&quot,nel);\newline	  retcode=0;\newline	  goto Lret; \newline	  //return(0);\newline	}\newline	\newline	mesh-&gttypage = 1;\newline	key = GmfSolAtQuadrilaterals;\newline\newline	/*  type,size,typetab  */  \newline	read_TypeSizeTyptab_bin( &amptype, &ampsize, typtab);\newline\newline	/* Reading solutions*/\newline	loadScaVecTen_bin( mesh, 1, dim, ver, nel, type, size, typtab, key);\newline      }\newline    }\newline\newline    if( mesh-&gtdim == 3 &amp&amp mesh-&gtntet ){\newline      if( KwdCod == GmfSolAtTetrahedra ){\newline	natureread = &quotSolAtTetrahedra&quot;\newline	fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline	fread( (unsigned char *)&ampnel ,WrdSiz, 1, stdin);\newline	if(debug)  fprintf(stdout,&quotSolAtTetrahedra : nel %i, mesh-&gtntet %i \\n&quot,nel,mesh-&gtntet);\newline	if ( nel &amp&amp nel != mesh-&gtntet ) {\newline	  fprintf(stderr,&quot  %%%% Wrong number %d.\\n&quot,nel); \newline	  retcode=0;\newline	  goto Lret; \newline	  //return(0);\newline	}\newline	mesh-&gttypage = 1;\newline	key = GmfSolAtTetrahedra;\newline\newline	/*  type,size,typetab  */  \newline	read_TypeSizeTyptab_bin( &amptype, &ampsize, typtab);\newline\newline	/* Reading solutions */\newline	loadScaVecTen_bin( mesh, 1, dim, ver, nel, type, size, typtab, key);\newline\newline      }\newline    }\newline\newline    if( mesh-&gtdim == 3 &amp&amp mesh-&gtnhex ){\newline      if(  KwdCod == GmfSolAtHexahedra ){\newline	natureread = &quotSolAtHexahedra&quot;\newline	fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline	fread( (unsigned char *)&ampnel ,WrdSiz, 1, stdin);\newline	if(debug)  fprintf(stdout,&quotSolAtHexahedra : nel %d, mesh-&gtnhex %d \\n&quot,nel,mesh-&gtnhex);\newline	if ( nel &amp&amp nel != mesh-&gtnhex ) {\newline	  fprintf(stderr,&quot  %%%% Wrong number %d.\\n&quot,nel);\newline	  GmfCloseMesh(inm);\newline	  retcode=0;\newline	  goto Lret; \newline	  //return(0);\newline	}\newline	mesh-&gttypage = 1;\newline	key = GmfSolAtHexahedra;\newline\newline	/*  type,size,typetab  */  \newline	read_TypeSizeTyptab_bin( &amptype, &ampsize, typtab);\newline\newline	/* Reading solutions*/\newline	loadScaVecTen_bin( mesh, 1, dim, ver, nel, type, size, typtab, key);\newline      }\newline    }\newline    if( KwdCod == GmfEnd ){\newline      fread( (unsigned char *)&ampNulPos ,WrdSiz, 1, stdin);\newline      if(debug)  printf(&quotEnd of solution\\n&quot);\newline      if( ddebug ) printf(&quotReading of mesh file is finished&quot);\newline      break;\newline    }    \newline  }\newline  retcode=1;\newline Lret:\newline#ifdef WIN32\newline  _setmode(fileno(stdin),O_BINARY);     \newline#endif \newline  return(retcode);\newline}\newline",load solution (metric) \newline,5579636,gnupg.c,PHPC_OBJ_HANDLER_CREATE_EX(gnupg)\newline{\newline	PHPC_OBJ_HANDLER_CREATE_EX_INIT(gnupg);\newline\newline	gnupg_res_init(PHPC_THIS TSRMLS_CC);\newline\newline	PHPC_OBJ_HANDLER_CREATE_EX_RETURN(gnupg);\newline}\newline,{{{ create_ex gnupg \newline,4514625,smsc_smasi.c,"static Octstr *get_originator_type(SMASI *smasi, Octstr *originator) \newline{\newline    /* International or alphanumeric sender? */\newline    if (octstr_get_char(originator, 0) == &#039+&#039) {\newline        if (!octstr_check_range(originator, 1, 256, gw_isdigit)) {\newline            return octstr_format(&quot%ld&quot, GSM_ADDR_TON_ALPHANUMERIC);\newline        } else {\newline           /* Numeric sender address with + in front: The + has to be\newline            * removed from this international number.\newline            */\newline           octstr_delete(originator, 0, 1);\newline           return octstr_format(&quot%ld&quot, GSM_ADDR_TON_INTERNATIONAL);\newline        }\newline    } else if (!octstr_check_range(originator, 0, 256, gw_isdigit)) {\newline       return octstr_format(&quot%ld&quot, GSM_ADDR_TON_ALPHANUMERIC);\newline    }\newline\newline    /* Return the default value. */\newline    return octstr_format(&quot%ld&quot, GSM_ADDR_TON_INTERNATIONAL);\newline}\newline",\newline Determine the originator (sender number) type based on the number. Will\newline change the originator number if necessary.\newline \newline,2469249,softhddev.c,void Play(void)\newline{\newline    TrickSpeed(0);			// normal play\newline    SkipAudio = 0;\newline    AudioPlay();\newline}\newline,\newline Sets the device into play mode.\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,101287,floating.c,"void floating_resize(Con *floating_con, int x, int y) {\newline    DLOG(&quotfloating resize to %dx%d px\\n&quot, x, y);\newline    Rect *rect = &ampfloating_con-&gtrect;\newline    Con *focused_con = con_descend_focused(floating_con);\newline    if (focused_con-&gtwindow == NULL) {\newline        DLOG(&quotNo window is focused. Not resizing.\\n&quot);\newline        return;\newline    }\newline    int wi = focused_con-&gtwindow-&gtwidth_increment;\newline    int hi = focused_con-&gtwindow-&gtheight_increment;\newline    rect-&gtwidth = x;\newline    rect-&gtheight = y;\newline    if (wi)\newline        rect-&gtwidth += (wi - 1 - rect-&gtwidth) % wi;\newline    if (hi)\newline        rect-&gtheight += (hi - 1 - rect-&gtheight) % hi;\newline\newline    floating_check_size(floating_con);\newline\newline    /* If this is a scratchpad window, don&#039t auto center it from now on. */\newline    if (floating_con-&gtscratchpad_state == SCRATCHPAD_FRESH)\newline        floating_con-&gtscratchpad_state = SCRATCHPAD_CHANGED;\newline}\newline","\newline Sets size of the CT_FLOATING_CON to specified dimensions. Might limit the\newline actual size with regard to size constraints taken from user settings.\newline Additionally, the dimensions may be upscaled until they&#039re divisible by the\newline window&#039s size hints.\newline \newline \newline",1142151,xwrappers.c,"int guess_bits_per_color(int bits_per_pixel) {\newline	int bits_per_color;\newline	\newline	/* first guess, spread them &quotevenly&quot over R, G, and B */\newline	bits_per_color = bits_per_pixel/3;\newline	if (bits_per_color &lt 1) {\newline		bits_per_color = 1;	/* 1bpp, 2bpp... */\newline	}\newline\newline	/* choose safe values for usual cases: */\newline	if (bits_per_pixel == 8) {\newline		bits_per_color = 2;\newline	} else if (bits_per_pixel == 15 || bits_per_pixel == 16) {\newline		bits_per_color = 5;\newline	} else if (bits_per_pixel == 24 || bits_per_pixel == 32) {\newline		bits_per_color = 8;\newline	}\newline	return bits_per_color;\newline}\newline","\newline used in rfbGetScreen and rfbNewFramebuffer: and estimate to the number\newline of bits per color, of course for some visuals, e.g. 565, the number\newline is not the same for each color. This is just a sane default.\newline \newline",6482585,net_udp.c,"int udp_recv(socket_udp *s, char *buffer, int buflen)\newline{\newline	/* Reads data into the buffer, returning the number of bytes read.   */\newline	/* If no data is available, this returns the value zero immediately. */\newline	/* Note: since we don&#039t care about the source address of the packet  */\newline	/* we receive, this function becomes protocol independent.           */\newline	int		len;\newline\newline	assert(buffer != NULL);\newline	assert(buflen &gt 0);\newline\newline	len = recvfrom(s-&gtfd, buffer, buflen, 0, 0, 0);\newline	if (len &gt 0) {\newline		return len;\newline	}\newline	if (errno != ECONNREFUSED) {\newline		socket_error(&quotrecvfrom&quot);\newline	}\newline	return 0;\newline}\newline","\newline udp_recv:\newline @s: UDP session.\newline @buffer: buffer to read data into.\newline @buflen: length of @buffer.\newline \newline Reads from datagram queue associated with UDP session.\newline \newline Return value: number of bytes read, returns 0 if no data is available.\newline \newline",on,,,,on,,on,on,,,,on,on,,,,,on,on,,on,,,,,,,,,,,,,,,,,,,,,,{},"gives us the attrs in an incredibly inconvenient array,",Check all the fishies and splats.,Resize a table to fit the new array/hash part sizes.,{},load solution,{},{},Sets the device into play mode.,Load an image from the named file.,Sets size of the CT_FLOATING_CON to specified dimensions.,{},{},Reads from datagram queue associated with UDP session.,Add or change the system and samba user,Draw a symbol at the specified position.,Output vertices,{},{},Process the next input event.,{},x,
3X2LT8FDHWIIF5AAC9WRQ967T1B8W8,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:44 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:44 PDT 2019,,,33LKR6A5KEKAZ8JO8LN2DY8PTW51TT,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:53 PDT 2019,Fri Apr 26 13:12:24 PDT 2019,Sun Apr 28 13:12:24 PDT 2019,,,,1471,100% (62/62),100% (62/62),0% (0/0),5211759,fifo.c,inline void *xbt_fifo_get_item_content(xbt_fifo_item_t i)\newline{\newline  return xbt_fifo_getItemcontent(i);\newline}\newline,\newline \\param i a bucket\newline \\return the object stored \\a i.\newline \newline,6484974,pppapi.c,void pppapi_sighup(ppp_pcb *pcb) {\newline  struct pppapi_msg msg;\newline  msg.function = pppapi_do_ppp_sighup;\newline  msg.msg.ppp = pcb;\newline  TCPIP_PPPAPI(&ampmsg);\newline}\newline,\newline Call ppp_sighup() in a thread-safe way by running that function inside the\newline tcpip_thread context.\newline \newline,66357,grpattr.c,"int milist_attr_next ( mihandle_t vol, milisthandle_t handle,\newline                   char *path, int maxpath,\newline                   char *name, int maxname )\newline{\newline  struct milistdata *data = ( struct milistdata * ) handle;\newline  herr_t r;\newline\newline  data-&gtname_ptr = name;\newline  data-&gtname_len = maxname;\newline\newline  for ( ;; ) {\newline\newline\newline    H5E_BEGIN_TRY {\newline      r = H5Aiterate1 ( data-&gtframe_ptr-&gtgrp_id,\newline        &ampdata-&gtframe_ptr-&gtatt_idx, milist_attr_op, data );\newline    } H5E_END_TRY;\newline\newline    if ( r &gt 0 ) {\newline      strncpy ( path, data-&gtframe_ptr-&gtrelpath, maxpath );\newline      return ( MI_NOERROR );\newline    } else {\newline      \newline      if ( data-&gtflags &amp MILIST_RECURSE ) {\newline\newline        return milist_recursion ( handle, path );\newline\newline      } else {\newline        return ( MI_ERROR );\newline      }\newline    }\newline  }\newline\newline  return ( MI_NOERROR );\newline}\newline",Iterate through attributes\newline \newline,218315,fcd.c,"EXTERN FCD_MODE_ENUM fcdGetMode(void)\newline{\newline    hid_device *phd=NULL;\newline    unsigned char aucBufIn[65];\newline    unsigned char aucBufOut[65];\newline    FCD_MODE_ENUM fcd_mode = FCD_MODE_NONE;\newline\newline\newline    phd = fcdOpen();\newline\newline    if (phd == NULL)\newline    {\newline        return FCD_MODE_NONE;\newline    }\newline\newline    /* Send a BL Query Command */\newline    aucBufOut[0] = 0; // Report ID, ignored\newline    aucBufOut[1] = FCD_CMD_BL_QUERY;\newline    hid_write(phd, aucBufOut, 65);\newline    memset(aucBufIn, 0xCC, 65); // Clear out the response buffer\newline    hid_read(phd, aucBufIn, 65);\newline\newline    fcdClose(phd);\newline    phd = NULL;\newline\newline    /* first check status bytes then check which mode */\newline    if (aucBufIn[0]==FCD_CMD_BL_QUERY &amp&amp aucBufIn[1]==1) {\newline\newline        /* In bootloader mode we have the string &quotFCDBL&quot starting at acBufIn[2] **/\newline        if (strncmp((char *)(aucBufIn+2), &quotFCDBL&quot, 5) == 0) {\newline            fcd_mode = FCD_MODE_BL;\newline        }\newline        /* In application mode we have &quotFCDAPP_18.06&quot where the number is the FW version */\newline        else if (strncmp((char *)(aucBufIn+2), &quotFCDAPP&quot, 6) == 0) {\newline            fcd_mode = FCD_MODE_APP;\newline        }\newline        /* either no FCD or firmware less than 18f */\newline        else {\newline            fcd_mode = FCD_MODE_NONE;\newline        }\newline    }\newline\newline    return fcd_mode;\newline}\newline",\\brief Get FCD mode.\newline \\return The current FCD mode.\newline \\sa FCD_MODE_ENUM\newline \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,6050973,gen_ordered.c,"double htsc_spot_circle(double x, double y)\newline{\newline    return 1.0 - (x*x + y*y);\newline}\newline",Various spot functions \newline,4318929,write_run.c,"int Xorriso_burn_track(struct XorrisO *xorriso, off_t write_start_address,\newline                       char *track_source, off_t tsize, int flag)\newline{\newline int ret, fd, profile_number, is_cd= 0, dummy, nwa= -1;\newline int isosize= -1, do_isosize, is_bd= 0, signal_mode;\newline struct burn_drive_info *dinfo;\newline struct burn_drive *drive;\newline struct burn_write_opts *burn_options= NULL;\newline struct burn_disc *disc= NULL;\newline struct burn_session *session= NULL;\newline struct burn_track *track= NULL;\newline struct stat stbuf; \newline off_t fixed_size= 0;\newline struct burn_source *data_src= NULL, *fifo_src= NULL;\newline enum burn_disc_status disc_state;\newline char *reasons= NULL, *profile_name= NULL;\newline char *head_buffer= NULL;\newline\newline Xorriso_alloc_meM(reasons, char, BURN_REASONS_LEN);\newline Xorriso_alloc_meM(profile_name, char, 80);\newline Xorriso_alloc_meM(head_buffer, char, 64 * 1024);\newline\newline ret= Xorriso_may_burn(xorriso, 0);\newline if(ret &lt= 0)\newline   {ret= 0; goto ex;}\newline ret= Xorriso_auto_format(xorriso, 0);\newline if(ret &lt=0 )\newline   {ret= 0; goto ex;}\newline\newline do_isosize= !!(flag&amp2);\newline ret= Xorriso_get_drive_handles(xorriso, &ampdinfo, &ampdrive,\newline                                &quoton attempt to burn track&quot, 2);\newline if(ret&lt=0)\newline   {ret= 0; goto ex;}\newline\newline ret= Xorriso_check_multi(xorriso, drive, 1);\newline if(ret&lt=0) \newline   goto ex;\newline ret= Xorriso_make_write_options(xorriso, drive, &ampburn_options, 0);\newline if(ret&lt=0)\newline   goto ex;\newline\newline disc= burn_disc_create();\newline session= burn_session_create();\newline ret= burn_disc_add_session(disc,session,BURN_POS_END);\newline if(ret==0) {\newline   sprintf(xorriso-&gtinfo_text, &quotCannot add session object to disc object.&quot);\newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFATAL&quot, 0);\newline   goto ex;\newline }\newline track= burn_track_create();\newline if(track_source[0] == &#039-&#039 &amp&amp track_source[1] == 0) {\newline   fd= 0;\newline } else {\newline   if(xorriso-&gtfs &gt= 64)\newline     fd= burn_os_open_track_src(track_source, O_RDONLY, 0);\newline   else\newline     fd= open(track_source, O_RDONLY | O_BINARY);\newline   if(fd&gt=0)\newline     if(fstat(fd,&ampstbuf)!=-1)\newline       if((stbuf.st_mode&ampS_IFMT)==S_IFREG)\newline         fixed_size= stbuf.st_size;\newline }\newline\newline if(fd&gt=0)\newline   data_src= burn_fd_source_new(fd, -1, fixed_size);\newline if(data_src==NULL) {\newline   sprintf(xorriso-&gtinfo_text, &quotCould not open data source &quot);\newline   Text_shellsafe(track_source, xorriso-&gtinfo_text, 1);\newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, errno, &quotFAILURE&quot, 0);\newline   ret= 0; goto ex;\newline }\newline if((do_isosize || xorriso-&gtfs != 0) &amp&amp xorriso-&gtfs &lt 64)\newline   xorriso-&gtfs= 64;\newline if(xorriso-&gtfs &gt 0) {\newline   fifo_src= burn_fifo_source_new(data_src, 2048 + 8 * !!(flag &amp 4),\newline                                  xorriso-&gtfs, 1);\newline   if(fifo_src == NULL) {\newline     sprintf(xorriso-&gtinfo_text, &quotCould not create fifo object of %.f MB&quot,\newline             ((double) xorriso-&gtfs) / 1024.0 / 1024.0);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFATAL&quot, 0);\newline     ret= 0; goto ex;\newline   }\newline } \newline xorriso-&gtpacifier_fifo= fifo_src;\newline if(burn_track_set_source(track, fifo_src == NULL ? data_src : fifo_src)\newline    != BURN_SOURCE_OK) {\newline   sprintf(xorriso-&gtinfo_text,\newline           &quotCannot attach source object to track object&quot);\newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFATAL&quot, 0);\newline   ret= 0; goto ex;\newline }\newline burn_track_set_cdxa_conv(track, !!(flag &amp 4));\newline burn_session_add_track(session, track, BURN_POS_END);\newline burn_source_free(data_src);\newline\newline if(flag&amp1)\newline   /* consider overwriteables with ISO as appendable */\newline   disc_state= isoburn_disc_get_status(drive);\newline else\newline   /* handle overwriteables as always blank */\newline   disc_state= burn_disc_get_status(drive);\newline\newline if(disc_state == BURN_DISC_BLANK || disc_state == BURN_DISC_APPENDABLE) {\newline   /* ok */;\newline } else {\newline   if(disc_state == BURN_DISC_FULL) {\newline     sprintf(xorriso-&gtinfo_text,\newline          &quotClosed media with data detected. Need blank or appendable media.&quot);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline     if(burn_disc_erasable(drive)) {\newline       sprintf(xorriso-&gtinfo_text, &quotTry -blank as_needed\\n&quot);\newline       Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotHINT&quot, 0);\newline     }\newline   } else if(disc_state == BURN_DISC_EMPTY) {\newline     sprintf(xorriso-&gtinfo_text, &quotNo media detected in drive&quot);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline   } else {\newline     sprintf(xorriso-&gtinfo_text,\newline             &quotCannot recognize state of drive and media&quot);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline   }\newline   ret= 0; goto ex;\newline }\newline if(isoburn_needs_emulation(drive))\newline   burn_write_opts_set_multi(burn_options, 0);\newline\newline if(tsize &gt 0) {\newline   fixed_size= tsize;\newline   burn_track_set_size(track, fixed_size);\newline }\newline if(do_isosize) {\newline   ret= burn_fifo_peek_data(xorriso-&gtpacifier_fifo, head_buffer, 64*1024, 0);\newline   if(ret&lt=0) {\newline     Xorriso_process_msg_queues(xorriso,0);\newline     sprintf(xorriso-&gtinfo_text,\newline             &quotCannot obtain first 64 kB from input stream.&quot); \newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline     ret= 0; goto ex;\newline   }\newline   /* read isosize from head_buffer, not from medium */\newline   ret= isoburn_read_iso_head(drive, 0, &ampisosize, head_buffer, (1&lt&lt13));\newline   if(ret&lt=0) {\newline     Xorriso_process_msg_queues(xorriso,0);\newline     sprintf(xorriso-&gtinfo_text,\newline             &quotOption -isosize given but data stream seems not to be ISO 9660&quot); \newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline     ret= 0; goto ex;\newline   }\newline   sprintf(xorriso-&gtinfo_text, &quotSize of ISO 9660 image: %ds&quot, isosize);\newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotNOTE&quot, 0);\newline   fixed_size= ((off_t) (isosize)) * (off_t) 2048;\newline   burn_track_set_size(track, fixed_size);\newline }\newline\newline ret= Xorriso_get_profile(xorriso, &ampprofile_number, profile_name, 2);\newline is_cd= (ret==2);\newline is_bd= (ret == 3);\newline\newline if(isoburn_needs_emulation(drive)) {\newline   if(flag&amp1) {\newline     ret= isoburn_disc_track_lba_nwa(drive, burn_options, 0, &ampdummy, &ampnwa);\newline     Xorriso_process_msg_queues(xorriso,0);\newline     if(ret&lt=0) {\newline       sprintf(xorriso-&gtinfo_text,\newline     &quotCannot obtain next writeable address of emulated multi-session media\\n&quot);\newline       Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline       ret= 0; goto ex;\newline     }\newline     if(nwa == 32 &amp&amp disc_state != BURN_DISC_APPENDABLE)\newline       nwa= 0; /* No automatic toc emulation. Formatter might not be aware. */\newline   } else {\newline     nwa= 0;\newline     if (disc_state == BURN_DISC_APPENDABLE) {\newline       ret= isoburn_disc_track_lba_nwa(drive, burn_options, 0, &ampdummy, &ampnwa);\newline       Xorriso_process_msg_queues(xorriso,0);\newline       if(ret&lt=0) {\newline         sprintf(xorriso-&gtinfo_text,\newline        &quotCannot obtain next writeable address of emulated appendable media\\n&quot);\newline         Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline         ret= 0; goto ex;\newline       }\newline     }\newline   }\newline   burn_write_opts_set_start_byte(burn_options,((off_t) nwa) * (off_t) 2048);\newline }\newline\newline if(write_start_address&gt=0) {\newline   nwa= write_start_address / (off_t) 2048;\newline   if(((off_t) nwa) * (off_t) 2048 &lt write_start_address )\newline     nwa++;\newline   burn_write_opts_set_start_byte(burn_options, ((off_t) nwa) * (off_t) 2048);\newline }\newline\newline if(xorriso-&gtdo_tao) {\newline   if (xorriso-&gtdo_tao &gt 0)\newline     burn_write_opts_set_write_type(burn_options,\newline                                    BURN_WRITE_TAO, BURN_BLOCK_MODE1);\newline   else\newline     burn_write_opts_set_write_type(burn_options,\newline                                    BURN_WRITE_SAO, BURN_BLOCK_SAO);\newline                                    \newline   ret = burn_precheck_write(burn_options, disc, reasons, 0);\newline   if(ret&lt=0) {\newline     sprintf(xorriso-&gtinfo_text,\newline             &quotCannot set write type %s for this medium.\\n&quot,\newline             xorriso-&gtdo_tao &gt 0 ? &quotTAO&quot : &quotSAO&quot);\newline     sprintf(xorriso-&gtinfo_text+strlen(xorriso-&gtinfo_text),\newline             &quotReasons given:\\n%s&quot, reasons);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline     ret= 0; goto ex;\newline   }\newline   sprintf(xorriso-&gtinfo_text, &quotExplicitly chosen write type: %s&quot,\newline           xorriso-&gtdo_tao &gt 0 ? &quotTAO&quot : &quotSAO&quot);\newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotDEBUG&quot, 0);\newline } else {\newline   if(burn_write_opts_auto_write_type(burn_options, disc, reasons, 0) ==\newline      BURN_WRITE_NONE) {\newline     sprintf(xorriso-&gtinfo_text,\newline             &quotFailed to find a suitable write mode with this media.\\n&quot);\newline     sprintf(xorriso-&gtinfo_text+strlen(xorriso-&gtinfo_text),\newline             &quotReasons given:\\n%s&quot, reasons);\newline     Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline     ret= 0; goto ex;\newline   }\newline }\newline\newline ret= Xorriso_sanitize_image_size(xorriso, drive, disc, burn_options, 2);\newline if(ret&lt=0) \newline   goto ex;\newline\newline sprintf(xorriso-&gtinfo_text, &quotBeginning to write data track.\\n&quot);\newline Xorriso_info(xorriso,0);\newline\newline /* Important: do not return until burn_is_aborting() was checked */\newline signal_mode= 1;\newline ret= burn_drive_get_drive_role(drive);\newline if(ret == 1)\newline   signal_mode|= 2;\newline Xorriso_set_signal_handling(xorriso, signal_mode);\newline\newline xorriso-&gtrun_state= 1; /* Indicate that burning has started */\newline burn_disc_write(burn_options, disc);\newline\newline ret= Xorriso_pacifier_loop(xorriso, drive, 2 | (is_cd &lt&lt 4) | (is_bd &lt&lt 5));\newline if(burn_is_aborting(0))\newline   Xorriso_abort(xorriso, 0); /* Never comes back */\newline Xorriso_set_signal_handling(xorriso, 0);\newline if(ret&lt=0)\newline   goto ex;\newline if(!burn_drive_wrote_well(drive)) {\newline   Xorriso_process_msg_queues(xorriso,0);\newline   if(xorriso-&gtauto_close &amp&amp xorriso-&gtdo_close == 0) {\newline     if(burn_drive_was_feat21_failure(drive)) {\newline       sprintf(xorriso-&gtinfo_text,\newline         &quotlibburn indicates failure with writing DVD-RW to appendable state.&quot);\newline       Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotNOTE&quot, 0);\newline       /* Urge caller to call Xorriso_retry_burn_rack() */\newline       ret= 2; goto ex;\newline     }\newline   }\newline   sprintf(xorriso-&gtinfo_text,\newline           &quotlibburn indicates failure with writing.&quot); \newline   Xorriso_msgs_submit(xorriso, 0, xorriso-&gtinfo_text, 0, &quotFAILURE&quot, 0);\newline   ret= 0; goto ex;\newline }\newline\newline if(flag &amp 1) {\newline   ret= Xorriso_update_iso_lba0(xorriso, nwa, isosize, head_buffer, NULL,\newline                                flag &amp 2);\newline   if(ret &lt= 0)\newline     goto ex;\newline }\newline sprintf(xorriso-&gtinfo_text, &quotWriting to &quot);\newline Text_shellsafe(xorriso-&gtoutdev, xorriso-&gtinfo_text, 1);\newline strcat(xorriso-&gtinfo_text, &quot completed successfully.\\n\\n&quot);\newline Xorriso_info(xorriso, 0);\newline ret= 1;\newlineex:;\newline Xorriso_process_msg_queues(xorriso,0);\newline if(disc!=NULL)\newline   burn_disc_free(disc);\newline if(session != NULL)\newline   burn_session_free(session);\newline if(track != NULL)\newline   burn_track_free(track);\newline if(burn_options != NULL)\newline   burn_write_opts_free(burn_options);\newline if(xorriso-&gtpacifier_fifo!=NULL)\newline   burn_source_free(xorriso-&gtpacifier_fifo);\newline xorriso-&gtpacifier_fifo= NULL;\newline xorriso-&gtrun_state= 0; /* Indicate that burning has ended */\newline Xorriso_free_meM(reasons);\newline Xorriso_free_meM(profile_name);\newline Xorriso_free_meM(head_buffer);\newline return(ret);\newline}\newline","@param write_start_address is valid if &gt=0 \newline@param tsize is valid if &gt0\newline@param flag bit0= grow_overwriteable_iso\newlinebit1= do_isosize\newlinebit2= do_xa1 conversion\newline@return &lt=0 error , 1= success\newline2= failure with DVD-RW, please call Xorriso_retry_burn_track()\newline \newline",1424160,flowgrind.c,"static void close_all_flows(void)\newline{\newline	xmlrpc_env env;\newline	xmlrpc_client *client;\newline\newline	for (unsigned short id = 0; id &lt copt.num_flows; id++) {\newline		DEBUG_MSG(LOG_WARNING, &quotclosing flow %u&quot, id);\newline\newline		if (cflow[id].finished[SOURCE] &amp&amp cflow[id].finished[DESTINATION])\newline			continue;\newline\newline		/* We use new env and client, old one might be in fault condition */\newline		xmlrpc_env_init(&ampenv);\newline		xmlrpc_client_create(&ampenv, XMLRPC_CLIENT_NO_FLAGS, &quotFlowgrind&quot, FLOWGRIND_VERSION, NULL, 0, &ampclient);\newline		die_if_fault_occurred(&ampenv);\newline		xmlrpc_env_clean(&ampenv);\newline\newline		foreach(int *i, SOURCE, DESTINATION) {\newline			xmlrpc_value * resultP = 0;\newline\newline			if (cflow[id].endpoint_id[*i] == -1 ||\newline			    cflow[id].finished[*i])\newline				/* Endpoint does not need closing */\newline				continue;\newline\newline			cflow[id].finished[*i] = 1;\newline\newline			xmlrpc_env_init(&ampenv);\newline			xmlrpc_client_call2f(&ampenv, client,\newline					     cflow[id].endpoint[*i].rpc_info-&gtserver_url,\newline					     &quotstop_flow&quot, &ampresultP, &quot({s:i})&quot,\newline					     &quotflow_id&quot, cflow[id].endpoint_id[*i]);\newline			if (resultP)\newline				xmlrpc_DECREF(resultP);\newline\newline			xmlrpc_env_clean(&ampenv);\newline		}\newline\newline		if (active_flows &gt 0)\newline			active_flows--;\newline\newline		xmlrpc_client_destroy(client);\newline		DEBUG_MSG(LOG_WARNING, &quotclosed flow %u&quot, id);\newline	}\newline}\newline","\newline Stop test connections for all flows in a test\newline \newline All the test connection are stopped, but the test connection flow in the\newline controller and in daemon are different. In the controller, test connection\newline are respective to number of flows in a test,but in daemons test connection\newline are respective to flow endpoints. Single daemons can maintain multiple flows\newline endpoints, So controller should stop a daemon only once.\newline \newline",554491,hostlist.c,static int hostname_suffix_width(hostname_t hn)\newline{\newline    assert(hn-&gtsuffix != NULL);\newline    return (int) strlen(hn-&gtsuffix);\newline}\newline,return the width (in characters) of the numeric part of the hostname\newline \newline,3452155,gtkhex.c,"void gtk_hex_set_nibble(GtkHex *gh, gint lower_nibble) {\newline	g_return_if_fail(gh != NULL);\newline	g_return_if_fail(GTK_IS_HEX(gh));\newline\newline	if(gh-&gtselecting) {\newline		bytes_changed(gh, gh-&gtcursor_pos, gh-&gtcursor_pos);\newline		gh-&gtlower_nibble = lower_nibble;\newline	}\newline	else if(gh-&gtselection.end != gh-&gtselection.start) {\newline		guint start = MIN(gh-&gtselection.start, gh-&gtselection.end);\newline		guint end = MAX(gh-&gtselection.start, gh-&gtselection.end);\newline		gh-&gtselection.end = gh-&gtselection.start = 0;\newline		bytes_changed(gh, start, end);\newline		gh-&gtlower_nibble = lower_nibble;\newline	}\newline	else {\newline		hide_cursor(gh);\newline		gh-&gtlower_nibble = lower_nibble;\newline		show_cursor(gh);\newline	}\newline}\newline",\newline moves cursor to UPPER_NIBBLE or LOWER_NIBBLE of the current byte\newline \newline,4928452,sv_phys.c,"trace_t SV_TracePoint(const vec3_t start, int type, prvm_edict_t *passedict, int hitsupercontentsmask)\newline{\newline	prvm_prog_t *prog = SVVM_prog;\newline	int i, bodysupercontents;\newline	int passedictprog;\newline	float pitchsign = 1;\newline	prvm_edict_t *traceowner, *touch;\newline	trace_t trace;\newline	// temporary storage because prvm_vec_t may differ from vec_t\newline	vec3_t touchmins, touchmaxs;\newline	// bounding box of entire move area\newline	vec3_t clipboxmins, clipboxmaxs;\newline	// size when clipping against monsters\newline	vec3_t clipmins2, clipmaxs2;\newline	// start and end origin of move\newline	vec3_t clipstart;\newline	// trace results\newline	trace_t cliptrace;\newline	// matrices to transform into/out of other entity&#039s space\newline	matrix4x4_t matrix, imatrix;\newline	// model of other entity\newline	dp_model_t *model;\newline	// list of entities to test for collisions\newline	int numtouchedicts;\newline	static prvm_edict_t *touchedicts[MAX_EDICTS];\newline\newline	//return SV_TraceBox(start, vec3_origin, vec3_origin, end, type, passedict, hitsupercontentsmask);\newline\newline	VectorCopy(start, clipstart);\newline	VectorClear(clipmins2);\newline	VectorClear(clipmaxs2);\newline#if COLLISIONPARANOID &gt= 3\newline	Con_Printf(&quotmove(%f %f %f)&quot, clipstart[0], clipstart[1], clipstart[2]);\newline#endif\newline\newline	// clip to world\newline	Collision_ClipPointToWorld(&ampcliptrace, sv.worldmodel, clipstart, hitsupercontentsmask);\newline	cliptrace.worldstartsolid = cliptrace.bmodelstartsolid = cliptrace.startsolid;\newline	if (cliptrace.startsolid || cliptrace.fraction &lt 1)\newline		cliptrace.ent = prog-&gtedicts;\newline	if (type == MOVE_WORLDONLY)\newline		goto finished;\newline\newline	if (type == MOVE_MISSILE)\newline	{\newline		// LordHavoc: modified this, was = -15, now -= 15\newline		for (i = 0;i &lt 3;i++)\newline		{\newline			clipmins2[i] -= 15;\newline			clipmaxs2[i] += 15;\newline		}\newline	}\newline\newline	// create the bounding box of the entire move\newline	for (i = 0;i &lt 3;i++)\newline	{\newline		clipboxmins[i] = min(clipstart[i], cliptrace.endpos[i]) + clipmins2[i] - 1;\newline		clipboxmaxs[i] = max(clipstart[i], cliptrace.endpos[i]) + clipmaxs2[i] + 1;\newline	}\newline\newline	// debug override to test against everything\newline	if (sv_debugmove.integer)\newline	{\newline		clipboxmins[0] = clipboxmins[1] = clipboxmins[2] = -999999999;\newline		clipboxmaxs[0] = clipboxmaxs[1] = clipboxmaxs[2] =  999999999;\newline	}\newline\newline	// if the passedict is world, make it NULL (to avoid two checks each time)\newline	if (passedict == prog-&gtedicts)\newline		passedict = NULL;\newline	// precalculate prog value for passedict for comparisons\newline	passedictprog = PRVM_EDICT_TO_PROG(passedict);\newline	// precalculate passedict&#039s owner edict pointer for comparisons\newline	traceowner = passedict ? PRVM_PROG_TO_EDICT(PRVM_serveredictedict(passedict, owner)) : 0;\newline\newline	// clip to entities\newline	// because this uses World_EntitiestoBox, we know all entity boxes overlap\newline	// the clip region, so we can skip culling checks in the loop below\newline	numtouchedicts = SV_EntitiesInBox(clipboxmins, clipboxmaxs, MAX_EDICTS, touchedicts);\newline	if (numtouchedicts &gt MAX_EDICTS)\newline	{\newline		// this never happens\newline		Con_Printf(&quotSV_EntitiesInBox returned %i edicts, max was %i\\n&quot, numtouchedicts, MAX_EDICTS);\newline		numtouchedicts = MAX_EDICTS;\newline	}\newline	for (i = 0;i &lt numtouchedicts;i++)\newline	{\newline		touch = touchedicts[i];\newline\newline		if (PRVM_serveredictfloat(touch, solid) &lt SOLID_BBOX)\newline			continue;\newline		if (type == MOVE_NOMONSTERS &amp&amp PRVM_serveredictfloat(touch, solid) != SOLID_BSP)\newline			continue;\newline\newline		if (passedict)\newline		{\newline			// don&#039t clip against self\newline			if (passedict == touch)\newline				continue;\newline			// don&#039t clip owned entities against owner\newline			if (traceowner == touch)\newline				continue;\newline			// don&#039t clip owner against owned entities\newline			if (passedictprog == PRVM_serveredictedict(touch, owner))\newline				continue;\newline			// don&#039t clip points against points (they can&#039t collide)\newline			if (VectorCompare(PRVM_serveredictvector(touch, mins), PRVM_serveredictvector(touch, maxs)) &amp&amp (type != MOVE_MISSILE || !((int)PRVM_serveredictfloat(touch, flags) &amp FL_MONSTER)))\newline				continue;\newline		}\newline\newline		bodysupercontents = PRVM_serveredictfloat(touch, solid) == SOLID_CORPSE ? SUPERCONTENTS_CORPSE : SUPERCONTENTS_BODY;\newline\newline		// might interact, so do an exact clip\newline		model = NULL;\newline		if ((int) PRVM_serveredictfloat(touch, solid) == SOLID_BSP || type == MOVE_HITMODEL)\newline		{\newline			model = SV_GetModelFromEdict(touch);\newline			pitchsign = SV_GetPitchSign(prog, touch);\newline		}\newline		if (model)\newline			Matrix4x4_CreateFromQuakeEntity(&ampmatrix, PRVM_serveredictvector(touch, origin)[0], PRVM_serveredictvector(touch, origin)[1], PRVM_serveredictvector(touch, origin)[2], pitchsign * PRVM_serveredictvector(touch, angles)[0], PRVM_serveredictvector(touch, angles)[1], PRVM_serveredictvector(touch, angles)[2], 1);\newline		else\newline			Matrix4x4_CreateTranslate(&ampmatrix, PRVM_serveredictvector(touch, origin)[0], PRVM_serveredictvector(touch, origin)[1], PRVM_serveredictvector(touch, origin)[2]);\newline		Matrix4x4_Invert_Simple(&ampimatrix, &ampmatrix);\newline		VM_GenerateFrameGroupBlend(prog, touch-&gtpriv.server-&gtframegroupblend, touch);\newline		VM_FrameBlendFromFrameGroupBlend(touch-&gtpriv.server-&gtframeblend, touch-&gtpriv.server-&gtframegroupblend, model, sv.time);\newline		VM_UpdateEdictSkeleton(prog, touch, model, touch-&gtpriv.server-&gtframeblend);\newline		VectorCopy(PRVM_serveredictvector(touch, mins), touchmins);\newline		VectorCopy(PRVM_serveredictvector(touch, maxs), touchmaxs);\newline		if (type == MOVE_MISSILE &amp&amp (int)PRVM_serveredictfloat(touch, flags) &amp FL_MONSTER)\newline			Collision_ClipToGenericEntity(&amptrace, model, touch-&gtpriv.server-&gtframeblend, &amptouch-&gtpriv.server-&gtskeleton, touchmins, touchmaxs, bodysupercontents, &ampmatrix, &ampimatrix, clipstart, clipmins2, clipmaxs2, clipstart, hitsupercontentsmask, 0.0f);\newline		else\newline			Collision_ClipPointToGenericEntity(&amptrace, model, touch-&gtpriv.server-&gtframeblend, &amptouch-&gtpriv.server-&gtskeleton, touchmins, touchmaxs, bodysupercontents, &ampmatrix, &ampimatrix, clipstart, hitsupercontentsmask);\newline\newline		Collision_CombineTraces(&ampcliptrace, &amptrace, (void *)touch, PRVM_serveredictfloat(touch, solid) == SOLID_BSP);\newline	}\newline\newlinefinished:\newline	return cliptrace;\newline}\newline",\newline==================\newlineSV_TracePoint\newline==================\newline \newline,6580717,silence.c,"static int sox_silence_flow(sox_effect_t * effp, const sox_sample_t *ibuf, sox_sample_t *obuf,\newline                    size_t *isamp, size_t *osamp)\newline{\newline    priv_t * silence = (priv_t *) effp-&gtpriv;\newline    int threshold;\newline    size_t i, j;\newline    size_t nrOfTicks, /* sometimes wide, sometimes non-wide samples */\newline      nrOfInSamplesRead, nrOfOutSamplesWritten; /* non-wide samples */\newline\newline    nrOfInSamplesRead = 0;\newline    nrOfOutSamplesWritten = 0;\newline\newline    switch (silence-&gtmode)\newline    {\newline        case SILENCE_TRIM:\newline            /* Reads and discards all input data until it detects a\newline             * sample that is above the specified threshold.  Turns on\newline             * copy mode when detected.\newline             * Need to make sure and copy input in groups of &quotchannels&quot to\newline             * prevent getting buffers out of sync.\newline             * nrOfTicks counts wide samples here.\newline             */\newlinesilence_trim:\newline            nrOfTicks = min((*isamp-nrOfInSamplesRead),\newline                            (*osamp-nrOfOutSamplesWritten)) /\newline                           effp-&gtin_signal.channels;\newline            for(i = 0; i &lt nrOfTicks; i++)\newline            {\newline                threshold = 0;\newline                for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                {\newline                    threshold |= aboveThreshold(effp,\newline                                                compute_rms(effp, ibuf[j]),\newline                                                silence-&gtstart_threshold,\newline                                                silence-&gtstart_unit);\newline                }\newline\newline                if (threshold)\newline                {\newline                    /* Add to holdoff buffer */\newline                    for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                    {\newline                        update_rms(effp, *ibuf);\newline                        silence-&gtstart_holdoff[\newline                            silence-&gtstart_holdoff_end++] = *ibuf++;\newline                        nrOfInSamplesRead++;\newline                    }\newline\newline                    if (silence-&gtstart_holdoff_end &gt=\newline                            silence-&gtstart_duration)\newline                    {\newline                        if (++silence-&gtstart_found_periods &gt=\newline                                silence-&gtstart_periods)\newline                        {\newline                            silence-&gtmode = SILENCE_TRIM_FLUSH;\newline                            goto silence_trim_flush;\newline                        }\newline                        /* Trash holdoff buffer since its not\newline                         * needed.  Start looking again.\newline                         */\newline                        silence-&gtstart_holdoff_offset = 0;\newline                        silence-&gtstart_holdoff_end = 0;\newline                    }\newline                }\newline                else /* !above Threshold */\newline                {\newline                    silence-&gtstart_holdoff_end = 0;\newline                    for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                    {\newline                        update_rms(effp, ibuf[j]);\newline                    }\newline                    ibuf += effp-&gtin_signal.channels;\newline                    nrOfInSamplesRead += effp-&gtin_signal.channels;\newline                }\newline            } /* for nrOfTicks */\newline            break;\newline\newline        case SILENCE_TRIM_FLUSH:\newline             /* nrOfTicks counts non-wide samples here. */\newlinesilence_trim_flush:\newline            nrOfTicks = min((silence-&gtstart_holdoff_end -\newline                             silence-&gtstart_holdoff_offset),\newline                             (*osamp-nrOfOutSamplesWritten));\newline            nrOfTicks -= nrOfTicks % effp-&gtin_signal.channels;\newline            for(i = 0; i &lt nrOfTicks; i++)\newline            {\newline                *obuf++ = silence-&gtstart_holdoff[silence-&gtstart_holdoff_offset++];\newline                nrOfOutSamplesWritten++;\newline            }\newline\newline            /* If fully drained holdoff then switch to copy mode */\newline            if (silence-&gtstart_holdoff_offset == silence-&gtstart_holdoff_end)\newline            {\newline                silence-&gtstart_holdoff_offset = 0;\newline                silence-&gtstart_holdoff_end = 0;\newline                silence-&gtmode = SILENCE_COPY;\newline                goto silence_copy;\newline            }\newline            break;\newline\newline        case SILENCE_COPY:\newline            /* Attempts to copy samples into output buffer.\newline             *\newline             * Case B:\newline             * If not looking for silence to terminate copy then\newline             * blindly copy data into output buffer.\newline             *\newline             * Case A:\newline             *\newline             * Case 1a:\newline             * If previous silence was detect then see if input sample is\newline             * above threshold.  If found then flush out hold off buffer\newline             * and copy over to output buffer.\newline             *\newline             * Case 1b:\newline             * If no previous silence detect then see if input sample\newline             * is above threshold.  If found then copy directly\newline             * to output buffer.\newline             *\newline             * Case 2:\newline             * If not above threshold then silence is detect so\newline             * store in hold off buffer and do not write to output\newline             * buffer.  Even though it wasn&#039t put in output\newline             * buffer, inform user that input was consumed.\newline             *\newline             * If hold off buffer is full after this then stop\newline             * copying data and discard data in hold off buffer.\newline             *\newline             * Special leave_silence logic:\newline             *\newline             * During this mode, go ahead and copy input\newline             * samples to output buffer instead of holdoff buffer\newline             * Then also short ciruit any flushes that would occur\newline             * when non-silence is detect since samples were already\newline             * copied.  This has the effect of always leaving\newline             * holdoff[] amount of silence but deleting any\newline             * beyond that amount.\newline             *\newline             * nrOfTicks counts wide samples here.\newline             */\newlinesilence_copy:\newline            nrOfTicks = min((*isamp-nrOfInSamplesRead),\newline                            (*osamp-nrOfOutSamplesWritten)) /\newline                           effp-&gtin_signal.channels;\newline            if (silence-&gtstop)\newline            {\newline                /* Case A */\newline                for(i = 0; i &lt nrOfTicks; i++)\newline                {\newline                    threshold = 1;\newline                    for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                    {\newline                        threshold &amp= aboveThreshold(effp,\newline                                                    compute_rms(effp, ibuf[j]),\newline                                                    silence-&gtstop_threshold,\newline                                                    silence-&gtstop_unit);\newline                    }\newline\newline                    /* Case 1a\newline                     * If above threshold, check to see if we where holding\newline                     * off previously.  If so then flush this buffer.\newline                     * We haven&#039t incremented any pointers yet so nothing\newline                     * is lost.\newline                     *\newline                     * If user wants to leave_silence, then we\newline                     * were already copying the data and so no\newline                     * need to flush the old data.  Just resume\newline                     * copying as if we were not holding off.\newline                     */\newline                    if (threshold &amp&amp silence-&gtstop_holdoff_end\newline                        &amp&amp !silence-&gtleave_silence)\newline                    {\newline                        silence-&gtmode = SILENCE_COPY_FLUSH;\newline                        goto silence_copy_flush;\newline                    }\newline                    /* Case 1b */\newline                    else if (threshold)\newline                    {\newline                        /* Not holding off so copy into output buffer */\newline                        for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                        {\newline                            update_rms(effp, *ibuf);\newline                            *obuf++ = *ibuf++;\newline                            nrOfInSamplesRead++;\newline                            nrOfOutSamplesWritten++;\newline                        }\newline                    }\newline                    /* Case 2 */\newline                    else if (!threshold)\newline                    {\newline                        /* Add to holdoff buffer */\newline                        for (j = 0; j &lt effp-&gtin_signal.channels; j++)\newline                        {\newline                            update_rms(effp, *ibuf);\newline                            if (silence-&gtleave_silence) {\newline                                *obuf++ = *ibuf;\newline                                nrOfOutSamplesWritten++;\newline                            }\newline                            silence-&gtstop_holdoff[\newline                                silence-&gtstop_holdoff_end++] = *ibuf++;\newline                            nrOfInSamplesRead++;\newline                        }\newline\newline                        /* Check if holdoff buffer is greater than duration\newline                         */\newline                        if (silence-&gtstop_holdoff_end &gt=\newline                                silence-&gtstop_duration)\newline                        {\newline                            /* Increment found counter and see if this\newline                             * is the last period.  If so then exit.\newline                             */\newline                            if (++silence-&gtstop_found_periods &gt=\newline                                    silence-&gtstop_periods)\newline                            {\newline                                silence-&gtstop_holdoff_offset = 0;\newline                                silence-&gtstop_holdoff_end = 0;\newline                                if (!silence-&gtrestart)\newline                                {\newline                                    *isamp = nrOfInSamplesRead;\newline                                    *osamp = nrOfOutSamplesWritten;\newline                                    silence-&gtmode = SILENCE_STOP;\newline                                    /* Return SOX_EOF since no more processing */\newline                                    return (SOX_EOF);\newline                                }\newline                                else\newline                                {\newline                                    silence-&gtstop_found_periods = 0;\newline                                    silence-&gtstart_found_periods = 0;\newline                                    silence-&gtstart_holdoff_offset = 0;\newline                                    silence-&gtstart_holdoff_end = 0;\newline                                    clear_rms(effp);\newline                                    silence-&gtmode = SILENCE_TRIM;\newline\newline                                    goto silence_trim;\newline                                }\newline                            }\newline                            else\newline                            {\newline                                /* Flush this buffer and start\newline                                 * looking again.\newline                                 */\newline                                silence-&gtmode = SILENCE_COPY_FLUSH;\newline                                goto silence_copy_flush;\newline                            }\newline                            break;\newline                        } /* Filled holdoff buffer */\newline                    } /* Detected silence */\newline                } /* For # of samples */\newline            } /* Trimming off backend */\newline            else /* !(silence-&gtstop) */\newline            {\newline                /* Case B */\newline                memcpy(obuf, ibuf, sizeof(sox_sample_t)*nrOfTicks*\newline                                   effp-&gtin_signal.channels);\newline                nrOfInSamplesRead += (nrOfTicks*effp-&gtin_signal.channels);\newline                nrOfOutSamplesWritten += (nrOfTicks*effp-&gtin_signal.channels);\newline            }\newline            break;\newline\newline        case SILENCE_COPY_FLUSH:\newline             /* nrOfTicks counts non-wide samples here. */\newlinesilence_copy_flush:\newline            nrOfTicks = min((silence-&gtstop_holdoff_end -\newline                                silence-&gtstop_holdoff_offset),\newline                            (*osamp-nrOfOutSamplesWritten));\newline            nrOfTicks -= nrOfTicks % effp-&gtin_signal.channels;\newline\newline            for(i = 0; i &lt nrOfTicks; i++)\newline            {\newline                *obuf++ = silence-&gtstop_holdoff[silence-&gtstop_holdoff_offset++];\newline                nrOfOutSamplesWritten++;\newline            }\newline\newline            /* If fully drained holdoff then return to copy mode */\newline            if (silence-&gtstop_holdoff_offset == silence-&gtstop_holdoff_end)\newline            {\newline                silence-&gtstop_holdoff_offset = 0;\newline                silence-&gtstop_holdoff_end = 0;\newline                silence-&gtmode = SILENCE_COPY;\newline                goto silence_copy;\newline            }\newline            break;\newline\newline        case SILENCE_STOP:\newline            /* This code can&#039t be reached. */\newline            nrOfInSamplesRead = *isamp;\newline            break;\newline        }\newline\newline        *isamp = nrOfInSamplesRead;\newline        *osamp = nrOfOutSamplesWritten;\newline\newline        return (SOX_SUCCESS);\newline}\newline",Return number of samples processed in isamp and osamp. \newline,5083910,test_util.c,"static apr_status_t default_http_conn_setup(apr_socket_t *skt,\newline                                            serf_bucket_t **input_bkt,\newline                                            serf_bucket_t **output_bkt,\newline                                            void *setup_baton,\newline                                            apr_pool_t *pool)\newline{\newline    test_baton_t *tb = setup_baton;\newline\newline    *input_bkt = serf_bucket_socket_create(skt, tb-&gtbkt_alloc);\newline    return APR_SUCCESS;\newline}\newline",Default implementation of a serf_connection_setup_t callback. \newline,2035610,darwin_sigar.c,static mach_vm_size_t sigar_shared_region_size(cpu_type_t type)\newline{\newline    switch (type) {\newline      case CPU_TYPE_ARM:\newline        return SHARED_REGION_SIZE_ARM;\newline      case CPU_TYPE_POWERPC:\newline        return SHARED_REGION_SIZE_PPC;\newline      case CPU_TYPE_POWERPC64:\newline	return SHARED_REGION_SIZE_PPC64;\newline      case CPU_TYPE_I386:\newline        return SHARED_REGION_SIZE_I386;\newline      case CPU_TYPE_X86_64:\newline        return SHARED_REGION_SIZE_X86_64;\newline      default:\newline        return SHARED_REGION_SIZE_I386; /* assume 32-bit x86|ppc */\newline    }\newline}\newline,shared memory region size for the given cpu_type_t \newline,2811315,merge.c,"int merge(struct syrep_db_context *c1, struct syrep_db_context *c2, const char* root, const char* sroot) {\newline    struct cb_info cb_info;\newline    DB *ddb = NULL;\newline    int r = -1;\newline\newline    memset(&ampcb_info, 0, sizeof(cb_info));\newline    cb_info.c1 = c1;\newline    cb_info.c2 = c2;\newline    cb_info.root = root;\newline    cb_info.sroot = sroot;\newline\newline    snprintf(cb_info.trash_dir, sizeof(cb_info.trash_dir), &quot%s/.syrep/trash&quot, root);\newline    mkdir_p(cb_info.trash_dir, 0777);\newline\newline    if (!(ddb = make_diff(c1, c2)))\newline        goto finish;\newline\newline    if (diff_foreach(ddb, conflict_phase, &ampcb_info) &lt 0)\newline        goto finish;\newline\newline    if (diff_foreach(ddb, delete_phase, &ampcb_info) &lt 0)\newline        goto finish;\newline\newline    if (diff_foreach(ddb, copy_phase, &ampcb_info) &lt 0)\newline        goto finish;\newline\newline    if (!args.keep_trash_flag)\newline        if (rm_rf(cb_info.trash_dir, 1) &lt 0)\newline            goto finish;\newline    \newline    r = 0;\newline    \newlinefinish:\newline    if (ddb)\newline        ddb-&gtclose(ddb, 0);\newline\newline    rmdir(cb_info.trash_dir);\newline    \newline    return r;\newline}\newline","Merges c1 into c2 in directory &quotroot&quot\newline sroot is an optional source directory, only used on bi-directory merges \newline",3673659,parallel.cpp,"int divide_equally_which_group(long int N, int size, long int myself)\newline{\newline    long int first, last;\newline    for (int rank = 0; rank &lt size; rank++)\newline    {\newline        divide_equally(N, size, rank, first, last);\newline        if (myself &gt= first &amp&amp myself &lt= last)\newline            return rank;\newline    }\newline    return -1;\newline}\newline",In which group from divide_equally is myself? \newline,2181465,libaudit.c,"static char *get_line(FILE *f, char *buf, size_t len)\newline{\newline	if (fgets(buf, len, f)) {\newline		/* remove newline */\newline		char *ptr = strchr(buf, 0x0a);\newline		if (ptr)\newline			*ptr = 0;\newline		return buf;\newline	}\newline	return NULL;\newline}\newline",Get 1 line from file \newline,6235120,gbnclient.c,"void bn_help( void )\newline{\newline        GtkTextIter text_help_iter;\newline	/*gtk_text_freeze(GTK_TEXT(text_help));*/\newline	gtk_widget_realize(text_help);\newline	/*gtk_text_insert( GTK_TEXT(text_help),NULL,NULL,NULL\newline		,_(&quotBatnav Quick Help -\\n&quot\newline		&quotUse this to hide your ships\\n&quot\newline		&quotFill the board with:\\n&quot\newline		&quot  4 ships of 1 unit\\n&quot\newline		&quot  3 ships of 2 units\\n&quot\newline		&quot  2 ships of 3 units\\n&quot\newline		&quot  1 ship of 4 units\\n&quot\newline		&quot  or press &#039Random&#039\\n&quot\newline		&quotThen press &#039Send ships&#039 and &#039Start&#039\\n&quot\newline		&quotSend bugs,comments, etc to:\\n&quot\newline		&quot  riq@core-sdi.com\\n&quot\newline		) ,-1 );\newline	*/\newline	gtk_text_buffer_get_end_iter(gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_help)),&amptext_help_iter);\newline	gtk_text_buffer_insert(gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_help)),&amptext_help_iter\newline	        ,_(&quotBatnav Quick Help -\\n&quot\newline		&quotUse this to hide your ships\\n&quot\newline		&quotFill the board with:\\n&quot\newline		&quot  4 ships of 1 unit\\n&quot\newline		&quot  3 ships of 2 units\\n&quot\newline		&quot  2 ships of 3 units\\n&quot\newline		&quot  1 ship of 4 units\\n&quot\newline		&quot  or press &#039Random&#039\\n&quot\newline		&quotThen press &#039Send ships&#039 and &#039Start&#039\\n&quot\newline		&quotSend bugs,comments, etc to:\\n&quot\newline		&quot  riq@core-sdi.com\\n&quot\newline		) ,-1 );\newline	/*gtk_text_thaw(GTK_TEXT(text_help));*/\newline   \newline}\newline",Quick Help tab \newline,1836492,io_m3sd.c,"bool M3SD_ReadSectors(u32 sector, u8 numSecs, void* buffer)\newline{\newline	//read multi sectors function\newline	M3_SetChipReg(0x400003);\newline	readsectors((u16*)buffer,sector,numSecs);\newline	M3_SetChipReg(0x400002);\newline	return true;	// */\newline}\newline","-----------------------------------------------------------------\newlineM3SD_ReadSectors\newlineRead 512 byte sector numbered &quotsector&quot into &quotbuffer&quot\newlineu32 sector IN: address of first 512 byte sector on CF card to read\newlineu8 numSecs IN: number of 512 byte sectors to read,\newline1 to 256 sectors can be read, 0 = 256\newlinevoid buffer OUT: pointer to 512 byte buffer to store data in\newlinebool return OUT: true if successful\newline----------------------------------------------------------------- \newline",6167009,frm_driver.c,"static int FN_Next_Field(FORM * form)\newline{\newline  return _nc_Set_Current_Field(form,\newline                               Next_Field_On_Page(form-&gtcurrent));\newline}\newline",---------------------------------------------------------------------------\newline| Facility : libnform \newline| Function : static int FN_Next_Field(FORM form)\newline| \newline| Description : Move to the next field on the current page of the form\newline|\newline| Return Values : E_OK - success\newline| != E_OK - error from subordinate call\newline+-------------------------------------------------------------------------- \newline,4854851,fsm.c,"static void fsm_gather_signals(\newline            expression* expr,         /*!&lt Pointer to expression to get signals from */\newline  /*@out@*/ sig_link**  head,         /*!&lt Pointer to head of signal list to populate */\newline  /*@out@*/ sig_link**  tail,         /*!&lt Pointer to tail of signal list to populate */\newline            int         expr_id,      /*!&lt Expression ID of the statement containing this expression */\newline  /*@out@*/ int**       expr_ids,     /*!&lt Pointer to expression ID array */\newline  /*@out@*/ int*        expr_id_size  /*!&lt Number of elements currently stored in expr_ids array */\newline) { PROFILE(FSM_GATHER_SIGNALS);\newline\newline  if( expr != NULL ) {\newline\newline    if( expr-&gtsig != NULL ) {\newline\newline      /* Add this signal to the list */\newline      sig_link_add( expr-&gtsig, head, tail );\newline\newline      /* Add specified expression ID to the expression IDs array, if needed */\newline      if( expr_id &gt= 0 ) {\newline        (*expr_ids)                  = (int*)realloc_safe( *expr_ids, (sizeof( int ) * (*expr_id_size)), (sizeof( int ) * ((*expr_id_size) + 1)) );\newline        (*expr_ids)[(*expr_id_size)] = expr_id;\newline        (*expr_id_size)++;\newline      }\newline\newline    } else {\newline\newline      fsm_gather_signals( expr-&gtleft,  head, tail, expr_id, expr_ids, expr_id_size );\newline      fsm_gather_signals( expr-&gtright, head, tail, expr_id, expr_ids, expr_id_size );\newline\newline    }\newline\newline  }\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineRecursively iterates through specified expression, adding the signal of each expression that\newlinepoints to one to the specified signal list. Also captures the expression ID of the statement\newlinecontaining this signal for each signal found (if expr_id is a non-negative value).\newline \newline",,,on,,,,,on,,,on,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,the object stored \a i.,moves cursor to UPPER_NIBBLE or LOWER_NIBBLE of the current byte,{},Return number of samples processed in isamp and osamp.,Default implementation of a serf_connection_setup_t callback.,shared memory region size,"Merges c1 into c2 in directory ""root""",{},Get 1 line from file,Quick Help tab,{},Call ppp_sighup() in a thread-safe,Move to the next field on the current page of the form,"Recursively iterates through specified expression,",Iterate through attributes,\return The current FCD mode.,Load an image from the named file.,Various spot functions,{},Stop test connections for all flows in a test,return the width (in characters) of the numeric part of the hostname,x,
32W3UF2EZOL8I6H3JF6DX3JZZZXC4W,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:51 PDT 2019,2,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 13:52:01 PDT 2019,,,34YB12FSQYO3QSJ7H77TY7H31EOMGB,AITP2LUW8GPB,Submitted,Fri Apr 26 15:22:53 PDT 2019,Fri Apr 26 15:40:58 PDT 2019,Sun Apr 28 15:40:58 PDT 2019,,,,1085,100% (62/62),100% (62/62),0% (0/0),2030947,datagramsocket.cpp,"void DatagramSocket::bind(int localPort1, InetAddressPtr localAddress1)\newline{\newline   Pool addrPool;\newline\newline   // Create server socket address (including port number)\newline   LOG4CXX_ENCODE_CHAR(hostAddr, localAddress1-&gtgetHostAddress());\newline   apr_sockaddr_t *server_addr;\newline   apr_status_t status =\newline       apr_sockaddr_info_get(&ampserver_addr, hostAddr.c_str(), APR_INET,\newline                             localPort1, 0, addrPool.getAPRPool());\newline   if (status != APR_SUCCESS) {\newline     throw BindException(status);\newline   }\newline\newline   // bind the socket to the address\newline   status = apr_socket_bind(socket, server_addr);\newline   if (status != APR_SUCCESS) {\newline     throw BindException(status);\newline   }\newline\newline   this-&gtlocalPort = localPort1;\newline   this-&gtlocalAddress = localAddress1;\newline}\newline",Binds a datagram socket to a local port and address. \newline,3251219,mj2.c,"int mj2_read_mvhd(opj_mj2_t * movie, opj_cio_t *cio)\newline{\newline  mj2_box_t box;\newline\newline  mj2_read_boxhdr(&ampbox, cio);\newline  if (MJ2_MVHD != box.type) {\newline    opj_event_msg(cio-&gtcinfo, EVT_ERROR, &quotError: Expected MVHD Marker\\n&quot);\newline    return 1;\newline  }\newline\newline\newline  if (0 != cio_read(cio, 4)) {  /* Version = 0, flags = 0 */\newline    opj_event_msg(cio-&gtcinfo, EVT_ERROR, &quotError: Only Version 0 handled in MVHD box\\n&quot);\newline  }\newline\newline  movie-&gtcreation_time = cio_read(cio, 4);  /* Creation Time */\newline\newline  movie-&gtmodification_time = cio_read(cio, 4);  /* Modification Time */\newline\newline  movie-&gttimescale = cio_read(cio, 4);  /* Timescale */\newline\newline  movie-&gtduration = cio_read(cio, 4);  /* Duration */\newline\newline  movie-&gtrate = cio_read(cio, 4);    /* Rate to play presentation    */\newline\newline  movie-&gtvolume = cio_read(cio, 2);    /* Volume       */\newline\newline  cio_skip(cio,10);        /* Reserved */\newline\newline  movie-&gttrans_matrix[0] = cio_read(cio, 4);  /* Transformation matrix for video */\newline  movie-&gttrans_matrix[1] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[2] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[3] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[4] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[5] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[6] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[7] = cio_read(cio, 4);\newline  movie-&gttrans_matrix[8] = cio_read(cio, 4);\newline\newline  cio_skip(cio,24);      /* Pre-defined */\newline\newline  movie-&gtnext_tk_id = cio_read(cio, 4);  /* ID of Next track to be added */\newline\newline  if (cio_tell(cio) - box.init_pos != box.length) {\newline    opj_event_msg(cio-&gtcinfo, EVT_ERROR, &quotError with MVHD Box Size\\n&quot);\newline    return 1;\newline  }\newline  return 0;\newline}\newline",\newline Read the MVHD box\newline \newline Movie header Box\newline \newline \newline,2215025,remove.c,"int remove_false_minutia_V2(MINUTIAE *minutiae,\newline           unsigned char *bdata, const int iw, const int ih,\newline           int *direction_map, int *low_flow_map, int *high_curve_map,\newline           const int mw, const int mh, const LFSPARMS *lfsparms)\newline{\newline   int ret;\newline\newline   /* 1. Sort minutiae points top-to-bottom and left-to-right. */\newline   if((ret = sort_minutiae_y_x(minutiae, iw, ih))){\newline      return(ret);\newline   }\newline\newline   /* 2. Remove minutiae on lakes (filled with white pixels) and        */\newline   /*    islands (filled with black pixels), both  defined by a pair of */\newline   /*    minutia points.                                                */\newline   if((ret = remove_islands_and_lakes(minutiae, bdata, iw, ih, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 3. Remove minutiae on holes in the binary image defined by a */\newline   /*    single point.                                             */\newline   if((ret = remove_holes(minutiae, bdata, iw, ih, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 4. Remove minutiae that point sufficiently close to a block with */\newline   /*    INVALID direction.                                            */\newline   if((ret = remove_pointing_invblock_V2(minutiae, direction_map, mw, mh,\newline                                        lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 5. Remove minutiae that are sufficiently close to a block with */\newline   /*    INVALID direction.                                          */\newline   if((ret = remove_near_invblock_V2(minutiae, direction_map, mw, mh,\newline                                    lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 6. Remove or adjust minutiae that reside on the side of a ridge */\newline   /*    or valley.                                                   */\newline   if((ret = remove_or_adjust_side_minutiae_V2(minutiae, bdata, iw, ih,\newline                                  direction_map, mw, mh, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 7. Remove minutiae that form a hook on the side of a ridge or valley. */\newline   if((ret = remove_hooks(minutiae, bdata, iw, ih, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 8. Remove minutiae that are on opposite sides of an overlap. */\newline   if((ret = remove_overlaps(minutiae, bdata, iw, ih, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 9. Remove minutiae that are &quotirregularly&quot shaped. */\newline   if((ret = remove_malformations(minutiae, bdata, iw, ih,\newline                                 low_flow_map, mw, mh, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 10. Remove minutiae that form long, narrow, loops in the */\newline   /*     &quotunreliable&quot regions in the binary image.            */\newline   if((ret = remove_pores_V2(minutiae,  bdata, iw, ih,\newline                            direction_map, low_flow_map, high_curve_map,\newline                            mw, mh, lfsparms))){\newline      return(ret);\newline   }\newline\newline   /* 11. Remove minutiae on image edge */\newline   if((ret = remove_perimeter_pts(minutiae, bdata, iw, ih, lfsparms))) {\newline      return (ret);\newline   }\newline\newline   return(0);\newline}\newline",\newline \newline#cat: remove_false_minutia_V2 - Takes a list of true and false minutiae and\newline#cat: attempts to detect and remove the false minutiae based\newline#cat: on a series of tests.\newlineInput:\newlineminutiae - list of true and false minutiae\newlinebdata - binary image data (0==while &amp 1==black)\newlineiw - width (in pixels) of image\newlineih - height (in pixels) of image\newlinedirection_map - map of image blocks containing directional ridge flow\newlinelow_flow_map - map of image blocks flagged as LOW RIDGE FLOW\newlinehigh_curve_map - map of image blocks flagged as HIGH CURVATURE\newlinemw - width in blocks of the maps\newlinemh - height in blocks of the maps\newlinelfsparms - parameters and thresholds for controlling LFS\newlineOutput:\newlineminutiae - list of pruned minutiae\newlineReturn Code:\newlineZero - successful completion\newlineNegative - system error\newline \newline,1783266,sv_ents.c,"void SV_WritePlayerstateToClient (client_frame_t *from, client_frame_t *to, sizebuf_t *msg)\newline{\newline	int				i;\newline	int				pflags;\newline	player_state_t	*ps, *ops;\newline	player_state_t	dummy;\newline	int				statbits;\newline\newline	ps = &ampto-&gtps;\newline	if (!from)\newline	{\newline		memset (&ampdummy, 0, sizeof(dummy));\newline		ops = &ampdummy;\newline	}\newline	else\newline		ops = &ampfrom-&gtps;\newline\newline	//\newline	// determine what needs to be sent\newline	//\newline	pflags = 0;\newline\newline	if (ps-&gtpmove.pm_type != ops-&gtpmove.pm_type)\newline		pflags |= PS_M_TYPE;\newline\newline	if (ps-&gtpmove.origin[0] != ops-&gtpmove.origin[0]\newline		|| ps-&gtpmove.origin[1] != ops-&gtpmove.origin[1]\newline		|| ps-&gtpmove.origin[2] != ops-&gtpmove.origin[2] )\newline		pflags |= PS_M_ORIGIN;\newline\newline	if (ps-&gtpmove.velocity[0] != ops-&gtpmove.velocity[0]\newline		|| ps-&gtpmove.velocity[1] != ops-&gtpmove.velocity[1]\newline		|| ps-&gtpmove.velocity[2] != ops-&gtpmove.velocity[2] )\newline		pflags |= PS_M_VELOCITY;\newline\newline	if (ps-&gtpmove.pm_time != ops-&gtpmove.pm_time)\newline		pflags |= PS_M_TIME;\newline\newline	if (ps-&gtpmove.pm_flags != ops-&gtpmove.pm_flags)\newline		pflags |= PS_M_FLAGS;\newline\newline	if (ps-&gtpmove.gravity != ops-&gtpmove.gravity)\newline		pflags |= PS_M_GRAVITY;\newline\newline	if (ps-&gtpmove.delta_angles[0] != ops-&gtpmove.delta_angles[0]\newline		|| ps-&gtpmove.delta_angles[1] != ops-&gtpmove.delta_angles[1]\newline		|| ps-&gtpmove.delta_angles[2] != ops-&gtpmove.delta_angles[2] )\newline		pflags |= PS_M_DELTA_ANGLES;\newline\newline\newline	if (ps-&gtviewoffset[0] != ops-&gtviewoffset[0]\newline		|| ps-&gtviewoffset[1] != ops-&gtviewoffset[1]\newline		|| ps-&gtviewoffset[2] != ops-&gtviewoffset[2] )\newline		pflags |= PS_VIEWOFFSET;\newline\newline	if (ps-&gtviewangles[0] != ops-&gtviewangles[0]\newline		|| ps-&gtviewangles[1] != ops-&gtviewangles[1]\newline		|| ps-&gtviewangles[2] != ops-&gtviewangles[2] )\newline		pflags |= PS_VIEWANGLES;\newline\newline	if (ps-&gtkick_angles[0] != ops-&gtkick_angles[0]\newline		|| ps-&gtkick_angles[1] != ops-&gtkick_angles[1]\newline		|| ps-&gtkick_angles[2] != ops-&gtkick_angles[2] )\newline		pflags |= PS_KICKANGLES;\newline\newline	if (ps-&gtblend[0] != ops-&gtblend[0]\newline		|| ps-&gtblend[1] != ops-&gtblend[1]\newline		|| ps-&gtblend[2] != ops-&gtblend[2]\newline		|| ps-&gtblend[3] != ops-&gtblend[3] )\newline		pflags |= PS_BLEND;\newline\newline	if (ps-&gtfov != ops-&gtfov)\newline		pflags |= PS_FOV;\newline\newline	if (ps-&gtrdflags != ops-&gtrdflags)\newline		pflags |= PS_RDFLAGS;\newline\newline	if (ps-&gtgunframe != ops-&gtgunframe\newline		|| (int)(ops-&gtgunoffset[0]*4) != (int)(ps-&gtgunoffset[0]*4)\newline		|| (int)(ops-&gtgunoffset[1]*4) != (int)(ps-&gtgunoffset[1]*4)\newline		|| (int)(ops-&gtgunoffset[2]*4) != (int)(ps-&gtgunoffset[2]*4)\newline		|| (int)(ops-&gtgunangles[0]*4) != (int)(ps-&gtgunangles[0]*4)\newline		|| (int)(ops-&gtgunangles[1]*4) != (int)(ps-&gtgunangles[1]*4)\newline		|| (int)(ops-&gtgunangles[2]*4) != (int)(ps-&gtgunangles[2]*4) )\newline		pflags |= PS_WEAPONFRAME;\newline\newline	pflags |= PS_WEAPONINDEX;\newline\newline	//\newline	// write it\newline	//\newline	MSG_WriteByte (msg, svc_playerinfo);\newline	MSG_WriteShort (msg, pflags);\newline\newline	//\newline	// write the pmove_state_t\newline	//\newline	if (pflags &amp PS_M_TYPE)\newline		MSG_WriteByte (msg, ps-&gtpmove.pm_type);\newline\newline	if (pflags &amp PS_M_ORIGIN)\newline	{\newline		MSG_WriteSizeInt (msg, coord_bytes, ps-&gtpmove.origin[0]);\newline		MSG_WriteSizeInt (msg, coord_bytes, ps-&gtpmove.origin[1]);\newline		MSG_WriteSizeInt (msg, coord_bytes, ps-&gtpmove.origin[2]);\newline	}\newline\newline	if (pflags &amp PS_M_VELOCITY)\newline	{\newline		MSG_WriteShort (msg, ps-&gtpmove.velocity[0]);\newline		MSG_WriteShort (msg, ps-&gtpmove.velocity[1]);\newline		MSG_WriteShort (msg, ps-&gtpmove.velocity[2]);\newline	}\newline\newline	if (pflags &amp PS_M_TIME)\newline		MSG_WriteByte (msg, ps-&gtpmove.pm_time);\newline\newline	if (pflags &amp PS_M_FLAGS)\newline		MSG_WriteByte (msg, ps-&gtpmove.pm_flags);\newline\newline	if (pflags &amp PS_M_GRAVITY)\newline		MSG_WriteShort (msg, ps-&gtpmove.gravity);\newline\newline	if (pflags &amp PS_M_DELTA_ANGLES)\newline	{\newline		MSG_WriteShort (msg, ps-&gtpmove.delta_angles[0]);\newline		MSG_WriteShort (msg, ps-&gtpmove.delta_angles[1]);\newline		MSG_WriteShort (msg, ps-&gtpmove.delta_angles[2]);\newline	}\newline\newline	//\newline	// write the rest of the player_state_t\newline	//\newline	if (pflags &amp PS_VIEWOFFSET)\newline	{\newline		MSG_WriteChar (msg, ps-&gtviewoffset[0]*4);\newline		MSG_WriteChar (msg, ps-&gtviewoffset[1]*4);\newline		MSG_WriteChar (msg, ps-&gtviewoffset[2]*4);\newline	}\newline\newline	if (pflags &amp PS_VIEWANGLES)\newline	{\newline		MSG_WriteAngle16 (msg, ps-&gtviewangles[0]);\newline		MSG_WriteAngle16 (msg, ps-&gtviewangles[1]);\newline		MSG_WriteAngle16 (msg, ps-&gtviewangles[2]);\newline	}\newline\newline	if (pflags &amp PS_KICKANGLES)\newline	{\newline		MSG_WriteChar (msg, ps-&gtkick_angles[0]*4);\newline		MSG_WriteChar (msg, ps-&gtkick_angles[1]*4);\newline		MSG_WriteChar (msg, ps-&gtkick_angles[2]*4);\newline	}\newline\newline	if (pflags &amp PS_WEAPONINDEX)\newline	{\newline		MSG_WriteByte (msg, ps-&gtgunindex);\newline	}\newline\newline	if (pflags &amp PS_WEAPONFRAME)\newline	{\newline		MSG_WriteByte (msg, ps-&gtgunframe);\newline		MSG_WriteChar (msg, ps-&gtgunoffset[0]*4);\newline		MSG_WriteChar (msg, ps-&gtgunoffset[1]*4);\newline		MSG_WriteChar (msg, ps-&gtgunoffset[2]*4);\newline		MSG_WriteChar (msg, ps-&gtgunangles[0]*4);\newline		MSG_WriteChar (msg, ps-&gtgunangles[1]*4);\newline		MSG_WriteChar (msg, ps-&gtgunangles[2]*4);\newline	}\newline\newline	if (pflags &amp PS_BLEND)\newline	{\newline		MSG_WriteByte (msg, ps-&gtblend[0]*255);\newline		MSG_WriteByte (msg, ps-&gtblend[1]*255);\newline		MSG_WriteByte (msg, ps-&gtblend[2]*255);\newline		MSG_WriteByte (msg, ps-&gtblend[3]*255);\newline	}\newline	if (pflags &amp PS_FOV)\newline		MSG_WriteByte (msg, ps-&gtfov);\newline	if (pflags &amp PS_RDFLAGS)\newline		MSG_WriteByte (msg, ps-&gtrdflags);\newline\newline	// send stats\newline	statbits = 0;\newline	for (i=0 ; i&ltMAX_STATS ; i++)\newline		if (ps-&gtstats[i] != ops-&gtstats[i])\newline			statbits |= 1&lt&lti;\newline	MSG_WriteLong (msg, statbits);\newline	for (i=0 ; i&ltMAX_STATS ; i++)\newline		if (statbits &amp (1&lt&lti) )\newline			MSG_WriteShort (msg, ps-&gtstats[i]);\newline}\newline",\newline=============\newlineSV_WritePlayerstateToClient\newline=============\newline \newline,4209935,tmainwindow.cpp,void TMainWindow::removeFromPerspective(QWidget *widget)\newline{\newline    #ifdef K_DEBUG\newline        #ifdef Q_OS_WIN\newline            qDebug() &lt&lt &quot[TMainWindow::removeFromPerspective()]&quot;\newline        #else\newline            T_FUNCINFO;\newline        #endif\newline    #endif\newline\newline    m_managedWidgets.remove(widget);\newline}\newline,\newline Remove widget from perspective\newline @param widget \newline \newline,5962511,irccommand.cpp,"IrcCommand* IrcCommand::createTopic(const QString&amp channel, const QString&amp topic)\newline{\newline    return IrcCommandPrivate::createCommand(Topic, QStringList() &lt&lt channel &lt&lt topic);\newline}\newline","!\newlineCreates a new TOPIC command with type IrcCommand::Topic and parameters \\a channel and optional \\a topic.\newlineThis command allows the client to query or set the channel topic on \\a channel.\newlineIf \\a topic is given, it sets the channel topic to \\a topic.\newlineIf channel mode +t is set, only a channel operator may set the topic.\newline \newline",4945732,label.c,int fdisk_label_is_disabled(const struct fdisk_label *lb)\newline{\newline	assert(lb);\newline	return lb ? lb-&gtdisabled : 0;\newline}\newline,\newline fdisk_label_is_disabled:\newline @lb: label\newline \newline Returns: 1 if label driver disabled.\newline \newline,6581485,list.c,enum listRtrn listInitialize(list_t *list) {\newline	list-&gtfirst=list-&gtlast=list-&gtcurrent=NULL;\newline	list-&gtelements=0;\newline	return(listRtrnOk);\newline}\newline,This routine initializes our list meta data. \newline,2188954,bqshe88.c,"int bqshe88(void)\newline{\newlineextern FR_DOUBLE xk[],yk[];\newlineextern FR_DOUBLE be[],hi[],hj[];\newline\newlineextern FR_DOUBLE pree,tr1e;\newline\newlineextern FR_INT4   intore;\newline\newlineFR_DOUBLE        s,wt;\newline\newlineFR_INT4          i,ly,j;\newline\newline/*----------------------------------------------------------------------\newline* Gauss-Legendre Stuetzstellen\newline*---------------------------------------------------------------------*/\newlinestatic FR_DOUBLE xg[17]= { 0.,\newline   0., -.5773502691896, -.7745966692415, -.8611363115941,\newline   0., +.5773502691896,              0., -.3399810435849,\newline   0.,              0., +.7745966692415, +.3399810435849,\newline   0.,              0.,              0., +.8611363115941 };\newline\newline/*----------------------------------------------------------------------\newline* Gauss-Legendre Integrationsgewichte\newline*---------------------------------------------------------------------*/\newlinestatic FR_DOUBLE wgt[17]= { 0.,\newline   2.,              1., +.5555555555556, +.3478548451375,\newline   0.,              1., +.8888888888889, +.6521451548625,\newline   0.,              0., +.5555555555556, +.6521451548625,\newline   0.,              0.,              0., +.3478548451375 };\newline\newline/*----------------------------------------------------------------------\newline* Lastvektor aufstellen\newline*---------------------------------------------------------------------*/\newlinefor(i = 1;i &lt= 6;i++)\newline  be[i]= 0.;\newline\newlinefor(ly = 1;ly &lt= intore;ly++)                            /* 80 */\newline  {\newline  s= xg[(ly-1)*4 + intore];\newline\newline/*======================================================================\newline* Matrix be der partiellen Ableitungen &amp Jacobi Determinante holen\newline*=====================================================================*/\newline  bqb88(s);\newline\newline  wt= wgt[(ly-1)*4 + intore];\newline\newline/*======================================================================\newline* Element- Lastvektor be\newline*=====================================================================*/\newline  for(j = 1;j &lt= 6;j++)\newline    {\newline    be[j]+= hi[j]*wt*pree + hj[j]*wt*tr1e;\newline    }\newline\newline  }\newline\newlinereturn(0);\newline}\newline",\newline hier beginnt Function bqshe88\newline \newline,3804022,testautomation_rect.c,"void _validateUnionRectResults(\newline    SDL_Rect *rectA, SDL_Rect *rectB, SDL_Rect *refRectA, SDL_Rect *refRectB,\newline    SDL_Rect *result, SDL_Rect *expectedResult)\newline{\newline    SDLTest_AssertCheck(rectA-&gtx == refRectA-&gtx &amp&amp rectA-&gty == refRectA-&gty &amp&amp rectA-&gtw == refRectA-&gtw &amp&amp rectA-&gth == refRectA-&gth,\newline        &quotCheck that source rectangle A was not modified: got (%d,%d,%d,%d) expected (%d,%d,%d,%d)&quot,\newline        rectA-&gtx, rectA-&gty, rectA-&gtw, rectA-&gth,\newline        refRectA-&gtx, refRectA-&gty, refRectA-&gtw, refRectA-&gth);\newline    SDLTest_AssertCheck(rectB-&gtx == refRectB-&gtx &amp&amp rectB-&gty == refRectB-&gty &amp&amp rectB-&gtw == refRectB-&gtw &amp&amp rectB-&gth == refRectB-&gth,\newline        &quotCheck that source rectangle B was not modified: got (%d,%d,%d,%d) expected (%d,%d,%d,%d)&quot,\newline        rectB-&gtx, rectB-&gty, rectB-&gtw, rectB-&gth,\newline        refRectB-&gtx, refRectB-&gty, refRectB-&gtw, refRectB-&gth);\newline    SDLTest_AssertCheck(result-&gtx == expectedResult-&gtx &amp&amp result-&gty == expectedResult-&gty &amp&amp result-&gtw == expectedResult-&gtw &amp&amp result-&gth == expectedResult-&gth,\newline        &quotCheck that union of rectangles A (%d,%d,%d,%d) and B (%d,%d,%d,%d) was correctly calculated, got (%d,%d,%d,%d) expected (%d,%d,%d,%d)&quot,\newline        rectA-&gtx, rectA-&gty, rectA-&gtw, rectA-&gth,\newline        rectB-&gtx, rectB-&gty, rectB-&gtw, rectB-&gth,\newline        result-&gtx, result-&gty, result-&gtw, result-&gth,\newline        expectedResult-&gtx, expectedResult-&gty, expectedResult-&gtw, expectedResult-&gth);\newline}\newline",!\newline \\brief Private helper to check SDL_UnionRect results\newline \newline,147563,srf_dump_all.c,"void dump_solexa(ztr_t *z, char *name, char mode, FILE **files) {\newline    int i, nc;\newline    ztr_chunk_t **chunks;\newline    char *seq;\newline    int lane = -1, tile = -1, x = -1, y = -1;\newline    parse_name(name, &amplane, &amptile, &ampx, &ampy);\newline\newline    uncompress_ztr(z);\newline\newline    chunks = ztr_find_chunks(z, ZTR_TYPE_BASE, &ampnc);\newline    if (nc != 1) {\newline	fprintf(stderr, &quotZero or greater than one BASE chunks found.\\n&quot);\newline	return;\newline    }\newline    seq = chunks[0]-&gtdata+1;\newline\newline    /* Sequence */\newline    if (mode &amp SEQ) {\newline	fprintf(files[0], &quot%d\\t%d\\t%d\\t%d\\t%.*s\\n&quot,\newline		lane, tile, x, y,\newline		chunks[0]-&gtdlength-1,\newline		chunks[0]-&gtdata+1);\newline    }\newline\newline    /* Confidence */\newline    if (mode &amp PRB) {\newline	chunks = ztr_find_chunks(z, ZTR_TYPE_CNF4, &ampnc);\newline	if (nc != 1) {\newline	    fprintf(stderr, &quotZero or greater than one CNF chunks found.\\n&quot);\newline	    return;\newline	}\newline\newline	dump_conf4_solexa(files[1], seq, (sc *)chunks[0]-&gtdata+1,\newline			  chunks[0]-&gtdlength-1);\newline    }\newline\newline    /* Traces */\newline    if (mode &amp SIG2) {\newline	chunks = ztr_find_chunks(z, ZTR_TYPE_SMP4, &ampnc);\newline	for (i = 0; i &lt nc; i++) {\newline	    char *key = ztr_lookup_mdata_value(z, chunks[i], &quotTYPE&quot);\newline	    if (!key || 0 == strcmp(key, &quotPROC&quot)) {\newline		key = ztr_lookup_mdata_value(z, chunks[i], &quotOFFS&quot);\newline		dump_samples4_solexa(files[2], lane, tile, x, y,\newline				     key ? atoi(key) : 0,\newline				     (uc *)chunks[i]-&gtdata+2,\newline				     chunks[i]-&gtdlength-2);\newline		break;\newline	    }\newline	}\newline    }\newline\newline    if (mode &amp INT) {\newline	chunks = ztr_find_chunks(z, ZTR_TYPE_SMP4, &ampnc);\newline	for (i = 0; i &lt nc; i++) {\newline	    char *key = ztr_lookup_mdata_value(z, chunks[i], &quotTYPE&quot);\newline	    if (key &amp&amp 0 == strcmp(key, &quotSLXI&quot)) {\newline		key = ztr_lookup_mdata_value(z, chunks[i], &quotOFFS&quot);\newline		dump_samples4_solexa(files[3], lane, tile, x, y,\newline				     key ? atoi(key) : 0,\newline				     (uc *)chunks[i]-&gtdata+2,\newline				     chunks[i]-&gtdlength-2);\newline		break;\newline	    }\newline	}\newline    }\newline\newline    if (mode &amp NSE) {\newline	chunks = ztr_find_chunks(z, ZTR_TYPE_SMP4, &ampnc);\newline	for (i = 0; i &lt nc; i++) {\newline	    char *key = ztr_lookup_mdata_value(z, chunks[i], &quotTYPE&quot);\newline	    if (key &amp&amp 0 == strcmp(key, &quotSLXN&quot)) {\newline		key = ztr_lookup_mdata_value(z, chunks[i], &quotOFFS&quot);\newline		dump_samples4_solexa(files[4], lane, tile, x, y,\newline				     key ? atoi(key) : 0,\newline				     (uc *)chunks[i]-&gtdata+2,\newline				     chunks[i]-&gtdlength-2);\newline		break;\newline	    }\newline	}\newline    }\newline}\newline","\newline Prints a read in solexa format. Depending on the given chunk type mode,\newline only some of the chunks are printed out for every read. The files are\newline given in the following order: seq, prb, sig2, int, nse. The files must\newline already be open.\newline \newline",1321381,ppc_vec.c,"void ppc_opc_vslo()\newline{\newline	VECTOR_DEBUG;\newline	int vrD, vrA, vrB;\newline	Vector_t r;\newline	int shift, i;\newline	PPC_OPC_TEMPL_X(gCPU.current_opc, vrD, vrA, vrB);\newline\newline	shift = (gCPU.vr[vrB].w[0] &gt&gt 3) &amp 0xf;\newline#if HOST_ENDIANESS == HOST_ENDIANESS_LE\newline	for (i=0; i&ltshift; i++) {\newline		r.b[i] = 0;\newline	}\newline\newline	for (; i&lt16; i++) {\newline		r.b[i] = gCPU.vr[vrA].b[i-shift];\newline	}\newline#elif HOST_ENDIANESS == HOST_ENDIANESS_BE\newline	for (i=0; i&lt(16-shift); i++) {\newline		r.b[i] = gCPU.vr[vrA].b[i+shift];\newline	}\newline\newline	for (; i&lt16; i++) {\newline		r.b[i] = 0;\newline	}\newline#else\newline#error Endianess not supported!\newline#endif\newline\newline	gCPU.vr[vrD] = r;\newline}\newline",vslo Vector Shift Left Octet\newline v.243\newline \newline,574675,misdn.c,"static int handle_tsX_write(struct osmo_fd *bfd, int len)\newline{\newline	struct e1inp_line *line = bfd-&gtdata;\newline	unsigned int ts_nr = bfd-&gtpriv_nr;\newline	struct e1inp_ts *e1i_ts = &ampline-&gtts[ts_nr-1];\newline	struct mISDNhead *hh;\newline	uint8_t tx_buf[len + sizeof(*hh)];\newline	struct subch_mux *mx = &ampe1i_ts-&gttrau.mux;\newline	int ret;\newline\newline	hh = (struct mISDNhead *) tx_buf;\newline	hh-&gtprim = PH_DATA_REQ;\newline	hh-&gtid = 0;\newline\newline	subchan_mux_out(mx, tx_buf+sizeof(*hh), len);\newline\newline	DEBUGP(DLMIB, &quotBCHAN TX: %s\\n&quot,\newline		osmo_hexdump(tx_buf+sizeof(*hh), len));\newline\newline	ret = send(bfd-&gtfd, tx_buf, sizeof(*hh) + len, 0);\newline	if (ret &lt sizeof(*hh) + len)\newline		DEBUGP(DLMIB, &quotsend returns %d instead of %zu\\n&quot, ret,\newline			sizeof(*hh) + len);\newline\newline	return ret;\newline}\newline",write to a B channel TS \newline,6301895,ident.c,"idresult_e log_remote_user( const struct server *serp, unsigned timeout )\newline{\newline   static char         buf[ IBUFSIZE ] ;\newline   int                 cc ;\newline   union xsockaddr     sin_local, sin_remote, sin_contact, sin_bind;\newline   volatile unsigned   local_port;\newline   volatile unsigned   remote_port;\newline   int                 sd ;\newline   socklen_t           sin_len ;\newline   char               *p ;\newline   const char         *func = &quotlog_remote_user&quot ;\newline\newline   if ( timeout &amp&amp signal( SIGALRM, sigalrm_handler ) == SIG_ERR )\newline   {\newline      msg( LOG_ERR, func, &quotsignal: %m&quot ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline\newline   /*\newline    * Determine local and remote addresses\newline    */\newline   sin_len = sizeof( sin_local ) ;\newline   if ( getsockname( SERVER_FD( serp ), &ampsin_local.sa, &ampsin_len ) == -1 )\newline   {\newline      msg( LOG_ERR, func, &quot(%d) getsockname: %m&quot, getpid() ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline\newline   if ( CONN_XADDRESS( SERVER_CONNECTION( serp ) ) == NULL )\newline   {\newline      /*\newline       * This shouldn&#039t happen since identification only works for\newline       * connection-based services.\newline       */\newline      msg( LOG_ERR, func, &quotconnection has no address&quot ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline\newline   CLEAR( sin_contact );\newline   sin_remote = *CONN_XADDRESS( SERVER_CONNECTION( serp ) ) ;\newline   sin_contact = sin_remote;\newline   memcpy( &ampsin_bind, &ampsin_local, sizeof(sin_bind) ) ;\newline   local_port = 0;\newline   remote_port = 0;\newline   if( sin_remote.sa.sa_family == AF_INET ) {\newline      local_port = ntohs( sin_local.sa_in6.sin6_port ) ;\newline      remote_port = ntohs( sin_remote.sa_in6.sin6_port ) ;\newline      sin_contact.sa_in6.sin6_port = htons( IDENTITY_SERVICE_PORT ) ;\newline      sin_bind.sa_in.sin_port = 0 ;\newline   } else if( sin_remote.sa.sa_family == AF_INET6 ) {\newline      local_port = ntohs( sin_local.sa_in.sin_port ) ;\newline      remote_port = ntohs( sin_remote.sa_in.sin_port ) ;\newline      sin_contact.sa_in.sin_port = htons( IDENTITY_SERVICE_PORT ) ;\newline      sin_bind.sa_in6.sin6_port = 0 ;\newline   }\newline\newline   /*\newline    * Create a socket, bind it, and set the close-on-exec flag on the\newline    * descriptor. We set the flag in case we are called as part of a \newline    * successful attempt to start a server (i.e. execve will follow). \newline    * The socket must be bound to the receiving address or ident might \newline    * fail for multi-homed hosts.\newline    */\newline   sd = socket( sin_remote.sa.sa_family, SOCK_STREAM, 0 ) ;\newline   if ( sd == -1 )\newline   {\newline      msg( LOG_ERR, func, &quotsocket creation: %m&quot ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline   if ( bind(sd, &ampsin_bind.sa, sizeof(sin_bind.sa)) == -1 )\newline   { \newline      msg( LOG_ERR, func, &quotsocket bind: %m&quot ) ;\newline      (void) Sclose( sd ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline   if ( fcntl( sd, F_SETFD, FD_CLOEXEC ) == -1 )\newline   {\newline      msg( LOG_ERR, func, &quotfcntl F_SETFD: %m&quot ) ;\newline      (void) Sclose( sd ) ;\newline      return( IDR_ERROR ) ;\newline   }\newline\newline   if ( timeout ) {\newline      if ( sigsetjmp( env, 1 ) == 0 )\newline         START_TIMER( timeout ) ;\newline      else {\newline         Sclose( sd ) ;\newline         return( IDR_TIMEDOUT ) ;\newline      }\newline   }\newline\newline   if ( connect( sd, &ampsin_contact.sa, sizeof( sin_contact ) ) == -1 )\newline   {\newline      if ( timeout ) {\newline         STOP_TIMER() ;\newline         signal ( SIGALRM, SIG_DFL ) ;\newline      }\newline      Sclose( sd );\newline      return( IDR_NOSERVER ) ;\newline   }\newline\newline   cc = strx_nprint( buf, sizeof( buf ), \newline      &quot%d,%d\\r\\n&quot, remote_port, local_port ) ;\newline   if ( write_buf( sd, buf, cc ) == FAILED )\newline   {\newline      if ( timeout ) {\newline         STOP_TIMER() ;\newline         signal ( SIGALRM, SIG_DFL ) ;\newline      }\newline      Sclose( sd );\newline      return( IDR_ERROR ) ;\newline   }\newline\newline   p = get_line( sd, buf, sizeof( buf ) ) ;\newline\newline   if ( timeout ) {\newline      STOP_TIMER() ;\newline      signal ( SIGALRM, SIG_DFL ) ;\newline   }\newline\newline   if ( p == NULL ) {\newline      Sclose( sd );\newline      return( IDR_RESPERR ) ;\newline   }\newline   \newline   /*\newline    * Verify that the received line is OK\newline    */\newline   if ( ( p = verify_line( buf, local_port, remote_port ) ) == NULL )\newline   {\newline      msg(LOG_ERR, func, &quotBad line received from identity server at %s: %s&quot,\newline         xaddrname( &ampsin_remote ), buf ) ;\newline      Sclose( sd );\newline      return( IDR_BADRESP ) ;\newline   }\newline\newline   svc_logprint( SERVER_CONNSERVICE( serp ), USERID_ENTRY, &quot%s&quot, p ) ;\newline   return( IDR_OK ) ;\newline}\newline",\newline This function always runs in a forked process.\newline \newline,1118853,pyfwnt_access_control_entry.c,"PyObject *pyfwnt_access_control_entry_get_flags(\newline           pyfwnt_access_control_entry_t *pyfwnt_access_control_entry,\newline           PyObject *arguments PYFWNT_ATTRIBUTE_UNUSED )\newline{\newline	libcerror_error_t *error = NULL;\newline	PyObject *integer_object = NULL;\newline	static char *function    = &quotpyfwnt_access_control_entry_get_flags&quot;\newline	uint8_t flags            = 0;\newline	int result               = 0;\newline\newline	PYFWNT_UNREFERENCED_PARAMETER( arguments )\newline\newline	if( pyfwnt_access_control_entry == NULL )\newline	{\newline		PyErr_Format(\newline		 PyExc_TypeError,\newline		 &quot%s: invalid access control entry.&quot,\newline		 function );\newline\newline		return( NULL );\newline	}\newline	Py_BEGIN_ALLOW_THREADS\newline\newline	result = libfwnt_access_control_entry_get_flags(\newline	          pyfwnt_access_control_entry-&gtaccess_control_entry,\newline	          &ampflags,\newline	          &amperror );\newline\newline	Py_END_ALLOW_THREADS\newline\newline	if( result != 1 )\newline	{\newline		pyfwnt_error_raise(\newline		 error,\newline		 PyExc_IOError,\newline		 &quot%s: unable to retrieve flags.&quot,\newline		 function );\newline\newline		libcerror_error_free(\newline		 &amperror );\newline\newline		return( NULL );\newline	}\newline#if PY_MAJOR_VERSION &gt= 3\newline	integer_object = PyLong_FromLong(\newline	                  (long) flags );\newline#else\newline	integer_object = PyInt_FromLong(\newline	                  (long) flags );\newline#endif\newline	return( integer_object );\newline}\newline",Retrieves the flags\newline Returns a Python object if successful or NULL on error\newline \newline,6659248,cdw_graftpoints.c,"cdw_rv_t cdw_graftpoints_open_file(void)\newline{\newline	cdw_assert (graftpoints_file == CDW_FILE_CLOSED, &quotcalled the function to open second file\\n&quot);\newline	cdw_assert (graftpoints_fullpath == (char *) NULL,\newline		    &quotyou forgot to clean up when closing previous file\\n&quot);\newline\newline	const char *tmp_dir = cdw_fs_get_tmp_dir_fullpath();\newline	if (tmp_dir == (char *) NULL) {\newline		cdw_vdm (&quotERROR: failed to get path to tmp dir\\n&quot);\newline		return CDW_ERROR;\newline	}\newline\newline	/* random part of file name, 10 digits + &#039\\0&#039 */\newline	/* address of the table will be also used as pseudo random string;\newline	   I know that this is a poor choice, but it will be used only\newline	   when time() fails, so not too often */\newline	char random_string[RANDOM_STRING_LEN + 1];\newline\newline	set_string_random(random_string);\newline	/* TODO: file name is (more or less) random, now make it safe (think\newline	   race conditions etc.) */\newline\newline	graftpoints_fullpath = cdw_string_concat(tmp_dir, &quotcdw_tmp_graft_&quot, random_string, (char * ) NULL);\newline	if (graftpoints_fullpath == (char *) NULL) {\newline		cdw_vdm (&quotERROR: failed to create path to graftpoint file\\n&quot);\newline		return CDW_ERROR;\newline	}\newline\newline	graftpoints_file = open(graftpoints_fullpath, O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);\newline	if (graftpoints_file == -1) {\newline		cdw_vdm (&quotERROR: failed to open graftpoints file\\n&quot);\newline\newline		free(graftpoints_fullpath);\newline		graftpoints_fullpath = (char *) NULL;\newline		graftpoints_file = CDW_FILE_CLOSED;\newline\newline		return CDW_ERROR;\newline	} else {\newline		return CDW_OK;\newline	}\newline}\newline","\newline\\brief Create new graftpoints file\newlineFunction opens in tmp directory new file with random name.\newlineThe file can be used as graftpoint file for mkisofs.\newlineVariable char graftpoints_fullpath (global in file) is set to\newlinefull path to graftpoint file. It can also be set to (char ) NULL if\newlinefile cannot be open.\newlineFile descriptor of open graftpoints file should be unique - there cannot\newlinebe two open graftpoints at the same time. Therefore this function\newlinereturns CDW_ERROR if some graftpoints file is already open. If such\newlinesituation occurs, then this is a sign of programming error.\newlineIn case of errors graftpoints_fullpath is set to (char ) NULL, and\newlinegraftpoints_file is set to CDW_FILE_CLOSED.\newline\\return CDW_ERROR on errors\newline\\return CDW_OK on success\newline \newline",4932722,view.c,"float V_CalcRoll (const vec3_t angles, const vec3_t velocity)\newline{\newline	vec3_t	right;\newline	float	sign;\newline	float	side;\newline	float	value;\newline\newline	AngleVectors (angles, NULL, right, NULL);\newline	side = DotProduct (velocity, right);\newline	sign = side &lt 0 ? -1 : 1;\newline	side = fabs(side);\newline\newline	value = cl_rollangle.value;\newline\newline	if (side &lt cl_rollspeed.value)\newline		side = side * value / cl_rollspeed.value;\newline	else\newline		side = value;\newline\newline	return side*sign;\newline\newline}\newline",\newline===============\newlineV_CalcRoll\newlineUsed by view and sv_user\newline===============\newline \newline,1885033,graph.c,"static void set_layout(RAGraph *g) {\newline	int i, j, k;\newline\newline	r_list_free (g-&gtedges);\newline	g-&gtedges = r_list_new ();\newline\newline	remove_cycles (g);\newline	assign_layers (g);\newline	create_dummy_nodes (g);\newline	create_layers (g);\newline	minimize_crossings (g);\newline\newline	/* identify row height */\newline	for (i = 0; i &lt g-&gtn_layers; i++) {\newline		int rh = 0;\newline		for (j = 0; j &lt g-&gtlayers[i].n_nodes; ++j) {\newline			const RANode *n = get_anode (g-&gtlayers[i].nodes[j]);\newline			if (n-&gth &gt rh) {\newline				rh = n-&gth;\newline			}\newline		}\newline		g-&gtlayers[i].height = rh;\newline	}\newline\newline	/* x-coordinate assignment: algorithm based on:\newline	 * A Fast Layout Algorithm for k-Level Graphs\newline	 * by C. Buchheim, M. Junger, S. Leipert */\newline	place_dummies (g);\newline	place_original (g);\newline\newline	/* vertical align */\newline	for (i = 0; i &lt g-&gtn_layers; ++i) {\newline		for (j = 0; j &lt g-&gtlayers[i].n_nodes; ++j) {\newline			RANode *n = get_anode (g-&gtlayers[i].nodes[j]);\newline			n-&gty = 1;\newline			for (k = 0; k &lt n-&gtlayer; ++k) {\newline				n-&gty += g-&gtlayers[k].height + VERTICAL_NODE_SPACING;\newline			}\newline		}\newline	}\newline\newline	/* finalize x coordinate */\newline	for (i = 0; i &lt g-&gtn_layers; ++i) {\newline		for (j = 0; j &lt g-&gtlayers[i].n_nodes; ++j) {\newline			RANode *n = get_anode (g-&gtlayers[i].nodes[j]);\newline			n-&gtx -= n-&gtw / 2;\newline		}\newline	}\newline\newline	restore_original_edges (g);\newline	remove_dummy_nodes (g);\newline\newline	/* free all temporary structures used during layout */\newline	for (i = 0; i &lt g-&gtn_layers; ++i) {\newline		free (g-&gtlayers[i].nodes);\newline	}\newline	free (g-&gtlayers);\newline	r_list_free (g-&gtlong_edges);\newline	r_list_free (g-&gtback_edges);\newline}\newline","1) trasform the graph into a DAG\newline 2) partition the nodes in layers\newline 3) split long edges that traverse multiple layers\newline 4) reorder nodes in each layer to reduce the number of edge crossing\newline 5) assign x and y coordinates to each node\newline 6) restore the original graph, with long edges and cycles \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,5948053,reconstruct_network.c,"static inline bool nextCombination(InputCombination * comb)\newline{\newline	bool posChanged = false;\newline\newline	// find the first position that has not been set\newline	// to its maximum number\newline	while(comb-&gtpos &lt comb-&gtk - comb-&gtnumFixed &amp&amp \newline	      comb-&gtintComb[comb-&gtpos] == comb-&gtnumAvailable - comb-&gtpos - 1)\newline	{\newline		++ (comb-&gtpos);\newline		posChanged = true;\newline	}\newline	if (comb-&gtpos == comb-&gtk - comb-&gtnumFixed)\newline	{\newline		// all elements have been listed\newline		return false;\newline  }\newline	if (posChanged)\newline	// reset lower-order positions, and increase\newline	// the position found previously\newline	{\newline		unsigned int i;\newline		++comb-&gtintComb[comb-&gtpos];\newline		for (i = comb-&gtpos; i &gt 0; --i)\newline			comb-&gtintComb[i-1] = comb-&gtintComb[i] + 1;\newline		comb-&gtpos = 0;\newline	}\newline	else\newline	// the current position has not been set to its maximum value\newline	// =&gt increase it\newline		++comb-&gtintComb[comb-&gtpos];\newline	\newline	unsigned int j;	\newline	for (j = 0; j &lt comb-&gtk - comb-&gtnumFixed; ++j)\newline	{\newline		comb-&gtcomb[comb-&gtnumFixed + j] = comb-&gtindexMapping[comb-&gtintComb[j]];\newline  }\newline  \newline  //for (j = 0; j &lt comb-&gtk; ++j)\newline  //  Rprintf(&quot%d &quot,comb-&gtcomb[j]);\newline  //Rprintf(&quot\\n&quot);  \newline    \newline	\newline	return true;\newline}\newline","\newline A function that iteratively returns all &ltn&gt choose &ltk&gt combinations of input genes\newline if called multiple times.\newline The function receives an input array &ltcomb&gt containing the previous combination.\newline Before the first call, this combination must be initialized to {k-1, k-2, ... , 0},\newline and &ltpos&gt must be set to 0.\newline After each call, &ltcomb&gt contains the next combination. If all combinations have been\newline listed, the function returns false, otherwise true.\newline \newline",2729825,epr_band.c,"float epr_get_scaling_factor(EPR_SProductId* product_id,  const char* str) {\newline    EPR_SDatasetRef scal_fact;\newline    const EPR_SField* field = NULL;\newline    EPR_SRecord* record = NULL;\newline    float ziff;\newline\newline    scal_fact = epr_get_ref_struct(product_id, str);\newline    if (scal_fact.dataset_id == NULL) {\newline        return (float)(-909.909);\newline    }\newline\newline    /*&#039Scaling_Factor_GADS&#039*/\newline    record = epr_create_record(scal_fact.dataset_id);\newline    record = epr_read_record(scal_fact.dataset_id, 0, record);\newline\newline    field = epr_get_field_at(record, scal_fact.field_index - 1);\newline    ziff = epr_get_field_elem_as_float(field, (uint)(scal_fact.elem_index - 1));\newline\newline    epr_free_record(record);\newline\newline    return ziff;\newline}\newline","\newline Gets the scaling factor by the given dataset_id, field_index, elem_index\newline \newline @param product_id the the product file identifier\newline @param str the string with the name, separator (&#039.&#039) and indexes.\newline @return the dataset_id, field_index and elem_index (-1 if no).\newline &ltcode&gtNULL&lt/code&gt if correspondent dataset name was not found.\newline \newline",,,,on,on,,,,on,on,,,,,on,on,,,,,,,,,,,,,,,,,,,,,,,,,,,Binds a datagram socket to a local port and address.,Private helper to check SDL_UnionRect results,Prints a read in solexa format.,{},{},This function always runs in a forked process.,Returns a Python object if successful or NULL on error,The file can be used as graftpoint file for mkisofs.,{},{},Load an image from the named file.,Movie header Box,if called multiple times.,"Gets the scaling factor by the given dataset_id, field_index, elem_index",{},{},Remove widget from perspective,Creates a new TOPIC command with type IrcCommand::Topic,Returns: 1 if label driver disabled.,This routine initializes our list meta data.,hier beginnt Function bqshe88,x,
3K1H3NEY7LZYZEG1EC3PQYYKA4IGDN,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:38 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:38 PDT 2019,,,3P1L2B7AD1P7CNIK5EJM33BGSUTOL0,AITP2LUW8GPB,Submitted,Fri Apr 26 12:49:11 PDT 2019,Fri Apr 26 13:28:18 PDT 2019,Sun Apr 28 13:28:18 PDT 2019,,,,2347,100% (62/62),100% (62/62),0% (0/0),286803,main.c,"static void *thread_dispatch_ust_registration(void *data)\newline{\newline	int ret, err = -1;\newline	struct cds_wfcq_node *node;\newline	struct ust_command *ust_cmd = NULL;\newline	struct ust_reg_wait_node *wait_node = NULL, *tmp_wait_node;\newline	struct ust_reg_wait_queue wait_queue = {\newline		.count = 0,\newline	};\newline\newline	rcu_register_thread();\newline\newline	health_register(health_sessiond, HEALTH_SESSIOND_TYPE_APP_REG_DISPATCH);\newline\newline	if (testpoint(sessiond_thread_app_reg_dispatch)) {\newline		goto error_testpoint;\newline	}\newline\newline	health_code_update();\newline\newline	CDS_INIT_LIST_HEAD(&ampwait_queue.head);\newline\newline	DBG(&quot[thread] Dispatch UST command started&quot);\newline\newline	for (;;) {\newline		health_code_update();\newline\newline		/* Atomically prepare the queue futex */\newline		futex_nto1_prepare(&ampust_cmd_queue.futex);\newline\newline		if (CMM_LOAD_SHARED(dispatch_thread_exit)) {\newline			break;\newline		}\newline\newline		do {\newline			struct ust_app *app = NULL;\newline			ust_cmd = NULL;\newline\newline			/*\newline			 * Make sure we don&#039t have node(s) that have hung up before receiving\newline			 * the notify socket. This is to clean the list in order to avoid\newline			 * memory leaks from notify socket that are never seen.\newline			 */\newline			sanitize_wait_queue(&ampwait_queue);\newline\newline			health_code_update();\newline			/* Dequeue command for registration */\newline			node = cds_wfcq_dequeue_blocking(&ampust_cmd_queue.head, &ampust_cmd_queue.tail);\newline			if (node == NULL) {\newline				DBG(&quotWoken up but nothing in the UST command queue&quot);\newline				/* Continue thread execution */\newline				break;\newline			}\newline\newline			ust_cmd = caa_container_of(node, struct ust_command, node);\newline\newline			DBG(&quotDispatching UST registration pid:%d ppid:%d uid:%d&quot\newline					&quot gid:%d sock:%d name:%s (version %d.%d)&quot,\newline					ust_cmd-&gtreg_msg.pid, ust_cmd-&gtreg_msg.ppid,\newline					ust_cmd-&gtreg_msg.uid, ust_cmd-&gtreg_msg.gid,\newline					ust_cmd-&gtsock, ust_cmd-&gtreg_msg.name,\newline					ust_cmd-&gtreg_msg.major, ust_cmd-&gtreg_msg.minor);\newline\newline			if (ust_cmd-&gtreg_msg.type == USTCTL_SOCKET_CMD) {\newline				wait_node = zmalloc(sizeof(*wait_node));\newline				if (!wait_node) {\newline					PERROR(&quotzmalloc wait_node dispatch&quot);\newline					ret = close(ust_cmd-&gtsock);\newline					if (ret &lt 0) {\newline						PERROR(&quotclose ust sock dispatch %d&quot, ust_cmd-&gtsock);\newline					}\newline					lttng_fd_put(LTTNG_FD_APPS, 1);\newline					free(ust_cmd);\newline					goto error;\newline				}\newline				CDS_INIT_LIST_HEAD(&ampwait_node-&gthead);\newline\newline				/* Create application object if socket is CMD. */\newline				wait_node-&gtapp = ust_app_create(&ampust_cmd-&gtreg_msg,\newline						ust_cmd-&gtsock);\newline				if (!wait_node-&gtapp) {\newline					ret = close(ust_cmd-&gtsock);\newline					if (ret &lt 0) {\newline						PERROR(&quotclose ust sock dispatch %d&quot, ust_cmd-&gtsock);\newline					}\newline					lttng_fd_put(LTTNG_FD_APPS, 1);\newline					free(wait_node);\newline					free(ust_cmd);\newline					continue;\newline				}\newline				/*\newline				 * Add application to the wait queue so we can set the notify\newline				 * socket before putting this object in the global ht.\newline				 */\newline				cds_list_add(&ampwait_node-&gthead, &ampwait_queue.head);\newline				wait_queue.count++;\newline\newline				free(ust_cmd);\newline				/*\newline				 * We have to continue here since we don&#039t have the notify\newline				 * socket and the application MUST be added to the hash table\newline				 * only at that moment.\newline				 */\newline				continue;\newline			} else {\newline				/*\newline				 * Look for the application in the local wait queue and set the\newline				 * notify socket if found.\newline				 */\newline				cds_list_for_each_entry_safe(wait_node, tmp_wait_node,\newline						&ampwait_queue.head, head) {\newline					health_code_update();\newline					if (wait_node-&gtapp-&gtpid == ust_cmd-&gtreg_msg.pid) {\newline						wait_node-&gtapp-&gtnotify_sock = ust_cmd-&gtsock;\newline						cds_list_del(&ampwait_node-&gthead);\newline						wait_queue.count--;\newline						app = wait_node-&gtapp;\newline						free(wait_node);\newline						DBG3(&quotUST app notify socket %d is set&quot, ust_cmd-&gtsock);\newline						break;\newline					}\newline				}\newline\newline				/*\newline				 * With no application at this stage the received socket is\newline				 * basically useless so close it before we free the cmd data\newline				 * structure for good.\newline				 */\newline				if (!app) {\newline					ret = close(ust_cmd-&gtsock);\newline					if (ret &lt 0) {\newline						PERROR(&quotclose ust sock dispatch %d&quot, ust_cmd-&gtsock);\newline					}\newline					lttng_fd_put(LTTNG_FD_APPS, 1);\newline				}\newline				free(ust_cmd);\newline			}\newline\newline			if (app) {\newline				/*\newline				 * @session_lock_list\newline				 *\newline				 * Lock the global session list so from the register up to the\newline				 * registration done message, no thread can see the application\newline				 * and change its state.\newline				 */\newline				session_lock_list();\newline				rcu_read_lock();\newline\newline				/*\newline				 * Add application to the global hash table. This needs to be\newline				 * done before the update to the UST registry can locate the\newline				 * application.\newline				 */\newline				ust_app_add(app);\newline\newline				/* Set app version. This call will print an error if needed. */\newline				(void) ust_app_version(app);\newline\newline				/* Send notify socket through the notify pipe. */\newline				ret = send_socket_to_thread(apps_cmd_notify_pipe[1],\newline						app-&gtnotify_sock);\newline				if (ret &lt 0) {\newline					rcu_read_unlock();\newline					session_unlock_list();\newline					/*\newline					 * No notify thread, stop the UST tracing. However, this is\newline					 * not an internal error of the this thread thus setting\newline					 * the health error code to a normal exit.\newline					 */\newline					err = 0;\newline					goto error;\newline				}\newline\newline				/*\newline				 * Update newly registered application with the tracing\newline				 * registry info already enabled information.\newline				 */\newline				update_ust_app(app-&gtsock);\newline\newline				/*\newline				 * Don&#039t care about return value. Let the manage apps threads\newline				 * handle app unregistration upon socket close.\newline				 */\newline				(void) ust_app_register_done(app);\newline\newline				/*\newline				 * Even if the application socket has been closed, send the app\newline				 * to the thread and unregistration will take place at that\newline				 * place.\newline				 */\newline				ret = send_socket_to_thread(apps_cmd_pipe[1], app-&gtsock);\newline				if (ret &lt 0) {\newline					rcu_read_unlock();\newline					session_unlock_list();\newline					/*\newline					 * No apps. thread, stop the UST tracing. However, this is\newline					 * not an internal error of the this thread thus setting\newline					 * the health error code to a normal exit.\newline					 */\newline					err = 0;\newline					goto error;\newline				}\newline\newline				rcu_read_unlock();\newline				session_unlock_list();\newline			}\newline		} while (node != NULL);\newline\newline		health_poll_entry();\newline		/* Futex wait on queue. Blocking call on futex() */\newline		futex_nto1_wait(&ampust_cmd_queue.futex);\newline		health_poll_exit();\newline	}\newline	/* Normal exit, no error */\newline	err = 0;\newline\newlineerror:\newline	/* Clean up wait queue. */\newline	cds_list_for_each_entry_safe(wait_node, tmp_wait_node,\newline			&ampwait_queue.head, head) {\newline		cds_list_del(&ampwait_node-&gthead);\newline		wait_queue.count--;\newline		free(wait_node);\newline	}\newline\newline	/* Empty command queue. */\newline	for (;;) {\newline		/* Dequeue command for registration */\newline		node = cds_wfcq_dequeue_blocking(&ampust_cmd_queue.head, &ampust_cmd_queue.tail);\newline		if (node == NULL) {\newline			break;\newline		}\newline		ust_cmd = caa_container_of(node, struct ust_command, node);\newline		ret = close(ust_cmd-&gtsock);\newline		if (ret &lt 0) {\newline			PERROR(&quotclose ust sock exit dispatch %d&quot, ust_cmd-&gtsock);\newline		}\newline		lttng_fd_put(LTTNG_FD_APPS, 1);\newline		free(ust_cmd);\newline	}\newline\newlineerror_testpoint:\newline	DBG(&quotDispatch thread dying&quot);\newline	if (err) {\newline		health_error();\newline		ERR(&quotHealth error occurred in %s&quot, __func__);\newline	}\newline	health_unregister(health_sessiond);\newline	rcu_unregister_thread();\newline	return NULL;\newline}\newline",\newline Dispatch request from the registration threads to the application\newline communication thread.\newline \newline,683619,mgr.c,"static void test_mgr_old_a(int flag)\newline{\newline    int32 fid;              /* HDF file ID */\newline    int32 grid;             /* GRID for the interface */\newline    int32 ret;              /* generic return value */\newline    char oldrlefile[512] = &quot&quot;\newline    char *srcdir = getenv(&quotsrcdir&quot);\newline\newline    /* Generate the correct name for the test file, by prepending the source path */\newline    if (srcdir &amp&amp ((strlen(srcdir) + strlen(OLDRLEFILE) + 1) &lt sizeof(oldrlefile))) {\newline        strcpy(oldrlefile, srcdir);\newline        strcat(oldrlefile, &quot/&quot);\newline    }\newline    strcat(oldrlefile, OLDRLEFILE);\newline\newline/* A - Read RLE compressed data from old raster image file */\newline    MESSAGE(8, printf(&quotRead RLE compressed image\\n&quot););\newline\newline    /* Open up the existing datafile and get the image information from it */\newline    fid=Hopen(oldrlefile,DFACC_READ,0);\newline    CHECK_VOID(fid,FAIL,&quotHopen&quot);\newline\newline    /* Initialize the GR interface */\newline    grid=GRstart(fid);\newline    CHECK_VOID(grid,FAIL,&quotGRstart&quot);\newline\newline    {\newline        int32 riid;     /* RI ID for the new image */\newline        int32 dims[2]={10,10};    /* dimensions for the empty image */\newline        uint8 image[10][10]; /* space for the image data */\newline        uint8 image0[10][10]; /* space for the image data */\newline        int32 start[2]; /* start of image data to grab */\newline        int32 stride[2];/* stride of image data to grab */\newline        intn i,j;       /* indices */\newline\newline        /* Initialize data we are looking for in image */\newline        for (i = 0; i &lt 10; i++)\newline            for (j = 0; j &lt 10; j++)\newline                image0[i][j] = (uint8) (i + j);\newline\newline        /* Get the first image in this file */\newline        riid=GRselect(grid,0);\newline        CHECK_VOID(riid,FAIL,&quotGRselect&quot);\newline\newline        /* Read the whole image in */\newline        start[0]=start[1]=0;\newline        stride[0]=stride[1]=1;\newline        ret=GRreadimage(riid,start,stride,dims,image);\newline        CHECK_VOID(ret,FAIL,&quotGRreadimage&quot);\newline\newline        /* Verify correct image contents */\newline        if(HDmemcmp(image,image0,10*10)!=0) {\newline            MESSAGE(3, printf(&quotError reading data for RLE compressed image\\n&quot););\newline            num_errs++;\newline        } /* end if */\newline\newline        /* Close the empty image */\newline        ret=GRendaccess(riid);\newline        CHECK_VOID(ret,FAIL,&quotGRendaccess&quot);\newline    }\newline    \newline    /* Shut down the GR interface */\newline    ret=GRend(grid);\newline    CHECK_VOID(ret,FAIL,&quotGRend&quot);\newline\newline    /* Close the file */\newline    ret=Hclose(fid);\newline    CHECK_VOID(ret,FAIL,&quotHclose&quot);\newline} /* end test_mgr_old_a() */\newline",Sub-tests for test_mgr_old() \newline,799769,sortedcache.c,"void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\newline{\newline	khiter_t pos = git_strmap_lookup_index(sc-&gtmap, key);\newline	if (git_strmap_valid_index(sc-&gtmap, pos))\newline		return git_strmap_value_at(sc-&gtmap, pos);\newline	return NULL;\newline}\newline",lookup item by key \newline,4854698,db.c,"bool db_do_timestep(\newline  uint64 time,  /*!&lt Current time step value being performed */\newline  bool   final  /*!&lt Specifies that this is the final timestep */\newline) { PROFILE(DB_DO_TIMESTEP);\newline\newline  bool            retval;               /* Return value for this function */\newline  static sim_time curr_time;\newline  static uint64   last_sim_update = 0;\newline\newline#ifdef DEBUG_MODE\newline  if( debug_mode ) {\newline    if( final ) {\newline      print_output( &quotPerforming final timestep&quot, DEBUG, __FILE__, __LINE__ );\newline    } else {\newline      unsigned int rv = snprintf( user_msg, USER_MSG_LENGTH, &quotPerforming timestep #%&quot FMT64 &quotu&quot, time );\newline      assert( rv &lt USER_MSG_LENGTH );\newline      print_output( user_msg, DEBUG, __FILE__, __LINE__ );\newline    }\newline  }\newline#endif\newline\newline  num_timesteps++;\newline\newline  curr_time.lo    = (time &amp 0xffffffffLL);\newline  curr_time.hi    = ((time &gt&gt 32) &amp 0xffffffffLL);\newline  curr_time.full  = time;\newline  curr_time.final = final;\newline\newline  if( (timestep_update &gt 0) &amp&amp ((time - last_sim_update) &gt= timestep_update) &amp&amp !debug_mode &amp&amp !final ) {\newline    unsigned int rv;\newline    last_sim_update = time;\newline    /*@-formattype -formatcode -duplicatequals@*/\newline    printf( &quot\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\bPerforming timestep %10&quot FMT64 &quotu&quot, time );\newline    /*@=formattype =formatcode =duplicatequals@*/\newline    rv = fflush( stdout );\newline    assert( rv == 0 );\newline  }\newline\newline  /* Simulate the current timestep */\newline  retval = sim_simulate( &ampcurr_time );\newline\newline  /* If this is the last timestep, add the final list and do one more simulate */\newline  if( final &amp&amp retval ) {\newline    curr_time.lo   = 0xffffffff;\newline    curr_time.hi   = 0xffffffff;\newline    curr_time.full = 0xffffffffffffffffLL;\newline    retval = sim_simulate( &ampcurr_time );\newline  }\newline\newline#ifdef DEBUG_MODE\newline  if( debug_mode ) {\newline    print_output( &quotAssigning postsimulation signals...&quot, DEBUG, __FILE__, __LINE__ );\newline  }\newline#endif\newline\newline  if( retval ) {\newline\newline    /* Assign all stored values in current post-timestep to stored signals */\newline    symtable_assign( &ampcurr_time );\newline\newline    /* Perform non-blocking assignment */\newline    sim_perform_nba( &ampcurr_time );\newline\newline  }\newline\newline  PROFILE_END;\newline\newline  return( retval );\newline\newline}\newline","!\newline\\return Returns TRUE if simulation should continue to advance; otherwise, returns FALSE\newlineto indicate that simulation should stop immediately.\newline\\throws anonymous symtable_assign\newlineCycles through expression queue, performing expression evaluations as we go. If\newlinean expression has a parent expression, that parent expression is placed in the\newlineexpression queue after that expression has completed its evaluation. When the\newlineexpression queue is empty, we are finished for this clock period.\newline \newline",2613575,tok_parse.c,"static int Tokenizer_handle_list_marker(Tokenizer* self)\newline{\newline    PyObject *kwargs, *markup;\newline    Unicode code = Tokenizer_read(self, 0);\newline\newline    if (code == &#039;&#039)\newline        self-&gttopstack-&gtcontext |= LC_DLTERM;\newline    kwargs = PyDict_New();\newline    if (!kwargs)\newline        return -1;\newline    if (!(markup = PyUnicode_FROM_SINGLE(code))) {\newline        Py_DECREF(kwargs);\newline        return -1;\newline    }\newline    PyDict_SetItemString(kwargs, &quotwiki_markup&quot, markup);\newline    Py_DECREF(markup);\newline    if (Tokenizer_emit_kwargs(self, TagOpenOpen, kwargs))\newline        return -1;\newline    if (Tokenizer_emit_text(self, GET_HTML_TAG(code)))\newline        return -1;\newline    if (Tokenizer_emit(self, TagCloseSelfclose))\newline        return -1;\newline    return 0;\newline}\newline","\newlineHandle a list marker at the head (#, , ;, :).\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,517284,select.c,"void socket_poll (HANDLE hStop, void *_data)\newline{\newline  LPSELECTDATA   lpSelectData;\newline  LPSELECTQUERY    iterQuery;\newline  HANDLE           aEvents[MAXIMUM_SELECT_OBJECTS];\newline  DWORD            nEvents;\newline  long             maskEvents;\newline  DWORD            i;\newline  u_long           iMode;\newline  SELECTMODE       mode;\newline  WSANETWORKEVENTS events;\newline\newline  lpSelectData = (LPSELECTDATA)_data;\newline\newline  DEBUG_PRINT(&quotWorker has %d queries to service&quot, lpSelectData-&gtnQueriesCount);\newline  for (nEvents = 0; nEvents &lt lpSelectData-&gtnQueriesCount; nEvents++)\newline  {\newline    iterQuery = &amp(lpSelectData-&gtaQueries[nEvents]);\newline    aEvents[nEvents] = CreateEvent(NULL, TRUE, FALSE, NULL);\newline    maskEvents = 0;\newline    mode = iterQuery-&gtEMode;\newline    if ((mode &amp SELECT_MODE_READ) != 0)\newline    {\newline      DEBUG_PRINT(&quotPolling read for %d&quot, iterQuery-&gthFileDescr);\newline      maskEvents |= FD_READ | FD_ACCEPT | FD_CLOSE;\newline    }\newline    if ((mode &amp SELECT_MODE_WRITE) != 0)\newline    {\newline      DEBUG_PRINT(&quotPolling write for %d&quot, iterQuery-&gthFileDescr);\newline      maskEvents |= FD_WRITE | FD_CONNECT | FD_CLOSE;\newline    }\newline    if ((mode &amp SELECT_MODE_EXCEPT) != 0)\newline    {\newline      DEBUG_PRINT(&quotPolling exceptions for %d&quot, iterQuery-&gthFileDescr);\newline      maskEvents |= FD_OOB;\newline    }\newline\newline    check_error(lpSelectData,\newline        WSAEventSelect(\newline          (SOCKET)(iterQuery-&gthFileDescr),\newline          aEvents[nEvents],\newline          maskEvents) == SOCKET_ERROR);\newline  }\newline\newline  /* Add stop event */\newline  aEvents[nEvents]  = hStop;\newline  nEvents++;\newline\newline  if (lpSelectData-&gtnError == 0)\newline  {\newline    check_error(lpSelectData,\newline        WaitForMultipleObjects(\newline          nEvents,\newline          aEvents,\newline          FALSE,\newline          INFINITE) == WAIT_FAILED);\newline  };\newline\newline  if (lpSelectData-&gtnError == 0)\newline  {\newline    for (i = 0; i &lt lpSelectData-&gtnQueriesCount; i++)\newline    {\newline      iterQuery = &amp(lpSelectData-&gtaQueries[i]);\newline      if (WaitForSingleObject(aEvents[i], 0) == WAIT_OBJECT_0)\newline      {\newline        DEBUG_PRINT(&quotSocket %d has pending events&quot, (i - 1));\newline        if (iterQuery != NULL)\newline        {\newline          /* Find out what kind of events were raised\newline           */\newline          if (WSAEnumNetworkEvents((SOCKET)(iterQuery-&gthFileDescr), aEvents[i], &ampevents) == 0)\newline          {\newline            if ((iterQuery-&gtEMode &amp SELECT_MODE_READ) != 0 &amp&amp (events.lNetworkEvents &amp (FD_READ | FD_ACCEPT | FD_CLOSE)) != 0)\newline            {\newline              select_data_result_add(lpSelectData, SELECT_MODE_READ, iterQuery-&gtlpOrigIdx);\newline            }\newline            if ((iterQuery-&gtEMode &amp SELECT_MODE_WRITE) != 0 &amp&amp (events.lNetworkEvents &amp (FD_WRITE | FD_CONNECT | FD_CLOSE)) != 0)\newline            {\newline              select_data_result_add(lpSelectData, SELECT_MODE_WRITE, iterQuery-&gtlpOrigIdx);\newline            }\newline            if ((iterQuery-&gtEMode &amp SELECT_MODE_EXCEPT) != 0 &amp&amp (events.lNetworkEvents &amp FD_OOB) != 0)\newline            {\newline              select_data_result_add(lpSelectData, SELECT_MODE_EXCEPT, iterQuery-&gtlpOrigIdx);\newline            }\newline          }\newline        }\newline      }\newline      /* WSAEventSelect() automatically sets socket to nonblocking mode.\newline         Restore the blocking one. */\newline      if (iterQuery-&gtuFlagsFd &amp FLAGS_FD_IS_BLOCKING)\newline      {\newline        DEBUG_PRINT(&quotRestore a blocking socket&quot);\newline        iMode = 0;\newline        check_error(lpSelectData,\newline          WSAEventSelect((SOCKET)(iterQuery-&gthFileDescr), aEvents[i], 0) != 0 ||\newline          ioctlsocket((SOCKET)(iterQuery-&gthFileDescr), FIONBIO, &ampiMode) != 0);\newline      }\newline      else\newline      {\newline        check_error(lpSelectData,\newline          WSAEventSelect((SOCKET)(iterQuery-&gthFileDescr), aEvents[i], 0) != 0);\newline      };\newline\newline      CloseHandle(aEvents[i]);\newline      aEvents[i] = INVALID_HANDLE_VALUE;\newline    }\newline  }\newline}\newline",Monitor socket \newline,1821438,pool_memqcache.c,static void *pool_memory_cache_address(void)\newline{\newline	return shmem;\newline}\newline,\newline Return shared memory cache address\newline \newline,391984,xz_dec_stream.c,"enum xz_ret xz_dec_run(struct xz_dec *s, struct xz_buf *b)\newline{\newline	size_t in_start;\newline	size_t out_start;\newline	enum xz_ret ret;\newline\newline	if (s-&gtsingle_call)\newline		xz_dec_reset(s);\newline\newline	in_start = b-&gtin_pos;\newline	out_start = b-&gtout_pos;\newline	ret = dec_main(s, b);\newline\newline	if (s-&gtsingle_call) {\newline		if (ret == XZ_OK)\newline			ret = b-&gtin_pos == b-&gtin_size\newline					? XZ_DATA_ERROR : XZ_BUF_ERROR;\newline\newline		if (ret != XZ_STREAM_END) {\newline			b-&gtin_pos = in_start;\newline			b-&gtout_pos = out_start;\newline		}\newline\newline	} else if (ret == XZ_OK &amp&amp in_start == b-&gtin_pos\newline			&amp&amp out_start == b-&gtout_pos) {\newline		if (s-&gtallow_buf_error)\newline			ret = XZ_BUF_ERROR;\newline\newline		s-&gtallow_buf_error = true;\newline	} else {\newline		s-&gtallow_buf_error = false;\newline	}\newline\newline	return ret;\newline}\newline","\newline xz_dec_run() is a wrapper for dec_main() to handle some special cases in\newline multi-call and single-call decoding.\newline \newline In multi-call mode, we must return XZ_BUF_ERROR when it seems clear that we\newline are not going to make any progress anymore. This is to prevent the caller\newline from calling us infinitely when the input file is truncated or otherwise\newline corrupt. Since zlib-style API allows that the caller fills the input buffer\newline only when the decoder doesn&#039t produce any new output, we have to be careful\newline to avoid returning XZ_BUF_ERROR too easily: XZ_BUF_ERROR is returned only\newline after the second consecutive call to xz_dec_run() that makes no progress.\newline \newline In single-call mode, if we couldn&#039t decode everything and no error\newline occurred, either the input is truncated or the output buffer is too small.\newline Since we know that the last input byte never produces any output, we know\newline that if all the input was consumed and decoding wasn&#039t finished, the file\newline must be corrupt. Otherwise the output buffer has to be too small or the\newline file is corrupt in a way that decoding it produces too big output.\newline \newline If single-call decoding fails, we reset b-&gtin_pos and b-&gtout_pos back to\newline their original values. This is because with some filter chains there won&#039t\newline be any valid uncompressed data in the output buffer unless the decoding\newline actually succeeds (that&#039s the price to pay of using the output buffer as\newline the workspace).\newline \newline",2924914,graphobject.c,"PyObject *igraphmodule_Graph_write_gml(igraphmodule_GraphObject * self,\newline                                       PyObject * args, PyObject * kwds)\newline{\newline  PyObject *ids = Py_None, *fname = NULL;\newline  PyObject *creator = Py_None;\newline  igraph_vector_t idvec, *idvecptr=0;\newline  char *creator_str=0;\newline  igraphmodule_filehandle_t fobj;\newline\newline  static char *kwlist[] = {\newline    &quotf&quot, &quotcreator&quot, &quotids&quot, NULL\newline  };\newline\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quotO|OO&quot, kwlist, &ampfname, &ampcreator, &ampids))\newline    return NULL;\newline\newline  if (igraphmodule_filehandle_init(&ampfobj, fname, &quotw&quot))\newline    return NULL;\newline\newline  if (PyList_Check(ids)) {\newline    idvecptr = &ampidvec;\newline    if (igraphmodule_PyObject_to_vector_t(ids, idvecptr, 0)) {\newline      igraphmodule_filehandle_destroy(&ampfobj);\newline      return NULL;\newline    }\newline  }\newline\newline  if (creator != Py_None) {\newline    PyObject* o = PyObject_Str(creator);\newline    if (o == 0) {\newline      if (idvecptr)\newline        igraph_vector_destroy(idvecptr);\newline      igraphmodule_filehandle_destroy(&ampfobj);\newline    }\newline\newline    creator_str = PyString_CopyAsString(o);\newline    Py_DECREF(o);\newline\newline    if (creator_str == 0) {\newline      if (idvecptr)\newline        igraph_vector_destroy(idvecptr);\newline      igraphmodule_filehandle_destroy(&ampfobj);\newline    }\newline  }\newline\newline  if (igraph_write_graph_gml(&ampself-&gtg, igraphmodule_filehandle_get(&ampfobj),\newline        idvecptr, creator_str)) {\newline    if (idvecptr) { igraph_vector_destroy(idvecptr); }\newline    if (creator_str)\newline      free(creator_str);\newline    igraphmodule_filehandle_destroy(&ampfobj);\newline    igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline  if (idvecptr) { igraph_vector_destroy(idvecptr); }\newline  if (creator_str)\newline    free(creator_str);\newline  igraphmodule_filehandle_destroy(&ampfobj);\newline\newline  Py_RETURN_NONE;\newline}\newline",\\ingroup python_interface_graph\newline \\brief Writes the graph as a GML file\newline \\return none\newline \\sa igraph_write_graph_gml\newline \newline,2187466,dpid.c,"char *get_dpi_dir(char *dpidrc)\newline{\newline   FILE *In;\newline   int len;\newline   char *rcline = NULL, *value = NULL, *p;\newline\newline   if ((In = fopen(dpidrc, &quotr&quot)) == NULL) {\newline      ERRMSG(&quotdpi_dir&quot, &quotfopen&quot, errno);\newline      MSG_ERR(&quot - %s\\n&quot, dpidrc);\newline      return (NULL);\newline   }\newline\newline   while ((rcline = dGetline(In)) != NULL) {\newline      if (strncmp(rcline, &quotdpi_dir&quot, 7) == 0)\newline         break;\newline      dFree(rcline);\newline   }\newline   fclose(In);\newline\newline   if (!rcline) {\newline      ERRMSG(&quotdpi_dir&quot, &quotFailed to find a dpi_dir entry in dpidrc&quot, 0);\newline      MSG_ERR(&quotPut your dillo plugins path in %s\\n&quot, dpidrc);\newline      MSG_ERR(&quote.g. dpi_dir=/usr/local/lib/dillo/dpi\\n&quot);\newline      MSG_ERR(&quotwith no leading spaces.\\n&quot);\newline      value = NULL;\newline   } else {\newline      len = (int) strlen(rcline);\newline      if (len &amp&amp rcline[len - 1] == &#039\\n&#039)\newline         rcline[len - 1] = 0;\newline\newline      if ((p = strchr(rcline, &#039=&#039))) {\newline         while (*++p == &#039 &#039);\newline         value = dStrdup(p);\newline      } else {\newline         ERRMSG(&quotdpi_dir&quot, &quotstrchr&quot, 0);\newline         MSG_ERR(&quot - &#039=&#039 not found in %s\\n&quot, rcline);\newline         value = NULL;\newline      }\newline   }\newline\newline   dFree(rcline);\newline   return (value);\newline}\newline","! Get dpi directory path from dpidrc\newline \\Return\newline dpi directory on success, NULL on failure\newline \\Important\newline The dpi_dir definition in dpidrc must have no leading white space.\newline \newline",6395843,example2.c,"void SetVelocity(FL_OBJECT *obj, long val)\newline{\newline  dt = fl_get_slider_value(VelocitySlider);\newline}\newline",SetVelocity is the slider callback procedure; FORMS calls this\newline when the user moves the slider bar.\newline \newline,3100549,ide-cd.c,"static void cdrom_buffer_sectors (ide_drive_t *drive, unsigned long sector,\newline                                  int sectors_to_transfer)\newline{\newline	struct cdrom_info *info = &ampdrive-&gtcdrom_info;\newline\newline	/* Number of sectors to read into the buffer. */\newline	int sectors_to_buffer = MIN (sectors_to_transfer,\newline				     (SECTOR_BUFFER_SIZE &gt&gt SECTOR_BITS) -\newline				       info-&gtnsectors_buffered);\newline\newline	char *dest;\newline\newline	/* If we don&#039t yet have a sector buffer, try to allocate one.\newline	   If we can&#039t get one atomically, it&#039s not fatal -- we&#039ll just throw\newline	   the data away rather than caching it. */\newline	if (info-&gtsector_buffer == NULL) {\newline		info-&gtsector_buffer = (char *) kmalloc (SECTOR_BUFFER_SIZE,\newline							GFP_ATOMIC);\newline\newline		/* If we couldn&#039t get a buffer,\newline		   don&#039t try to buffer anything... */\newline		if (info-&gtsector_buffer == NULL)\newline			sectors_to_buffer = 0;\newline	}\newline\newline	/* If this is the first sector in the buffer, remember its number. */\newline	if (info-&gtnsectors_buffered == 0)\newline		info-&gtsector_buffered = sector;\newline\newline	/* Read the data into the buffer. */\newline	dest = info-&gtsector_buffer + info-&gtnsectors_buffered * SECTOR_SIZE;\newline	while (sectors_to_buffer &gt 0) {\newline		cdrom_in_bytes (drive, dest, SECTOR_SIZE);\newline		--sectors_to_buffer;\newline		--sectors_to_transfer;\newline		++info-&gtnsectors_buffered;\newline		dest += SECTOR_SIZE;\newline	}\newline\newline	/* Throw away any remaining data. */\newline	while (sectors_to_transfer &gt 0) {\newline		char dum[SECTOR_SIZE];\newline		cdrom_in_bytes (drive, dum, sizeof (dum));\newline		--sectors_to_transfer;\newline	}\newline}\newline","\newline Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector\newline buffer. Once the first sector is added, any subsequent sectors are\newline assumed to be continuous (until the buffer is cleared). For the first\newline sector added, SECTOR is its sector number. (SECTOR is then ignored until\newline the buffer is cleared.)\newline \newline",3928458,shctx.c,"int shared_context_init(SSL_CTX *ctx, int size)\newline{\newline	int ret = 0;\newline\newline	if (!shctx) {\newline		int i;\newline\newline#ifndef USE_SYSCALL_FUTEX\newline		pthread_mutexattr_t attr;\newline#endif /* USE_SYSCALL_FUTEX */\newline		struct shared_session *prev,*cur;\newline\newline		shctx = (struct shared_context *)mmap(NULL, sizeof(struct shared_context)+(size*sizeof(struct shared_session)),\newline								PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\newline		if (!shctx || shctx == MAP_FAILED)\newline			return -1;\newline\newline#ifdef USE_SYSCALL_FUTEX\newline		shctx-&gtwaiters = 0;\newline#else\newline		pthread_mutexattr_init(&ampattr);\newline		pthread_mutexattr_setpshared(&ampattr, PTHREAD_PROCESS_SHARED);\newline		pthread_mutex_init(&ampshctx-&gtmutex, &ampattr);\newline#endif\newline		memset(&ampshctx-&gtactive.key, 0, sizeof(struct ebmb_node));\newline		memset(&ampshctx-&gtfree.key, 0, sizeof(struct ebmb_node));\newline\newline		/* No duplicate authorized in tree: */\newline		shctx-&gtactive.key.node.branches.b[1] = (void *)1;\newline\newline		cur = &ampshctx-&gtactive;\newline		cur-&gtn = cur-&gtp = cur;\newline\newline		cur = &ampshctx-&gtfree;\newline		for ( i = 0 ; i &lt size ; i++) {\newline			prev = cur;\newline			cur = (struct shared_session *)((char *)prev + sizeof(struct shared_session));\newline			prev-&gtn = cur;\newline			cur-&gtp = prev;\newline		}\newline		cur-&gtn = &ampshctx-&gtfree;\newline		shctx-&gtfree.p = cur;\newline\newline		ret = size;\newline	}\newline\newline	/* set SSL internal cache size to external cache / 8  + 123 */\newline	SSL_CTX_sess_set_cache_size(ctx, size &gt&gt 3 | 0x3ff);\newline\newline	/* Set callbacks */\newline	SSL_CTX_sess_set_new_cb(ctx, shctx_new_cb);\newline	SSL_CTX_sess_set_get_cb(ctx, shctx_get_cb);\newline	SSL_CTX_sess_set_remove_cb(ctx, shctx_remove_cb);\newline\newline	return ret;\newline}\newline","Init shared memory context if not allocated and set SSL context callbacks\newline size is the max number of stored session\newline Returns: -1 on alloc failure, size if performs context alloc, and 0 if just perform\newline callbacks registration \newline",5940695,expense.c,"int plugin_gui_cleanup(void) {\newline   int b;\newline   \newline   jp_logf(JP_LOG_DEBUG, &quotExpense: plugin_gui_cleanup\\n&quot);\newline\newline   b=dialog_save_changed_record(scrolled_window, record_changed);\newline   if (b==DIALOG_SAID_2) {\newline      cb_add_new_record(NULL, GINT_TO_POINTER(record_changed));\newline   }\newline\newline   connect_changed_signals(DISCONNECT_SIGNALS);\newline\newline   free_myexpense_list(&ampglob_myexpense_list);\newline\newline   if (pane) {\newline      /* Remove the accelerators */\newline#ifndef ENABLE_STOCK_BUTTONS\newline      gtk_window_remove_accel_group(GTK_WINDOW(gtk_widget_get_toplevel(pane)), accel_group);\newline#endif\newline\newline      set_pref(PREF_EXPENSE_PANE, gtk_paned_get_position(GTK_PANED(pane)), NULL, TRUE);\newline      pane = NULL;\newline   }\newline   set_pref(PREF_EXPENSE_SORT_COLUMN, clist_col_selected, NULL, TRUE);\newline   set_pref(PREF_EXPENSE_SORT_ORDER, GTK_CLIST(clist)-&gtsort_type, NULL, TRUE);\newline\newline   plugin_last_time = time(NULL);\newline\newline   return EXIT_SUCCESS;\newline}\newline","\newline This function is called by J-Pilot before switching to another application.\newline The plugin is expected to perform any desirable cleanup operations before\newline its windows are terminated. Desirable actions include freeing allocated \newline memory, storing state variables, etc. \newline \newline",4153470,eurephia_init.c,"int setup_session_params(eurephiaCTX *ctx, eurephiaVALUES *cfg) {\newline        char buffer[22], value[22];\newline        char *fname = get_config_filename(NULL, &quoteurephiadm.cfg&quot);\newline        memset(&ampbuffer, 0, 22);\newline\newline        printf(&quot------------------------------------------------------------------------------\\n&quot);\newline        printf(&quot  eurephia :: SESSION PARAMETERS\\n&quot);\newline        printf(&quot------------------------------------------------------------------------------\\n\\n&quot);\newline\newline        get_console_input(buffer, 10,\newline                          &quoteurephiadmin: How many minutes before a session is auto logged out: [10]&quot, 0);\newline        memset(&ampvalue, 0, 22);\newline        snprintf(value, 20, &quot%i&quot, (atoi_nullsafe(buffer) &gt 0 ? atoi_nullsafe(buffer) : 10));\newline        if( !config_set(ctx, &quoteurephiadmin_autologout&quot, value) ) {\newline                fprintf(stderr, &quotFailed to set configuration settings in database\\n&quot);\newline                return 0;\newline        }\newline\newline        if( fname != NULL ) {\newline                printf(&quot\\nGenerating %s\\n&quot, fname);\newline                printf(&quot---------------------------------------------------------------\\n&quot);\newline                write_eurephiadmcfg_file(stdout, cfg);\newline                printf(&quot---------------------------------------------------------------\\n&quot);\newline                memset(&ampbuffer, 0, 22);\newline                get_console_input(buffer, 8, &quotDo you want this to be written to disk? [Yes]&quot, 0);\newline                if(  (buffer[0] == &#039\\n&#039) || (buffer[0] == &#039y&#039) || (buffer[0] == &#039Y&#039) ) {\newline                        FILE *f;\newline\newline                        if( (f = fopen(fname, &quotw&quot)) == NULL ) {\newline                                fprintf(stderr, &quotFailed to create %s\\n&quot, fname);\newline                                return 0;\newline                        }\newline                        write_eurephiadmcfg_file(f, cfg);\newline                        fclose(f);\newline                        printf(&quotWrote %s\\n&quot, fname);\newline                } else {\newline                        printf(&quotConfiguration file was not written to disk\\n&quot);\newline                }\newline        } else {\newline                printf(&quot\\n** ERROR ** Could not generate eurephiadm.cfg file due to file system restrictions.\\n&quot);\newline                printf(&quot            Skipping this part.\\n&quot);\newline        }\newline        printf(&quot\\n==============================================================================\\n\\n&quot);\newline\newline        return 1;\newline}\newline","\newline Guides the user through setting up session specific parameters, mainly for the admin utilities\newline \newline @param ctx eurephiaCTX\newline @param cfg Configuration arguments, given via the command line\newline \newline @return Returns 1 on success, otherwise 0.\newline \newline",2638386,test_c.cpp,"static ae_bool testspline3dunit_testlintrans(ae_state *_state)\newline{\newline    ae_frame _frame_block;\newline    spline3dinterpolant c;\newline    spline3dinterpolant c2;\newline    ae_int_t m;\newline    ae_int_t n;\newline    ae_int_t l;\newline    ae_int_t d;\newline    ae_vector x;\newline    ae_vector y;\newline    ae_vector z;\newline    ae_vector f;\newline    double a1;\newline    double a2;\newline    double a3;\newline    double b1;\newline    double b2;\newline    double b3;\newline    double tx;\newline    double ty;\newline    double tz;\newline    double vx;\newline    double vy;\newline    double vz;\newline    ae_vector v1;\newline    ae_vector v2;\newline    ae_int_t pass;\newline    ae_int_t passcount;\newline    ae_int_t xjob;\newline    ae_int_t yjob;\newline    ae_int_t zjob;\newline    double err;\newline    ae_int_t i;\newline    ae_bool result;\newline\newline    ae_frame_make(_state, &amp_frame_block);\newline    _spline3dinterpolant_init(&ampc, _state);\newline    _spline3dinterpolant_init(&ampc2, _state);\newline    ae_vector_init(&ampx, 0, DT_REAL, _state);\newline    ae_vector_init(&ampy, 0, DT_REAL, _state);\newline    ae_vector_init(&ampz, 0, DT_REAL, _state);\newline    ae_vector_init(&ampf, 0, DT_REAL, _state);\newline    ae_vector_init(&ampv1, 0, DT_REAL, _state);\newline    ae_vector_init(&ampv2, 0, DT_REAL, _state);\newline\newline    err = (double)(0);\newline    passcount = 15;\newline    for(pass=1; pass&lt=passcount; pass++)\newline    {\newline        testspline3dunit_buildrndgrid(ae_true, ae_false, &ampn, &ampm, &ampl, &ampd, &ampx, &ampy, &ampz, &ampf, _state);\newline        spline3dbuildtrilinearv(&ampx, n, &ampy, m, &ampz, l, &ampf, d, &ampc, _state);\newline        for(xjob=0; xjob&lt=1; xjob++)\newline        {\newline            for(yjob=0; yjob&lt=1; yjob++)\newline            {\newline                for(zjob=0; zjob&lt=1; zjob++)\newline                {\newline                    \newline                    /*\newline                     * Prepare\newline                     */\newline                    do\newline                    {\newline                        a1 = 2.0*ae_randomreal(_state)-1.0;\newline                    }\newline                    while(ae_fp_eq(a1,(double)(0)));\newline                    a1 = a1*xjob;\newline                    b1 = x.ptr.p_double[0]+ae_randomreal(_state)*(x.ptr.p_double[n-1]-x.ptr.p_double[0]+2.0)-1.0;\newline                    do\newline                    {\newline                        a2 = 2.0*ae_randomreal(_state)-1.0;\newline                    }\newline                    while(ae_fp_eq(a2,(double)(0)));\newline                    a2 = a2*yjob;\newline                    b2 = y.ptr.p_double[0]+ae_randomreal(_state)*(y.ptr.p_double[m-1]-y.ptr.p_double[0]+2.0)-1.0;\newline                    do\newline                    {\newline                        a3 = 2.0*ae_randomreal(_state)-1.0;\newline                    }\newline                    while(ae_fp_eq(a3,(double)(0)));\newline                    a3 = a3*zjob;\newline                    b3 = z.ptr.p_double[0]+ae_randomreal(_state)*(z.ptr.p_double[l-1]-z.ptr.p_double[0]+2.0)-1.0;\newline                    \newline                    /*\newline                     * Test XYZ\newline                     */\newline                    spline3dcopy(&ampc, &ampc2, _state);\newline                    spline3dlintransxyz(&ampc2, a1, b1, a2, b2, a3, b3, _state);\newline                    tx = x.ptr.p_double[0]+ae_randomreal(_state)*(x.ptr.p_double[n-1]-x.ptr.p_double[0]);\newline                    ty = y.ptr.p_double[0]+ae_randomreal(_state)*(y.ptr.p_double[m-1]-y.ptr.p_double[0]);\newline                    tz = z.ptr.p_double[0]+ae_randomreal(_state)*(z.ptr.p_double[l-1]-z.ptr.p_double[0]);\newline                    if( xjob==0 )\newline                    {\newline                        tx = b1;\newline                        vx = x.ptr.p_double[0]+ae_randomreal(_state)*(x.ptr.p_double[n-1]-x.ptr.p_double[0]);\newline                    }\newline                    else\newline                    {\newline                        vx = (tx-b1)/a1;\newline                    }\newline                    if( yjob==0 )\newline                    {\newline                        ty = b2;\newline                        vy = y.ptr.p_double[0]+ae_randomreal(_state)*(y.ptr.p_double[m-1]-y.ptr.p_double[0]);\newline                    }\newline                    else\newline                    {\newline                        vy = (ty-b2)/a2;\newline                    }\newline                    if( zjob==0 )\newline                    {\newline                        tz = b3;\newline                        vz = z.ptr.p_double[0]+ae_randomreal(_state)*(z.ptr.p_double[l-1]-z.ptr.p_double[0]);\newline                    }\newline                    else\newline                    {\newline                        vz = (tz-b3)/a3;\newline                    }\newline                    spline3dcalcv(&ampc, tx, ty, tz, &ampv1, _state);\newline                    spline3dcalcv(&ampc2, vx, vy, vz, &ampv2, _state);\newline                    for(i=0; i&lt=d-1; i++)\newline                    {\newline                        err = ae_maxreal(err, ae_fabs(v1.ptr.p_double[i]-v2.ptr.p_double[i], _state), _state);\newline                    }\newline                    if( ae_fp_greater(err,1.0E+4*ae_machineepsilon) )\newline                    {\newline                        result = ae_true;\newline                        ae_frame_leave(_state);\newline                        return result;\newline                    }\newline                    \newline                    /*\newline                     * Test F\newline                     */\newline                    spline3dcopy(&ampc, &ampc2, _state);\newline                    spline3dlintransf(&ampc2, a1, b1, _state);\newline                    tx = x.ptr.p_double[0]+ae_randomreal(_state)*(x.ptr.p_double[n-1]-x.ptr.p_double[0]);\newline                    ty = y.ptr.p_double[0]+ae_randomreal(_state)*(y.ptr.p_double[m-1]-y.ptr.p_double[0]);\newline                    tz = z.ptr.p_double[0]+ae_randomreal(_state)*(z.ptr.p_double[l-1]-z.ptr.p_double[0]);\newline                    spline3dcalcv(&ampc, tx, ty, tz, &ampv1, _state);\newline                    spline3dcalcv(&ampc2, tx, ty, tz, &ampv2, _state);\newline                    for(i=0; i&lt=d-1; i++)\newline                    {\newline                        err = ae_maxreal(err, ae_fabs(a1*v1.ptr.p_double[i]+b1-v2.ptr.p_double[i], _state), _state);\newline                    }\newline                }\newline            }\newline        }\newline    }\newline    result = ae_fp_greater(err,1.0E+4*ae_machineepsilon);\newline    ae_frame_leave(_state);\newline    return result;\newline}\newline",\newlineLinTrans test\newline \newline,6416508,abstractset.c,"GType gee_abstract_set_get_type (void) {\newline	static volatile gsize gee_abstract_set_type_id__volatile = 0;\newline	if (g_once_init_enter (&ampgee_abstract_set_type_id__volatile)) {\newline		static const GTypeInfo g_define_type_info = { sizeof (GeeAbstractSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_abstract_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeAbstractSet), 0, (GInstanceInitFunc) gee_abstract_set_instance_init, NULL };\newline		static const GInterfaceInfo gee_set_info = { (GInterfaceInitFunc) gee_abstract_set_gee_set_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};\newline		GType gee_abstract_set_type_id;\newline		gee_abstract_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_COLLECTION, &quotGeeAbstractSet&quot, &ampg_define_type_info, G_TYPE_FLAG_ABSTRACT);\newline		g_type_add_interface_static (gee_abstract_set_type_id, GEE_TYPE_SET, &ampgee_set_info);\newline		g_once_init_leave (&ampgee_abstract_set_type_id__volatile, gee_abstract_set_type_id);\newline	}\newline	return gee_abstract_set_type_id__volatile;\newline}\newline",\newline Skeletal implementation of the {@link Set} interface.\newline \newline Contains common code shared by all set implementations.\newline \newline @see HashSet\newline @see TreeSet\newline \newline,812254,qwebplugindatabase.cpp,void QWebPluginDatabase::addSearchPath(const QString&amp path)\newline{\newline    m_database-&gtaddExtraPluginDirectory(path);\newline    // PluginDatabase::addExtraPluginDirectory() does refresh the database.\newline}\newline,"!\newlineAdds an additional \\a path to the current set.\newlineThe database is automatically refreshed.\newline\\sa searchPaths(), setSearchPaths()\newline \newline",4385311,utility.c,"void ln_hequ_to_equ(struct lnh_equ_posn *hpos, struct ln_equ_posn *pos)\newline{\newline	pos-&gtra = ln_hms_to_deg(&amphpos-&gtra);\newline	pos-&gtdec = ln_dms_to_deg(&amphpos-&gtdec);\newline}\newline","! \\fn void ln_hequ_to_equ(struct lnh_equ_posn hpos, struct ln_equ_posn pos)\newline \\brief human readable equatorial position to double equatorial position\newline \\ingroup conversion\newline \newline",897441,ospreauthrsp.c,"void OSPPReauthRspSetComponentId(\newline    OSPT_REAUTH_RSP *ospvReauthRsp, /* In - pointer to Usage Indication struct */\newline    const char *ospvComponentId)    /* In - pointer to component id string */\newline{\newline    int len = OSPM_STRLEN(ospvComponentId);\newline\newline    if (ospvReauthRsp != OSPC_OSNULL) {\newline        if (ospvReauthRsp-&gtComponentId != OSPC_OSNULL) {\newline            OSPM_FREE(ospvReauthRsp-&gtComponentId);\newline        }\newline\newline        OSPM_MALLOC(ospvReauthRsp-&gtComponentId, char, len + 1);\newline        OSPM_MEMSET(ospvReauthRsp-&gtComponentId, 0, len + 1);\newline        OSPM_MEMCPY(ospvReauthRsp-&gtComponentId, ospvComponentId, len);\newline    }\newline}\newline",\newline OSPPReauthRspSetComponentId() - creates space and copies in the string.\newline \newline,on,,,,,,,,on,,,on,on,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,{},Writes the graph as a GML file,Get dpi directory path from dpidrc,"FORMS calls this
when the user moves the slider bar.","Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector
buffer.","Returns: -1 on alloc failure,",This function is called by J-Pilot before switching to another application.,"Guides the user through setting up session specific parameters,",{},Contains common code shared by all set implementations.,Adds an additional \a path to the current set.,{},{},creates space and copies in the string.,lookup item by key,Returns TRUE if simulation should continue to advance;,Handle a list marker at the head,Load an image from the named file.,Monitor socket,Return shared memory cache address,{},x,
3RQVKZ7ZRKJS3B7KOKFEO2UNEAA722,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:51 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:51 PDT 2019,,,3RYC5T2D73T00LPYPYTXEFP58RDRP9,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:55 PDT 2019,Fri Apr 26 13:13:41 PDT 2019,Sun Apr 28 13:13:41 PDT 2019,,,,1546,100% (62/62),100% (62/62),0% (0/0),3213111,events.c,"void HandleLeaveNotify()\newline{\newline  /* If we leave the root window, then we&#039re really moving\newline   * another screen on a multiple screen display, and we\newline   * need to de-focus and unhighlight to make sure that we\newline   * don&#039t end up with more than one highlighted window at a time */\newline  if(Event.xcrossing.window == Scr.Root)\newline    {\newline      if(Event.xcrossing.mode == NotifyNormal)\newline	{\newline	  if (Event.xcrossing.detail != NotifyInferior) \newline	    {\newline	      if(Scr.Focus != NULL)\newline		{\newline		  SetFocus(Scr.NoFocusWin,NULL);\newline		}\newline	      if(Scr.Hilite != NULL)\newline		SetBorder(Scr.Hilite,False,True,True,None);\newline	    }\newline	}\newline    }\newline}\newline",\newline \newline Procedure:\newline HandleLeaveNotify - LeaveNotify event handler\newline \newline \newline,3007920,gmr.c,"int gmr_get_typed(gmr_t *mreg, void *src, int src_count, MPI_Datatype src_type,\newline    void *dst, int dst_count, MPI_Datatype dst_type, int proc) {\newline\newline  int        grp_proc;\newline  gmr_size_t disp;\newline  MPI_Aint lb, extent;\newline\newline  grp_proc = ARMCII_Translate_absolute_to_group(&ampmreg-&gtgroup, proc);\newline  ARMCII_Assert(grp_proc &gt= 0);\newline  ARMCII_Assert_msg(mreg-&gtwindow != MPI_WIN_NULL, &quotA non-null mreg contains a null window.&quot);\newline\newline  // Calculate displacement from beginning of the window\newline  if (src == MPI_BOTTOM) \newline    disp = 0;\newline  else\newline    disp = (gmr_size_t) ((uint8_t*)src - (uint8_t*)mreg-&gtslices[proc].base);\newline\newline  // Perform checks\newline  MPI_Type_get_true_extent(src_type, &amplb, &ampextent);\newline  ARMCII_Assert_msg(disp &gt= 0 &amp&amp disp &lt mreg-&gtslices[proc].size, &quotInvalid remote address&quot);\newline  ARMCII_Assert_msg(disp + src_count*extent &lt= mreg-&gtslices[proc].size, &quotTransfer is out of range&quot);\newline\newline  if (ARMCII_GLOBAL_STATE.rma_atomicity) {\newline      MPI_Get_accumulate(NULL, 0, MPI_BYTE, dst, dst_count, dst_type, grp_proc,\newline                         (MPI_Aint) disp, src_count, src_type, MPI_NO_OP, mreg-&gtwindow);\newline  } else {\newline      MPI_Get(dst, dst_count, dst_type, grp_proc,\newline              (MPI_Aint) disp, src_count, src_type, mreg-&gtwindow);\newline  }\newline\newline  return 0;\newline}\newline","One-sided get operation with type arguments. Destination buffer must be private.\newline \newline @param[in] mreg Memory region\newline @param[in] src Address of source data\newline @param[in] src_count Number of elements of the given type at the source\newline @param[in] src_type MPI datatype of the source elements\newline @param[in] dst Address of destination buffer\newline @param[in] dst_count Number of elements of the given type at the destination\newline @param[in] src_type MPI datatype of the destination elements\newline @param[in] size Number of bytes to transfer\newline @param[in] proc Absolute process id of target process\newline @return 0 on success, non-zero on failure\newline \newline",5943557,duffdriver.c,"static void process_path(const char* path, int depth)\newline{\newline  mode_t mode;\newline  struct stat sb;\newline\newline  if (stat_path(path, &ampsb, depth) != 0)\newline    return;\newline\newline  mode = sb.st_mode &amp S_IFMT;\newline  switch (mode)\newline  {\newline    case S_IFREG:\newline    {\newline      process_file(path, &ampsb);\newline      break;\newline    }\newline\newline    case S_IFDIR:\newline    {\newline      if (recursive_flag)\newline      {\newline	process_directory(path, &ampsb, depth + 1);\newline        break;\newline      }\newline\newline      /* FALLTHROUGH */\newline    }\newline\newline    default:\newline    {\newline      if (!quiet_flag)\newline      {\newline	switch (mode)\newline	{\newline	  case S_IFLNK:\newline	    warning(_(&quot%s is a symbolic link; skipping&quot), path);\newline	    break;\newline	  case S_IFIFO:\newline	    warning(_(&quot%s is a named pipe; skipping&quot), path);\newline	    break;\newline          case S_IFBLK:\newline	    warning(_(&quot%s is a block device; skipping&quot), path);\newline	    break;\newline	  case S_IFCHR:\newline	    warning(_(&quot%s is a character device; skipping&quot), path);\newline	    break;\newline	  case S_IFDIR:\newline	    warning(_(&quot%s is a directory; skipping&quot), path);\newline	    break;\newline	  case S_IFSOCK:\newline	    warning(_(&quot%s is a socket; skipping&quot), path);\newline	    break;\newline	  default:\newline	    error(_(&quotThis cannot happen&quot));\newline	}\newline      }\newline    }\newline  }\newline}\newline","Processes a path name according to its type, whether from the command line or\newline from directory recursion.\newline \newline This function calls process_file and process_directory as needed.\newline \newline",4662571,console.c,"STATIC TEG_STATUS con_scores_show( PSCORES pS )\newline{\newline	int color;\newline	color = ( ( pS-&gtcolor &gt= TEG_MAX_PLAYERS || pS-&gtcolor &lt 0 ) ? TEG_MAX_PLAYERS : pS-&gtcolor );\newline	printf(&quot  %4d   %s   %-15s   %-8s %s\\n&quot,\newline				 pS-&gtstats.score,\newline				 pS-&gtdate,\newline				 pS-&gtname,\newline				 _(g_colores[color]),\newline				 pS-&gthuman ? _(&quotyes&quot) : _(&quotno&quot)\newline				 );\newline\newline	return TEG_STATUS_SUCCESS;\newline}\newline",shows all the scores \newline,3326727,audio-in.c,"static int read_chunk(FILE *in, unsigned char *buf, unsigned int bufsize,\newline        unsigned int *len)\newline{\newline    unsigned int chunklen = *len;\newline    unsigned int readlen = chunklen &gt bufsize ? bufsize : chunklen;\newline\newline    if(fread(buf, 1, readlen, in) != readlen)\newline        return 0;\newline\newline    if(!seek_forward(in, (ogg_int64_t)(chunklen - readlen) + (chunklen &amp 1)))\newline        return 0;\newline\newline    *len = readlen;\newline    return 1;\newline}\newline",Read chunk of size len and advance the file position to the next chunk.\newline Returns 0 on EOF or read error. Otherwise len is updated with the number\newline of bytes placed in the buffer (the lesser of the chunk size and buffer\newline size) and 1 is returned.\newline \newline,3498127,diod_conf.c,int diod_conf_get_foreground (void) { return config.foreground; }\newline,foreground - run daemon in foreground\newline \newline,2532158,hash_update.c,"static int file_set_load_from_crc_file(file_set *set, file_t* file)\newline{\newline	FILE *fd;\newline	int line_num;\newline	char buf[2048];\newline	hash_check hc;\newline\newline	if ( !(fd = rsh_fopen_bin(file-&gtpath, &quotrb&quot) )) {\newline		/* if file not exist, it will be created */\newline		return (errno == ENOENT ? 0 : -1);\newline	}\newline	for (line_num = 0; fgets(buf, 2048, fd); line_num++) {\newline		char* line = buf;\newline\newline		/* skip unicode BOM */\newline		if (line_num == 0 &amp&amp buf[0] == (char)0xEF &amp&amp buf[1] == (char)0xBB &amp&amp buf[2] == (char)0xBF) line += 3;\newline\newline		if (*line == 0) continue; /* skip empty lines */\newline\newline		if (is_binary_string(line)) {\newline			log_error(_(&quotskipping binary file %s\\n&quot), file-&gtpath);\newline			fclose(fd);\newline			return -1;\newline		}\newline\newline		if (IS_COMMENT(*line) || *line == &#039\\r&#039 || *line == &#039\\n&#039) continue;\newline\newline		/* parse a hash file line */\newline		if (hash_check_parse_line(line, &amphc, !feof(fd))) {\newline			/* store file info to the file set */\newline			if (hc.file_path) file_set_add_name(set, hc.file_path);\newline		}\newline	}\newline	fclose(fd);\newline	return 0;\newline}\newline","\newline Load a set of files from given crc file.\newline \newline @param set the file set to store loaded files\newline @param file the file containing hash sums to load\newline @return 0 on success, -1 on fail with error code in errno\newline \newline",3687579,cdtext.c,"int burn_cdtext_crc_mismatches(unsigned char *packs, int num_packs, int flag)\newline{\newline	int i, residue, count = 0, repair;\newline	unsigned char crc[2];\newline\newline	repair = flag &amp 1;\newline	if (flag &amp 2) {\newline		for (i = 0; i &lt num_packs * 18; i += 18)\newline			if (packs[i + 16] || packs[i + 17])\newline		break;\newline		if (i == num_packs * 18)\newline			repair = 1;\newline	}\newline	for (i = 0; i &lt num_packs * 18; i += 18) {\newline		residue = crc_11021(packs + i, 16, 0);\newline		crc[0] = ((residue &gt&gt 8) &amp 0xff) ^ 0xff;\newline		crc[1] = ((residue     ) &amp 0xff) ^ 0xff;\newline		if(crc[0] != packs[i + 16] || crc[1] != packs[i + 17]) {\newline			if (repair) {\newline				if (packs[i + 16] || packs[i + 17])\newline					count--;\newline				packs[i + 16] = crc[0];\newline				packs[i + 17] = crc[1];\newline			} else\newline				count++;\newline		}\newline		\newline	}\newline	return count;\newline}\newline","@param flag bit0= repair mismatching checksums\newlinebit1= repair checksums if all pack CRCs are 0\newline@return 0= no mismatch , &gt0 number of unrepaired mismatches\newline&lt0 number of repaired mismatches that were not 0\newline \newline",2244506,getglenv.c,"char *getGLenv()\newline{\newlinestatic char *gl = NULL;\newline\newline    if (gl != NULL)\newline	return gl;\newline\newline#ifdef _WINDOWS\newline    \newline    gl = gl_GetRegistryString(GLHOME, APPLICATION_NAME);\newline    if (gl == NULL) \newline	return NULL;\newline#else\newline    gl = getenv(&quotGRASSLAND&quot);\newline    if (gl == NULL) \newline	return NULL;\newline#endif\newline    return gl;\newline\newline}\newline",\newline Retreive the information related to where is the bin path of GRASSLAND \newline \newline Results:\newline A string\newline \newline \newline,5824901,dxplugin.cpp,"static int write_dx_data(void *v, molfile_volumetric_t *metadata,\newline        float *datablock, float *colorblock) {\newline\newline    int i, j, k, count;\newline    FILE *fd = (FILE *)v;\newline    const int xsize = metadata-&gtxsize;\newline    const int ysize = metadata-&gtysize;\newline    const int zsize = metadata-&gtzsize;\newline    const int xysize = xsize * ysize;\newline    const int total = xysize * zsize;\newline\newline    double xdelta[3], ydelta[3], zdelta[3];\newline    for (i=0; i&lt3; i++) {\newline      xdelta[i] = metadata-&gtxaxis[i]/(xsize - 1);\newline      ydelta[i] = metadata-&gtyaxis[i]/(ysize - 1);\newline      zdelta[i] = metadata-&gtzaxis[i]/(zsize - 1);\newline    }\newline\newline    fprintf(fd, &quot# Data from VMD\\n&quot);\newline    fprintf(fd, &quot# %s\\n&quot, metadata-&gtdataname);\newline    fprintf(fd, &quotobject 1 class gridpositions counts %d %d %d\\n&quot,\newline            xsize, ysize, zsize);\newline    fprintf(fd, &quotorigin %g %g %g\\n&quot, \newline            metadata-&gtorigin[0], metadata-&gtorigin[1], metadata-&gtorigin[2]);\newline    fprintf(fd, &quotdelta %g %g %g\\n&quot, \newline            xdelta[0], xdelta[1], xdelta[2]);\newline    fprintf(fd, &quotdelta %g %g %g\\n&quot, \newline            ydelta[0], ydelta[1], ydelta[2]);\newline    fprintf(fd, &quotdelta %g %g %g\\n&quot, \newline            zdelta[0], zdelta[1], zdelta[2]);\newline    fprintf(fd, &quotobject 2 class gridconnections counts %d %d %d\\n&quot,\newline            xsize, ysize, zsize);\newline\newline    int useBinary = (getenv(&quotVMDBINARYDX&quot) != NULL);\newline    fprintf(fd, &quotobject 3 class array type double rank 0 items %d %sdata follows\\n&quot, total, useBinary ? &quotbinary &quot : &quot&quot);\newline    count = 0;\newline    for (i=0; i&ltxsize; i++) {\newline        for (j=0; j&ltysize; j++) {\newline            for (k=0; k&ltzsize; k++) {\newline                if (useBinary) {\newline                    fwrite(datablock + k*xysize + j*xsize + i, sizeof(float),\newline                            1, fd);\newline                } else {\newline                    fprintf(fd, &quot%g &quot, datablock[k*xysize + j*xsize + i]);\newline                    if (++count == 3) {\newline                        fprintf(fd, &quot\\n&quot);\newline                        count = 0;\newline                    }\newline                }\newline            }\newline        }\newline    }\newline    if (!useBinary &amp&amp count) \newline      fprintf(fd, &quot\\n&quot);\newline\newline    // Replace any double quotes (&quot) by single quotes (&#039) in the \newline    // dataname string to make sure that we don&#039t prematurely\newline    // terminate the string in the dx file.\newline    char *squotes = new char[strlen(metadata-&gtdataname)+1];\newline    strcpy(squotes, metadata-&gtdataname);\newline    char *s = squotes;\newline    // while(s=strchr(s, &#039&quot&#039)) *s = &#039\\&#039&#039;\newline    while(1) { \newline      s=strchr(s, &#039&quot&#039); \newline      if (s) { \newline        *s = &#039\\&#039&#039;\newline      } else { \newline        break;\newline      }\newline    }\newline\newline    // Print last line\newline    fprintf(fd, &quotobject \\&quot%s\\&quot class field\\n&quot, squotes);\newline    delete [] squotes;\newline\newline    fflush(fd);\newline    return MOLFILE_SUCCESS;\newline}\newline",\newline \newline# Data from APBS\newline# \newline# POTENTIAL (kT/e)\newline# \newlineobject 1 class gridpositions counts 129 129 129\newlineorigin -3.075250e+01 -3.848600e+01 -2.908250e+01\newlinedelta 4.687500e-01 0.000000e+00 0.000000e+00\newlinedelta 0.000000e+00 6.250000e-01 0.000000e+00\newlinedelta 0.000000e+00 0.000000e+00 4.687500e-01\newlineobject 2 class gridconnections counts 129 129 129\newlineobject 3 class array type double rank 0 items 2146689 data follows\newline \newline,1314408,eztrace_list.h,"static inline void ezt_list_add(struct ezt_list_t*l,\newline                                struct ezt_list_token_t *n) {\newline  /* initialize the new token */\newline  n-&gtlist = l;\newline  n-&gtnext = NULL;\newline  n-&gtprev = l-&gttail;\newline\newline  if (ezt_list_empty(l)) {\newline    l-&gthead = n;\newline  } else {\newline    l-&gttail-&gtnext = n;\newline  }\newline  l-&gttail = n;\newline  l-&gtnb_item++;\newline}\newline",add a new token at the list tail \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2469301,codec.c,void CodecAudioFlushBuffers(AudioDecoder * decoder)\newline{\newline    avcodec_flush_buffers(decoder-&gtAudioCtx);\newline}\newline,\newline Flush the audio decoder.\newline \newline @param decoder audio decoder data\newline \newline,6564625,main.c,"int get_unit(void *arg)\newline{\newline    static struct {\newline	char *str;\newline	double unit;\newline    } *ptr, unittab[] = {\newline	{&quotpt&quot,  1.0},\newline	{&quotin&quot,  72.0},\newline	{&quotcm&quot,  72.0/2.54},\newline	{&quotmm&quot,  72.0/25.4},\newline	{NULL, 0.0}\newline    };\newline\newline    for (ptr = unittab; ptr-&gtstr &amp&amp strcmp((char *)arg, ptr-&gtstr); ptr++)\newline	;\newline    unit = ptr-&gtunit;\newline    if (ptr-&gtstr) return 0;\newline\newline    fprintf(stderr, &quot%s: incorrect unit \\&quot%s\\&quot (use one of&quot,\newline	    prgname, (char *)arg);\newline    for (ptr = unittab; ptr-&gtstr; ptr++)\newline	fprintf(stderr, &quot \\&quot%s\\&quot&quot, ptr-&gtstr);\newline    fprintf(stderr, &quot)\\n&quot);\newline    return -2;\newline}\newline",accept a unit specification \newline,2574474,syldap.c,static gboolean syldap_display_search_results(SyldapServer *ldapServer)\newline{\newline	/* NOTE: when this function is called the accompanying thread should\newline	 * already be terminated. */\newline	gdk_threads_enter();\newline	ldapServer-&gtcallBack(ldapServer);\newline	gdk_threads_leave();\newline	/* FIXME:  match should know whether to free this SyldapServer stuff. */\newline	g_free(ldapServer-&gtthread);\newline	ldapServer-&gtthread = NULL;\newline	return FALSE;\newline}\newline,syldap_display_search_results() - updates the ui. this function is called from the\newline main thread (the thread running the GTK event loop). \newline,252874,ghwp-document.c,"GHWPDocument *ghwp_document_new_from_uri (const gchar *uri, GError **error)\newline{\newline    g_return_val_if_fail (uri != NULL, NULL);\newline\newline    gchar        *filename = g_filename_from_uri (uri, NULL, error);\newline    GHWPDocument *document = ghwp_document_new_from_filename (filename, error);\newline    _g_free0 (filename);\newline    return document;\newline}\newline","\newline ghwp_document_new_from_uri:\newline @uri: uri of the file to load\newline @error: (allow-none): Return location for an error, or %NULL\newline \newline Creates a new #GHWPDocument. If %NULL is returned, then @error will be\newline set. Possible errors include those in the #GHWP_ERROR and #G_FILE_ERROR\newline domains.\newline \newline Return value: A newly created #GHWPDocument, or %NULL\newline \newline",5608678,rpmfi.c,"static int rpmfnInit(rpmfn fndata, rpmTagVal bntag, Header h, rpmstrPool pool)\newline{\newline    struct rpmtd_s bn, dn, dx;\newline    rpmTagVal dntag, ditag;\newline    int rc = 0;\newline\newline    if (bntag == RPMTAG_BASENAMES) {\newline	dntag = RPMTAG_DIRNAMES;\newline	ditag = RPMTAG_DIRINDEXES;\newline    } else if (bntag == RPMTAG_ORIGBASENAMES) {\newline	dntag = RPMTAG_ORIGDIRNAMES;\newline	ditag = RPMTAG_ORIGDIRINDEXES;\newline    } else {\newline	return -1;\newline    }\newline\newline    /* Grab and validate file triplet data (if there is any) */\newline    if (headerGet(h, bntag, &ampbn, HEADERGET_MINMEM)) {\newline	headerGet(h, dntag, &ampdn, HEADERGET_MINMEM);\newline	headerGet(h, ditag, &ampdx, HEADERGET_ALLOC);\newline\newline	if (indexSane(&ampbn, &ampdn, &ampdx)) {\newline	    /* Init the file triplet data */\newline	    fndata-&gtfc = rpmtdCount(&ampbn);\newline	    fndata-&gtdc = rpmtdCount(&ampdn);\newline	    fndata-&gtbnid = rpmtdToPool(&ampbn, pool);\newline	    fndata-&gtdnid = rpmtdToPool(&ampdn, pool);\newline	    /* Steal index data from the td (pooh...) */\newline	    fndata-&gtdil = dx.data;\newline	    dx.data = NULL;\newline	    rc = fndata-&gtfc;\newline	} else {\newline	    memset(fndata, 0, sizeof(*fndata));\newline	    rc = -1;\newline	}\newline	rpmtdFreeData(&ampbn);\newline	rpmtdFreeData(&ampdn);\newline	rpmtdFreeData(&ampdx);\newline    }\newline\newline    return rc;\newline}\newline",\newline Collect and validate file path data from header.\newline Return the number of files found (could be none) or -1 on error.\newline \newline,280421,vdb-dump-coldefs.c,"static char *vdcd_get_read_desc_txt( const uint8_t * src )\newline{\newline    char *res = calloc( 1, 120 );\newline    SRAReadDesc desc;\newline    memmove( &ampdesc, src, sizeof( desc ) );\newline    string_printf ( res, 119, NULL,\newline              &quotseg.start=%u, seg.len=%u, type=%u, cs_key=%u, label=%s&quot,\newline              desc.seg.start, desc.seg.len, desc.type,\newline              desc.cs_key, desc.label );\newline    return res;\newline}\newline",implementation of the dimension-translation-functions \newline,117415,hfile.c,"int hputc2(int c, hFILE *fp)\newline{\newline    if (flush_buffer(fp) &lt 0) return EOF;\newline    *(fp-&gtbegin++) = c;\newline    return c;\newline}\newline","Called only from hputc(), when our buffer is already full. \newline",5020614,libcard.c,"int genwqe_card_execute_ddcb(card_handle_t dev,\newline			     struct genwqe_ddcb_cmd *req)\newline{\newline	return __genwqe_card_execute(dev, req, GENWQE_EXECUTE_DDCB);\newline}\newline",\newline @brief Execute a DDCB request with automatic DMA buffer translations.\newline @param card handle returned from &#039card_open()&#039\newline @param req req describes the DDCB which should be executed.\newline \newline,4360985,remote.c,"Error DXCompareModuleId(Pointer id1, Pointer id2)\newline{\newline    if (id1 == NULL || id2 == NULL)\newline	return ERROR;\newline\newline    return ((strcmp(id1, id2) == 0) ? OK : ERROR);\newline}\newline",compare two module ids\newline \newline,,on,,,,,on,,,,on,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,,,,LeaveNotify event handler,{},add a new token at the list tail,Load an image from the named file.,Flush the audio decoder.,accept a unit specification,{},Creates a new #GHWPDocument.,Collect and validate file path data from header.,implementation of the dimension-translation-functions,{},One-sided get operation with type arguments.,Execute a DDCB request,compare two module ids,"Processes a path name according to its type,",shows all the scores,Read chunk of size len,{},Load a set of files from given crc file.,repair mismatching checksums,Retreive the information related,x,
31KPKEKW4AD89D7WMENGAGN402HB08,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:38 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:38 PDT 2019,,,3HWRJOOET528490LV9DRADVXGMUESZ,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:37 PDT 2019,Fri Apr 26 12:58:41 PDT 2019,Sun Apr 28 12:58:41 PDT 2019,,,,664,100% (62/62),100% (62/62),0% (0/0),4139929,l_denoise.h,"inline double dn_diff(double a, double b)\newline{\newline  assert(a == a);\newline  assert(b == b);\newline  return fixzero(a-b, a);\newline}\newline",dn_diff: de-noised difference \newline,1213522,cdirect.c,"static double rect_diameter(int n, const double *w, const params *p)\newline{\newline     int i;\newline     if (p-&gtwhich_diam == 0) { /* Jones measure */\newline	  double sum = 0;\newline	  for (i = 0; i &lt n; ++i)\newline	       sum += w[i] * w[i];\newline	  /* distance from center to a vertex */\newline	  return ((float) (sqrt(sum) * 0.5)); \newline     }\newline     else { /* Gablonsky measure */\newline	  double maxw = 0;\newline	  for (i = 0; i &lt n; ++i)\newline	       if (w[i] &gt maxw)\newline		    maxw = w[i];\newline	  /* half-width of longest side */\newline	  return ((float) (maxw * 0.5));\newline     }\newline}\newline","Evaluate the &quotdiameter&quot (d) of a rectangle of widths w[n] \newlineWe round the result to single precision, which should be plenty for\newlinethe use we put the diameter to (rect sorting), to allow our\newlineperformance hack in convex_hull to work (in the Jones and Gablonsky\newlineDIRECT algorithms, all of the rects fall into a few diameter\newlinevalues, and we don&#039t want rounding error to spoil this) \newline",5940857,category.c,"int pdb_file_swap_indexes(char *DB_name, int old_cat, int new_cat)\newline{\newline   return _change_cat_pdb(DB_name, old_cat, new_cat, TRUE);\newline}\newline",Exported routine to swap categories in pdb file \newline,5182716,helper.c,"void swap_buffers(char *fst, char *snd) {\newline	char *tmp;\newline\newline	if (fst == snd)\newline		return;\newline	tmp = str_alloc(strlen(fst)+1);\newline	strcpy(tmp, fst);\newline	strcpy(fst, snd);\newline	strcpy(snd, tmp);\newline	free(tmp);\newline}\newline",sipmly swappes the content of the two buffers \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,2103551,ctkclocks.c,"GtkTextBuffer *ctk_clocks_create_help(GtkTextTagTable *table,\newline                                      CtkClocks *ctk_object)\newline{\newline    GtkTextIter i;\newline    GtkTextBuffer *b;\newline    \newline    b = gtk_text_buffer_new(table);\newline    \newline    gtk_text_buffer_get_iter_at_offset(b, &ampi, 0);\newline\newline    ctk_help_title(b, &ampi, &quotClock Frequency Overclocking Help&quot);\newline    ctk_help_para(b, &ampi,\newline                  &quotWARNING: Overclocking has the potential of destroying your &quot\newline                  &quotgraphics card, CPU, RAM and any other component.  It may &quot\newline                  &quotalso reduce the life expectancy of your components and &quot\newline                  &quotvoid manufacturer warranties.  DO THIS AT YOUR OWN RISK.&quot\newline                  );\newline    ctk_help_heading(b, &ampi, &quotEnabling Clock Frequencies&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __enable_button_help);\newline    ctk_help_para(b, &ampi,\newline                  &quotGPU Overclocking functionality is currently limited to &quot\newline                  &quotGeForce FX and newer non-mobile GPUs.&quot\newline                  );\newline    ctk_help_heading(b, &ampi, &quot2D/3D Clock Frequencies&quot);\newline    ctk_help_para(b, &ampi,\newline                  &quotThe 2D clock frequencies are the standard clock &quot\newline                  &quotfrequencies used when only 2D applications are running.&quot\newline                  );\newline    ctk_help_para(b, &ampi,\newline                  &quotThe 3D clock frequencies are the performance clock &quot\newline                  &quotfrequencies used when running 3D applications.&quot\newline                  );\newline    ctk_help_heading(b, &ampi, &quotGraphics Clock Frequency&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __graphics_clock_help);\newline    ctk_help_heading(b, &ampi, &quotMemory Clock Frequency&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __mem_clock_help);\newline    ctk_help_heading(b, &ampi, &quotApplying Custom Clock Frequencies&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __apply_button_help);\newline    ctk_help_heading(b, &ampi, &quotAuto Detect Optimal 3D Clock Frequencies&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __detect_button_help);\newline    ctk_help_heading(b, &ampi, &quotCanceling Optimal 3D Clock Frequency Auto-&quot\newline                     &quotdetection.&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __cancel_button_help);\newline    ctk_help_para(b, &ampi,\newline                  &quotThis button is only available if the Optimal &quot\newline                  &quotclocks are currently being probed.&quot);\newline    ctk_help_heading(b, &ampi, &quotRestoring Hardware Default Frequencies&quot);\newline    ctk_help_para(b, &ampi, &quot%s&quot, __reset_button_help);\newline\newline    ctk_help_finish(b);\newline\newline    return b;\newline\newline} /* ctk_clocks_create_help() */\newline",\newline \newline GPU overclocking help screen.\newline \newline \newline,2187362,history.c,"int a_History_add_url(DilloUrl *url)\newline{\newline   int i, idx;\newline\newline   _MSG(&quota_History_add_url: &#039%s&#039 &quot, URL_STR(url));\newline   for (i = 0; i &lt history_size; ++i)\newline      if (!a_Url_cmp(history[i].url, url) &amp&amp\newline          !strcmp(URL_FRAGMENT(history[i].url), URL_FRAGMENT(url)))\newline         break;\newline\newline   if (i &lt history_size) {\newline      idx = i;\newline      _MSG(&quotFOUND at idx=%d\\n&quot, idx);\newline   } else {\newline      idx = history_size;\newline      a_List_add(history, history_size, history_size_max);\newline      history[idx].url = a_Url_dup(url);\newline      history[idx].title = NULL;\newline      ++history_size;\newline      _MSG(&quotADDED at idx=%d\\n&quot, idx);\newline   }\newline\newline   /* History_show(); */\newline\newline   return idx;\newline}\newline",\newline Add a new H_Item at the end of the history list\newline (taking care of not making a duplicate entry)\newline \newline,4475033,dlist.c,"int get_all_ucontacts(void *buf, int len, unsigned int flags,\newline					unsigned int part_idx, unsigned int part_max, int pack_cid)\newline{\newline	dlist_t *p;\newline	ucontact_t c;\newline	int shortage=0;\newline	int res, ini_len, cur_pos=0;\newline\newline\newline	/* Reserve space for terminating 0000 */\newline	len -= sizeof(c.c.len);\newline\newline	for (p = root; p != NULL; p = p-&gtnext) {\newline		ini_len = len;\newline		if (db_mode != DB_ONLY) {\newline			shortage +=\newline				get_domain_mem_ucontacts(p-&gtd, buf+cur_pos, &amplen, flags,\newline					part_idx, part_max, 0 /* don&#039t add zeroed contact*/,\newline					pack_cid);\newline		} else {\newline			res =\newline				get_domain_db_ucontacts(p-&gtd, buf+cur_pos, &amplen, flags,\newline					part_idx, part_max, 0, pack_cid);\newline			if (res &gt= 0) {\newline				shortage += res;\newline			} else {\newline				LM_ERR(&quotget db ucontacts failed; domain %.*s\\n&quot,\newline						p-&gtd-&gtname-&gtlen, p-&gtd-&gtname-&gts);\newline				return -1;\newline			}\newline		}\newline		cur_pos += ini_len - len;\newline	}\newline	/* len &lt 0 is possible, if size of the buffer &lt sizeof(c-&gtc.len) */\newline	if (!shortage &amp&amp len &gt= 0)\newline		memset(buf + cur_pos, 0, sizeof(c.c.len));\newline\newline	return shortage &gt 0 ? shortage : 0;\newline}\newline","! \\brief\newline Return list of all contacts for all currently registered\newline users in all domains. Caller must provide buffer of\newline sufficient length for fitting all those contacts. In the\newline case when buffer was exhausted, the function returns\newline estimated amount of additional space needed, in this\newline case the caller is expected to repeat the call using\newline this value as the hint.\newline \newline Information is packed into the buffer as follows:\newline \newline +------------+----------+-----+------+-----+-------------+\newline |contact1.len|contact1.s|sock1|flags1|path1| contact_id1 |\newline +------------+----------+-----+------+-----+-------------+\newline |contact2.len|contact2.s|sock2|flags2|path1| contact_id2 |\newline +------------+----------+-----+------+-----+-------------+\newline |..........................................|.............|\newline +------------+----------+-----+------+-----+-------------+\newline |contactN.len|contactN.s|sockN|flagsN|pathN| contact_idN |\newline +------------+----------+-----+------+-----+-------------+\newline |000000000000|\newline +------------+\newline \newline if pack_cid not set, contact id will not be put into the buffer\newline \newline",1892951,isoline.c,VisuLine* visu_line_ref(VisuLine *line)\newline{\newline  line-&gtrefCount += 1;\newline  return line;\newline}\newline,\newline visu_line_ref:\newline @line: a #VisuLine object.\newline \newline Increase the ref counter.\newline \newline Since: 3.7\newline \newline Returns: itself.\newline \newline,3481164,zdeflate.cpp,"unsigned Deflator::fill_window(const byte *buffer, unsigned int length)\newline{\newline   register unsigned n, m;\newline   unsigned more = length;\newline\newline   /* Amount of free space at the end of the window. */\newline   if (WINDOW_SIZE - lookahead - strstart &lt more) {\newline      more = (unsigned)(WINDOW_SIZE - lookahead - strstart);\newline   }\newline   /* If the window is almost full and there is insufficient lookahead,\newline    * move the upper half to the lower one to make room in the upper half.\newline    */\newline   if (strstart &gt= (unsigned)WSIZE+MAX_DIST) {\newline      memcpy(window, window+(unsigned int)WSIZE, WSIZE);\newline      match_start -= WSIZE;\newline      strstart    -= WSIZE; /* we now have strstart &gt= MAX_DIST: */\newline\newline      block_start -= (long) WSIZE;\newline\newline      for (n = 0; n &lt (unsigned)HASH_SIZE; n++) {\newline         m = head[n];\newline         head[n] = (Pos)(m &gt= (unsigned)WSIZE ? m-WSIZE : NIL);\newline      }\newline      for (n = 0; n &lt (unsigned)WSIZE; n++) {\newline         m = prev[n];\newline         prev[n] = (Pos)(m &gt= (unsigned)WSIZE ? m-WSIZE : NIL);\newline         /* If n is not on any hash chain, prev[n] is garbage but\newline            its value will never be used. */\newline      }\newline      if ((more += WSIZE) &gt length) more = length;\newline   }\newline   if (more) {\newline      memcpy((byte*)window+strstart+lookahead, buffer, more);\newline      lookahead += more;\newline   }\newline   return more;\newline}\newline",Add a block of data into the window. Updates strstart and lookahead.\newline IN assertion: lookahead &lt MIN_LOOKAHEAD.\newline Note: call with either lookahead == 0 or length == 0 is valid\newline \newline,1765719,rsrr.c,"void rsrr_cache_clean(struct gtable *gt)\newline{\newline    struct rsrr_cache *rc, *rc_next, **rcnp;\newline    struct gtable *gt_wide;\newline#ifdef PIM\newline    uint8_t flags = 0;\newline\newline    IF_DEBUG(DEBUG_RSRR) {\newline	if (gt-&gtflags &amp MRTF_SG)\newline	    logit(LOG_DEBUG, 0, &quotcleaning cache for source %s and group %s&quot,\newline		  inet_fmt(gt-&gtsource-&gtaddress, s1, sizeof(s1)),\newline		  inet_fmt(gt-&gtgroup-&gtgroup, s2, sizeof(s2)));\newline	else if (gt-&gtflags &amp MRTF_WC)\newline	    logit(LOG_DEBUG, 0, &quotcleaning cache for group %s and ANY sources&quot,\newline		  inet_fmt(gt-&gtgroup-&gtgroup, s1, sizeof(s1)));\newline	else if (gt-&gtflags &amp MRTF_PMBR)\newline	    logit(LOG_DEBUG, 0,\newline		  &quotcleaning cache for ALL groups matching to RP %s&quot,\newline		  inet_fmt(gt-&gtsource-&gtaddress, s1, sizeof(s1)));\newline    }\newline    rc = gt-&gtrsrr_cache;\newline    if (rc == (struct rsrr_cache *)NULL)\newline	return;\newline    if (gt-&gtflags &amp MRTF_SG) {\newline	if ((gt_wide = gt-&gtgroup-&gtgrp_route) == (struct gtable *)NULL)\newline	    gt_wide = gt-&gtgroup-&gtactive_rp_grp-&gtrp-&gtrpentry-&gtmrtlink;\newline    }\newline    else if (gt-&gtflags &amp MRTF_WC)\newline	gt_wide = gt-&gtgroup-&gtactive_rp_grp-&gtrp-&gtrpentry-&gtmrtlink;\newline    else\newline	gt_wide = (struct gtable *)NULL;\newline    \newline    if (gt_wide == (struct gtable *)NULL) {\newline	/* No routing entry where to move down the rsrr cache entry.\newline	 * Send a message with &quotcannot_notify&quot bit set.\newline	 */\newline	rsrr_cache_send(gt, 0);\newline	while (rc) {\newline	    rc_next = rc-&gtnext;\newline	    free(rc);\newline	    rc = rc_next;\newline	}\newline    } else if ((gt_wide-&gtincoming == gt-&gtincoming)\newline	       &amp&amp (VIFM_SAME(gt-&gtoifs, gt_wide-&gtoifs))) {\newline	/* The (iif, oifs) are the same. Just move to the beginning of the\newline	 * RSRR cache chain. No need to send message */\newline	while (rc-&gtnext != (struct rsrr_cache *)NULL)\newline	    rc = rc-&gtnext;\newline	rc-&gtnext = gt_wide-&gtrsrr_cache;\newline	gt_wide-&gtrsrr_cache = gt-&gtrsrr_cache;\newline    }\newline    else {\newline	/* Have to move to the RSRR cache entries and at the same time\newline	 * send an update for each of them.\newline	 */\newline	rcnp = &ampgt-&gtrsrr_cache;\newline	BIT_SET(flags, RSRR_NOTIFICATION_BIT);\newline	if (gt-&gtgroup-&gtmrtlink != (mrtentry_t *)NULL) {\newline	    RSRR_THIS_SENDER_SHARED_TREE_SOME_OTHER_NOT(flags);\newline	}\newline	else {\newline	    RSRR_SET_ALL_SENDERS_SHARED_TREE(flags);\newline	}\newline 	while ((rc = *rcnp) != NULL) {\newline	    if (rsrr_accept_rq(&amprc-&gtroute_query, flags, gt_wide) &lt 0) {\newline		IF_DEBUG(DEBUG_RSRR) {\newline		    logit(LOG_DEBUG, 0,\newline			  &quotDeleting cached query id %ld from client %s\\n&quot,\newline			  rc-&gtroute_query.query_id, rc-&gtclient_addr.sun_path);\newline		}\newline		/* Delete cache entry. */\newline		*rcnp = rc-&gtnext;\newline		free(rc);\newline	    } else {\newline		rcnp = &amprc-&gtnext;\newline	    }\newline	}\newline    }\newline    gt-&gtrsrr_cache = (struct rsrr_cache *)NULL;\newline    \newline#else\newline    IF_DEBUG(DEBUG_RSRR) {\newline        logit(LOG_DEBUG, 0, &quotcleaning cache for group %s\\n&quot,\newline	      inet_fmt(gt-&gtgt_mcastgrp, s1, sizeof(s1)));\newline    }\newline    rc = gt-&gtgt_rsrr_cache;\newline    while (rc) {\newline	rc_next = rc-&gtnext;\newline	free(rc);\newline	rc = rc_next;\newline    }\newline    gt-&gtgt_rsrr_cache = NULL;\newline#endif /* PIM */\newline}\newline","XXX: for PIM, if the routing entry is (S,G), will try first to\newline &quottransfer&quot the RSRR cache entry to the ( ,G) or ( , ,RP) routing entry\newline (if any). If the current routing entry is ( ,G), it will move the\newline cache entries to the ( , ,RP) routing entry (if existing).\newline If the old and the new (iif, oifs) are the same, then no need to send\newline route change message to the reservation daemon: just plug all entries at\newline the front of the rsrr_cache chain.\newline \newline",5940988,keyring.c,"static int keyr_plugin_unpack_cai_from_ai(struct CategoryAppInfo *cai, \newline                                          unsigned char *record, \newline                                          int len)\newline{\newline   int i, rec;\newline\newline   jp_logf(JP_LOG_DEBUG, &quotunpack_keyring_cai_from_ai\\n&quot);\newline\newline   if (len &lt 2 + 16 * 16 + 16 + 2)\newline      return EXIT_FAILURE;\newline   rec = get_short(record);\newline   for (i = 0; i &lt 16; i++) {\newline      if (rec &amp (1 &lt&lt i))\newline         cai-&gtrenamed[i] = 1;\newline      else\newline         cai-&gtrenamed[i] = 0;\newline   }\newline   record += 2;\newline   for (i = 0; i &lt 16; i++) {\newline      memcpy(cai-&gtname[i], record, 16);\newline      record += 16;\newline   }\newline   memcpy(cai-&gtID, record, 16);\newline   record += 16;\newline   cai-&gtlastUniqueID = get_byte(record);\newline\newline   return EXIT_SUCCESS;\newline}\newline",Routine to get category app info from raw buffer. \newline KeyRing is broken and uses a non-standard length CategoryAppInfo.\newline The KeyRing structure is 276 bytes whereas pilot-link uses 278.\newline Code below is taken from unpack_CategoryAppInfo in pilot-link but modified\newline for the shortened structure. \newline,4587578,lbtable.c,"static void get_cmos_checksum_info (void)\newline { const cmos_entry_t *e;\newline   struct cmos_checksum *checksum;\newline   cmos_checksum_layout_t layout;\newline   unsigned index, index2;\newline\newline   checksum = (struct cmos_checksum *) find_lbrec(LB_TAG_OPTION_CHECKSUM);\newline\newline   if (checksum != NULL)\newline    { /* We are lucky.  The coreboot table hints us to the checksum.\newline       * We might have to check the type field here though.\newline       */\newline      layout.summed_area_start = checksum-&gtrange_start;\newline      layout.summed_area_end = checksum-&gtrange_end;\newline      layout.checksum_at = checksum-&gtlocation;\newline      try_convert_checksum_layout(&amplayout);\newline      cmos_checksum_start = layout.summed_area_start;\newline      cmos_checksum_end = layout.summed_area_end;\newline      cmos_checksum_index = layout.checksum_at;\newline      return;\newline    }\newline\newline   if ((e = find_cmos_entry(checksum_param_name)) == NULL)\newline      return;\newline\newline   /* If we get here, we are unlucky.  The CMOS option table contains the\newline    * location of the CMOS checksum.  However, there is no information\newline    * regarding which bytes of the CMOS area the checksum is computed over.\newline    * Thus we have to hope our presets will be fine.\newline    */\newline\newline   if (e-&gtbit % 8)\newline    { fprintf(stderr, &quot%s: Error: CMOS checksum is not byte-aligned.\\n&quot,\newline              prog_name);\newline      exit(1);\newline    }\newline\newline   index = e-&gtbit / 8;\newline   index2 = index + 1;  /* The CMOS checksum occupies 16 bits. */\newline\newline   if (verify_cmos_byte_index(index) || verify_cmos_byte_index(index2))\newline    { fprintf(stderr, &quot%s: Error: CMOS checksum location out of range.\\n&quot,\newline              prog_name);\newline      exit(1);\newline    }\newline\newline   if (((index &gt= cmos_checksum_start) &amp&amp (index &lt= cmos_checksum_end)) ||\newline       (((index2) &gt= cmos_checksum_start) &amp&amp ((index2) &lt= cmos_checksum_end)))\newline    { fprintf(stderr, &quot%s: Error: CMOS checksum overlaps checksummed area.\\n&quot,\newline              prog_name);\newline      exit(1);\newline    }\newline\newline   cmos_checksum_index = index;\newline }\newline",\newline get_cmos_checksum_info\newline \newline Get layout information for CMOS checksum.\newline \newline,345769,kganttdatetimegrid.cpp,void DateTimeGrid::setNoInformationBrush( const QBrush&amp brush )\newline{\newline    d-&gtnoInformationBrush = brush;\newline    emit gridChanged();\newline}\newline,! Sets the brush used to display rows where no data is found.\newline Default is a red pattern. If set to QBrush() rows with no\newline information will not be marked.\newline \newline,5131424,e00error.c,"void    E00Error(int nErrNo, const char *pszFmt, ...)\newline{\newline    va_list args;\newline\newline    gnE00LastErrNo = nErrNo;\newline\newline    /* Expand the error message \newline     */\newline    va_start(args, pszFmt);\newline    vsprintf(gszE00LastErrMsg, pszFmt, args);\newline    va_end(args);\newline\newline\newline    /* If the user provided his own error handling function, then call\newline     * it, otherwise print the error to stderr and return.\newline     */\newline    if (gpfnE00ErrorHandler != NULL)\newline    {\newline        gpfnE00ErrorHandler(nErrNo, gszE00LastErrMsg);\newline    }\newline    else\newline    {\newline        fprintf(stderr, &quotERROR %d: %s\\n&quot, gnE00LastErrNo, gszE00LastErrMsg);\newline    }\newline}\newline",\newline E00Error()\newline \newline This function records an error code and displays the error message\newline to stderr.\newline \newline The error code can be accessed later using E00GetLastErrNo()\newline \newline,4483385,parse_param.c,"static inline int parse_token_param(str* _s, str* _r)\newline{\newline	int i;\newline\newline	     /* There is nothing to parse,\newline	      * return error\newline	      */\newline	if (_s-&gtlen == 0) {\newline		return -1;\newline	}\newline\newline	     /* Save the beginning of the\newline	      * token in _r-&gts\newline	      */\newline	_r-&gts = _s-&gts;\newline\newline	     /* Iterate through the\newline	      * token body\newline	      */\newline	for(i = 0; i &lt _s-&gtlen; i++) {\newline\newline		     /* All these characters\newline		      * mark end of the token\newline		      */\newline		switch(_s-&gts[i]) {\newline		case &#039 &#039:\newline		case &#039\\t&#039:\newline		case &#039\\r&#039:\newline		case &#039\\n&#039:\newline		case &#039,&#039:\newline		case &#039;&#039:\newline			     /* So if you find\newline			      * any of them\newline			      * stop iterating\newline			      */\newline			goto out;\newline		}\newline	}\newline out:\newline	if (i == 0) {\newline		return -1;\newline        }\newline\newline	     /* Save length of the token */\newline        _r-&gtlen = i;\newline\newline	     /* Update _s parameter so it points\newline	      * right behind the end of the token\newline	      */\newline	_s-&gts = _s-&gts + i;\newline	_s-&gtlen -= i;\newline\newline	     /* Everything went OK */\newline	return 0;\newline}\newline",\newline Parse unquoted token in a parameter body\newline let _r point to the token and update _s\newline to point right behind the token\newline \newline,4153276,users.c,"int add_user(eurephiaCTX *ctx, eurephiaSESSION *sess, eurephiaVALUES *cfg, int argc, char **argv) {\newline        xmlDoc *user_xml = NULL, *resxml = NULL;\newline        xmlNode *node = NULL, *node2 = NULL;\newline        eurephiaRESULT *res = NULL;\newline        struct stat cert_stat;\newline        int i = 0, certid = 0, uid = 0, certfile_format = CERTFILE_PEM;\newline        char *uname = NULL, *passwd = NULL, *certfile = NULL, *digest = NULL;\newline\newline        e_options addu_args[] = {\newline                {&quot--username&quot, &quot-u&quot, 1},\newline                {&quot--password&quot, &quot-P&quot, 1},\newline                {&quot--certid&quot,   &quot-C&quot, 1},\newline                {&quot--certfile&quot, &quot-c&quot, 1},\newline                {&quot--digest&quot,   &quot-D&quot, 1},\newline                {&quot--pkcs12&quot,   &quot-2&quot, 0},\newline                {&quot--help&quot, &quot-h&quot, 0},\newline                {NULL, NULL, 0}\newline        };\newline\newline        assert((ctx != NULL) &amp&amp (ctx-&gtdbc != NULL) &amp&amp (ctx-&gtdbc-&gtconfig != NULL));\newline\newline        // Parse arguments\newline        for( i = 1; i &lt argc; i++ ) {\newline                switch( eurephia_getopt(&ampi, argc, argv, addu_args) ) {\newline                case &#039u&#039:\newline                        if( strlen_nullsafe(optargs[0]) &lt 3 ) {\newline                                fprintf(stderr, &quot%s: username is too short\\n&quot, MODULE);\newline                                return 1;\newline                        }\newline                        uname = optargs[0];\newline                        break;\newline\newline                case &#039P&#039:\newline                        if( strlen_nullsafe(optargs[0]) &lt 4 ) {\newline                                fprintf(stderr, &quot%s: password is too short\\n&quot, MODULE);\newline                                return 1;\newline                        }\newline                        passwd = strdup_nullsafe(optargs[0]);\newline                        break;\newline\newline                case &#039C&#039:\newline                        if( (certid = atoi_nullsafe(optargs[0])) &lt 1 ) {\newline                                fprintf(stderr, &quot%s: Invalid certid (numeric value &gt 0)\\n&quot, MODULE);\newline                                return 1;\newline                        }\newline                        break;\newline\newline                case &#039c&#039: // Check if certfile exists and is readable for us\newline                        if( strlen_nullsafe(optargs[0]) &lt 1 ) {\newline                                fprintf(stderr, &quot%s: certfile is too short\\n&quot, MODULE);\newline                                return 1;\newline                        }\newline                        certfile = optargs[0];\newline\newline                        if( stat(certfile, &ampcert_stat) == -1 ) {\newline                                fprintf(stderr, &quot%s: Could not access certfile: %s (%s)\\n&quot, MODULE,\newline                                        certfile, strerror(errno));\newline                                return 1;\newline                        }\newline\newline                        if( cert_stat.st_size == 0 ) {\newline                                fprintf(stderr, &quot%s: certfile &#039%s&#039 is empty\\n&quot, MODULE, certfile);\newline                                return 1;\newline                        }\newline                        break;\newline\newline                case &#0392&#039:\newline                        certfile_format = CERTFILE_PKCS12;\newline                        break;\newline\newline                case &#039D&#039:\newline                        if( strlen_nullsafe(optargs[0]) &lt 59 ) {\newline                                fprintf(stderr, &quot%s: Certificate digest is too short\\n&quot, MODULE);\newline                                return 1;\newline                        }\newline                        digest = optargs[0];\newline                        break;\newline\newline                case &#039h&#039:\newline                        display_users_help(&#039A&#039);\newline                        return 0;\newline\newline                default:\newline                        return 1;\newline                }\newline        }\newline\newline        // Make sure received arguments are sane\newline        if( uname == NULL ) {\newline                fprintf(stderr, &quot%s: Missing user name\\n&quot, MODULE);\newline                return 1;\newline        }\newline\newline        if( ((certid &gt 0) &amp&amp (digest != NULL))\newline            || ((certid &gt 0) &amp&amp (certfile != NULL))\newline            || ((digest != NULL) &amp&amp (certfile != NULL)) ) {\newline                fprintf(stderr, &quot%s: --certid, --certfile and --digest cannot be used together\\n&quot, MODULE);\newline                return 1;\newline        }\newline\newline        // If we do not have a password .... ask for password via console\newline        if( passwd == NULL ) {\newline                char *chkpwd = NULL;\newline\newline                passwd = (char *) malloc_nullsafe(ctx, 66);\newline                assert(passwd != NULL);\newline\newline                chkpwd = (char *) malloc_nullsafe(ctx, 66);\newline                assert(chkpwd != NULL);\newline\newline                get_console_input(passwd, 64, &quotPassword for user:&quot, 1);\newline                if( strlen_nullsafe(passwd) &lt 4 ) {\newline                        free_nullsafe(ctx, passwd);\newline                        free_nullsafe(ctx, chkpwd);\newline                        fprintf(stderr, &quot%s: Password is too short\\n&quot, MODULE);\newline                        return 1;\newline                }\newline\newline                get_console_input(chkpwd, 64, &quotVerify password for user:&quot, 1);\newline                if( strcmp(passwd, chkpwd) != 0 ) {\newline                        free_nullsafe(ctx, passwd);\newline                        free_nullsafe(ctx, chkpwd);\newline                        fprintf(stderr, &quot%s: Passwords didn&#039t match\\n&quot, MODULE);\newline                        return 1;\newline                }\newline                free_nullsafe(ctx, chkpwd);\newline        }\newline\newline        // Prepare add user XML document with fieldMapping\newline        eurephiaXML_CreateDoc(ctx, 1, &quotUserAccount&quot, &ampuser_xml, &ampnode);\newline        xmlNewProp(node, (xmlChar *) &quotmode&quot, (xmlChar *) &quotadd&quot);\newline\newline        node = xmlNewChild(node, NULL, (xmlChar *) &quotfieldMapping&quot, NULL);\newline        xmlNewProp(node, (xmlChar *) &quottable&quot, (xmlChar *) &quotusers&quot);\newline\newline        xmlNewChild(node, NULL, (xmlChar *) &quotusername&quot, (xmlChar *) uname);\newline        node2 = xmlNewChild(node, NULL, (xmlChar *) &quotpassword&quot, (xmlChar *) passwd);\newline        xmlNewProp(node2, (xmlChar *) &quotpwhash&quot, (xmlChar *) &quotnone&quot);\newline\newline        // Add the user\newline        resxml = eDBadminUserAccount(ctx, user_xml);\newline        xmlFreeDoc(user_xml);\newline        memset(passwd, 0, strlen_nullsafe(passwd));\newline        free_nullsafe(ctx, passwd);\newline        if( (resxml == NULL) || !eurephiaXML_IsResultMsg(ctx, resxml) ) {\newline                fprintf(stderr, &quot%s: Failed to register the user.  Unknown failure.\\n&quot, MODULE);\newline                return 1;\newline        }\newline\newline        res = eurephiaXML_ParseResultMsg(ctx, resxml);\newline        if( res == NULL ) {\newline                fprintf(stderr, &quot%s: Failed to register the user.  No results returned.\\n&quot, MODULE);\newline                xmlFreeDoc(resxml);\newline                return 1;\newline        } else if( res-&gtresultType == exmlERROR ) {\newline                fprintf(stderr, &quot%s: %s\\n&quot, MODULE, res-&gtmessage);\newline                xmlFreeDoc(resxml);\newline                free_nullsafe(ctx, res);\newline                return 1;\newline        }\newline\newline        if( xmlStrcmp(res-&gtdetails-&gtchildren-&gtname, (xmlChar *) &quotUserAccount&quot) != 0 ) {\newline                fprintf(stderr, &quot%s: Invalid result value.  User account might be registered\\n&quot, MODULE);\newline                xmlFreeDoc(resxml);\newline                free_nullsafe(ctx, res);\newline                return 1;\newline        }\newline\newline        fprintf(stdout, &quot%s: %s\\n&quot, MODULE, res-&gtmessage);\newline        uid = atoi_nullsafe(xmlGetAttrValue(res-&gtdetails-&gtproperties, &quotuid&quot));\newline        xmlFreeDoc(resxml);\newline        free_nullsafe(ctx, res);\newline\newline        if( (digest != NULL) || (certfile != NULL) ) {\newline                if( digest != NULL ) {\newline                        xmlDoc *cert_xml = NULL, *certlist = NULL;\newline                        xmlNode *cert_n = NULL;\newline                        int certcount = 0;\newline\newline                        // when we have certificate digest, look that up\newline                        eurephiaXML_CreateDoc(ctx, 1, &quotcertificates&quot, &ampcert_xml, &ampcert_n);\newline                        assert( (cert_xml != NULL) &amp&amp (cert_n != NULL) );\newline                        xmlNewProp(cert_n, (xmlChar *) &quotmode&quot, (xmlChar *) &quotlist&quot);\newline                        xmlNewChild(cert_n, NULL, (xmlChar *) &quotsortkeys&quot, (xmlChar *) &quotcertid&quot);\newline\newline                        cert_n = xmlNewChild(cert_n, NULL, (xmlChar *) &quotfieldMapping&quot, NULL);\newline                        xmlNewProp(cert_n, (xmlChar *) &quottable&quot, (xmlChar *) &quotcertificates&quot);\newline                        xmlNewChild(cert_n, NULL, (xmlChar *) &quotdigest&quot, (xmlChar *) digest);\newline\newline                        certlist = eDBadminCertificate(ctx, cert_xml);\newline                        if( certlist == NULL ) {\newline                                fprintf(stderr, &quot%s: Error while looking up certificate info.\\n&quot\newline                                        &quot%s: User account is not associated with any certificates\\n&quot,\newline                                        MODULE, MODULE);\newline                                xmlFreeDoc(cert_xml);\newline                                goto exit;\newline                        }\newline                        xmlFreeDoc(cert_xml);\newline\newline                        cert_n = eurephiaXML_getRoot(ctx, certlist, &quotcertificates&quot, 1);\newline                        if( cert_n == NULL ) {\newline                                fprintf(stderr, &quot%s: Could not find certificates root node in XML document. &quot\newline                                        &quotNo association done.\\n&quot, MODULE);\newline                                xmlFreeDoc(certlist);\newline                                goto exit;\newline                        }\newline                        certcount = atoi_nullsafe(xmlGetAttrValue(cert_n-&gtproperties, &quotcertificates&quot));\newline                        if( certcount == 0) {\newline                                fprintf(stderr, &quot%s: No certificates was found. No association is done.\\n&quot,\newline                                        MODULE);\newline                                xmlFreeDoc(certlist);\newline                                goto exit;\newline                        } else if( certcount &gt 1 ) {\newline                                fprintf(stderr, &quot%s: More than one certificates was found. &quot\newline                                        &quotNo association is done.\\n&quot, MODULE);\newline                                xmlFreeDoc(certlist);\newline                                goto exit;\newline                        }\newline\newline                        // Get the first and only certificate node\newline                        cert_n = xmlFindNode(cert_n, &quotcertificate&quot);\newline                        if( cert_n == NULL ) {\newline                                fprintf(stderr, &quot%s: Could not find certificate node in XML document. &quot\newline                                        &quotNo association done.\\n&quot, MODULE);\newline                                xmlFreeDoc(certlist);\newline                                goto exit;\newline                        }\newline                        // finally, we should have located the certid in the XML\newline                        certid = atoi_nullsafe(xmlGetAttrValue(cert_n-&gtproperties, &quotcertid&quot));\newline                        xmlFreeDoc(certlist);\newline                } else if( certfile != NULL ) {\newline                        // when we have certfile - register the certificate and register the link\newline                        certinfo *ci = NULL;\newline\newline                        ci = Cert_ParseFile(certfile, certfile_format);\newline                        if( ci == NULL ) {\newline                                fprintf(stderr, &quot%s: Could not parse the certificate file.  &quot\newline                                        &quotNo association done.\\n&quot, MODULE);\newline                                goto exit;\newline                        }\newline\newline                        certid = register_certificate(ctx, 0, ci-&gtdigest, ci-&gtcommon_name, ci-&gtorg, ci-&gtemail);\newline                        if( certid == 0 ) {\newline                                fprintf(stderr, &quot%s: Failed to register certificate file.  No association done.&quot,\newline                                        MODULE);\newline                        }\newline                }\newline        }\newline\newline        // If we have a certificate id, register a certificate link to the user account\newline        if( (certid &gt 0) &amp&amp (uid &gt 0) ) {\newline                xmlDoc *usercert_xml = NULL, *res_xml = NULL;\newline                xmlNode *usercert_n = NULL;\newline                eurephiaRESULT *res = NULL;\newline                xmlChar tmp[66];\newline\newline                memset(&amptmp, 0, 66);\newline                eurephiaXML_CreateDoc(ctx, 1, &quotusercerts&quot, &ampusercert_xml, &ampusercert_n);\newline                assert( (usercert_xml != NULL) &amp&amp (usercert_n != NULL) );\newline\newline                xmlNewProp(usercert_n, (xmlChar *) &quotmode&quot, (xmlChar *) &quotregister&quot);\newline                usercert_n = xmlNewChild(usercert_n, NULL, (xmlChar *) &quotfieldMapping&quot, NULL);\newline                xmlNewProp(usercert_n, (xmlChar *) &quottable&quot, (xmlChar *) &quotusercerts&quot);\newline\newline                xmlStrPrintf(tmp, 64, (xmlChar *) &quot%i%c&quot, uid, &#039\\0&#039);\newline                xmlNewChild(usercert_n, NULL, (xmlChar *) &quotuid&quot, tmp);\newline                xmlStrPrintf(tmp, 64, (xmlChar *) &quot%i%c&quot, certid, &#039\\0&#039);\newline                xmlNewChild(usercert_n, NULL, (xmlChar *) &quotcertid&quot, tmp);\newline\newline                res_xml = eDBadminUserCertsLink(ctx, usercert_xml);\newline                if( res_xml == NULL ) {\newline                        fprintf(stderr, &quot%s: Failed to register user &lt-&gt certificate link\\n&quot, MODULE);\newline                        goto exit;\newline                }\newline\newline                res = eurephiaXML_ParseResultMsg(ctx, res_xml);\newline                if( res == NULL ) {\newline                        fprintf(stderr, &quot%s: Failed to register user &lt-&gt certificate link.  &quot\newline                                &quotNo results received\\n&quot, MODULE);\newline                } else if( res-&gtresultType == exmlERROR ) {\newline                        fprintf(stderr, &quot%s: %s\\n&quot, MODULE, res-&gtmessage);\newline                }\newline                free_nullsafe(ctx, res);\newline                xmlFreeDoc(res_xml);\newline        }\newline exit:\newline        return (uid &gt 0);\newline}\newline","\newline users add mode. Creates a new user account.\newline \newline @param ctx eurephiaCTX\newline @param sess eurephiaSESSION of the current logged in user\newline @param cfg eurephiaVALUES struct of the current configuration\newline @param argc argument count for the eurephiadm command\newline @param argv argument table for the eurephiadm command\newline \newline @return returns 0 on success, otherwise 1.\newline \newline",3808382,tl_int.c,"void thin_irq_enable(int irq)\newline{\newline   uint8 pic;\newline\newline   _irq_init();\newline\newline   pic = inportb(0x21);\newline\newline   if (irq &gt 7)\newline   {\newline      /* unmask cascade (IRQ2) interrupt */\newline      //outportb(0x21, pic &amp 0xFB);\newline      outportb(0x21, pic &amp ~(1 &lt&lt 2));\newline      pic = inportb(0xA1);\newline      outportb(0xA1, pic &amp ~(1 &lt&lt (irq - 8)));\newline      pic2_mask |= 1 &lt&lt (irq - 8);\newline   }\newline   else\newline   {\newline      outportb(0x21, pic &amp ~(1 &lt&lt irq));\newline      pic1_mask |= 1 &lt&lt irq;\newline   }\newline}\newline",unmask an interrupt \newline,1119408,genomicregion.c,"Gene * access_gene_GenomicRegion(GenomicRegion * obj,int i) \newline{\newline    if( obj == NULL)     {  \newline      warn(&quotIn accessor function gene for object GenomicRegion, got a NULL object&quot); \newline      return NULL;   \newline      }  \newline    if( obj-&gtlen &lt= i )  {  \newline      warn(&quotIn accessor function gene for object GenomicRegion, index %%d is greater than list length %%d&quot,i,obj-&gtlen);  \newline      return NULL;   \newline      }  \newline    return obj-&gtgene[i];     \newline}    \newline","Function: access_gene_GenomicRegion(obj,i)\newline \newline Descrip: Access members stored in the gene list\newline For use principly by API functions\newline \newline \newline Arg: obj [UNKN ] Object holding the list [GenomicRegion ]\newline Arg: i [UNKN ] Position in the list [int]\newline \newline Return [SOFT ] Element of the list [Gene ]\newline \newline \newline",2265223,util_constraints_list.c,"Constraint_list* read_constraint_list(Constraint_list *CL,char *in_fname,char *in_mode, char *mem_mode,char *weight_mode)\newline{\newline	Sequence *SL=NULL, *TS=NULL;\newline	int a;\newline	Constraint_list *SUBCL=NULL;\newline	static char *read_mode;\newline	char *fname;\newline\newline	fname=in_fname;\newline	if ( !read_mode)read_mode=(char*)vcalloc ( STRING, sizeof (char));\newline\newline	if ( is_lib_list (in_fname))sprintf ( read_mode, &quotlib_list&quot);\newline	else if ( in_mode)sprintf (read_mode, &quot%s&quot, in_mode);\newline	else if ( fname[0]==&#039A&#039){sprintf ( read_mode, &quotaln&quot);fname++;}\newline	else if ( fname[0]==&#039L&#039){sprintf ( read_mode, &quotlib&quot);fname++;}\newline	else if ( fname[0]==&#039M&#039){sprintf ( read_mode, &quotmethod&quot);fname++;}\newline	else if ( fname[0]==&#039S&#039){sprintf ( read_mode, &quotsequence&quot);return CL;}\newline	else if ( fname[0]==&#039P&#039){sprintf ( read_mode, &quotpdb&quot)     ;return CL;}\newline	else if ( fname[0]==&#039R&#039){sprintf ( read_mode, &quotprofile&quot) ;return CL;}\newline	else if ( fname[0]==&#039X&#039){sprintf ( read_mode, &quotmatrix&quot);++fname;}\newline	else if ( fname[0]==&#039W&#039){sprintf ( read_mode, &quotstructure&quot);fname++;}\newline	else\newline	{\newline		fprintf ( stderr, &quot\\nERROR: The descriptor %s could not be identified as a file or a method.[FATAL]\\nIf it is a method file please indicate it with M%s\\n&quot, fname, fname);\newline		myexit (EXIT_SUCCESS);\newline	}\newline\newline	fprintf (CL-&gtlocal_stderr, &quot\\n\\t%s [%s]\\n&quot, fname, read_mode);\newline\newline\newline	if ( strm (read_mode, &quotlib_list&quot))\newline	{\newline		int n, a;\newline		char **l;\newline		l=read_lib_list (fname, &ampn);\newline		for ( a=0; a&ltn; a++)\newline			CL=read_constraint_list (CL,l[a],in_mode, mem_mode,weight_mode);\newline		free_char (l,-1);\newline	}\newline	else if (strm(read_mode, &quotbinary&quot))\newline	{\newline		fprintf ( stderr, &quot\\nERROR: Library %s: binary mode is not any more supported [FATAL:%s]\\n&quot, fname,PROGRAM);\newline		myexit (EXIT_FAILURE);\newline	}\newline	else if ( strm (fname, &quotmake_test_lib&quot))\newline	{\newline		CL=make_test_lib (CL);\newline	}\newline	else if ( strm2 (read_mode,&quotascii&quot,&quotlib&quot))\newline	{\newline\newline		SUBCL=read_constraint_list_file(NULL, fname);\newline\newline	}\newline	else if (strm(read_mode, &quotmethod&quot))\newline	{\newline		CL=produce_list ( CL, CL-&gtS, fname,weight_mode,mem_mode);\newline	}\newline	else if (strm(read_mode, &quotmatrix&quot))\newline	{\newline		CL-&gtresidue_index=NULL;\newline		CL-&gtextend_jit=0;\newline		CL-&gtM=read_matrice ( fname);\newline	}\newline	else if ( strm ( read_mode, &quotstructure&quot))\newline	{\newline		if ( CL-&gtne&gt0)\newline		{\newline			fprintf ( stderr, &quot\\nERROR: Wstructure must come before Mmethod or Aaln [FATAL:%s]&quot,PROGRAM);\newline			myexit (EXIT_FAILURE);\newline		}\newline\newline		if ( !(CL-&gtSTRUC_LIST))\newline		{\newline			CL-&gtSTRUC_LIST=declare_sequence (1,1,10000);\newline			(CL-&gtSTRUC_LIST)-&gtnseq=0;\newline		}\newline		SL=CL-&gtSTRUC_LIST;\newline\newline		if ( check_file_exists(fname))\newline		{\newline			TS=main_read_seq ( fname);\newline			for (a=0; a&ltTS-&gtnseq; a++)sprintf (SL-&gtname[SL-&gtnseq++], &quot%s&quot, TS-&gtname[a]);\newline			free_sequence (TS, TS-&gtnseq);\newline		}\newline		else\newline		{\newline			sprintf (SL-&gtname[SL-&gtnseq++], &quot%s&quot, fname);\newline		}\newline	}\newline	else if (strm (read_mode, &quotaln&quot))\newline	{\newline		CL=aln_file2constraint_list ( fname,CL,weight_mode);\newline	}\newline	else\newline	{\newline		SUBCL=read_constraint_list_file(SUBCL, fname);\newline	}\newline\newline\newline	if (SUBCL)\newline	{\newline		CL=merge_constraint_list    (SUBCL, CL, &quotdefault&quot);\newline		free_constraint_list_full (SUBCL);\newline	}\newline\newline	return CL;\newline}\newline","\newline Central method for reading different types of files.\newline \newline \\todo This MUST be documented! Explain what types of input are possible and so on.\newline \\todo It should also contain odds that occur when reading several inputs, like keeping the maximum edge weight.\newline \newline \\param[in,out] CL points to the global ::Constrain_list object.\newline \\param[in] in_fname Name of the input file to be read.\newline \newline",700765,event-parse.c,"int pevent_register_function(struct pevent *pevent, char *func,\newline			     unsigned long long addr, char *mod)\newline{\newline	struct func_list *item = malloc(sizeof(*item));\newline\newline	if (!item)\newline		return -1;\newline\newline	item-&gtnext = pevent-&gtfunclist;\newline	item-&gtfunc = strdup(func);\newline	if (!item-&gtfunc)\newline		goto out_free;\newline\newline	if (mod) {\newline		item-&gtmod = strdup(mod);\newline		if (!item-&gtmod)\newline			goto out_free_func;\newline	} else\newline		item-&gtmod = NULL;\newline	item-&gtaddr = addr;\newline\newline	pevent-&gtfunclist = item;\newline	pevent-&gtfunc_count++;\newline\newline	return 0;\newline\newlineout_free_func:\newline	free(item-&gtfunc);\newline	item-&gtfunc = NULL;\newlineout_free:\newline	free(item);\newline	errno = ENOMEM;\newline	return -1;\newline}\newline",\newline pevent_register_function - register a function with a given address\newline @pevent: handle for the pevent\newline @function: the function name to register\newline @addr: the address the function starts at\newline @mod: the kernel module the function may be in (NULL for none)\newline \newline This registers a function name with an address and module.\newline The @func passed in is duplicated.\newline \newline,,,on,,,,,,,,,,,,,,,on,on,,,,,,,,,,,,,,,,,,,,,,,,de-noised difference,Add a block of data into the window.,{},Routine to get category app info from raw buffer.,Get layout information for CMOS checksum.,Default is a red pattern.,The error code can be accessed later using E00GetLastErrNo(),Parse unquoted token in a parameter body,Creates a new user account.,unmask an interrupt,"Function: access_gene_GenomicRegion(obj,i)","Evaluate the ""diameter"" (d) of a rectangle of widths",Explain what types of input are possible and so on.,This registers a function name with an address and module.,Exported routine,sipmly swappes the content of the two buffers,Load an image from the named file.,{},{},Information is packed into the buffer as follows:,Increase the ref counter.,x,
32ZCLEW0BZKHFD9SRRFNN57PGF2JP8,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:52 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:52 PDT 2019,,,3VA45EW49NNUMGEGC413JO22UOOO1U,AITP2LUW8GPB,Submitted,Fri Apr 26 12:48:59 PDT 2019,Fri Apr 26 13:24:05 PDT 2019,Sun Apr 28 13:24:05 PDT 2019,,,,2106,100% (62/62),100% (62/62),0% (0/0),6373981,var-int.h,"static inline int var_int_write(unsigned char *p, unsigned int i)\newline{\newline    if (i &lt (1&lt&lt7)) {\newline	*p = 0x80 | i;\newline	return 1;\newline    }\newline    else if (i &lt (1&lt&lt14)) {\newline	*(p++) = 0x40 | (i &gt&gt 8);\newline	*p = i &amp 0xFF;\newline	return 2;\newline    }\newline    else if (i &lt (1&lt&lt21)) {\newline	*(p++) = 0x20 | (i &gt&gt 16);\newline	*(p++) = 0xFF &amp (i &gt&gt 8);\newline	*p = i &amp 0xFF;\newline	return 3;\newline    }\newline    else if (i &lt (1&lt&lt28)) {\newline	*(p++) = 0x10 | (i &gt&gt 24);\newline	*(p++) = 0xFF &amp (i &gt&gt 16);\newline	*(p++) = 0xFF &amp (i &gt&gt 8);\newline	*p = i &amp 0xFF;\newline	return 4;\newline    }\newline    else {\newline	/* Assume the value fits in 32 bits */\newline	*(p++) = 0x08;\newline	*(p++) = 0xFF &amp (i &gt&gt 24);\newline	*(p++) = 0xFF &amp (i &gt&gt 16);\newline	*(p++) = 0xFF &amp (i &gt&gt 8);\newline	*p = i &amp 0xFF;\newline	return 5;\newline    }\newline}\newline","Writes an integer at &#039p&#039, returns the number of bytes written \newline",6413282,main.cpp,"bool methodCancelFindDevices(NPObject *obj, const NPVariant args[], uint32_t argCount, NPVariant * result)\newline{\newline    devManager-&gtcancelFindDevices();\newline    return true;\newline}\newline",\newline Cancel the search for devices.\newline This method gets called from the outside.\newline This method takes no parameter\newline Return nothing\newline @param obj\newline @param args[] contains all passed parameters\newline @param argCount number of passed parameters\newline @param result store return value here\newline @return boolean. Return true if successful\newline \newline,346923,tree.c,"EXPORT Tree get_elt_by_id(Node *n, const conststring id)\newline{\newline  /* To do: should this use a hash table? */\newline  Tree h, p;\newline\newline  h = get_root(n);\newline  for (h = h-&gtchildren; h; h = h-&gtsister)\newline    if (h-&gttp == Element &amp&amp (p = get_by_id(h, id))) return p;\newline  return NULL;\newline}\newline",get_elt_by_id -- get the element node with the ID attribute id \newline,3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,1209195,jsint.c,"void js_upcall_reset(void *bidak, long document_id, long form_id)\newline{\newline	struct f_data_c *js_ctx=(struct f_data_c*)bidak;\newline	struct f_data_c *fd;\newline\newline	if (!js_ctx)internal(&quotjs_upcall_reset called with NULL context pointer\\n&quot);\newline	fd=jsint_find_document(document_id);\newline	if (!fd||!jsint_can_access(js_ctx,fd))return;\newline	if ((form_id&ampJS_OBJ_MASK)!=JS_OBJ_T_FORM)return;\newline	if (!fd-&gtf_data)return;\newline\newline	reset_form(fd,form_id&gt&gtJS_OBJ_MASK_SIZE);\newline	draw_fd(fd);\newline	change_screen_status(fd-&gtses);\newline	print_screen_status(fd-&gtses);\newline}\newline",emulates reset of a form \newline,4517132,dec_main.c,"Word32 D_MAIN_decode(Word16 mode, Word16 prms[], Word16 synth16k[],\newline                     void *spd_state, UWord8 frame_type)\newline{\newline\newline   Word32 code2[L_SUBFR];           /* algebraic codevector                */\newline   Word32 L_tmp, L_tmp2, L_gain_code, L_stab_fac;\newline   Word32 i, j, i_subfr, pit_flag;\newline   Word32 T0, T0_frac, T0_max, select, T0_min = 0;\newline\newline   Word16 exc2[L_FRAME];            /* excitation vector                   */\newline   Word16 Aq[NB_SUBFR * (M + 1)];   /* A(z) quantized for the 4 subframes  */\newline   Word16 code[L_SUBFR];            /* algebraic codevector                */\newline   Word16 excp[L_SUBFR];            /* excitation vector                   */\newline   Word16 HfIsf[M16k];\newline   Word16 ispnew[M];                /* immittance spectral pairs at 4nd sfr*/\newline   Word16 isf[M];                   /* ISF (frequency domain) at 4nd sfr   */\newline   Word16 isf_tmp[M];               /* ISF tmp                             */\newline   Word16 ind[8];                   /* quantization indices                */\newline\newline   Word16 index, fac, voice_fac, max, Q_new = 0;\newline   Word16 gain_pit, gain_code, gain_code_lo, tmp;\newline   Word16 corr_gain = 0;\newline   UWord16 pit_sharp = 0;\newline\newline   Word16 *exc;                     /* Excitation vector                   */\newline   Word16 *p_Aq;                    /* ptr to A(z) for the 4 subframes     */\newline   Word16 *p_isf;                   /* prt to isf                          */\newline\newline   Decoder_State *st;   /* Decoder states */\newline   UWord8 newDTXState, bfi, unusable_frame;\newline   UWord8 vad_flag;\newline\newline   st = (Decoder_State*)spd_state;\newline\newline   /* find the new  DTX state  SPEECH OR DTX */\newline   newDTXState = D_DTX_rx_handler(st-&gtdtx_decSt, frame_type);\newline\newline   if(newDTXState != SPEECH)\newline   {\newline      D_DTX_exe(st-&gtdtx_decSt, exc2, newDTXState, isf, &ampprms);\newline   }\newline\newline   /* SPEECH action state machine  */\newline   if((frame_type == RX_SPEECH_BAD) |\newline      (frame_type == RX_SPEECH_PROBABLY_DEGRADED))\newline   {\newline      /* bfi for all index, bits are not usable */\newline      bfi = 1;\newline      unusable_frame = 0;\newline   }\newline   else if((frame_type == RX_NO_DATA) | (frame_type == RX_SPEECH_LOST))\newline   {\newline      /* bfi only for lsf, gains and pitch period */\newline      bfi = 1;\newline      unusable_frame = 1;\newline   }\newline   else\newline   {\newline      bfi = 0;\newline      unusable_frame = 0;\newline   }\newline\newline   if(bfi != 0)\newline   {\newline      st-&gtmem_state = (UWord8)(st-&gtmem_state + 1);\newline\newline      if(st-&gtmem_state &gt 6)\newline      {\newline         st-&gtmem_state = 6;\newline      }\newline   }\newline   else\newline   {\newline      st-&gtmem_state = (UWord8)(st-&gtmem_state &gt&gt 1);\newline   }\newline\newline   /*\newline    * If this frame is the first speech frame after CNI period,\newline    * set the BFH state machine to an appropriate state depending\newline    * on whether there was DTX muting before start of speech or not\newline    * If there was DTX muting, the first speech frame is muted.\newline    * If there was no DTX muting, the first speech frame is not\newline    * muted. The BFH state machine starts from state 5, however, to\newline    * keep the audible noise resulting from a SID frame which is\newline    * erroneously interpreted as a good speech frame as small as\newline    * possible (the decoder output in this case is quickly muted)\newline    */\newline\newline   if(st-&gtdtx_decSt-&gtmem_dtx_global_state == DTX)\newline   {\newline      st-&gtmem_state = 5;\newline      st-&gtmem_bfi = 0;\newline   }\newline   else if(st-&gtdtx_decSt-&gtmem_dtx_global_state == D_DTX_MUTE)\newline   {\newline      st-&gtmem_state = 5;\newline      st-&gtmem_bfi = 1;\newline   }\newline\newline   if(newDTXState == SPEECH)\newline   {\newline      vad_flag = (UWord8)(*prms++);\newline\newline      if(bfi == 0)\newline      {\newline         if(vad_flag == 0)\newline         {\newline            st-&gtmem_vad_hist = (Word16)(st-&gtmem_vad_hist + 1);\newline\newline            if(st-&gtmem_vad_hist &gt 32767)\newline            {\newline               st-&gtmem_vad_hist = 32767;\newline            }\newline         }\newline         else\newline         {\newline            st-&gtmem_vad_hist = 0;\newline         }\newline      }\newline   }\newline\newline   /*\newline    * DTX-CNG\newline    */\newline   if(newDTXState != SPEECH) /* CNG mode */\newline   {\newline      /*\newline       * increase slightly energy of noise below 200 Hz\newline       * Convert ISFs to the cosine domain\newline       */\newline      D_LPC_isf_isp_conversion(isf, ispnew, M);\newline      D_LPC_isp_a_conversion(ispnew, Aq, 1, M);\newline      memcpy(isf_tmp, st-&gtmem_isf, M * sizeof(Word16));\newline\newline      for(i_subfr = 0; i_subfr &lt L_FRAME; i_subfr += L_SUBFR)\newline      {\newline         j = (i_subfr &gt&gt 6);\newline\newline         for(i = 0; i &lt M; i++)\newline         {\newline            L_tmp = (isf_tmp[i] * (32767 - D_ROM_interpol_frac[j])) &lt&lt 1;\newline            L_tmp = L_tmp + ((isf[i] * D_ROM_interpol_frac[j]) &lt&lt 1);\newline            HfIsf[i] = (Word16)((L_tmp + 0x8000) &gt&gt 16);\newline         }\newline\newline         D_UTIL_dec_synthesis(Aq, &ampexc2[i_subfr], 0, &ampsynth16k[i_subfr * 5 /4],\newline            (Word16) 1, HfIsf, mode, newDTXState, bfi, st);\newline      }\newline\newline      /* reset speech coder memories */\newline      D_MAIN_reset(st, 0);\newline      memcpy(st-&gtmem_isf, isf, M * sizeof(Word16));\newline      st-&gtmem_bfi = bfi;\newline      st-&gtdtx_decSt-&gtmem_dtx_global_state = (UWord8)newDTXState;\newline\newline      return(0);\newline   }\newline\newline   /*\newline    * ACELP\newline    */\newline\newline   exc = st-&gtmem_exc + PIT_MAX + L_INTERPOL;\newline\newline   /* Decode the ISFs */\newline   if(mode &lt= MODE_7k)\newline   {\newline      ind[0] = *prms++;\newline      ind[1] = *prms++;\newline      ind[2] = *prms++;\newline      ind[3] = *prms++;\newline      ind[4] = *prms++;\newline      D_LPC_isf_2s3s_decode(ind, isf, st-&gtmem_isf_q, st-&gtmem_isf,\newline         st-&gtmem_isf_buf, bfi);\newline   }\newline   else\newline   {\newline      ind[0] = *prms++;\newline      ind[1] = *prms++;\newline      ind[2] = *prms++;\newline      ind[3] = *prms++;\newline      ind[4] = *prms++;\newline      ind[5] = *prms++;\newline      ind[6] = *prms++;\newline      D_LPC_isf_2s5s_decode(ind, isf, st-&gtmem_isf_q, st-&gtmem_isf,\newline         st-&gtmem_isf_buf, bfi);\newline   }\newline\newline   /* Convert ISFs to the cosine domain */\newline   D_LPC_isf_isp_conversion(isf, ispnew, M);\newline\newline   if(st-&gtmem_first_frame != 0)\newline   {\newline      st-&gtmem_first_frame = 0;\newline      memcpy(st-&gtmem_isp, ispnew, M * sizeof(Word16));\newline   }\newline\newline   /* Find the interpolated ISPs and convert to a[] for all subframes */\newline   D_LPC_int_isp_find(st-&gtmem_isp, ispnew, D_ROM_interpol_frac, Aq);\newline\newline   /* update isp memory for the next frame */\newline   memcpy(st-&gtmem_isp, ispnew, M * sizeof(Word16));\newline\newline   /* Check stability on isf : distance between old isf and current isf */\newline   L_tmp = 0;\newline   p_isf = st-&gtmem_isf;\newline\newline   for(i = 0; i &lt M - 1; i++)\newline   {\newline      tmp = (Word16)((isf[i] - p_isf[i]));\newline      L_tmp = L_tmp + (tmp * tmp);\newline   }\newline\newline   if(L_tmp &lt 3276928)\newline   {\newline      L_tmp = L_tmp &gt&gt 7;\newline      L_tmp = (L_tmp * 26214) &gt&gt 15;   /* tmp = L_tmp*0.8/256        */\newline      L_tmp = 20480 - L_tmp;           /* 1.25 - tmp                 */\newline      L_stab_fac = L_tmp &lt&lt 1;         /* Q14 -&gt Q15 with saturation */\newline\newline      if(L_stab_fac &gt 0x7FFF)\newline      {\newline         L_stab_fac = 0x7FFF;\newline      }\newline   }\newline   else\newline   {\newline      L_stab_fac = 0x0;\newline   }\newline\newline   memcpy(isf_tmp, st-&gtmem_isf, M * sizeof(Word16));\newline   memcpy(st-&gtmem_isf, isf, M * sizeof(Word16));\newline\newline   /*\newline    * Loop for every subframe in the analysis frame\newline    *\newline    * The subframe size is L_SUBFR and the loop is repeated L_FRAME/L_SUBFR\newline    * times\newline    *   - decode the pitch delay and filter mode\newline    *   - decode algebraic code\newline    *   - decode pitch and codebook gains\newline    *   - find voicing factor and tilt of code for next subframe\newline    *   - find the excitation and compute synthesis speech\newline    */\newline\newline   p_Aq = Aq;   /* pointer to interpolated LPC parameters */\newline\newline   for(i_subfr = 0; i_subfr &lt L_FRAME; i_subfr += L_SUBFR)\newline   {\newline      pit_flag = i_subfr;\newline\newline      if((i_subfr == (2 * L_SUBFR)) &amp (mode &gt MODE_7k))\newline      {\newline         pit_flag = 0;\newline      }\newline\newline      /*\newline       * - Decode pitch lag\newline       * Lag indeces received also in case of BFI,\newline       * so that the parameter pointer stays in sync.\newline       */\newline\newline      if(pit_flag == 0)\newline      {\newline         if(mode &lt= MODE_9k)\newline         {\newline            index = *prms++;\newline\newline            if(index &lt ((PIT_FR1_8b - PIT_MIN) * 2))\newline            {\newline               T0 = (PIT_MIN + (index &gt&gt 1));\newline               T0_frac = (index - ((T0 - PIT_MIN) &lt&lt 1));\newline               T0_frac = (T0_frac &lt&lt 1);\newline            }\newline            else\newline            {\newline               T0 = index + (PIT_FR1_8b - ((PIT_FR1_8b - PIT_MIN) * 2));\newline               T0_frac = 0;\newline            }\newline         }\newline         else\newline         {\newline            index = *prms++;\newline\newline            if(index &lt ((PIT_FR2 - PIT_MIN) * 4))\newline            {\newline               T0 = PIT_MIN + (index &gt&gt 2);\newline               T0_frac = index - ((T0 - PIT_MIN) &lt&lt 2);\newline            }\newline            else if(index &lt\newline               ((((PIT_FR2 - PIT_MIN) * 4) + ((PIT_FR1_9b - PIT_FR2) * 2))))\newline            {\newline               index = (Word16)((index - ((PIT_FR2 - PIT_MIN) * 4)));\newline               T0 = PIT_FR2 + (index &gt&gt 1);\newline               T0_frac = index - ((T0 - PIT_FR2) &lt&lt 1);\newline               T0_frac = T0_frac &lt&lt 1;\newline            }\newline            else\newline            {\newline               T0 = index + (PIT_FR1_9b - ((PIT_FR2 - PIT_MIN) * 4) -\newline                  ((PIT_FR1_9b - PIT_FR2) * 2));\newline               T0_frac = 0;\newline            }\newline         }\newline\newline         /* find T0_min and T0_max for subframe 2 and 4 */\newline         T0_min = T0 - 8;\newline\newline         if(T0_min &lt PIT_MIN)\newline         {\newline            T0_min = PIT_MIN;\newline         }\newline\newline         T0_max = T0_min + 15;\newline\newline         if(T0_max &gt PIT_MAX)\newline         {\newline            T0_max = PIT_MAX;\newline            T0_min = T0_max - 15;\newline         }\newline      }\newline      else\newline      {   /* if subframe 2 or 4 */\newline\newline         if(mode &lt= MODE_9k)\newline         {\newline            index = *prms++;\newline            T0 = T0_min + (index &gt&gt 1);\newline            T0_frac = index - ((T0 - T0_min) &lt&lt 1);\newline            T0_frac = T0_frac &lt&lt 1;\newline         }\newline         else\newline         {\newline            index = *prms++;\newline            T0 = T0_min + (index &gt&gt 2);\newline            T0_frac = index - ((T0 - T0_min) &lt&lt 2);\newline         }\newline      }\newline\newline      /* check BFI after pitch lag decoding */\newline      if(bfi != 0) /* if frame erasure */\newline      {\newline         D_GAIN_lag_concealment(&amp(st-&gtmem_gain[17]), st-&gtmem_lag, &ampT0,\newline            &amp(st-&gtmem_T0), &amp(st-&gtmem_seed3), unusable_frame);\newline         T0_frac = 0;\newline      }\newline\newline      /*\newline       * Find the pitch gain, the interpolation filter\newline       * and the adaptive codebook vector.\newline       */\newline\newline      D_GAIN_adaptive_codebook_excitation(&ampexc[i_subfr], T0, T0_frac);\newline\newline      if(unusable_frame)\newline      {\newline         select = 1;\newline      }\newline      else\newline      {\newline         if(mode &lt= MODE_9k)\newline         {\newline            select = 0;\newline         }\newline         else\newline         {\newline            select = *prms++;\newline         }\newline      }\newline\newline      if(select == 0)\newline      {\newline         /* find pitch excitation with lp filter */\newline         for(i = 0; i &lt L_SUBFR; i++)\newline         {\newline            L_tmp = 2949 * exc[i - 1 + i_subfr];\newline            L_tmp = L_tmp + (10486 * exc[i + i_subfr]);\newline            L_tmp = L_tmp + (2949 * exc[i + 1 + i_subfr]);\newline            code[i] = (Word16)((L_tmp + 0x2000) &gt&gt 14);\newline         }\newline\newline         memcpy(&ampexc[i_subfr], code, L_SUBFR * sizeof(Word16));\newline      }\newline\newline      /*\newline       * Decode innovative codebook.\newline       * Add the fixed-gain pitch contribution to code[].\newline       */\newline\newline      if(unusable_frame != 0)\newline      {\newline         /* the innovative code doesn&#039t need to be scaled (see Q_gain2) */\newline         for(i = 0; i &lt L_SUBFR; i++)\newline         {\newline            code[i] = (Word16)(D_UTIL_random(&amp(st-&gtmem_seed)) &gt&gt 3);\newline         }\newline      }\newline      else if(mode &lt= MODE_7k)\newline      {\newline         ind[0] = *prms++;\newline         D_ACELP_decode_2t(ind[0], code);\newline      }\newline      else if(mode &lt= MODE_9k)\newline      {\newline         memcpy(ind, prms, 4 * sizeof(Word16));\newline         prms += 4;\newline         D_ACELP_decode_4t(ind, 20, code);\newline      }\newline      else if(mode &lt= MODE_12k)\newline      {\newline         memcpy(ind, prms, 4 * sizeof(Word16));\newline         prms += 4;\newline         D_ACELP_decode_4t(ind, 36, code);\newline      }\newline      else if(mode &lt= MODE_14k)\newline      {\newline         memcpy(ind, prms, 4 * sizeof(Word16));\newline         prms += 4;\newline         D_ACELP_decode_4t(ind, 44, code);\newline      }\newline      else if(mode &lt= MODE_16k)\newline      {\newline         memcpy(ind, prms, 4 * sizeof(Word16));\newline         prms += 4;\newline         D_ACELP_decode_4t(ind, 52, code);\newline      }\newline      else if(mode &lt= MODE_18k)\newline      {\newline         memcpy(ind, prms, 8 * sizeof(Word16));\newline         prms += 8;\newline         D_ACELP_decode_4t(ind, 64, code);\newline      }\newline      else if(mode &lt= MODE_20k)\newline      {\newline         memcpy(ind, prms, 8 * sizeof(Word16));\newline         prms += 8;\newline         D_ACELP_decode_4t(ind, 72, code);\newline      }\newline      else\newline      {\newline         memcpy(ind, prms, 8 * sizeof(Word16));\newline         prms += 8;\newline         D_ACELP_decode_4t(ind, 88, code);\newline      }\newline\newline      tmp = 0;\newline      D_UTIL_preemph(code, st-&gtmem_tilt_code, L_SUBFR, &amptmp);\newline\newline      L_tmp = T0;\newline\newline      if(T0_frac &gt 2)\newline      {\newline         L_tmp = L_tmp + 1;\newline      }\newline\newline      D_GAIN_pitch_sharpening(code, L_tmp, PIT_SHARP);\newline\newline      /*\newline       * Decode codebooks gains.\newline       */\newline      index = *prms++;   /* codebook gain index */\newline\newline      if(mode &lt= MODE_9k)\newline      {\newline         D_GAIN_decode(index, 6, code, &ampgain_pit, &ampL_gain_code, bfi,\newline            st-&gtmem_bfi, st-&gtmem_state, unusable_frame, st-&gtmem_vad_hist,\newline            st-&gtmem_gain);\newline      }\newline      else\newline      {\newline         D_GAIN_decode(index, 7, code, &ampgain_pit, &ampL_gain_code, bfi,\newline            st-&gtmem_bfi, st-&gtmem_state, unusable_frame, st-&gtmem_vad_hist,\newline            st-&gtmem_gain);\newline      }\newline\newline      /* find best scaling to perform on excitation (Q_new) */\newline      tmp = st-&gtmem_subfr_q[0];\newline\newline      for(i = 1; i &lt 4; i++)\newline      {\newline         if(st-&gtmem_subfr_q[i] &lt tmp)\newline         {\newline            tmp = st-&gtmem_subfr_q[i];\newline         }\newline      }\newline\newline      /* limit scaling (Q_new) to Q_MAX */\newline      if(tmp &gt Q_MAX)\newline      {\newline         tmp = Q_MAX;\newline      }\newline\newline      Q_new = 0;\newline      L_tmp = L_gain_code;   /* L_gain_code in Q16 */\newline\newline      while((L_tmp &lt 0x08000000L) &amp&amp (Q_new &lt tmp))\newline      {\newline         L_tmp = (L_tmp &lt&lt 1);\newline         Q_new = (Word16)((Q_new + 1));\newline      }\newline\newline      if(L_tmp &lt 0x7FFF7FFF)\newline      {\newline         gain_code = (Word16)((L_tmp + 0x8000) &gt&gt 16);\newline         /* scaled gain_code with Qnew */\newline      }\newline      else\newline      {\newline         gain_code = 32767;\newline      }\newline\newline      if(Q_new &gt st-&gtmem_q)\newline      {\newline         D_UTIL_signal_up_scale(exc + i_subfr - (PIT_MAX + L_INTERPOL),\newline            PIT_MAX + L_INTERPOL + L_SUBFR, (Word16)(Q_new - st-&gtmem_q));\newline      }\newline      else\newline      {\newline         D_UTIL_signal_down_scale(exc + i_subfr - (PIT_MAX + L_INTERPOL),\newline            PIT_MAX + L_INTERPOL + L_SUBFR, (Word16)(st-&gtmem_q - Q_new));\newline      }\newline\newline      st-&gtmem_q = Q_new;\newline\newline      /*\newline       * Update parameters for the next subframe.\newline       * - tilt of code: 0.0 (unvoiced) to 0.5 (voiced)\newline       */\newline      if(bfi == 0)\newline      {\newline         /* LTP-Lag history update */\newline         for(i = 4; i &gt 0; i--)\newline         {\newline            st-&gtmem_lag[i] = st-&gtmem_lag[i - 1];\newline         }\newline         st-&gtmem_lag[0] = (Word16)T0;\newline         st-&gtmem_T0 = (Word16)T0;\newline         st-&gtmem_T0_frac = 0;   /* Remove fraction in case of BFI */\newline      }\newline\newline      /* find voice factor in Q15 (1=voiced, -1=unvoiced) */\newline      memcpy(exc2, &ampexc[i_subfr], L_SUBFR * sizeof(Word16));\newline      D_UTIL_signal_down_scale(exc2, L_SUBFR, 3);\newline\newline      /* post processing of excitation elements */\newline      if(mode &lt= MODE_9k)\newline      {\newline         pit_sharp = (Word16)(gain_pit &lt&lt 1);\newline\newline         if(pit_sharp &gt 16384)\newline         {\newline            if(pit_sharp &gt 32767)\newline            {\newline               pit_sharp = 32767;\newline            }\newline\newline            for(i = 0; i &lt L_SUBFR; i++)\newline            {\newline               L_tmp = (exc2[i] * pit_sharp) &gt&gt 15;\newline               L_tmp = L_tmp * gain_pit;\newline               excp[i] = (Word16)((L_tmp + 0x8000) &gt&gt 16);\newline            }\newline         }\newline      }\newline\newline      voice_fac = D_GAIN_find_voice_factor(exc2, -3, gain_pit, code, gain_code,\newline         L_SUBFR);\newline\newline      /* tilt of code for next subframe: 0.5=voiced, 0=unvoiced */\newline      st-&gtmem_tilt_code = (Word16)((voice_fac &gt&gt 2) + 8192);\newline\newline      /*\newline       * Find the total excitation.\newline       * Find synthesis speech corresponding to exc[].\newline       * Find maximum value of excitation for next scaling\newline       */\newline      memcpy(exc2, &ampexc[i_subfr], L_SUBFR * sizeof(Word16));\newline      max = 1;\newline\newline      for(i = 0; i &lt L_SUBFR; i++)\newline      {\newline         L_tmp = (code[i] * gain_code) &lt&lt 5;\newline         L_tmp = L_tmp + (exc[i + i_subfr] * gain_pit);\newline         L_tmp = (L_tmp + 0x2000) &gt&gt 14;\newline\newline         if((L_tmp &gt MIN_16) &amp (L_tmp &lt 32768))\newline         {\newline            exc[i + i_subfr] = (Word16)L_tmp;\newline            tmp = (Word16)(abs(L_tmp));\newline\newline            if(tmp &gt max)\newline            {\newline               max = tmp;\newline            }\newline         }\newline         else if(L_tmp &gt MAX_16)\newline         {\newline            exc[i + i_subfr] = MAX_16;\newline            max = MAX_16;\newline         }\newline         else\newline         {\newline            exc[i + i_subfr] = MIN_16;\newline            max = MAX_16;\newline         }\newline      }\newline\newline      /* tmp = scaling possible according to max value of excitation */\newline      tmp = (Word16)((D_UTIL_norm_s(max) + Q_new) - 1);\newline      st-&gtmem_subfr_q[3] = st-&gtmem_subfr_q[2];\newline      st-&gtmem_subfr_q[2] = st-&gtmem_subfr_q[1];\newline      st-&gtmem_subfr_q[1] = st-&gtmem_subfr_q[0];\newline      st-&gtmem_subfr_q[0] = tmp;\newline\newline      /*\newline       * phase dispersion to enhance noise in low bit rate\newline       */\newline\newline      /* L_gain_code in Q16 */\newline      D_UTIL_l_extract(L_gain_code, &ampgain_code, &ampgain_code_lo);\newline\newline      if(mode &lt= MODE_7k)\newline      {\newline         j = 0;   /* high dispersion for rate &lt= 7.5 kbit/s */\newline      }\newline      else if(mode &lt= MODE_9k)\newline      {\newline         j = 1;   /* low dispersion for rate &lt= 9.6 kbit/s */\newline      }\newline      else\newline      {\newline         j = 2;   /* no dispersion for rate &gt 9.6 kbit/s */\newline      }\newline\newline      D_ACELP_phase_dispersion(gain_code, gain_pit, code, (Word16)j,\newline         st-&gtmem_ph_disp);\newline\newline      /*\newline       * noise enhancer\newline       * - Enhance excitation on noise. (modify gain of code)\newline       *   If signal is noisy and LPC filter is stable, move gain\newline       *   of code 1.5 dB toward gain of code threshold.\newline       *   This decrease by 3 dB noise energy variation.\newline       */\newline      L_tmp = 16384 - (voice_fac &gt&gt 1);   /* 1=unvoiced, 0=voiced */\newline      fac = (Word16)((L_stab_fac * L_tmp) &gt&gt 15);\newline      L_tmp = L_gain_code;\newline\newline      if(L_tmp &lt st-&gtmem_gc_thres)\newline      {\newline         L_tmp = (L_tmp + D_UTIL_mpy_32_16(gain_code, gain_code_lo, 6226));\newline\newline         if(L_tmp &gt st-&gtmem_gc_thres)\newline         {\newline            L_tmp = st-&gtmem_gc_thres;\newline         }\newline      }\newline      else\newline      {\newline         L_tmp = D_UTIL_mpy_32_16(gain_code, gain_code_lo, 27536);\newline\newline         if(L_tmp &lt st-&gtmem_gc_thres)\newline         {\newline            L_tmp = st-&gtmem_gc_thres;\newline         }\newline      }\newline      st-&gtmem_gc_thres = L_tmp;\newline      L_gain_code =\newline         D_UTIL_mpy_32_16(gain_code, gain_code_lo, (Word16)(32767 - fac));\newline      D_UTIL_l_extract(L_tmp, &ampgain_code, &ampgain_code_lo);\newline      L_gain_code =\newline         L_gain_code + D_UTIL_mpy_32_16(gain_code, gain_code_lo, fac);\newline\newline      /*\newline       * pitch enhancer\newline       * - Enhance excitation on voice. (HP filtering of code)\newline       *   On voiced signal, filtering of code by a smooth fir HP\newline       *   filter to decrease energy of code in low frequency.\newline       */\newline\newline      L_tmp2 = (voice_fac &gt&gt 3) + 4096;   /* 0.25=voiced, 0=unvoiced */\newline      L_tmp = (code[0] &lt&lt 15) - (code[1] * L_tmp2);\newline      code2[0] = (L_tmp + 0x4000) &gt&gt 15;\newline\newline      for(i = 1; i &lt L_SUBFR - 1; i++)\newline      {\newline         L_tmp = code[i] &lt&lt 15;\newline         L_tmp = L_tmp - (code[i + 1] * L_tmp2);\newline         L_tmp = L_tmp - (code[i - 1] * L_tmp2);\newline         code2[i] = (L_tmp + 0x4000) &gt&gt 15;\newline      }\newline\newline      L_tmp = code[L_SUBFR - 1] &lt&lt 15;\newline      L_tmp = L_tmp - (code[L_SUBFR - 2] * L_tmp2);\newline      code2[L_SUBFR - 1] = (L_tmp + 0x4000) &gt&gt 15;\newline\newline      /* build excitation */\newline      gain_code = (Word16)(((L_gain_code &lt&lt Q_new) + 0x8000) &gt&gt 16);\newline\newline      for(i = 0; i &lt L_SUBFR; i++)\newline      {\newline         L_tmp = (code2[i] * gain_code) &lt&lt 5;\newline         L_tmp = L_tmp + (exc2[i] * gain_pit);\newline         L_tmp = (L_tmp + 0x2000) &gt&gt 14;\newline\newline         exc2[i] = D_UTIL_saturate(L_tmp);\newline      }\newline\newline      if(mode &lt= MODE_9k)\newline      {\newline         if(pit_sharp &gt 16384)\newline         {\newline            for(i = 0; i &lt L_SUBFR; i++)\newline            {\newline               L_tmp = (excp[i] + exc2[i]);\newline               excp[i] = D_UTIL_saturate(L_tmp);\newline            }\newline\newline            D_GAIN_adaptive_control(exc2, excp, L_SUBFR);\newline            memcpy(exc2, excp, L_SUBFR * sizeof(Word16));\newline         }\newline      }\newline\newline      if(mode &lt= MODE_7k)\newline      {\newline         j = (i_subfr &gt&gt 6);\newline\newline         for(i = 0; i &lt M; i++)\newline         {\newline            L_tmp = isf_tmp[i] * (32767 - D_ROM_interpol_frac[j]);\newline            L_tmp = L_tmp + (isf[i] * D_ROM_interpol_frac[j]);\newline            HfIsf[i] = (Word16)((L_tmp + 0x4000) &gt&gt 15);\newline         }\newline      }\newline      else\newline      {\newline         memset(st-&gtmem_syn_hf, 0, (M16k - M) * sizeof(Word16));\newline      }\newline\newline      if(mode &gt= MODE_24k)\newline      {\newline         corr_gain = *prms++;\newline         D_UTIL_dec_synthesis(p_Aq, exc2, Q_new, &ampsynth16k[i_subfr * 5 / 4],\newline            corr_gain, HfIsf, mode, newDTXState, bfi, st);\newline      }\newline      else\newline      {\newline         D_UTIL_dec_synthesis(p_Aq, exc2, Q_new, &ampsynth16k[i_subfr * 5 / 4], 0,\newline            HfIsf, mode, newDTXState, bfi, st);\newline      }\newline\newline      p_Aq += (M + 1);   /* interpolated LPC parameters for next subframe */\newline   }\newline\newline   /*\newline    * Update signal for next frame\newline    * -&gt save past of exc[]\newline    * -&gt save pitch parameters.\newline    */\newline\newline   memmove(st-&gtmem_exc, &ampst-&gtmem_exc[L_FRAME], (PIT_MAX + L_INTERPOL) * sizeof(Word16));\newline   D_UTIL_signal_down_scale(exc, L_FRAME, Q_new);\newline   D_DTX_activity_update(st-&gtdtx_decSt, isf, exc);\newline   st-&gtdtx_decSt-&gtmem_dtx_global_state = (UWord8)newDTXState;\newline   st-&gtmem_bfi = bfi;\newline\newline   return(0);\newline}\newline",\newline Decoder_exe\newline \newline Parameters:\newline mode I: used mode\newline prms I: parameter vector\newline synth_out O: synthesis speech\newline spe_state B: state structure\newline frame_type I: received frame type\newline \newline Function:\newline Main decoder routine.\newline \newline Returns:\newline 0 if successful\newline \newline,3959234,platform.c,"ssize_t plat_read(int fd, void *buf, size_t count)\newline{\newline    ssize_t n = 0, r = 0;\newline\newline    while (r &lt count) {\newline        n = read(fd, buf + r, count - r);\newline        if (n == 0)\newline	        break;\newline        if (n &lt 0) {\newline	        if (errno == EINTR)\newline	            continue;\newline	        else\newline	            break;\newline        }\newline\newline        r += n;\newline   }\newline   return r;\newline}\newline",\newline automatically restart after a recoverable interruption\newline \newline,1315254,cfg.c,"void cfg_addaddress(struct cvsd_cfg *cfg,\newline                    const char *filename,int lnr,\newline                    const char *node,const char *service)\newline{\newline  struct cvsd_addrs *addr,*tmp;\newline  struct addrinfo hints;\newline  int i;\newline\newline  /* create space to store address */\newline  addr=(struct cvsd_addrs *)xmalloc(sizeof(struct cvsd_addrs));\newline  addr-&gtnode=xstrdup(node);\newline  addr-&gtservice=xstrdup(service);\newline  addr-&gtaddrs=NULL;\newline  addr-&gtnext=NULL;\newline\newline  /* some aliases for the unspecified address */\newline  if ((strcmp(node,&quot*&quot)==0)||(strcmp(node,&quot&quot)==0))\newline    node=NULL;\newline\newline  /* create the name for the socket */\newline  memset(&amphints,0,sizeof(struct addrinfo));\newline  hints.ai_flags=AI_PASSIVE;\newline#ifdef AI_ADDRCONFIG\newline  hints.ai_flags|=AI_ADDRCONFIG;\newline#endif\newline  hints.ai_family=PF_UNSPEC;\newline  hints.ai_socktype=SOCK_STREAM;\newline  switch (i=getaddrinfo(node,service,&amphints,&amp(addr-&gtaddrs)))\newline  {\newline    case 0: break;\newline    case EAI_SYSTEM:\newline      if (filename==NULL)\newline        log_log(LOG_ERR,&quotgetaddrinfo() failed: %s&quot,strerror(errno));\newline      else\newline        log_log(LOG_ERR,&quot%s:%d: getaddrinfo() failed: %s&quot,\newline                    filename,lnr,strerror(errno));\newline      exit(1);\newline    default:\newline      if (filename==NULL)\newline        log_log(LOG_ERR,&quotgetaddrinfo() failed: %s&quot,gai_strerror(i));\newline      else\newline        log_log(LOG_ERR,&quot%s:%d: getaddrinfo() failed: %s&quot,\newline                    filename,lnr,gai_strerror(i));\newline      exit(1);\newline  }\newline  if (addr-&gtaddrs==NULL)\newline  {\newline    log_log(LOG_ERR,&quot%s:%d: getaddrinfo() returned no usable addresses&quot,filename,lnr);\newline    exit(1);\newline  }\newline\newline  /* save the address */\newline  if (cfg-&gtaddresses==NULL)\newline    cfg-&gtaddresses=addr;\newline  else\newline  {\newline    for (tmp=cfg-&gtaddresses;tmp-&gtnext!=NULL;tmp=tmp-&gtnext);\newline    tmp-&gtnext=addr;\newline  }\newline}\newline",add the given node and service to the list of addresses that\newlinewill be listened on \newline,6235190,robot_proceso.c,"int main (int argc, char *argv[])\newline{\newline	int i;\newline	poptContext ctx=NULL;\newline\newline	dont_run_as_root();\newline\newline	bindtextdomain( PACKAGE, GNOMELOCALEDIR );\newline	textdomain( PACKAGE );\newline \newline	cliente.port = 1995;\newline	strncpy(cliente.server,&quot127.0.0.1&quot,sizeof(cliente.server)-1);\newline	cliente.with_nogui=0;\newline\newline	ctx = poptGetContext(NULL,argc,argv,options,0);\newline	if(ctx) {\newline		while( poptGetNextOpt(ctx) != -1);\newline		poptFreeContext(ctx);\newline	}\newline\newline	if( !cliente.with_nogui ) {\newline		gnome_init_with_popt_table(&quotgbnrobot&quot, ROBOTVER, argc, argv, options, 0, NULL);\newline		init_X();\newline	}\newline\newline	if( server_name ) {\newline		strncpy(cliente.server,server_name,sizeof(cliente.server)-1);\newline		cliente.server[sizeof(cliente.server)-1]=0;\newline	}\newline\newline	if( robot_init() &lt 0 ) exit(-1);\newline\newline	bnwrite( cliente.sock,BN_NUMJUG);\newline\newline	if(cliente.with_nogui)\newline		nogui_main();\newline	else\newline		gtk_main();\newline	return 0;\newline}\newline",\newline MAIN MAIN MAIN\newline \newline,4929910,cmd.c,"static void Cbuf_Execute_Deferred (void)\newline{\newline	static double oldrealtime = 0;\newline	cmddeferred_t *cmd, *prev;\newline	double eat;\newline	if (realtime - oldrealtime &lt 0 || realtime - oldrealtime &gt 1800) oldrealtime = realtime;\newline	eat = realtime - oldrealtime;\newline	if (eat &lt (1.0 / 120.0))\newline		return;\newline	oldrealtime = realtime;\newline	prev = NULL;\newline	cmd = cmd_deferred_list;\newline	while(cmd)\newline	{\newline		cmd-&gtdelay -= eat;\newline		if(cmd-&gtdelay &lt= 0)\newline		{\newline			Cbuf_AddText(cmd-&gtvalue);\newline			Cbuf_AddText(&quot;\\n&quot);\newline			Mem_Free(cmd-&gtvalue);\newline\newline			if(prev) {\newline				prev-&gtnext = cmd-&gtnext;\newline				Mem_Free(cmd);\newline				cmd = prev-&gtnext;\newline			} else {\newline				cmd_deferred_list = cmd-&gtnext;\newline				Mem_Free(cmd);\newline				cmd = cmd_deferred_list;\newline			}\newline			continue;\newline		}\newline		prev = cmd;\newline		cmd = cmd-&gtnext;\newline	}\newline}\newline",\newline============\newlineCbuf_Execute_Deferred --blub\newline============\newline \newline,528888,gnbind.c,"void gnome_init_nhwindows(int* argc, char** argv)\newline{\newline    int i;\newline    char *path;\newline\newline    /* Main window */\newline    ghack_init_main_window( *argc, argv);\newline    ghack_init_signals( );\newline\newline    for(i = 0; i &lt no_tilesets; i++)\newline	if (!strcmp(tileset, tilesets[i].name))\newline	    break;\newline    if ((tilesets[i].flags &amp ~TILESET_TRANSPARENT) != 0) {\newline	g_warning(&quotCan&#039t use tile set \\&quot%s\\&quot; unsupported flag set\\n&quot, tileset);\newline	i = no_tilesets;		/* Use a default tile set */\newline    }\newline    if (i == no_tilesets) {\newline	for(i = 0; i &lt no_tilesets; i++)\newline	    if ((tilesets[i].flags &amp ~TILESET_TRANSPARENT) == 0)\newline		break;\newline	if (i == no_tilesets)\newline	    g_error(&quotERROR: No valid tiles found\\n&quot);\newline    }\newline    path = (char *)alloc(strlen(TILESETDIR) + strlen(tilesets[i].file) + 2);\newline    sprintf(path, TILESETDIR &quot/%s&quot, tilesets[i].file);\newline    if (ghack_init_glyphs(path))\newline	g_error (&quotERROR:  Could not initialize glyphs.\\n&quot);\newline    free(path);\newline  \newline    // gnome/gtk is not reentrant\newline    set_option_mod_status(&quotignintr&quot, DISP_IN_GAME);\newline    flags.ignintr = TRUE;\newline\newline    iflags.window_inited = TRUE;\newline\newline    /* gnome-specific window creation */\newline    WIN_WORN = gnome_create_nhwindow(NHW_WORN);\newline}\newline","\newlineinit_nhwindows(int argcp, char argv)\newline-- Initialize the windows used by NetHack. This can also\newlinecreate the standard windows listed at the top, but does\newlinenot display them.\newline-- Any commandline arguments relevant to the windowport\newlineshould be interpreted, and argcp and argv should\newlinebe changed to remove those arguments.\newline-- When the message window is created, the variable\newlineiflags.window_inited needs to be set to TRUE. Otherwise\newlineall plines() will be done via raw_print().\newline Why not have init_nhwindows() create all of the &quotstandard&quot\newline windows? Or at least all but WIN_INFO? -dean\newline \newline",3572063,m16c60hardware.h,"inline __nesc_atomic_t __nesc_atomic_start(void) @spontaneous()\newline{\newline  __nesc_atomic_t result;\newline  // Save the flag register (FLG)\newline  asm volatile (&quotstc flg, %0&quot: &quot=r&quot(result): : &quot%flg&quot);\newline  // Disable interrupts\newline  __nesc_disable_interrupt();\newline  asm volatile(&quot&quot : : : &quotmemory&quot); // ensure atomic section effect visibility\newline  return result;\newline}\newline",\newline Start atomic section.\newline \newline,1626056,cfgfile.c,"const int *getJP2KBitLenYA (int width, int height)\newline{\newline	int imgcat;\newline\newline	imgcat = getImgSizeCategory (width, height);\newline\newline	return (JP2BitResYA + (2 * imgcat));\newline}\newline",return a pointer to a array[4] with the bit lenght for JP2K YA components \newline,5083966,test_server.c,"static apr_status_t replay(serv_ctx_t *servctx,\newline                           apr_int16_t rtnevents,\newline                           apr_pool_t *pool)\newline{\newline    apr_status_t status = APR_SUCCESS;\newline    test_server_action_t *action;\newline\newline    if (rtnevents &amp APR_POLLIN) {\newline        if (servctx-&gtmessage_list == NULL) {\newline            /* we&#039re not expecting any requests to reach this server! */\newline            serf__log(TEST_VERBOSE, __FILE__,\newline                      &quotReceived request where none was expected.\\n&quot);\newline\newline            return SERF_ERROR_ISSUE_IN_TESTSUITE;\newline        }\newline\newline        if (servctx-&gtcur_action &gt= servctx-&gtaction_count) {\newline            char buf[128];\newline            apr_size_t len = sizeof(buf);\newline\newline            status = servctx-&gtread(servctx, buf, &amplen);\newline            if (! APR_STATUS_IS_EAGAIN(status)) {\newline                /* we&#039re out of actions! */\newline                serf__log(TEST_VERBOSE, __FILE__,\newline                          &quotReceived more requests than expected.\\n&quot);\newline\newline                return SERF_ERROR_ISSUE_IN_TESTSUITE;\newline            }\newline            return status;\newline        }\newline\newline        action = &ampservctx-&gtaction_list[servctx-&gtcur_action];\newline\newline        serf__log(TEST_VERBOSE, __FILE__,\newline                  &quotPOLLIN while replaying action %d, kind: %d.\\n&quot,\newline                  servctx-&gtcur_action, action-&gtkind);\newline\newline        /* Read the remaining data from the client and kill the socket. */\newline        if (action-&gtkind == SERVER_IGNORE_AND_KILL_CONNECTION) {\newline            char buf[128];\newline            apr_size_t len = sizeof(buf);\newline\newline            status = servctx-&gtread(servctx, buf, &amplen);\newline\newline            if (status == APR_EOF) {\newline                serf__log(TEST_VERBOSE, __FILE__,\newline                          &quotKilling this connection.\\n&quot);\newline                apr_socket_close(servctx-&gtclient_sock);\newline                servctx-&gtclient_sock = NULL;\newline                next_action(servctx);\newline                return APR_SUCCESS;\newline            }\newline\newline            return status;\newline        }\newline        else if (action-&gtkind == SERVER_RECV ||\newline                 (action-&gtkind == SERVER_RESPOND &amp&amp\newline                  servctx-&gtoutstanding_responses == 0)) {\newline            apr_size_t msg_len, len;\newline            char buf[128];\newline            test_server_message_t *message;\newline\newline            message = &ampservctx-&gtmessage_list[servctx-&gtcur_message];\newline            msg_len = strlen(message-&gttext);\newline\newline            do\newline            {\newline                len = msg_len - servctx-&gtmessage_buf_pos;\newline                if (len &gt sizeof(buf))\newline                    len = sizeof(buf);\newline\newline                status = servctx-&gtread(servctx, buf, &amplen);\newline                if (SERF_BUCKET_READ_ERROR(status))\newline                    return status;\newline\newline                if (status == APR_EOF) {\newline                    serf__log(TEST_VERBOSE, __FILE__,\newline                              &quotServer: Client hung up the connection.\\n&quot);\newline                    break;\newline                }\newline                if (servctx-&gtoptions &amp TEST_SERVER_DUMP)\newline                    fwrite(buf, len, 1, stdout);\newline\newline                if (strncmp(buf,\newline                            message-&gttext + servctx-&gtmessage_buf_pos,\newline                            len) != 0) {\newline                    /* ## TODO: Better diagnostics. */\newline                    printf(&quotExpected: (\\n&quot);\newline                    fwrite(message-&gttext + servctx-&gtmessage_buf_pos, len, 1,\newline                           stdout);\newline                    printf(&quot)\\n&quot);\newline                    printf(&quotActual: (\\n&quot);\newline                    fwrite(buf, len, 1, stdout);\newline                    printf(&quot)\\n&quot);\newline\newline                    return SERF_ERROR_ISSUE_IN_TESTSUITE;\newline                }\newline\newline                servctx-&gtmessage_buf_pos += len;\newline\newline                if (servctx-&gtmessage_buf_pos &gt= msg_len) {\newline                    next_message(servctx);\newline                    servctx-&gtmessage_buf_pos -= msg_len;\newline                    if (action-&gtkind == SERVER_RESPOND)\newline                        servctx-&gtoutstanding_responses++;\newline                    if (action-&gtkind == SERVER_RECV)\newline                        next_action(servctx);\newline                    break;\newline                }\newline            } while (!status);\newline        }\newline        else if (action-&gtkind == PROXY_FORWARD) {\newline            apr_size_t len;\newline            char buf[BUFSIZE];\newline            serf_bucket_t *tmp;\newline\newline            /* Read all incoming data from the client to forward it to the\newline               server later. */\newline            do\newline            {\newline                len = BUFSIZE;\newline\newline                status = servctx-&gtread(servctx, buf, &amplen);\newline                if (SERF_BUCKET_READ_ERROR(status))\newline                    return status;\newline\newline                serf__log(TEST_VERBOSE, __FILE__,\newline                          &quotproxy: reading %d bytes %.*s from client with &quot\newline                          &quotstatus %d.\\n&quot,\newline                          len, len, buf, status);\newline\newline                if (status == APR_EOF) {\newline                    serf__log(TEST_VERBOSE, __FILE__,\newline                              &quotProxy: client hung up the connection. Reset the &quot\newline                              &quotconnection to the server.\\n&quot);\newline                    /* We have to stop forwarding, if a new connection opens\newline                       the CONNECT request should not be forwarded to the\newline                       server. */\newline                    next_action(servctx);\newline                }\newline                if (!servctx-&gtservstream)\newline                    servctx-&gtservstream = serf__bucket_stream_create(\newline                                              servctx-&gtallocator,\newline                                              detect_eof,servctx);\newline                if (len) {\newline                    tmp = serf_bucket_simple_copy_create(buf, len,\newline                                                         servctx-&gtallocator);\newline                    serf_bucket_aggregate_append(servctx-&gtservstream, tmp);\newline                }\newline            } while (!status);\newline        }\newline    }\newline    if (rtnevents &amp APR_POLLOUT) {\newline        action = &ampservctx-&gtaction_list[servctx-&gtcur_action];\newline\newline        serf__log(TEST_VERBOSE, __FILE__,\newline                  &quotPOLLOUT when replaying action %d, kind: %d.\\n&quot, servctx-&gtcur_action,\newline                  action-&gtkind);\newline\newline        if (action-&gtkind == SERVER_RESPOND &amp&amp servctx-&gtoutstanding_responses) {\newline            apr_size_t msg_len;\newline            apr_size_t len;\newline\newline            msg_len = strlen(action-&gttext);\newline            len = msg_len - servctx-&gtaction_buf_pos;\newline\newline            status = servctx-&gtsend(servctx,\newline                                   action-&gttext + servctx-&gtaction_buf_pos,\newline                                   &amplen);\newline            if (status != APR_SUCCESS)\newline                return status;\newline\newline            if (servctx-&gtoptions &amp TEST_SERVER_DUMP)\newline                fwrite(action-&gttext + servctx-&gtaction_buf_pos, len, 1, stdout);\newline\newline            servctx-&gtaction_buf_pos += len;\newline\newline            if (servctx-&gtaction_buf_pos &gt= msg_len) {\newline                next_action(servctx);\newline                servctx-&gtoutstanding_responses--;\newline            }\newline        }\newline        else if (action-&gtkind == SERVER_KILL_CONNECTION ||\newline                 action-&gtkind == SERVER_IGNORE_AND_KILL_CONNECTION) {\newline            serf__log(TEST_VERBOSE, __FILE__,\newline                      &quotKilling this connection.\\n&quot);\newline            apr_socket_close(servctx-&gtclient_sock);\newline            servctx-&gtclient_sock = NULL;\newline            next_action(servctx);\newline        }\newline        else if (action-&gtkind == PROXY_FORWARD) {\newline            apr_size_t len;\newline            char *buf;\newline\newline            if (!servctx-&gtproxy_client_sock) {\newline                serf__log(TEST_VERBOSE, __FILE__, &quotProxy: setting up connection &quot\newline                          &quotto server.\\n&quot);\newline                status = create_client_socket(&ampservctx-&gtproxy_client_sock,\newline                                              servctx, action-&gttext);\newline                if (!servctx-&gtclientstream)\newline                    servctx-&gtclientstream = serf__bucket_stream_create(\newline                                                servctx-&gtallocator,\newline                                                detect_eof,servctx);\newline            }\newline\newline            /* Send all data received from the server to the client. */\newline            do\newline            {\newline                apr_size_t readlen;\newline\newline                readlen = BUFSIZE;\newline\newline                status = serf_bucket_read(servctx-&gtclientstream, readlen,\newline                                          &ampbuf, &ampreadlen);\newline                if (SERF_BUCKET_READ_ERROR(status))\newline                    return status;\newline                if (!readlen)\newline                    break;\newline\newline                len = readlen;\newline\newline                serf__log(TEST_VERBOSE, __FILE__,\newline                          &quotproxy: sending %d bytes to client.\\n&quot, len);\newline                status = servctx-&gtsend(servctx, buf, &amplen);\newline                if (status != APR_SUCCESS) {\newline                    return status;\newline                }\newline                \newline                if (len != readlen) /* abort for now, return buf to aggregate\newline                                       if not everything could be sent. */\newline                    return APR_EGENERAL;\newline            } while (!status);\newline        }\newline    }\newline    else if (rtnevents &amp APR_POLLIN) {\newline        /* ignore */\newline    }\newline    else {\newline        printf(&quotUnknown rtnevents: %d\\n&quot, rtnevents);\newline        abort();\newline    }\newline\newline    return status;\newline}\newline","Verify received requests and take the necessary actions\newline(return a response, kill the connection ...) \newline",2161434,message.c,"static int message_read_address(struct protstream *strm, struct address **addrp)\newline{\newline    int c;\newline\newline    if ((c = prot_getc(strm)) == &#039(&#039) {\newline	/* parse list */\newline	struct address *addr;\newline	struct buf buf;\newline	unsigned nameoff = 0, rtoff = 0, mboxoff = 0, domoff = 0;\newline\newline	do {\newline	    *addrp = addr = (struct address *) xzmalloc(sizeof(struct address));\newline	    buf_init(&ampbuf);\newline\newline	    /* opening &#039(&#039 */\newline	    c = prot_getc(strm);\newline\newline	    /* name */\newline	    c = message_read_addrpart(strm, &ampaddr-&gtname, &ampnameoff, &ampbuf);\newline\newline	    /* route */\newline	    c = message_read_addrpart(strm, &ampaddr-&gtroute, &amprtoff, &ampbuf);\newline\newline	    /* mailbox */\newline	    c = message_read_addrpart(strm, &ampaddr-&gtmailbox, &ampmboxoff, &ampbuf);\newline\newline	    /* host */\newline	    c = message_read_addrpart(strm, &ampaddr-&gtdomain, &ampdomoff, &ampbuf);\newline\newline	    /* addr parts must now point into our freeme string */\newline	    if (buf.len) {\newline		char *freeme = addr-&gtfreeme = buf.s;\newline\newline		if (addr-&gtname) addr-&gtname = freeme+nameoff;\newline		if (addr-&gtroute) addr-&gtroute = freeme+rtoff;\newline		if (addr-&gtmailbox) addr-&gtmailbox = freeme+mboxoff;\newline		if (addr-&gtdomain) addr-&gtdomain = freeme+domoff;\newline	    }\newline\newline	    /* get ready to append the next address */\newline	    addrp = &ampaddr-&gtnext;\newline\newline	} while (((c = prot_getc(strm)) == &#039(&#039) &amp&amp prot_ungetc(c, strm));\newline\newline	if (c == &#039)&#039) c = prot_getc(strm);\newline    }\newline    else {\newline	/* NIL */\newline	prot_ungetc(c, strm);\newline	c = message_read_nstring(strm, NULL, 0);\newline    }\newline\newline    return c;\newline}\newline",\newline Read an address list from cached bodystructure.\newline Analog to mesage_write_address()\newline \newline,2214926,minutia.c,"int adjust_horizontal_rescan(const int nbr_dir, int *rescan_x, int *rescan_y,\newline            int *rescan_w, int *rescan_h, const int scan_x, const int scan_y,\newline            const int scan_w, const int scan_h, const int blocksize)\newline{\newline   int half_blocksize, qtr_blocksize;\newline\newline   /* Compute half of blocksize. */\newline   half_blocksize = blocksize&gt&gt1;\newline   /* Compute quarter of blocksize. */\newline   qtr_blocksize = blocksize&gt&gt2;\newline\newline   /* Neighbor will either be NORTH, SOUTH, EAST, OR WEST. */\newline   switch(nbr_dir){\newline      case NORTH:\newline         /*\newline               *************************\newline               *     RESCAN NORTH      *\newline               *        AREA           *\newline               *************************\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               -------------------------\newline         */\newline         /* Rescan origin stays the same. */\newline         *rescan_x = scan_x;\newline         *rescan_y = scan_y;\newline         /* Rescan width stays the same. */\newline         *rescan_w = scan_w;\newline         /* Rescan height is reduced to &quotqtr_blocksize&quot */\newline         /* if scan_h is larger.                         */\newline         *rescan_h = min(qtr_blocksize, scan_h);\newline         break;\newline      case EAST:\newline         /*\newline               ------------*************\newline               |           *           *\newline               |           *           *\newline               |           *    E R    *\newline               |           *    A E    *\newline               |           *    S S    *\newline               |           *    T C    *\newline               |           *      A    *\newline               |           *      N    *\newline               |           *           *\newline               |           *           *\newline               ------------*************\newline         */\newline         /* Rescan x-orign is set to half_blocksize from right edge of */\newline         /* block if scan width is larger.                            */\newline         *rescan_x = max(scan_x+scan_w-half_blocksize, scan_x);\newline         /* Rescan y-origin stays the same. */\newline         *rescan_y = scan_y;\newline         /* Rescan width is reduced to &quothalf_blocksize&quot */\newline         /* if scan width is larger.                   */\newline         *rescan_w = min(half_blocksize, scan_w);\newline         /* Rescan height stays the same. */\newline         *rescan_h = scan_h;\newline         break;\newline      case SOUTH:\newline         /*\newline               -------------------------\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               |                       |\newline               *************************\newline               *     RESCAN SOUTH      *\newline               *        AREA           *\newline               *************************\newline         */\newline         /* Rescan x-origin stays the same. */\newline         *rescan_x = scan_x;\newline         /* Rescan y-orign is set to qtr_blocksize from bottom edge of */\newline         /* block if scan height is larger.                             */\newline         *rescan_y = max(scan_y+scan_h-qtr_blocksize, scan_y);\newline         /* Rescan width stays the same. */\newline         *rescan_w = scan_w;\newline         /* Rescan height is reduced to &quotqtr_blocksize&quot */\newline         /* if scan height is larger.                    */\newline         *rescan_h = min(qtr_blocksize, scan_h);\newline         break;\newline      case WEST:\newline         /*\newline               *************------------\newline               *           *           |\newline               *           *           |\newline               *    W R    *           |\newline               *    E E    *           |\newline               *    S S    *           |\newline               *    T C    *           |\newline               *      A    *           |\newline               *      N    *           |\newline               *           *           |\newline               *           *           |\newline               *************------------\newline         */\newline         /* Rescan origin stays the same. */\newline         *rescan_x = scan_x;\newline         *rescan_y = scan_y;\newline         /* Rescan width is reduced to &quothalf_blocksize&quot */\newline         /* if scan width is larger.                   */\newline         *rescan_w = min(half_blocksize, scan_w);\newline         /* Rescan height stays the same. */\newline         *rescan_h = scan_h;\newline         break;\newline      default:\newline         fprintf(stderr,\newline         &quotERROR : adjust_horizontal_rescan : illegal neighbor direction\\n&quot);\newline          return(-210);\newline   }\newline\newline   /* Return normally. */\newline   return(0);\newline}\newline","\newline \newline#cat: adjust_horizontal_rescan - Determines the portion of an image block to\newline#cat: be rescanned horizontally based on a specified neighbor.\newlineInput:\newlinenbr_dir - specifies which block neighbor {NORTH, SOUTH, EAST, WEST}\newlinescan_x - x-pixel coord of origin of image region\newlinescan_y - y-pixel coord of origin of image region\newlinescan_w - width (in pixels) of image region\newlinescan_h - height (in pixels) of image region\newlineblocksize - dimension of image blocks (in pixels)\newlineOutput:\newlinerescan_x - x-pixel coord of origin of region to be rescanned\newlinerescan_y - y-pixel coord of origin of region to be rescanned\newlinerescan_w - width (in pixels) of region to be rescanned\newlinerescan_h - height (in pixels) of region to be rescanned\newlineReturn Code:\newlineZero - successful completion\newlineNegative - system error\newline \newline",6629329,ibv.c,"void SendData(ArgStruct *p)\newline{\newline  int                ret;       /* Return code */\newline  struct ibv_send_wr sr;        /* Send request */\newline  struct ibv_send_wr *bad_wr;	/* Handle to any incomplete wr returned by ibv*/\newline  struct ibv_sge     sg_entry;  /* Scatter/Gather list - holds buff addr */\newline\newline  /* Fill in send request struct */\newline    /* Set the send request&#039s opcode based on run-time options */\newline  if(p-&gtprot.commtype == NP_COMM_SENDRECV) {\newline     sr.opcode = IBV_WR_SEND;\newline     LOGPRINTF((&quotDoing regular send&quot));\newline  } else if(p-&gtprot.commtype == NP_COMM_SENDRECV_WITH_IMM) {\newline     sr.opcode = IBV_WR_SEND_WITH_IMM;\newline     LOGPRINTF((&quotDoing regular send with imm&quot));\newline  } else if(p-&gtprot.commtype == NP_COMM_RDMAWRITE) {\newline     sr.opcode = IBV_WR_RDMA_WRITE;	/* if RDMA, need to give more info */\newline     sr.wr.rdma.remote_addr = (uintptr_t)(((char *)remote_address) + (p-&gts_ptr - p-&gts_buff));\newline     sr.wr.rdma.rkey = remote_key;\newline     LOGPRINTF((&quotDoing RDMA write (raddr=%p)&quot, sr.wr.rdma.remote_addr));\newline  } else if(p-&gtprot.commtype == NP_COMM_RDMAWRITE_WITH_IMM) {\newline     sr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;	/* more info if RDMA */\newline     sr.wr.rdma.remote_addr = (uintptr_t)(((char *)remote_address) + (p-&gts_ptr - p-&gts_buff));\newline     sr.wr.rdma.rkey = remote_key;\newline     LOGPRINTF((&quotDoing RDMA write with imm (raddr=%p)&quot, sr.wr.rdma.remote_addr));\newline  } else {\newline     fprintf(stderr, &quotError, invalid communication type in SendData\\n&quot);\newline     exit(-1);\newline  }\newline  \newline  sr.send_flags = 0;	/* This needed due to a bug in Mellanox HW rel a-0 */\newline\newline  sr.num_sge = 1;		    /* # entries in this request */\newline  sr.sg_list = &ampsg_entry;	    /* the list of other requests */\newline  sr.next = NULL;		    /* the next request in the list */\newline\newline  sg_entry.lkey = s_mr_hndl-&gtlkey;  /* Local memory region key */\newline  sg_entry.length = p-&gtbufflen;	   /* buffer&#039s size */\newline  sg_entry.addr = (uintptr_t)p-&gts_ptr;	/* buffer&#039s location */\newline\newline\newline  \newline  /* Post the send request to the (send)command queue */\newline\newline  /* ibv_post_send(...) is handled in same fashion ibv_post_recv(..) */\newline  ret = ibv_post_send(qp_hndl, &ampsr, &ampbad_wr);\newline  if(ret) {\newline    fprintf(stderr, &quotError posting send request\\n&quot);\newline  } else {\newline    LOGPRINTF((&quotPosted send request&quot));\newline  }\newline\newline}\newline",SendData == Post a &#039send&#039 request to the (send)command queue \newline,3630056,arg_check.c,"char	*_dmalloc_strchr(const char *file, const int line,\newline			 const char *str, const int ch)\newline{\newline  if (BIT_IS_SET(_dmalloc_flags, DEBUG_CHECK_FUNCS)) {\newline    if (! dmalloc_verify_pnt(file, line, &quotstrchr&quot, str,\newline			     0 /* not exact */, -1)) {\newline      dmalloc_message(&quotbad pointer argument found in strchr&quot);\newline    }\newline  }\newline  return (char *)strchr(str, ch);\newline}\newline",\newline Dummy function for checking strchr&#039s arguments.\newline \newline,3893807,wmcalc.c,"int flush_expose(Window w) {\newline  XEvent      dummy;\newline  int         i=0;\newline\newline  while (XCheckTypedWindowEvent(display, w, Expose, &ampdummy)) i++;\newline  return(i);\newline} /***** End of function flush_expose() *************************/\newline",\newline Function: flush_expose\newline \newlineDescription:\newlineThis function is a hold-over from previous programs (wmcp).\newlineThe use of this function is not well understood.\newlineChange History:\newlineDate Modification\newline11/1/00 Function header updated.\newline \newline,1320514,playlist.c,"void mpc_cb_playlist_row (GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *col, gpointer user_data) {\newline	GtkTreeIter   iter;\newline	gint id;\newline	gchar * command;\newline\newline	if (gtk_tree_model_get_iter(GTK_TREE_MODEL(mpc_playlist_store), &ampiter, path)) {\newline		gtk_tree_model_get(GTK_TREE_MODEL(mpc_playlist_store), &ampiter\newline				, MPC_PLAYLIST_COLUMN_ID, &ampid\newline				, -1);\newline		command = g_strdup_printf(&quotplayid %d\\n&quot, id);\newline		mpc_mpd_do(command);\newline		g_free(command);\newline	}\newline}\newline",\newline Called when the user double-clicks/hits enter on a playlist row\newline \newline,5568734,kgamepropertyhandler.cpp,void KGamePropertyHandler::lockDirectEmit()\newline{\newline  d-&gtmIndirectEmit++;\newline}\newline,Fire all property signal changed which are collected in\newline the queque\newline \newline,,on,,,,,,,,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,"Writes an integer at 'p',",{},Initialize the windows used by NetHack.,Start atomic section.,return a pointer to a array[4],Verify received requests and take the necessary actions,Read an address list from cached bodystructure.,successful completion,Post a 'send' request to the (send)command queue,Dummy function for checking strchr's arguments.,This function is a hold-over from previous programs,This method gets called from the outside.,Called when the user double-clicks/hits enter on a playlist row,Fire all property signal changed,get the element node with the ID attribute id,Load an image from the named file.,emulates reset of a form,Main decoder routine.,automatically restart after a recoverable interruption,add the given node,{},x,
39N6W9XWRDN1XPBSA8Q33J8LSSOGYV,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:46 PDT 2019,1,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 12:44:46 PDT 2019,,,32Z9ZLUT1LK5QRZUET4OBBI9BDJOHS,AITP2LUW8GPB,Submitted,Fri Apr 26 12:47:35 PDT 2019,Fri Apr 26 12:54:17 PDT 2019,Sun Apr 28 12:54:17 PDT 2019,,,,402,100% (62/62),100% (62/62),0% (0/0),6606424,request.c,"int send_recv_dhcp(int sock_send,\newline		int sock_recv,\newline		struct dhcp_packet* dhcp,\newline		size_t dhcplen,\newline		const struct sockaddr_ll* dstaddr,\newline		const unsigned char* dstmac,\newline		struct dhcp_lease* lease,\newline		long timeout)\newline{\newline	unsigned char buffer[1024];\newline	size_t bufflen;\newline	int sent_bytes;\newline\newline	assert(sock_send != -1);\newline	assert(sock_recv != -1);\newline	assert(dhcp);\newline	assert(dstaddr);\newline	assert(lease);\newline\newline	bufflen = init_udp_packet(buffer,\newline			sizeof(buffer),\newline			dhcp,\newline			dhcplen,\newline			ifmac,\newline			0,\newline			htons(68),\newline			dstmac ? dstmac : brd_mac,\newline			0xffffffff,\newline			htons(67));\newline\newline	if (bufflen == -1) {\newline		log_err(&quotcan not initialize packet to send&quot);\newline		return -1;\newline	}\newline\newline	sent_bytes = sendto(sock_send, buffer, bufflen, 0,\newline			(struct sockaddr*) dstaddr,\newline			sizeof(struct sockaddr_ll));\newline	if (sent_bytes &lt= 0) {\newline		log_err(&quotcan not send DHCP packet: %s\\n&quot, strerror(errno));\newline		return -1;\newline	}\newline\newline	if (0 == read_dhcp_from_socket(sock_recv, lease-&gtxid, dhcp, timeout))\newline		return 0;\newline	else\newline		return 1;\newline}\newline","\newline Send DHCP packet (broadcast) and receive response for it. Return 0 if\newline successul, &gt 0 if can not receive response, &lt 0 if another error occurred.\newline \newline",4463733,mq_open.c,"mqd_t mq_open(const char *name, int oflag, ...)\newline{\newline	mode_t mode;\newline	struct mq_attr *attr;\newline\newline	if (name[0] != &#039/&#039) {\newline		__set_errno(EINVAL);\newline		return -1;\newline	}\newline\newline	mode = 0;\newline	attr = NULL;\newline\newline	if (oflag &amp O_CREAT) {\newline		va_list ap;\newline\newline		va_start(ap, oflag);\newline		mode = va_arg(ap, mode_t);\newline		attr = va_arg(ap, struct mq_attr *);\newline\newline		va_end(ap);\newline	}\newline\newline	return __syscall_mq_open(name + 1, oflag, mode, attr);\newline}\newline","\newline Establish connection between a process and a message queue and\newline return message queue descriptor or (mqd_t) -1 on error.\newline oflag determines the type of access used. If O_CREAT is on oflag, the\newline third argument is taken as a `mode_t&#039, the mode of the created\newline message queue, and the fourth argument is taken as `struct mq_attr &#039,\newline pointer to message queue attributes.\newline If the fourth argument is NULL, default attributes are used.\newline \newline",286496,viewer-stream.c,bool viewer_stream_get(struct relay_viewer_stream *vstream)\newline{\newline	bool has_ref = false;\newline\newline	pthread_mutex_lock(&ampvstream-&gtreflock);\newline	if (vstream-&gtref.refcount != 0) {\newline		has_ref = true;\newline		urcu_ref_get(&ampvstream-&gtref);\newline	}\newline	pthread_mutex_unlock(&ampvstream-&gtreflock);\newline\newline	return has_ref;\newline}\newline,Must be called with RCU read-side lock held. \newline,6416797,functions.c,"static gboolean ___lambda36_ (gconstpointer a, gconstpointer b) {\newline	gboolean result = FALSE;\newline	gconstpointer _tmp0_ = NULL;\newline	gconstpointer _tmp1_ = NULL;\newline	_tmp0_ = a;\newline	_tmp1_ = b;\newline	if (_tmp0_ == _tmp1_) {\newline		result = TRUE;\newline		return result;\newline	} else {\newline		gboolean _tmp2_ = FALSE;\newline		gconstpointer _tmp3_ = NULL;\newline		_tmp3_ = a;\newline		if (_tmp3_ == NULL) {\newline			_tmp2_ = TRUE;\newline		} else {\newline			gconstpointer _tmp4_ = NULL;\newline			_tmp4_ = b;\newline			_tmp2_ = _tmp4_ == NULL;\newline		}\newline		if (_tmp2_) {\newline			result = FALSE;\newline			return result;\newline		} else {\newline			GEqualFunc _tmp5_ = NULL;\newline			gconstpointer _tmp6_ = NULL;\newline			gconstpointer _tmp7_ = NULL;\newline			gboolean _tmp8_ = FALSE;\newline			_tmp5_ = g_str_equal;\newline			_tmp6_ = a;\newline			_tmp7_ = b;\newline			_tmp8_ = _tmp5_ ((const gchar*) _tmp6_, (const gchar*) _tmp7_);\newline			result = _tmp8_;\newline			return result;\newline		}\newline	}\newline}\newline",\newline Get a equality testing function for a given type.\newline \newline @param t the type which to get an equality testing function for.\newline \newline @return the equality testing function corresponding to the given type.\newline \newline,5898175,kmclipm_vector.c,"cpl_error_code kmclipm_vector_set(kmclipm_vector *kv, int pos, double val)\newline{\newline    cpl_error_code  err    = CPL_ERROR_NONE;\newline\newline    KMCLIPM_TRY\newline    {\newline        KMCLIPM_TRY_CHECK_AUTOMSG(kv != NULL,\newline                                  CPL_ERROR_NULL_INPUT);\newline\newline        KMCLIPM_TRY_CHECK_AUTOMSG((pos &gt= 0) &amp&amp\newline                                  (pos &lt cpl_vector_get_size(kv-&gtdata)),\newline                                  CPL_ERROR_ACCESS_OUT_OF_RANGE);\newline\newline        cpl_vector_set(kv-&gtdata, pos, val);\newline        if (kmclipm_is_nan_or_inf(val)) {\newline            cpl_vector_set(kv-&gtmask, pos, 0.);\newline        } else {\newline            cpl_vector_set(kv-&gtmask, pos, 1.);\newline        }\newline    }\newline    KMCLIPM_CATCH\newline    {\newline        err = cpl_error_get_code();\newline    }\newline\newline    return err;\newline}\newline",\newline@brief\newlineSet an element of the kmclipm_vector.\newline@param kv Input kmclipm_vector\newline@param pos The index of the element (0 to nelem-1)\newline@param val The value to set in the vector\newline@return A newly allocated kmclipm_vector or NULL in case of an error\newlineIf the value is Nan or Inf the element is marked as rejected.\newlinePossible cpl_error_code set in this function:\newline@li CPL_ERROR_NULL_INPUT if @c kv is NULL\newline@li CPL_ERROR_ACCESS_OUT_OF_RANGE if the specified position is out of the\newlinevector\newline \newline,4928192,utf8lib.c,"int u8_charidx(const char *_s, size_t i, size_t *len)\newline{\newline	size_t st, ln;\newline	size_t ofs = 0;\newline	size_t pofs = 0;\newline	int idx = 0;\newline	const unsigned char *s = (const unsigned char*)_s;\newline\newline	if (!utf8_enable.integer)\newline	{\newline		if (len) *len = 0;\newline		return (int)i;\newline	}\newline\newline	while (ofs &lt i &amp&amp s[ofs])\newline	{\newline		// ascii character, skip u8_analyze\newline		if (s[ofs] &lt 0x80)\newline		{\newline			pofs = ofs;\newline			++idx;\newline			++ofs;\newline			continue;\newline		}\newline\newline		// invalid, skip u8_analyze\newline		if (s[ofs] &lt 0xC2)\newline		{\newline			++ofs;\newline			continue;\newline		}\newline\newline		if (!u8_analyze((const char*)s+ofs, &ampst, &ampln, NULL, U8_ANALYZE_INFINITY))\newline			return -1;\newline		// see if next char is after the bytemark\newline		if (ofs + st &gt i)\newline		{\newline			if (len)\newline				*len = i - pofs;\newline			return idx;\newline		}\newline		++idx;\newline		pofs = ofs + st;\newline		ofs += st + ln;\newline		// see if bytemark is within the char\newline		if (ofs &gt i)\newline		{\newline			if (len)\newline				*len = i - pofs;\newline			return idx;\newline		}\newline	}\newline	if (len) *len = 0;\newline	return idx;\newline}\newline","Get the char-index for a byte-index.\newline @param _s An utf-8 encoded string.\newline @param i The byte offset for which you want the character index.\newline @param len If not null, the offset within the character is stored here.\newline @return The character-index, or -1 if the string is too short.\newline \newline",2268740,sf_gencode.c,"static void init_regs()\newline{\newline    curreg = 0;\newline    memset(regused, 0, sizeof regused);\newline}\newline",\newline Initialize the table of used registers and the current register.\newline \newline,2059772,fluid_synth.c,"int\newlinefluid_synth_all_notes_off(fluid_synth_t* synth, int chan)\newline{\newline  int result;\newline\newline  fluid_return_val_if_fail (synth != NULL, FLUID_FAILED);\newline  fluid_return_val_if_fail (chan &gt= -1, FLUID_FAILED);\newline  fluid_synth_api_enter(synth);\newline  if (chan &gt= synth-&gtmidi_channels) \newline    result = FLUID_FAILED;\newline  else\newline    result = fluid_synth_all_notes_off_LOCAL (synth, chan);\newline  FLUID_API_RETURN(result);\newline}\newline","\newline Turn off all notes on a MIDI channel (put them into release phase).\newline @param synth FluidSynth instance\newline @param chan MIDI channel number (0 to MIDI channel count - 1), (chan=-1 selects all channels)\newline @return FLUID_OK on success, FLUID_FAILED otherwise\newline @since 1.1.4\newline \newline",808266,scsidev.c,"int procscsi_readrecord (FILE* f)\newline{\newline	int c; char *ptr;\newline	fourlnbuf[0][0] = 0; fourlnbuf[1][0] = 0;\newline	fourlnbuf[2][0] = 0; fourlnbuf[3][0] = 0;\newline	do {\newline		ptr = fgets (fourlnbuf[0], 128, f);\newline		if (!ptr || feof (f))\newline			return -1;\newline	} while (memcmp (fourlnbuf[0], &quotHost:&quot, 5));\newline	ptr = fgets (fourlnbuf[1], 128, f);\newline	ptr = fgets (fourlnbuf[2], 128, f);\newline	/* Test for extensions ... */\newline	c = fgetc (f);\newline	if (c != EOF) {\newline		ungetc (c, f);\newline		if (c != &#039H&#039) {\newline			ptr = fgets (fourlnbuf[3], 128, f);\newline			c = fgetc (f);\newline			if (c != EOF) \newline				ungetc (c, f);\newline		}\newline	}\newline#ifdef DEBUG\newline	printf (&quotprocscsi_readrecord:\\n&quot);\newline	printf (&quot%s&quot, fourlnbuf[0]); printf (&quot%s&quot, fourlnbuf[1]);\newline	printf (&quot%s&quot, fourlnbuf[2]); printf (&quot%s&quot, fourlnbuf[3]);\newline	printf (&quot%i\\n&quot, fourlnbuf[3][0]);\newline#endif\newline	return 0;\newline}\newline",Fill fourlnbuf with the next record from /proc/scsi/scsi \newline,2461995,config.cpp,"void Config::setSaveTransientSettings(bool value) {\newline    return setValue(&quot/qmpdlcient/saveTransient&quot, value);\newline}\newline",\newline Window and splitter sizes\newline \newline,341393,quotient.c, void reset_rot_order()\newline {\newline   if (lookup_global(ROTORDER_NAME) &gt= 0)\newline   new_rot_order();\newline } // end reset_rot_order()\newline,"called by recalc() even if not using symmetry, hence don&#039t set user var \newline",577246,c_util.h,static inline void *deconst(const void *in)\newline{\newline  union { const void *in; void *out; } tmp;\newline\newline  tmp.in = in;\newline\newline  return tmp.out;\newline}\newline,"\newline ragel enforces fpc as a const, and merely casting can make picky\newline compilers unhappy, so we have this little helper do our dirty work\newline \newline",760242,ares_llist.c,void ares__remove_from_list(struct list_node* node) {\newline  if (node-&gtnext != NULL) {\newline    node-&gtprev-&gtnext = node-&gtnext;\newline    node-&gtnext-&gtprev = node-&gtprev;\newline    node-&gtprev = NULL;\newline    node-&gtnext = NULL;\newline  }\newline}\newline,"Removes the node from the list it&#039s in, if any \newline",5979868,gtm_relqueopi.c,"int gtm_insqhi(que_ent_ptr_t new, que_head_ptr_t base)\newline{\newline	int4	status;\newline\newline	assert(0 == new-&gtfl);\newline	assert(0 == new-&gtbl);\newline	status = SYS_INSQHI(new, base);\newline	/* We cannot assert that new-&gtfl and new-&gtbl are non-zero at this point since they\newline	 * could be concurrently removed from the queue right after we inserted it above.\newline	 */\newline	return status;\newline}\newline","An element that is not present in the queue should have its fl,bl fields zero.\newline An element that is present in the queue should have its fl,bl fields non-zero.\newline Ensure/Check this property for all queue operations.\newline This will help catch a case when an element that is already present in the queue is re-added into the same queue.\newline Such operations will cause queue corruption and since the queue is in shared memory (given that the interlocked\newline queue operations are being done), could cause shared memory corruption and database damage (D9H03-002644).\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,285107,utils.c,"char * nl_msec2str(uint64_t msec, char *buf, size_t len)\newline{\newline	uint64_t split[5];\newline	size_t i;\newline	static const char *units[5] = {&quotd&quot, &quoth&quot, &quotm&quot, &quots&quot, &quotmsec&quot};\newline	char * const buf_orig = buf;\newline\newline	if (msec == 0) {\newline		snprintf(buf, len, &quot0msec&quot);\newline		return buf_orig;\newline	}\newline\newline#define _SPLIT(idx, unit) if ((split[idx] = msec / unit)) msec %= unit\newline	_SPLIT(0, 86400000);	/* days */\newline	_SPLIT(1, 3600000);	/* hours */\newline	_SPLIT(2, 60000);	/* minutes */\newline	_SPLIT(3, 1000);	/* seconds */\newline#undef  _SPLIT\newline	split[4] = msec;\newline\newline	for (i = 0; i &lt ARRAY_SIZE(split) &amp&amp len; i++) {\newline		int l;\newline		if (split[i] == 0)\newline			continue;\newline		l = snprintf(buf, len, &quot%s%&quot PRIu64 &quot%s&quot,\newline			(buf==buf_orig) ? &quot&quot : &quot &quot, split[i], units[i]);\newline		buf += l;\newline		len -= l;\newline	}\newline\newline	return buf_orig;\newline}\newline","\newline Convert milliseconds to a character string\newline @arg msec number of milliseconds\newline @arg buf destination buffer\newline @arg len buffer length\newline \newline Converts milliseconds to a character string split up in days, hours,\newline minutes, seconds, and milliseconds and stores it in the specified\newline destination buffer.\newline \newline @return The destination buffer.\newline \newline",1886662,libtcc.c,"PUB_FUNC void tcc_error_noabort(const char *fmt, ...)\newline{\newline    TCCState *s1 = tcc_state;\newline    va_list ap;\newline\newline    va_start(ap, fmt);\newline    error1(s1, 0, fmt, ap);\newline    va_end(ap);\newline}\newline",error without aborting current compilation \newline,2796450,libcdata_array.c,"int libcdata_array_get_number_of_entries(\newline     libcdata_array_t *array,\newline     int *number_of_entries,\newline     libcerror_error_t **error )\newline{\newline	libcdata_internal_array_t *internal_array = NULL;\newline	static char *function                     = &quotlibcdata_array_get_number_of_entries&quot;\newline\newline	if( array == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid array.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_array = (libcdata_internal_array_t *) array;\newline\newline	if( number_of_entries == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid number of entries.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#if defined( HAVE_MULTI_THREAD_SUPPORT ) &amp&amp !defined( HAVE_LOCAL_LIBCDATA )\newline	if( libcthreads_read_write_lock_grab_for_read(\newline	     internal_array-&gtread_write_lock,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,\newline		 &quot%s: unable to grab read/write lock for reading.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#endif\newline	*number_of_entries = internal_array-&gtnumber_of_entries;\newline\newline#if defined( HAVE_MULTI_THREAD_SUPPORT ) &amp&amp !defined( HAVE_LOCAL_LIBCDATA )\newline	if( libcthreads_read_write_lock_release_for_read(\newline	     internal_array-&gtread_write_lock,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,\newline		 &quot%s: unable to release read/write lock for reading.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#endif\newline	return( 1 );\newline}\newline",Retrieves the number of entries in the array\newline Returns 1 if successful or -1 on error\newline \newline,146664,compression.c,"char *decorrelate2(char *x_uncomp,\newline		   int uncomp_len,\newline		   int level,\newline		   int *comp_len) {\newline    int i, z, delta;\newline    int u1 = 0, u2 = 0, u3 = 0;\newline    char *comp = (char *)xmalloc(uncomp_len + 2);\newline    unsigned char *u_uncomp = (unsigned char *)x_uncomp;\newline\newline    if (!comp)\newline	return NULL;\newline\newline    comp+=2;\newline    switch (level) {\newline    case 1:\newline	for (i = 0; i &lt uncomp_len; i+=2) {\newline	    z = u1;\newline	    u1 = (u_uncomp[i] &lt&lt 8) + u_uncomp[i+1];\newline	    delta = u1 - z;\newline	    comp[i  ] = (delta &gt&gt 8) &amp 0xff;\newline	    comp[i+1] = (delta &gt&gt 0) &amp 0xff;\newline	}\newline	break;\newline	\newline    case 2:\newline	for (i = 0; i &lt uncomp_len; i+=2) {\newline	    z = 2*u1 - u2;\newline	    u2 = u1;\newline	    u1 = (u_uncomp[i] &lt&lt 8) + u_uncomp[i+1];\newline	    delta = u1 - z;\newline	    comp[i  ] = (delta &gt&gt 8) &amp 0xff;\newline	    comp[i+1] = (delta &gt&gt 0) &amp 0xff;\newline	}\newline	break;\newline\newline    case 3:\newline	for (i = 0; i &lt uncomp_len; i+=2) {\newline	    z = 3*u1 - 3*u2 + u3;\newline	    u3 = u2;\newline	    u2 = u1;\newline	    u1 = (u_uncomp[i] &lt&lt 8) + u_uncomp[i+1];\newline	    delta = u1 - z;\newline	    comp[i  ] = (delta &gt&gt 8) &amp 0xff;\newline	    comp[i+1] = (delta &gt&gt 0) &amp 0xff;\newline	}\newline	break;\newline\newline    default:\newline	return NULL;\newline    }\newline    comp-=2;\newline    comp[0] = ZTR_FORM_DELTA2;\newline    comp[1] = level;\newline\newline    *comp_len = uncomp_len+2;\newline\newline    return comp;\newline}\newline","\newline decorrelate2()\newline \newline Produce successive deltas from a 2-byte array (big endian)\newline \newline Arguments:\newline uncomp Uncompressed data\newline uncomp_len Length of uncompressed data\newline level Differencing level (must be 1, 2 or 3)\newline comp_len Return: where to store new compressed length\newline \newline Returns:\newline Success: A decorrelated buffer (malloced)\newline Failure: NULL\newline \newline",4399344,ui_sdlgl.c,"static config_t *do_menu(int *pgn)\newline{\newline    title_process_retval=2;\newline\newline    resize_window(screen_width, screen_height);\newline    glEnable(GL_BLEND);\newline    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\newline    engine_error_shown = 0;\newline    set_loading=FALSE;\newline    draw_credits(1);\newline    open_title_root_dialog();\newline    if (mode_set_failed) {\newline        gg_dialog_open(dialog_error_create(gg_dialog_get_active(), &quotError: failed to set video mode; using defaults&quot, NULL));\newline        mode_set_failed = 0;\newline    }\newline\newline    set_fade_start(gg_system_get_ticks());\newline    set_show_egg(FALSE);\newline\newline    DBG_LOG(&quotentering title menu&quot);\newline\newline    while ( 1 )\newline    {\newline        Uint8 *keystate;\newline        gg_event_t event;\newline\newline        keystate = SDL_GetKeyState(NULL);\newline\newline        egg_req1=FALSE;\newline\newline        gg_dialog_cleanup();\newline\newline        /* Draw the menu.. */\newline        glDisable(GL_BLEND);\newline        glDisable(GL_DEPTH_TEST);\newline        draw_texture(&ampmenu_title_tex, 0, 0, 640, 480, 1.0f, get_col(COL_WHITE));\newline        glEnable(GL_BLEND);\newline        glEnable(GL_DEPTH_TEST);\newline        text_draw_string_right(620, 20, &quotv&quot PACKAGE_VERSION &quot (&quot GIT_REV &quot)&quot, 0.75f, get_col(COL_WHITE));\newline\newline        /*if (get_show_egg())\newline            text_draw_string(560, 440, &quotEgg!&quot, 1, get_col(COL_WHITE));*/\newline\newline        switch(menu_state)\newline        {\newline        case MENU_STATE_FADE_IN:\newline            while (poll_event(&ampevent));\newline            gg_dialog_render_all();\newline\newline            if (!draw_fade(FADE_IN))\newline            {\newline                menu_state = MENU_STATE_IN_MENU;\newline                draw_credits(1);\newline            }\newline            break;\newline\newline        case MENU_STATE_IN_MENU:\newline\newline            if ( keystate[SDLK_UP] )\newline                egg_req1=TRUE;\newline\newline            while (poll_event(&ampevent))\newline                gg_dialog_input_current(event);\newline\newline            if (title_process_retval == 1)\newline                return NULL;\newline\newline            if (set_loading)\newline            {\newline                gg_widget_t *widget = gg_label_create(&quotLoading, please wait...&quot);\newline                widget = gg_dialog_create(widget, NULL, NULL, 0);\newline                gg_dialog_set_style(GG_DIALOG(widget), get_menu_style());\newline                gg_dialog_open(GG_DIALOG(widget));\newline                menu_state = MENU_STATE_LOAD;\newline            }\newline            else\newline                draw_credits(0);\newline\newline            gg_dialog_render_all();\newline            break;\newline\newline        case MENU_STATE_LOAD:\newline            {\newline                option_t *option = config_get_option(&quottheme&quot);\newline                struct theme_struct *theme = option-&gtselected-&gtdata;\newline\newline                load_theme(theme);\newline                sprintf(get_white_name(),&quot%s&quot, theme-&gtwhite_name);\newline                sprintf(get_black_name(),&quot%s&quot, theme-&gtblack_name);\newline                reset_transition(TRUE);\newline            }\newline\newline            *pgn = pgn_slot;\newline            if (pgn_slot &gt= 0)\newline                config = *get_config_save(pgn_slot);\newline\newline            reset_3d(config.player[WHITE] == PLAYER_ENGINE);\newline\newline            set_fade_start(gg_system_get_ticks());\newline            gg_dialog_close();\newline\newline            menu_state = MENU_STATE_FADE_OUT;\newline            break;\newline\newline        case MENU_STATE_FADE_OUT:\newline            while (poll_event(&ampevent));\newline            if ((get_show_egg() &amp&amp !draw_sonic_fade( FADE_OUT )) ||\newline                    (!get_show_egg() &amp&amp !draw_fade( FADE_OUT )))\newline            {\newline                set_fade_start(gg_system_get_ticks());\newline                menu_state = MENU_STATE_RETURN;\newline                return &ampconfig;\newline            }\newline            break;\newline\newline        case MENU_STATE_RETURN:\newline            while (poll_event(&ampevent));\newline            gg_dialog_render_all();\newline\newline            if (!draw_fade(FADE_IN))\newline                menu_state = MENU_STATE_IN_MENU;\newline            break;\newline\newline        }\newline\newline        /* Draw mouse cursor.. */\newline#ifndef __BEOS__\newline        draw_texture( get_menu_mouse_cursor(), get_mouse_x(), (479-get_mouse_y()-32), 32, 32, 1.0f,\newline                      get_col(COL_WHITE) );\newline#endif /* __BEOS __ */\newline\newline        gl_swap();\newline    }\newline}\newline",Implements ui_driver::menu \newline,2907411,dialogs.c,"void otrg_dialog_notify_info(const char *accountname, const char *protocol,\newline	const char *username, const char *title, const char *primary,\newline	const char *secondary)\newline{\newline    otrg_dialog_notify_message(PURPLE_NOTIFY_MSG_INFO, accountname,\newline	    protocol, username, title, primary, secondary);\newline}\newline",Put up the info version of otrg_dialog_notify_message \newline,,on,on,,,,,,,,,,,,,,,,,,on,,,,,,,,,,,,,,,,,,,,,,Send DHCP packet (broadcast) and receive response for it.,{},{},"ragel enforces fpc as a const,",Removes the node from the list,Ensure/Check this property for all queue operations.,Load an image from the named file.,Convert milliseconds to a character string,error without aborting current compilation,Returns 1 if successful or -1 on error,Produce successive deltas from a 2-byte array (big endian),Establish connection between a process,Implements ui_driver::menu,Put up the info version of otrg_dialog_notify_message,Must be called with RCU read-side lock held.,Get a equality testing function for a given type.,Set an element of the kmclipm_vector.,Get the char-index for a byte-index.,Initialize the table of used registers,Turn off all notes on a MIDI channel,{},x,
30ZKOOGW2W63XSNMCJRKTAM8NC21A6,3GSIANI2QSDN2IHIBNYS4M52TLVDP7,Highlight the phrase that best summarizes a source code comment (Open to new and returning workers) (Chrome and Firefox only),"Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.",programming highlight code C function comment tag find choose summarize software engineering,$1.00,Fri Apr 26 12:44:46 PDT 2019,3,BatchId:3622159;OriginalHitTemplateId:920937336;,3600,172800,Fri May 03 13:59:22 PDT 2019,,,31N2WW6R9RQWQ6F205WWKN8L087F3P,AITP2LUW8GPB,Submitted,Fri Apr 26 14:57:22 PDT 2019,Fri Apr 26 15:07:02 PDT 2019,Sun Apr 28 15:07:02 PDT 2019,,,,580,100% (62/62),100% (62/62),0% (0/0),85939,tp.c,"GLOBAL BOOLEAN set_docinfo ( void )\newline{\newline	char s[512], *cont, *data, inhalt[512], *buffer;\newline	char sDriv[512], sPath[512], sFile[512], sSuff[512];\newline	size_t contlen;\newline\newline	tokcpy2(s, 512);\newline	/* New: Fixed bug #0000040 in r6.3pl16 [NHz] */\newline	node2postscript(s, KPS_PS2DOCINFO);\newline\newline	contlen= get_brackets_ptr(s, &ampcont, &ampdata);\newline	\newline	if (contlen==0 || cont==NULL || data==NULL)\newline	{	error_syntax_error();\newline		return FALSE;\newline	}\newline\newline	inhalt[0]= EOS;	\newline	strncpy(inhalt, cont, contlen);\newline	inhalt[contlen]= EOS;\newline	del_whitespaces(inhalt);\newline\newline	/* New: Fixed Bug #0000040 in r6.3pl16 [NHz] */\newline	node2postscript(data, KPS_DOCINFO2PS);\newline\newline	if (strcmp(inhalt, &quotauthorimage&quot)==0)\newline	{	del_whitespaces(data);\newline		if (data[0]==EOS)\newline		{	error_empty_docinfo();\newline		}\newline		else\newline		{	path_adjust_separator(data);\newline			buffer= (char *) um_malloc ( strlen(data)*sizeof(char)+1 );\newline			if (buffer)\newline			{	strcpy(buffer, data);\newline				titdat.authorimage= buffer;\newline				if (desttype==TOHTM || desttype==TOMHH)\newline				{	replace_char(titdat.authorimage, &quot\\\\&quot, &quot/&quot);	/*r6pl4*/\newline					/* r6pl9: Ausmasse nicht ermitteln -&gt da */\newline					/* ueber c_gif_output() ausgegeben wird  */\newline				}\newline			}\newline			else\newline			{	error_malloc_failed();\newline				bFatalErrorDetected= TRUE;\newline			}\newline		}\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotauthoricon&quot)==0)	/*r6pl6*/\newline	{	del_whitespaces(data);\newline		if (data[0]==EOS)\newline		{	error_empty_docinfo();\newline		}\newline		else\newline		{	/* r6pl12: Endung abschneiden und mit !html_img_suffix ersetzen */\newline			fsplit(data, sDriv, sPath, sFile, sSuff);\newline			sprintf(data, &quot%s%s%s&quot, sPath, sFile, sDocImgSuffix);\newline			path_adjust_separator(data);\newline			buffer= (char *) um_malloc ( strlen(data)*sizeof(char)+1 );\newline			if (buffer)\newline			{	strcpy(buffer, data);\newline				titdat.authoricon= buffer;\newline				if (desttype==TOHTM || desttype==TOMHH)\newline				{	replace_char(titdat.authoricon, &quot\\\\&quot, &quot/&quot);\newline					if (my_stricmp(sDocImgSuffix, &quot.gif&quot)==0)\newline					{	/* r6pl9: Ausmasse ermitteln */\newline						strinsert(data, old_outfile.path);\newline						strinsert(data, old_outfile.driv);\newline						/* strcat(data, &quot.gif&quot); */\newline						path_adjust_separator(data);\newline						if (!get_gif_size(data, &amptitdat.authoriconWidth, &amptitdat.authoriconHeight))\newline						{	error_read_gif(data);\newline						}\newline					}\newline				}\newline			}\newline			else\newline			{	error_malloc_failed();\newline				bFatalErrorDetected= TRUE;\newline			}\newline		}\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotauthoricon_active&quot)==0)	/*r6pl13*/\newline	{	del_whitespaces(data);\newline		if (data[0]==EOS)\newline		{	error_empty_docinfo();\newline		}\newline		else\newline		{	/* r6pl12: Endung abschneiden und mit !html_img_suffix ersetzen */\newline			fsplit(data, sDriv, sPath, sFile, sSuff);\newline			sprintf(data, &quot%s%s%s&quot, sPath, sFile, sDocImgSuffix);\newline			path_adjust_separator(data);\newline			buffer= (char *) um_malloc ( strlen(data)*sizeof(char)+1 );\newline			if (buffer)\newline			{	strcpy(buffer, data);\newline				titdat.authoricon_active= buffer;\newline				if (desttype==TOHTM || desttype==TOMHH)\newline				{	replace_char(titdat.authoricon_active, &quot\\\\&quot, &quot/&quot);\newline					if (my_stricmp(sDocImgSuffix, &quot.gif&quot)==0)\newline					{	/* r6pl9: Ausmasse ermitteln */\newline						strinsert(data, old_outfile.path);\newline						strinsert(data, old_outfile.driv);\newline						/* strcat(data, &quot.gif&quot); */\newline						path_adjust_separator(data);\newline						if (!get_gif_size(data, &amptitdat.authoriconActiveWidth, &amptitdat.authoriconActiveHeight))\newline						{	error_read_gif(data);\newline						}\newline					}\newline				}\newline			}\newline			else\newline			{	error_malloc_failed();\newline				bFatalErrorDetected= TRUE;\newline			}\newline		}\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotprogramimage&quot)==0)\newline	{	del_whitespaces(data);\newline		if (data[0]==EOS)\newline		{	error_empty_docinfo();\newline		}\newline		else\newline		{	path_adjust_separator(data);\newline			buffer= (char *) um_malloc ( strlen(data)*sizeof(char)+1 );\newline			if (buffer)\newline			{	strcpy(buffer, data);\newline				titdat.programimage= buffer;\newline				if (desttype==TOHTM || desttype==TOMHH)\newline				{	replace_char(titdat.programimage, &quot\\\\&quot, &quot/&quot);	/*r6pl4*/\newline					/* r6pl9: Ausmasse nicht ermitteln -&gt da */\newline					/* ueber c_gif_output() ausgegeben wird  */\newline				}\newline			}\newline			else\newline			{	error_malloc_failed();\newline				bFatalErrorDetected= TRUE;\newline			}\newline		}\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quottitle&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.title), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotprogram&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.program), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotversion&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.version), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotdate&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.date), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotauthor&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.author), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotaddress&quot)==0)\newline	{	if (address_counter&ltMAXADDRESS)\newline		{	address_counter++;\newline			init_docinfo_data(data, &amp(titdat.address[address_counter]), FALSE);\newline		}\newline		return TRUE;\newline	}\newline\newline	/* New in r6pl15 [NHz] */\newline	if (strcmp(inhalt, &quotkeywords&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.keywords), FALSE);\newline		return TRUE;\newline	}\newline\newline	/* New in r6pl15 [NHz] */\newline	if (strcmp(inhalt, &quotdescription&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.description), FALSE);\newline		return TRUE;\newline	}\newline\newline	/* Spezialitaeten fuer ST-Guide */\newline	if (strcmp(inhalt, &quotstgdatabase&quot)==0)	/*r6pl4*/\newline	{	init_docinfo_data(data, &amp(titdat.stg_database), TRUE);\newline		return TRUE;\newline	}\newline\newline	/* Spezialitaeten fuer DRC */\newline	if (strcmp(inhalt, &quotdrcstatusline&quot)==0)	/*r6pl4*/\newline	{	init_docinfo_data(data, &amp(titdat.drc_statusline), FALSE);\newline		return TRUE;\newline	}\newline\newline	/* Spezialitaeten fuer HTML */\newline	if (strcmp(inhalt, &quothtmltitle&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.htmltitle), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotwebmastername&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.webmastername), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotwebmasteremail&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.webmasteremail), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotwebmastermailurl&quot)==0)\newline	{	init_docinfo_data(data, &amp(titdat.webmastermailurl), FALSE);\newline		return TRUE;\newline	}\newline\newline	if (strcmp(inhalt, &quotwebmasterurl&quot)==0)\newline	{	del_whitespaces(data);	/* nicht init_...!!! */\newline		convert_tilde(data);\newline		if (data[0]==EOS)\newline		{	error_empty_docinfo();\newline		}\newline		else\newline		{	buffer= (char *) um_malloc ( strlen(data)*sizeof(char)+1 );\newline			if (buffer)\newline			{	strcpy(buffer, data);\newline				titdat.webmasterurl= buffer;\newline			}\newline			else\newline			{	error_malloc_failed();\newline				bFatalErrorDetected= TRUE;\newline			}\newline		}\newline		return TRUE;\newline	}\newline\newline	error_unknown_docinfo(inhalt);\newline	\newline	return FALSE;\newline\newline}	/* set_docinfo */\newline","--------------------------------------------------------------\newline set_docinfo()\newline Setzen von Informationen fuer die Titelseite (neue Version)\newline Die Daten stehen in token[]. Frueher setzte man bspw. den\newline Programmnamen mit &quot!program UDO&quot, nun mit\newline &quot!docinfo [program] UDO&quot.\newline &lt- TRUE: OK\newline sonst: Fehler\newline -------------------------------------------------------------- \newline",2205061,fitskey.c,"int	add_key(keystruct *key, tabstruct *tab, int pos)\newline\newline  {\newline\newline/*Check if a similar key doesn&#039t already exist in the dest. cat */\newline  if (name_to_key(tab, key-&gtname))\newline    return RETURN_ERROR;\newline\newline/*Update links (portion of code similar to that of copy_key below) */\newline  if ((key-&gtnextkey = pos_to_key(tab, pos)))\newline    {\newline    (key-&gtprevkey = key-&gtnextkey-&gtprevkey)-&gtnextkey = key;\newline    key-&gtnextkey-&gtprevkey = key;\newline/*--the first place has a special meaning*/\newline    if (pos==1)\newline      tab-&gtkey = key;\newline    }\newline  else\newline/*There was no no key before*/\newline    tab-&gtkey = key-&gtnextkey = key-&gtprevkey = key;\newline\newline  tab-&gtnkey++;\newline\newline  return RETURN_OK;\newline  }\newline","add_key \newlinePROTO int add_key(keystruct key, tabstruct tab, int pos)\newlinePURPOSE Copy a key from one table to another.\newlineINPUT Pointer to the key,\newlinePointer to the table,\newline Pointer to the destination table,\newline Position (1= first, &lt=0 = at the end)\newlineOUTPUT RETURN_OK if everything went as expected, and RETURN_ERROR otherwise.\newlineNOTES A preexisting key in the destination table yields a RETURN_ERROR.\newlineAUTHOR E. Bertin (IAP &amp Leiden observatory)\newlineVERSION 26/03/96\newline \newline",2968989,patternset.cpp,"int patternset::SymbolRandPos(int number, char symb) {\newline	std::vector&ltint&gt positions;\newline	int pos;\newline\newline	positions = GetSymbol(number, symb);\newline\newline	std::uniform_int_distribution&ltint&gt distribution(0, (int) positions.size() - 1);\newline\newline	pos = distribution(generator);\newline	pos = positions[pos];\newline\newline	positions.clear();\newline	return pos;\newline}\newline","\newline Returns for a specific symbol (&#0391&#039, &#0390&#039) a random chosen position\newline \newline @param number The pattern index of the modifying pattern\newline \newline @param symb The specific symbol, either &#0391&#039 or &#0390&#039\newline \newline @return A random chosen position in the pattern of the specific symbol\newline \newline",3105192,pars.c,"int One_Pars_Step(t_edge *b,t_tree *tree)\newline{\newline  int site;\newline  int init_general_pars;\newline\newline  init_general_pars = tree-&gtmod-&gts_opt-&gtgeneral_pars;\newline\newline  tree-&gtmod-&gts_opt-&gtgeneral_pars = 0;\newline  Set_Both_Sides(YES,tree);\newline  Pars(NULL,tree);\newline\newline  for(site=0;site&lttree-&gtn_pattern;site++)\newline    {\newline      if(!(b-&gtui_l[site] &amp b-&gtui_r[site])) break;\newline    }\newline  tree-&gtmod-&gts_opt-&gtgeneral_pars = init_general_pars;\newline  if(site == tree-&gtn_pattern) return 0;\newline  else\newline    {\newline      PhyML_Printf(&quot\\n. One parsimony step ocurred at site %4d&quot,site);\newline      return 1;\newline    }\newline}\newline",Is there one or more parsimoniy step(s) along this t_edge ?\newline0 -&gt NO; 1 -&gt YES\newline \newline,705600,dw_switch.c,"TVector* RealTimeSmoothedProbabilities(TVector *p, int tau, TStateModel *model)\newline{\newline  int nstates=model-&gtsv-&gtnstates, i, k, t;\newline\newline  if (!p)\newline    {\newline      p=dw_CreateArray_vector(tau+1);\newline      for (t=tau; t &gt= 0; t--)\newline	p[t]=CreateVector(model-&gtsv-&gtnstates);\newline    }\newline  else\newline    if (dw_DimA(p) &lt= tau)\newline      {\newline	dw_Error(SIZE_ERR);\newline	return (TVector*)NULL;\newline      }\newline\newline  //====== Check for valid forward recursion through time tau ======\newline  if ((model-&gtt0 &lt tau) &amp&amp !ForwardRecursion(tau,model)) return 0;\newline\newline  //====== Compute smoothed probabilities via backward recursion ======\newline  EquateVector(p[tau],model-&gtV[tau]);\newline  for (t=tau-1; t &gt= 0; t--)\newline    {\newline      //------ compute Q(t) if necessary ------\newline      if (((t &lt model-&gtsv-&gtt0) || (model-&gtsv-&gtt1 &lt t)) &amp&amp !sv_ComputeTransitionMatrix(t+1,model-&gtsv,model)) return 0;\newline\newline      // s[t] = k and s[t+1] = i\newline      for (k=nstates-1; k &gt= 0; k--)\newline	{\newline	  for (ElementV(p[t],k)=0.0, i=nstates-1; i &gt= 0; i--)\newline	    if (ElementV(model-&gtZ[t+1],i) &gt 0.0)\newline	      ElementV(p[t],k)+=ElementV(p[t+1],i)*ElementM(model-&gtsv-&gtQ,i,k)/ElementV(model-&gtZ[t+1],i);\newline	  ElementV(p[t],k)*=ElementV(model-&gtV[t],k);\newline	}\newline    }\newline\newline  return p;\newline}\newline","\newlineComputes\newline\newlinep[t][s] = P(s[t] = s | Y[tau], Z[tau], theta, q)\newline \newline",3580134,image.c,"GLuint make_image_from_file(const char *filename, int fl)\newline{\newline    void  *p;\newline    int    w;\newline    int    h;\newline    int    b;\newline    GLuint o = 0;\newline\newline    /* Load the image. */\newline\newline    if ((p = image_load(filename, &ampw, &amph, &ampb)))\newline    {\newline        o = make_texture(p, w, h, b, fl);\newline        free(p);\newline    }\newline\newline    return o;\newline}\newline",\newline Load an image from the named file. Return an OpenGL texture object.\newline \newline,3081294,ndef.c,"static struct near_ndef_record_header *parse_record_header(uint8_t *rec,\newline					uint32_t offset, uint32_t length)\newline{\newline	struct near_ndef_record_header *rec_header = NULL;\newline	uint8_t *type = NULL;\newline	uint32_t header_len = 0;\newline\newline	DBG(&quotlength %d&quot, length);\newline\newline	if (!rec || offset &gt= length)\newline		return NULL;\newline\newline	/* This check is for empty record. */\newline	if ((length - offset) &lt NDEF_MSG_MIN_LENGTH)\newline		return NULL;\newline\newline	rec_header = g_try_malloc0(sizeof(struct near_ndef_record_header));\newline	if (!rec_header)\newline		return NULL;\newline\newline	rec_header-&gtmb = RECORD_MB_BIT(rec[offset]);\newline	rec_header-&gtme = RECORD_ME_BIT(rec[offset]);\newline	rec_header-&gtsr = RECORD_SR_BIT(rec[offset]);\newline	rec_header-&gtil = RECORD_IL_BIT(rec[offset]);\newline	rec_header-&gttnf = RECORD_TNF_BIT(rec[offset]);\newline\newline	DBG(&quotmb %d me %d sr %d il %d tnf %d&quot,\newline		rec_header-&gtmb, rec_header-&gtme, rec_header-&gtsr,\newline		rec_header-&gtil, rec_header-&gttnf);\newline\newline	offset++;\newline	rec_header-&gttype_len = rec[offset++];\newline	header_len = 2; /* type length + header bits */\newline\newline	if (rec_header-&gtsr == 1) {\newline		rec_header-&gtpayload_len = rec[offset++];\newline		header_len++;\newline	} else {\newline		rec_header-&gtpayload_len = near_get_be32(rec + offset);\newline		offset += 4;\newline		header_len += 4;\newline\newline		if ((offset + rec_header-&gtpayload_len) &gt length)\newline			goto fail;\newline	}\newline\newline	DBG(&quotpayload length %d&quot, rec_header-&gtpayload_len);\newline\newline	if (rec_header-&gtil == 1) {\newline		rec_header-&gtil_length = rec[offset++];\newline		header_len++;\newline\newline		if ((offset + rec_header-&gtpayload_len) &gt length)\newline			goto fail;\newline	}\newline\newline	if (rec_header-&gttype_len &gt 0) {\newline		if ((offset + rec_header-&gttype_len) &gt length)\newline			goto fail;\newline\newline		type = g_try_malloc0(rec_header-&gttype_len);\newline		if (!type)\newline			goto fail;\newline\newline		memcpy(type, rec + offset, rec_header-&gttype_len);\newline		offset += rec_header-&gttype_len;\newline		header_len += rec_header-&gttype_len;\newline\newline		if ((offset + rec_header-&gtpayload_len) &gt length)\newline			goto fail;\newline	}\newline\newline	if (rec_header-&gtil_length &gt 0) {\newline		if ((offset + rec_header-&gtil_length) &gt length)\newline			goto fail;\newline\newline		rec_header-&gtil_field = g_try_malloc0(rec_header-&gtil_length);\newline		if (!rec_header-&gtil_field)\newline			goto fail;\newline\newline		memcpy(rec_header-&gtil_field, rec + offset,\newline					rec_header-&gtil_length);\newline		offset += rec_header-&gtil_length;\newline		header_len += rec_header-&gtil_length;\newline\newline		if ((offset + rec_header-&gtpayload_len) &gt length)\newline			goto fail;\newline	}\newline\newline	rec_header-&gtrec_type = get_record_type(rec_header-&gttnf, type,\newline							rec_header-&gttype_len);\newline	rec_header-&gtoffset = offset;\newline	rec_header-&gtheader_len = header_len;\newline	rec_header-&gttype_name = g_strndup((char *) type, rec_header-&gttype_len);\newline\newline	g_free(type);\newline\newline	return rec_header;\newline\newlinefail:\newline	near_error(&quotparsing record header failed&quot);\newline\newline	g_free(type);\newline	g_free(rec_header-&gtil_field);\newline	g_free(rec_header-&gttype_name);\newline	g_free(rec_header);\newline\newline	return NULL;\newline}\newline","\newline Parse the ndef record header and cache the begin, end, chunkflag,\newline short-record and type-name-format bits. ID length and field, record\newline type, payload length and offset (where payload byte starts in input\newline parameter). Validate offset for every step forward against total\newline available length.\newline \newline",3479503,rominfo.c,"char **read_textual_leafes(raw1394handle_t handle, int phyID,\newline	octlet_t offsets[], int n) {\newline	int i;\newline	char **textual_leafes;\newline\newline	if (n == 0) return NULL;\newline	if ((textual_leafes = (char **) calloc(n,sizeof(char *))) == NULL)\newline		fatal(&quotout of memory&quot);\newline	for (i=0; i&ltn; i++) {\newline		textual_leafes[i] = read_textual_leaf(handle, phyID,\newline			offsets[i]);\newline	}\newline	return textual_leafes;\newline}\newline",\newline Read a whole bunch of textual leafes from a node into an array of ASCII\newline strings.\newline IN: phyID: Physical ID of the node to read from\newline offsets: Memory offsets to read from\newline n: Number of Strings to read\newline RETURNS: pointer to a freshly malloced array of freshly malloced\newline strings that contains the requested texts. Some of the\newline strings might be NULL however.\newline Returns NULL when the number of textual leafes is 0.\newline \newline,3689978,moves.c,"int load_images_from_theme(char *theme)\newline{\newline   char *home, file[256];\newline   FILE *theme_fd;\newline   char variable[256];\newline   char buffer[256];\newline   int value;\newline   char ch;\newline\newline\newline   theme_fd = fopen(theme, &quotr&quot);\newline   if(theme_fd == NULL)\newline     {\newline      fprintf(stderr, &quotCan&#039t open theme file %s\\n&quot, theme);\newline      return FALSE;\newline     }\newline\newline   while (fscanf(theme_fd, &quot%s&quot, variable) != EOF)\newline     {\newline      while (ch = fgetc(theme_fd))\newline	{\newline	 if (ch == EOF)\newline	    return TRUE;\newline	 if (ch == &#039=&#039)\newline	    break;\newline	}\newline\newline      if (strcmp(variable, &quotWHITE_PIECE&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 strcpy(options.images.white_piece, PACKAGE_DATA_DIR &quot/pixmaps/gamazons/&quot);\newline	 strcat(options.images.white_piece, buffer);\newline	}\newline      else if (strcmp(variable, &quotBLACK_PIECE&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 strcpy(options.images.black_piece, PACKAGE_DATA_DIR &quot/pixmaps/gamazons/&quot);\newline	 strcat(options.images.black_piece, buffer);\newline	}\newline      else if (strcmp(variable, &quotWHITE_SQUARE&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 strcpy(options.images.white_sq, PACKAGE_DATA_DIR &quot/pixmaps/gamazons/&quot);\newline	 strcat(options.images.white_sq, buffer);\newline	}\newline      else if (strcmp(variable, &quotGREY_SQUARE&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 strcpy(options.images.grey_sq, PACKAGE_DATA_DIR &quot/pixmaps/gamazons/&quot);\newline	 strcat(options.images.grey_sq, buffer);\newline	}\newline      else if (strcmp(variable, &quotARROW_SQUARE&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 strcpy(options.images.arrow_sq, PACKAGE_DATA_DIR &quot/pixmaps/gamazons/&quot);\newline	 strcat(options.images.arrow_sq, buffer);\newline	}\newline      else if (strcmp(variable, &quotDRAW_GRID&quot) == 0)\newline	{\newline	 fscanf(theme_fd, &quot%s&quot, buffer);\newline	 if (strcmp(buffer, &quotTRUE&quot) == 0)\newline	    options.images.grid = TRUE;\newline	 else\newline	    options.images.grid = FALSE;\newline	}\newline\newline\newline     }\newline\newline   fclose(theme_fd);\newline   return TRUE;\newline}\newline","==============================================================================\newline load_images_from_theme\newline \newline This file will read image paths from a theme file. These values get loaded \newline into the options struct, and subsequently used to draw the board.\newline \newline",4607801,bayes-filter.c,"static double chi2q(double x2, double v)\newline{\newline	double m;\newline	double sum;\newline	double term;\newline	int i;\newline\newline	m = x2 / 2.0;\newline	sum = term = exp(0.0 - m);\newline\newline	for (i = 1; i &lt (v / 2) - 1; i++) {\newline		term *= m / i;\newline		sum += term;\newline	}\newline\newline	return sum &lt 1.0 ? sum : 1.0;\newline}\newline",inverse chi-squared function \newline,3103262,sched_prim.c,"void thread_timeout(\newline	void *_thread)\newline{\newline	thread_t thread = _thread;\newline	assert(thread-&gttimer.set == TELT_UNSET);\newline\newline	clear_wait(thread, THREAD_TIMED_OUT, FALSE);\newline}\newline","\newline Thread timeout routine, called when timer expires.\newline Called at splsoftclock.\newline \newline",3100810,tmscsim.c,"int DC390_initAdapter( PSH psh, ULONG io_port, UCHAR Irq, USHORT index )\newline{\newline    USHORT ioport;\newline    UCHAR  bval;\newline    PACB   pACB, pacb;\newline    USHORT used_irq = 0;\newline\newline    pacb = pACB_start;\newline    if( pacb != NULL )\newline    {\newline	for ( ; (pacb != (PACB) -1) ; )\newline	{\newline	    if( pacb-&gtIRQLevel == Irq )\newline	    {\newline		used_irq = 1;\newline		break;\newline	    }\newline	    else\newline		pacb = pacb-&gtpNextACB;\newline	}\newline    }\newline\newline    if( !used_irq )\newline    {\newline#ifdef	VERSION_ELF_1_2_13\newline	if( request_irq(Irq, DC390_Interrupt, SA_INTERRUPT, &quottmscsim&quot))\newline#else\newline	if( request_irq(Irq, DC390_Interrupt, SA_INTERRUPT | SA_SHIRQ, &quottmscsim&quot, NULL))\newline#endif\newline	{\newline	    printk(&quotDC390: register IRQ error!\\n&quot);\newline	    return( -1 );\newline	}\newline    }\newline\newline    request_region(io_port,psh-&gtn_io_port,&quottmscsim&quot);\newline\newline    ioport = (USHORT) io_port;\newline\newline    pACB = (PACB) psh-&gthostdata;\newline    bval = SEL_TIMEOUT; 		/* 250ms selection timeout */\newline    outb(bval,ioport+Scsi_TimeOut);\newline\newline    bval = CLK_FREQ_40MHZ;		/* Conversion factor = 0 , 40MHz clock */\newline    outb(bval,ioport+Clk_Factor);\newline\newline    bval = NOP_CMD;			/* NOP cmd - clear command register */\newline    outb(bval,ioport+ScsiCmd);\newline\newline    bval = EN_FEATURE+EN_SCSI2_CMD;	/* Enable Feature and SCSI-2 */\newline    outb(bval,ioport+CtrlReg2);\newline\newline    bval = FAST_CLK;			/* fast clock */\newline    outb(bval,ioport+CtrlReg3);\newline\newline    bval = EATER_25NS;\newline    if( eepromBuf[index][EE_MODE2] &amp ACTIVE_NEGATION )\newline	 bval |= NEGATE_REQACKDATA;\newline    outb(bval,ioport+CtrlReg4);\newline\newline    bval = DIS_INT_ON_SCSI_RST; 	/* Disable SCSI bus reset interrupt */\newline    outb(bval,ioport+CtrlReg1);\newline\newline    return(0);\newline}\newline",\newline Function : static int DC390_initAdapter\newline \newline Purpose : initialize the SCSI chip ctrl registers\newline \newline Inputs : psh - pointer to this host adapter&#039s structure\newline \newline \newline,5796069,eca-engine.cpp,"void ECA_ENGINE::start_operation(void)\newline{\newline  // ---\newline  DBC_REQUIRE(is_prepared() == true);\newline  DBC_REQUIRE(is_running() != true);\newline  // ---\newline\newline  ECA_LOG_MSG(ECA_LOGGER::system_objects, &quotstarting engine operation!&quot);\newline\newline  start_realtime_objects();\newline  running_rep = true;\newline\newline  // ---\newline  DBC_ENSURE(is_running() == true);\newline  DBC_ENSURE(status() == ECA_ENGINE::engine_status_running);\newline  // ---\newline}\newline",\newline Starts engine operation.\newline \newline This function should be called by the\newline driver just before it starts iterating the \newline engine&#039s main loop.\newline \newline context: E-level-1/3\newline must not be run at the same time\newline as engine_iteration()\newline \newline @pre is_prepared() == true\newline @pre is_running() != true\newline @post is_running() == true\newline @post status() == ECA_ENGINE::engine_status_running\newline \newline,4977276,types.c,"type make_array_type(type t, expression size)\newline{\newline  type nt = new_type(tk_array);\newline\newline  nt-&gtu.array.arrayof = t;\newline  nt-&gtu.array.size = size;\newline  nt-&gtnetwork = t-&gtnetwork != nx_no ? nx_derived : nx_no;\newline\newline  return nt;\newline}\newline",Return type &#039array [size] of t&#039. size is optional \newline,1256502,genx.c,"genxAttribute genxDeclareAttribute(genxWriter w,\newline				   genxNamespace ns, constUtf8 name,\newline				   genxStatus * statusP)\newline{\newline  if ((w-&gtstatus = checkNCName(w, name)) != GENX_SUCCESS)\newline  {\newline    *statusP = w-&gtstatus;\newline    return NULL;\newline  }\newline\newline  return declareAttribute(w, ns, name, NULL, statusP);\newline}\newline",\newline genxDeclareAttribute - see genx.h for details\newline \newline,6464344,audioeffectx.cpp,"void* AudioEffectX::getDirectory ()\newline{\newline	if (audioMaster)\newline	{\newline		VstIntPtr ret = (audioMaster (&ampcEffect, audioMasterGetDirectory, 0, 0, 0, 0));\newline		return FromVstPtr&ltvoid&gt (ret);\newline	}\newline	return 0;\newline}\newline","!\newline \\return FSSpec on MAC, else char \newline \newline",3583252,eedi2.c,"void eedi2_calc_directions( const int plane, uint8_t * mskp, int msk_pitch, uint8_t * srcp, int src_pitch,\newline                            uint8_t * dstp, int dst_pitch, int maxd, int nt, int height, int width  )\newline{\newline    int x, y, u, i;\newline    \newline    memset( dstp, 255, dst_pitch * height );\newline    mskp += msk_pitch;\newline    dstp += dst_pitch;\newline    srcp += src_pitch;\newline    unsigned char *src2p = srcp - src_pitch * 2;\newline    unsigned char *srcpp = srcp - src_pitch;\newline    unsigned char *srcpn = srcp + src_pitch;\newline    unsigned char *src2n = srcp + src_pitch * 2;\newline    unsigned char *mskpp = mskp - msk_pitch;\newline    unsigned char *mskpn = mskp + msk_pitch;\newline    const int maxdt = plane == 0 ? maxd : ( maxd &gt&gt 1 );\newline\newline    for( y = 1; y &lt height - 1; ++y )\newline    {\newline        for( x = 1; x &lt width - 1; ++x )\newline        {\newline            if( mskp[x] != 0xFF || ( mskp[x-1] != 0xFF &amp&amp mskp[x+1] != 0xFF ) )\newline                continue;\newline            const int startu = MAX( -x + 1, -maxdt );\newline            const int stopu = MIN( width - 2 - x, maxdt );\newline            int minb = MIN( 13 * nt,\newline                            ( abs( srcp[x] - srcpn[x] ) +\newline                              abs( srcp[x] - srcpp[x] ) ) * 6 );\newline            int mina = MIN( 19 * nt,\newline                            ( abs( srcp[x] - srcpn[x] ) +\newline                              abs( srcp[x] - srcpp[x] ) ) * 9 );\newline            int minc = mina;\newline            int mind = minb;\newline            int mine = minb;\newline            int dira = -5000, dirb = -5000, dirc = -5000, dird = -5000, dire = -5000;\newline            for( u = startu; u &lt= stopu; ++u )\newline            {\newline                if( y == 1 ||\newline                      mskpp[x-1+u] == 0xFF || mskpp[x+u] == 0xFF || mskpp[x+1+u] == 0xFF )\newline                {\newline                    if( y == height - 2 ||\newline                        mskpn[x-1-u] == 0xFF || mskpn[x-u] == 0xFF || mskpn[x+1-u] == 0xFF )\newline                    {\newline                        const int diffsn = abs(  srcp[x-1] - srcpn[x-1-u] ) +\newline                                           abs(  srcp[x]   - srcpn[x-u] )   +\newline                                           abs(  srcp[x+1] - srcpn[x+1-u] );\newline\newline                        const int diffsp = abs(  srcp[x-1] - srcpp[x-1+u] ) +\newline                                           abs(  srcp[x]   - srcpp[x+u] )   +\newline                                           abs(  srcp[x+1] - srcpp[x+1+u] );\newline\newline                        const int diffps = abs( srcpp[x-1] -  srcp[x-1-u] ) +\newline                                           abs( srcpp[x]   -  srcp[x-u] )   +\newline                                           abs( srcpp[x+1] -  srcp[x+1-u] );\newline\newline                        const int diffns = abs( srcpn[x-1] -  srcp[x-1+u] ) +\newline                                           abs( srcpn[x]   -  srcp[x+u] )   +\newline                                           abs( srcpn[x+1] -  srcp[x+1+u] );\newline\newline                        const int diff = diffsn + diffsp + diffps + diffns;\newline                        int diffd = diffsp + diffns;\newline                        int diffe = diffsn + diffps;\newline                        if( diff &lt minb )\newline                        {\newline                            dirb = u;\newline                            minb = diff;\newline                        }\newline                        if( __builtin_expect( y &gt 1, 1) )\newline                        {\newline                            const int diff2pp = abs( src2p[x-1] - srcpp[x-1-u] ) +\newline                                            abs( src2p[x]   - srcpp[x-u] )   +\newline                                            abs( src2p[x+1] - srcpp[x+1-u] );\newline                            const int diffp2p = abs( srcpp[x-1] - src2p[x-1+u] ) + \newline                                            abs( srcpp[x]   - src2p[x+u] )   + \newline                                            abs( srcpp[x+1] - src2p[x+1+u] );\newline                            const int diffa = diff + diff2pp + diffp2p;\newline                            diffd += diffp2p;\newline                            diffe += diff2pp;\newline                            if( diffa &lt mina )\newline                            {\newline                                dira = u;\newline                                mina = diffa;\newline                            }\newline                        }\newline                        if( __builtin_expect( y &lt height-2, 1) )\newline                        {\newline                            const int diff2nn = abs( src2n[x-1] - srcpn[x-1+u] ) +\newline                                                abs( src2n[x]   - srcpn[x+u] )   +\newline                                                abs( src2n[x+1] - srcpn[x+1+u] );\newline                            const int diffn2n = abs( srcpn[x-1] - src2n[x-1-u] ) +\newline                                                abs( srcpn[x]   - src2n[x-u] )   +\newline                                                abs( srcpn[x+1] - src2n[x+1-u] );\newline                            const int diffc = diff + diff2nn + diffn2n;\newline                            diffd += diff2nn;\newline                            diffe += diffn2n;\newline                            if( diffc &lt minc )\newline                            {\newline                                dirc = u;\newline                                minc = diffc;\newline                            }\newline                        }\newline                        if( diffd &lt mind )\newline                        {\newline                            dird = u;\newline                            mind = diffd;\newline                        }\newline                        if( diffe &lt mine )\newline                        {\newline                            dire = u;\newline                            mine = diffe;\newline                        }\newline                    }\newline                }\newline            }\newline            int order[5], k=0;\newline            if( dira != -5000 ) order[k++] = dira;\newline            if( dirb != -5000 ) order[k++] = dirb;\newline            if( dirc != -5000 ) order[k++] = dirc;\newline            if( dird != -5000 ) order[k++] = dird;\newline            if( dire != -5000 ) order[k++] = dire;\newline            if( k &gt 1 )\newline            {\newline                eedi2_sort_metrics( order, k );\newline                const int mid = ( k &amp 1 ) ? \newline                                    order[k&gt&gt1] :\newline                                    ( order[(k-1)&gt&gt1] + order[k&gt&gt1] + 1 ) &gt&gt 1;\newline                const int tlim = MAX( eedi2_limlut[abs(mid)] &gt&gt 2, 2 );\newline                int sum = 0, count = 0;\newline                for( i = 0; i &lt k; ++i )\newline                {\newline                    if( abs( order[i] - mid ) &lt= tlim )\newline                    {\newline                        ++count;\newline                        sum += order[i];\newline                    }\newline                }\newline                if( count &gt 1 ) \newline                    dstp[x] = 128 + ( (int)( (float)sum / (float)count ) * 4 );\newline                else\newline                    dstp[x] = 128;\newline            }\newline            else dstp[x] = 128;\newline        }\newline        mskpp += msk_pitch;\newline        mskp += msk_pitch;\newline        mskpn += msk_pitch;\newline        src2p += src_pitch;\newline        srcpp += src_pitch;\newline        srcp += src_pitch;\newline        srcpn += src_pitch;\newline        src2n += src_pitch;\newline        dstp += dst_pitch;\newline    }\newline}\newline","\newline Calculates spatial direction vectors for the edges. This is EEDI2&#039s timesink, and can be thought of as YADIF_CHECK on steroids, as both try to discern which angle a given edge follows\newline @param plane The plane of the image being processed, to know to reduce maxd for chroma planes (HandBrake only works with YUV420 video so it is assumed they are half-height)\newline @param mskp Pointer to the source edge mask being read from\newline @param msk_pitch Stride of mskp\newline @param srcp Pointer to the source image being filtered\newline @param src_pitch Stride of srcp\newline @param dstp Pointer to the destination to store the dilated edge mask\newline @param dst_pitch Stride of dstp\newline @param maxd Maximum pixel distance to search (24 is a good default value)\newline @param nt Noise threshold (50 is a good default value)\newline @param height Height of half-height field-sized frame\newline @param width Width of srcp bitmap rows, as opposed to the pdded stride in src_pitch\newline \newline",2234399,curve_tools.c,"float *d3_np_fs(int n, float a[], float b[])\newline\newline{\newline  if(n &lt= 0 || n &gt curvedata_anchors_max) return NULL;\newline\newline  int i;\newline  float *x;\newline  float xmult;\newline  //\newline  //  Check.\newline  //\newline  for(i = 0; i &lt n; i++)\newline  {\newline    if(a[1 + i * 3] == 0.0E+00)\newline    {\newline      return NULL;\newline    }\newline  }\newline  x = (float *)calloc(n, sizeof(float));\newline  // nc_merror(x, &quotd3_np_fs&quot);\newline\newline  for(i = 0; i &lt n; i++)\newline  {\newline    x[i] = b[i];\newline  }\newline\newline  for(i = 1; i &lt n; i++)\newline  {\newline    xmult = a[2 + (i - 1) * 3] / a[1 + (i - 1) * 3];\newline    a[1 + i * 3] = a[1 + i * 3] - xmult * a[0 + i * 3];\newline    x[i] = x[i] - xmult * x[i - 1];\newline  }\newline\newline  x[n - 1] = x[n - 1] / a[1 + (n - 1) * 3];\newline  for(i = n - 2; 0 &lt= i; i--)\newline  {\newline    x[i] = (x[i] - a[0 + (i + 1) * 3] * x[i + 1]) / a[1 + i * 3];\newline  }\newline\newline  return x;\newline}\newline","\newlinePurpose:\newlineD3_NP_FS factors and solves a D3 system.\newlineDiscussion:\newlineThe D3 storage format is used for a tridiagonal matrix.\newlineThe superdiagonal is stored in entries (1,2:N), the diagonal in\newlineentries (2,1:N), and the subdiagonal in (3,1:N-1). Thus, the\newlineoriginal matrix is &quotcollapsed&quot vertically into the array.\newlineThis algorithm requires that each diagonal entry be nonzero.\newlineIt does not use pivoting, and so can fail on systems that\newlineare actually nonsingular.\newlineExample:\newlineHere is how a D3 matrix of order 5 would be stored:\newline A12 A23 A34 A45\newlineA11 A22 A33 A44 A55\newlineA21 A32 A43 A54 \newlineModified:\newline07 January 2005 Shawn Freeman (pure C modifications)\newline15 November 2003 John Burkardt\newlineAuthor:\newlineJohn Burkardt\newlineParameters:\newlineInput, int N, the order of the linear system.\newlineInput/output, float A[3 N].\newlineOn input, the nonzero diagonals of the linear system.\newlineOn output, the data in these vectors has been overwritten\newlineby factorization information.\newlineInput, float B[N], the right hand side.\newlineOutput, float D3_NP_FS[N], the solution of the linear system.\newlineThis is NULL if there was an error because one of the diagonal\newlineentries was zero.\newline \newline",2090390,epilines.cpp,"void icvGetCutPiece(   CvVect64d areaLineCoef1,CvVect64d areaLineCoef2,\newline                    CvPoint2D64d epipole,\newline                    CvSize imageSize,\newline                    CvPoint2D64d* point11,CvPoint2D64d* point12,\newline                    CvPoint2D64d* point21,CvPoint2D64d* point22,\newline                    int* result)\newline{\newline    /* Compute nearest cut line to epipole */\newline    /* Get corners inside sector */\newline    /* Collect all candidate point */\newline\newline    CvPoint2D64d candPoints[8];\newline    CvPoint2D64d midPoint = {0, 0};\newline    int numPoints = 0;\newline    int res;\newline    int i;\newline\newline    double cutLine1[3];\newline    double cutLine2[3];\newline\newline    /* Find middle line of sector */\newline    double midLine[3]={0,0,0};\newline\newline\newline    /* Different way  */\newline    CvPoint2D64d pointOnLine1;  pointOnLine1.x = pointOnLine1.y = 0;\newline    CvPoint2D64d pointOnLine2;  pointOnLine2.x = pointOnLine2.y = 0;\newline\newline    CvPoint2D64d start1,end1;\newline\newline    icvGetCrossRectDirect( imageSize,\newline                        areaLineCoef1[0],areaLineCoef1[1],areaLineCoef1[2],\newline                        &ampstart1,&ampend1,&ampres);\newline    if( res &gt 0 )\newline    {\newline        pointOnLine1 = start1;\newline    }\newline\newline    icvGetCrossRectDirect( imageSize,\newline                        areaLineCoef2[0],areaLineCoef2[1],areaLineCoef2[2],\newline                        &ampstart1,&ampend1,&ampres);\newline    if( res &gt 0 )\newline    {\newline        pointOnLine2 = start1;\newline    }\newline\newline    icvGetMiddleAnglePoint(epipole,pointOnLine1,pointOnLine2,&ampmidPoint);\newline\newline    icvGetCoefForPiece(epipole,midPoint,&ampmidLine[0],&ampmidLine[1],&ampmidLine[2],&ampres);\newline\newline    /* Test corner points */\newline    CvPoint2D64d cornerPoint;\newline    CvPoint2D64d tmpPoints[2];\newline\newline    cornerPoint.x = 0;\newline    cornerPoint.y = 0;\newline    icvTestPoint( cornerPoint, areaLineCoef1, areaLineCoef2, epipole, &ampres);\newline    if( res == 1 )\newline    {/* Add point */\newline        candPoints[numPoints] = cornerPoint;\newline        numPoints++;\newline    }\newline\newline    cornerPoint.x = imageSize.width;\newline    cornerPoint.y = 0;\newline    icvTestPoint( cornerPoint, areaLineCoef1, areaLineCoef2, epipole, &ampres);\newline    if( res == 1 )\newline    {/* Add point */\newline        candPoints[numPoints] = cornerPoint;\newline        numPoints++;\newline    }\newline\newline    cornerPoint.x = imageSize.width;\newline    cornerPoint.y = imageSize.height;\newline    icvTestPoint( cornerPoint, areaLineCoef1, areaLineCoef2, epipole, &ampres);\newline    if( res == 1 )\newline    {/* Add point */\newline        candPoints[numPoints] = cornerPoint;\newline        numPoints++;\newline    }\newline\newline    cornerPoint.x = 0;\newline    cornerPoint.y = imageSize.height;\newline    icvTestPoint( cornerPoint, areaLineCoef1, areaLineCoef2, epipole, &ampres);\newline    if( res == 1 )\newline    {/* Add point */\newline        candPoints[numPoints] = cornerPoint;\newline        numPoints++;\newline    }\newline\newline    /* Find cross line 1 with image border */\newline    icvGetCrossRectDirect( imageSize,\newline                        areaLineCoef1[0],areaLineCoef1[1],areaLineCoef1[2],\newline                        &amptmpPoints[0], &amptmpPoints[1],\newline                        &ampres);\newline    for( i = 0; i &lt res; i++ )\newline    {\newline        candPoints[numPoints++] = tmpPoints[i];\newline    }\newline\newline    /* Find cross line 2 with image border */\newline    icvGetCrossRectDirect( imageSize,\newline                        areaLineCoef2[0],areaLineCoef2[1],areaLineCoef2[2],\newline                        &amptmpPoints[0], &amptmpPoints[1],\newline                        &ampres);\newline\newline    for( i = 0; i &lt res; i++ )\newline    {\newline        candPoints[numPoints++] = tmpPoints[i];\newline    }\newline\newline    if( numPoints &lt 2 )\newline    {\newline        *result = 0;\newline        return;/* Error. Not enought points */\newline    }\newline    /* Project all points to middle line and get max and min */\newline\newline    CvPoint2D64d projPoint;\newline    CvPoint2D64d minPoint; minPoint.x = minPoint.y = FLT_MAX;\newline    CvPoint2D64d maxPoint; maxPoint.x = maxPoint.y = -FLT_MAX;\newline\newline\newline    double dist;\newline    double maxDist = 0;\newline    double minDist = 10000000;\newline\newline\newline    for( i = 0; i &lt numPoints; i++ )\newline    {\newline        icvProjectPointToDirect(candPoints[i], midLine, &ampprojPoint);\newline        icvGetPieceLength(epipole,projPoint,&ampdist);\newline        if( dist &lt minDist)\newline        {\newline            minDist = dist;\newline            minPoint = projPoint;\newline        }\newline\newline        if( dist &gt maxDist)\newline        {\newline            maxDist = dist;\newline            maxPoint = projPoint;\newline        }\newline    }\newline\newline    /* We know maximum and minimum points. Now we can compute cut lines */\newline\newline    icvGetNormalDirect(midLine,minPoint,cutLine1);\newline    icvGetNormalDirect(midLine,maxPoint,cutLine2);\newline\newline    /* Test for begin of line. */\newline    CvPoint2D64d tmpPoint2;\newline\newline    /* Get cross with */\newline    icvGetCrossDirectDirect(areaLineCoef1,cutLine1,point11,&ampres);\newline    icvGetCrossDirectDirect(areaLineCoef2,cutLine1,point12,&ampres);\newline\newline    icvGetCrossDirectDirect(areaLineCoef1,cutLine2,point21,&ampres);\newline    icvGetCrossDirectDirect(areaLineCoef2,cutLine2,point22,&ampres);\newline\newline    if( epipole.x &gt imageSize.width * 0.5 )\newline    {/* Need to change points */\newline        tmpPoint2 = *point11;\newline        *point11 = *point21;\newline        *point21 = tmpPoint2;\newline\newline        tmpPoint2 = *point12;\newline        *point12 = *point22;\newline        *point22 = tmpPoint2;\newline    }\newline\newline    return;\newline}\newline",Get cut line for one image \newline,6267100,scan_scr.c,"static void fmt_scan_entry(struct scan_entry *cur, char buf[], size_t buflen)\newline{\newline	size_t len = 0;\newline\newline	if (cur-&gtbss_signal) {\newline		float sig_qual, sig_qual_max;\newline\newline		if (cur-&gtbss_signal_qual) {\newline			/* BSS_SIGNAL_UNSPEC is scaled 0..100 */\newline			sig_qual     = cur-&gtbss_signal_qual;\newline			sig_qual_max = 100;\newline		} else {\newline			if (cur-&gtbss_signal &lt -110)\newline				sig_qual = 0;\newline			else if (cur-&gtbss_signal &gt -40)\newline				sig_qual = 70;\newline			else\newline				sig_qual = cur-&gtbss_signal + 110;\newline			sig_qual_max = 70;\newline		}\newline		len += snprintf(buf + len, buflen - len, &quot%3.0f%%, %d dBm&quot,\newline				(1E2 * sig_qual)/ sig_qual_max, cur-&gtbss_signal);\newline	} else if (cur-&gtbss_signal_qual) {\newline		len += snprintf(buf + len, buflen - len, &quot%2d/%d&quot,\newline				cur-&gtbss_signal_qual, 100);\newline	} else {\newline		len += snprintf(buf + len, buflen - len, &quot? dBm&quot);\newline	}\newline\newline	if (cur-&gtchan &gt= 0)\newline		len += snprintf(buf + len, buflen - len, &quot, %s %3d, %d MHz&quot,\newline				cur-&gtfreq &lt 5e6 ? &quotch&quot : &quotCH&quot,\newline				cur-&gtchan, cur-&gtfreq);\newline	else\newline		len += snprintf(buf + len, buflen - len, &quot, %g GHz&quot,\newline				cur-&gtfreq / 1e3);\newline\newline	if (cur-&gtbss_capa &amp WLAN_CAPABILITY_ESS) {\newline		if (cur-&gtbss_sta_count || cur-&gtbss_chan_usage &gt 2) {\newline			if (cur-&gtbss_sta_count)\newline				len += snprintf(buf + len, buflen - len, &quot %u sta&quot, cur-&gtbss_sta_count);\newline			if (cur-&gtbss_chan_usage &gt 2) /* 1% is 2.55 */\newline				len += snprintf(buf + len, buflen - len, &quot%s %.0f%% chan&quot,\newline						cur-&gtbss_sta_count? &quot,&quot : &quot&quot, (1e2 * cur-&gtbss_chan_usage)/2.55e2);\newline		} else {\newline			len += snprintf(buf + len, buflen - len, &quot ESS&quot);\newline		}\newline		if (cur-&gtbss_capa &amp WLAN_CAPABILITY_RADIO_MEASURE)\newline			len += snprintf(buf + len, buflen - len, &quot, Radio Measure&quot);\newline		if (cur-&gtbss_capa &amp WLAN_CAPABILITY_SPECTRUM_MGMT)\newline			len += snprintf(buf + len, buflen - len, &quot, Spectrum Mgmt&quot);\newline	} else if (cur-&gtbss_capa &amp WLAN_CAPABILITY_IBSS) {\newline		len += snprintf(buf + len, buflen - len, &quot IBSS&quot);\newline	}\newline}\newline",\newline Sanitize and format single scan entry as a string.\newline @cur: entry to format\newline @buf: buffer to put results into\newline @buflen: length of @buf\newline \newline,5944587,chassis.c,"int group_nodes(ibnd_fabric_t * fabric)\newline{\newline	ibnd_node_t *node;\newline	int chassisnum = 0;\newline	ibnd_chassis_t *chassis;\newline	ibnd_chassis_t *ch, *ch_next;\newline	chassis_scan_t chassis_scan;\newline	int vendor_id;\newline\newline	chassis_scan.first_chassis = NULL;\newline	chassis_scan.current_chassis = NULL;\newline	chassis_scan.last_chassis = NULL;\newline\newline	/* first pass on switches and build for every Voltaire node */\newline	/* an appropriate chassis record (slotnum and position) */\newline	/* according to internal connectivity */\newline	/* not very efficient but clear code so... */\newline	for (node = fabric-&gtswitches; node; node = node-&gttype_next) {\newline\newline		vendor_id = mad_get_field(node-&gtinfo, 0,IB_NODE_VENDORID_F);\newline\newline		if (vendor_id == VTR_VENDOR_ID\newline		    &amp&amp fill_voltaire_chassis_record(node))\newline			goto cleanup;\newline		else if (vendor_id == MLX_VENDOR_ID\newline			&amp&amp fill_mellanox_chassis_record(node))\newline			goto cleanup;\newline\newline	}\newline\newline	/* separate every Voltaire chassis from each other and build linked list of them */\newline	/* algorithm: catch spine and find all surrounding nodes */\newline	for (node = fabric-&gtswitches; node; node = node-&gttype_next) {\newline		if (mad_get_field(node-&gtinfo, 0,\newline				  IB_NODE_VENDORID_F) != VTR_VENDOR_ID)\newline			continue;\newline		if (!node-&gtch_found\newline		    || (node-&gtchassis &amp&amp node-&gtchassis-&gtchassisnum)\newline		    || !is_spine(node))\newline			continue;\newline		if (add_chassis(&ampchassis_scan))\newline			goto cleanup;\newline		chassis_scan.current_chassis-&gtchassisnum = ++chassisnum;\newline		if (build_chassis(node, chassis_scan.current_chassis))\newline			goto cleanup;\newline	}\newline\newline	/* now make pass on nodes for chassis which are not Voltaire */\newline	/* grouped by common SystemImageGUID */\newline	for (node = fabric-&gtnodes; node; node = node-&gtnext) {\newline		if (mad_get_field(node-&gtinfo, 0,\newline				  IB_NODE_VENDORID_F) == VTR_VENDOR_ID)\newline			continue;\newline		if (mad_get_field64(node-&gtinfo, 0, IB_NODE_SYSTEM_GUID_F)) {\newline			chassis = find_chassisguid(fabric, node);\newline			if (chassis)\newline				chassis-&gtnodecount++;\newline			else {\newline				/* Possible new chassis */\newline				if (add_chassis(&ampchassis_scan))\newline					goto cleanup;\newline				chassis_scan.current_chassis-&gtchassisguid =\newline				    get_chassisguid(node);\newline				chassis_scan.current_chassis-&gtnodecount = 1;\newline				if (!fabric-&gtchassis)\newline					fabric-&gtchassis = chassis_scan.first_chassis;\newline			}\newline		}\newline	}\newline\newline	/* now, make another pass to see which nodes are part of chassis */\newline	/* (defined as chassis-&gtnodecount &gt 1) */\newline	for (node = fabric-&gtnodes; node; node = node-&gtnext) {\newline\newline		vendor_id = mad_get_field(node-&gtinfo, 0,IB_NODE_VENDORID_F);\newline\newline		if (vendor_id == VTR_VENDOR_ID)\newline			continue;\newline		if (mad_get_field64(node-&gtinfo, 0, IB_NODE_SYSTEM_GUID_F)) {\newline			chassis = find_chassisguid(fabric, node);\newline			if (chassis &amp&amp chassis-&gtnodecount &gt 1) {\newline				if (!chassis-&gtchassisnum)\newline					chassis-&gtchassisnum = ++chassisnum;\newline				if (!node-&gtch_found) {\newline					node-&gtch_found = 1;\newline					add_node_to_chassis(chassis, node);\newline				}\newline				else if (vendor_id == MLX_VENDOR_ID){\newline					insert_mellanox_line_and_spine(node, chassis);\newline				}\newline			}\newline		}\newline	}\newline\newline	fabric-&gtchassis = chassis_scan.first_chassis;\newline	return 0;\newline\newlinecleanup:\newline	ch = chassis_scan.first_chassis;\newline	while (ch) {\newline		ch_next = ch-&gtnext;\newline		free(ch);\newline		ch = ch_next;\newline	}\newline	fabric-&gtchassis = NULL;\newline	return -1;\newline}\newline","\newline Main grouping function\newline Algorithm:\newline 1. pass on every Voltaire node\newline 2. catch spine chip for every Voltaire node\newline 2.1 build/interpolate chassis around this chip\newline 2.2 go to 1.\newline 3. pass on non Voltaire nodes (SystemImageGUID based grouping)\newline 4. now group non Voltaire nodes by SystemImageGUID\newline Returns:\newline 0 on success, -1 on failure\newline \newline",on,on,on,,,on,,,,,,,,on,,on,on,,,,,,,,,,,,,,,,,,,,,,,,,,{},{},{},initialize the SCSI chip ctrl registers,Starts engine operation.,{},see genx.h for details,"\return FSSpec on MAC, else char",Calculates spatial direction vectors for the edges.,The D3 storage format is used for a tridiagonal matrix.,Get cut line for one image,Copy a key from one table to another.,Sanitize and format single scan entry as a string.,{},Returns for a specific symbol,{},{},Load an image from the named file.,Parse the ndef record header,Read a whole bunch of textual leafes,This file will read image paths from a theme file.,x,
