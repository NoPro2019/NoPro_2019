"HITId","HITTypeId","Title","Description","Keywords","Reward","CreationTime","MaxAssignments","RequesterAnnotation","AssignmentDurationInSeconds","AutoApprovalDelayInSeconds","Expiration","NumberOfSimilarHITs","LifetimeInSeconds","AssignmentId","WorkerId","AssignmentStatus","AcceptTime","SubmitTime","AutoApprovalTime","ApprovalTime","RejectionTime","RequesterFeedback","WorkTimeInSeconds","LifetimeApprovalRate","Last30DaysApprovalRate","Last7DaysApprovalRate","Input.fid_1","Input.file_name_1","Input.function_body_1","Input.comment_body_1","Input.fid_2","Input.file_name_2","Input.function_body_2","Input.comment_body_2","Input.fid_3","Input.file_name_3","Input.function_body_3","Input.comment_body_3","Input.fid_4","Input.file_name_4","Input.function_body_4","Input.comment_body_4","Input.fid_5","Input.file_name_5","Input.function_body_5","Input.comment_body_5","Input.fid_6","Input.file_name_6","Input.function_body_6","Input.comment_body_6","Input.fid_7","Input.file_name_7","Input.function_body_7","Input.comment_body_7","Input.fid_8","Input.file_name_8","Input.function_body_8","Input.comment_body_8","Input.fid_9","Input.file_name_9","Input.function_body_9","Input.comment_body_9","Input.fid_10","Input.file_name_10","Input.function_body_10","Input.comment_body_10","Input.fid_11","Input.file_name_11","Input.function_body_11","Input.comment_body_11","Input.fid_12","Input.file_name_12","Input.function_body_12","Input.comment_body_12","Input.fid_13","Input.file_name_13","Input.function_body_13","Input.comment_body_13","Input.fid_14","Input.file_name_14","Input.function_body_14","Input.comment_body_14","Input.fid_15","Input.file_name_15","Input.function_body_15","Input.comment_body_15","Input.fid_16","Input.file_name_16","Input.function_body_16","Input.comment_body_16","Input.fid_17","Input.file_name_17","Input.function_body_17","Input.comment_body_17","Input.fid_18","Input.file_name_18","Input.function_body_18","Input.comment_body_18","Input.fid_19","Input.file_name_19","Input.function_body_19","Input.comment_body_19","Input.fid_20","Input.file_name_20","Input.function_body_20","Input.comment_body_20","Input.fid_21","Input.file_name_21","Input.function_body_21","Input.comment_body_21","Answer.empty_1","Answer.empty_10","Answer.empty_11","Answer.empty_12","Answer.empty_13","Answer.empty_14","Answer.empty_15","Answer.empty_16","Answer.empty_17","Answer.empty_18","Answer.empty_19","Answer.empty_2","Answer.empty_20","Answer.empty_21","Answer.empty_3","Answer.empty_4","Answer.empty_5","Answer.empty_6","Answer.empty_7","Answer.empty_8","Answer.empty_9","Answer.multiple_1","Answer.multiple_10","Answer.multiple_11","Answer.multiple_12","Answer.multiple_13","Answer.multiple_14","Answer.multiple_15","Answer.multiple_16","Answer.multiple_17","Answer.multiple_18","Answer.multiple_19","Answer.multiple_2","Answer.multiple_20","Answer.multiple_21","Answer.multiple_3","Answer.multiple_4","Answer.multiple_5","Answer.multiple_6","Answer.multiple_7","Answer.multiple_8","Answer.multiple_9","Answer.tag_1","Answer.tag_10","Answer.tag_11","Answer.tag_12","Answer.tag_13","Answer.tag_14","Answer.tag_15","Answer.tag_16","Answer.tag_17","Answer.tag_18","Answer.tag_19","Answer.tag_2","Answer.tag_20","Answer.tag_21","Answer.tag_3","Answer.tag_4","Answer.tag_5","Answer.tag_6","Answer.tag_7","Answer.tag_8","Answer.tag_9","Approve","Reject"
"31SIZS5W59FJDDTKZ93LP1JQVIJRQG","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","338JKRMM26ZGON5T4AZ6AGY4KF7AH7","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:36:29 PDT 2019","Wed Apr 17 14:41:43 PDT 2019","Fri Apr 19 14:41:43 PDT 2019","2019-04-19 21:42:21 UTC","","","314","100% (27/27)","100% (27/27)","100% (27/27)","2806215","map.c","static void map_get_dist_air_mask( int ax, int ay, short *dist_air_mask )\newline{\newline    int x, y;\newline    for ( x = 0; x &lt map_w; x++ )\newline        for ( y = 0; y &lt map_h; y++ ) {\newline            int d = get_dist( ax, ay, x, y ) - 1;\newline            if (d &lt dist_air_mask[y*map_w+x])\newline                dist_air_mask[y*map_w+x] = d;\newline        }\newline    dist_air_mask[ay*map_w+ax] = 0;\newline}\newline","\newline====================================================================\newlineSets the distance mask beginning with the airfield at (ax, ay).\newline====================================================================\newline \newline","896366","ospdest.c","OSPTBOOL OSPPDestHasCallId( /* returns non-zero if exists */\newline    OSPT_DEST *ospvDest)    /* destination in question */\newline{\newline    OSPTBOOL has = OSPC_FALSE;\newline\newline    if (ospvDest != OSPC_OSNULL) {\newline        has = (ospvDest-&gtCallId != OSPC_OSNULL);\newline    }\newline\newline    return has;\newline}\newline","\newline OSPPDestHasCallId() - does a destination have a Call ID?\newline \newline","4599862","libcsystem_string.c","int libcsystem_string_size_to_utf8_string(\newline     const libcstring_system_character_t *string,\newline     size_t string_size,\newline     size_t *utf8_string_size,\newline     libcerror_error_t **error )\newline{\newline	static char *function = &quotlibcsystem_string_size_to_utf8_string&quot;\newline\newline	if( string == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid string.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( string_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid string size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( utf8_string_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#if defined( LIBCSTRING_HAVE_WIDE_SYSTEM_CHARACTER )\newline#if SIZEOF_WCHAR_T == 4\newline	if( libuna_utf8_string_size_from_utf32(\newline	     (libuna_utf32_character_t *) string,\newline	     string_size,\newline	     utf8_string_size,\newline	     error ) != 1 )\newline#elif SIZEOF_WCHAR_T == 2\newline	if( libuna_utf8_string_size_from_utf16(\newline	     (libuna_utf16_character_t *) string,\newline	     string_size,\newline	     utf8_string_size,\newline	     error ) != 1 )\newline#endif\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_GENERIC,\newline		 &quot%s: unable to determine UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#else\newline	if( libclocale_codepage == 0 )\newline	{\newline		*utf8_string_size = 1 + libcstring_system_string_length(\newline		                         string );\newline	}\newline	else if( libuna_utf8_string_size_from_byte_stream(\newline	          (uint8_t *) string,\newline	          string_size,\newline	          libclocale_codepage,\newline	          utf8_string_size,\newline	          error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_GENERIC,\newline		 &quot%s: unable to determine UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#endif\newline	return( 1 );\newline}\newline","Determines the UTF-8 string size from the system string\newline Returns 1 if successful or -1 on error\newline \newline","245106","test_audio_analyzer.c","static int TestDetectSinglePhaseError( double sampleRate, int cycleSize, int latencyFrames, int glitchPosition, int framesAdded )\newline{\newline	int result = 0;\newline	PaQaRecording     recording;	\newline	PaQaTestTone testTone;\newline	PaQaAnalysisResult analysisResult = { 0.0 };\newline	int framesDropped = 0;\newline    int maxFrames = ((int)sampleRate) * 2;\newline\newline	testTone.samplesPerFrame = 1;\newline	testTone.sampleRate = sampleRate;\newline	testTone.frequency = sampleRate / cycleSize;\newline	testTone.amplitude = 0.5;\newline	testTone.startDelay = latencyFrames;\newline	\newline	result = PaQa_InitializeRecording( &amprecording, maxFrames, (int) sampleRate );\newline	QA_ASSERT_EQUALS( &quotPaQa_InitializeRecording failed&quot, 0, result );\newline	\newline	MakeRecordingWithAddedFrames( &amprecording, &amptestTone, glitchPosition, framesAdded );\newline	\newline	PaQa_AnalyseRecording( &amprecording, &amptestTone, &ampanalysisResult );\newline	\newline	if( framesAdded &lt 0 )\newline	{\newline		framesDropped = -framesAdded;\newline		framesAdded = 0;\newline	}\newline	\newline#if PRINT_REPORTS\newline	printf(&quot\\n=== Dropped Frame Analysis ===================\\n&quot);\newline	printf(&quot                        expected      actual\\n&quot);\newline	printf(&quot             latency: %10.3f  %10.3f\\n&quot, (double)latencyFrames, analysisResult.latency );\newline	printf(&quot    num added frames: %10.3f  %10.3f\\n&quot, (double)framesAdded, analysisResult.numAddedFrames );\newline	printf(&quot     added frames at: %10.3f  %10.3f\\n&quot, (double)glitchPosition, analysisResult.addedFramesPosition );\newline	printf(&quot  num dropped frames: %10.3f  %10.3f\\n&quot, (double)framesDropped, analysisResult.numDroppedFrames );\newline	printf(&quot   dropped frames at: %10.3f  %10.3f\\n&quot, (double)glitchPosition, analysisResult.droppedFramesPosition );\newline#endif\newline	\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording latency&quot, latencyFrames, analysisResult.latency, 0.5 );\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording framesAdded&quot, framesAdded, analysisResult.numAddedFrames, 1.0 );\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording framesDropped&quot, framesDropped, analysisResult.numDroppedFrames, 1.0 );\newline//	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording glitchPosition&quot, glitchPosition, analysisResult.glitchPosition, cycleSize );\newline\newline	PaQa_TerminateRecording( &amprecording );\newline	return 0;\newline	\newlineerror:\newline	PaQa_TerminateRecording( &amprecording);	\newline	return 1;\newline}	\newline","\newline Detect one phase error in a recording.\newline \newline","774095","libdm-report.c","static int _cmp_field_string_list_subset_all(const struct str_list_sort_value *val,\newline					     const struct selection_str_list *sel)\newline{\newline	unsigned int sel_list_size = dm_list_size(&ampsel-&gtstr_list.list);\newline	struct dm_str_list *sel_item;\newline	unsigned int i, last_found = 1;\newline	int r = 0;\newline\newline	if (!val-&gtitems[0].len) {\newline		if (sel_list_size == 1) {\newline			/* match blank string list with selection defined as blank string only */\newline			sel_item = dm_list_item(dm_list_first(&ampsel-&gtstr_list.list), struct dm_str_list);\newline			return !strcmp(sel_item-&gtstr, &quot&quot);\newline		}\newline		return 0;\newline	}\newline\newline	/* check selection is a subset of the value */\newline	dm_list_iterate_items(sel_item, &ampsel-&gtstr_list.list) {\newline		r = 0;\newline		for (i = last_found; i &lt= val-&gtitems[0].len; i++) {\newline			if ((strlen(sel_item-&gtstr) == val-&gtitems[i].len) &amp&amp\newline			    !strncmp(sel_item-&gtstr, val-&gtvalue + val-&gtitems[i].pos, val-&gtitems[i].len)) {\newline				last_found = i;\newline				r = 1;\newline			}\newline		}\newline		if (!r)\newline			break;\newline	}\newline\newline	return r;\newline}\newline","Matches if all items from selection string list match a subset of list value. \newline","512815","fgui.c","int qstrcmp(const void *l, const void *r)\newline{\newline	char *left = NULL;\newline	char *right = NULL;\newline\newline	left = *(char**)l;\newline	right = *(char**)r;\newline\newline	return strcmp(left,right);\newline}\newline","a glorified strcmp for qsort \newline","3468967","profiles.c","static int set_show_profiles(metro_t* metro,\newline                             const char* option_name _U_,\newline			     const char* show_profiles)\newline{\newline  if (metro) {\newline    gtk_toggle_action_set_active(metro-&gtprofiles_action,\newline      !strcmp(show_profiles, &quotyes&quot) || !strcmp(show_profiles, &quot1&quot));\newline    return 0;\newline  } else {\newline    return -1;\newline  }\newline}\newline","option system callback for setting profiles show option \newline","4950733","graph.c","static void graph_calls(struct entrypoint *ep, int internal)\newline{\newline	struct basic_block *bb;\newline	struct instruction *insn;\newline\newline	show_ident(ep-&gtname-&gtident);\newline	stream_name(ep-&gtentry-&gtbb-&gtpos.stream);\newline\newline	FOR_EACH_PTR(ep-&gtbbs, bb) {\newline		if (!bb)\newline			continue;\newline		if (!bb-&gtparents &amp&amp !bb-&gtchildren &amp&amp !bb-&gtinsns &amp&amp verbose &lt 2)\newline			continue;\newline\newline		FOR_EACH_PTR(bb-&gtinsns, insn) {\newline			if (insn-&gtopcode == OP_CALL &amp&amp\newline			    internal == !(insn-&gtfunc-&gtsym-&gtctype.modifiers &amp MOD_EXTERN)) {\newline\newline				/* Find the symbol for the callee&#039s definition */\newline				struct symbol * sym;\newline				if (insn-&gtfunc-&gttype == PSEUDO_SYM) {\newline					for (sym = insn-&gtfunc-&gtsym-&gtident-&gtsymbols;\newline					     sym; sym = sym-&gtnext_id) {\newline						if (sym-&gtnamespace &amp NS_SYMBOL &amp&amp sym-&gtep)\newline							break;\newline					}\newline\newline					if (sym)\newline						printf(&quotbb%p -&gt bb%p&quot\newline						       &quot[label=%d,line=%d,col=%d,op=call,style=bold,weight=30];\\n&quot,\newline						       bb, sym-&gtep-&gtentry-&gtbb,\newline						       insn-&gtpos.line, insn-&gtpos.line, insn-&gtpos.pos);\newline					else\newline						printf(&quotbb%p -&gt \\&quot%s\\&quot &quot\newline						       &quot[label=%d,line=%d,col=%d,op=extern,style=dashed];\\n&quot,\newline						       bb, show_pseudo(insn-&gtfunc),\newline						       insn-&gtpos.line, insn-&gtpos.line, insn-&gtpos.pos);\newline				}\newline			}\newline		} END_FOR_EACH_PTR(insn);\newline	} END_FOR_EACH_PTR(bb);\newline}\newline","Insert edges for intra- or inter-file calls, depending on the value\newline of internal. Bold edges are used for calls with destinations;\newline dashed for calls to external functions \newline","1628921","magfreq_analysis~.c","void magfreq_analysis_tilde_setup(void)\newline{\newline	magfreq_analysis_class = class_new(gensym(&quotmagfreq_analysis~&quot), (t_newmethod)magfreq_analysis_new, \newline						   (t_method)magfreq_analysis_free ,sizeof(t_magfreq_analysis), 0,A_GIMME,0);\newline	CLASS_MAINSIGNALIN(magfreq_analysis_class, t_magfreq_analysis, x_f);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_dsp, gensym(&quotdsp&quot), 0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_mute, gensym(&quotmute&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_bypass, gensym(&quotbypass&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_highfreq, gensym(&quothighfreq&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_lowfreq, gensym(&quotlowfreq&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_overlap, gensym(&quotoverlap&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_winfac, gensym(&quotwinfac&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_fftinfo, gensym(&quotfftinfo&quot),0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_assist, gensym(&quotassist&quot), 0);\newline	post(&quot%s %s&quot,OBJECT_NAME, LYONPOTPOURRI_MSG);\newline}\newline","Pd Initialization \newline","2970316","folder.c","static char *get_parent_folder(const char *p)\newline{\newline	const char *q;\newline\newline	q=strrchr(p, &#039.&#039);\newline\newline	if (q)\newline	{\newline		char	*s;\newline\newline		s=malloc(q-p+1);\newline		if (!s)	enomem();\newline		memcpy(s, p, q-p);\newline		s[q-p]=0;\newline		return (s);\newline	}\newline	return (strdup(&quot&quot));\newline}\newline","\newline If we&#039re currently showing (INBOX|shared|#shared).foo.bar hierarchy, return\newline &quotx.foo&quot. If we&#039re currently showing (INBOX|shared|#shared).foo, return\newline an empty string.\newline \newline","4206722","w32svrapi.c","void w32_set_service_cwd(void)\newline{\newline   char exe_name[MAX_PATH+1];\newline   char dir_name[MAX_PATH+1];\newline   char *pszFile = NULL;\newline\newline   /* Get the exe name and path of the service */\newline   if (GetModuleFileName(NULL, exe_name, MAX_PATH))\newline   {\newline      /* Ask the API to tell us where the filename portion starts */\newline      if (GetFullPathName(exe_name, MAX_PATH, dir_name, &amppszFile))\newline      {\newline         /* remove the filename from the string */\newline         if (pszFile != NULL)\newline         {\newline            *pszFile = &#039\\0&#039;\newline            /* We have just a directory path now, so make it current */\newline            SetCurrentDirectory(dir_name);\newline         }\newline      }\newline   }\newline}\newline","\newline \newline Function : w32_set_service_cwd\newline \newline Description : Simple function to change the current directory to\newline the same location as the service executable.\newline \newline Parameters : void\newline \newline Returns : void\newline \newline \newline","1892705","shade.c","gboolean visu_gl_ext_shade_setMinMax(VisuGlExtShade *shade, float minV, float maxV)\newline{\newline  g_return_val_if_fail(VISU_IS_GL_EXT_SHADE(shade), FALSE);\newline\newline  if (shade-&gtpriv-&gtminMax[0] == minV &amp&amp shade-&gtpriv-&gtminMax[1] == maxV)\newline    return FALSE;\newline\newline  shade-&gtpriv-&gtminMax[0] = minV;\newline  shade-&gtpriv-&gtminMax[1] = maxV;\newline\newline  VISU_GL_EXT_FRAME(shade)-&gtisBuilt = FALSE;\newline  return visu_gl_ext_getActive(VISU_GL_EXT(shade));\newline}\newline","\newline visu_gl_ext_shade_setMinMax:\newline @shade: the #VisuGlExtShade to update.\newline @minV: a value.\newline @maxV: another value.\newline \newline Change the minimum and maximum values used on the legend.\newline \newline Since: 3.7\newline \newline Returns: TRUE if visu_gl_ext_frame_draw() should be called.\newline \newline","1082559","input_dvb.c","static void pthread_sleep(int seconds) {\newline    pthread_mutex_t dummy_mutex;\newline    static pthread_cond_t dummy_cond = PTHREAD_COND_INITIALIZER;\newline    struct timespec timeout;\newline\newline    /* Create a dummy mutex which doesn&#039t unlock for sure while waiting. */\newline    pthread_mutex_init(&ampdummy_mutex, NULL);\newline    pthread_mutex_lock(&ampdummy_mutex);\newline\newline    /* Create a dummy condition variable. */\newline/*    pthread_cond_init(&ampdummy_cond, NULL); */\newline\newline    timeout.tv_sec = time(NULL) + seconds;\newline    timeout.tv_nsec = 0;\newline\newline    pthread_cond_timedwait(&ampdummy_cond, &ampdummy_mutex, &amptimeout);\newline\newline/*    pthread_cond_destroy(&ampdummy_cond); */\newline    pthread_mutex_unlock(&ampdummy_mutex);\newline    pthread_mutex_destroy(&ampdummy_mutex);\newline}\newline","Sleep routine for pthread (hackish). \newline","1786865","md5.c","static void MD5_Update (MD5_CTX *ctx, unsigned char const *buf, unsigned int len)\newline{\newline    unsigned int t;\newline\newline    // Update bitcount\newline    t = ctx-&gtbits[0];\newline\newline	if ((ctx-&gtbits[0] = t + ((unsigned int)len &lt&lt 3)) &lt t)\newline        ctx-&gtbits[1]++;         // Carry from low to high\newline\newline    ctx-&gtbits[1] += len &gt&gt 29;\newline    t = (t &gt&gt 3)&amp 0x3f;        // Bytes already in shsInfo-&gtdata\newline\newline    // Handle any leading odd-sized chunks\newline    if (t)\newline	{\newline        unsigned char *p = (unsigned char *)ctx-&gtin + t;\newline\newline        t = 64 - t;\newline\newline        if (len &lt t)\newline		{\newline            memcpy(p, buf, len);\newline            return;\newline        }\newline\newline        memcpy(p, buf, t);\newline        MD5_Transform(ctx-&gtstate, (unsigned int *)ctx-&gtin);\newline        buf += t;\newline        len -= t;\newline    }\newline\newline	// Process data in 64-byte chunks\newline    while (len &gt= 64)\newline	{\newline        memcpy(ctx-&gtin, buf, 64);\newline        MD5_Transform(ctx-&gtstate, (unsigned int *)ctx-&gtin);\newline        buf += 64;\newline        len -= 64;\newline    }\newline\newline    // Handle any remaining bytes of data.\newline    memcpy(ctx-&gtin, buf, len);\newline}\newline","\newline===================\newlineMD5_Update\newlineMD5 block update operation. Continues an MD5 message-digest operation,\newlineprocessing another message block, and updating the context.\newline===================\newline \newline","6007310","genrcbin.c","static void ClearBloadGenerics(\newline  void *theEnv)\newline  {\newline   register long i;\newline   unsigned long space;\newline\newline   space = (unsigned long) (sizeof(DEFGENERIC_MODULE) * DefgenericBinaryData(theEnv)-&gtModuleCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtModuleArray,space);\newline   DefgenericBinaryData(theEnv)-&gtModuleArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtModuleCount = 0L;\newline\newline   for (i = 0 ; i &lt DefgenericBinaryData(theEnv)-&gtGenericCount ; i++)\newline     UnmarkConstructHeader(theEnv,&ampDefgenericBinaryData(theEnv)-&gtDefgenericArray[i].header);\newline\newline   space = (unsigned long) (sizeof(DEFGENERIC) * DefgenericBinaryData(theEnv)-&gtGenericCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtDefgenericArray,space);\newline   DefgenericBinaryData(theEnv)-&gtDefgenericArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtGenericCount = 0L;\newline\newline   space = (unsigned long) (sizeof(DEFMETHOD) * DefgenericBinaryData(theEnv)-&gtMethodCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtMethodArray,space);\newline   DefgenericBinaryData(theEnv)-&gtMethodArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtMethodCount = 0L;\newline\newline   space = (unsigned long) (sizeof(RESTRICTION) * DefgenericBinaryData(theEnv)-&gtRestrictionCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtRestrictionArray,space);\newline   DefgenericBinaryData(theEnv)-&gtRestrictionArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtRestrictionCount = 0L;\newline\newline#if ! OBJECT_SYSTEM\newline   for (i = 0 ; i &lt DefgenericBinaryData(theEnv)-&gtTypeCount ; i++)\newline     DecrementIntegerCount(theEnv,(INTEGER_HN *) DefgenericBinaryData(theEnv)-&gtTypeArray[i]);\newline#endif\newline   space = (unsigned long) (sizeof(void *) * DefgenericBinaryData(theEnv)-&gtTypeCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtTypeArray,space);\newline   DefgenericBinaryData(theEnv)-&gtTypeArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtTypeCount = 0L;\newline  }\newline","\newlineNAME : ClearBloadGenerics\newlineDESCRIPTION : Release all binary-loaded generic function\newlinestructure arrays\newlineResets generic function list to NULL\newlineINPUTS : None\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Memory cleared\newlineNOTES : Generic function name symbol counts decremented\newline \newline","3007719","strided.c","armcii_iov_iter_t *ARMCII_Strided_to_iov_iter(\newline               void *src_ptr, int src_stride_ar[/*stride_levels*/],\newline               void *dst_ptr, int dst_stride_ar[/*stride_levels*/], \newline               int count[/*stride_levels+1*/], int stride_levels) {\newline\newline  int i;\newline  armcii_iov_iter_t *it = malloc(sizeof(armcii_iov_iter_t));\newline\newline  ARMCII_Assert(it != NULL);\newline\newline  it-&gtsrc = src_ptr;\newline  it-&gtdst = dst_ptr;\newline  it-&gtstride_levels = stride_levels;\newline  it-&gtbase_ptr      = malloc(sizeof(int)*(4*stride_levels+1));\newline  it-&gtwas_contiguous= 0;\newline\newline  ARMCII_Assert( it-&gtbase_ptr != NULL );\newline\newline  it-&gtsrc_stride_ar = &ampit-&gtbase_ptr[0*stride_levels];\newline  it-&gtdst_stride_ar = &ampit-&gtbase_ptr[1*stride_levels];\newline  it-&gtcount         = &ampit-&gtbase_ptr[2*stride_levels];\newline  it-&gtidx           = &ampit-&gtbase_ptr[3*stride_levels+1];\newline\newline  for (i = 0; i &lt stride_levels; i++) {\newline    it-&gtsrc_stride_ar[i] = src_stride_ar[i];\newline    it-&gtdst_stride_ar[i] = dst_stride_ar[i];\newline    it-&gtcount[i]         = count[i];\newline    it-&gtidx[i]           = 0;\newline  }\newline\newline  return it;\newline}\newline","Translate a strided operation into a more general IO Vector iterator.\newline \newline @param[in] src_ptr Source starting address of the data block to put.\newline @param[in] src_stride_arr Source array of stride distances in bytes.\newline @param[in] dst_ptr Destination starting address to put data.\newline @param[in] dst_stride_ar Destination array of stride distances in bytes.\newline @param[in] count Block size in each dimension. count[0] should be the\newline number of bytes of contiguous data in leading dimension.\newline @param[in] stride_levels The level of strides.\newline \newline @return ARMCI IOV iterator corresponding to the strided parameters.\newline \newline","148620","modeltest.cpp","void ModelTest::rowsAboutToBeInserted ( const QModelIndex &ampparent, int start, int /* end */)\newline{\newline//     Q_UNUSED(end);\newline//    qDebug() &lt&lt &quotrowsAboutToBeInserted&quot &lt&lt &quotstart=&quot &lt&lt start &lt&lt &quotend=&quot &lt&lt end &lt&lt &quotparent=&quot &lt&lt model-&gtdata ( parent ).toString()\newline//    &lt&lt &quotcurrent count of parent=&quot &lt&lt model-&gtrowCount ( parent ); // &lt&lt &quotdisplay of last=&quot &lt&lt model-&gtdata( model-&gtindex(start-1, 0, parent) );\newline//     qDebug() &lt&lt model-&gtindex(start-1, 0, parent) &lt&lt model-&gtdata( model-&gtindex(start-1, 0, parent) );\newline    Changing c;\newline    c.parent = parent;\newline    c.oldSize = model-&gtrowCount ( parent );\newline    c.last = model-&gtdata ( model-&gtindex ( start - 1, 0, parent ) );\newline    c.next = model-&gtdata ( model-&gtindex ( start, 0, parent ) );\newline    insert.push ( c );\newline}\newline","!\newlineStore what is about to be inserted to make sure it actually happens\newline\\sa rowsInserted()\newline \newline","503091","qcustomplot.cpp","void QCPAxisRect::setupFullAxesBox(bool connectRanges)\newline{\newline  QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;\newline  if (axisCount(QCPAxis::atBottom) == 0)\newline    xAxis = addAxis(QCPAxis::atBottom);\newline  else\newline    xAxis = axis(QCPAxis::atBottom);\newline  \newline  if (axisCount(QCPAxis::atLeft) == 0)\newline    yAxis = addAxis(QCPAxis::atLeft);\newline  else\newline    yAxis = axis(QCPAxis::atLeft);\newline  \newline  if (axisCount(QCPAxis::atTop) == 0)\newline    xAxis2 = addAxis(QCPAxis::atTop);\newline  else\newline    xAxis2 = axis(QCPAxis::atTop);\newline  \newline  if (axisCount(QCPAxis::atRight) == 0)\newline    yAxis2 = addAxis(QCPAxis::atRight);\newline  else\newline    yAxis2 = axis(QCPAxis::atRight);\newline  \newline  xAxis-&gtsetVisible(true);\newline  yAxis-&gtsetVisible(true);\newline  xAxis2-&gtsetVisible(true);\newline  yAxis2-&gtsetVisible(true);\newline  xAxis2-&gtsetTickLabels(false);\newline  yAxis2-&gtsetTickLabels(false);\newline  \newline  xAxis2-&gtsetRange(xAxis-&gtrange());\newline  xAxis2-&gtsetRangeReversed(xAxis-&gtrangeReversed());\newline  xAxis2-&gtsetScaleType(xAxis-&gtscaleType());\newline  xAxis2-&gtsetScaleLogBase(xAxis-&gtscaleLogBase());\newline  xAxis2-&gtsetTicks(xAxis-&gtticks());\newline  xAxis2-&gtsetAutoTickCount(xAxis-&gtautoTickCount());\newline  xAxis2-&gtsetSubTickCount(xAxis-&gtsubTickCount());\newline  xAxis2-&gtsetAutoSubTicks(xAxis-&gtautoSubTicks());\newline  xAxis2-&gtsetTickStep(xAxis-&gttickStep());\newline  xAxis2-&gtsetAutoTickStep(xAxis-&gtautoTickStep());\newline  xAxis2-&gtsetNumberFormat(xAxis-&gtnumberFormat());\newline  xAxis2-&gtsetNumberPrecision(xAxis-&gtnumberPrecision());\newline  xAxis2-&gtsetTickLabelType(xAxis-&gttickLabelType());\newline  xAxis2-&gtsetDateTimeFormat(xAxis-&gtdateTimeFormat());\newline  xAxis2-&gtsetDateTimeSpec(xAxis-&gtdateTimeSpec());\newline\newline  yAxis2-&gtsetRange(yAxis-&gtrange());\newline  yAxis2-&gtsetRangeReversed(yAxis-&gtrangeReversed());\newline  yAxis2-&gtsetScaleType(yAxis-&gtscaleType());\newline  yAxis2-&gtsetScaleLogBase(yAxis-&gtscaleLogBase());\newline  yAxis2-&gtsetTicks(yAxis-&gtticks());\newline  yAxis2-&gtsetAutoTickCount(yAxis-&gtautoTickCount());\newline  yAxis2-&gtsetSubTickCount(yAxis-&gtsubTickCount());\newline  yAxis2-&gtsetAutoSubTicks(yAxis-&gtautoSubTicks());\newline  yAxis2-&gtsetTickStep(yAxis-&gttickStep());\newline  yAxis2-&gtsetAutoTickStep(yAxis-&gtautoTickStep());\newline  yAxis2-&gtsetNumberFormat(yAxis-&gtnumberFormat());\newline  yAxis2-&gtsetNumberPrecision(yAxis-&gtnumberPrecision());\newline  yAxis2-&gtsetTickLabelType(yAxis-&gttickLabelType());\newline  yAxis2-&gtsetDateTimeFormat(yAxis-&gtdateTimeFormat());\newline  yAxis2-&gtsetDateTimeSpec(yAxis-&gtdateTimeSpec());\newline  \newline  if (connectRanges)\newline  {\newline    connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));\newline    connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));\newline  }\newline}\newline","!\newlineConvenience function to create an axis on each side that doesn&#039t have any axes yet and set their\newlinevisibility to true. Further, the top/right axes are assigned the following properties of the\newlinebottom/left axes:\newline\newline\\li range (\\ref QCPAxis::setRange)\newline\\li range reversed (\\ref QCPAxis::setRangeReversed)\newline\\li scale type (\\ref QCPAxis::setScaleType)\newline\\li scale log base (\\ref QCPAxis::setScaleLogBase)\newline\\li ticks (\\ref QCPAxis::setTicks)\newline\\li auto (major) tick count (\\ref QCPAxis::setAutoTickCount)\newline\\li sub tick count (\\ref QCPAxis::setSubTickCount)\newline\\li auto sub ticks (\\ref QCPAxis::setAutoSubTicks)\newline\\li tick step (\\ref QCPAxis::setTickStep)\newline\\li auto tick step (\\ref QCPAxis::setAutoTickStep)\newline\\li number format (\\ref QCPAxis::setNumberFormat)\newline\\li number precision (\\ref QCPAxis::setNumberPrecision)\newline\\li tick label type (\\ref QCPAxis::setTickLabelType)\newline\\li date time format (\\ref QCPAxis::setDateTimeFormat)\newline\\li date time spec (\\ref QCPAxis::setDateTimeSpec)\newline\newlineTick labels (\\ref QCPAxis::setTickLabels) of the right and top axes are set to false.\newlineIf \\a connectRanges is true, the \\ref QCPAxis::rangeChanged &quotrangeChanged&quot signals of the bottom\newlineand left axes are connected to the \\ref QCPAxis::setRange slots of the top and right axes.\newline \newline","2476784","updateview.cpp","void UpdateView::openDirectory(const QString&amp dirName)\newline{\newline    clear();\newline\newline    // do this each time as the configuration could be changed\newline    updateColors();\newline\newline    Entry entry;\newline    entry.m_name = dirName;\newline    entry.m_type = Entry::Dir;\newline\newline    UpdateDirItem *item = new UpdateDirItem(this, entry);\newline    item-&gtsetExpanded(true);\newline    setCurrentItem(item);\newline    item-&gtsetSelected(true);\newline}\newline","\newline Clear the tree view and insert the directory dirname\newline into it as the new root item\newline \newline","3055082","execcmd.c","int check_cmd_for_too_long_lines( char const * command, int const max,\newline    int * const error_length, int * const error_max_length )\newline{\newline    while ( *command )\newline    {\newline        size_t const l = strcspn( command, &quot\\n&quot );\newline        if ( l &gt max )\newline        {\newline            *error_length = l;\newline            *error_max_length = max;\newline            return EXEC_CHECK_LINE_TOO_LONG;\newline        }\newline        command += l;\newline        if ( *command )\newline            ++command;\newline    }\newline    return EXEC_CHECK_OK;\newline}\newline","Returns whether the given command string contains lines longer than the given\newline maximum.\newline \newline","5569444","gdf1.c","LOCAL_FN int xdf_is_gdf1file(const unsigned char* magickey)\newline{\newline	char key[9] = {0};\newline	unsigned int version;\newline\newline	strncpy(key, (const char*)magickey, 8);\newline	if (sscanf(key, &quotGDF 1.%u&quot, &ampversion) == 1)\newline		return 1;\newline	return 0;\newline}\newline","\\param magickey pointer to key identifying a type of file\newline \newline Returns 1 if the supplied magickey corresponds to a GDF1 file\newline \newline","","on","","","","","","","","","","on","","on","","","","on","","","on","","","","","","on","","","","","","","","","","","","","","","","Sets the distance mask beginning with the airfield","{}","change the current directory tothe same location as the service executable.","Change the minimum and maximum values used on the legend.","Sleep routine for pthread","MD5 block update operation.","Release all binary-loaded generic functionstructure arrays","Translate a strided operation into a more general IO Vector iterator.","Store what is about to be inserted","create an axis on each side that doesn't have any axes","Clear the tree view and insert the directory dirnameinto it","{}","whether the given command string contains lines longer than the givenmaximum.","{}","Determines the UTF-8 string size from the system string","Detect one phase error in a recording.","Matches if all items from selection string list match a subset","{}","system callback for setting profiles show option","Insert edges for intra- or inter-file calls,","{}"
"31SIZS5W59FJDDTKZ93LP1JQVIJRQG","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3LKC68YZ3A3NNHUJ9SQOCESWOK6OW2","AVC62JNYAXA45","Approved","Wed Apr 17 14:23:19 PDT 2019","Wed Apr 17 14:57:59 PDT 2019","Fri Apr 19 14:57:59 PDT 2019","2019-04-19 21:58:21 UTC","","","2080","100% (24/24)","100% (24/24)","100% (24/24)","2806215","map.c","static void map_get_dist_air_mask( int ax, int ay, short *dist_air_mask )\newline{\newline    int x, y;\newline    for ( x = 0; x &lt map_w; x++ )\newline        for ( y = 0; y &lt map_h; y++ ) {\newline            int d = get_dist( ax, ay, x, y ) - 1;\newline            if (d &lt dist_air_mask[y*map_w+x])\newline                dist_air_mask[y*map_w+x] = d;\newline        }\newline    dist_air_mask[ay*map_w+ax] = 0;\newline}\newline","\newline====================================================================\newlineSets the distance mask beginning with the airfield at (ax, ay).\newline====================================================================\newline \newline","896366","ospdest.c","OSPTBOOL OSPPDestHasCallId( /* returns non-zero if exists */\newline    OSPT_DEST *ospvDest)    /* destination in question */\newline{\newline    OSPTBOOL has = OSPC_FALSE;\newline\newline    if (ospvDest != OSPC_OSNULL) {\newline        has = (ospvDest-&gtCallId != OSPC_OSNULL);\newline    }\newline\newline    return has;\newline}\newline","\newline OSPPDestHasCallId() - does a destination have a Call ID?\newline \newline","4599862","libcsystem_string.c","int libcsystem_string_size_to_utf8_string(\newline     const libcstring_system_character_t *string,\newline     size_t string_size,\newline     size_t *utf8_string_size,\newline     libcerror_error_t **error )\newline{\newline	static char *function = &quotlibcsystem_string_size_to_utf8_string&quot;\newline\newline	if( string == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid string.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( string_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid string size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( utf8_string_size == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#if defined( LIBCSTRING_HAVE_WIDE_SYSTEM_CHARACTER )\newline#if SIZEOF_WCHAR_T == 4\newline	if( libuna_utf8_string_size_from_utf32(\newline	     (libuna_utf32_character_t *) string,\newline	     string_size,\newline	     utf8_string_size,\newline	     error ) != 1 )\newline#elif SIZEOF_WCHAR_T == 2\newline	if( libuna_utf8_string_size_from_utf16(\newline	     (libuna_utf16_character_t *) string,\newline	     string_size,\newline	     utf8_string_size,\newline	     error ) != 1 )\newline#endif\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_GENERIC,\newline		 &quot%s: unable to determine UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#else\newline	if( libclocale_codepage == 0 )\newline	{\newline		*utf8_string_size = 1 + libcstring_system_string_length(\newline		                         string );\newline	}\newline	else if( libuna_utf8_string_size_from_byte_stream(\newline	          (uint8_t *) string,\newline	          string_size,\newline	          libclocale_codepage,\newline	          utf8_string_size,\newline	          error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_CONVERSION,\newline		 LIBCERROR_CONVERSION_ERROR_GENERIC,\newline		 &quot%s: unable to determine UTF-8 string size.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline#endif\newline	return( 1 );\newline}\newline","Determines the UTF-8 string size from the system string\newline Returns 1 if successful or -1 on error\newline \newline","245106","test_audio_analyzer.c","static int TestDetectSinglePhaseError( double sampleRate, int cycleSize, int latencyFrames, int glitchPosition, int framesAdded )\newline{\newline	int result = 0;\newline	PaQaRecording     recording;	\newline	PaQaTestTone testTone;\newline	PaQaAnalysisResult analysisResult = { 0.0 };\newline	int framesDropped = 0;\newline    int maxFrames = ((int)sampleRate) * 2;\newline\newline	testTone.samplesPerFrame = 1;\newline	testTone.sampleRate = sampleRate;\newline	testTone.frequency = sampleRate / cycleSize;\newline	testTone.amplitude = 0.5;\newline	testTone.startDelay = latencyFrames;\newline	\newline	result = PaQa_InitializeRecording( &amprecording, maxFrames, (int) sampleRate );\newline	QA_ASSERT_EQUALS( &quotPaQa_InitializeRecording failed&quot, 0, result );\newline	\newline	MakeRecordingWithAddedFrames( &amprecording, &amptestTone, glitchPosition, framesAdded );\newline	\newline	PaQa_AnalyseRecording( &amprecording, &amptestTone, &ampanalysisResult );\newline	\newline	if( framesAdded &lt 0 )\newline	{\newline		framesDropped = -framesAdded;\newline		framesAdded = 0;\newline	}\newline	\newline#if PRINT_REPORTS\newline	printf(&quot\\n=== Dropped Frame Analysis ===================\\n&quot);\newline	printf(&quot                        expected      actual\\n&quot);\newline	printf(&quot             latency: %10.3f  %10.3f\\n&quot, (double)latencyFrames, analysisResult.latency );\newline	printf(&quot    num added frames: %10.3f  %10.3f\\n&quot, (double)framesAdded, analysisResult.numAddedFrames );\newline	printf(&quot     added frames at: %10.3f  %10.3f\\n&quot, (double)glitchPosition, analysisResult.addedFramesPosition );\newline	printf(&quot  num dropped frames: %10.3f  %10.3f\\n&quot, (double)framesDropped, analysisResult.numDroppedFrames );\newline	printf(&quot   dropped frames at: %10.3f  %10.3f\\n&quot, (double)glitchPosition, analysisResult.droppedFramesPosition );\newline#endif\newline	\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording latency&quot, latencyFrames, analysisResult.latency, 0.5 );\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording framesAdded&quot, framesAdded, analysisResult.numAddedFrames, 1.0 );\newline	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording framesDropped&quot, framesDropped, analysisResult.numDroppedFrames, 1.0 );\newline//	QA_ASSERT_CLOSE( &quotPaQa_AnalyseRecording glitchPosition&quot, glitchPosition, analysisResult.glitchPosition, cycleSize );\newline\newline	PaQa_TerminateRecording( &amprecording );\newline	return 0;\newline	\newlineerror:\newline	PaQa_TerminateRecording( &amprecording);	\newline	return 1;\newline}	\newline","\newline Detect one phase error in a recording.\newline \newline","774095","libdm-report.c","static int _cmp_field_string_list_subset_all(const struct str_list_sort_value *val,\newline					     const struct selection_str_list *sel)\newline{\newline	unsigned int sel_list_size = dm_list_size(&ampsel-&gtstr_list.list);\newline	struct dm_str_list *sel_item;\newline	unsigned int i, last_found = 1;\newline	int r = 0;\newline\newline	if (!val-&gtitems[0].len) {\newline		if (sel_list_size == 1) {\newline			/* match blank string list with selection defined as blank string only */\newline			sel_item = dm_list_item(dm_list_first(&ampsel-&gtstr_list.list), struct dm_str_list);\newline			return !strcmp(sel_item-&gtstr, &quot&quot);\newline		}\newline		return 0;\newline	}\newline\newline	/* check selection is a subset of the value */\newline	dm_list_iterate_items(sel_item, &ampsel-&gtstr_list.list) {\newline		r = 0;\newline		for (i = last_found; i &lt= val-&gtitems[0].len; i++) {\newline			if ((strlen(sel_item-&gtstr) == val-&gtitems[i].len) &amp&amp\newline			    !strncmp(sel_item-&gtstr, val-&gtvalue + val-&gtitems[i].pos, val-&gtitems[i].len)) {\newline				last_found = i;\newline				r = 1;\newline			}\newline		}\newline		if (!r)\newline			break;\newline	}\newline\newline	return r;\newline}\newline","Matches if all items from selection string list match a subset of list value. \newline","512815","fgui.c","int qstrcmp(const void *l, const void *r)\newline{\newline	char *left = NULL;\newline	char *right = NULL;\newline\newline	left = *(char**)l;\newline	right = *(char**)r;\newline\newline	return strcmp(left,right);\newline}\newline","a glorified strcmp for qsort \newline","3468967","profiles.c","static int set_show_profiles(metro_t* metro,\newline                             const char* option_name _U_,\newline			     const char* show_profiles)\newline{\newline  if (metro) {\newline    gtk_toggle_action_set_active(metro-&gtprofiles_action,\newline      !strcmp(show_profiles, &quotyes&quot) || !strcmp(show_profiles, &quot1&quot));\newline    return 0;\newline  } else {\newline    return -1;\newline  }\newline}\newline","option system callback for setting profiles show option \newline","4950733","graph.c","static void graph_calls(struct entrypoint *ep, int internal)\newline{\newline	struct basic_block *bb;\newline	struct instruction *insn;\newline\newline	show_ident(ep-&gtname-&gtident);\newline	stream_name(ep-&gtentry-&gtbb-&gtpos.stream);\newline\newline	FOR_EACH_PTR(ep-&gtbbs, bb) {\newline		if (!bb)\newline			continue;\newline		if (!bb-&gtparents &amp&amp !bb-&gtchildren &amp&amp !bb-&gtinsns &amp&amp verbose &lt 2)\newline			continue;\newline\newline		FOR_EACH_PTR(bb-&gtinsns, insn) {\newline			if (insn-&gtopcode == OP_CALL &amp&amp\newline			    internal == !(insn-&gtfunc-&gtsym-&gtctype.modifiers &amp MOD_EXTERN)) {\newline\newline				/* Find the symbol for the callee&#039s definition */\newline				struct symbol * sym;\newline				if (insn-&gtfunc-&gttype == PSEUDO_SYM) {\newline					for (sym = insn-&gtfunc-&gtsym-&gtident-&gtsymbols;\newline					     sym; sym = sym-&gtnext_id) {\newline						if (sym-&gtnamespace &amp NS_SYMBOL &amp&amp sym-&gtep)\newline							break;\newline					}\newline\newline					if (sym)\newline						printf(&quotbb%p -&gt bb%p&quot\newline						       &quot[label=%d,line=%d,col=%d,op=call,style=bold,weight=30];\\n&quot,\newline						       bb, sym-&gtep-&gtentry-&gtbb,\newline						       insn-&gtpos.line, insn-&gtpos.line, insn-&gtpos.pos);\newline					else\newline						printf(&quotbb%p -&gt \\&quot%s\\&quot &quot\newline						       &quot[label=%d,line=%d,col=%d,op=extern,style=dashed];\\n&quot,\newline						       bb, show_pseudo(insn-&gtfunc),\newline						       insn-&gtpos.line, insn-&gtpos.line, insn-&gtpos.pos);\newline				}\newline			}\newline		} END_FOR_EACH_PTR(insn);\newline	} END_FOR_EACH_PTR(bb);\newline}\newline","Insert edges for intra- or inter-file calls, depending on the value\newline of internal. Bold edges are used for calls with destinations;\newline dashed for calls to external functions \newline","1628921","magfreq_analysis~.c","void magfreq_analysis_tilde_setup(void)\newline{\newline	magfreq_analysis_class = class_new(gensym(&quotmagfreq_analysis~&quot), (t_newmethod)magfreq_analysis_new, \newline						   (t_method)magfreq_analysis_free ,sizeof(t_magfreq_analysis), 0,A_GIMME,0);\newline	CLASS_MAINSIGNALIN(magfreq_analysis_class, t_magfreq_analysis, x_f);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_dsp, gensym(&quotdsp&quot), 0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_mute, gensym(&quotmute&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_bypass, gensym(&quotbypass&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_highfreq, gensym(&quothighfreq&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_lowfreq, gensym(&quotlowfreq&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_overlap, gensym(&quotoverlap&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_winfac, gensym(&quotwinfac&quot), A_DEFFLOAT,0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_fftinfo, gensym(&quotfftinfo&quot),0);\newline	class_addmethod(magfreq_analysis_class, (t_method)magfreq_analysis_assist, gensym(&quotassist&quot), 0);\newline	post(&quot%s %s&quot,OBJECT_NAME, LYONPOTPOURRI_MSG);\newline}\newline","Pd Initialization \newline","2970316","folder.c","static char *get_parent_folder(const char *p)\newline{\newline	const char *q;\newline\newline	q=strrchr(p, &#039.&#039);\newline\newline	if (q)\newline	{\newline		char	*s;\newline\newline		s=malloc(q-p+1);\newline		if (!s)	enomem();\newline		memcpy(s, p, q-p);\newline		s[q-p]=0;\newline		return (s);\newline	}\newline	return (strdup(&quot&quot));\newline}\newline","\newline If we&#039re currently showing (INBOX|shared|#shared).foo.bar hierarchy, return\newline &quotx.foo&quot. If we&#039re currently showing (INBOX|shared|#shared).foo, return\newline an empty string.\newline \newline","4206722","w32svrapi.c","void w32_set_service_cwd(void)\newline{\newline   char exe_name[MAX_PATH+1];\newline   char dir_name[MAX_PATH+1];\newline   char *pszFile = NULL;\newline\newline   /* Get the exe name and path of the service */\newline   if (GetModuleFileName(NULL, exe_name, MAX_PATH))\newline   {\newline      /* Ask the API to tell us where the filename portion starts */\newline      if (GetFullPathName(exe_name, MAX_PATH, dir_name, &amppszFile))\newline      {\newline         /* remove the filename from the string */\newline         if (pszFile != NULL)\newline         {\newline            *pszFile = &#039\\0&#039;\newline            /* We have just a directory path now, so make it current */\newline            SetCurrentDirectory(dir_name);\newline         }\newline      }\newline   }\newline}\newline","\newline \newline Function : w32_set_service_cwd\newline \newline Description : Simple function to change the current directory to\newline the same location as the service executable.\newline \newline Parameters : void\newline \newline Returns : void\newline \newline \newline","1892705","shade.c","gboolean visu_gl_ext_shade_setMinMax(VisuGlExtShade *shade, float minV, float maxV)\newline{\newline  g_return_val_if_fail(VISU_IS_GL_EXT_SHADE(shade), FALSE);\newline\newline  if (shade-&gtpriv-&gtminMax[0] == minV &amp&amp shade-&gtpriv-&gtminMax[1] == maxV)\newline    return FALSE;\newline\newline  shade-&gtpriv-&gtminMax[0] = minV;\newline  shade-&gtpriv-&gtminMax[1] = maxV;\newline\newline  VISU_GL_EXT_FRAME(shade)-&gtisBuilt = FALSE;\newline  return visu_gl_ext_getActive(VISU_GL_EXT(shade));\newline}\newline","\newline visu_gl_ext_shade_setMinMax:\newline @shade: the #VisuGlExtShade to update.\newline @minV: a value.\newline @maxV: another value.\newline \newline Change the minimum and maximum values used on the legend.\newline \newline Since: 3.7\newline \newline Returns: TRUE if visu_gl_ext_frame_draw() should be called.\newline \newline","1082559","input_dvb.c","static void pthread_sleep(int seconds) {\newline    pthread_mutex_t dummy_mutex;\newline    static pthread_cond_t dummy_cond = PTHREAD_COND_INITIALIZER;\newline    struct timespec timeout;\newline\newline    /* Create a dummy mutex which doesn&#039t unlock for sure while waiting. */\newline    pthread_mutex_init(&ampdummy_mutex, NULL);\newline    pthread_mutex_lock(&ampdummy_mutex);\newline\newline    /* Create a dummy condition variable. */\newline/*    pthread_cond_init(&ampdummy_cond, NULL); */\newline\newline    timeout.tv_sec = time(NULL) + seconds;\newline    timeout.tv_nsec = 0;\newline\newline    pthread_cond_timedwait(&ampdummy_cond, &ampdummy_mutex, &amptimeout);\newline\newline/*    pthread_cond_destroy(&ampdummy_cond); */\newline    pthread_mutex_unlock(&ampdummy_mutex);\newline    pthread_mutex_destroy(&ampdummy_mutex);\newline}\newline","Sleep routine for pthread (hackish). \newline","1786865","md5.c","static void MD5_Update (MD5_CTX *ctx, unsigned char const *buf, unsigned int len)\newline{\newline    unsigned int t;\newline\newline    // Update bitcount\newline    t = ctx-&gtbits[0];\newline\newline	if ((ctx-&gtbits[0] = t + ((unsigned int)len &lt&lt 3)) &lt t)\newline        ctx-&gtbits[1]++;         // Carry from low to high\newline\newline    ctx-&gtbits[1] += len &gt&gt 29;\newline    t = (t &gt&gt 3)&amp 0x3f;        // Bytes already in shsInfo-&gtdata\newline\newline    // Handle any leading odd-sized chunks\newline    if (t)\newline	{\newline        unsigned char *p = (unsigned char *)ctx-&gtin + t;\newline\newline        t = 64 - t;\newline\newline        if (len &lt t)\newline		{\newline            memcpy(p, buf, len);\newline            return;\newline        }\newline\newline        memcpy(p, buf, t);\newline        MD5_Transform(ctx-&gtstate, (unsigned int *)ctx-&gtin);\newline        buf += t;\newline        len -= t;\newline    }\newline\newline	// Process data in 64-byte chunks\newline    while (len &gt= 64)\newline	{\newline        memcpy(ctx-&gtin, buf, 64);\newline        MD5_Transform(ctx-&gtstate, (unsigned int *)ctx-&gtin);\newline        buf += 64;\newline        len -= 64;\newline    }\newline\newline    // Handle any remaining bytes of data.\newline    memcpy(ctx-&gtin, buf, len);\newline}\newline","\newline===================\newlineMD5_Update\newlineMD5 block update operation. Continues an MD5 message-digest operation,\newlineprocessing another message block, and updating the context.\newline===================\newline \newline","6007310","genrcbin.c","static void ClearBloadGenerics(\newline  void *theEnv)\newline  {\newline   register long i;\newline   unsigned long space;\newline\newline   space = (unsigned long) (sizeof(DEFGENERIC_MODULE) * DefgenericBinaryData(theEnv)-&gtModuleCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtModuleArray,space);\newline   DefgenericBinaryData(theEnv)-&gtModuleArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtModuleCount = 0L;\newline\newline   for (i = 0 ; i &lt DefgenericBinaryData(theEnv)-&gtGenericCount ; i++)\newline     UnmarkConstructHeader(theEnv,&ampDefgenericBinaryData(theEnv)-&gtDefgenericArray[i].header);\newline\newline   space = (unsigned long) (sizeof(DEFGENERIC) * DefgenericBinaryData(theEnv)-&gtGenericCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtDefgenericArray,space);\newline   DefgenericBinaryData(theEnv)-&gtDefgenericArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtGenericCount = 0L;\newline\newline   space = (unsigned long) (sizeof(DEFMETHOD) * DefgenericBinaryData(theEnv)-&gtMethodCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtMethodArray,space);\newline   DefgenericBinaryData(theEnv)-&gtMethodArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtMethodCount = 0L;\newline\newline   space = (unsigned long) (sizeof(RESTRICTION) * DefgenericBinaryData(theEnv)-&gtRestrictionCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtRestrictionArray,space);\newline   DefgenericBinaryData(theEnv)-&gtRestrictionArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtRestrictionCount = 0L;\newline\newline#if ! OBJECT_SYSTEM\newline   for (i = 0 ; i &lt DefgenericBinaryData(theEnv)-&gtTypeCount ; i++)\newline     DecrementIntegerCount(theEnv,(INTEGER_HN *) DefgenericBinaryData(theEnv)-&gtTypeArray[i]);\newline#endif\newline   space = (unsigned long) (sizeof(void *) * DefgenericBinaryData(theEnv)-&gtTypeCount);\newline   if (space == 0L)\newline     return;\newline   genlongfree(theEnv,(void *) DefgenericBinaryData(theEnv)-&gtTypeArray,space);\newline   DefgenericBinaryData(theEnv)-&gtTypeArray = NULL;\newline   DefgenericBinaryData(theEnv)-&gtTypeCount = 0L;\newline  }\newline","\newlineNAME : ClearBloadGenerics\newlineDESCRIPTION : Release all binary-loaded generic function\newlinestructure arrays\newlineResets generic function list to NULL\newlineINPUTS : None\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Memory cleared\newlineNOTES : Generic function name symbol counts decremented\newline \newline","3007719","strided.c","armcii_iov_iter_t *ARMCII_Strided_to_iov_iter(\newline               void *src_ptr, int src_stride_ar[/*stride_levels*/],\newline               void *dst_ptr, int dst_stride_ar[/*stride_levels*/], \newline               int count[/*stride_levels+1*/], int stride_levels) {\newline\newline  int i;\newline  armcii_iov_iter_t *it = malloc(sizeof(armcii_iov_iter_t));\newline\newline  ARMCII_Assert(it != NULL);\newline\newline  it-&gtsrc = src_ptr;\newline  it-&gtdst = dst_ptr;\newline  it-&gtstride_levels = stride_levels;\newline  it-&gtbase_ptr      = malloc(sizeof(int)*(4*stride_levels+1));\newline  it-&gtwas_contiguous= 0;\newline\newline  ARMCII_Assert( it-&gtbase_ptr != NULL );\newline\newline  it-&gtsrc_stride_ar = &ampit-&gtbase_ptr[0*stride_levels];\newline  it-&gtdst_stride_ar = &ampit-&gtbase_ptr[1*stride_levels];\newline  it-&gtcount         = &ampit-&gtbase_ptr[2*stride_levels];\newline  it-&gtidx           = &ampit-&gtbase_ptr[3*stride_levels+1];\newline\newline  for (i = 0; i &lt stride_levels; i++) {\newline    it-&gtsrc_stride_ar[i] = src_stride_ar[i];\newline    it-&gtdst_stride_ar[i] = dst_stride_ar[i];\newline    it-&gtcount[i]         = count[i];\newline    it-&gtidx[i]           = 0;\newline  }\newline\newline  return it;\newline}\newline","Translate a strided operation into a more general IO Vector iterator.\newline \newline @param[in] src_ptr Source starting address of the data block to put.\newline @param[in] src_stride_arr Source array of stride distances in bytes.\newline @param[in] dst_ptr Destination starting address to put data.\newline @param[in] dst_stride_ar Destination array of stride distances in bytes.\newline @param[in] count Block size in each dimension. count[0] should be the\newline number of bytes of contiguous data in leading dimension.\newline @param[in] stride_levels The level of strides.\newline \newline @return ARMCI IOV iterator corresponding to the strided parameters.\newline \newline","148620","modeltest.cpp","void ModelTest::rowsAboutToBeInserted ( const QModelIndex &ampparent, int start, int /* end */)\newline{\newline//     Q_UNUSED(end);\newline//    qDebug() &lt&lt &quotrowsAboutToBeInserted&quot &lt&lt &quotstart=&quot &lt&lt start &lt&lt &quotend=&quot &lt&lt end &lt&lt &quotparent=&quot &lt&lt model-&gtdata ( parent ).toString()\newline//    &lt&lt &quotcurrent count of parent=&quot &lt&lt model-&gtrowCount ( parent ); // &lt&lt &quotdisplay of last=&quot &lt&lt model-&gtdata( model-&gtindex(start-1, 0, parent) );\newline//     qDebug() &lt&lt model-&gtindex(start-1, 0, parent) &lt&lt model-&gtdata( model-&gtindex(start-1, 0, parent) );\newline    Changing c;\newline    c.parent = parent;\newline    c.oldSize = model-&gtrowCount ( parent );\newline    c.last = model-&gtdata ( model-&gtindex ( start - 1, 0, parent ) );\newline    c.next = model-&gtdata ( model-&gtindex ( start, 0, parent ) );\newline    insert.push ( c );\newline}\newline","!\newlineStore what is about to be inserted to make sure it actually happens\newline\\sa rowsInserted()\newline \newline","503091","qcustomplot.cpp","void QCPAxisRect::setupFullAxesBox(bool connectRanges)\newline{\newline  QCPAxis *xAxis, *yAxis, *xAxis2, *yAxis2;\newline  if (axisCount(QCPAxis::atBottom) == 0)\newline    xAxis = addAxis(QCPAxis::atBottom);\newline  else\newline    xAxis = axis(QCPAxis::atBottom);\newline  \newline  if (axisCount(QCPAxis::atLeft) == 0)\newline    yAxis = addAxis(QCPAxis::atLeft);\newline  else\newline    yAxis = axis(QCPAxis::atLeft);\newline  \newline  if (axisCount(QCPAxis::atTop) == 0)\newline    xAxis2 = addAxis(QCPAxis::atTop);\newline  else\newline    xAxis2 = axis(QCPAxis::atTop);\newline  \newline  if (axisCount(QCPAxis::atRight) == 0)\newline    yAxis2 = addAxis(QCPAxis::atRight);\newline  else\newline    yAxis2 = axis(QCPAxis::atRight);\newline  \newline  xAxis-&gtsetVisible(true);\newline  yAxis-&gtsetVisible(true);\newline  xAxis2-&gtsetVisible(true);\newline  yAxis2-&gtsetVisible(true);\newline  xAxis2-&gtsetTickLabels(false);\newline  yAxis2-&gtsetTickLabels(false);\newline  \newline  xAxis2-&gtsetRange(xAxis-&gtrange());\newline  xAxis2-&gtsetRangeReversed(xAxis-&gtrangeReversed());\newline  xAxis2-&gtsetScaleType(xAxis-&gtscaleType());\newline  xAxis2-&gtsetScaleLogBase(xAxis-&gtscaleLogBase());\newline  xAxis2-&gtsetTicks(xAxis-&gtticks());\newline  xAxis2-&gtsetAutoTickCount(xAxis-&gtautoTickCount());\newline  xAxis2-&gtsetSubTickCount(xAxis-&gtsubTickCount());\newline  xAxis2-&gtsetAutoSubTicks(xAxis-&gtautoSubTicks());\newline  xAxis2-&gtsetTickStep(xAxis-&gttickStep());\newline  xAxis2-&gtsetAutoTickStep(xAxis-&gtautoTickStep());\newline  xAxis2-&gtsetNumberFormat(xAxis-&gtnumberFormat());\newline  xAxis2-&gtsetNumberPrecision(xAxis-&gtnumberPrecision());\newline  xAxis2-&gtsetTickLabelType(xAxis-&gttickLabelType());\newline  xAxis2-&gtsetDateTimeFormat(xAxis-&gtdateTimeFormat());\newline  xAxis2-&gtsetDateTimeSpec(xAxis-&gtdateTimeSpec());\newline\newline  yAxis2-&gtsetRange(yAxis-&gtrange());\newline  yAxis2-&gtsetRangeReversed(yAxis-&gtrangeReversed());\newline  yAxis2-&gtsetScaleType(yAxis-&gtscaleType());\newline  yAxis2-&gtsetScaleLogBase(yAxis-&gtscaleLogBase());\newline  yAxis2-&gtsetTicks(yAxis-&gtticks());\newline  yAxis2-&gtsetAutoTickCount(yAxis-&gtautoTickCount());\newline  yAxis2-&gtsetSubTickCount(yAxis-&gtsubTickCount());\newline  yAxis2-&gtsetAutoSubTicks(yAxis-&gtautoSubTicks());\newline  yAxis2-&gtsetTickStep(yAxis-&gttickStep());\newline  yAxis2-&gtsetAutoTickStep(yAxis-&gtautoTickStep());\newline  yAxis2-&gtsetNumberFormat(yAxis-&gtnumberFormat());\newline  yAxis2-&gtsetNumberPrecision(yAxis-&gtnumberPrecision());\newline  yAxis2-&gtsetTickLabelType(yAxis-&gttickLabelType());\newline  yAxis2-&gtsetDateTimeFormat(yAxis-&gtdateTimeFormat());\newline  yAxis2-&gtsetDateTimeSpec(yAxis-&gtdateTimeSpec());\newline  \newline  if (connectRanges)\newline  {\newline    connect(xAxis, SIGNAL(rangeChanged(QCPRange)), xAxis2, SLOT(setRange(QCPRange)));\newline    connect(yAxis, SIGNAL(rangeChanged(QCPRange)), yAxis2, SLOT(setRange(QCPRange)));\newline  }\newline}\newline","!\newlineConvenience function to create an axis on each side that doesn&#039t have any axes yet and set their\newlinevisibility to true. Further, the top/right axes are assigned the following properties of the\newlinebottom/left axes:\newline\newline\\li range (\\ref QCPAxis::setRange)\newline\\li range reversed (\\ref QCPAxis::setRangeReversed)\newline\\li scale type (\\ref QCPAxis::setScaleType)\newline\\li scale log base (\\ref QCPAxis::setScaleLogBase)\newline\\li ticks (\\ref QCPAxis::setTicks)\newline\\li auto (major) tick count (\\ref QCPAxis::setAutoTickCount)\newline\\li sub tick count (\\ref QCPAxis::setSubTickCount)\newline\\li auto sub ticks (\\ref QCPAxis::setAutoSubTicks)\newline\\li tick step (\\ref QCPAxis::setTickStep)\newline\\li auto tick step (\\ref QCPAxis::setAutoTickStep)\newline\\li number format (\\ref QCPAxis::setNumberFormat)\newline\\li number precision (\\ref QCPAxis::setNumberPrecision)\newline\\li tick label type (\\ref QCPAxis::setTickLabelType)\newline\\li date time format (\\ref QCPAxis::setDateTimeFormat)\newline\\li date time spec (\\ref QCPAxis::setDateTimeSpec)\newline\newlineTick labels (\\ref QCPAxis::setTickLabels) of the right and top axes are set to false.\newlineIf \\a connectRanges is true, the \\ref QCPAxis::rangeChanged &quotrangeChanged&quot signals of the bottom\newlineand left axes are connected to the \\ref QCPAxis::setRange slots of the top and right axes.\newline \newline","2476784","updateview.cpp","void UpdateView::openDirectory(const QString&amp dirName)\newline{\newline    clear();\newline\newline    // do this each time as the configuration could be changed\newline    updateColors();\newline\newline    Entry entry;\newline    entry.m_name = dirName;\newline    entry.m_type = Entry::Dir;\newline\newline    UpdateDirItem *item = new UpdateDirItem(this, entry);\newline    item-&gtsetExpanded(true);\newline    setCurrentItem(item);\newline    item-&gtsetSelected(true);\newline}\newline","\newline Clear the tree view and insert the directory dirname\newline into it as the new root item\newline \newline","3055082","execcmd.c","int check_cmd_for_too_long_lines( char const * command, int const max,\newline    int * const error_length, int * const error_max_length )\newline{\newline    while ( *command )\newline    {\newline        size_t const l = strcspn( command, &quot\\n&quot );\newline        if ( l &gt max )\newline        {\newline            *error_length = l;\newline            *error_max_length = max;\newline            return EXEC_CHECK_LINE_TOO_LONG;\newline        }\newline        command += l;\newline        if ( *command )\newline            ++command;\newline    }\newline    return EXEC_CHECK_OK;\newline}\newline","Returns whether the given command string contains lines longer than the given\newline maximum.\newline \newline","5569444","gdf1.c","LOCAL_FN int xdf_is_gdf1file(const unsigned char* magickey)\newline{\newline	char key[9] = {0};\newline	unsigned int version;\newline\newline	strncpy(key, (const char*)magickey, 8);\newline	if (sscanf(key, &quotGDF 1.%u&quot, &ampversion) == 1)\newline		return 1;\newline	return 0;\newline}\newline","\\param magickey pointer to key identifying a type of file\newline \newline Returns 1 if the supplied magickey corresponds to a GDF1 file\newline \newline","","on","","","on","","","","","","","on","","","","","","on","","","on","","","on","","","","","","","","","","on","","","","on","","","","","Sets the distance mask","{}","change the current directory","Change the minimum and maximum values used on the legend.","{}","Continues an MD5 message-digest operation,","Release all binary-loaded generic functionstructure arrays","Translate a strided operation into a more general IO Vector iterator.","Store what is about to be inserted","create an axis on each side that doesn't have any axes yet","Clear the tree view and insert the directory dirnameinto it","{}","Returns whether the given command string contains lines longer","Returns 1 if the supplied magickey corresponds to a GDF1 file","Determines the UTF-8 string size from the system string","Detect one phase error in a recording.","Matches if all items from selection string list match a subset","{}","setting profiles show option","Insert edges for intra- or inter-file calls,","{}"
"32LAQ1JNT9POLLDTK7SLZHHXMOMTU0","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","3","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:54:28 PDT 2019","","","3DPNQGW4LLFLP95VZQYB0MNEJRF469","A3V6XE43H0BFC9","Rejected","Wed Apr 17 13:27:04 PDT 2019","Wed Apr 17 13:52:05 PDT 2019","Fri Apr 19 13:52:05 PDT 2019","","Thu Apr 18 10:54:27 PDT 2019","Problem: All of the tags submitted consisted of only one word. 

This assignment has been rejected as spam, a miscommunication of the task goals, or an unfortunate glitch. If you believe you completed the task properly, and your full, appropriate tags appeared in the ""You have selected:"" section, please contact me. If this is the result of a technical malfunction that you are able to help me identify and resolve, I will be happy to restore your approval and possibly offer a bonus for your assistance.","1501","50% (1/2)","50% (1/2)","50% (1/2)","4515541","xmlrpc.c","void xmlrpc_scalar_destroy(XMLRPCScalar *scalar)\newline{\newline    if (scalar == NULL)\newline        return;\newline\newline    octstr_destroy(scalar-&gts_str);\newline    octstr_destroy(scalar-&gts_date);\newline    octstr_destroy(scalar-&gts_base64);\newline    \newline    gw_free(scalar);\newline}\newline","Destroy scalar \newline","4623939","fix_qbmsst.cpp","void FixQBMSST::check_alloc(int n)\newline{\newline  if ( atoms_allocated &lt n ) {\newline    memory-&gtdestroy(old_velocity);\newline    memory-&gtcreate(old_velocity,n,3,&quotqbmsst:old_velocity&quot);\newline    atoms_allocated = n;\newline  }\newline}\newline","----------------------------------------------------------------------\newlineChecks to see if the allocated size of old_velocity is &gt= n\newlineThe number of local atoms can change during a parallel run.\newline------------------------------------------------------------------------- \newline","5179053","xml_node_set.c","static VALUE slice(int argc, VALUE *argv, VALUE self)\newline{\newline  VALUE arg ;\newline  long beg, len ;\newline  xmlNodeSetPtr node_set;\newline\newline  Data_Get_Struct(self, xmlNodeSet, node_set);\newline\newline  if (argc == 2) {\newline    beg = NUM2LONG(argv[0]);\newline    len = NUM2LONG(argv[1]);\newline    if (beg &lt 0) {\newline      beg += node_set-&gtnodeNr ;\newline    }\newline    return subseq(self, beg, len);\newline  }\newline\newline  if (argc != 1) {\newline    rb_scan_args(argc, argv, &quot11&quot, NULL, NULL);\newline  }\newline  arg = argv[0];\newline\newline  if (FIXNUM_P(arg)) {\newline    return index_at(self, FIX2LONG(arg));\newline  }\newline\newline  /* if arg is Range */\newline  switch (rb_range_beg_len(arg, &ampbeg, &amplen, (long)node_set-&gtnodeNr, 0)) {\newline  case Qfalse:\newline    break;\newline  case Qnil:\newline    return Qnil;\newline  default:\newline    return subseq(self, beg, len);\newline  }\newline\newline  return index_at(self, NUM2LONG(arg));\newline}\newline","\newline call-seq:\newline [index] -&gt Node or nil\newline [start, length] -&gt NodeSet or nil\newline [range] -&gt NodeSet or nil\newline slice(index) -&gt Node or nil\newline slice(start, length) -&gt NodeSet or nil\newline slice(range) -&gt NodeSet or nil\newline \newline Element reference - returns the node at +index+, or returns a NodeSet\newline containing nodes starting at +start+ and continuing for +length+ elements, or\newline returns a NodeSet containing nodes specified by +range+. Negative +indices+\newline count backward from the end of the +node_set+ (-1 is the last node). Returns\newline nil if the +index+ (or +start+) are out of range.\newline \newline","4476453","statistics.c","void action_stat(struct cell *t)\newline{\newline   unsigned int seas_dispatch/*,as_delay*/;\newline   struct timeval *t1,*t2/*,*t3*/;\newline   struct statscell *s;\newline   struct totag_elem *to;\newline   if(t==0)\newline      return;\newline   if(t-&gtfwded_totags == 0){\newline      LM_DBG(&quotseas:event_stat() unable to set the event_stat timeval:&quot\newline			  &quot no payload found at cell!! (fwded_totags=0)\\n&quot);\newline      return;\newline   }\newline   to=t-&gtfwded_totags;\newline   while(to){\newline      if(to-&gtacked==STATS_PAY){\newline	 s=(struct statscell *)to-&gttag.s;\newline	 gettimeofday(&amp(s-&gtu.uas.action_recvd),NULL);\newline	 break;\newline      }else\newline	 to=to-&gtnext;\newline   }\newline   /**no statistics found**/\newline   if(to==0)\newline      return;\newline   t1=&amp(s-&gtu.uas.as_relay);\newline   t2=&amp(s-&gtu.uas.event_sent);\newline/*   t3=&amp(s-&gtu.uas.action_recvd); */\newline   seas_dispatch = (t2-&gttv_sec - t1-&gttv_sec)*1000 + (t2-&gttv_usec-t1-&gttv_usec)/1000;\newline/*   as_delay = (t3-&gttv_sec - t2-&gttv_sec)*1000 + (t3-&gttv_usec-t2-&gttv_usec)/1000; */\newline\newline   lock_get(seas_stats_table-&gtmutex);\newline   {\newline      seas_stats_table-&gtdispatch[assignIndex(seas_dispatch)]++;\newline      seas_stats_table-&gtevent[assignIndex(seas_dispatch)]++;\newline      (seas_stats_table-&gtfinished_transactions)++;\newline   }\newline   lock_release(seas_stats_table-&gtmutex);\newline}\newline","this will be called from the SEAS action dispatcher\newline when it receives the action from the socket\newline \newline","4474917","tls_conn_ops.h","static int _tls_read(struct tcp_connection *c, void *buf, size_t len)\newline{\newline	int ret, err;\newline	SSL *ssl;\newline\newline	ssl = c-&gtextra_data;\newline\newline	ret = SSL_read(ssl, buf, len);\newline	if (ret &gt 0) {\newline		LM_DBG(&quot%d bytes read\\n&quot, ret);\newline		return ret;\newline	} else if (ret == 0) {\newline		/* unclean shutdown of the other peer */\newline		c-&gtstate = S_CONN_EOF;\newline		return 0;\newline	} else {\newline		err = SSL_get_error(ssl, ret);\newline		switch (err) {\newline		case SSL_ERROR_ZERO_RETURN:\newline			LM_DBG(&quotTLS connection to %s:%d closed cleanly\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			/*\newline			* mark end of file\newline			*/\newline			c-&gtstate = S_CONN_EOF;\newline			return 0;\newline\newline		case SSL_ERROR_WANT_READ:\newline		case SSL_ERROR_WANT_WRITE:\newline			return 0;\newline\newline		case SSL_ERROR_SYSCALL:\newline			LM_ERR(&quotSYSCALL error -&gt (%d) &lt%s&gt\\n&quot,errno,strerror(errno));\newline		default:\newline			LM_ERR(&quotTLS connection to %s:%d read failed\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			LM_ERR(&quotTLS read error: %d\\n&quot,err);\newline			c-&gtstate = S_CONN_BAD;\newline			tls_print_errstack();\newline			return -1;\newline		}\newline	}\newline\newline	LM_BUG(&quotbug\\n&quot);\newline	return -1;\newline}\newline","\newline Wrapper around SSL_read\newline \newline returns number of bytes read, 0 on eof and transits into S_CONN_EOF, -1\newline on error\newline \newline","2254150","gap.c","long i_paranoia_overlap_f(int16_t *buffA,int16_t *buffB,\newline			  long offsetA, long offsetB,\newline			  long sizeA,long sizeB){\newline  long endA=offsetA;\newline  long endB=offsetB;\newline  \newline  /* Start at the given offsets and work our way forward until we hit\newline   * the end of one of the vectors.\newline   */\newline  for(;endA&ltsizeA &amp&amp endB&ltsizeB;endA++,endB++)\newline    if(buffA[endA]!=buffB[endB])break;\newline  \newline  return(endA-offsetA);\newline}\newline","===========================================================================\newline i_paranoia_overlap_f (internal)\newline \newline This function seeks forward through two vectors (starting at the given\newline offsets) to determine how many consecutive samples agree. It returns\newline the number of matching samples, which may be 0.\newline \newline Unlike its sibling, i_paranoia_overlap_r, this function needs to given\newline the size of the vectors.\newline \newline This function is used by i_analyze_rift_f() below to find where a\newline trailing rift ends.\newline \newline","4946453","loopdev.c","static int loopcxt_next_from_proc(struct loopdev_cxt *lc)\newline{\newline	struct loopdev_iter *iter = &amplc-&gtiter;\newline	char buf[BUFSIZ];\newline\newline	DBG(ITER, ul_debugobj(iter, &quotscan /proc/partitions&quot));\newline\newline	if (!iter-&gtproc)\newline		iter-&gtproc = fopen(_PATH_PROC_PARTITIONS, &quotr&quot UL_CLOEXECSTR);\newline	if (!iter-&gtproc)\newline		return 1;\newline\newline	while (fgets(buf, sizeof(buf), iter-&gtproc)) {\newline		unsigned int m;\newline		char name[128 + 1];\newline\newline\newline		if (sscanf(buf, &quot %u %*s %*s %128[^\\n ]&quot,\newline			   &ampm, name) != 2 || m != LOOPDEV_MAJOR)\newline			continue;\newline\newline		DBG(ITER, ul_debugobj(iter, &quotchecking %s&quot, name));\newline\newline		if (loopiter_set_device(lc, name) == 0)\newline			return 0;\newline	}\newline\newline	return 1;\newline}\newline","\newline Set the next used loop device according to /proc/partitions.\newline \newline Loop devices smaller than 512 bytes are invisible for this function.\newline \newline","1831586","corresp.c","static int identical_refs(int npaths,PATH **paths){\newline  int p, w, wp;  \newline\newline  if (npaths == 0) {return 0;}\newline  if (npaths == 1) {return 1;}\newline\newline  for (p=1; p&ltnpaths; p++){\newline    w=0; wp=0;\newline    while (w &lt paths[0]-&gtnum &amp&amp wp &lt paths[p]-&gtnum){\newline      /* skip insertions */\newline      while (w &lt paths[0]-&gtnum &amp&amp (paths[0]-&gtpset[w].eval == P_INS))\newline	w++;\newline      while (wp &lt paths[p]-&gtnum &amp&amp (paths[p]-&gtpset[wp].eval == P_INS))\newline	wp++;\newline      if (w &gt= paths[0]-&gtnum &amp&amp wp &gt= paths[p]-&gtnum)\newline	;\newline      else {\newline	if (w &gt paths[0]-&gtnum || wp &gt paths[p]-&gtnum)\newline	  return 0;\newline	if (TEXT_strcmp(((WORD *)(paths[0]-&gtpset[w].a_ptr))-&gtvalue,\newline			((WORD *)(paths[p]-&gtpset[wp].a_ptr))-&gtvalue) != 0)\newline	  return(0);\newline	w++; wp++;\newline      }\newline    }    \newline  }\newline  return 1;\newline}\newline","return 1 if the paths have the identical reference strings \newline","6580400","ffmpeg.c","static int stream_component_open(priv_t * ffmpeg, int stream_index)\newline{\newline  AVFormatContext *ic = ffmpeg-&gtctxt;\newline  AVCodecContext *enc;\newline  AVCodec *codec;\newline\newline  if (stream_index &lt 0 || stream_index &gt= (int)(ic-&gtnb_streams))\newline    return -1;\newline  enc = ic-&gtstreams[stream_index]-&gtcodec;\newline\newline  /* hack for AC3. XXX: suppress that */\newline  if (enc-&gtchannels &gt 2)\newline    enc-&gtchannels = 2;\newline\newline  codec = avcodec_find_decoder(enc-&gtcodec_id);\newline  enc-&gtworkaround_bugs = 1;\newline#if LIBAVCODEC_VERSION_INT &lt ((52&lt&lt16)+(0&lt&lt8)+0)\newline  enc-&gterror_resilience = 1;\newline#else\newline  enc-&gterror_recognition = 1;\newline#endif\newline\newline  if (!codec || avcodec_open(enc, codec) &lt 0)\newline    return -1;\newline  if (enc-&gtcodec_type != AVMEDIA_TYPE_AUDIO) {\newline    lsx_fail(&quotffmpeg CODEC %x is not an audio CODEC&quot, enc-&gtcodec_type);\newline    return -1;\newline  }\newline\newline  ffmpeg-&gtaudio_stream = stream_index;\newline  ffmpeg-&gtaudio_st = ic-&gtstreams[stream_index];\newline  ffmpeg-&gtaudio_buf_size = 0;\newline  ffmpeg-&gtaudio_buf_index = 0;\newline\newline  memset(&ampffmpeg-&gtaudio_pkt, 0, sizeof(ffmpeg-&gtaudio_pkt));\newline\newline  return 0;\newline}\newline","open a given stream. Return 0 if OK \newline","5141550","tilda.c","static gint get_instance_number ()\newline{\newline    DEBUG_FUNCTION (&quotget_instance_number&quot);\newline\newline    gchar *name;\newline\newline    GSequence *seq;\newline    GSequenceIter *iter;\newline    gint lowest_lock_instance = 0;\newline    gint current_lock_instance;\newline\newline    GDir *dir;\newline    struct lock_info *lock;\newline    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), &quottilda&quot, &quotlocks&quot, NULL);\newline\newline    /* Open the lock directory */\newline    dir = g_dir_open (lock_dir, 0, NULL);\newline\newline    /* Check for failure to open */\newline    if (dir == NULL)\newline    {\newline        g_printerr (_(&quotUnable to open lock directory: %s\\n&quot), lock_dir);\newline        g_free (lock_dir);\newline        return 0;\newline    }\newline\newline    /* Look through every file in the lock directory, and see if it is a lock file.\newline     * If it is a lock file, insert it in a sorted sequence. */\newline    seq = g_sequence_new(NULL);\newline    while ((name = (gchar*)g_dir_read_name (dir)) != NULL)\newline    {\newline        lock = islockfile (name);\newline\newline        if (lock != NULL)\newline        {\newline            g_sequence_insert_sorted(seq, GINT_TO_POINTER(lock-&gtinstance), (GCompareDataFunc)_cmp_locks, NULL);\newline            g_free (lock);\newline        }\newline    }\newline\newline    g_dir_close (dir);\newline    g_free (lock_dir);\newline\newline    /* We iterate the sorted sequence of lock instances to find the first (lowest) number *not* taken. */\newline    for (iter = g_sequence_get_begin_iter(seq); !g_sequence_iter_is_end(iter); iter = g_sequence_iter_next(iter)) {\newline      current_lock_instance = GPOINTER_TO_INT(g_sequence_get(iter));\newline      if (lowest_lock_instance &lt current_lock_instance)\newline        break;\newline      else\newline        lowest_lock_instance = current_lock_instance + 1;\newline    }\newline\newline    g_sequence_free(seq);\newline\newline    return lowest_lock_instance;\newline}\newline","\newline get_instance_number ()\newline \newline Gets the next available tilda instance number. This will always pick the\newline lowest non-running tilda available.\newline \newline Success: return next available instance number (&gt=0)\newline Failure: return 0\newline \newline","1052275","domtool.cpp","void DomTool::fixDocument( QDomDocument&amp doc )\newline{\newline    QDomElement e;\newline    QDomNode n;\newline    QDomNodeList nl;\newline    int i = 0;\newline\newline    e = doc.firstChild().toElement();\newline    if ( e.tagName() != &quotUI&quot )\newline	return;\newline    if ( e.hasAttribute(&quotversion&quot) &amp&amp e.attribute(&quotversion&quot).toDouble() &gt= 4.0 )\newline	return;\newline\newline    e.setAttribute( &quotversion&quot, 4.0 );\newline\newline    e.setAttribute(&quotstdsetdef&quot, 1 );\newline    nl = doc.elementsByTagName( &quotproperty&quot );\newline    int nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline	bool stdset = toBool( e.attribute( &quotstdset&quot ) );\newline	if ( stdset || name == &quottoolTip&quot || name == &quotwhatsThis&quot ||\newline	     name == &quotbuddy&quot ||\newline	     e.parentNode().toElement().tagName() == &quotitem&quot ||\newline	     e.parentNode().toElement().tagName() == &quotspacer&quot ||\newline	     e.parentNode().toElement().tagName() == &quotcolumn&quot\newline	     )\newline	    e.removeAttribute( &quotstdset&quot );\newline	else\newline	    e.setAttribute( &quotstdset&quot, 0 );\newline    }\newline\newline    nl = doc.elementsByTagName( &quotattribute&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotimage&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotwidget&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotclass&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotclass&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline}\newline","!\newlineConvert Qt 2.x format to Qt 3.0 format if necessary\newline \newline","703121","system.c","void fpcrtl_interlockedIncrement__vars(int *i) {\newline    (*i)++;\newline}\newline","\newline XXX No protection currently!\newline \newline","253059","setup.c","void generate_blended_images(void)\newline{\newline    blended_igloos[0] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.06);\newline    blended_igloos[1] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.125);\newline    blended_igloos[2] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.185);\newline    blended_igloos[3] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.25);\newline    blended_igloos[4] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.5);\newline    blended_igloos[5] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.75);\newline    blended_igloos[6] = images[IMG_IGLOO_REBUILDING1];\newline    blended_igloos[7] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.25);\newline    blended_igloos[8] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.5);\newline    blended_igloos[9] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.75);\newline    blended_igloos[10] = images[IMG_IGLOO_REBUILDING2];\newline    blended_igloos[11] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.25);\newline    blended_igloos[12] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.5);\newline    blended_igloos[13] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.75);\newline    blended_igloos[14] = images[IMG_IGLOO_INTACT];\newline}\newline","Created images that are blends of two other images to smooth out\newlinethe transitions. \newline","3923522","mincresample.c","static void normalize_vector(double vector[])\newline{\newline   int idim;\newline   double magnitude;\newline\newline   /* Normalize the direction cosine */\newline   magnitude = 0.0;\newline   for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline      magnitude += (vector[idim] * vector[idim]);\newline   }\newline   magnitude = sqrt(magnitude);\newline   if (magnitude &gt 0.0) {\newline      for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline         vector[idim] /= magnitude;\newline      }\newline   }\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : normalize_vector\newline@INPUT : vector - 3D vector\newline@OUTPUT : (none)\newline@RETURNS : (nothing)\newline@DESCRIPTION: Routine to normalize a vector\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : November 9, 1995 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4538411","qwt_point_data.cpp","QwtCPointerData::QwtCPointerData(\newline        const double *x, const double *y, size_t size ):\newline    d_x( x ),\newline    d_y( y ),\newline    d_size( size )\newline{\newline}\newline","!\newlineConstructor\newline\\param x Array of x values\newline\\param y Array of y values\newline\\param size Size of the x and y arrays\newline\\warning The programmer must assure that the memory blocks referenced\newlineby the pointers remain valid during the lifetime of the\newlineQwtPlotCPointer object.\newline\\sa QwtPlotCurve::setData(), QwtPlotCurve::setRawSamples()\newline \newline","6005770","insmoddp.c","globle void MsgModifyMsgHandler(\newline  void *theEnv,\newline  DATA_OBJECT *result)\newline  {\newline   ModifyMsgHandlerSupport(theEnv,result,TRUE);\newline  }\newline","\newlineNAME : MsgModifyMsgHandler\newlineDESCRIPTION : Implementation for the USER class\newlinehandler message-modify\newlineImplements modify-instance message\newlinewith a series of put- messages\newlineINPUTS : A data object buffer to hold the\newlineresult\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Slot values updated\newlineNOTES : None\newline \newline","6345416","sha2.c","void sha2_hmac( unsigned char *key, int keylen,\newline                unsigned char *input, int ilen,\newline                unsigned char output[32] )\newline{\newline    int i;\newline    sha2_context ctx;\newline    unsigned char k_ipad[64];\newline    unsigned char k_opad[64];\newline    unsigned char tmpbuf[32];\newline\newline    memset( k_ipad, 0x36, 64 );\newline    memset( k_opad, 0x5C, 64 );\newline\newline    for( i = 0; i &lt keylen; i++ )\newline    {\newline        if( i &gt= 64 ) break;\newline\newline        k_ipad[i] ^= key[i];\newline        k_opad[i] ^= key[i];\newline    }\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_ipad, 64 );\newline    sha2_update( &ampctx, input, ilen );\newline    sha2_finish( &ampctx, tmpbuf );\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_opad, 64 );\newline    sha2_update( &ampctx, tmpbuf, 32 );\newline    sha2_finish( &ampctx, output );\newline\newline    memset( k_ipad, 0, 64 );\newline    memset( k_opad, 0, 64 );\newline    memset( tmpbuf, 0, 32 );\newline    memset( &ampctx, 0, sizeof( sha2_context ) );\newline}\newline","\newline Output = HMAC-SHA-2( input buffer, hmac key )\newline \newline","3908739","jsprf.cpp","static int LimitStuff(SprintfState *ss, const char *sp, JSUint32 len)\newline{\newline    JSUint32 limit = ss-&gtmaxlen - (ss-&gtcur - ss-&gtbase);\newline\newline    if (len &gt limit) {\newline        len = limit;\newline    }\newline    while (len) {\newline        --len;\newline        *ss-&gtcur++ = *sp++;\newline    }\newline    return 0;\newline}\newline","\newline Stuff routine that discards overflow data\newline \newline","2808524","sspm.c","void sspm_build_header(struct sspm_header *header, char* line)\newline{\newline    char *prop;\newline    char *val;\newline    \newline    val = sspm_strdup(sspm_value(line));\newline    prop = sspm_strdup(sspm_property_name(line));\newline\newline    if(strcmp(prop,&quotContent-Type&quot) == 0){\newline	\newline	/* Create a new mime_header, fill in content-type\newline	   and possibly boundary */\newline	\newline	char* boundary= sspm_get_parameter(line,&quotboundary&quot);\newline	\newline	header-&gtdef = 0;\newline	header-&gtmajor = sspm_find_major_content_type(val);\newline	header-&gtminor = sspm_find_minor_content_type(val);\newline	\newline	if(header-&gtminor == SSPM_UNKNOWN_MINOR_TYPE){\newline	    char *p = strchr(val,&#039/&#039);\newline	    \newline	    if (p != 0){\newline		p++; /* Skip the &#039/&#039 */\newline		\newline		header-&gtminor_text = sspm_strdup(p);\newline	    } else {\newline		/* Error, malformed content type */\newline		header-&gtminor_text = sspm_strdup(&quotunknown&quot);\newline	    }\newline	}\newline	if (boundary != 0){\newline	    header-&gtboundary = sspm_strdup(boundary);\newline	}\newline	\newline    } else if(strcmp(prop,&quotContent-Transfer-Encoding&quot)==0){\newline	char* encoding = sspm_value(line);\newline	char* lencoding = sspm_lowercase(encoding);\newline\newline	if(strcmp(lencoding,&quotbase64&quot)==0){\newline	    header-&gtencoding = SSPM_BASE64_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotquoted-printable&quot)==0){\newline	    header-&gtencoding = SSPM_QUOTED_PRINTABLE_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotbinary&quot)==0){\newline	    header-&gtencoding = SSPM_BINARY_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot7bit&quot)==0){\newline	    header-&gtencoding = SSPM_7BIT_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot8bit&quot)==0){\newline	    header-&gtencoding = SSPM_8BIT_ENCODING;\newline	} else {\newline	    header-&gtencoding = SSPM_UNKNOWN_ENCODING;\newline	}\newline\newline\newline	free(lencoding);\newline\newline	header-&gtdef = 0;\newline	\newline    } else if(strcmp(prop,&quotContent-Id&quot)==0){\newline	char* cid = sspm_value(line);\newline	header-&gtcontent_id = sspm_strdup(cid);\newline	header-&gtdef = 0;\newline	\newline    }\newline    free(val);\newline    free(prop);\newline}\newline","Interpret a header line and add its data to the header\newlinestructure. \newline","2469258","softhddev.c","const char *CommandLineHelp(void)\newline{\newline    return &quot  -a device\\taudio device (fe. alsa: hw:0,0 oss: /dev/dsp)\\n&quot\newline	&quot  -p device\\taudio device for pass-through (hw:0,1 or /dev/dsp1)\\n&quot\newline	&quot  -c channel\\taudio mixer channel name (fe. PCM)\\n&quot\newline	&quot  -d display\\tdisplay of x11 server (fe. :0.0)\\n&quot\newline	&quot  -f\\t\\tstart with fullscreen window (only with window manager)\\n&quot\newline	&quot  -g geometry\\tx11 window geometry wxh+x+y\\n&quot\newline	&quot  -v device\\tvideo driver device (va-api, vdpau, noop)\\n&quot\newline	&quot  -s\\t\\tstart in suspended mode\\n&quot\newline	&quot  -x\\t\\tstart x11 server, with -xx try to connect, if this fails\\n&quot\newline	&quot  -X args\\tX11 server arguments (f.e. -nocursor)\\n&quot\newline	&quot  -w workaround\\tenable/disable workarounds\\n&quot\newline	&quot\\tno-hw-decoder\\t\\tdisable hw decoder, use software decoder only\\n&quot\newline	&quot\\tno-mpeg-hw-decoder\\tdisable hw decoder for mpeg only\\n&quot\newline	&quot\\tstill-hw-decoder\\tenable hardware decoder for still-pictures\\n&quot\newline	&quot\\tstill-h264-hw-decoder\\tenable h264 hw decoder for still-pictures\\n&quot\newline	&quot\\talsa-driver-broken\\tdisable broken alsa driver message\\n&quot\newline	&quot\\talsa-no-close-open\\tdisable close open to fix alsa no sound bug\\n&quot\newline	&quot\\talsa-close-open-delay\\tenable close open delay to fix no sound bug\\n&quot\newline	&quot\\tignore-repeat-pict\\tdisable repeat pict message\\n&quot\newline	&quot\\tuse-possible-defect-frames prefer faster channel switch\\n&quot\newline	&quot  -D\\t\\tstart in detached mode\\n&quot;\newline}\newline","\newline Return command line help string.\newline \newline","5459428","gl-subsystem.c","struct fbo_info *get_fbo(struct gs_device *device,\newline		uint32_t width, uint32_t height, enum gs_color_format format)\newline{\newline	size_t i;\newline	GLuint fbo;\newline	struct fbo_info *ptr;\newline\newline	for (i = 0; i &lt device-&gtfbos.num; i++) {\newline		ptr = device-&gtfbos.array[i];\newline\newline		if (ptr-&gtwidth  == width &amp&amp ptr-&gtheight == height &amp&amp\newline		    ptr-&gtformat == format)\newline			return ptr;\newline	}\newline\newline	glGenFramebuffers(1, &ampfbo);\newline	if (!gl_success(&quotglGenFramebuffers&quot))\newline		return NULL;\newline\newline	ptr = bmalloc(sizeof(struct fbo_info));\newline	ptr-&gtfbo                 = fbo;\newline	ptr-&gtwidth               = width;\newline	ptr-&gtheight              = height;\newline	ptr-&gtformat              = format;\newline	ptr-&gtcur_render_target   = NULL;\newline	ptr-&gtcur_render_side     = 0;\newline	ptr-&gtcur_zstencil_buffer = NULL;\newline\newline	da_push_back(device-&gtfbos, &ampptr);\newline	return ptr;\newline}\newline","\newline This automatically manages FBOs so that render targets are always given\newline an FBO that matches their width/height/format to maximize optimization\newline \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","on","","","on","","","","scalar","available","format","protection","images","normalize","programmer","handler","Output","routine","Interpret","atoms","command","automatically","Element","receives","around","number","devices","identical","stream."
"32LAQ1JNT9POLLDTK7SLZHHXMOMTU0","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","3","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:54:28 PDT 2019","","","3RYC5T2D73T00LPYPYTXEFP57N5RPS","A1Y0ABOUJUMCWW","Approved","Fri Apr 19 01:24:45 PDT 2019","Fri Apr 19 01:45:47 PDT 2019","Sun Apr 21 01:45:47 PDT 2019","2019-04-21 08:46:21 UTC","","","1262","100% (10/10)","100% (10/10)","100% (10/10)","4515541","xmlrpc.c","void xmlrpc_scalar_destroy(XMLRPCScalar *scalar)\newline{\newline    if (scalar == NULL)\newline        return;\newline\newline    octstr_destroy(scalar-&gts_str);\newline    octstr_destroy(scalar-&gts_date);\newline    octstr_destroy(scalar-&gts_base64);\newline    \newline    gw_free(scalar);\newline}\newline","Destroy scalar \newline","4623939","fix_qbmsst.cpp","void FixQBMSST::check_alloc(int n)\newline{\newline  if ( atoms_allocated &lt n ) {\newline    memory-&gtdestroy(old_velocity);\newline    memory-&gtcreate(old_velocity,n,3,&quotqbmsst:old_velocity&quot);\newline    atoms_allocated = n;\newline  }\newline}\newline","----------------------------------------------------------------------\newlineChecks to see if the allocated size of old_velocity is &gt= n\newlineThe number of local atoms can change during a parallel run.\newline------------------------------------------------------------------------- \newline","5179053","xml_node_set.c","static VALUE slice(int argc, VALUE *argv, VALUE self)\newline{\newline  VALUE arg ;\newline  long beg, len ;\newline  xmlNodeSetPtr node_set;\newline\newline  Data_Get_Struct(self, xmlNodeSet, node_set);\newline\newline  if (argc == 2) {\newline    beg = NUM2LONG(argv[0]);\newline    len = NUM2LONG(argv[1]);\newline    if (beg &lt 0) {\newline      beg += node_set-&gtnodeNr ;\newline    }\newline    return subseq(self, beg, len);\newline  }\newline\newline  if (argc != 1) {\newline    rb_scan_args(argc, argv, &quot11&quot, NULL, NULL);\newline  }\newline  arg = argv[0];\newline\newline  if (FIXNUM_P(arg)) {\newline    return index_at(self, FIX2LONG(arg));\newline  }\newline\newline  /* if arg is Range */\newline  switch (rb_range_beg_len(arg, &ampbeg, &amplen, (long)node_set-&gtnodeNr, 0)) {\newline  case Qfalse:\newline    break;\newline  case Qnil:\newline    return Qnil;\newline  default:\newline    return subseq(self, beg, len);\newline  }\newline\newline  return index_at(self, NUM2LONG(arg));\newline}\newline","\newline call-seq:\newline [index] -&gt Node or nil\newline [start, length] -&gt NodeSet or nil\newline [range] -&gt NodeSet or nil\newline slice(index) -&gt Node or nil\newline slice(start, length) -&gt NodeSet or nil\newline slice(range) -&gt NodeSet or nil\newline \newline Element reference - returns the node at +index+, or returns a NodeSet\newline containing nodes starting at +start+ and continuing for +length+ elements, or\newline returns a NodeSet containing nodes specified by +range+. Negative +indices+\newline count backward from the end of the +node_set+ (-1 is the last node). Returns\newline nil if the +index+ (or +start+) are out of range.\newline \newline","4476453","statistics.c","void action_stat(struct cell *t)\newline{\newline   unsigned int seas_dispatch/*,as_delay*/;\newline   struct timeval *t1,*t2/*,*t3*/;\newline   struct statscell *s;\newline   struct totag_elem *to;\newline   if(t==0)\newline      return;\newline   if(t-&gtfwded_totags == 0){\newline      LM_DBG(&quotseas:event_stat() unable to set the event_stat timeval:&quot\newline			  &quot no payload found at cell!! (fwded_totags=0)\\n&quot);\newline      return;\newline   }\newline   to=t-&gtfwded_totags;\newline   while(to){\newline      if(to-&gtacked==STATS_PAY){\newline	 s=(struct statscell *)to-&gttag.s;\newline	 gettimeofday(&amp(s-&gtu.uas.action_recvd),NULL);\newline	 break;\newline      }else\newline	 to=to-&gtnext;\newline   }\newline   /**no statistics found**/\newline   if(to==0)\newline      return;\newline   t1=&amp(s-&gtu.uas.as_relay);\newline   t2=&amp(s-&gtu.uas.event_sent);\newline/*   t3=&amp(s-&gtu.uas.action_recvd); */\newline   seas_dispatch = (t2-&gttv_sec - t1-&gttv_sec)*1000 + (t2-&gttv_usec-t1-&gttv_usec)/1000;\newline/*   as_delay = (t3-&gttv_sec - t2-&gttv_sec)*1000 + (t3-&gttv_usec-t2-&gttv_usec)/1000; */\newline\newline   lock_get(seas_stats_table-&gtmutex);\newline   {\newline      seas_stats_table-&gtdispatch[assignIndex(seas_dispatch)]++;\newline      seas_stats_table-&gtevent[assignIndex(seas_dispatch)]++;\newline      (seas_stats_table-&gtfinished_transactions)++;\newline   }\newline   lock_release(seas_stats_table-&gtmutex);\newline}\newline","this will be called from the SEAS action dispatcher\newline when it receives the action from the socket\newline \newline","4474917","tls_conn_ops.h","static int _tls_read(struct tcp_connection *c, void *buf, size_t len)\newline{\newline	int ret, err;\newline	SSL *ssl;\newline\newline	ssl = c-&gtextra_data;\newline\newline	ret = SSL_read(ssl, buf, len);\newline	if (ret &gt 0) {\newline		LM_DBG(&quot%d bytes read\\n&quot, ret);\newline		return ret;\newline	} else if (ret == 0) {\newline		/* unclean shutdown of the other peer */\newline		c-&gtstate = S_CONN_EOF;\newline		return 0;\newline	} else {\newline		err = SSL_get_error(ssl, ret);\newline		switch (err) {\newline		case SSL_ERROR_ZERO_RETURN:\newline			LM_DBG(&quotTLS connection to %s:%d closed cleanly\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			/*\newline			* mark end of file\newline			*/\newline			c-&gtstate = S_CONN_EOF;\newline			return 0;\newline\newline		case SSL_ERROR_WANT_READ:\newline		case SSL_ERROR_WANT_WRITE:\newline			return 0;\newline\newline		case SSL_ERROR_SYSCALL:\newline			LM_ERR(&quotSYSCALL error -&gt (%d) &lt%s&gt\\n&quot,errno,strerror(errno));\newline		default:\newline			LM_ERR(&quotTLS connection to %s:%d read failed\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			LM_ERR(&quotTLS read error: %d\\n&quot,err);\newline			c-&gtstate = S_CONN_BAD;\newline			tls_print_errstack();\newline			return -1;\newline		}\newline	}\newline\newline	LM_BUG(&quotbug\\n&quot);\newline	return -1;\newline}\newline","\newline Wrapper around SSL_read\newline \newline returns number of bytes read, 0 on eof and transits into S_CONN_EOF, -1\newline on error\newline \newline","2254150","gap.c","long i_paranoia_overlap_f(int16_t *buffA,int16_t *buffB,\newline			  long offsetA, long offsetB,\newline			  long sizeA,long sizeB){\newline  long endA=offsetA;\newline  long endB=offsetB;\newline  \newline  /* Start at the given offsets and work our way forward until we hit\newline   * the end of one of the vectors.\newline   */\newline  for(;endA&ltsizeA &amp&amp endB&ltsizeB;endA++,endB++)\newline    if(buffA[endA]!=buffB[endB])break;\newline  \newline  return(endA-offsetA);\newline}\newline","===========================================================================\newline i_paranoia_overlap_f (internal)\newline \newline This function seeks forward through two vectors (starting at the given\newline offsets) to determine how many consecutive samples agree. It returns\newline the number of matching samples, which may be 0.\newline \newline Unlike its sibling, i_paranoia_overlap_r, this function needs to given\newline the size of the vectors.\newline \newline This function is used by i_analyze_rift_f() below to find where a\newline trailing rift ends.\newline \newline","4946453","loopdev.c","static int loopcxt_next_from_proc(struct loopdev_cxt *lc)\newline{\newline	struct loopdev_iter *iter = &amplc-&gtiter;\newline	char buf[BUFSIZ];\newline\newline	DBG(ITER, ul_debugobj(iter, &quotscan /proc/partitions&quot));\newline\newline	if (!iter-&gtproc)\newline		iter-&gtproc = fopen(_PATH_PROC_PARTITIONS, &quotr&quot UL_CLOEXECSTR);\newline	if (!iter-&gtproc)\newline		return 1;\newline\newline	while (fgets(buf, sizeof(buf), iter-&gtproc)) {\newline		unsigned int m;\newline		char name[128 + 1];\newline\newline\newline		if (sscanf(buf, &quot %u %*s %*s %128[^\\n ]&quot,\newline			   &ampm, name) != 2 || m != LOOPDEV_MAJOR)\newline			continue;\newline\newline		DBG(ITER, ul_debugobj(iter, &quotchecking %s&quot, name));\newline\newline		if (loopiter_set_device(lc, name) == 0)\newline			return 0;\newline	}\newline\newline	return 1;\newline}\newline","\newline Set the next used loop device according to /proc/partitions.\newline \newline Loop devices smaller than 512 bytes are invisible for this function.\newline \newline","1831586","corresp.c","static int identical_refs(int npaths,PATH **paths){\newline  int p, w, wp;  \newline\newline  if (npaths == 0) {return 0;}\newline  if (npaths == 1) {return 1;}\newline\newline  for (p=1; p&ltnpaths; p++){\newline    w=0; wp=0;\newline    while (w &lt paths[0]-&gtnum &amp&amp wp &lt paths[p]-&gtnum){\newline      /* skip insertions */\newline      while (w &lt paths[0]-&gtnum &amp&amp (paths[0]-&gtpset[w].eval == P_INS))\newline	w++;\newline      while (wp &lt paths[p]-&gtnum &amp&amp (paths[p]-&gtpset[wp].eval == P_INS))\newline	wp++;\newline      if (w &gt= paths[0]-&gtnum &amp&amp wp &gt= paths[p]-&gtnum)\newline	;\newline      else {\newline	if (w &gt paths[0]-&gtnum || wp &gt paths[p]-&gtnum)\newline	  return 0;\newline	if (TEXT_strcmp(((WORD *)(paths[0]-&gtpset[w].a_ptr))-&gtvalue,\newline			((WORD *)(paths[p]-&gtpset[wp].a_ptr))-&gtvalue) != 0)\newline	  return(0);\newline	w++; wp++;\newline      }\newline    }    \newline  }\newline  return 1;\newline}\newline","return 1 if the paths have the identical reference strings \newline","6580400","ffmpeg.c","static int stream_component_open(priv_t * ffmpeg, int stream_index)\newline{\newline  AVFormatContext *ic = ffmpeg-&gtctxt;\newline  AVCodecContext *enc;\newline  AVCodec *codec;\newline\newline  if (stream_index &lt 0 || stream_index &gt= (int)(ic-&gtnb_streams))\newline    return -1;\newline  enc = ic-&gtstreams[stream_index]-&gtcodec;\newline\newline  /* hack for AC3. XXX: suppress that */\newline  if (enc-&gtchannels &gt 2)\newline    enc-&gtchannels = 2;\newline\newline  codec = avcodec_find_decoder(enc-&gtcodec_id);\newline  enc-&gtworkaround_bugs = 1;\newline#if LIBAVCODEC_VERSION_INT &lt ((52&lt&lt16)+(0&lt&lt8)+0)\newline  enc-&gterror_resilience = 1;\newline#else\newline  enc-&gterror_recognition = 1;\newline#endif\newline\newline  if (!codec || avcodec_open(enc, codec) &lt 0)\newline    return -1;\newline  if (enc-&gtcodec_type != AVMEDIA_TYPE_AUDIO) {\newline    lsx_fail(&quotffmpeg CODEC %x is not an audio CODEC&quot, enc-&gtcodec_type);\newline    return -1;\newline  }\newline\newline  ffmpeg-&gtaudio_stream = stream_index;\newline  ffmpeg-&gtaudio_st = ic-&gtstreams[stream_index];\newline  ffmpeg-&gtaudio_buf_size = 0;\newline  ffmpeg-&gtaudio_buf_index = 0;\newline\newline  memset(&ampffmpeg-&gtaudio_pkt, 0, sizeof(ffmpeg-&gtaudio_pkt));\newline\newline  return 0;\newline}\newline","open a given stream. Return 0 if OK \newline","5141550","tilda.c","static gint get_instance_number ()\newline{\newline    DEBUG_FUNCTION (&quotget_instance_number&quot);\newline\newline    gchar *name;\newline\newline    GSequence *seq;\newline    GSequenceIter *iter;\newline    gint lowest_lock_instance = 0;\newline    gint current_lock_instance;\newline\newline    GDir *dir;\newline    struct lock_info *lock;\newline    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), &quottilda&quot, &quotlocks&quot, NULL);\newline\newline    /* Open the lock directory */\newline    dir = g_dir_open (lock_dir, 0, NULL);\newline\newline    /* Check for failure to open */\newline    if (dir == NULL)\newline    {\newline        g_printerr (_(&quotUnable to open lock directory: %s\\n&quot), lock_dir);\newline        g_free (lock_dir);\newline        return 0;\newline    }\newline\newline    /* Look through every file in the lock directory, and see if it is a lock file.\newline     * If it is a lock file, insert it in a sorted sequence. */\newline    seq = g_sequence_new(NULL);\newline    while ((name = (gchar*)g_dir_read_name (dir)) != NULL)\newline    {\newline        lock = islockfile (name);\newline\newline        if (lock != NULL)\newline        {\newline            g_sequence_insert_sorted(seq, GINT_TO_POINTER(lock-&gtinstance), (GCompareDataFunc)_cmp_locks, NULL);\newline            g_free (lock);\newline        }\newline    }\newline\newline    g_dir_close (dir);\newline    g_free (lock_dir);\newline\newline    /* We iterate the sorted sequence of lock instances to find the first (lowest) number *not* taken. */\newline    for (iter = g_sequence_get_begin_iter(seq); !g_sequence_iter_is_end(iter); iter = g_sequence_iter_next(iter)) {\newline      current_lock_instance = GPOINTER_TO_INT(g_sequence_get(iter));\newline      if (lowest_lock_instance &lt current_lock_instance)\newline        break;\newline      else\newline        lowest_lock_instance = current_lock_instance + 1;\newline    }\newline\newline    g_sequence_free(seq);\newline\newline    return lowest_lock_instance;\newline}\newline","\newline get_instance_number ()\newline \newline Gets the next available tilda instance number. This will always pick the\newline lowest non-running tilda available.\newline \newline Success: return next available instance number (&gt=0)\newline Failure: return 0\newline \newline","1052275","domtool.cpp","void DomTool::fixDocument( QDomDocument&amp doc )\newline{\newline    QDomElement e;\newline    QDomNode n;\newline    QDomNodeList nl;\newline    int i = 0;\newline\newline    e = doc.firstChild().toElement();\newline    if ( e.tagName() != &quotUI&quot )\newline	return;\newline    if ( e.hasAttribute(&quotversion&quot) &amp&amp e.attribute(&quotversion&quot).toDouble() &gt= 4.0 )\newline	return;\newline\newline    e.setAttribute( &quotversion&quot, 4.0 );\newline\newline    e.setAttribute(&quotstdsetdef&quot, 1 );\newline    nl = doc.elementsByTagName( &quotproperty&quot );\newline    int nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline	bool stdset = toBool( e.attribute( &quotstdset&quot ) );\newline	if ( stdset || name == &quottoolTip&quot || name == &quotwhatsThis&quot ||\newline	     name == &quotbuddy&quot ||\newline	     e.parentNode().toElement().tagName() == &quotitem&quot ||\newline	     e.parentNode().toElement().tagName() == &quotspacer&quot ||\newline	     e.parentNode().toElement().tagName() == &quotcolumn&quot\newline	     )\newline	    e.removeAttribute( &quotstdset&quot );\newline	else\newline	    e.setAttribute( &quotstdset&quot, 0 );\newline    }\newline\newline    nl = doc.elementsByTagName( &quotattribute&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotimage&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotwidget&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotclass&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotclass&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline}\newline","!\newlineConvert Qt 2.x format to Qt 3.0 format if necessary\newline \newline","703121","system.c","void fpcrtl_interlockedIncrement__vars(int *i) {\newline    (*i)++;\newline}\newline","\newline XXX No protection currently!\newline \newline","253059","setup.c","void generate_blended_images(void)\newline{\newline    blended_igloos[0] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.06);\newline    blended_igloos[1] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.125);\newline    blended_igloos[2] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.185);\newline    blended_igloos[3] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.25);\newline    blended_igloos[4] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.5);\newline    blended_igloos[5] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.75);\newline    blended_igloos[6] = images[IMG_IGLOO_REBUILDING1];\newline    blended_igloos[7] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.25);\newline    blended_igloos[8] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.5);\newline    blended_igloos[9] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.75);\newline    blended_igloos[10] = images[IMG_IGLOO_REBUILDING2];\newline    blended_igloos[11] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.25);\newline    blended_igloos[12] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.5);\newline    blended_igloos[13] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.75);\newline    blended_igloos[14] = images[IMG_IGLOO_INTACT];\newline}\newline","Created images that are blends of two other images to smooth out\newlinethe transitions. \newline","3923522","mincresample.c","static void normalize_vector(double vector[])\newline{\newline   int idim;\newline   double magnitude;\newline\newline   /* Normalize the direction cosine */\newline   magnitude = 0.0;\newline   for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline      magnitude += (vector[idim] * vector[idim]);\newline   }\newline   magnitude = sqrt(magnitude);\newline   if (magnitude &gt 0.0) {\newline      for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline         vector[idim] /= magnitude;\newline      }\newline   }\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : normalize_vector\newline@INPUT : vector - 3D vector\newline@OUTPUT : (none)\newline@RETURNS : (nothing)\newline@DESCRIPTION: Routine to normalize a vector\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : November 9, 1995 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4538411","qwt_point_data.cpp","QwtCPointerData::QwtCPointerData(\newline        const double *x, const double *y, size_t size ):\newline    d_x( x ),\newline    d_y( y ),\newline    d_size( size )\newline{\newline}\newline","!\newlineConstructor\newline\\param x Array of x values\newline\\param y Array of y values\newline\\param size Size of the x and y arrays\newline\\warning The programmer must assure that the memory blocks referenced\newlineby the pointers remain valid during the lifetime of the\newlineQwtPlotCPointer object.\newline\\sa QwtPlotCurve::setData(), QwtPlotCurve::setRawSamples()\newline \newline","6005770","insmoddp.c","globle void MsgModifyMsgHandler(\newline  void *theEnv,\newline  DATA_OBJECT *result)\newline  {\newline   ModifyMsgHandlerSupport(theEnv,result,TRUE);\newline  }\newline","\newlineNAME : MsgModifyMsgHandler\newlineDESCRIPTION : Implementation for the USER class\newlinehandler message-modify\newlineImplements modify-instance message\newlinewith a series of put- messages\newlineINPUTS : A data object buffer to hold the\newlineresult\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Slot values updated\newlineNOTES : None\newline \newline","6345416","sha2.c","void sha2_hmac( unsigned char *key, int keylen,\newline                unsigned char *input, int ilen,\newline                unsigned char output[32] )\newline{\newline    int i;\newline    sha2_context ctx;\newline    unsigned char k_ipad[64];\newline    unsigned char k_opad[64];\newline    unsigned char tmpbuf[32];\newline\newline    memset( k_ipad, 0x36, 64 );\newline    memset( k_opad, 0x5C, 64 );\newline\newline    for( i = 0; i &lt keylen; i++ )\newline    {\newline        if( i &gt= 64 ) break;\newline\newline        k_ipad[i] ^= key[i];\newline        k_opad[i] ^= key[i];\newline    }\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_ipad, 64 );\newline    sha2_update( &ampctx, input, ilen );\newline    sha2_finish( &ampctx, tmpbuf );\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_opad, 64 );\newline    sha2_update( &ampctx, tmpbuf, 32 );\newline    sha2_finish( &ampctx, output );\newline\newline    memset( k_ipad, 0, 64 );\newline    memset( k_opad, 0, 64 );\newline    memset( tmpbuf, 0, 32 );\newline    memset( &ampctx, 0, sizeof( sha2_context ) );\newline}\newline","\newline Output = HMAC-SHA-2( input buffer, hmac key )\newline \newline","3908739","jsprf.cpp","static int LimitStuff(SprintfState *ss, const char *sp, JSUint32 len)\newline{\newline    JSUint32 limit = ss-&gtmaxlen - (ss-&gtcur - ss-&gtbase);\newline\newline    if (len &gt limit) {\newline        len = limit;\newline    }\newline    while (len) {\newline        --len;\newline        *ss-&gtcur++ = *sp++;\newline    }\newline    return 0;\newline}\newline","\newline Stuff routine that discards overflow data\newline \newline","2808524","sspm.c","void sspm_build_header(struct sspm_header *header, char* line)\newline{\newline    char *prop;\newline    char *val;\newline    \newline    val = sspm_strdup(sspm_value(line));\newline    prop = sspm_strdup(sspm_property_name(line));\newline\newline    if(strcmp(prop,&quotContent-Type&quot) == 0){\newline	\newline	/* Create a new mime_header, fill in content-type\newline	   and possibly boundary */\newline	\newline	char* boundary= sspm_get_parameter(line,&quotboundary&quot);\newline	\newline	header-&gtdef = 0;\newline	header-&gtmajor = sspm_find_major_content_type(val);\newline	header-&gtminor = sspm_find_minor_content_type(val);\newline	\newline	if(header-&gtminor == SSPM_UNKNOWN_MINOR_TYPE){\newline	    char *p = strchr(val,&#039/&#039);\newline	    \newline	    if (p != 0){\newline		p++; /* Skip the &#039/&#039 */\newline		\newline		header-&gtminor_text = sspm_strdup(p);\newline	    } else {\newline		/* Error, malformed content type */\newline		header-&gtminor_text = sspm_strdup(&quotunknown&quot);\newline	    }\newline	}\newline	if (boundary != 0){\newline	    header-&gtboundary = sspm_strdup(boundary);\newline	}\newline	\newline    } else if(strcmp(prop,&quotContent-Transfer-Encoding&quot)==0){\newline	char* encoding = sspm_value(line);\newline	char* lencoding = sspm_lowercase(encoding);\newline\newline	if(strcmp(lencoding,&quotbase64&quot)==0){\newline	    header-&gtencoding = SSPM_BASE64_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotquoted-printable&quot)==0){\newline	    header-&gtencoding = SSPM_QUOTED_PRINTABLE_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotbinary&quot)==0){\newline	    header-&gtencoding = SSPM_BINARY_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot7bit&quot)==0){\newline	    header-&gtencoding = SSPM_7BIT_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot8bit&quot)==0){\newline	    header-&gtencoding = SSPM_8BIT_ENCODING;\newline	} else {\newline	    header-&gtencoding = SSPM_UNKNOWN_ENCODING;\newline	}\newline\newline\newline	free(lencoding);\newline\newline	header-&gtdef = 0;\newline	\newline    } else if(strcmp(prop,&quotContent-Id&quot)==0){\newline	char* cid = sspm_value(line);\newline	header-&gtcontent_id = sspm_strdup(cid);\newline	header-&gtdef = 0;\newline	\newline    }\newline    free(val);\newline    free(prop);\newline}\newline","Interpret a header line and add its data to the header\newlinestructure. \newline","2469258","softhddev.c","const char *CommandLineHelp(void)\newline{\newline    return &quot  -a device\\taudio device (fe. alsa: hw:0,0 oss: /dev/dsp)\\n&quot\newline	&quot  -p device\\taudio device for pass-through (hw:0,1 or /dev/dsp1)\\n&quot\newline	&quot  -c channel\\taudio mixer channel name (fe. PCM)\\n&quot\newline	&quot  -d display\\tdisplay of x11 server (fe. :0.0)\\n&quot\newline	&quot  -f\\t\\tstart with fullscreen window (only with window manager)\\n&quot\newline	&quot  -g geometry\\tx11 window geometry wxh+x+y\\n&quot\newline	&quot  -v device\\tvideo driver device (va-api, vdpau, noop)\\n&quot\newline	&quot  -s\\t\\tstart in suspended mode\\n&quot\newline	&quot  -x\\t\\tstart x11 server, with -xx try to connect, if this fails\\n&quot\newline	&quot  -X args\\tX11 server arguments (f.e. -nocursor)\\n&quot\newline	&quot  -w workaround\\tenable/disable workarounds\\n&quot\newline	&quot\\tno-hw-decoder\\t\\tdisable hw decoder, use software decoder only\\n&quot\newline	&quot\\tno-mpeg-hw-decoder\\tdisable hw decoder for mpeg only\\n&quot\newline	&quot\\tstill-hw-decoder\\tenable hardware decoder for still-pictures\\n&quot\newline	&quot\\tstill-h264-hw-decoder\\tenable h264 hw decoder for still-pictures\\n&quot\newline	&quot\\talsa-driver-broken\\tdisable broken alsa driver message\\n&quot\newline	&quot\\talsa-no-close-open\\tdisable close open to fix alsa no sound bug\\n&quot\newline	&quot\\talsa-close-open-delay\\tenable close open delay to fix no sound bug\\n&quot\newline	&quot\\tignore-repeat-pict\\tdisable repeat pict message\\n&quot\newline	&quot\\tuse-possible-defect-frames prefer faster channel switch\\n&quot\newline	&quot  -D\\t\\tstart in detached mode\\n&quot;\newline}\newline","\newline Return command line help string.\newline \newline","5459428","gl-subsystem.c","struct fbo_info *get_fbo(struct gs_device *device,\newline		uint32_t width, uint32_t height, enum gs_color_format format)\newline{\newline	size_t i;\newline	GLuint fbo;\newline	struct fbo_info *ptr;\newline\newline	for (i = 0; i &lt device-&gtfbos.num; i++) {\newline		ptr = device-&gtfbos.array[i];\newline\newline		if (ptr-&gtwidth  == width &amp&amp ptr-&gtheight == height &amp&amp\newline		    ptr-&gtformat == format)\newline			return ptr;\newline	}\newline\newline	glGenFramebuffers(1, &ampfbo);\newline	if (!gl_success(&quotglGenFramebuffers&quot))\newline		return NULL;\newline\newline	ptr = bmalloc(sizeof(struct fbo_info));\newline	ptr-&gtfbo                 = fbo;\newline	ptr-&gtwidth               = width;\newline	ptr-&gtheight              = height;\newline	ptr-&gtformat              = format;\newline	ptr-&gtcur_render_target   = NULL;\newline	ptr-&gtcur_render_side     = 0;\newline	ptr-&gtcur_zstencil_buffer = NULL;\newline\newline	da_push_back(device-&gtfbos, &ampptr);\newline	return ptr;\newline}\newline","\newline This automatically manages FBOs so that render targets are always given\newline an FBO that matches their width/height/format to maximize optimization\newline \newline","","","","on","","on","","","on","","","","on","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","","Destroy scalar","Gets the next available tilda instance number.","Convert Qt 2.x format to Qt 3.0 format","{}","Created images that are blends of two other images","{}","The programmer must assure that the memory blocks referenced","Implements modify-instance message","{}","discards overflow data","Interpret a header line and add its data to the headerstructure.","Checks to see if the allocated size","{}","automatically manages FBOs","{}","called from the SEAS action dispatcher","returns number of bytes read,","returnsthe number of matching samples,","Set the next used loop device","{}","open a given stream."
"32LAQ1JNT9POLLDTK7SLZHHXMOMTU0","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","3","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Thu Apr 25 10:54:28 PDT 2019","","","3SNLUL3WO4N2PS2H10VV29358Z2LUV","AVC62JNYAXA45","Approved","Wed Apr 17 14:14:03 PDT 2019","Wed Apr 17 14:43:41 PDT 2019","Fri Apr 19 14:43:41 PDT 2019","2019-04-19 21:44:21 UTC","","","1778","100% (24/24)","100% (24/24)","100% (24/24)","4515541","xmlrpc.c","void xmlrpc_scalar_destroy(XMLRPCScalar *scalar)\newline{\newline    if (scalar == NULL)\newline        return;\newline\newline    octstr_destroy(scalar-&gts_str);\newline    octstr_destroy(scalar-&gts_date);\newline    octstr_destroy(scalar-&gts_base64);\newline    \newline    gw_free(scalar);\newline}\newline","Destroy scalar \newline","4623939","fix_qbmsst.cpp","void FixQBMSST::check_alloc(int n)\newline{\newline  if ( atoms_allocated &lt n ) {\newline    memory-&gtdestroy(old_velocity);\newline    memory-&gtcreate(old_velocity,n,3,&quotqbmsst:old_velocity&quot);\newline    atoms_allocated = n;\newline  }\newline}\newline","----------------------------------------------------------------------\newlineChecks to see if the allocated size of old_velocity is &gt= n\newlineThe number of local atoms can change during a parallel run.\newline------------------------------------------------------------------------- \newline","5179053","xml_node_set.c","static VALUE slice(int argc, VALUE *argv, VALUE self)\newline{\newline  VALUE arg ;\newline  long beg, len ;\newline  xmlNodeSetPtr node_set;\newline\newline  Data_Get_Struct(self, xmlNodeSet, node_set);\newline\newline  if (argc == 2) {\newline    beg = NUM2LONG(argv[0]);\newline    len = NUM2LONG(argv[1]);\newline    if (beg &lt 0) {\newline      beg += node_set-&gtnodeNr ;\newline    }\newline    return subseq(self, beg, len);\newline  }\newline\newline  if (argc != 1) {\newline    rb_scan_args(argc, argv, &quot11&quot, NULL, NULL);\newline  }\newline  arg = argv[0];\newline\newline  if (FIXNUM_P(arg)) {\newline    return index_at(self, FIX2LONG(arg));\newline  }\newline\newline  /* if arg is Range */\newline  switch (rb_range_beg_len(arg, &ampbeg, &amplen, (long)node_set-&gtnodeNr, 0)) {\newline  case Qfalse:\newline    break;\newline  case Qnil:\newline    return Qnil;\newline  default:\newline    return subseq(self, beg, len);\newline  }\newline\newline  return index_at(self, NUM2LONG(arg));\newline}\newline","\newline call-seq:\newline [index] -&gt Node or nil\newline [start, length] -&gt NodeSet or nil\newline [range] -&gt NodeSet or nil\newline slice(index) -&gt Node or nil\newline slice(start, length) -&gt NodeSet or nil\newline slice(range) -&gt NodeSet or nil\newline \newline Element reference - returns the node at +index+, or returns a NodeSet\newline containing nodes starting at +start+ and continuing for +length+ elements, or\newline returns a NodeSet containing nodes specified by +range+. Negative +indices+\newline count backward from the end of the +node_set+ (-1 is the last node). Returns\newline nil if the +index+ (or +start+) are out of range.\newline \newline","4476453","statistics.c","void action_stat(struct cell *t)\newline{\newline   unsigned int seas_dispatch/*,as_delay*/;\newline   struct timeval *t1,*t2/*,*t3*/;\newline   struct statscell *s;\newline   struct totag_elem *to;\newline   if(t==0)\newline      return;\newline   if(t-&gtfwded_totags == 0){\newline      LM_DBG(&quotseas:event_stat() unable to set the event_stat timeval:&quot\newline			  &quot no payload found at cell!! (fwded_totags=0)\\n&quot);\newline      return;\newline   }\newline   to=t-&gtfwded_totags;\newline   while(to){\newline      if(to-&gtacked==STATS_PAY){\newline	 s=(struct statscell *)to-&gttag.s;\newline	 gettimeofday(&amp(s-&gtu.uas.action_recvd),NULL);\newline	 break;\newline      }else\newline	 to=to-&gtnext;\newline   }\newline   /**no statistics found**/\newline   if(to==0)\newline      return;\newline   t1=&amp(s-&gtu.uas.as_relay);\newline   t2=&amp(s-&gtu.uas.event_sent);\newline/*   t3=&amp(s-&gtu.uas.action_recvd); */\newline   seas_dispatch = (t2-&gttv_sec - t1-&gttv_sec)*1000 + (t2-&gttv_usec-t1-&gttv_usec)/1000;\newline/*   as_delay = (t3-&gttv_sec - t2-&gttv_sec)*1000 + (t3-&gttv_usec-t2-&gttv_usec)/1000; */\newline\newline   lock_get(seas_stats_table-&gtmutex);\newline   {\newline      seas_stats_table-&gtdispatch[assignIndex(seas_dispatch)]++;\newline      seas_stats_table-&gtevent[assignIndex(seas_dispatch)]++;\newline      (seas_stats_table-&gtfinished_transactions)++;\newline   }\newline   lock_release(seas_stats_table-&gtmutex);\newline}\newline","this will be called from the SEAS action dispatcher\newline when it receives the action from the socket\newline \newline","4474917","tls_conn_ops.h","static int _tls_read(struct tcp_connection *c, void *buf, size_t len)\newline{\newline	int ret, err;\newline	SSL *ssl;\newline\newline	ssl = c-&gtextra_data;\newline\newline	ret = SSL_read(ssl, buf, len);\newline	if (ret &gt 0) {\newline		LM_DBG(&quot%d bytes read\\n&quot, ret);\newline		return ret;\newline	} else if (ret == 0) {\newline		/* unclean shutdown of the other peer */\newline		c-&gtstate = S_CONN_EOF;\newline		return 0;\newline	} else {\newline		err = SSL_get_error(ssl, ret);\newline		switch (err) {\newline		case SSL_ERROR_ZERO_RETURN:\newline			LM_DBG(&quotTLS connection to %s:%d closed cleanly\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			/*\newline			* mark end of file\newline			*/\newline			c-&gtstate = S_CONN_EOF;\newline			return 0;\newline\newline		case SSL_ERROR_WANT_READ:\newline		case SSL_ERROR_WANT_WRITE:\newline			return 0;\newline\newline		case SSL_ERROR_SYSCALL:\newline			LM_ERR(&quotSYSCALL error -&gt (%d) &lt%s&gt\\n&quot,errno,strerror(errno));\newline		default:\newline			LM_ERR(&quotTLS connection to %s:%d read failed\\n&quot,\newline				ip_addr2a(&ampc-&gtrcv.src_ip), c-&gtrcv.src_port);\newline			LM_ERR(&quotTLS read error: %d\\n&quot,err);\newline			c-&gtstate = S_CONN_BAD;\newline			tls_print_errstack();\newline			return -1;\newline		}\newline	}\newline\newline	LM_BUG(&quotbug\\n&quot);\newline	return -1;\newline}\newline","\newline Wrapper around SSL_read\newline \newline returns number of bytes read, 0 on eof and transits into S_CONN_EOF, -1\newline on error\newline \newline","2254150","gap.c","long i_paranoia_overlap_f(int16_t *buffA,int16_t *buffB,\newline			  long offsetA, long offsetB,\newline			  long sizeA,long sizeB){\newline  long endA=offsetA;\newline  long endB=offsetB;\newline  \newline  /* Start at the given offsets and work our way forward until we hit\newline   * the end of one of the vectors.\newline   */\newline  for(;endA&ltsizeA &amp&amp endB&ltsizeB;endA++,endB++)\newline    if(buffA[endA]!=buffB[endB])break;\newline  \newline  return(endA-offsetA);\newline}\newline","===========================================================================\newline i_paranoia_overlap_f (internal)\newline \newline This function seeks forward through two vectors (starting at the given\newline offsets) to determine how many consecutive samples agree. It returns\newline the number of matching samples, which may be 0.\newline \newline Unlike its sibling, i_paranoia_overlap_r, this function needs to given\newline the size of the vectors.\newline \newline This function is used by i_analyze_rift_f() below to find where a\newline trailing rift ends.\newline \newline","4946453","loopdev.c","static int loopcxt_next_from_proc(struct loopdev_cxt *lc)\newline{\newline	struct loopdev_iter *iter = &amplc-&gtiter;\newline	char buf[BUFSIZ];\newline\newline	DBG(ITER, ul_debugobj(iter, &quotscan /proc/partitions&quot));\newline\newline	if (!iter-&gtproc)\newline		iter-&gtproc = fopen(_PATH_PROC_PARTITIONS, &quotr&quot UL_CLOEXECSTR);\newline	if (!iter-&gtproc)\newline		return 1;\newline\newline	while (fgets(buf, sizeof(buf), iter-&gtproc)) {\newline		unsigned int m;\newline		char name[128 + 1];\newline\newline\newline		if (sscanf(buf, &quot %u %*s %*s %128[^\\n ]&quot,\newline			   &ampm, name) != 2 || m != LOOPDEV_MAJOR)\newline			continue;\newline\newline		DBG(ITER, ul_debugobj(iter, &quotchecking %s&quot, name));\newline\newline		if (loopiter_set_device(lc, name) == 0)\newline			return 0;\newline	}\newline\newline	return 1;\newline}\newline","\newline Set the next used loop device according to /proc/partitions.\newline \newline Loop devices smaller than 512 bytes are invisible for this function.\newline \newline","1831586","corresp.c","static int identical_refs(int npaths,PATH **paths){\newline  int p, w, wp;  \newline\newline  if (npaths == 0) {return 0;}\newline  if (npaths == 1) {return 1;}\newline\newline  for (p=1; p&ltnpaths; p++){\newline    w=0; wp=0;\newline    while (w &lt paths[0]-&gtnum &amp&amp wp &lt paths[p]-&gtnum){\newline      /* skip insertions */\newline      while (w &lt paths[0]-&gtnum &amp&amp (paths[0]-&gtpset[w].eval == P_INS))\newline	w++;\newline      while (wp &lt paths[p]-&gtnum &amp&amp (paths[p]-&gtpset[wp].eval == P_INS))\newline	wp++;\newline      if (w &gt= paths[0]-&gtnum &amp&amp wp &gt= paths[p]-&gtnum)\newline	;\newline      else {\newline	if (w &gt paths[0]-&gtnum || wp &gt paths[p]-&gtnum)\newline	  return 0;\newline	if (TEXT_strcmp(((WORD *)(paths[0]-&gtpset[w].a_ptr))-&gtvalue,\newline			((WORD *)(paths[p]-&gtpset[wp].a_ptr))-&gtvalue) != 0)\newline	  return(0);\newline	w++; wp++;\newline      }\newline    }    \newline  }\newline  return 1;\newline}\newline","return 1 if the paths have the identical reference strings \newline","6580400","ffmpeg.c","static int stream_component_open(priv_t * ffmpeg, int stream_index)\newline{\newline  AVFormatContext *ic = ffmpeg-&gtctxt;\newline  AVCodecContext *enc;\newline  AVCodec *codec;\newline\newline  if (stream_index &lt 0 || stream_index &gt= (int)(ic-&gtnb_streams))\newline    return -1;\newline  enc = ic-&gtstreams[stream_index]-&gtcodec;\newline\newline  /* hack for AC3. XXX: suppress that */\newline  if (enc-&gtchannels &gt 2)\newline    enc-&gtchannels = 2;\newline\newline  codec = avcodec_find_decoder(enc-&gtcodec_id);\newline  enc-&gtworkaround_bugs = 1;\newline#if LIBAVCODEC_VERSION_INT &lt ((52&lt&lt16)+(0&lt&lt8)+0)\newline  enc-&gterror_resilience = 1;\newline#else\newline  enc-&gterror_recognition = 1;\newline#endif\newline\newline  if (!codec || avcodec_open(enc, codec) &lt 0)\newline    return -1;\newline  if (enc-&gtcodec_type != AVMEDIA_TYPE_AUDIO) {\newline    lsx_fail(&quotffmpeg CODEC %x is not an audio CODEC&quot, enc-&gtcodec_type);\newline    return -1;\newline  }\newline\newline  ffmpeg-&gtaudio_stream = stream_index;\newline  ffmpeg-&gtaudio_st = ic-&gtstreams[stream_index];\newline  ffmpeg-&gtaudio_buf_size = 0;\newline  ffmpeg-&gtaudio_buf_index = 0;\newline\newline  memset(&ampffmpeg-&gtaudio_pkt, 0, sizeof(ffmpeg-&gtaudio_pkt));\newline\newline  return 0;\newline}\newline","open a given stream. Return 0 if OK \newline","5141550","tilda.c","static gint get_instance_number ()\newline{\newline    DEBUG_FUNCTION (&quotget_instance_number&quot);\newline\newline    gchar *name;\newline\newline    GSequence *seq;\newline    GSequenceIter *iter;\newline    gint lowest_lock_instance = 0;\newline    gint current_lock_instance;\newline\newline    GDir *dir;\newline    struct lock_info *lock;\newline    gchar *lock_dir = g_build_filename (g_get_user_cache_dir (), &quottilda&quot, &quotlocks&quot, NULL);\newline\newline    /* Open the lock directory */\newline    dir = g_dir_open (lock_dir, 0, NULL);\newline\newline    /* Check for failure to open */\newline    if (dir == NULL)\newline    {\newline        g_printerr (_(&quotUnable to open lock directory: %s\\n&quot), lock_dir);\newline        g_free (lock_dir);\newline        return 0;\newline    }\newline\newline    /* Look through every file in the lock directory, and see if it is a lock file.\newline     * If it is a lock file, insert it in a sorted sequence. */\newline    seq = g_sequence_new(NULL);\newline    while ((name = (gchar*)g_dir_read_name (dir)) != NULL)\newline    {\newline        lock = islockfile (name);\newline\newline        if (lock != NULL)\newline        {\newline            g_sequence_insert_sorted(seq, GINT_TO_POINTER(lock-&gtinstance), (GCompareDataFunc)_cmp_locks, NULL);\newline            g_free (lock);\newline        }\newline    }\newline\newline    g_dir_close (dir);\newline    g_free (lock_dir);\newline\newline    /* We iterate the sorted sequence of lock instances to find the first (lowest) number *not* taken. */\newline    for (iter = g_sequence_get_begin_iter(seq); !g_sequence_iter_is_end(iter); iter = g_sequence_iter_next(iter)) {\newline      current_lock_instance = GPOINTER_TO_INT(g_sequence_get(iter));\newline      if (lowest_lock_instance &lt current_lock_instance)\newline        break;\newline      else\newline        lowest_lock_instance = current_lock_instance + 1;\newline    }\newline\newline    g_sequence_free(seq);\newline\newline    return lowest_lock_instance;\newline}\newline","\newline get_instance_number ()\newline \newline Gets the next available tilda instance number. This will always pick the\newline lowest non-running tilda available.\newline \newline Success: return next available instance number (&gt=0)\newline Failure: return 0\newline \newline","1052275","domtool.cpp","void DomTool::fixDocument( QDomDocument&amp doc )\newline{\newline    QDomElement e;\newline    QDomNode n;\newline    QDomNodeList nl;\newline    int i = 0;\newline\newline    e = doc.firstChild().toElement();\newline    if ( e.tagName() != &quotUI&quot )\newline	return;\newline    if ( e.hasAttribute(&quotversion&quot) &amp&amp e.attribute(&quotversion&quot).toDouble() &gt= 4.0 )\newline	return;\newline\newline    e.setAttribute( &quotversion&quot, 4.0 );\newline\newline    e.setAttribute(&quotstdsetdef&quot, 1 );\newline    nl = doc.elementsByTagName( &quotproperty&quot );\newline    int nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline	bool stdset = toBool( e.attribute( &quotstdset&quot ) );\newline	if ( stdset || name == &quottoolTip&quot || name == &quotwhatsThis&quot ||\newline	     name == &quotbuddy&quot ||\newline	     e.parentNode().toElement().tagName() == &quotitem&quot ||\newline	     e.parentNode().toElement().tagName() == &quotspacer&quot ||\newline	     e.parentNode().toElement().tagName() == &quotcolumn&quot\newline	     )\newline	    e.removeAttribute( &quotstdset&quot );\newline	else\newline	    e.setAttribute( &quotstdset&quot, 0 );\newline    }\newline\newline    nl = doc.elementsByTagName( &quotattribute&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotimage&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotname&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotname&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline    nl = doc.elementsByTagName( &quotwidget&quot );\newline    nllen = nl.length();\newline    for ( i = 0; i &lt nllen; i++ ) {\newline	e = nl.item(i).toElement();\newline	QString name;\newline	QDomElement n2 = e.firstChild().toElement();\newline	if ( n2.tagName() == &quotclass&quot ) {\newline	    name = n2.firstChild().toText().data();\newline	    e.setAttribute( &quotclass&quot, name );\newline	    e.removeChild( n2 );\newline	}\newline    }\newline\newline}\newline","!\newlineConvert Qt 2.x format to Qt 3.0 format if necessary\newline \newline","703121","system.c","void fpcrtl_interlockedIncrement__vars(int *i) {\newline    (*i)++;\newline}\newline","\newline XXX No protection currently!\newline \newline","253059","setup.c","void generate_blended_images(void)\newline{\newline    blended_igloos[0] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.06);\newline    blended_igloos[1] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.125);\newline    blended_igloos[2] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.185);\newline    blended_igloos[3] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.25);\newline    blended_igloos[4] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.5);\newline    blended_igloos[5] = T4K_Blend(images[IMG_IGLOO_REBUILDING1],NULL,0.75);\newline    blended_igloos[6] = images[IMG_IGLOO_REBUILDING1];\newline    blended_igloos[7] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.25);\newline    blended_igloos[8] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.5);\newline    blended_igloos[9] = T4K_Blend(images[IMG_IGLOO_REBUILDING2],images[IMG_IGLOO_REBUILDING1],0.75);\newline    blended_igloos[10] = images[IMG_IGLOO_REBUILDING2];\newline    blended_igloos[11] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.25);\newline    blended_igloos[12] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.5);\newline    blended_igloos[13] = T4K_Blend(images[IMG_IGLOO_INTACT],images[IMG_IGLOO_REBUILDING2],0.75);\newline    blended_igloos[14] = images[IMG_IGLOO_INTACT];\newline}\newline","Created images that are blends of two other images to smooth out\newlinethe transitions. \newline","3923522","mincresample.c","static void normalize_vector(double vector[])\newline{\newline   int idim;\newline   double magnitude;\newline\newline   /* Normalize the direction cosine */\newline   magnitude = 0.0;\newline   for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline      magnitude += (vector[idim] * vector[idim]);\newline   }\newline   magnitude = sqrt(magnitude);\newline   if (magnitude &gt 0.0) {\newline      for (idim=0; idim &lt WORLD_NDIMS; idim++) {\newline         vector[idim] /= magnitude;\newline      }\newline   }\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : normalize_vector\newline@INPUT : vector - 3D vector\newline@OUTPUT : (none)\newline@RETURNS : (nothing)\newline@DESCRIPTION: Routine to normalize a vector\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : November 9, 1995 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4538411","qwt_point_data.cpp","QwtCPointerData::QwtCPointerData(\newline        const double *x, const double *y, size_t size ):\newline    d_x( x ),\newline    d_y( y ),\newline    d_size( size )\newline{\newline}\newline","!\newlineConstructor\newline\\param x Array of x values\newline\\param y Array of y values\newline\\param size Size of the x and y arrays\newline\\warning The programmer must assure that the memory blocks referenced\newlineby the pointers remain valid during the lifetime of the\newlineQwtPlotCPointer object.\newline\\sa QwtPlotCurve::setData(), QwtPlotCurve::setRawSamples()\newline \newline","6005770","insmoddp.c","globle void MsgModifyMsgHandler(\newline  void *theEnv,\newline  DATA_OBJECT *result)\newline  {\newline   ModifyMsgHandlerSupport(theEnv,result,TRUE);\newline  }\newline","\newlineNAME : MsgModifyMsgHandler\newlineDESCRIPTION : Implementation for the USER class\newlinehandler message-modify\newlineImplements modify-instance message\newlinewith a series of put- messages\newlineINPUTS : A data object buffer to hold the\newlineresult\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Slot values updated\newlineNOTES : None\newline \newline","6345416","sha2.c","void sha2_hmac( unsigned char *key, int keylen,\newline                unsigned char *input, int ilen,\newline                unsigned char output[32] )\newline{\newline    int i;\newline    sha2_context ctx;\newline    unsigned char k_ipad[64];\newline    unsigned char k_opad[64];\newline    unsigned char tmpbuf[32];\newline\newline    memset( k_ipad, 0x36, 64 );\newline    memset( k_opad, 0x5C, 64 );\newline\newline    for( i = 0; i &lt keylen; i++ )\newline    {\newline        if( i &gt= 64 ) break;\newline\newline        k_ipad[i] ^= key[i];\newline        k_opad[i] ^= key[i];\newline    }\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_ipad, 64 );\newline    sha2_update( &ampctx, input, ilen );\newline    sha2_finish( &ampctx, tmpbuf );\newline\newline    sha2_starts( &ampctx );\newline    sha2_update( &ampctx, k_opad, 64 );\newline    sha2_update( &ampctx, tmpbuf, 32 );\newline    sha2_finish( &ampctx, output );\newline\newline    memset( k_ipad, 0, 64 );\newline    memset( k_opad, 0, 64 );\newline    memset( tmpbuf, 0, 32 );\newline    memset( &ampctx, 0, sizeof( sha2_context ) );\newline}\newline","\newline Output = HMAC-SHA-2( input buffer, hmac key )\newline \newline","3908739","jsprf.cpp","static int LimitStuff(SprintfState *ss, const char *sp, JSUint32 len)\newline{\newline    JSUint32 limit = ss-&gtmaxlen - (ss-&gtcur - ss-&gtbase);\newline\newline    if (len &gt limit) {\newline        len = limit;\newline    }\newline    while (len) {\newline        --len;\newline        *ss-&gtcur++ = *sp++;\newline    }\newline    return 0;\newline}\newline","\newline Stuff routine that discards overflow data\newline \newline","2808524","sspm.c","void sspm_build_header(struct sspm_header *header, char* line)\newline{\newline    char *prop;\newline    char *val;\newline    \newline    val = sspm_strdup(sspm_value(line));\newline    prop = sspm_strdup(sspm_property_name(line));\newline\newline    if(strcmp(prop,&quotContent-Type&quot) == 0){\newline	\newline	/* Create a new mime_header, fill in content-type\newline	   and possibly boundary */\newline	\newline	char* boundary= sspm_get_parameter(line,&quotboundary&quot);\newline	\newline	header-&gtdef = 0;\newline	header-&gtmajor = sspm_find_major_content_type(val);\newline	header-&gtminor = sspm_find_minor_content_type(val);\newline	\newline	if(header-&gtminor == SSPM_UNKNOWN_MINOR_TYPE){\newline	    char *p = strchr(val,&#039/&#039);\newline	    \newline	    if (p != 0){\newline		p++; /* Skip the &#039/&#039 */\newline		\newline		header-&gtminor_text = sspm_strdup(p);\newline	    } else {\newline		/* Error, malformed content type */\newline		header-&gtminor_text = sspm_strdup(&quotunknown&quot);\newline	    }\newline	}\newline	if (boundary != 0){\newline	    header-&gtboundary = sspm_strdup(boundary);\newline	}\newline	\newline    } else if(strcmp(prop,&quotContent-Transfer-Encoding&quot)==0){\newline	char* encoding = sspm_value(line);\newline	char* lencoding = sspm_lowercase(encoding);\newline\newline	if(strcmp(lencoding,&quotbase64&quot)==0){\newline	    header-&gtencoding = SSPM_BASE64_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotquoted-printable&quot)==0){\newline	    header-&gtencoding = SSPM_QUOTED_PRINTABLE_ENCODING;\newline	} else 	if(strcmp(lencoding,&quotbinary&quot)==0){\newline	    header-&gtencoding = SSPM_BINARY_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot7bit&quot)==0){\newline	    header-&gtencoding = SSPM_7BIT_ENCODING;\newline	} else 	if(strcmp(lencoding,&quot8bit&quot)==0){\newline	    header-&gtencoding = SSPM_8BIT_ENCODING;\newline	} else {\newline	    header-&gtencoding = SSPM_UNKNOWN_ENCODING;\newline	}\newline\newline\newline	free(lencoding);\newline\newline	header-&gtdef = 0;\newline	\newline    } else if(strcmp(prop,&quotContent-Id&quot)==0){\newline	char* cid = sspm_value(line);\newline	header-&gtcontent_id = sspm_strdup(cid);\newline	header-&gtdef = 0;\newline	\newline    }\newline    free(val);\newline    free(prop);\newline}\newline","Interpret a header line and add its data to the header\newlinestructure. \newline","2469258","softhddev.c","const char *CommandLineHelp(void)\newline{\newline    return &quot  -a device\\taudio device (fe. alsa: hw:0,0 oss: /dev/dsp)\\n&quot\newline	&quot  -p device\\taudio device for pass-through (hw:0,1 or /dev/dsp1)\\n&quot\newline	&quot  -c channel\\taudio mixer channel name (fe. PCM)\\n&quot\newline	&quot  -d display\\tdisplay of x11 server (fe. :0.0)\\n&quot\newline	&quot  -f\\t\\tstart with fullscreen window (only with window manager)\\n&quot\newline	&quot  -g geometry\\tx11 window geometry wxh+x+y\\n&quot\newline	&quot  -v device\\tvideo driver device (va-api, vdpau, noop)\\n&quot\newline	&quot  -s\\t\\tstart in suspended mode\\n&quot\newline	&quot  -x\\t\\tstart x11 server, with -xx try to connect, if this fails\\n&quot\newline	&quot  -X args\\tX11 server arguments (f.e. -nocursor)\\n&quot\newline	&quot  -w workaround\\tenable/disable workarounds\\n&quot\newline	&quot\\tno-hw-decoder\\t\\tdisable hw decoder, use software decoder only\\n&quot\newline	&quot\\tno-mpeg-hw-decoder\\tdisable hw decoder for mpeg only\\n&quot\newline	&quot\\tstill-hw-decoder\\tenable hardware decoder for still-pictures\\n&quot\newline	&quot\\tstill-h264-hw-decoder\\tenable h264 hw decoder for still-pictures\\n&quot\newline	&quot\\talsa-driver-broken\\tdisable broken alsa driver message\\n&quot\newline	&quot\\talsa-no-close-open\\tdisable close open to fix alsa no sound bug\\n&quot\newline	&quot\\talsa-close-open-delay\\tenable close open delay to fix no sound bug\\n&quot\newline	&quot\\tignore-repeat-pict\\tdisable repeat pict message\\n&quot\newline	&quot\\tuse-possible-defect-frames prefer faster channel switch\\n&quot\newline	&quot  -D\\t\\tstart in detached mode\\n&quot;\newline}\newline","\newline Return command line help string.\newline \newline","5459428","gl-subsystem.c","struct fbo_info *get_fbo(struct gs_device *device,\newline		uint32_t width, uint32_t height, enum gs_color_format format)\newline{\newline	size_t i;\newline	GLuint fbo;\newline	struct fbo_info *ptr;\newline\newline	for (i = 0; i &lt device-&gtfbos.num; i++) {\newline		ptr = device-&gtfbos.array[i];\newline\newline		if (ptr-&gtwidth  == width &amp&amp ptr-&gtheight == height &amp&amp\newline		    ptr-&gtformat == format)\newline			return ptr;\newline	}\newline\newline	glGenFramebuffers(1, &ampfbo);\newline	if (!gl_success(&quotglGenFramebuffers&quot))\newline		return NULL;\newline\newline	ptr = bmalloc(sizeof(struct fbo_info));\newline	ptr-&gtfbo                 = fbo;\newline	ptr-&gtwidth               = width;\newline	ptr-&gtheight              = height;\newline	ptr-&gtformat              = format;\newline	ptr-&gtcur_render_target   = NULL;\newline	ptr-&gtcur_render_side     = 0;\newline	ptr-&gtcur_zstencil_buffer = NULL;\newline\newline	da_push_back(device-&gtfbos, &ampptr);\newline	return ptr;\newline}\newline","\newline This automatically manages FBOs so that render targets are always given\newline an FBO that matches their width/height/format to maximize optimization\newline \newline","","","","on","","","on","","on","","","","","","","on","","","","","","","","","","","","","","","","","","","on","on","","","","","","","Destroy scalar","Gets the next available tilda instance number.","Convert Qt 2.x format to Qt 3.0 format","{}","Created images that are blends of two other images","normalize a vector","{}","Implements modify-instance message","{}","discards overflow data","Interpret a header line and add its data to the headerstructure.","Checks to see if the allocated size of old_velocity is >= n","Return command line help string.","manages FBOs","returns the node at +index+, or returns a NodeSet","{}","returns number of bytes read,","determine how many consecutive samples agree.","Set the next used loop device according to /proc/partitions.","return 1 if the paths have the identical reference strings","open a given stream."
"32ZCLEW0BZKHFD9SRRFNN57PG53JPP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","32AT8R96GL9PT5X7L9SWEVH00THUSP","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:44:45 PDT 2019","Wed Apr 17 14:52:31 PDT 2019","Fri Apr 19 14:52:31 PDT 2019","2019-04-19 21:53:21 UTC","","","466","100% (27/27)","100% (27/27)","100% (27/27)","1577449","crosstabeditor.cpp","CrossTabEditor::CrossTabEditor(QWidget* parent)\newline    : QDialog(parent)\newline{\newline    setupUi(this);\newline\newline\newline    // signals and slots connections\newline    connect(buttonOk, SIGNAL(clicked()), this, SLOT(accept()));\newline    connect(buttonCancel, SIGNAL(clicked()), this, SLOT(reject()));\newline    connect(btnFont, SIGNAL(clicked()), this, SLOT(btnFont_clicked()));\newline}\newline","\newline Constructs a CrossTabEditor as a child of &#039parent&#039, with the\newline name &#039name&#039 and widget flags set to &#039f&#039.\newline \newline The dialog will by default be modeless, unless you set &#039modal&#039 to\newline true to construct a modal dialog.\newline \newline","6581777","clirpc.c","int dcc_read_link(const char* fname, char *points_to)\newline{\newline    int len;\newline    if ((len = readlink(fname, points_to, MAXPATHLEN)) == -1) {\newline        rs_log_error(&quotreadlink &#039%s&#039 failed: %s&quot, fname, strerror(errno));\newline        return EXIT_IO_ERROR;\newline    }\newline    points_to[len] = &#039\\0&#039;\newline    return 0;\newline}\newline","points_to must be at least MAXPATHLEN + 1 long \newline","4318047","preproc.c","static int do_directive(Token * tline)\newline{\newline    enum preproc_token i;\newline    int j;\newline    bool err;\newline    int nparam;\newline    bool nolist;\newline    bool casesense;\newline    int k, m;\newline    int offset;\newline    char *p, *pp;\newline    const char *mname;\newline    Include *inc;\newline    Context *ctx;\newline    Cond *cond;\newline    MMacro *mmac, **mmhead;\newline    Token *t = NULL, *tt, *param_start, *macro_start, *last, **tptr, *origline;\newline    Line *l;\newline    struct tokenval tokval;\newline    expr *evalresult;\newline    MMacro *tmp_defining;       /* Used when manipulating rep_nest */\newline    int64_t count;\newline    size_t len;\newline    int severity;\newline\newline    origline = tline;\newline\newline    skip_white_(tline);\newline    if (!tline || !tok_type_(tline, TOK_PREPROC_ID) ||\newline        (tline-&gttext[1] == &#039%&#039 || tline-&gttext[1] == &#039$&#039\newline         || tline-&gttext[1] == &#039!&#039))\newline        return NO_DIRECTIVE_FOUND;\newline\newline    i = pp_token_hash(tline-&gttext);\newline\newline    /*\newline     * FIXME: We zap execution of PP_RMACRO, PP_IRMACRO, PP_EXITMACRO\newline     * since they are known to be buggy at moment, we need to fix them\newline     * in future release (2.09-2.10)\newline     */\newline    if (i == PP_RMACRO || i == PP_IRMACRO || i == PP_EXITMACRO) {\newline        nasm_error(ERR_NONFATAL, &quotunknown preprocessor directive `%s&#039&quot,\newline              tline-&gttext);\newline       return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    /*\newline     * If we&#039re in a non-emitting branch of a condition construct,\newline     * or walking to the end of an already terminated %rep block,\newline     * we should ignore all directives except for condition\newline     * directives.\newline     */\newline    if (((istk-&gtconds &amp&amp !emitting(istk-&gtconds-&gtstate)) ||\newline         (istk-&gtmstk &amp&amp !istk-&gtmstk-&gtin_progress)) &amp&amp !is_condition(i)) {\newline        return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    /*\newline     * If we&#039re defining a macro or reading a %rep block, we should\newline     * ignore all directives except for %macro/%imacro (which nest),\newline     * %endm/%endmacro, and (only if we&#039re in a %rep block) %endrep.\newline     * If we&#039re in a %rep block, another %rep nests, so should be let through.\newline     */\newline    if (defining &amp&amp i != PP_MACRO &amp&amp i != PP_IMACRO &amp&amp\newline        i != PP_RMACRO &amp&amp  i != PP_IRMACRO &amp&amp\newline        i != PP_ENDMACRO &amp&amp i != PP_ENDM &amp&amp\newline        (defining-&gtname || (i != PP_ENDREP &amp&amp i != PP_REP))) {\newline        return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    if (defining) {\newline        if (i == PP_MACRO || i == PP_IMACRO ||\newline            i == PP_RMACRO || i == PP_IRMACRO) {\newline            nested_mac_count++;\newline            return NO_DIRECTIVE_FOUND;\newline        } else if (nested_mac_count &gt 0) {\newline            if (i == PP_ENDMACRO) {\newline                nested_mac_count--;\newline                return NO_DIRECTIVE_FOUND;\newline            }\newline        }\newline        if (!defining-&gtname) {\newline            if (i == PP_REP) {\newline                nested_rep_count++;\newline                return NO_DIRECTIVE_FOUND;\newline            } else if (nested_rep_count &gt 0) {\newline                if (i == PP_ENDREP) {\newline                    nested_rep_count--;\newline                    return NO_DIRECTIVE_FOUND;\newline                }\newline            }\newline        }\newline    }\newline\newline    switch (i) {\newline    case PP_INVALID:\newline        nasm_error(ERR_NONFATAL, &quotunknown preprocessor directive `%s&#039&quot,\newline              tline-&gttext);\newline        return NO_DIRECTIVE_FOUND;      /* didn&#039t get it */\newline\newline    case PP_STACKSIZE:\newline        /* Directive to tell NASM what the default stack size is. The\newline         * default is for a 16-bit stack, and this can be overriden with\newline         * %stacksize large.\newline         */\newline        tline = tline-&gtnext;\newline        if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline            tline = tline-&gtnext;\newline        if (!tline || tline-&gttype != TOK_ID) {\newline            nasm_error(ERR_NONFATAL, &quot`%%stacksize&#039 missing size parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        if (nasm_stricmp(tline-&gttext, &quotflat&quot) == 0) {\newline            /* All subsequent ARG directives are for a 32-bit stack */\newline            StackSize = 4;\newline            StackPointer = &quotebp&quot;\newline            ArgOffset = 8;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotflat64&quot) == 0) {\newline            /* All subsequent ARG directives are for a 64-bit stack */\newline            StackSize = 8;\newline            StackPointer = &quotrbp&quot;\newline            ArgOffset = 16;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotlarge&quot) == 0) {\newline            /* All subsequent ARG directives are for a 16-bit stack,\newline             * far function call.\newline             */\newline            StackSize = 2;\newline            StackPointer = &quotbp&quot;\newline            ArgOffset = 4;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotsmall&quot) == 0) {\newline            /* All subsequent ARG directives are for a 16-bit stack,\newline             * far function call. We don&#039t support near functions.\newline             */\newline            StackSize = 2;\newline            StackPointer = &quotbp&quot;\newline            ArgOffset = 6;\newline            LocalOffset = 0;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%stacksize&#039 invalid size type&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ARG:\newline        /* TASM like ARG directive to define arguments to functions, in\newline         * the following form:\newline         *\newline         *      ARG arg1:WORD, arg2:DWORD, arg4:QWORD\newline         */\newline        offset = ArgOffset;\newline        do {\newline            char *arg, directive[256];\newline            int size = StackSize;\newline\newline            /* Find the argument name */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL, &quot`%%arg&#039 missing argument parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            arg = tline-&gttext;\newline\newline            /* Find the argument size type */\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_OTHER\newline                || tline-&gttext[0] != &#039:&#039) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotSyntax error processing `%%arg&#039 directive&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL, &quot`%%arg&#039 missing size type parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline\newline            /* Allow macro expansion of type parameter */\newline            tt = tokenize(tline-&gttext);\newline            tt = expand_smacro(tt);\newline            size = parse_size(tt-&gttext);\newline            if (!size) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotInvalid size type for `%%arg&#039 missing directive&quot);\newline                free_tlist(tt);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            free_tlist(tt);\newline\newline            /* Round up to even stack slots */\newline            size = ALIGN(size, StackSize);\newline\newline            /* Now define the macro for the argument */\newline            snprintf(directive, sizeof(directive), &quot%%define %s (%s+%d)&quot,\newline                     arg, StackPointer, offset);\newline            do_directive(tokenize(directive));\newline            offset += size;\newline\newline            /* Move to the next argument in the list */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline        } while (tline &amp&amp tline-&gttype == TOK_OTHER &amp&amp tline-&gttext[0] == &#039,&#039);\newline        ArgOffset = offset;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_LOCAL:\newline        /* TASM like LOCAL directive to define local variables for a\newline         * function, in the following form:\newline         *\newline         *      LOCAL local1:WORD, local2:DWORD, local4:QWORD = LocalSize\newline         *\newline         * The &#039= LocalSize&#039 at the end is ignored by NASM, but is\newline         * required by TASM to define the local parameter size (and used\newline         * by the TASM macro package).\newline         */\newline        offset = LocalOffset;\newline        do {\newline            char *local, directive[256];\newline            int size = StackSize;\newline\newline            /* Find the argument name */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quot`%%local&#039 missing argument parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            local = tline-&gttext;\newline\newline            /* Find the argument size type */\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_OTHER\newline                || tline-&gttext[0] != &#039:&#039) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotSyntax error processing `%%local&#039 directive&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quot`%%local&#039 missing size type parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline\newline            /* Allow macro expansion of type parameter */\newline            tt = tokenize(tline-&gttext);\newline            tt = expand_smacro(tt);\newline            size = parse_size(tt-&gttext);\newline            if (!size) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotInvalid size type for `%%local&#039 missing directive&quot);\newline                free_tlist(tt);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            free_tlist(tt);\newline\newline            /* Round up to even stack slots */\newline            size = ALIGN(size, StackSize);\newline\newline            offset += size;     /* Negative offset, increment before */\newline\newline            /* Now define the macro for the argument */\newline            snprintf(directive, sizeof(directive), &quot%%define %s (%s-%d)&quot,\newline                     local, StackPointer, offset);\newline            do_directive(tokenize(directive));\newline\newline            /* Now define the assign to setup the enter_c macro correctly */\newline            snprintf(directive, sizeof(directive),\newline                     &quot%%assign %%$localsize %%$localsize+%d&quot, size);\newline            do_directive(tokenize(directive));\newline\newline            /* Move to the next argument in the list */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline        } while (tline &amp&amp tline-&gttype == TOK_OTHER &amp&amp tline-&gttext[0] == &#039,&#039);\newline        LocalOffset = offset;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_CLEAR:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%clear&#039 ignored&quot);\newline        free_macros();\newline        init_macros();\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEPEND:\newline        t = tline-&gtnext = expand_smacro(tline-&gtnext);\newline        skip_white_(t);\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%depend&#039 expects a file name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%depend&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote_cstr(p, i);\newline        if (dephead &amp&amp !in_list(*dephead, p)) {\newline            StrList *sl = nasm_malloc(strlen(p)+1+sizeof sl-&gtnext);\newline            sl-&gtnext = NULL;\newline            strcpy(sl-&gtstr, p);\newline            *deptail = sl;\newline            deptail = &ampsl-&gtnext;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_INCLUDE:\newline        t = tline-&gtnext = expand_smacro(tline-&gtnext);\newline        skip_white_(t);\newline\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%include&#039 expects a file name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%include&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote_cstr(p, i);\newline        inc = nasm_malloc(sizeof(Include));\newline        inc-&gtnext = istk;\newline        inc-&gtconds = NULL;\newline        inc-&gtfp = inc_fopen(p, dephead, &ampdeptail, pass == 0);\newline        if (!inc-&gtfp) {\newline            /* -MG given but file not found */\newline            nasm_free(inc);\newline        } else {\newline            inc-&gtfname = src_set_fname(nasm_strdup(p));\newline            inc-&gtlineno = src_set_linnum(0);\newline            inc-&gtlineinc = 1;\newline            inc-&gtexpansion = NULL;\newline            inc-&gtmstk = NULL;\newline            istk = inc;\newline            lfmt-&gtuplevel(LIST_INCLUDE);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_USE:\newline    {\newline        static macros_t *use_pkg;\newline        const char *pkg_macro = NULL;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline\newline        if (!tline || (tline-&gttype != TOK_STRING &amp&amp\newline                       tline-&gttype != TOK_INTERNAL_STRING &amp&amp\newline                       tline-&gttype != TOK_ID)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%use&#039 expects a package name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%use&#039 ignored&quot);\newline        if (tline-&gttype == TOK_STRING)\newline            nasm_unquote_cstr(tline-&gttext, i);\newline        use_pkg = nasm_stdmac_find_package(tline-&gttext);\newline        if (!use_pkg)\newline            nasm_error(ERR_NONFATAL, &quotunknown `%%use&#039 package: %s&quot, tline-&gttext);\newline        else\newline            pkg_macro = (char *)use_pkg + 1; /* The first string will be &lt%define&gt__USE_*__ */\newline        if (use_pkg &amp&amp ! smacro_defined(NULL, pkg_macro, 0, NULL, true)) {\newline            /* Not already included, go ahead and include it */\newline            stdmacpos = use_pkg;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline    case PP_PUSH:\newline    case PP_REPL:\newline    case PP_POP:\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (tline) {\newline            if (!tok_type_(tline, TOK_ID)) {\newline                nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a context identifier&quot,\newline                      pp_directives[i]);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;     /* but we did _something_ */\newline            }\newline            if (tline-&gtnext)\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quottrailing garbage after `%s&#039 ignored&quot,\newline                      pp_directives[i]);\newline            p = nasm_strdup(tline-&gttext);\newline        } else {\newline            p = NULL; /* Anonymous */\newline        }\newline\newline        if (i == PP_PUSH) {\newline            ctx = nasm_malloc(sizeof(Context));\newline            ctx-&gtnext = cstk;\newline            hash_init(&ampctx-&gtlocalmac, HASH_SMALL);\newline            ctx-&gtname = p;\newline            ctx-&gtnumber = unique++;\newline            cstk = ctx;\newline        } else {\newline            /* %pop or %repl */\newline            if (!cstk) {\newline                nasm_error(ERR_NONFATAL, &quot`%s&#039: context stack is empty&quot,\newline                      pp_directives[i]);\newline            } else if (i == PP_POP) {\newline                if (p &amp&amp (!cstk-&gtname || nasm_stricmp(p, cstk-&gtname)))\newline                    nasm_error(ERR_NONFATAL, &quot`%%pop&#039 in wrong context: %s, &quot\newline                          &quotexpected %s&quot,\newline                          cstk-&gtname ? cstk-&gtname : &quotanonymous&quot, p);\newline                else\newline                    ctx_pop();\newline            } else {\newline                /* i == PP_REPL */\newline                nasm_free(cstk-&gtname);\newline                cstk-&gtname = p;\newline                p = NULL;\newline            }\newline            nasm_free(p);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    case PP_FATAL:\newline        severity = ERR_FATAL;\newline        goto issue_error;\newline    case PP_ERROR:\newline        severity = ERR_NONFATAL;\newline        goto issue_error;\newline    case PP_WARNING:\newline        severity = ERR_WARNING|ERR_WARN_USER;\newline        goto issue_error;\newline\newlineissue_error:\newline    {\newline        /* Only error out if this is the final pass */\newline        if (pass != 2 &amp&amp i != PP_FATAL)\newline            return DIRECTIVE_FOUND;\newline\newline        tline-&gtnext = expand_smacro(tline-&gtnext);\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        t = tline ? tline-&gtnext : NULL;\newline        skip_white_(t);\newline        if (tok_type_(tline, TOK_STRING) &amp&amp !t) {\newline            /* The line contains only a quoted string */\newline            p = tline-&gttext;\newline            nasm_unquote(p, NULL); /* Ignore NUL character truncation */\newline            nasm_error(severity, &quot%s&quot,  p);\newline        } else {\newline            /* Not a quoted string, or more than a quoted string */\newline            p = detoken(tline, false);\newline            nasm_error(severity, &quot%s&quot,  p);\newline            nasm_free(p);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    CASE_PP_IF:\newline        if (istk-&gtconds &amp&amp !emitting(istk-&gtconds-&gtstate))\newline            j = COND_NEVER;\newline        else {\newline            j = if_condition(tline-&gtnext, i);\newline            tline-&gtnext = NULL; /* it got freed */\newline            j = j &lt 0 ? COND_NEVER : j ? COND_IF_TRUE : COND_IF_FALSE;\newline        }\newline        cond = nasm_malloc(sizeof(Cond));\newline        cond-&gtnext = istk-&gtconds;\newline        cond-&gtstate = j;\newline        istk-&gtconds = cond;\newline        if(istk-&gtmstk)\newline            istk-&gtmstk-&gtcondcnt ++;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    CASE_PP_ELIF:\newline        if (!istk-&gtconds)\newline            nasm_error(ERR_FATAL, &quot`%s&#039: no matching `%%if&#039&quot, pp_directives[i]);\newline        switch(istk-&gtconds-&gtstate) {\newline        case COND_IF_TRUE:\newline            istk-&gtconds-&gtstate = COND_DONE;\newline            break;\newline\newline        case COND_DONE:\newline        case COND_NEVER:\newline            break;\newline\newline        case COND_ELSE_TRUE:\newline        case COND_ELSE_FALSE:\newline	    nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quot`%%elif&#039 after `%%else&#039 ignored&quot);\newline            istk-&gtconds-&gtstate = COND_NEVER;\newline            break;\newline\newline        case COND_IF_FALSE:\newline            /*\newline             * IMPORTANT: In the case of %if, we will already have\newline             * called expand_mmac_params(); however, if we&#039re\newline             * processing an %elif we must have been in a\newline             * non-emitting mode, which would have inhibited\newline             * the normal invocation of expand_mmac_params().\newline             * Therefore, we have to do it explicitly here.\newline             */\newline            j = if_condition(expand_mmac_params(tline-&gtnext), i);\newline            tline-&gtnext = NULL; /* it got freed */\newline            istk-&gtconds-&gtstate =\newline                j &lt 0 ? COND_NEVER : j ? COND_IF_TRUE : COND_IF_FALSE;\newline            break;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ELSE:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quottrailing garbage after `%%else&#039 ignored&quot);\newline        if (!istk-&gtconds)\newline	    nasm_fatal(0, &quot`%%else: no matching `%%if&#039&quot);\newline        switch(istk-&gtconds-&gtstate) {\newline        case COND_IF_TRUE:\newline        case COND_DONE:\newline            istk-&gtconds-&gtstate = COND_ELSE_FALSE;\newline            break;\newline\newline        case COND_NEVER:\newline            break;\newline\newline        case COND_IF_FALSE:\newline            istk-&gtconds-&gtstate = COND_ELSE_TRUE;\newline            break;\newline\newline        case COND_ELSE_TRUE:\newline        case COND_ELSE_FALSE:\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline                          &quot`%%else&#039 after `%%else&#039 ignored.&quot);\newline            istk-&gtconds-&gtstate = COND_NEVER;\newline            break;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDIF:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quottrailing garbage after `%%endif&#039 ignored&quot);\newline        if (!istk-&gtconds)\newline            nasm_error(ERR_FATAL, &quot`%%endif&#039: no matching `%%if&#039&quot);\newline        cond = istk-&gtconds;\newline        istk-&gtconds = cond-&gtnext;\newline        nasm_free(cond);\newline        if(istk-&gtmstk)\newline            istk-&gtmstk-&gtcondcnt --;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_RMACRO:\newline    case PP_IRMACRO:\newline    case PP_MACRO:\newline    case PP_IMACRO:\newline        if (defining) {\newline            nasm_error(ERR_FATAL, &quot`%s&#039: already defining a macro&quot,\newline                  pp_directives[i]);\newline            return DIRECTIVE_FOUND;\newline        }\newline        defining = nasm_malloc(sizeof(MMacro));\newline        defining-&gtmax_depth =\newline            (i == PP_RMACRO) || (i == PP_IRMACRO) ? DEADMAN_LIMIT : 0;\newline        defining-&gtcasesense = (i == PP_MACRO) || (i == PP_RMACRO);\newline        if (!parse_mmacro_spec(tline, defining, pp_directives[i])) {\newline            nasm_free(defining);\newline            defining = NULL;\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        mmac = (MMacro *) hash_findix(&ampmmacros, defining-&gtname);\newline        while (mmac) {\newline            if (!strcmp(mmac-&gtname, defining-&gtname) &amp&amp\newline                (mmac-&gtnparam_min &lt= defining-&gtnparam_max\newline                 || defining-&gtplus)\newline                &amp&amp (defining-&gtnparam_min &lt= mmac-&gtnparam_max\newline                    || mmac-&gtplus)) {\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quotredefining multi-line macro `%s&#039&quot, defining-&gtname);\newline                return DIRECTIVE_FOUND;\newline            }\newline            mmac = mmac-&gtnext;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDM:\newline    case PP_ENDMACRO:\newline        if (! (defining &amp&amp defining-&gtname)) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039: not defining a macro&quot, tline-&gttext);\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmhead = (MMacro **) hash_findi_add(&ampmmacros, defining-&gtname);\newline        defining-&gtnext = *mmhead;\newline        *mmhead = defining;\newline        defining = NULL;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_EXITMACRO:\newline        /*\newline         * We must search along istk-&gtexpansion until we hit a\newline         * macro-end marker for a macro with a name. Then we\newline         * bypass all lines between exitmacro and endmacro.\newline         */\newline        list_for_each(l, istk-&gtexpansion)\newline            if (l-&gtfinishes &amp&amp l-&gtfinishes-&gtname)\newline                break;\newline\newline        if (l) {\newline            /*\newline             * Remove all conditional entries relative to this\newline             * macro invocation. (safe to do in this context)\newline             */\newline            for ( ; l-&gtfinishes-&gtcondcnt &gt 0; l-&gtfinishes-&gtcondcnt --) {\newline                cond = istk-&gtconds;\newline                istk-&gtconds = cond-&gtnext;\newline                nasm_free(cond);\newline            }\newline            istk-&gtexpansion = l;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%exitmacro&#039 not within `%%macro&#039 block&quot);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_UNMACRO:\newline    case PP_UNIMACRO:\newline    {\newline        MMacro **mmac_p;\newline        MMacro spec;\newline\newline        spec.casesense = (i == PP_UNMACRO);\newline        if (!parse_mmacro_spec(tline, &ampspec, pp_directives[i])) {\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmac_p = (MMacro **) hash_findi(&ampmmacros, spec.name, NULL);\newline        while (mmac_p &amp&amp *mmac_p) {\newline            mmac = *mmac_p;\newline            if (mmac-&gtcasesense == spec.casesense &amp&amp\newline                !mstrcmp(mmac-&gtname, spec.name, spec.casesense) &amp&amp\newline                mmac-&gtnparam_min == spec.nparam_min &amp&amp\newline                mmac-&gtnparam_max == spec.nparam_max &amp&amp\newline                mmac-&gtplus == spec.plus) {\newline                *mmac_p = mmac-&gtnext;\newline                free_mmacro(mmac);\newline            } else {\newline                mmac_p = &ampmmac-&gtnext;\newline            }\newline        }\newline        free_tlist(origline);\newline        free_tlist(spec.dlist);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_ROTATE:\newline        if (tline-&gtnext &amp&amp tline-&gtnext-&gttype == TOK_WHITESPACE)\newline            tline = tline-&gtnext;\newline        if (!tline-&gtnext) {\newline            free_tlist(origline);\newline            nasm_error(ERR_NONFATAL, &quot`%%rotate&#039 missing rotate count&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline        t = expand_smacro(tline-&gtnext);\newline        tline-&gtnext = NULL;\newline        free_tlist(origline);\newline        tline = t;\newline        tptr = &ampt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult =\newline            evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        free_tlist(tline);\newline        if (!evalresult)\newline            return DIRECTIVE_FOUND;\newline        if (tokval.t_type)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after expression ignored&quot);\newline        if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%rotate&#039&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmac = istk-&gtmstk;\newline        while (mmac &amp&amp !mmac-&gtname)     /* avoid mistaking %reps for macros */\newline            mmac = mmac-&gtnext_active;\newline        if (!mmac) {\newline            nasm_error(ERR_NONFATAL, &quot`%%rotate&#039 invoked outside a macro call&quot);\newline        } else if (mmac-&gtnparam == 0) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%rotate&#039 invoked within macro without parameters&quot);\newline        } else {\newline            int rotate = mmac-&gtrotate + reloc_value(evalresult);\newline\newline            rotate %= (int)mmac-&gtnparam;\newline            if (rotate &lt 0)\newline                rotate += mmac-&gtnparam;\newline\newline            mmac-&gtrotate = rotate;\newline        }\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_REP:\newline        nolist = false;\newline        do {\newline            tline = tline-&gtnext;\newline        } while (tok_type_(tline, TOK_WHITESPACE));\newline\newline        if (tok_type_(tline, TOK_ID) &amp&amp\newline            nasm_stricmp(tline-&gttext, &quot.nolist&quot) == 0) {\newline            nolist = true;\newline            do {\newline                tline = tline-&gtnext;\newline            } while (tok_type_(tline, TOK_WHITESPACE));\newline        }\newline\newline        if (tline) {\newline            t = expand_smacro(tline);\newline            tptr = &ampt;\newline            tokval.t_type = TOKEN_INVALID;\newline            evalresult =\newline                evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline            if (!evalresult) {\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            if (tokval.t_type)\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quottrailing garbage after expression ignored&quot);\newline            if (!is_simple(evalresult)) {\newline                nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%rep&#039&quot);\newline                return DIRECTIVE_FOUND;\newline            }\newline            count = reloc_value(evalresult);\newline            if (count &gt= REP_LIMIT) {\newline                nasm_error(ERR_NONFATAL, &quot`%%rep&#039 value exceeds limit&quot);\newline                count = 0;\newline            } else\newline                count++;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%rep&#039 expects a repeat count&quot);\newline            count = 0;\newline        }\newline        free_tlist(origline);\newline\newline        tmp_defining = defining;\newline        defining = nasm_malloc(sizeof(MMacro));\newline        defining-&gtprev = NULL;\newline        defining-&gtname = NULL;  /* flags this macro as a %rep block */\newline        defining-&gtcasesense = false;\newline        defining-&gtplus = false;\newline        defining-&gtnolist = nolist;\newline        defining-&gtin_progress = count;\newline        defining-&gtmax_depth = 0;\newline        defining-&gtnparam_min = defining-&gtnparam_max = 0;\newline        defining-&gtdefaults = NULL;\newline        defining-&gtdlist = NULL;\newline        defining-&gtexpansion = NULL;\newline        defining-&gtnext_active = istk-&gtmstk;\newline        defining-&gtrep_nest = tmp_defining;\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDREP:\newline        if (!defining || defining-&gtname) {\newline            nasm_error(ERR_NONFATAL, &quot`%%endrep&#039: no matching `%%rep&#039&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        /*\newline         * Now we have a &quotmacro&quot defined - although it has no name\newline         * and we won&#039t be entering it in the hash tables - we must\newline         * push a macro-end marker for it on to istk-&gtexpansion.\newline         * After that, it will take care of propagating itself (a\newline         * macro-end marker line for a macro which is really a %rep\newline         * block will cause the macro to be re-expanded, complete\newline         * with another macro-end marker to ensure the process\newline         * continues) until the whole expansion is forcibly removed\newline         * from istk-&gtexpansion by a %exitrep.\newline         */\newline        l = nasm_malloc(sizeof(Line));\newline        l-&gtnext = istk-&gtexpansion;\newline        l-&gtfinishes = defining;\newline        l-&gtfirst = NULL;\newline        istk-&gtexpansion = l;\newline\newline        istk-&gtmstk = defining;\newline\newline        lfmt-&gtuplevel(defining-&gtnolist ? LIST_MACRO_NOLIST : LIST_MACRO);\newline        tmp_defining = defining;\newline        defining = defining-&gtrep_nest;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_EXITREP:\newline        /*\newline         * We must search along istk-&gtexpansion until we hit a\newline         * macro-end marker for a macro with no name. Then we set\newline         * its `in_progress&#039 flag to 0.\newline         */\newline        list_for_each(l, istk-&gtexpansion)\newline            if (l-&gtfinishes &amp&amp !l-&gtfinishes-&gtname)\newline                break;\newline\newline        if (l)\newline            l-&gtfinishes-&gtin_progress = 1;\newline        else\newline            nasm_error(ERR_NONFATAL, &quot`%%exitrep&#039 not within `%%rep&#039 block&quot);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_XDEFINE:\newline    case PP_IXDEFINE:\newline    case PP_DEFINE:\newline    case PP_IDEFINE:\newline        casesense = (i == PP_DEFINE || i == PP_XDEFINE);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a macro identifier&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        param_start = tline = tline-&gtnext;\newline        nparam = 0;\newline\newline        /* Expand the macro definition now for %xdefine and %ixdefine */\newline        if ((i == PP_XDEFINE) || (i == PP_IXDEFINE))\newline            tline = expand_smacro(tline);\newline\newline        if (tok_is_(tline, &quot(&quot)) {\newline            /*\newline             * This macro has parameters.\newline             */\newline\newline            tline = tline-&gtnext;\newline            while (1) {\newline                skip_white_(tline);\newline                if (!tline) {\newline                    nasm_error(ERR_NONFATAL, &quotparameter identifier expected&quot);\newline                    free_tlist(origline);\newline                    return DIRECTIVE_FOUND;\newline                }\newline                if (tline-&gttype != TOK_ID) {\newline                    nasm_error(ERR_NONFATAL,\newline                          &quot`%s&#039: parameter identifier expected&quot,\newline                          tline-&gttext);\newline                    free_tlist(origline);\newline                    return DIRECTIVE_FOUND;\newline                }\newline                tline-&gttype = TOK_SMAC_PARAM + nparam++;\newline                tline = tline-&gtnext;\newline                skip_white_(tline);\newline                if (tok_is_(tline, &quot,&quot)) {\newline                    tline = tline-&gtnext;\newline                } else {\newline                    if (!tok_is_(tline, &quot)&quot)) {\newline                        nasm_error(ERR_NONFATAL,\newline                              &quot`)&#039 expected to terminate macro template&quot);\newline                        free_tlist(origline);\newline                        return DIRECTIVE_FOUND;\newline                    }\newline                    break;\newline                }\newline            }\newline            last = tline;\newline            tline = tline-&gtnext;\newline        }\newline        if (tok_type_(tline, TOK_WHITESPACE))\newline            last = tline, tline = tline-&gtnext;\newline        macro_start = NULL;\newline        last-&gtnext = NULL;\newline        t = tline;\newline        while (t) {\newline            if (t-&gttype == TOK_ID) {\newline                list_for_each(tt, param_start)\newline                    if (tt-&gttype &gt= TOK_SMAC_PARAM &amp&amp\newline                        !strcmp(tt-&gttext, t-&gttext))\newline                        t-&gttype = tt-&gttype;\newline            }\newline            tt = t-&gtnext;\newline            t-&gtnext = macro_start;\newline            macro_start = t;\newline            t = tt;\newline        }\newline        /*\newline         * Good. We now have a macro name, a parameter count, and a\newline         * token list (in reverse order) for an expansion. We ought\newline         * to be OK just to create an SMacro, store it, and let\newline         * free_tlist have the rest of the line (which we have\newline         * carefully re-terminated after chopping off the expansion\newline         * from the end).\newline         */\newline        define_smacro(ctx, mname, casesense, nparam, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_UNDEF:\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%%undef&#039 expects a macro identifier&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        if (tline-&gtnext) {\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after macro name ignored&quot);\newline        }\newline\newline        /* Find the context that symbol belongs to */\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        undef_smacro(ctx, mname);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEFSTR:\newline    case PP_IDEFSTR:\newline        casesense = (i == PP_DEFSTR);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a macro identifier&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        while (tok_type_(tline, TOK_WHITESPACE))\newline            tline = delete_Token(tline);\newline\newline        p = detoken(tline, false);\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote(p, strlen(p));\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline        nasm_free(p);\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a string token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEFTOK:\newline    case PP_IDEFTOK:\newline        casesense = (i == PP_DEFTOK);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%s&#039 expects a macro identifier as first parameter&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%s` requires string as second parameter&quot,\newline                  pp_directives[i]);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        /*\newline         * Convert the string to a token stream.  Note that smacros\newline         * are stored with the token stream reversed, so we have to\newline         * reverse the output of tokenize().\newline         */\newline        nasm_unquote_cstr(t-&gttext, i);\newline        macro_start = reverse_tokens(tokenize(t-&gttext));\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_PATHSEARCH:\newline    {\newline        FILE *fp;\newline        StrList *xsl = NULL;\newline        StrList **xst = &ampxsl;\newline\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%pathsearch&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%pathsearch&#039 expects a file name&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%pathsearch&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote(p, NULL);\newline\newline        fp = inc_fopen(p, &ampxsl, &ampxst, true);\newline        if (fp) {\newline            p = xsl-&gtstr;\newline            fclose(fp);         /* Don&#039t actually care about the file */\newline        }\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote(p, strlen(p));\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline        if (xsl)\newline            nasm_free(xsl);\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a string token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_STRLEN:\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strlen&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strlen` requires string as second parameter&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        make_tok_num(macro_start, nasm_unquote(t-&gttext, NULL));\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_STRCAT:\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strcat&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        len = 0;\newline        list_for_each(t, tline) {\newline            switch (t-&gttype) {\newline            case TOK_WHITESPACE:\newline                break;\newline            case TOK_STRING:\newline                len += t-&gta.len = nasm_unquote(t-&gttext, NULL);\newline                break;\newline            case TOK_OTHER:\newline                if (!strcmp(t-&gttext, &quot,&quot)) /* permit comma separators */\newline                    break;\newline                /* else fall through */\newline            default:\newline                nasm_error(ERR_NONFATAL,\newline                      &quotnon-string passed to `%%strcat&#039 (%d)&quot, t-&gttype);\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline        }\newline\newline        p = pp = nasm_malloc(len);\newline        list_for_each(t, tline) {\newline            if (t-&gttype == TOK_STRING) {\newline                memcpy(p, t-&gttext, t-&gta.len);\newline                p += t-&gta.len;\newline            }\newline        }\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        macro_start = new_Token(NULL, TOK_STRING, NULL, 0);\newline        macro_start-&gttext = nasm_quote(pp, len);\newline        nasm_free(pp);\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_SUBSTR:\newline    {\newline        int64_t start, count;\newline        size_t len;\newline\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%substr&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        if (tline) /* skip expanded id */\newline            t = tline-&gtnext;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%substr` requires string as second parameter&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        tt = t-&gtnext;\newline        tptr = &amptt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        if (!evalresult) {\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        } else if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%substr`&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        start = evalresult-&gtvalue - 1;\newline\newline        while (tok_type_(tt, TOK_WHITESPACE))\newline            tt = tt-&gtnext;\newline        if (!tt) {\newline            count = 1;  /* Backwards compatibility: one character */\newline        } else {\newline            tokval.t_type = TOKEN_INVALID;\newline            evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline            if (!evalresult) {\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            } else if (!is_simple(evalresult)) {\newline                nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%substr`&quot);\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            count = evalresult-&gtvalue;\newline        }\newline\newline        len = nasm_unquote(t-&gttext, NULL);\newline\newline        /* make start and count being in range */\newline        if (start &lt 0)\newline            start = 0;\newline        if (count &lt 0)\newline            count = len + count + 1 - start;\newline        if (start + count &gt (int64_t)len)\newline            count = len - start;\newline        if (!len || count &lt 0 || start &gt=(int64_t)len)\newline            start = -1, count = 0; /* empty string */\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote((start &lt 0) ? &quot&quot : t-&gttext + start, count);\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_ASSIGN:\newline    case PP_IASSIGN:\newline        casesense = (i == PP_ASSIGN);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%%sassign&#039 expects a macro identifier&quot,\newline                  (i == PP_IASSIGN ? &quoti&quot : &quot&quot));\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        tptr = &ampt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        free_tlist(tline);\newline        if (!evalresult) {\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        if (tokval.t_type)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after expression ignored&quot);\newline\newline        if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quotnon-constant value given to `%%%sassign&#039&quot,\newline                  (i == PP_IASSIGN ? &quoti&quot : &quot&quot));\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        make_tok_num(macro_start, reloc_value(evalresult));\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_LINE:\newline        /*\newline         * Syntax is `%line nnn[+mmm] [filename]&#039\newline         */\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        if (!tok_type_(tline, TOK_NUMBER)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%line&#039 expects line number&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        k = readnum(tline-&gttext, &amperr);\newline        m = 1;\newline        tline = tline-&gtnext;\newline        if (tok_is_(tline, &quot+&quot)) {\newline            tline = tline-&gtnext;\newline            if (!tok_type_(tline, TOK_NUMBER)) {\newline                nasm_error(ERR_NONFATAL, &quot`%%line&#039 expects line increment&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            m = readnum(tline-&gttext, &amperr);\newline            tline = tline-&gtnext;\newline        }\newline        skip_white_(tline);\newline        src_set_linnum(k);\newline        istk-&gtlineinc = m;\newline        if (tline) {\newline            nasm_free(src_set_fname(detoken(tline, false)));\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    default:\newline        nasm_error(ERR_FATAL,\newline              &quotpreprocessor directive `%s&#039 not yet implemented&quot,\newline              pp_directives[i]);\newline        return DIRECTIVE_FOUND;\newline    }\newline}\newline","\newline find and process preprocessor directive in passed line\newline Find out if a line contains a preprocessor directive, and deal\newline with it if so.\newline \newline If a directive _is_ found, it is the responsibility of this routine\newline (and not the caller) to free_tlist() the line.\newline \newline @param tline a pointer to the current tokeninzed line linked list\newline @return DIRECTIVE_FOUND or NO_DIRECTIVE_FOUND\newline \newline \newline","1259456","tidy.c","static ctmbstr ConfigCategoryName( TidyConfigCategory id )\newline{\newline    switch( id )\newline    {\newline        case TidyMarkup:\newline            return tidyLocalizedString( TC_CAT_MARKUP );\newline        case TidyDiagnostics:\newline            return tidyLocalizedString( TC_CAT_DIAGNOSTICS );\newline        case TidyPrettyPrint:\newline            return tidyLocalizedString( TC_CAT_PRETTYPRINT );\newline        case TidyEncoding:\newline            return tidyLocalizedString( TC_CAT_ENCODING );\newline        case TidyMiscellaneous:\newline            return tidyLocalizedString( TC_CAT_MISC );\newline    }\newline    fprintf(stderr, tidyLocalizedString(TC_STRING_FATAL_ERROR), (int)id);\newline    fprintf(stderr, &quot\\n&quot);\newline\newline    assert(0);\newline    abort();\newline    return &quotnever_here&quot; /* only for the compiler warning */\newline}\newline","\newline Returns the configuration category name for the\newline specified configuration category id. This will be\newline used as an XML class attribute value.\newline \newline","5150287","ptunnel.c","challenge_t*	generate_challenge(void) {\newline	struct timeval	tt;\newline	challenge_t		*c;\newline	int				i;\newline	\newline	c	= calloc(1, sizeof(challenge_t));\newline	gettimeofday(&amptt, 0);\newline	c-&gtsec		= tt.tv_sec;\newline	c-&gtusec_rnd	= tt.tv_usec + rand();\newline	for (i=0;i&lt6;i++)\newline		c-&gtrandom[i]	= rand();\newline	\newline	return c;\newline}\newline","generate_challenge: Generates a random challenge, incorporating the current\newline local timestamp to avoid replay attacks.\newline \newline","2285311","rrd_hw.c","void erase_violations(\newline    rrd_t *rrd,\newline    unsigned long cdp_idx,\newline    unsigned long rra_idx)\newline{\newline    unsigned short i;\newline    char     *violations_array;\newline\newline    /* check that rra_idx is a CF_FAILURES array */\newline    if (cf_conv(rrd-&gtrra_def[rra_idx].cf_nam) != CF_FAILURES) {\newline#ifdef DEBUG\newline        fprintf(stderr, &quoterase_violations called for non-FAILURES RRA: %s\\n&quot,\newline                rrd-&gtrra_def[rra_idx].cf_nam);\newline#endif\newline        return;\newline    }\newline#ifdef DEBUG\newline    fprintf(stderr, &quotscratch buffer before erase:\\n&quot);\newline    for (i = 0; i &lt MAX_CDP_PAR_EN; i++) {\newline        fprintf(stderr, &quot%lu &quot, rrd-&gtcdp_prep[cdp_idx].scratch[i].u_cnt);\newline    }\newline    fprintf(stderr, &quot\\n&quot);\newline#endif\newline\newline    /* WARNING: an array of longs on disk is treated as an array of chars\newline     * in memory. */\newline    violations_array = (char *) ((void *) rrd-&gtcdp_prep[cdp_idx].scratch);\newline    /* erase everything in the part of the CDP scratch array that will be\newline     * used to store violations for the current window */\newline    for (i = rrd-&gtrra_def[rra_idx].par[RRA_window_len].u_cnt; i &gt 0; i--) {\newline        violations_array[i - 1] = 0;\newline    }\newline#ifdef DEBUG\newline    fprintf(stderr, &quotscratch buffer after erase:\\n&quot);\newline    for (i = 0; i &lt MAX_CDP_PAR_EN; i++) {\newline        fprintf(stderr, &quot%lu &quot, rrd-&gtcdp_prep[cdp_idx].scratch[i].u_cnt);\newline    }\newline    fprintf(stderr, &quot\\n&quot);\newline#endif\newline}\newline","For the specified CDP prep area and the FAILURES RRA,\newline erase all history of past violations.\newline \newline","3680637","verbs_info.c","static int fi_ibv_have_device(void)\newline{\newline	struct ibv_device **devs;\newline	struct ibv_context *verbs;\newline	int i, ret = 0;\newline\newline	devs = ibv_get_device_list(NULL);\newline	if (!devs)\newline		return 0;\newline\newline	for (i = 0; devs[i]; i++) {\newline		verbs = ibv_open_device(devs[i]);\newline		if (verbs) {\newline			ibv_close_device(verbs);\newline			ret = 1;\newline			break;\newline		}\newline	}\newline\newline	ibv_free_device_list(devs);\newline	return ret;\newline}\newline","\newline USNIC plugs into the verbs framework, but is not a usable device.\newline Manually check for devices and fail gracefully if none are present.\newline This avoids the lower libraries (libibverbs and librdmacm) from\newline reporting error messages to stderr.\newline \newline","1345582","tls_generic.c","int TLSVerifyPeer(ConnectionInfo *conn_info, const char *remoteip, const char *username)\newline{\newline    int ret, retval;\newline\newline    X509 *received_cert = SSL_get_peer_certificate(conn_info-&gtssl);\newline    if (received_cert == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR,\newline            &quotNo certificate presented by remote peer (openssl: %s)&quot,\newline            TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret1;\newline    }\newline\newline    EVP_PKEY *received_pubkey = X509_get_pubkey(received_cert);\newline    if (received_pubkey == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotX509_get_pubkey: %s&quot,\newline            TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret2;\newline    }\newline    if (EVP_PKEY_type(received_pubkey-&gttype) != EVP_PKEY_RSA)\newline    {\newline        Log(LOG_LEVEL_ERR,\newline            &quotReceived key of unknown type, only RSA currently supported!&quot);\newline        retval = -1;\newline        goto ret3;\newline    }\newline\newline    RSA *remote_key = EVP_PKEY_get1_RSA(received_pubkey);\newline    if (remote_key == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_get1_RSA failed!&quot);\newline        retval = -1;\newline        goto ret3;\newline    }\newline\newline    Key *key = KeyNew(remote_key, CF_DEFAULT_DIGEST);\newline    conn_info-&gtremote_key = key;\newline\newline    /*\newline     * Compare the key received with the one stored.\newline     */\newline    const char *key_hash = KeyPrintableHash(key);\newline    RSA *expected_rsa_key = HavePublicKey(username, remoteip, key_hash);\newline\newline    if (expected_rsa_key == NULL)\newline    {\newline        /* TODO LOG_LEVEL_NOTICE once cf-serverd logs to a different file. */\newline        Log(LOG_LEVEL_VERBOSE,\newline            &quotReceived key &#039%s&#039 not found in ppkeys&quot, key_hash);\newline        retval = 0;\newline        goto ret4;\newline    }\newline\newline    EVP_PKEY *expected_pubkey = EVP_PKEY_new();\newline    if (expected_pubkey == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_new allocation failed!&quot);\newline        retval = -1;\newline        goto ret5;\newline    }\newline\newline    ret = EVP_PKEY_set1_RSA(expected_pubkey, expected_rsa_key);\newline    if (ret == 0)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_set1_RSA failed!&quot);\newline        retval = -1;\newline        goto ret6;\newline    }\newline\newline    ret = EVP_PKEY_cmp(received_pubkey, expected_pubkey);\newline    if (ret == 1)\newline    {\newline        Log(LOG_LEVEL_VERBOSE,\newline            &quotReceived public key compares equal to the one we have stored&quot);\newline        retval = 1;               /* TRUSTED KEY, equal to the expected one */\newline        goto ret6;\newline    }\newline    else if (ret == 0 || ret == -1)\newline    {\newline        Log(LOG_LEVEL_NOTICE,\newline            &quotReceived key &#039%s&#039 compares different to the one in ppkeys&quot,\newline            key_hash);\newline        retval = 0;\newline        goto ret6;\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_ERR, &quotOpenSSL EVP_PKEY_cmp: %d %s&quot,\newline            ret, TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret6;\newline    }\newline\newline    UnexpectedError(&quotUnreachable!&quot);\newline    return 0;\newline\newline  ret6:\newline    EVP_PKEY_free(expected_pubkey);\newline  ret5:\newline    RSA_free(expected_rsa_key);\newline  ret4:\newline    if (retval == -1)\newline    {\newline        /* We won&#039t be needing conn_info-&gtremote_key */\newline        KeyDestroy(&ampkey);\newline        conn_info-&gtremote_key = NULL;\newline    }\newline  ret3:\newline    EVP_PKEY_free(received_pubkey);\newline  ret2:\newline    X509_free(received_cert);\newline  ret1:\newline    return retval;\newline}\newline","\newline @retval 1 if the public key used by the peer in the TLS handshake is the\newline same with the one stored for that host.\newline @retval 0 if stored key for the host is missing or differs from the one\newline received.\newline @retval -1 in case of other error (error will be Log()ed).\newline @note When return value is != -1 (so no error occurred) the #conn_info struct\newline should have been populated, with key received and its hash.\newline \newline","6424471","sequence.c","void dsa_push(dsa_t *A, seq_t S) {\newline	if (A-&gtsize &lt A-&gtcapacity) {\newline		A-&gtdata[A-&gtsize++] = S;\newline	} else {\newline		// use the near-optimal growth factor of 1.5\newline		seq_t *ptr = reallocarray(A-&gtdata, A-&gtcapacity / 2, sizeof(seq_t) * 3);\newline		CHECK_MALLOC(ptr);\newline\newline		A-&gtcapacity = (A-&gtcapacity / 2) * 3;\newline		A-&gtdata = ptr;\newline		A-&gtdata[A-&gtsize++] = S;\newline	}\newline}\newline","Add a sequence to an array. \newline","776877","metadata.c","static int _vg_update_old_pv_ext_if_needed(struct volume_group *vg)\newline{\newline	struct pv_list *pvl, *new_pvl;\newline	int pv_needs_rewrite;\newline\newline	if (!(vg-&gtfid-&gtfmt-&gtfeatures &amp FMT_PV_FLAGS))\newline		return 1;\newline\newline	dm_list_iterate_items(pvl, &ampvg-&gtpvs) {\newline		if (is_missing_pv(pvl-&gtpv) ||\newline		    !pvl-&gtpv-&gtfmt-&gtops-&gtpv_needs_rewrite)\newline			continue;\newline\newline		if (_pv_in_pv_list(pvl-&gtpv, &ampvg-&gtpv_write_list))\newline			continue;\newline\newline		if (!pvl-&gtpv-&gtfmt-&gtops-&gtpv_needs_rewrite(pvl-&gtpv-&gtfmt, pvl-&gtpv,\newline							 &amppv_needs_rewrite))\newline			return_0;\newline\newline		if (pv_needs_rewrite) {\newline			/*\newline			 * Schedule PV for writing only once!\newline			 */\newline			if (_pv_in_pv_list(pvl-&gtpv, &ampvg-&gtpv_write_list))\newline				continue;\newline\newline			if (!(new_pvl = dm_pool_zalloc(vg-&gtvgmem, sizeof(*new_pvl)))) {\newline				log_error(&quotpv_to_write allocation for &#039%s&#039 failed&quot, pv_dev_name(pvl-&gtpv));\newline				return 0;\newline			}\newline			new_pvl-&gtpv = pvl-&gtpv;\newline			dm_list_add(&ampvg-&gtpv_write_list, &ampnew_pvl-&gtlist);\newline			log_debug(&quotPV %s has old extension header, updating to newest version.&quot,\newline				  pv_dev_name(pvl-&gtpv));\newline		}\newline	}\newline\newline	if (!dm_list_empty(&ampvg-&gtpv_write_list) &amp&amp\newline	    (!vg_write(vg) || !vg_commit(vg))) {\newline		log_error(&quotFailed to update old PV extension headers in VG %s.&quot, vg-&gtname);\newline		return 0;\newline	}\newline\newline	return 1;\newline}\newline","\newline Check if any of the PVs in VG still contain old PV headers\newline and if yes, schedule them for PV header update.\newline \newline","336311","diff_match_patch.cpp","QString Patch::toString() {\newline  QString coords1, coords2;\newline  if (length1 == 0) {\newline    coords1 = QString::number(start1) + QString(&quot,0&quot);\newline  } else if (length1 == 1) {\newline    coords1 = QString::number(start1 + 1);\newline  } else {\newline    coords1 = QString::number(start1 + 1) + QString(&quot,&quot)\newline        + QString::number(length1);\newline  }\newline  if (length2 == 0) {\newline    coords2 = QString::number(start2) + QString(&quot,0&quot);\newline  } else if (length2 == 1) {\newline    coords2 = QString::number(start2 + 1);\newline  } else {\newline    coords2 = QString::number(start2 + 1) + QString(&quot,&quot)\newline        + QString::number(length2);\newline  }\newline  QString text;\newline  text = QString(&quot@@ -&quot) + coords1 + QString(&quot +&quot) + coords2\newline      + QString(&quot @@\\n&quot);\newline  // Escape the body of the patch with %xx notation.\newline  foreach (Diff aDiff, diffs) {\newline    switch (aDiff.operation) {\newline      case INSERT:\newline        text += QString(&#039+&#039);\newline        break;\newline      case DELETE:\newline        text += QString(&#039-&#039);\newline        break;\newline      case EQUAL:\newline        text += QString(&#039 &#039);\newline        break;\newline    }\newline    text += QString(QUrl::toPercentEncoding(aDiff.text, &quot !~*&#039();/?:@&amp=+$,#&quot))\newline        + QString(&quot\\n&quot);\newline  }\newline\newline  return text;\newline}\newline","\newline Emmulate GNU diff&#039s format.\newline Header: @@ -382,8 +481,9 @@\newline Indicies are printed as 1-based, not 0-based.\newline @return The GNU diff string\newline \newline","3466649","grid.c","static void rectEdge(double xmin, double ymin, double xmax, double ymax,\newline		     double theta,\newline		     double *edgex, double *edgey) \newline{\newline    double xm = (xmin + xmax)/2;\newline    double ym = (ymin + ymax)/2;\newline    double dx = (xmax - xmin)/2;\newline    double dy = (ymax - ymin)/2;\newline    /*\newline     * FIXME: Special case 0 width or 0 height\newline     */\newline    /*\newline     * Special case angles \newline     */\newline    if (theta == 0) {\newline	*edgex = xmax;\newline	*edgey = ym;\newline    } else if (theta == 270) {\newline	*edgex = xm;\newline	*edgey = ymin;\newline    } else if (theta == 180) {\newline	*edgex = xmin;\newline	*edgey = ym;\newline    } else if (theta == 90) {\newline	*edgex = xm;\newline	*edgey = ymax;\newline    } else {\newline	double cutoff = dy/dx;\newline	double angle = theta/180*M_PI;\newline	double tanTheta = tan(angle);\newline	double cosTheta = cos(angle);\newline	double sinTheta = sin(angle);\newline	if (fabs(tanTheta) &lt cutoff) { /* Intersect with side */\newline	    if (cosTheta &gt 0) { /* Right side */\newline		*edgex = xmax;\newline		*edgey = ym + tanTheta*dx;\newline	    } else { /* Left side */\newline		*edgex = xmin;\newline		*edgey = ym - tanTheta*dx;\newline	    }\newline	} else { /* Intersect with top/bottom */\newline	    if (sinTheta &gt 0) { /* Top */\newline		*edgey = ymax;\newline		*edgex = xm + dy/tanTheta;\newline	    } else { /* Bottom */\newline		*edgey = ymin;\newline		*edgex = xm - dy/tanTheta;\newline	    }\newline	}\newline    }\newline}\newline","\newline Calculate the point on the edge of a rectangle at angle theta\newline 0 = East, 180 = West, etc ...\newline Assumes that x- and y-values are in INCHES\newline Assumes that theta is within [0, 360)\newline \newline","12731","gci_execute.c","static GCI_result readTree( reader *rdr,\newline                            const GCI_nodeinfo *n )\newline{\newline   GCI_result rc;\newline   const GCI_parseinfo *info;\newline   unsigned i;\newline   unsigned shift = 0;\newline   int origlen = GCI_strlen( rdr-&gtbase );\newline\newline   info = &ampn-&gttype;\newline\newline   GCI_strcats( rdr-&gtbase, &quot.&quot );\newline   GCI_strcats( rdr-&gtbase, rdr-&gtprefix );\newline   if ( ( rc = GCI_strcats( rdr-&gtbase, &quotVALUE&quot ) ) != GCI_OK )\newline      return rc;\newline   if ( info-&gtindirect )\newline   {\newline      /*\newline       * This allows missing values. We have to try loading a value for arrays\newline       * and containers but should read strings directly to the target place to\newline       * prevent a slow double buffering. We assume to have values in most\newline       * cases.\newline       */\newline      switch ( info-&gttype )\newline      {\newline         case GCI_integer:\newline         case GCI_unsigned:\newline         case GCI_float:\newline         case GCI_char:\newline            if ( ( rc = readValue( rdr,\newline                                   info,\newline                                   n-&gtindirect_pos + rdr-&gtishift,\newline                                   1 ) ) != GCI_OK )\newline               return rc;\newline            if ( rdr-&gtnovalue )\newline            {\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            break;\newline\newline         case GCI_string:\newline         case GCI_raw:\newline            if ( ( rc = readString( rdr,\newline                                    info,\newline                                    n-&gtindirect_pos + rdr-&gtishift,\newline                                    1,\newline                                    ( info-&gttype == GCI_raw ) ) ) != GCI_OK )\newline               return rc;\newline            if ( rdr-&gtnovalue )\newline            {\newline               memset( rdr-&gtbasebuf + n-&gtindirect_pos + rdr-&gtishift,\newline                       0,\newline                       info-&gtsize + 1 );\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            break;\newline\newline         case GCI_container:\newline            rdr-&gtnovalue = 0;\newline            rc = GCI_readRexx( rdr-&gthidden,\newline                               rdr-&gtbase,\newline                               rdr-&gttmp,\newline                               0,\newline                               0,\newline                               &amprdr-&gtnovalue );\newline            if ( rdr-&gtnovalue )\newline            {\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            if ( rc != GCI_OK )\newline               return rc;\newline            if ( ( rc = GCI_string2bin( rdr-&gthidden,\newline                                        GCI_ccontent( rdr-&gttmp ),\newline                                        GCI_strlen( rdr-&gttmp ),\newline                                        &amprdr-&gtcount,\newline                                        sizeof( unsigned ),\newline                                        GCI_unsigned ) ) != GCI_OK )\newline               return rc;\newline            if ( info-&gtgenerated )\newline            {\newline               if ( rdr-&gtcount != rdr-&gtnodes[n-&gtchild].type.size )\newline                  return GCI_NumberRange;\newline            }\newline            else\newline            {\newline               if ( rdr-&gtcount != info-&gtsize )\newline                  return GCI_NumberRange;\newline            }\newline            break;\newline\newline         case GCI_array:\newline         default:\newline            return GCI_InternalError;\newline      }\newline\newline      assert( n-&gtdirect_pos + rdr-&gtdshift + sizeof( void* ) &lt= rdr-&gtmax );\newline      *((void **) (rdr-&gtbasebuf + n-&gtdirect_pos + rdr-&gtdshift)) =\newline                                  rdr-&gtbasebuf + n-&gtindirect_pos + rdr-&gtishift;\newline   }\newline   else\newline   {\newline      /*\newline       * The direct case, this is somewhat simpler, but we have do make special\newline       * considerations for GCI_string, too.\newline       */\newline      switch ( info-&gttype )\newline      {\newline         case GCI_integer:\newline         case GCI_unsigned:\newline         case GCI_float:\newline         case GCI_char:\newline            if ( ( rc = readValue( rdr,\newline                                   info,\newline                                   n-&gtdirect_pos + rdr-&gtdshift,\newline                                   0 ) ) != GCI_OK )\newline               return rc;\newline            break;\newline\newline         case GCI_string:\newline         case GCI_raw:\newline            if ( ( rc = readString( rdr,\newline                                    info,\newline                                    n-&gtdirect_pos + rdr-&gtdshift,\newline                                    0,\newline                                    ( info-&gttype == GCI_raw ) ) ) != GCI_OK )\newline               return rc;\newline            break;\newline\newline         case GCI_container:\newline         case GCI_array:\newline            break;\newline\newline         default:\newline            return GCI_InternalError;\newline      }\newline   }\newline\newline   GCI_strsetlen( rdr-&gtbase, origlen );\newline\newline   switch ( info-&gttype )\newline   {\newline      case GCI_integer:\newline      case GCI_unsigned:\newline      case GCI_float:\newline      case GCI_char:\newline      case GCI_string:\newline      case GCI_raw:\newline         return GCI_OK;\newline\newline      case GCI_container:\newline         if ( info-&gtindirect )\newline         {\newline            shift = rdr-&gtdshift;\newline            rdr-&gtdshift = rdr-&gtishift;\newline            rdr-&gtishift = 0;\newline         }\newline         n = rdr-&gtnodes + n-&gtchild;\newline         for ( i = 0; i &lt info-&gtsize; i++ )\newline         {\newline            assert( n &gt= rdr-&gtnodes );\newline            if ( info-&gtgenerated )\newline            {\newline               assert( info-&gtsize == 1 );\newline               assert( n-&gttype.type == GCI_array );\newline            }\newline            else\newline            {\newline               sprintf( rdr-&gthelper, &quot.%u&quot, i + 1 );\newline               if ( ( rc = GCI_strcats( rdr-&gtbase, rdr-&gthelper ) ) != GCI_OK )\newline                  return rc;\newline            }\newline\newline            if ( ( rc = readTree( rdr, n ) ) != GCI_OK )\newline               return rc;\newline\newline            GCI_strsetlen( rdr-&gtbase, origlen );\newline            n = rdr-&gtnodes + n-&gtsibling;\newline         }\newline         if ( info-&gtindirect )\newline         {\newline            rdr-&gtishift = rdr-&gtdshift;\newline            rdr-&gtdshift = shift;\newline         }\newline         return GCI_OK;\newline\newline      case GCI_array:\newline         assert( info-&gtindirect == 0 );\newline         assert( n-&gtchild &gt= 0 );\newline         assert( ( n-&gtdirect_size % info-&gtsize ) == 0 );\newline         assert( ( n-&gtindirect_size % info-&gtsize ) == 0);\newline         for ( i = 0; i &lt info-&gtsize; i++ )\newline         {\newline            sprintf( rdr-&gthelper, &quot.%u&quot, i + 1 );\newline            if ( ( rc = GCI_strcats( rdr-&gtbase, rdr-&gthelper ) ) != GCI_OK )\newline               return rc;\newline\newline            if ( ( rc = readTree( rdr, rdr-&gtnodes + n-&gtchild ) ) != GCI_OK )\newline               return rc;\newline\newline            GCI_strsetlen( rdr-&gtbase, origlen );\newline            rdr-&gtdshift += n-&gtdirect_size / info-&gtsize;\newline            rdr-&gtishift += n-&gtindirect_size / info-&gtsize;\newline         }\newline         rdr-&gtdshift -= n-&gtdirect_size;\newline         rdr-&gtishift -= n-&gtindirect_size;\newline         return GCI_OK;\newline\newline      default:\newline         break;\newline   }\newline   return GCI_InternalError;\newline}\newline","\newline readTree assigns all node values of a given tree recursively to the buffer\newline which shall hold the binary values.\newline \newline reader contains all variables useful for all or several leafs.\newline \newline n is the starting node within reader-&gtnodes.\newline \newline Return values:\newline GCI_OK: Everything is fine.\newline \newline In case of an error base will contain the\newline stem&#039s name where the problem raises first.\newline \newline GCI_UnsupportedType: Wrong type of input, e.g. FLOAT31 or the empty string\newline in a type description string. Another reason is an\newline internal error since the default sizes for &quotunsigned&quot\newline and &quotinteger&quot are not supported.\newline GCI_WrongInput: Strange characters occur in the input string as a\newline number.\newline GCI_NumberRange: Number to small or big to fit into the desired type\newline with the desired destbyte-size. This applies to the\newline different number type.\newline Another reason is a wrong value for indirected arrays\newline or containers.\newline GCI_StringRange: String too big for the defined buffer.\newline GCI_InternalError: Unexpected type for the base type.\newline GCI_RexxError: Strange return value by the interpreter.\newline \newline","1525170","gdw.cpp","void Gdw::buildCovList(bool pregStat)\newline{ \newline  if (interceptID.size())\newline    interceptID.clear();\newline\newline  VB_Vector tmpVec;\newline  int upRatio = TR / tmpResolve;\newline  for (uint32 i = 0; i &lt gMatrix.n; i++) {\newline    // If preG is valid, use it instead\newline    if (pregStat) {\newline      tmpVec = pregMatrix.GetColumn(i);\newline      VB_Vector *newVector = new VB_Vector(tmpVec);\newline      // record intercept index\newline      if (newVector-&gtgetVariance() &lt= 1e-15)\newline        interceptID.push_back(i);\newline      covList.push_back(newVector);\newline    }\newline    // Otherwise use G file\newline    else {\newline      tmpVec = gMatrix.GetColumn(i);\newline      VB_Vector *downVector = new VB_Vector(tmpVec);\newline      VB_Vector *newVector = upSampling(downVector, upRatio);\newline      if (newVector-&gtgetVariance() &lt= 1e-15)\newline        interceptID.push_back(i);\newline      covList.push_back(newVector);\newline      delete downVector;\newline    }\newline  }\newline}\newline","buildCovList() reads each column of gMatrix or pregMatrix (if available) into covList \newline","1271691","safe.c","int safe_unlink (const char *pathname)\newline{\newline  int dirfd;\newline\newline  dirfd = traverse_path (&amppathname);\newline  if (dirfd &lt 0 &amp&amp dirfd != AT_FDCWD)\newline    return dirfd;\newline  return unlinkat (dirfd, pathname, 0);\newline}\newline","Replacement for unlink() \newline","4476740","cpl_loader.c","int write_to_file(char *filename, str *buf)\newline{\newline	int fd;\newline	int ret;\newline\newline	fd = open(filename,O_WRONLY|O_CREAT|O_TRUNC,0644);\newline	if (!fd) {\newline		LM_ERR(&quotcannot open file : %s\\n&quot,\newline			strerror(errno));\newline		goto error;\newline	}\newline\newline	while ( (ret=write( fd, buf-&gts, buf-&gtlen))!=buf-&gtlen) {\newline		if ((ret==-1 &amp&amp errno!=EINTR)|| ret!=-1) {\newline			LM_ERR(&quotcannot write to file:&quot\newline				&quot%s write_ret=%d\\n&quot,strerror(errno), ret );\newline			goto error;\newline		}\newline	}\newline	close(fd);\newline\newline	return 0;\newlineerror:\newline	return -1;\newline}\newline","debug function -&gt write into a file the content of a str struct. \newline","2748849","pth_high.c","int pth_select(int nfds, fd_set *rfds, fd_set *wfds,\newline               fd_set *efds, struct timeval *timeout)\newline{\newline    return pth_select_ev(nfds, rfds, wfds, efds, timeout, NULL);\newline}\newline","Pth variant of select(2) \newline","2966524","tevent.c","void tevent_fd_set_close_fn(struct tevent_fd *fde,\newline			    tevent_fd_close_fn_t close_fn)\newline{\newline	if (!fde) return;\newline	if (!fde-&gtevent_ctx) return;\newline	fde-&gtevent_ctx-&gtops-&gtset_fd_close_fn(fde, close_fn);\newline}\newline","\newlineset a close function on the fd event\newline \newline","4405260","sqlite3.c","static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){\newline  assert( sqlite3_mutex_held(pPage-&gtpBt-&gtmutex) );\newline  assert( sqlite3PagerIswriteable(pPage-&gtpDbPage) );\newline  if( eType==PTRMAP_OVERFLOW2 ){\newline    /* The pointer is always the first 4 bytes of the page in this case.  */\newline    if( get4byte(pPage-&gtaData)!=iFrom ){\newline      return SQLITE_CORRUPT_BKPT;\newline    }\newline    put4byte(pPage-&gtaData, iTo);\newline  }else{\newline    u8 isInitOrig = pPage-&gtisInit;\newline    int i;\newline    int nCell;\newline    int rc;\newline\newline    rc = btreeInitPage(pPage);\newline    if( rc ) return rc;\newline    nCell = pPage-&gtnCell;\newline\newline    for(i=0; i&ltnCell; i++){\newline      u8 *pCell = findCell(pPage, i);\newline      if( eType==PTRMAP_OVERFLOW1 ){\newline        CellInfo info;\newline        pPage-&gtxParseCell(pPage, pCell, &ampinfo);\newline        if( info.nLocal&ltinfo.nPayload\newline         &amp&amp pCell+info.nSize-1&lt=pPage-&gtaData+pPage-&gtmaskPage\newline         &amp&amp iFrom==get4byte(pCell+info.nSize-4)\newline        ){\newline          put4byte(pCell+info.nSize-4, iTo);\newline          break;\newline        }\newline      }else{\newline        if( get4byte(pCell)==iFrom ){\newline          put4byte(pCell, iTo);\newline          break;\newline        }\newline      }\newline    }\newline  \newline    if( i==nCell ){\newline      if( eType!=PTRMAP_BTREE || \newline          get4byte(&amppPage-&gtaData[pPage-&gthdrOffset+8])!=iFrom ){\newline        return SQLITE_CORRUPT_BKPT;\newline      }\newline      put4byte(&amppPage-&gtaData[pPage-&gthdrOffset+8], iTo);\newline    }\newline\newline    pPage-&gtisInit = isInitOrig;\newline  }\newline  return SQLITE_OK;\newline}\newline","\newline Somewhere on pPage is a pointer to page iFrom. Modify this pointer so\newline that it points to iTo. Parameter eType describes the type of pointer to\newline be modified, as follows:\newline \newline PTRMAP_BTREE: pPage is a btree-page. The pointer points at a child \newline page of pPage.\newline \newline PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow\newline page pointed to by one of the cells on pPage.\newline \newline PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next\newline overflow page in the list.\newline \newline","5792503","simple_fold.c","wchar_t unicode_simple_fold(wchar_t wc)\newline{\newline	if ((wc &gt= 0) &amp&amp (wc &lt 0x10000))\newline	{\newline		const uint16_t *p = pages[wc &gt&gt 8];\newline		if (p) wc = (wchar_t) p[wc &amp 0xFF];\newline	}\newline	else if ((wc &gt= 0x10400) &amp&amp (wc &lt= 0x10427)) wc += 0x28;\newline	return wc;\newline}\newline","\newline \\brief Simple case folding of a wide character.\newline \\param wc the wide character to fold.\newline \\return If a simple folding is defined, the folded version of \\c wc\newline is returned, otherwise \\c wc is returned unchanged.\newline \\remarks This function performs simple case folding using two\newline accesses in large lookup tables.\newline \newline Case folding provides a mapping between characters that only differ\newline in case. This is useful for case insensitive comparison. Simple case\newline folding maps a single wide character to another single wide character\newline (usually lower case). Full case folding, instead, may map a single\newline wide character to more wide characters.\newline \newline","4765200","xhfc.c","static unsigned char hfc_readcounter8(struct b400m *b4, const unsigned int reg)\newline{\newline	unsigned char r1, r2;\newline	unsigned long maxwait = 1048576;\newline\newline	do {\newline		r1 = b400m_getreg(b4, reg);\newline		r2 = b400m_getreg(b4, reg);\newline	} while ((r1 != r2) &amp&amp maxwait--);\newline\newline	if (!maxwait) {\newline		if (printk_ratelimit()) {\newline			dev_warn(&ampb4-&gtwc-&gtvb.pdev-&gtdev,\newline				 &quothfc_readcounter8(reg 0x%02x) timed out &quot \\\newline				 &quotwaiting for data to settle!\\n&quot, reg);\newline		}\newline	}\newline\newline	return r1;\newline}\newline","\newline reads an 8-bit register over over and over until the same value is read\newline twice, then returns that value.\newline \newline","","","","","","","on","","on","","","on","","","","","","","","on","","","on","","","","","","","","","","","","","","","","","","","","Constructs a CrossTabEditor as a child of 'parent',","Check if any of the PVs in VG still contain old PV","Emmulate GNU diff's format.","Calculate the point on the edge of a rectangle","assigns all node values of a given tree recursively to the buffer","reads each column of gMatrix or pregMatrix","{}","write into a file","{}","set a close function on the fd event","pointer tobe modified,","{}","Simple case folding of a wide character.","reads an 8-bit register","find and process preprocessor directive in passed line","Returns the configuration category name for thespecified configuration category id.","Generates a random challenge,","erase all history of past violations.","check for devices and fail gracefully if none are present.","{}","Add a sequence to an array."
"32ZCLEW0BZKHFD9SRRFNN57PG53JPP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3WYGZ5XF3WFBQ9SVRVOU8882Y2CKSB","AVC62JNYAXA45","Approved","Wed Apr 17 14:16:11 PDT 2019","Wed Apr 17 14:47:48 PDT 2019","Fri Apr 19 14:47:48 PDT 2019","2019-04-19 21:48:21 UTC","","","1897","100% (24/24)","100% (24/24)","100% (24/24)","1577449","crosstabeditor.cpp","CrossTabEditor::CrossTabEditor(QWidget* parent)\newline    : QDialog(parent)\newline{\newline    setupUi(this);\newline\newline\newline    // signals and slots connections\newline    connect(buttonOk, SIGNAL(clicked()), this, SLOT(accept()));\newline    connect(buttonCancel, SIGNAL(clicked()), this, SLOT(reject()));\newline    connect(btnFont, SIGNAL(clicked()), this, SLOT(btnFont_clicked()));\newline}\newline","\newline Constructs a CrossTabEditor as a child of &#039parent&#039, with the\newline name &#039name&#039 and widget flags set to &#039f&#039.\newline \newline The dialog will by default be modeless, unless you set &#039modal&#039 to\newline true to construct a modal dialog.\newline \newline","6581777","clirpc.c","int dcc_read_link(const char* fname, char *points_to)\newline{\newline    int len;\newline    if ((len = readlink(fname, points_to, MAXPATHLEN)) == -1) {\newline        rs_log_error(&quotreadlink &#039%s&#039 failed: %s&quot, fname, strerror(errno));\newline        return EXIT_IO_ERROR;\newline    }\newline    points_to[len] = &#039\\0&#039;\newline    return 0;\newline}\newline","points_to must be at least MAXPATHLEN + 1 long \newline","4318047","preproc.c","static int do_directive(Token * tline)\newline{\newline    enum preproc_token i;\newline    int j;\newline    bool err;\newline    int nparam;\newline    bool nolist;\newline    bool casesense;\newline    int k, m;\newline    int offset;\newline    char *p, *pp;\newline    const char *mname;\newline    Include *inc;\newline    Context *ctx;\newline    Cond *cond;\newline    MMacro *mmac, **mmhead;\newline    Token *t = NULL, *tt, *param_start, *macro_start, *last, **tptr, *origline;\newline    Line *l;\newline    struct tokenval tokval;\newline    expr *evalresult;\newline    MMacro *tmp_defining;       /* Used when manipulating rep_nest */\newline    int64_t count;\newline    size_t len;\newline    int severity;\newline\newline    origline = tline;\newline\newline    skip_white_(tline);\newline    if (!tline || !tok_type_(tline, TOK_PREPROC_ID) ||\newline        (tline-&gttext[1] == &#039%&#039 || tline-&gttext[1] == &#039$&#039\newline         || tline-&gttext[1] == &#039!&#039))\newline        return NO_DIRECTIVE_FOUND;\newline\newline    i = pp_token_hash(tline-&gttext);\newline\newline    /*\newline     * FIXME: We zap execution of PP_RMACRO, PP_IRMACRO, PP_EXITMACRO\newline     * since they are known to be buggy at moment, we need to fix them\newline     * in future release (2.09-2.10)\newline     */\newline    if (i == PP_RMACRO || i == PP_IRMACRO || i == PP_EXITMACRO) {\newline        nasm_error(ERR_NONFATAL, &quotunknown preprocessor directive `%s&#039&quot,\newline              tline-&gttext);\newline       return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    /*\newline     * If we&#039re in a non-emitting branch of a condition construct,\newline     * or walking to the end of an already terminated %rep block,\newline     * we should ignore all directives except for condition\newline     * directives.\newline     */\newline    if (((istk-&gtconds &amp&amp !emitting(istk-&gtconds-&gtstate)) ||\newline         (istk-&gtmstk &amp&amp !istk-&gtmstk-&gtin_progress)) &amp&amp !is_condition(i)) {\newline        return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    /*\newline     * If we&#039re defining a macro or reading a %rep block, we should\newline     * ignore all directives except for %macro/%imacro (which nest),\newline     * %endm/%endmacro, and (only if we&#039re in a %rep block) %endrep.\newline     * If we&#039re in a %rep block, another %rep nests, so should be let through.\newline     */\newline    if (defining &amp&amp i != PP_MACRO &amp&amp i != PP_IMACRO &amp&amp\newline        i != PP_RMACRO &amp&amp  i != PP_IRMACRO &amp&amp\newline        i != PP_ENDMACRO &amp&amp i != PP_ENDM &amp&amp\newline        (defining-&gtname || (i != PP_ENDREP &amp&amp i != PP_REP))) {\newline        return NO_DIRECTIVE_FOUND;\newline    }\newline\newline    if (defining) {\newline        if (i == PP_MACRO || i == PP_IMACRO ||\newline            i == PP_RMACRO || i == PP_IRMACRO) {\newline            nested_mac_count++;\newline            return NO_DIRECTIVE_FOUND;\newline        } else if (nested_mac_count &gt 0) {\newline            if (i == PP_ENDMACRO) {\newline                nested_mac_count--;\newline                return NO_DIRECTIVE_FOUND;\newline            }\newline        }\newline        if (!defining-&gtname) {\newline            if (i == PP_REP) {\newline                nested_rep_count++;\newline                return NO_DIRECTIVE_FOUND;\newline            } else if (nested_rep_count &gt 0) {\newline                if (i == PP_ENDREP) {\newline                    nested_rep_count--;\newline                    return NO_DIRECTIVE_FOUND;\newline                }\newline            }\newline        }\newline    }\newline\newline    switch (i) {\newline    case PP_INVALID:\newline        nasm_error(ERR_NONFATAL, &quotunknown preprocessor directive `%s&#039&quot,\newline              tline-&gttext);\newline        return NO_DIRECTIVE_FOUND;      /* didn&#039t get it */\newline\newline    case PP_STACKSIZE:\newline        /* Directive to tell NASM what the default stack size is. The\newline         * default is for a 16-bit stack, and this can be overriden with\newline         * %stacksize large.\newline         */\newline        tline = tline-&gtnext;\newline        if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline            tline = tline-&gtnext;\newline        if (!tline || tline-&gttype != TOK_ID) {\newline            nasm_error(ERR_NONFATAL, &quot`%%stacksize&#039 missing size parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        if (nasm_stricmp(tline-&gttext, &quotflat&quot) == 0) {\newline            /* All subsequent ARG directives are for a 32-bit stack */\newline            StackSize = 4;\newline            StackPointer = &quotebp&quot;\newline            ArgOffset = 8;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotflat64&quot) == 0) {\newline            /* All subsequent ARG directives are for a 64-bit stack */\newline            StackSize = 8;\newline            StackPointer = &quotrbp&quot;\newline            ArgOffset = 16;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotlarge&quot) == 0) {\newline            /* All subsequent ARG directives are for a 16-bit stack,\newline             * far function call.\newline             */\newline            StackSize = 2;\newline            StackPointer = &quotbp&quot;\newline            ArgOffset = 4;\newline            LocalOffset = 0;\newline        } else if (nasm_stricmp(tline-&gttext, &quotsmall&quot) == 0) {\newline            /* All subsequent ARG directives are for a 16-bit stack,\newline             * far function call. We don&#039t support near functions.\newline             */\newline            StackSize = 2;\newline            StackPointer = &quotbp&quot;\newline            ArgOffset = 6;\newline            LocalOffset = 0;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%stacksize&#039 invalid size type&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ARG:\newline        /* TASM like ARG directive to define arguments to functions, in\newline         * the following form:\newline         *\newline         *      ARG arg1:WORD, arg2:DWORD, arg4:QWORD\newline         */\newline        offset = ArgOffset;\newline        do {\newline            char *arg, directive[256];\newline            int size = StackSize;\newline\newline            /* Find the argument name */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL, &quot`%%arg&#039 missing argument parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            arg = tline-&gttext;\newline\newline            /* Find the argument size type */\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_OTHER\newline                || tline-&gttext[0] != &#039:&#039) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotSyntax error processing `%%arg&#039 directive&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL, &quot`%%arg&#039 missing size type parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline\newline            /* Allow macro expansion of type parameter */\newline            tt = tokenize(tline-&gttext);\newline            tt = expand_smacro(tt);\newline            size = parse_size(tt-&gttext);\newline            if (!size) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotInvalid size type for `%%arg&#039 missing directive&quot);\newline                free_tlist(tt);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            free_tlist(tt);\newline\newline            /* Round up to even stack slots */\newline            size = ALIGN(size, StackSize);\newline\newline            /* Now define the macro for the argument */\newline            snprintf(directive, sizeof(directive), &quot%%define %s (%s+%d)&quot,\newline                     arg, StackPointer, offset);\newline            do_directive(tokenize(directive));\newline            offset += size;\newline\newline            /* Move to the next argument in the list */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline        } while (tline &amp&amp tline-&gttype == TOK_OTHER &amp&amp tline-&gttext[0] == &#039,&#039);\newline        ArgOffset = offset;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_LOCAL:\newline        /* TASM like LOCAL directive to define local variables for a\newline         * function, in the following form:\newline         *\newline         *      LOCAL local1:WORD, local2:DWORD, local4:QWORD = LocalSize\newline         *\newline         * The &#039= LocalSize&#039 at the end is ignored by NASM, but is\newline         * required by TASM to define the local parameter size (and used\newline         * by the TASM macro package).\newline         */\newline        offset = LocalOffset;\newline        do {\newline            char *local, directive[256];\newline            int size = StackSize;\newline\newline            /* Find the argument name */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quot`%%local&#039 missing argument parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            local = tline-&gttext;\newline\newline            /* Find the argument size type */\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_OTHER\newline                || tline-&gttext[0] != &#039:&#039) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotSyntax error processing `%%local&#039 directive&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            tline = tline-&gtnext;\newline            if (!tline || tline-&gttype != TOK_ID) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quot`%%local&#039 missing size type parameter&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline\newline            /* Allow macro expansion of type parameter */\newline            tt = tokenize(tline-&gttext);\newline            tt = expand_smacro(tt);\newline            size = parse_size(tt-&gttext);\newline            if (!size) {\newline                nasm_error(ERR_NONFATAL,\newline                      &quotInvalid size type for `%%local&#039 missing directive&quot);\newline                free_tlist(tt);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            free_tlist(tt);\newline\newline            /* Round up to even stack slots */\newline            size = ALIGN(size, StackSize);\newline\newline            offset += size;     /* Negative offset, increment before */\newline\newline            /* Now define the macro for the argument */\newline            snprintf(directive, sizeof(directive), &quot%%define %s (%s-%d)&quot,\newline                     local, StackPointer, offset);\newline            do_directive(tokenize(directive));\newline\newline            /* Now define the assign to setup the enter_c macro correctly */\newline            snprintf(directive, sizeof(directive),\newline                     &quot%%assign %%$localsize %%$localsize+%d&quot, size);\newline            do_directive(tokenize(directive));\newline\newline            /* Move to the next argument in the list */\newline            tline = tline-&gtnext;\newline            if (tline &amp&amp tline-&gttype == TOK_WHITESPACE)\newline                tline = tline-&gtnext;\newline        } while (tline &amp&amp tline-&gttype == TOK_OTHER &amp&amp tline-&gttext[0] == &#039,&#039);\newline        LocalOffset = offset;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_CLEAR:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%clear&#039 ignored&quot);\newline        free_macros();\newline        init_macros();\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEPEND:\newline        t = tline-&gtnext = expand_smacro(tline-&gtnext);\newline        skip_white_(t);\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%depend&#039 expects a file name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%depend&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote_cstr(p, i);\newline        if (dephead &amp&amp !in_list(*dephead, p)) {\newline            StrList *sl = nasm_malloc(strlen(p)+1+sizeof sl-&gtnext);\newline            sl-&gtnext = NULL;\newline            strcpy(sl-&gtstr, p);\newline            *deptail = sl;\newline            deptail = &ampsl-&gtnext;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_INCLUDE:\newline        t = tline-&gtnext = expand_smacro(tline-&gtnext);\newline        skip_white_(t);\newline\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%include&#039 expects a file name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%include&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote_cstr(p, i);\newline        inc = nasm_malloc(sizeof(Include));\newline        inc-&gtnext = istk;\newline        inc-&gtconds = NULL;\newline        inc-&gtfp = inc_fopen(p, dephead, &ampdeptail, pass == 0);\newline        if (!inc-&gtfp) {\newline            /* -MG given but file not found */\newline            nasm_free(inc);\newline        } else {\newline            inc-&gtfname = src_set_fname(nasm_strdup(p));\newline            inc-&gtlineno = src_set_linnum(0);\newline            inc-&gtlineinc = 1;\newline            inc-&gtexpansion = NULL;\newline            inc-&gtmstk = NULL;\newline            istk = inc;\newline            lfmt-&gtuplevel(LIST_INCLUDE);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_USE:\newline    {\newline        static macros_t *use_pkg;\newline        const char *pkg_macro = NULL;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline\newline        if (!tline || (tline-&gttype != TOK_STRING &amp&amp\newline                       tline-&gttype != TOK_INTERNAL_STRING &amp&amp\newline                       tline-&gttype != TOK_ID)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%use&#039 expects a package name&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%use&#039 ignored&quot);\newline        if (tline-&gttype == TOK_STRING)\newline            nasm_unquote_cstr(tline-&gttext, i);\newline        use_pkg = nasm_stdmac_find_package(tline-&gttext);\newline        if (!use_pkg)\newline            nasm_error(ERR_NONFATAL, &quotunknown `%%use&#039 package: %s&quot, tline-&gttext);\newline        else\newline            pkg_macro = (char *)use_pkg + 1; /* The first string will be &lt%define&gt__USE_*__ */\newline        if (use_pkg &amp&amp ! smacro_defined(NULL, pkg_macro, 0, NULL, true)) {\newline            /* Not already included, go ahead and include it */\newline            stdmacpos = use_pkg;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline    case PP_PUSH:\newline    case PP_REPL:\newline    case PP_POP:\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (tline) {\newline            if (!tok_type_(tline, TOK_ID)) {\newline                nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a context identifier&quot,\newline                      pp_directives[i]);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;     /* but we did _something_ */\newline            }\newline            if (tline-&gtnext)\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quottrailing garbage after `%s&#039 ignored&quot,\newline                      pp_directives[i]);\newline            p = nasm_strdup(tline-&gttext);\newline        } else {\newline            p = NULL; /* Anonymous */\newline        }\newline\newline        if (i == PP_PUSH) {\newline            ctx = nasm_malloc(sizeof(Context));\newline            ctx-&gtnext = cstk;\newline            hash_init(&ampctx-&gtlocalmac, HASH_SMALL);\newline            ctx-&gtname = p;\newline            ctx-&gtnumber = unique++;\newline            cstk = ctx;\newline        } else {\newline            /* %pop or %repl */\newline            if (!cstk) {\newline                nasm_error(ERR_NONFATAL, &quot`%s&#039: context stack is empty&quot,\newline                      pp_directives[i]);\newline            } else if (i == PP_POP) {\newline                if (p &amp&amp (!cstk-&gtname || nasm_stricmp(p, cstk-&gtname)))\newline                    nasm_error(ERR_NONFATAL, &quot`%%pop&#039 in wrong context: %s, &quot\newline                          &quotexpected %s&quot,\newline                          cstk-&gtname ? cstk-&gtname : &quotanonymous&quot, p);\newline                else\newline                    ctx_pop();\newline            } else {\newline                /* i == PP_REPL */\newline                nasm_free(cstk-&gtname);\newline                cstk-&gtname = p;\newline                p = NULL;\newline            }\newline            nasm_free(p);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    case PP_FATAL:\newline        severity = ERR_FATAL;\newline        goto issue_error;\newline    case PP_ERROR:\newline        severity = ERR_NONFATAL;\newline        goto issue_error;\newline    case PP_WARNING:\newline        severity = ERR_WARNING|ERR_WARN_USER;\newline        goto issue_error;\newline\newlineissue_error:\newline    {\newline        /* Only error out if this is the final pass */\newline        if (pass != 2 &amp&amp i != PP_FATAL)\newline            return DIRECTIVE_FOUND;\newline\newline        tline-&gtnext = expand_smacro(tline-&gtnext);\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        t = tline ? tline-&gtnext : NULL;\newline        skip_white_(t);\newline        if (tok_type_(tline, TOK_STRING) &amp&amp !t) {\newline            /* The line contains only a quoted string */\newline            p = tline-&gttext;\newline            nasm_unquote(p, NULL); /* Ignore NUL character truncation */\newline            nasm_error(severity, &quot%s&quot,  p);\newline        } else {\newline            /* Not a quoted string, or more than a quoted string */\newline            p = detoken(tline, false);\newline            nasm_error(severity, &quot%s&quot,  p);\newline            nasm_free(p);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    CASE_PP_IF:\newline        if (istk-&gtconds &amp&amp !emitting(istk-&gtconds-&gtstate))\newline            j = COND_NEVER;\newline        else {\newline            j = if_condition(tline-&gtnext, i);\newline            tline-&gtnext = NULL; /* it got freed */\newline            j = j &lt 0 ? COND_NEVER : j ? COND_IF_TRUE : COND_IF_FALSE;\newline        }\newline        cond = nasm_malloc(sizeof(Cond));\newline        cond-&gtnext = istk-&gtconds;\newline        cond-&gtstate = j;\newline        istk-&gtconds = cond;\newline        if(istk-&gtmstk)\newline            istk-&gtmstk-&gtcondcnt ++;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    CASE_PP_ELIF:\newline        if (!istk-&gtconds)\newline            nasm_error(ERR_FATAL, &quot`%s&#039: no matching `%%if&#039&quot, pp_directives[i]);\newline        switch(istk-&gtconds-&gtstate) {\newline        case COND_IF_TRUE:\newline            istk-&gtconds-&gtstate = COND_DONE;\newline            break;\newline\newline        case COND_DONE:\newline        case COND_NEVER:\newline            break;\newline\newline        case COND_ELSE_TRUE:\newline        case COND_ELSE_FALSE:\newline	    nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quot`%%elif&#039 after `%%else&#039 ignored&quot);\newline            istk-&gtconds-&gtstate = COND_NEVER;\newline            break;\newline\newline        case COND_IF_FALSE:\newline            /*\newline             * IMPORTANT: In the case of %if, we will already have\newline             * called expand_mmac_params(); however, if we&#039re\newline             * processing an %elif we must have been in a\newline             * non-emitting mode, which would have inhibited\newline             * the normal invocation of expand_mmac_params().\newline             * Therefore, we have to do it explicitly here.\newline             */\newline            j = if_condition(expand_mmac_params(tline-&gtnext), i);\newline            tline-&gtnext = NULL; /* it got freed */\newline            istk-&gtconds-&gtstate =\newline                j &lt 0 ? COND_NEVER : j ? COND_IF_TRUE : COND_IF_FALSE;\newline            break;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ELSE:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quottrailing garbage after `%%else&#039 ignored&quot);\newline        if (!istk-&gtconds)\newline	    nasm_fatal(0, &quot`%%else: no matching `%%if&#039&quot);\newline        switch(istk-&gtconds-&gtstate) {\newline        case COND_IF_TRUE:\newline        case COND_DONE:\newline            istk-&gtconds-&gtstate = COND_ELSE_FALSE;\newline            break;\newline\newline        case COND_NEVER:\newline            break;\newline\newline        case COND_IF_FALSE:\newline            istk-&gtconds-&gtstate = COND_ELSE_TRUE;\newline            break;\newline\newline        case COND_ELSE_TRUE:\newline        case COND_ELSE_FALSE:\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline                          &quot`%%else&#039 after `%%else&#039 ignored.&quot);\newline            istk-&gtconds-&gtstate = COND_NEVER;\newline            break;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDIF:\newline        if (tline-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1|ERR_PP_PRECOND,\newline		       &quottrailing garbage after `%%endif&#039 ignored&quot);\newline        if (!istk-&gtconds)\newline            nasm_error(ERR_FATAL, &quot`%%endif&#039: no matching `%%if&#039&quot);\newline        cond = istk-&gtconds;\newline        istk-&gtconds = cond-&gtnext;\newline        nasm_free(cond);\newline        if(istk-&gtmstk)\newline            istk-&gtmstk-&gtcondcnt --;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_RMACRO:\newline    case PP_IRMACRO:\newline    case PP_MACRO:\newline    case PP_IMACRO:\newline        if (defining) {\newline            nasm_error(ERR_FATAL, &quot`%s&#039: already defining a macro&quot,\newline                  pp_directives[i]);\newline            return DIRECTIVE_FOUND;\newline        }\newline        defining = nasm_malloc(sizeof(MMacro));\newline        defining-&gtmax_depth =\newline            (i == PP_RMACRO) || (i == PP_IRMACRO) ? DEADMAN_LIMIT : 0;\newline        defining-&gtcasesense = (i == PP_MACRO) || (i == PP_RMACRO);\newline        if (!parse_mmacro_spec(tline, defining, pp_directives[i])) {\newline            nasm_free(defining);\newline            defining = NULL;\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        mmac = (MMacro *) hash_findix(&ampmmacros, defining-&gtname);\newline        while (mmac) {\newline            if (!strcmp(mmac-&gtname, defining-&gtname) &amp&amp\newline                (mmac-&gtnparam_min &lt= defining-&gtnparam_max\newline                 || defining-&gtplus)\newline                &amp&amp (defining-&gtnparam_min &lt= mmac-&gtnparam_max\newline                    || mmac-&gtplus)) {\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quotredefining multi-line macro `%s&#039&quot, defining-&gtname);\newline                return DIRECTIVE_FOUND;\newline            }\newline            mmac = mmac-&gtnext;\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDM:\newline    case PP_ENDMACRO:\newline        if (! (defining &amp&amp defining-&gtname)) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039: not defining a macro&quot, tline-&gttext);\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmhead = (MMacro **) hash_findi_add(&ampmmacros, defining-&gtname);\newline        defining-&gtnext = *mmhead;\newline        *mmhead = defining;\newline        defining = NULL;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_EXITMACRO:\newline        /*\newline         * We must search along istk-&gtexpansion until we hit a\newline         * macro-end marker for a macro with a name. Then we\newline         * bypass all lines between exitmacro and endmacro.\newline         */\newline        list_for_each(l, istk-&gtexpansion)\newline            if (l-&gtfinishes &amp&amp l-&gtfinishes-&gtname)\newline                break;\newline\newline        if (l) {\newline            /*\newline             * Remove all conditional entries relative to this\newline             * macro invocation. (safe to do in this context)\newline             */\newline            for ( ; l-&gtfinishes-&gtcondcnt &gt 0; l-&gtfinishes-&gtcondcnt --) {\newline                cond = istk-&gtconds;\newline                istk-&gtconds = cond-&gtnext;\newline                nasm_free(cond);\newline            }\newline            istk-&gtexpansion = l;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%exitmacro&#039 not within `%%macro&#039 block&quot);\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_UNMACRO:\newline    case PP_UNIMACRO:\newline    {\newline        MMacro **mmac_p;\newline        MMacro spec;\newline\newline        spec.casesense = (i == PP_UNMACRO);\newline        if (!parse_mmacro_spec(tline, &ampspec, pp_directives[i])) {\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmac_p = (MMacro **) hash_findi(&ampmmacros, spec.name, NULL);\newline        while (mmac_p &amp&amp *mmac_p) {\newline            mmac = *mmac_p;\newline            if (mmac-&gtcasesense == spec.casesense &amp&amp\newline                !mstrcmp(mmac-&gtname, spec.name, spec.casesense) &amp&amp\newline                mmac-&gtnparam_min == spec.nparam_min &amp&amp\newline                mmac-&gtnparam_max == spec.nparam_max &amp&amp\newline                mmac-&gtplus == spec.plus) {\newline                *mmac_p = mmac-&gtnext;\newline                free_mmacro(mmac);\newline            } else {\newline                mmac_p = &ampmmac-&gtnext;\newline            }\newline        }\newline        free_tlist(origline);\newline        free_tlist(spec.dlist);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_ROTATE:\newline        if (tline-&gtnext &amp&amp tline-&gtnext-&gttype == TOK_WHITESPACE)\newline            tline = tline-&gtnext;\newline        if (!tline-&gtnext) {\newline            free_tlist(origline);\newline            nasm_error(ERR_NONFATAL, &quot`%%rotate&#039 missing rotate count&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline        t = expand_smacro(tline-&gtnext);\newline        tline-&gtnext = NULL;\newline        free_tlist(origline);\newline        tline = t;\newline        tptr = &ampt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult =\newline            evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        free_tlist(tline);\newline        if (!evalresult)\newline            return DIRECTIVE_FOUND;\newline        if (tokval.t_type)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after expression ignored&quot);\newline        if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%rotate&#039&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline        mmac = istk-&gtmstk;\newline        while (mmac &amp&amp !mmac-&gtname)     /* avoid mistaking %reps for macros */\newline            mmac = mmac-&gtnext_active;\newline        if (!mmac) {\newline            nasm_error(ERR_NONFATAL, &quot`%%rotate&#039 invoked outside a macro call&quot);\newline        } else if (mmac-&gtnparam == 0) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%rotate&#039 invoked within macro without parameters&quot);\newline        } else {\newline            int rotate = mmac-&gtrotate + reloc_value(evalresult);\newline\newline            rotate %= (int)mmac-&gtnparam;\newline            if (rotate &lt 0)\newline                rotate += mmac-&gtnparam;\newline\newline            mmac-&gtrotate = rotate;\newline        }\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_REP:\newline        nolist = false;\newline        do {\newline            tline = tline-&gtnext;\newline        } while (tok_type_(tline, TOK_WHITESPACE));\newline\newline        if (tok_type_(tline, TOK_ID) &amp&amp\newline            nasm_stricmp(tline-&gttext, &quot.nolist&quot) == 0) {\newline            nolist = true;\newline            do {\newline                tline = tline-&gtnext;\newline            } while (tok_type_(tline, TOK_WHITESPACE));\newline        }\newline\newline        if (tline) {\newline            t = expand_smacro(tline);\newline            tptr = &ampt;\newline            tokval.t_type = TOKEN_INVALID;\newline            evalresult =\newline                evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline            if (!evalresult) {\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            if (tokval.t_type)\newline                nasm_error(ERR_WARNING|ERR_PASS1,\newline                      &quottrailing garbage after expression ignored&quot);\newline            if (!is_simple(evalresult)) {\newline                nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%rep&#039&quot);\newline                return DIRECTIVE_FOUND;\newline            }\newline            count = reloc_value(evalresult);\newline            if (count &gt= REP_LIMIT) {\newline                nasm_error(ERR_NONFATAL, &quot`%%rep&#039 value exceeds limit&quot);\newline                count = 0;\newline            } else\newline                count++;\newline        } else {\newline            nasm_error(ERR_NONFATAL, &quot`%%rep&#039 expects a repeat count&quot);\newline            count = 0;\newline        }\newline        free_tlist(origline);\newline\newline        tmp_defining = defining;\newline        defining = nasm_malloc(sizeof(MMacro));\newline        defining-&gtprev = NULL;\newline        defining-&gtname = NULL;  /* flags this macro as a %rep block */\newline        defining-&gtcasesense = false;\newline        defining-&gtplus = false;\newline        defining-&gtnolist = nolist;\newline        defining-&gtin_progress = count;\newline        defining-&gtmax_depth = 0;\newline        defining-&gtnparam_min = defining-&gtnparam_max = 0;\newline        defining-&gtdefaults = NULL;\newline        defining-&gtdlist = NULL;\newline        defining-&gtexpansion = NULL;\newline        defining-&gtnext_active = istk-&gtmstk;\newline        defining-&gtrep_nest = tmp_defining;\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_ENDREP:\newline        if (!defining || defining-&gtname) {\newline            nasm_error(ERR_NONFATAL, &quot`%%endrep&#039: no matching `%%rep&#039&quot);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        /*\newline         * Now we have a &quotmacro&quot defined - although it has no name\newline         * and we won&#039t be entering it in the hash tables - we must\newline         * push a macro-end marker for it on to istk-&gtexpansion.\newline         * After that, it will take care of propagating itself (a\newline         * macro-end marker line for a macro which is really a %rep\newline         * block will cause the macro to be re-expanded, complete\newline         * with another macro-end marker to ensure the process\newline         * continues) until the whole expansion is forcibly removed\newline         * from istk-&gtexpansion by a %exitrep.\newline         */\newline        l = nasm_malloc(sizeof(Line));\newline        l-&gtnext = istk-&gtexpansion;\newline        l-&gtfinishes = defining;\newline        l-&gtfirst = NULL;\newline        istk-&gtexpansion = l;\newline\newline        istk-&gtmstk = defining;\newline\newline        lfmt-&gtuplevel(defining-&gtnolist ? LIST_MACRO_NOLIST : LIST_MACRO);\newline        tmp_defining = defining;\newline        defining = defining-&gtrep_nest;\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_EXITREP:\newline        /*\newline         * We must search along istk-&gtexpansion until we hit a\newline         * macro-end marker for a macro with no name. Then we set\newline         * its `in_progress&#039 flag to 0.\newline         */\newline        list_for_each(l, istk-&gtexpansion)\newline            if (l-&gtfinishes &amp&amp !l-&gtfinishes-&gtname)\newline                break;\newline\newline        if (l)\newline            l-&gtfinishes-&gtin_progress = 1;\newline        else\newline            nasm_error(ERR_NONFATAL, &quot`%%exitrep&#039 not within `%%rep&#039 block&quot);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_XDEFINE:\newline    case PP_IXDEFINE:\newline    case PP_DEFINE:\newline    case PP_IDEFINE:\newline        casesense = (i == PP_DEFINE || i == PP_XDEFINE);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a macro identifier&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        param_start = tline = tline-&gtnext;\newline        nparam = 0;\newline\newline        /* Expand the macro definition now for %xdefine and %ixdefine */\newline        if ((i == PP_XDEFINE) || (i == PP_IXDEFINE))\newline            tline = expand_smacro(tline);\newline\newline        if (tok_is_(tline, &quot(&quot)) {\newline            /*\newline             * This macro has parameters.\newline             */\newline\newline            tline = tline-&gtnext;\newline            while (1) {\newline                skip_white_(tline);\newline                if (!tline) {\newline                    nasm_error(ERR_NONFATAL, &quotparameter identifier expected&quot);\newline                    free_tlist(origline);\newline                    return DIRECTIVE_FOUND;\newline                }\newline                if (tline-&gttype != TOK_ID) {\newline                    nasm_error(ERR_NONFATAL,\newline                          &quot`%s&#039: parameter identifier expected&quot,\newline                          tline-&gttext);\newline                    free_tlist(origline);\newline                    return DIRECTIVE_FOUND;\newline                }\newline                tline-&gttype = TOK_SMAC_PARAM + nparam++;\newline                tline = tline-&gtnext;\newline                skip_white_(tline);\newline                if (tok_is_(tline, &quot,&quot)) {\newline                    tline = tline-&gtnext;\newline                } else {\newline                    if (!tok_is_(tline, &quot)&quot)) {\newline                        nasm_error(ERR_NONFATAL,\newline                              &quot`)&#039 expected to terminate macro template&quot);\newline                        free_tlist(origline);\newline                        return DIRECTIVE_FOUND;\newline                    }\newline                    break;\newline                }\newline            }\newline            last = tline;\newline            tline = tline-&gtnext;\newline        }\newline        if (tok_type_(tline, TOK_WHITESPACE))\newline            last = tline, tline = tline-&gtnext;\newline        macro_start = NULL;\newline        last-&gtnext = NULL;\newline        t = tline;\newline        while (t) {\newline            if (t-&gttype == TOK_ID) {\newline                list_for_each(tt, param_start)\newline                    if (tt-&gttype &gt= TOK_SMAC_PARAM &amp&amp\newline                        !strcmp(tt-&gttext, t-&gttext))\newline                        t-&gttype = tt-&gttype;\newline            }\newline            tt = t-&gtnext;\newline            t-&gtnext = macro_start;\newline            macro_start = t;\newline            t = tt;\newline        }\newline        /*\newline         * Good. We now have a macro name, a parameter count, and a\newline         * token list (in reverse order) for an expansion. We ought\newline         * to be OK just to create an SMacro, store it, and let\newline         * free_tlist have the rest of the line (which we have\newline         * carefully re-terminated after chopping off the expansion\newline         * from the end).\newline         */\newline        define_smacro(ctx, mname, casesense, nparam, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_UNDEF:\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%%undef&#039 expects a macro identifier&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        if (tline-&gtnext) {\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after macro name ignored&quot);\newline        }\newline\newline        /* Find the context that symbol belongs to */\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        undef_smacro(ctx, mname);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEFSTR:\newline    case PP_IDEFSTR:\newline        casesense = (i == PP_DEFSTR);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL, &quot`%s&#039 expects a macro identifier&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        while (tok_type_(tline, TOK_WHITESPACE))\newline            tline = delete_Token(tline);\newline\newline        p = detoken(tline, false);\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote(p, strlen(p));\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline        nasm_free(p);\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a string token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_DEFTOK:\newline    case PP_IDEFTOK:\newline        casesense = (i == PP_DEFTOK);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%s&#039 expects a macro identifier as first parameter&quot,\newline                  pp_directives[i]);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%s` requires string as second parameter&quot,\newline                  pp_directives[i]);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        /*\newline         * Convert the string to a token stream.  Note that smacros\newline         * are stored with the token stream reversed, so we have to\newline         * reverse the output of tokenize().\newline         */\newline        nasm_unquote_cstr(t-&gttext, i);\newline        macro_start = reverse_tokens(tokenize(t-&gttext));\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_PATHSEARCH:\newline    {\newline        FILE *fp;\newline        StrList *xsl = NULL;\newline        StrList **xst = &ampxsl;\newline\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%pathsearch&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline\newline        if (!t || (t-&gttype != TOK_STRING &amp&amp\newline                   t-&gttype != TOK_INTERNAL_STRING)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%pathsearch&#039 expects a file name&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;     /* but we did _something_ */\newline        }\newline        if (t-&gtnext)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after `%%pathsearch&#039 ignored&quot);\newline        p = t-&gttext;\newline        if (t-&gttype != TOK_INTERNAL_STRING)\newline            nasm_unquote(p, NULL);\newline\newline        fp = inc_fopen(p, &ampxsl, &ampxst, true);\newline        if (fp) {\newline            p = xsl-&gtstr;\newline            fclose(fp);         /* Don&#039t actually care about the file */\newline        }\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote(p, strlen(p));\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline        if (xsl)\newline            nasm_free(xsl);\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a string token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_STRLEN:\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strlen&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strlen` requires string as second parameter&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        make_tok_num(macro_start, nasm_unquote(t-&gttext, NULL));\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_STRCAT:\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%strcat&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        len = 0;\newline        list_for_each(t, tline) {\newline            switch (t-&gttype) {\newline            case TOK_WHITESPACE:\newline                break;\newline            case TOK_STRING:\newline                len += t-&gta.len = nasm_unquote(t-&gttext, NULL);\newline                break;\newline            case TOK_OTHER:\newline                if (!strcmp(t-&gttext, &quot,&quot)) /* permit comma separators */\newline                    break;\newline                /* else fall through */\newline            default:\newline                nasm_error(ERR_NONFATAL,\newline                      &quotnon-string passed to `%%strcat&#039 (%d)&quot, t-&gttype);\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline        }\newline\newline        p = pp = nasm_malloc(len);\newline        list_for_each(t, tline) {\newline            if (t-&gttype == TOK_STRING) {\newline                memcpy(p, t-&gttext, t-&gta.len);\newline                p += t-&gta.len;\newline            }\newline        }\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        macro_start = new_Token(NULL, TOK_STRING, NULL, 0);\newline        macro_start-&gttext = nasm_quote(pp, len);\newline        nasm_free(pp);\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_SUBSTR:\newline    {\newline        int64_t start, count;\newline        size_t len;\newline\newline        casesense = true;\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%substr&#039 expects a macro identifier as first parameter&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        if (tline) /* skip expanded id */\newline            t = tline-&gtnext;\newline        while (tok_type_(t, TOK_WHITESPACE))\newline            t = t-&gtnext;\newline\newline        /* t should now point to the string */\newline        if (!tok_type_(t, TOK_STRING)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%substr` requires string as second parameter&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        tt = t-&gtnext;\newline        tptr = &amptt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        if (!evalresult) {\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        } else if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%substr`&quot);\newline            free_tlist(tline);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        start = evalresult-&gtvalue - 1;\newline\newline        while (tok_type_(tt, TOK_WHITESPACE))\newline            tt = tt-&gtnext;\newline        if (!tt) {\newline            count = 1;  /* Backwards compatibility: one character */\newline        } else {\newline            tokval.t_type = TOKEN_INVALID;\newline            evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline            if (!evalresult) {\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            } else if (!is_simple(evalresult)) {\newline                nasm_error(ERR_NONFATAL, &quotnon-constant value given to `%%substr`&quot);\newline                free_tlist(tline);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            count = evalresult-&gtvalue;\newline        }\newline\newline        len = nasm_unquote(t-&gttext, NULL);\newline\newline        /* make start and count being in range */\newline        if (start &lt 0)\newline            start = 0;\newline        if (count &lt 0)\newline            count = len + count + 1 - start;\newline        if (start + count &gt (int64_t)len)\newline            count = len - start;\newline        if (!len || count &lt 0 || start &gt=(int64_t)len)\newline            start = -1, count = 0; /* empty string */\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        macro_start-&gttext = nasm_quote((start &lt 0) ? &quot&quot : t-&gttext + start, count);\newline        macro_start-&gttype = TOK_STRING;\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(tline);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline    }\newline\newline    case PP_ASSIGN:\newline    case PP_IASSIGN:\newline        casesense = (i == PP_ASSIGN);\newline\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        tline = expand_id(tline);\newline        if (!tline || (tline-&gttype != TOK_ID &amp&amp\newline                       (tline-&gttype != TOK_PREPROC_ID ||\newline                        tline-&gttext[1] != &#039$&#039))) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quot`%%%sassign&#039 expects a macro identifier&quot,\newline                  (i == PP_IASSIGN ? &quoti&quot : &quot&quot));\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        ctx = get_ctx(tline-&gttext, &ampmname);\newline        last = tline;\newline        tline = expand_smacro(tline-&gtnext);\newline        last-&gtnext = NULL;\newline\newline        t = tline;\newline        tptr = &ampt;\newline        tokval.t_type = TOKEN_INVALID;\newline        evalresult = evaluate(ppscan, tptr, &amptokval, NULL, pass, NULL);\newline        free_tlist(tline);\newline        if (!evalresult) {\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        if (tokval.t_type)\newline            nasm_error(ERR_WARNING|ERR_PASS1,\newline                  &quottrailing garbage after expression ignored&quot);\newline\newline        if (!is_simple(evalresult)) {\newline            nasm_error(ERR_NONFATAL,\newline                  &quotnon-constant value given to `%%%sassign&#039&quot,\newline                  (i == PP_IASSIGN ? &quoti&quot : &quot&quot));\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline\newline        macro_start = nasm_malloc(sizeof(*macro_start));\newline        macro_start-&gtnext = NULL;\newline        make_tok_num(macro_start, reloc_value(evalresult));\newline        macro_start-&gta.mac = NULL;\newline\newline        /*\newline         * We now have a macro name, an implicit parameter count of\newline         * zero, and a numeric token to use as an expansion. Create\newline         * and store an SMacro.\newline         */\newline        define_smacro(ctx, mname, casesense, 0, macro_start);\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    case PP_LINE:\newline        /*\newline         * Syntax is `%line nnn[+mmm] [filename]&#039\newline         */\newline        tline = tline-&gtnext;\newline        skip_white_(tline);\newline        if (!tok_type_(tline, TOK_NUMBER)) {\newline            nasm_error(ERR_NONFATAL, &quot`%%line&#039 expects line number&quot);\newline            free_tlist(origline);\newline            return DIRECTIVE_FOUND;\newline        }\newline        k = readnum(tline-&gttext, &amperr);\newline        m = 1;\newline        tline = tline-&gtnext;\newline        if (tok_is_(tline, &quot+&quot)) {\newline            tline = tline-&gtnext;\newline            if (!tok_type_(tline, TOK_NUMBER)) {\newline                nasm_error(ERR_NONFATAL, &quot`%%line&#039 expects line increment&quot);\newline                free_tlist(origline);\newline                return DIRECTIVE_FOUND;\newline            }\newline            m = readnum(tline-&gttext, &amperr);\newline            tline = tline-&gtnext;\newline        }\newline        skip_white_(tline);\newline        src_set_linnum(k);\newline        istk-&gtlineinc = m;\newline        if (tline) {\newline            nasm_free(src_set_fname(detoken(tline, false)));\newline        }\newline        free_tlist(origline);\newline        return DIRECTIVE_FOUND;\newline\newline    default:\newline        nasm_error(ERR_FATAL,\newline              &quotpreprocessor directive `%s&#039 not yet implemented&quot,\newline              pp_directives[i]);\newline        return DIRECTIVE_FOUND;\newline    }\newline}\newline","\newline find and process preprocessor directive in passed line\newline Find out if a line contains a preprocessor directive, and deal\newline with it if so.\newline \newline If a directive _is_ found, it is the responsibility of this routine\newline (and not the caller) to free_tlist() the line.\newline \newline @param tline a pointer to the current tokeninzed line linked list\newline @return DIRECTIVE_FOUND or NO_DIRECTIVE_FOUND\newline \newline \newline","1259456","tidy.c","static ctmbstr ConfigCategoryName( TidyConfigCategory id )\newline{\newline    switch( id )\newline    {\newline        case TidyMarkup:\newline            return tidyLocalizedString( TC_CAT_MARKUP );\newline        case TidyDiagnostics:\newline            return tidyLocalizedString( TC_CAT_DIAGNOSTICS );\newline        case TidyPrettyPrint:\newline            return tidyLocalizedString( TC_CAT_PRETTYPRINT );\newline        case TidyEncoding:\newline            return tidyLocalizedString( TC_CAT_ENCODING );\newline        case TidyMiscellaneous:\newline            return tidyLocalizedString( TC_CAT_MISC );\newline    }\newline    fprintf(stderr, tidyLocalizedString(TC_STRING_FATAL_ERROR), (int)id);\newline    fprintf(stderr, &quot\\n&quot);\newline\newline    assert(0);\newline    abort();\newline    return &quotnever_here&quot; /* only for the compiler warning */\newline}\newline","\newline Returns the configuration category name for the\newline specified configuration category id. This will be\newline used as an XML class attribute value.\newline \newline","5150287","ptunnel.c","challenge_t*	generate_challenge(void) {\newline	struct timeval	tt;\newline	challenge_t		*c;\newline	int				i;\newline	\newline	c	= calloc(1, sizeof(challenge_t));\newline	gettimeofday(&amptt, 0);\newline	c-&gtsec		= tt.tv_sec;\newline	c-&gtusec_rnd	= tt.tv_usec + rand();\newline	for (i=0;i&lt6;i++)\newline		c-&gtrandom[i]	= rand();\newline	\newline	return c;\newline}\newline","generate_challenge: Generates a random challenge, incorporating the current\newline local timestamp to avoid replay attacks.\newline \newline","2285311","rrd_hw.c","void erase_violations(\newline    rrd_t *rrd,\newline    unsigned long cdp_idx,\newline    unsigned long rra_idx)\newline{\newline    unsigned short i;\newline    char     *violations_array;\newline\newline    /* check that rra_idx is a CF_FAILURES array */\newline    if (cf_conv(rrd-&gtrra_def[rra_idx].cf_nam) != CF_FAILURES) {\newline#ifdef DEBUG\newline        fprintf(stderr, &quoterase_violations called for non-FAILURES RRA: %s\\n&quot,\newline                rrd-&gtrra_def[rra_idx].cf_nam);\newline#endif\newline        return;\newline    }\newline#ifdef DEBUG\newline    fprintf(stderr, &quotscratch buffer before erase:\\n&quot);\newline    for (i = 0; i &lt MAX_CDP_PAR_EN; i++) {\newline        fprintf(stderr, &quot%lu &quot, rrd-&gtcdp_prep[cdp_idx].scratch[i].u_cnt);\newline    }\newline    fprintf(stderr, &quot\\n&quot);\newline#endif\newline\newline    /* WARNING: an array of longs on disk is treated as an array of chars\newline     * in memory. */\newline    violations_array = (char *) ((void *) rrd-&gtcdp_prep[cdp_idx].scratch);\newline    /* erase everything in the part of the CDP scratch array that will be\newline     * used to store violations for the current window */\newline    for (i = rrd-&gtrra_def[rra_idx].par[RRA_window_len].u_cnt; i &gt 0; i--) {\newline        violations_array[i - 1] = 0;\newline    }\newline#ifdef DEBUG\newline    fprintf(stderr, &quotscratch buffer after erase:\\n&quot);\newline    for (i = 0; i &lt MAX_CDP_PAR_EN; i++) {\newline        fprintf(stderr, &quot%lu &quot, rrd-&gtcdp_prep[cdp_idx].scratch[i].u_cnt);\newline    }\newline    fprintf(stderr, &quot\\n&quot);\newline#endif\newline}\newline","For the specified CDP prep area and the FAILURES RRA,\newline erase all history of past violations.\newline \newline","3680637","verbs_info.c","static int fi_ibv_have_device(void)\newline{\newline	struct ibv_device **devs;\newline	struct ibv_context *verbs;\newline	int i, ret = 0;\newline\newline	devs = ibv_get_device_list(NULL);\newline	if (!devs)\newline		return 0;\newline\newline	for (i = 0; devs[i]; i++) {\newline		verbs = ibv_open_device(devs[i]);\newline		if (verbs) {\newline			ibv_close_device(verbs);\newline			ret = 1;\newline			break;\newline		}\newline	}\newline\newline	ibv_free_device_list(devs);\newline	return ret;\newline}\newline","\newline USNIC plugs into the verbs framework, but is not a usable device.\newline Manually check for devices and fail gracefully if none are present.\newline This avoids the lower libraries (libibverbs and librdmacm) from\newline reporting error messages to stderr.\newline \newline","1345582","tls_generic.c","int TLSVerifyPeer(ConnectionInfo *conn_info, const char *remoteip, const char *username)\newline{\newline    int ret, retval;\newline\newline    X509 *received_cert = SSL_get_peer_certificate(conn_info-&gtssl);\newline    if (received_cert == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR,\newline            &quotNo certificate presented by remote peer (openssl: %s)&quot,\newline            TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret1;\newline    }\newline\newline    EVP_PKEY *received_pubkey = X509_get_pubkey(received_cert);\newline    if (received_pubkey == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotX509_get_pubkey: %s&quot,\newline            TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret2;\newline    }\newline    if (EVP_PKEY_type(received_pubkey-&gttype) != EVP_PKEY_RSA)\newline    {\newline        Log(LOG_LEVEL_ERR,\newline            &quotReceived key of unknown type, only RSA currently supported!&quot);\newline        retval = -1;\newline        goto ret3;\newline    }\newline\newline    RSA *remote_key = EVP_PKEY_get1_RSA(received_pubkey);\newline    if (remote_key == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_get1_RSA failed!&quot);\newline        retval = -1;\newline        goto ret3;\newline    }\newline\newline    Key *key = KeyNew(remote_key, CF_DEFAULT_DIGEST);\newline    conn_info-&gtremote_key = key;\newline\newline    /*\newline     * Compare the key received with the one stored.\newline     */\newline    const char *key_hash = KeyPrintableHash(key);\newline    RSA *expected_rsa_key = HavePublicKey(username, remoteip, key_hash);\newline\newline    if (expected_rsa_key == NULL)\newline    {\newline        /* TODO LOG_LEVEL_NOTICE once cf-serverd logs to a different file. */\newline        Log(LOG_LEVEL_VERBOSE,\newline            &quotReceived key &#039%s&#039 not found in ppkeys&quot, key_hash);\newline        retval = 0;\newline        goto ret4;\newline    }\newline\newline    EVP_PKEY *expected_pubkey = EVP_PKEY_new();\newline    if (expected_pubkey == NULL)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_new allocation failed!&quot);\newline        retval = -1;\newline        goto ret5;\newline    }\newline\newline    ret = EVP_PKEY_set1_RSA(expected_pubkey, expected_rsa_key);\newline    if (ret == 0)\newline    {\newline        Log(LOG_LEVEL_ERR, &quotTLSVerifyPeer: EVP_PKEY_set1_RSA failed!&quot);\newline        retval = -1;\newline        goto ret6;\newline    }\newline\newline    ret = EVP_PKEY_cmp(received_pubkey, expected_pubkey);\newline    if (ret == 1)\newline    {\newline        Log(LOG_LEVEL_VERBOSE,\newline            &quotReceived public key compares equal to the one we have stored&quot);\newline        retval = 1;               /* TRUSTED KEY, equal to the expected one */\newline        goto ret6;\newline    }\newline    else if (ret == 0 || ret == -1)\newline    {\newline        Log(LOG_LEVEL_NOTICE,\newline            &quotReceived key &#039%s&#039 compares different to the one in ppkeys&quot,\newline            key_hash);\newline        retval = 0;\newline        goto ret6;\newline    }\newline    else\newline    {\newline        Log(LOG_LEVEL_ERR, &quotOpenSSL EVP_PKEY_cmp: %d %s&quot,\newline            ret, TLSErrorString(ERR_get_error()));\newline        retval = -1;\newline        goto ret6;\newline    }\newline\newline    UnexpectedError(&quotUnreachable!&quot);\newline    return 0;\newline\newline  ret6:\newline    EVP_PKEY_free(expected_pubkey);\newline  ret5:\newline    RSA_free(expected_rsa_key);\newline  ret4:\newline    if (retval == -1)\newline    {\newline        /* We won&#039t be needing conn_info-&gtremote_key */\newline        KeyDestroy(&ampkey);\newline        conn_info-&gtremote_key = NULL;\newline    }\newline  ret3:\newline    EVP_PKEY_free(received_pubkey);\newline  ret2:\newline    X509_free(received_cert);\newline  ret1:\newline    return retval;\newline}\newline","\newline @retval 1 if the public key used by the peer in the TLS handshake is the\newline same with the one stored for that host.\newline @retval 0 if stored key for the host is missing or differs from the one\newline received.\newline @retval -1 in case of other error (error will be Log()ed).\newline @note When return value is != -1 (so no error occurred) the #conn_info struct\newline should have been populated, with key received and its hash.\newline \newline","6424471","sequence.c","void dsa_push(dsa_t *A, seq_t S) {\newline	if (A-&gtsize &lt A-&gtcapacity) {\newline		A-&gtdata[A-&gtsize++] = S;\newline	} else {\newline		// use the near-optimal growth factor of 1.5\newline		seq_t *ptr = reallocarray(A-&gtdata, A-&gtcapacity / 2, sizeof(seq_t) * 3);\newline		CHECK_MALLOC(ptr);\newline\newline		A-&gtcapacity = (A-&gtcapacity / 2) * 3;\newline		A-&gtdata = ptr;\newline		A-&gtdata[A-&gtsize++] = S;\newline	}\newline}\newline","Add a sequence to an array. \newline","776877","metadata.c","static int _vg_update_old_pv_ext_if_needed(struct volume_group *vg)\newline{\newline	struct pv_list *pvl, *new_pvl;\newline	int pv_needs_rewrite;\newline\newline	if (!(vg-&gtfid-&gtfmt-&gtfeatures &amp FMT_PV_FLAGS))\newline		return 1;\newline\newline	dm_list_iterate_items(pvl, &ampvg-&gtpvs) {\newline		if (is_missing_pv(pvl-&gtpv) ||\newline		    !pvl-&gtpv-&gtfmt-&gtops-&gtpv_needs_rewrite)\newline			continue;\newline\newline		if (_pv_in_pv_list(pvl-&gtpv, &ampvg-&gtpv_write_list))\newline			continue;\newline\newline		if (!pvl-&gtpv-&gtfmt-&gtops-&gtpv_needs_rewrite(pvl-&gtpv-&gtfmt, pvl-&gtpv,\newline							 &amppv_needs_rewrite))\newline			return_0;\newline\newline		if (pv_needs_rewrite) {\newline			/*\newline			 * Schedule PV for writing only once!\newline			 */\newline			if (_pv_in_pv_list(pvl-&gtpv, &ampvg-&gtpv_write_list))\newline				continue;\newline\newline			if (!(new_pvl = dm_pool_zalloc(vg-&gtvgmem, sizeof(*new_pvl)))) {\newline				log_error(&quotpv_to_write allocation for &#039%s&#039 failed&quot, pv_dev_name(pvl-&gtpv));\newline				return 0;\newline			}\newline			new_pvl-&gtpv = pvl-&gtpv;\newline			dm_list_add(&ampvg-&gtpv_write_list, &ampnew_pvl-&gtlist);\newline			log_debug(&quotPV %s has old extension header, updating to newest version.&quot,\newline				  pv_dev_name(pvl-&gtpv));\newline		}\newline	}\newline\newline	if (!dm_list_empty(&ampvg-&gtpv_write_list) &amp&amp\newline	    (!vg_write(vg) || !vg_commit(vg))) {\newline		log_error(&quotFailed to update old PV extension headers in VG %s.&quot, vg-&gtname);\newline		return 0;\newline	}\newline\newline	return 1;\newline}\newline","\newline Check if any of the PVs in VG still contain old PV headers\newline and if yes, schedule them for PV header update.\newline \newline","336311","diff_match_patch.cpp","QString Patch::toString() {\newline  QString coords1, coords2;\newline  if (length1 == 0) {\newline    coords1 = QString::number(start1) + QString(&quot,0&quot);\newline  } else if (length1 == 1) {\newline    coords1 = QString::number(start1 + 1);\newline  } else {\newline    coords1 = QString::number(start1 + 1) + QString(&quot,&quot)\newline        + QString::number(length1);\newline  }\newline  if (length2 == 0) {\newline    coords2 = QString::number(start2) + QString(&quot,0&quot);\newline  } else if (length2 == 1) {\newline    coords2 = QString::number(start2 + 1);\newline  } else {\newline    coords2 = QString::number(start2 + 1) + QString(&quot,&quot)\newline        + QString::number(length2);\newline  }\newline  QString text;\newline  text = QString(&quot@@ -&quot) + coords1 + QString(&quot +&quot) + coords2\newline      + QString(&quot @@\\n&quot);\newline  // Escape the body of the patch with %xx notation.\newline  foreach (Diff aDiff, diffs) {\newline    switch (aDiff.operation) {\newline      case INSERT:\newline        text += QString(&#039+&#039);\newline        break;\newline      case DELETE:\newline        text += QString(&#039-&#039);\newline        break;\newline      case EQUAL:\newline        text += QString(&#039 &#039);\newline        break;\newline    }\newline    text += QString(QUrl::toPercentEncoding(aDiff.text, &quot !~*&#039();/?:@&amp=+$,#&quot))\newline        + QString(&quot\\n&quot);\newline  }\newline\newline  return text;\newline}\newline","\newline Emmulate GNU diff&#039s format.\newline Header: @@ -382,8 +481,9 @@\newline Indicies are printed as 1-based, not 0-based.\newline @return The GNU diff string\newline \newline","3466649","grid.c","static void rectEdge(double xmin, double ymin, double xmax, double ymax,\newline		     double theta,\newline		     double *edgex, double *edgey) \newline{\newline    double xm = (xmin + xmax)/2;\newline    double ym = (ymin + ymax)/2;\newline    double dx = (xmax - xmin)/2;\newline    double dy = (ymax - ymin)/2;\newline    /*\newline     * FIXME: Special case 0 width or 0 height\newline     */\newline    /*\newline     * Special case angles \newline     */\newline    if (theta == 0) {\newline	*edgex = xmax;\newline	*edgey = ym;\newline    } else if (theta == 270) {\newline	*edgex = xm;\newline	*edgey = ymin;\newline    } else if (theta == 180) {\newline	*edgex = xmin;\newline	*edgey = ym;\newline    } else if (theta == 90) {\newline	*edgex = xm;\newline	*edgey = ymax;\newline    } else {\newline	double cutoff = dy/dx;\newline	double angle = theta/180*M_PI;\newline	double tanTheta = tan(angle);\newline	double cosTheta = cos(angle);\newline	double sinTheta = sin(angle);\newline	if (fabs(tanTheta) &lt cutoff) { /* Intersect with side */\newline	    if (cosTheta &gt 0) { /* Right side */\newline		*edgex = xmax;\newline		*edgey = ym + tanTheta*dx;\newline	    } else { /* Left side */\newline		*edgex = xmin;\newline		*edgey = ym - tanTheta*dx;\newline	    }\newline	} else { /* Intersect with top/bottom */\newline	    if (sinTheta &gt 0) { /* Top */\newline		*edgey = ymax;\newline		*edgex = xm + dy/tanTheta;\newline	    } else { /* Bottom */\newline		*edgey = ymin;\newline		*edgex = xm - dy/tanTheta;\newline	    }\newline	}\newline    }\newline}\newline","\newline Calculate the point on the edge of a rectangle at angle theta\newline 0 = East, 180 = West, etc ...\newline Assumes that x- and y-values are in INCHES\newline Assumes that theta is within [0, 360)\newline \newline","12731","gci_execute.c","static GCI_result readTree( reader *rdr,\newline                            const GCI_nodeinfo *n )\newline{\newline   GCI_result rc;\newline   const GCI_parseinfo *info;\newline   unsigned i;\newline   unsigned shift = 0;\newline   int origlen = GCI_strlen( rdr-&gtbase );\newline\newline   info = &ampn-&gttype;\newline\newline   GCI_strcats( rdr-&gtbase, &quot.&quot );\newline   GCI_strcats( rdr-&gtbase, rdr-&gtprefix );\newline   if ( ( rc = GCI_strcats( rdr-&gtbase, &quotVALUE&quot ) ) != GCI_OK )\newline      return rc;\newline   if ( info-&gtindirect )\newline   {\newline      /*\newline       * This allows missing values. We have to try loading a value for arrays\newline       * and containers but should read strings directly to the target place to\newline       * prevent a slow double buffering. We assume to have values in most\newline       * cases.\newline       */\newline      switch ( info-&gttype )\newline      {\newline         case GCI_integer:\newline         case GCI_unsigned:\newline         case GCI_float:\newline         case GCI_char:\newline            if ( ( rc = readValue( rdr,\newline                                   info,\newline                                   n-&gtindirect_pos + rdr-&gtishift,\newline                                   1 ) ) != GCI_OK )\newline               return rc;\newline            if ( rdr-&gtnovalue )\newline            {\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            break;\newline\newline         case GCI_string:\newline         case GCI_raw:\newline            if ( ( rc = readString( rdr,\newline                                    info,\newline                                    n-&gtindirect_pos + rdr-&gtishift,\newline                                    1,\newline                                    ( info-&gttype == GCI_raw ) ) ) != GCI_OK )\newline               return rc;\newline            if ( rdr-&gtnovalue )\newline            {\newline               memset( rdr-&gtbasebuf + n-&gtindirect_pos + rdr-&gtishift,\newline                       0,\newline                       info-&gtsize + 1 );\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            break;\newline\newline         case GCI_container:\newline            rdr-&gtnovalue = 0;\newline            rc = GCI_readRexx( rdr-&gthidden,\newline                               rdr-&gtbase,\newline                               rdr-&gttmp,\newline                               0,\newline                               0,\newline                               &amprdr-&gtnovalue );\newline            if ( rdr-&gtnovalue )\newline            {\newline               GCI_strsetlen( rdr-&gtbase, origlen );\newline               return GCI_OK;\newline            }\newline            if ( rc != GCI_OK )\newline               return rc;\newline            if ( ( rc = GCI_string2bin( rdr-&gthidden,\newline                                        GCI_ccontent( rdr-&gttmp ),\newline                                        GCI_strlen( rdr-&gttmp ),\newline                                        &amprdr-&gtcount,\newline                                        sizeof( unsigned ),\newline                                        GCI_unsigned ) ) != GCI_OK )\newline               return rc;\newline            if ( info-&gtgenerated )\newline            {\newline               if ( rdr-&gtcount != rdr-&gtnodes[n-&gtchild].type.size )\newline                  return GCI_NumberRange;\newline            }\newline            else\newline            {\newline               if ( rdr-&gtcount != info-&gtsize )\newline                  return GCI_NumberRange;\newline            }\newline            break;\newline\newline         case GCI_array:\newline         default:\newline            return GCI_InternalError;\newline      }\newline\newline      assert( n-&gtdirect_pos + rdr-&gtdshift + sizeof( void* ) &lt= rdr-&gtmax );\newline      *((void **) (rdr-&gtbasebuf + n-&gtdirect_pos + rdr-&gtdshift)) =\newline                                  rdr-&gtbasebuf + n-&gtindirect_pos + rdr-&gtishift;\newline   }\newline   else\newline   {\newline      /*\newline       * The direct case, this is somewhat simpler, but we have do make special\newline       * considerations for GCI_string, too.\newline       */\newline      switch ( info-&gttype )\newline      {\newline         case GCI_integer:\newline         case GCI_unsigned:\newline         case GCI_float:\newline         case GCI_char:\newline            if ( ( rc = readValue( rdr,\newline                                   info,\newline                                   n-&gtdirect_pos + rdr-&gtdshift,\newline                                   0 ) ) != GCI_OK )\newline               return rc;\newline            break;\newline\newline         case GCI_string:\newline         case GCI_raw:\newline            if ( ( rc = readString( rdr,\newline                                    info,\newline                                    n-&gtdirect_pos + rdr-&gtdshift,\newline                                    0,\newline                                    ( info-&gttype == GCI_raw ) ) ) != GCI_OK )\newline               return rc;\newline            break;\newline\newline         case GCI_container:\newline         case GCI_array:\newline            break;\newline\newline         default:\newline            return GCI_InternalError;\newline      }\newline   }\newline\newline   GCI_strsetlen( rdr-&gtbase, origlen );\newline\newline   switch ( info-&gttype )\newline   {\newline      case GCI_integer:\newline      case GCI_unsigned:\newline      case GCI_float:\newline      case GCI_char:\newline      case GCI_string:\newline      case GCI_raw:\newline         return GCI_OK;\newline\newline      case GCI_container:\newline         if ( info-&gtindirect )\newline         {\newline            shift = rdr-&gtdshift;\newline            rdr-&gtdshift = rdr-&gtishift;\newline            rdr-&gtishift = 0;\newline         }\newline         n = rdr-&gtnodes + n-&gtchild;\newline         for ( i = 0; i &lt info-&gtsize; i++ )\newline         {\newline            assert( n &gt= rdr-&gtnodes );\newline            if ( info-&gtgenerated )\newline            {\newline               assert( info-&gtsize == 1 );\newline               assert( n-&gttype.type == GCI_array );\newline            }\newline            else\newline            {\newline               sprintf( rdr-&gthelper, &quot.%u&quot, i + 1 );\newline               if ( ( rc = GCI_strcats( rdr-&gtbase, rdr-&gthelper ) ) != GCI_OK )\newline                  return rc;\newline            }\newline\newline            if ( ( rc = readTree( rdr, n ) ) != GCI_OK )\newline               return rc;\newline\newline            GCI_strsetlen( rdr-&gtbase, origlen );\newline            n = rdr-&gtnodes + n-&gtsibling;\newline         }\newline         if ( info-&gtindirect )\newline         {\newline            rdr-&gtishift = rdr-&gtdshift;\newline            rdr-&gtdshift = shift;\newline         }\newline         return GCI_OK;\newline\newline      case GCI_array:\newline         assert( info-&gtindirect == 0 );\newline         assert( n-&gtchild &gt= 0 );\newline         assert( ( n-&gtdirect_size % info-&gtsize ) == 0 );\newline         assert( ( n-&gtindirect_size % info-&gtsize ) == 0);\newline         for ( i = 0; i &lt info-&gtsize; i++ )\newline         {\newline            sprintf( rdr-&gthelper, &quot.%u&quot, i + 1 );\newline            if ( ( rc = GCI_strcats( rdr-&gtbase, rdr-&gthelper ) ) != GCI_OK )\newline               return rc;\newline\newline            if ( ( rc = readTree( rdr, rdr-&gtnodes + n-&gtchild ) ) != GCI_OK )\newline               return rc;\newline\newline            GCI_strsetlen( rdr-&gtbase, origlen );\newline            rdr-&gtdshift += n-&gtdirect_size / info-&gtsize;\newline            rdr-&gtishift += n-&gtindirect_size / info-&gtsize;\newline         }\newline         rdr-&gtdshift -= n-&gtdirect_size;\newline         rdr-&gtishift -= n-&gtindirect_size;\newline         return GCI_OK;\newline\newline      default:\newline         break;\newline   }\newline   return GCI_InternalError;\newline}\newline","\newline readTree assigns all node values of a given tree recursively to the buffer\newline which shall hold the binary values.\newline \newline reader contains all variables useful for all or several leafs.\newline \newline n is the starting node within reader-&gtnodes.\newline \newline Return values:\newline GCI_OK: Everything is fine.\newline \newline In case of an error base will contain the\newline stem&#039s name where the problem raises first.\newline \newline GCI_UnsupportedType: Wrong type of input, e.g. FLOAT31 or the empty string\newline in a type description string. Another reason is an\newline internal error since the default sizes for &quotunsigned&quot\newline and &quotinteger&quot are not supported.\newline GCI_WrongInput: Strange characters occur in the input string as a\newline number.\newline GCI_NumberRange: Number to small or big to fit into the desired type\newline with the desired destbyte-size. This applies to the\newline different number type.\newline Another reason is a wrong value for indirected arrays\newline or containers.\newline GCI_StringRange: String too big for the defined buffer.\newline GCI_InternalError: Unexpected type for the base type.\newline GCI_RexxError: Strange return value by the interpreter.\newline \newline","1525170","gdw.cpp","void Gdw::buildCovList(bool pregStat)\newline{ \newline  if (interceptID.size())\newline    interceptID.clear();\newline\newline  VB_Vector tmpVec;\newline  int upRatio = TR / tmpResolve;\newline  for (uint32 i = 0; i &lt gMatrix.n; i++) {\newline    // If preG is valid, use it instead\newline    if (pregStat) {\newline      tmpVec = pregMatrix.GetColumn(i);\newline      VB_Vector *newVector = new VB_Vector(tmpVec);\newline      // record intercept index\newline      if (newVector-&gtgetVariance() &lt= 1e-15)\newline        interceptID.push_back(i);\newline      covList.push_back(newVector);\newline    }\newline    // Otherwise use G file\newline    else {\newline      tmpVec = gMatrix.GetColumn(i);\newline      VB_Vector *downVector = new VB_Vector(tmpVec);\newline      VB_Vector *newVector = upSampling(downVector, upRatio);\newline      if (newVector-&gtgetVariance() &lt= 1e-15)\newline        interceptID.push_back(i);\newline      covList.push_back(newVector);\newline      delete downVector;\newline    }\newline  }\newline}\newline","buildCovList() reads each column of gMatrix or pregMatrix (if available) into covList \newline","1271691","safe.c","int safe_unlink (const char *pathname)\newline{\newline  int dirfd;\newline\newline  dirfd = traverse_path (&amppathname);\newline  if (dirfd &lt 0 &amp&amp dirfd != AT_FDCWD)\newline    return dirfd;\newline  return unlinkat (dirfd, pathname, 0);\newline}\newline","Replacement for unlink() \newline","4476740","cpl_loader.c","int write_to_file(char *filename, str *buf)\newline{\newline	int fd;\newline	int ret;\newline\newline	fd = open(filename,O_WRONLY|O_CREAT|O_TRUNC,0644);\newline	if (!fd) {\newline		LM_ERR(&quotcannot open file : %s\\n&quot,\newline			strerror(errno));\newline		goto error;\newline	}\newline\newline	while ( (ret=write( fd, buf-&gts, buf-&gtlen))!=buf-&gtlen) {\newline		if ((ret==-1 &amp&amp errno!=EINTR)|| ret!=-1) {\newline			LM_ERR(&quotcannot write to file:&quot\newline				&quot%s write_ret=%d\\n&quot,strerror(errno), ret );\newline			goto error;\newline		}\newline	}\newline	close(fd);\newline\newline	return 0;\newlineerror:\newline	return -1;\newline}\newline","debug function -&gt write into a file the content of a str struct. \newline","2748849","pth_high.c","int pth_select(int nfds, fd_set *rfds, fd_set *wfds,\newline               fd_set *efds, struct timeval *timeout)\newline{\newline    return pth_select_ev(nfds, rfds, wfds, efds, timeout, NULL);\newline}\newline","Pth variant of select(2) \newline","2966524","tevent.c","void tevent_fd_set_close_fn(struct tevent_fd *fde,\newline			    tevent_fd_close_fn_t close_fn)\newline{\newline	if (!fde) return;\newline	if (!fde-&gtevent_ctx) return;\newline	fde-&gtevent_ctx-&gtops-&gtset_fd_close_fn(fde, close_fn);\newline}\newline","\newlineset a close function on the fd event\newline \newline","4405260","sqlite3.c","static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){\newline  assert( sqlite3_mutex_held(pPage-&gtpBt-&gtmutex) );\newline  assert( sqlite3PagerIswriteable(pPage-&gtpDbPage) );\newline  if( eType==PTRMAP_OVERFLOW2 ){\newline    /* The pointer is always the first 4 bytes of the page in this case.  */\newline    if( get4byte(pPage-&gtaData)!=iFrom ){\newline      return SQLITE_CORRUPT_BKPT;\newline    }\newline    put4byte(pPage-&gtaData, iTo);\newline  }else{\newline    u8 isInitOrig = pPage-&gtisInit;\newline    int i;\newline    int nCell;\newline    int rc;\newline\newline    rc = btreeInitPage(pPage);\newline    if( rc ) return rc;\newline    nCell = pPage-&gtnCell;\newline\newline    for(i=0; i&ltnCell; i++){\newline      u8 *pCell = findCell(pPage, i);\newline      if( eType==PTRMAP_OVERFLOW1 ){\newline        CellInfo info;\newline        pPage-&gtxParseCell(pPage, pCell, &ampinfo);\newline        if( info.nLocal&ltinfo.nPayload\newline         &amp&amp pCell+info.nSize-1&lt=pPage-&gtaData+pPage-&gtmaskPage\newline         &amp&amp iFrom==get4byte(pCell+info.nSize-4)\newline        ){\newline          put4byte(pCell+info.nSize-4, iTo);\newline          break;\newline        }\newline      }else{\newline        if( get4byte(pCell)==iFrom ){\newline          put4byte(pCell, iTo);\newline          break;\newline        }\newline      }\newline    }\newline  \newline    if( i==nCell ){\newline      if( eType!=PTRMAP_BTREE || \newline          get4byte(&amppPage-&gtaData[pPage-&gthdrOffset+8])!=iFrom ){\newline        return SQLITE_CORRUPT_BKPT;\newline      }\newline      put4byte(&amppPage-&gtaData[pPage-&gthdrOffset+8], iTo);\newline    }\newline\newline    pPage-&gtisInit = isInitOrig;\newline  }\newline  return SQLITE_OK;\newline}\newline","\newline Somewhere on pPage is a pointer to page iFrom. Modify this pointer so\newline that it points to iTo. Parameter eType describes the type of pointer to\newline be modified, as follows:\newline \newline PTRMAP_BTREE: pPage is a btree-page. The pointer points at a child \newline page of pPage.\newline \newline PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow\newline page pointed to by one of the cells on pPage.\newline \newline PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next\newline overflow page in the list.\newline \newline","5792503","simple_fold.c","wchar_t unicode_simple_fold(wchar_t wc)\newline{\newline	if ((wc &gt= 0) &amp&amp (wc &lt 0x10000))\newline	{\newline		const uint16_t *p = pages[wc &gt&gt 8];\newline		if (p) wc = (wchar_t) p[wc &amp 0xFF];\newline	}\newline	else if ((wc &gt= 0x10400) &amp&amp (wc &lt= 0x10427)) wc += 0x28;\newline	return wc;\newline}\newline","\newline \\brief Simple case folding of a wide character.\newline \\param wc the wide character to fold.\newline \\return If a simple folding is defined, the folded version of \\c wc\newline is returned, otherwise \\c wc is returned unchanged.\newline \\remarks This function performs simple case folding using two\newline accesses in large lookup tables.\newline \newline Case folding provides a mapping between characters that only differ\newline in case. This is useful for case insensitive comparison. Simple case\newline folding maps a single wide character to another single wide character\newline (usually lower case). Full case folding, instead, may map a single\newline wide character to more wide characters.\newline \newline","4765200","xhfc.c","static unsigned char hfc_readcounter8(struct b400m *b4, const unsigned int reg)\newline{\newline	unsigned char r1, r2;\newline	unsigned long maxwait = 1048576;\newline\newline	do {\newline		r1 = b400m_getreg(b4, reg);\newline		r2 = b400m_getreg(b4, reg);\newline	} while ((r1 != r2) &amp&amp maxwait--);\newline\newline	if (!maxwait) {\newline		if (printk_ratelimit()) {\newline			dev_warn(&ampb4-&gtwc-&gtvb.pdev-&gtdev,\newline				 &quothfc_readcounter8(reg 0x%02x) timed out &quot \\\newline				 &quotwaiting for data to settle!\\n&quot, reg);\newline		}\newline	}\newline\newline	return r1;\newline}\newline","\newline reads an 8-bit register over over and over until the same value is read\newline twice, then returns that value.\newline \newline","","","","","","","on","","on","","","on","","","","","","","","on","","","on","","","","","","","","","","","","on","","","","","","","","Constructs a CrossTabEditor","schedule them for PV header update.","Emmulate GNU diff's format.","Calculate the point on the edge of a rectangle at angle theta","assigns all node values of a given tree recursively to the buffer","reads each column of gMatrix or pregMatrix","{}","write into a file the content of a str struct.","{}","set a close function","Modify this pointer sothat it points to iTo.","{}","case folding of a wide character.","reads an 8-bit register over over and over","find and process preprocessor directive in passed line","Returns the configuration category name for thespecified configuration category id.","Generates a random challenge,","erase all history of past violations.","check for devices","{}","Add a sequence to an array."
"335VBRURDJ0OCA7TW18Z4ZUI6TPE94","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3GNCZX450IN8143HNN7BJP0V66CPAM","AVC62JNYAXA45","Approved","Wed Apr 17 14:20:43 PDT 2019","Wed Apr 17 14:55:33 PDT 2019","Fri Apr 19 14:55:33 PDT 2019","2019-04-19 21:56:21 UTC","","","2090","100% (24/24)","100% (24/24)","100% (24/24)","2494178","telepathy-tls.c","static void foreach_channel(TpChannelManager *manager,\newline			    TpExportableChannelFunc func,\newline			    gpointer user_data)\newline{\newline	SipeTLSManager *self = SIPE_TLS_MANAGER(manager);\newline	GSList *entry;\newline\newline	SIPE_DEBUG_INFO_NOFORMAT(&quotSipeTLSManager::foreach_channel&quot);\newline\newline	for (entry = self-&gtchannels; entry; entry = entry-&gtnext)\newline		func(entry-&gtdata, user_data);\newline}\newline","\newline TLS Manager class - interface implementation\newline \newline Channel Manager\newline \newline","5964632","tlv.c","faim_internal void aim_tlvlist_remove(aim_tlvlist_t **list, const fu16_t type)\newline{\newline	aim_tlvlist_t *del;\newline\newline	if (!list || !(*list))\newline		return;\newline\newline	/* Remove the item from the list */\newline	if ((*list)-&gttlv-&gttype == type) {\newline		del = *list;\newline		*list = (*list)-&gtnext;\newline	} else {\newline		aim_tlvlist_t *cur;\newline		for (cur=*list; (cur-&gtnext &amp&amp (cur-&gtnext-&gttlv-&gttype!=type)); cur=cur-&gtnext);\newline		if (!cur-&gtnext)\newline			return;\newline		del = cur-&gtnext;\newline		cur-&gtnext = del-&gtnext;\newline	}\newline\newline	/* Free the removed item */\newline	free(del-&gttlv-&gtvalue);\newline	free(del-&gttlv);\newline	free(del);\newline}\newline","\newline Remove a TLV of a given type. If you attempt to remove a TLV that \newline does not exist, nothing happens.\newline \newline @param list Desination chain (%NULL pointer if empty).\newline @param type TLV type.\newline \newline","770678","lpeg.c","static int jointable (lua_State *L, int p1) {\newline  int n, n1, i;\newline  lua_getfenv(L, p1);\newline  n1 = ktablelen(L, -1);  /* number of elements in p1&#039s env */\newline  lua_getfenv(L, -2);\newline  if (n1 == 0 || lua_equal(L, -2, -1)) {\newline    lua_pop(L, 2);\newline    return 0;  /* no need to change anything */\newline  }\newline  n = ktablelen(L, -1);  /* number of elements in p&#039s env */\newline  if (n == 0) {\newline    lua_pop(L, 1);  /* removes p env */\newline    lua_setfenv(L, -2);  /* p now shares p1&#039s env */\newline    return 0;  /* no need to correct anything */\newline  }\newline  lua_createtable(L, n + n1, 0);\newline  /* stack: p; p1 env; p env; new p env */\newline  for (i = 1; i &lt= n; i++) {\newline    lua_rawgeti(L, -2, i);\newline    lua_rawseti(L, -2, i);\newline  }\newline  for (i = 1; i &lt= n1; i++) {\newline    lua_rawgeti(L, -3, i);\newline    lua_rawseti(L, -2, n + i);\newline  }\newline  lua_setfenv(L, -4);  /* new table becomes p env */\newline  lua_pop(L, 2);  /* remove p1 env and old p env */\newline  return n;\newline}\newline","\newline join the elements of the ktable from pattern &#039p1&#039 into the ktable of\newline the pattern at the top of the stack (&#039p&#039). If &#039p1&#039 has no elements,\newline &#039p&#039 keeps its original ktable. If &#039p&#039 has no elements, it shares\newline &#039p1&#039 ktable. Otherwise, this function creates a new ktable for &#039p&#039.\newline Return the offset of original &#039p&#039 elements in the new ktable.\newline \newline","286860","cmd.c","int cmd_track_pid(struct ltt_session *session, enum lttng_domain_type domain,\newline		int pid)\newline{\newline	int ret;\newline\newline	rcu_read_lock();\newline\newline	switch (domain) {\newline	case LTTNG_DOMAIN_KERNEL:\newline	{\newline		struct ltt_kernel_session *ksess;\newline\newline		ksess = session-&gtkernel_session;\newline\newline		ret = kernel_track_pid(ksess, pid);\newline		if (ret != LTTNG_OK) {\newline			goto error;\newline		}\newline\newline		kernel_wait_quiescent(kernel_tracer_fd);\newline		break;\newline	}\newline	case LTTNG_DOMAIN_UST:\newline	{\newline		struct ltt_ust_session *usess;\newline\newline		usess = session-&gtust_session;\newline\newline		ret = trace_ust_track_pid(usess, pid);\newline		if (ret != LTTNG_OK) {\newline			goto error;\newline		}\newline		break;\newline	}\newline	default:\newline		ret = LTTNG_ERR_UNKNOWN_DOMAIN;\newline		goto error;\newline	}\newline\newline	ret = LTTNG_OK;\newline\newlineerror:\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Command LTTNG_TRACK_PID processed by the client thread.\newline \newline Called with session lock held.\newline \newline","287649","ust-consumer.c","static void destroy_channel(struct lttng_consumer_channel *channel)\newline{\newline	struct lttng_consumer_stream *stream, *stmp;\newline\newline	assert(channel);\newline\newline	DBG(&quotUST consumer cleaning stream list&quot);\newline\newline	cds_list_for_each_entry_safe(stream, stmp, &ampchannel-&gtstreams.head,\newline			send_node) {\newline\newline		health_code_update();\newline\newline		cds_list_del(&ampstream-&gtsend_node);\newline		ustctl_destroy_stream(stream-&gtustream);\newline		free(stream);\newline	}\newline\newline	/*\newline	 * If a channel is available meaning that was created before the streams\newline	 * were, delete it.\newline	 */\newline	if (channel-&gtuchan) {\newline		lttng_ustconsumer_del_channel(channel);\newline		lttng_ustconsumer_free_channel(channel);\newline	}\newline	free(channel);\newline}\newline","\newline Free channel object and all streams associated with it. This MUST be used\newline only and only if the channel has _NEVER_ been added to the global channel\newline hash table.\newline \newline","4943029","column.c","int scols_column_is_wrap(const struct libscols_column *cl)\newline{\newline	return cl-&gtflags &amp SCOLS_FL_WRAP ? 1 : 0;\newline}\newline","\newline scols_column_is_wrap:\newline @cl: a pointer to a struct libscols_column instance\newline \newline Gets the value of @cl&#039s flag wrap.\newline \newline Returns: 0 or 1\newline \newline Since: 2.28\newline \newline","3599397","utilities.c","static void add_module_to_prayerlist_folder(GtkTreeModel *model,\newline					    GtkTreeIter iter,\newline					    gchar *module_name)\newline{\newline\newline	GtkTreeIter child_iter;\newline\newline	gtk_tree_store_append(GTK_TREE_STORE(model), &ampchild_iter, &ampiter);\newline	gtk_tree_store_set(GTK_TREE_STORE(model), &ampchild_iter,\newline			   0, module_name, -1);\newline}\newline","\newline Name\newline add_module_to_prayerlist_folder\newline \newline Synopsis\newline #include &quotmain/sidebar.h&quot\newline \newline void add_module_to_prayerlist_folder(GtkTreeModel model,\newline GtkTreeIter iter, gchar module_name)\newline \newline Description\newline \newline \newline Return value\newline void\newline \newline","4132536","server.c","lscp_status_t lscp_server_broadcast ( lscp_server_t *pServer, lscp_event_t event, const char *pchData, int cchData )\newline{\newline	lscp_connect_t *p;\newline	const char *pszEvent;\newline	char  achBuffer[LSCP_BUFSIZ];\newline	int   cchBuffer;\newline\newline	if (pServer == NULL)\newline		return LSCP_FAILED;\newline	if (pchData == NULL || cchData &lt 1)\newline		return LSCP_FAILED;\newline\newline	// Which (single) event?\newline	pszEvent = lscp_event_to_text(event);\newline	if (pszEvent == NULL)\newline		return LSCP_FAILED;\newline\newline	// Build the event message string...\newline	cchBuffer = sprintf(achBuffer, &quotNOTIFY:%s:&quot, pszEvent);\newline	if (pchData) {\newline		if (cchData &gt LSCP_BUFSIZ - cchBuffer - 2)\newline			cchData = LSCP_BUFSIZ - cchBuffer - 2;\newline		strncpy(&ampachBuffer[cchBuffer], pchData, cchData);\newline		cchBuffer += cchData;\newline	}\newline	achBuffer[cchBuffer++] = &#039\\r&#039;\newline	achBuffer[cchBuffer++] = &#039\\n&#039;\newline\newline	// And do the direct broadcasting...\newline	\newline	lscp_mutex_lock(pServer-&gtconnects.mutex);\newline\newline	for (p = pServer-&gtconnects.first; p; p = p-&gtnext) {\newline		if (p-&gtevents &amp event)\newline			send(p-&gtclient.sock, achBuffer, cchBuffer, 0);\newline	}\newline\newline	lscp_mutex_unlock(pServer-&gtconnects.mutex);\newline\newline	return LSCP_OK;\newline}\newline","\newline Send an event notification message to all subscribed clients.\newline \newline @param pServer Pointer to server instance structure.\newline @param event Event type flag to send to all subscribed clients.\newline @param pchData Pointer to event data to be sent to all clients.\newline @param cchData Length of the event data to be sent in bytes.\newline \newline @returns LSCP_OK on success, LSCP_FAILED otherwise.\newline \newline","3130533","msg_renderers.c","int summcmp_rsender(const void *s1, const void *s2) {\newline	message_summary *summ1;\newline	message_summary *summ2;\newline	\newline	summ1 = (message_summary *)GetSearchPayload(s1);\newline	summ2 = (message_summary *)GetSearchPayload(s2);\newline	return strcasecmp(ChrPtr(summ2-&gtfrom), ChrPtr(summ1-&gtfrom));\newline}\newline","\newline comparator for message summary structs by descending sender.\newline \newline","4500528","mooproxy.c","static void print_help_text( void )\newline{\newline	printf( &quotMooproxy - a buffering proxy for MOO connections\\n&quot\newline	&quotCopyright (C) %s Marcel L. Moreaux &ltmarcelm@qvdr.net&gt\\n&quot\newline	&quot\\n&quot\newline	&quotUsage: mooproxy [options]\\n&quot\newline	&quot\\n&quot\newline	&quot  -h, --help        shows this help screen and exits\\n&quot\newline	&quot  -V, --version     shows version information and exits\\n&quot\newline	&quot  -L, --license     shows licensing information and exits\\n&quot\newline	&quot  -w, --world       world to load\\n&quot\newline	&quot  -d, --no-daemon   forces mooproxy to stay in the foreground\\n&quot\newline	&quot  -m, --md5crypt    prompts for a string to create an md5 hash of\\n&quot\newline	&quot\\n&quot\newline	&quotReleased under the GPL v2, report bugs to &ltmarcelm@qvdr.net&gt\\n&quot\newline	&quotMooproxy comes with ABSOLUTELY NO WARRANTY; &quot\newline	&quotfor details run mooproxy --license\\n&quot,\newline	COPYYEARS );\newline}\newline","Print the help output (-h, --help) \newline","5687784","ne_openssl.c","static char *dup_ia5string(const ASN1_IA5STRING *as)\newline{\newline    return ne_strnqdup(as-&gtdata, as-&gtlength);\newline}\newline","Returns a malloc-allocated version of IA5 string AS, escaped for\newline safety. \newline","4226552","bitmap.c","static int convert_ARGB(guiImage *img)\newline{\newline    unsigned char *orgImage;\newline    unsigned int i, c;\newline\newline    if (img-&gtBpp == 24) {\newline        orgImage = img-&gtImage;\newline\newline        img-&gtBpp       = 32;\newline        img-&gtImageSize = img-&gtWidth * img-&gtHeight * 4;\newline        img-&gtImage     = calloc(1, img-&gtImageSize);\newline\newline        if (!img-&gtImage) {\newline            free(orgImage);\newline            mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] not enough memory: %u\\n&quot, img-&gtImageSize);\newline            return False;\newline        }\newline\newline        mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] 32 bpp conversion size: %u\\n&quot, img-&gtImageSize);\newline\newline        for (i = 0, c = 0; i &lt img-&gtImageSize; i += 4, c += 3)\newline            *(uint32_t *)&ampimg-&gtImage[i] = ALPHA_OPAQUE | AV_RB24(&amporgImage[c]);\newline\newline        free(orgImage);\newline    } else if (img-&gtBpp == 32) {\newline        mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] 32 bpp ARGB conversion\\n&quot);\newline\newline        for (i = 0; i &lt img-&gtImageSize; i += 4)\newline            *(uint32_t *)&ampimg-&gtImage[i] = (img-&gtImage[i + 3] &lt&lt 24) | AV_RB24(&ampimg-&gtImage[i]);\newline    } else\newline        return False;\newline\newline    return True;\newline}\newline","\newline @brief Convert a 24-bit RGB or 32-bit RGBA image into a 32-bit ARGB image.\newline \newline @param img image to be converted\newline \newline @return #True (ok) or #False (error)\newline \newline @note This is an in-place conversion,\newline new memory will be allocated for @a img if necessary.\newline \newline","407571","libusb-utils.c","int init_usb(libusb_context *ctx) {\newline  int result;\newline\newline  result = libusb_init(&ampctx); //initialize the library for the session\newline  \newline  if (result &lt LIBUSB_SUCCESS) {\newline    \newline#ifdef DEBUG\newline\newline    printf(&quotInit Error: %d\\n&quot, result);\newline\newline#endif\newline\newline    return USB_FAILURE;\newline  }\newline\newline#ifdef DEBUG\newline\newline#if (HOST_OS == LINUX)\newline\newline  libusb_set_debug(ctx, 4); //set verbosity level to 4\newline\newline#elif (HOST_OS == FREEBSD)\newline\newline  libusb_set_debug(ctx, 1); //set verbosity level to 1\newline\newline#endif\newline\newline#endif\newline\newline  return USB_SUCCESS;\newline}\newline","\newline Initializes libusb.\newline \newline Returns USB_SUCCESS or USB_FAILURE.\newline \newline","6550419","gkrelluim.c","static gint panel_expose_event( GtkWidget *widget, GdkEventExpose *ev ) {\newline  gdk_draw_pixmap( widget-&gtwindow,\newline    widget-&gtstyle-&gtfg_gc[ GTK_WIDGET_STATE( widget ) ],\newline    panel-&gtpixmap, ev-&gtarea.x, ev-&gtarea.y, ev-&gtarea.x, ev-&gtarea.y,\newline    ev-&gtarea.width, ev-&gtarea.height );\newline  return FALSE;\newline}\newline","\newline taken from gkrellm2-demos/demo2.c\newline \newline","5692844","test_bus.c","int  test_sysfs_close_bus(int flag)\newline{\newline	struct sysfs_bus *bus = NULL;\newline	char *bus_name = NULL;\newline\newline	switch (flag) {\newline	case 0:\newline		bus_name = val_bus_name;\newline		bus = sysfs_open_bus(bus_name);\newline		if (bus == NULL) {\newline			dbg_print(&quot%s: sysfs_open_bus() failed\\n&quot,__FUNCTION__);\newline			return 0;\newline		}\newline		break;\newline	case 1:\newline		bus = NULL;\newline		break;\newline	default:\newline		return -1;\newline	}\newline	sysfs_close_bus(bus);\newline\newline	dbg_print(&quot%s: returns void\\n&quot, __FUNCTION__);\newline	return 0;\newline}\newline","\newline extern void sysfs_close_bus(struct sysfs_bus bus);\newline \newline flags:\newline 0 -&gt bus -&gt valid\newline 1 -&gt bus -&gt null.\newline \newline","4102148","tag.c","int tag_insert(\newline  const char *zTag,        /* Name of the tag (w/o the &quot+&quot or &quot-&quot prefix */\newline  int tagtype,             /* 0:cancel  1:singleton  2:propagated */\newline  const char *zValue,      /* Value if the tag is really a property */\newline  int srcId,               /* Artifact that contains this tag */\newline  double mtime,            /* Timestamp.  Use default if &lt=0.0 */\newline  int rid                  /* Artifact to which the tag is to attached */\newline){\newline  Stmt s;\newline  const char *zCol;\newline  int tagid = tag_findid(zTag, 1);\newline  int rc;\newline\newline  if( mtime&lt=0.0 ){\newline    mtime = db_double(0.0, &quotSELECT julianday(&#039now&#039)&quot);\newline  }\newline  db_prepare(&amps,\newline    &quotSELECT 1 FROM tagxref&quot\newline    &quot WHERE tagid=%d&quot\newline    &quot   AND rid=%d&quot\newline    &quot   AND mtime&gt=:mtime&quot,\newline    tagid, rid\newline  );\newline  db_bind_double(&amps, &quot:mtime&quot, mtime);\newline  rc = db_step(&amps);\newline  db_finalize(&amps);\newline  if( rc==SQLITE_ROW ){\newline    /* Another entry that is more recent already exists.  Do nothing */\newline    return tagid;\newline  }\newline  db_prepare(&amps,\newline    &quotREPLACE INTO tagxref(tagid,tagtype,srcId,origid,value,mtime,rid)&quot\newline    &quot VALUES(%d,%d,%d,%d,%Q,:mtime,%d)&quot,\newline    tagid, tagtype, srcId, rid, zValue, rid\newline  );\newline  db_bind_double(&amps, &quot:mtime&quot, mtime);\newline  db_step(&amps);\newline  db_finalize(&amps);\newline  if( tagid==TAG_BRANCH ) leaf_eventually_check(rid);\newline  if( tagtype==0 ){\newline    zValue = 0;\newline  }\newline  zCol = 0;\newline  switch( tagid ){\newline    case TAG_BGCOLOR: {\newline      zCol = &quotbgcolor&quot;\newline      break;\newline    }\newline    case TAG_COMMENT: {\newline      zCol = &quotecomment&quot;\newline      break;\newline    }\newline    case TAG_USER: {\newline      zCol = &quoteuser&quot;\newline      break;\newline    }\newline    case TAG_PRIVATE: {\newline      db_multi_exec(\newline        &quotINSERT OR IGNORE INTO private(rid) VALUES(%d);&quot,\newline        rid\newline      );\newline    }\newline  }\newline  if( zCol ){\newline    db_multi_exec(&quotUPDATE event SET \\&quot%w\\&quot=%Q WHERE objid=%d&quot,\newline                  zCol, zValue, rid);\newline    if( tagid==TAG_COMMENT ){\newline      char *zCopy = mprintf(&quot%s&quot, zValue);\newline      wiki_extract_links(zCopy, rid, 0, mtime, 1, WIKI_INLINE);\newline      free(zCopy);\newline    }\newline  }\newline  if( tagid==TAG_DATE ){\newline    db_multi_exec(&quotUPDATE event &quot\newline                  &quot   SET mtime=julianday(%Q),&quot\newline                  &quot       omtime=coalesce(omtime,mtime)&quot\newline                  &quot WHERE objid=%d&quot,\newline                  zValue, rid);\newline  }\newline  if( tagid==TAG_PARENT &amp&amp tagtype==1 ){\newline    manifest_reparent_checkin(rid, zValue);\newline  }\newline  if( tagtype==1 ) tagtype = 0;\newline  tag_propagate(rid, tagid, tagtype, rid, zValue, mtime);\newline  return tagid;\newline}\newline","\newline Insert a tag into the database.\newline \newline Also translate zTag into a tagid and return the tagid. (In other words\newline if zTag is &quotbgcolor&quot then return TAG_BGCOLOR.)\newline \newline","6629709","uuid_dce.c","void uuid_dce_create_nil(uuid_dce_t *uuid_dce, int *status)\newline{\newline    /* initialize status */\newline    if (status != NULL)\newline        *status = uuid_s_error;\newline\newline    /* sanity check argument(s) */\newline    if (uuid_dce == NULL)\newline        return;\newline\newline    /* short-circuit implementation, because Nil UUID is trivial to\newline       create, so no need to use regular OSSP uuid API */\newline    memset(uuid_dce, 0, UUID_LEN_BIN);\newline\newline    /* return successfully */\newline    if (status != NULL)\newline        *status = uuid_s_ok;\newline    return;\newline}\newline","create a Nil UUID \newline","2907458","gtk-ui.c","static void make_settings_ui(GtkWidget *vbox)\newline{\newline    GtkWidget *fbox;\newline    GtkWidget *frame;\newline\newline    frame = gtk_frame_new(_(&quotDefault OTR Settings&quot));\newline    gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, FALSE, 0);\newline\newline    fbox = gtk_vbox_new(FALSE, 0);\newline    gtk_container_set_border_width(GTK_CONTAINER(fbox), 10);\newline    gtk_container_add(GTK_CONTAINER(frame), fbox);\newline\newline    create_otrsettings_buttons(&amp(ui_layout.os), fbox);\newline\newline    load_otrsettings(&amp(ui_layout.os));\newline\newline    g_signal_connect(G_OBJECT(ui_layout.os.enablebox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.automaticbox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.onlyprivatebox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.avoidloggingotrbox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline}\newline","Make the settings UI, and pack it into the vbox \newline","1626060","cfgfile.c","const int *getJP2KCSamplingRGBA (int width, int height)\newline{\newline	int imgcat;\newline\newline	imgcat = getImgSizeCategory (width, height);\newline\newline	return (JP2CSamplingRGBA + (16 * imgcat));\newline}\newline","return a pointer to a array[16] with the components&#039 sampling parameters JP2K RGBA components \newline","6061729","imagescalertest.cpp","void ImageScalerTest::testDontCrashWithoutImage()\newline{\newline    Gwenview::ImageScaler scaler;\newline    scaler.setZoom(1.0);\newline    scaler.setDestinationRegion(QRect(0, 0, 10, 10));\newline}\newline","\newline Test instantiating a scaler without setting an image won&#039t crash\newline \newline","1471463","plugin.c","static void usage_controller_onResourceAppearing_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {\newline	usage_controller_onResourceAppearingData* _data_;\newline	_data_ = _user_data_;\newline	_data_-&gt_source_object_ = source_object;\newline	_data_-&gt_res_ = _res_;\newline	usage_controller_onResourceAppearing_co (_data_);\newline}\newline","\newline Handle a resource appearing on the bus. This will send out a notification and\newline enable or disables the resource depending on which debug option is set.\newline \newline","on","","","","","on","on","","","","","","","","","on","","","on","","","","","","on","","","","on","","","","","","","on","","","","","","","{}","Print the help output","Returns a malloc-allocated version of IA5 string","Convert a 24-bit RGB or 32-bit RGBA image","Initializes libusb.","{}","{}","Insert a tag into the database.","create a Nil UUID","Make the settings UI, and pack it into the vbox","return a pointer to a array[16] with the components' sampling parameters","Remove a TLV of a given type.","Test instantiating a scaler without setting an image","send out a notification andenable or disables the resource","join the elements of the ktable from pattern 'p1'","{}","Free channel object and all streams associated with it.","Gets the value of @cl's flag wrap.","{}","Send an event notification message to all subscribed clients.","comparator for message summary structs"
"335VBRURDJ0OCA7TW18Z4ZUI6TPE94","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3WQ3B2KGE8GA3MP78ZWHD423L841B2","A1NV81QEC0GDG7","Approved","Wed Apr 17 15:09:55 PDT 2019","Wed Apr 17 15:16:05 PDT 2019","Fri Apr 19 15:16:05 PDT 2019","2019-04-19 22:16:21 UTC","","","370","100% (5/5)","100% (5/5)","100% (5/5)","2494178","telepathy-tls.c","static void foreach_channel(TpChannelManager *manager,\newline			    TpExportableChannelFunc func,\newline			    gpointer user_data)\newline{\newline	SipeTLSManager *self = SIPE_TLS_MANAGER(manager);\newline	GSList *entry;\newline\newline	SIPE_DEBUG_INFO_NOFORMAT(&quotSipeTLSManager::foreach_channel&quot);\newline\newline	for (entry = self-&gtchannels; entry; entry = entry-&gtnext)\newline		func(entry-&gtdata, user_data);\newline}\newline","\newline TLS Manager class - interface implementation\newline \newline Channel Manager\newline \newline","5964632","tlv.c","faim_internal void aim_tlvlist_remove(aim_tlvlist_t **list, const fu16_t type)\newline{\newline	aim_tlvlist_t *del;\newline\newline	if (!list || !(*list))\newline		return;\newline\newline	/* Remove the item from the list */\newline	if ((*list)-&gttlv-&gttype == type) {\newline		del = *list;\newline		*list = (*list)-&gtnext;\newline	} else {\newline		aim_tlvlist_t *cur;\newline		for (cur=*list; (cur-&gtnext &amp&amp (cur-&gtnext-&gttlv-&gttype!=type)); cur=cur-&gtnext);\newline		if (!cur-&gtnext)\newline			return;\newline		del = cur-&gtnext;\newline		cur-&gtnext = del-&gtnext;\newline	}\newline\newline	/* Free the removed item */\newline	free(del-&gttlv-&gtvalue);\newline	free(del-&gttlv);\newline	free(del);\newline}\newline","\newline Remove a TLV of a given type. If you attempt to remove a TLV that \newline does not exist, nothing happens.\newline \newline @param list Desination chain (%NULL pointer if empty).\newline @param type TLV type.\newline \newline","770678","lpeg.c","static int jointable (lua_State *L, int p1) {\newline  int n, n1, i;\newline  lua_getfenv(L, p1);\newline  n1 = ktablelen(L, -1);  /* number of elements in p1&#039s env */\newline  lua_getfenv(L, -2);\newline  if (n1 == 0 || lua_equal(L, -2, -1)) {\newline    lua_pop(L, 2);\newline    return 0;  /* no need to change anything */\newline  }\newline  n = ktablelen(L, -1);  /* number of elements in p&#039s env */\newline  if (n == 0) {\newline    lua_pop(L, 1);  /* removes p env */\newline    lua_setfenv(L, -2);  /* p now shares p1&#039s env */\newline    return 0;  /* no need to correct anything */\newline  }\newline  lua_createtable(L, n + n1, 0);\newline  /* stack: p; p1 env; p env; new p env */\newline  for (i = 1; i &lt= n; i++) {\newline    lua_rawgeti(L, -2, i);\newline    lua_rawseti(L, -2, i);\newline  }\newline  for (i = 1; i &lt= n1; i++) {\newline    lua_rawgeti(L, -3, i);\newline    lua_rawseti(L, -2, n + i);\newline  }\newline  lua_setfenv(L, -4);  /* new table becomes p env */\newline  lua_pop(L, 2);  /* remove p1 env and old p env */\newline  return n;\newline}\newline","\newline join the elements of the ktable from pattern &#039p1&#039 into the ktable of\newline the pattern at the top of the stack (&#039p&#039). If &#039p1&#039 has no elements,\newline &#039p&#039 keeps its original ktable. If &#039p&#039 has no elements, it shares\newline &#039p1&#039 ktable. Otherwise, this function creates a new ktable for &#039p&#039.\newline Return the offset of original &#039p&#039 elements in the new ktable.\newline \newline","286860","cmd.c","int cmd_track_pid(struct ltt_session *session, enum lttng_domain_type domain,\newline		int pid)\newline{\newline	int ret;\newline\newline	rcu_read_lock();\newline\newline	switch (domain) {\newline	case LTTNG_DOMAIN_KERNEL:\newline	{\newline		struct ltt_kernel_session *ksess;\newline\newline		ksess = session-&gtkernel_session;\newline\newline		ret = kernel_track_pid(ksess, pid);\newline		if (ret != LTTNG_OK) {\newline			goto error;\newline		}\newline\newline		kernel_wait_quiescent(kernel_tracer_fd);\newline		break;\newline	}\newline	case LTTNG_DOMAIN_UST:\newline	{\newline		struct ltt_ust_session *usess;\newline\newline		usess = session-&gtust_session;\newline\newline		ret = trace_ust_track_pid(usess, pid);\newline		if (ret != LTTNG_OK) {\newline			goto error;\newline		}\newline		break;\newline	}\newline	default:\newline		ret = LTTNG_ERR_UNKNOWN_DOMAIN;\newline		goto error;\newline	}\newline\newline	ret = LTTNG_OK;\newline\newlineerror:\newline	rcu_read_unlock();\newline	return ret;\newline}\newline","\newline Command LTTNG_TRACK_PID processed by the client thread.\newline \newline Called with session lock held.\newline \newline","287649","ust-consumer.c","static void destroy_channel(struct lttng_consumer_channel *channel)\newline{\newline	struct lttng_consumer_stream *stream, *stmp;\newline\newline	assert(channel);\newline\newline	DBG(&quotUST consumer cleaning stream list&quot);\newline\newline	cds_list_for_each_entry_safe(stream, stmp, &ampchannel-&gtstreams.head,\newline			send_node) {\newline\newline		health_code_update();\newline\newline		cds_list_del(&ampstream-&gtsend_node);\newline		ustctl_destroy_stream(stream-&gtustream);\newline		free(stream);\newline	}\newline\newline	/*\newline	 * If a channel is available meaning that was created before the streams\newline	 * were, delete it.\newline	 */\newline	if (channel-&gtuchan) {\newline		lttng_ustconsumer_del_channel(channel);\newline		lttng_ustconsumer_free_channel(channel);\newline	}\newline	free(channel);\newline}\newline","\newline Free channel object and all streams associated with it. This MUST be used\newline only and only if the channel has _NEVER_ been added to the global channel\newline hash table.\newline \newline","4943029","column.c","int scols_column_is_wrap(const struct libscols_column *cl)\newline{\newline	return cl-&gtflags &amp SCOLS_FL_WRAP ? 1 : 0;\newline}\newline","\newline scols_column_is_wrap:\newline @cl: a pointer to a struct libscols_column instance\newline \newline Gets the value of @cl&#039s flag wrap.\newline \newline Returns: 0 or 1\newline \newline Since: 2.28\newline \newline","3599397","utilities.c","static void add_module_to_prayerlist_folder(GtkTreeModel *model,\newline					    GtkTreeIter iter,\newline					    gchar *module_name)\newline{\newline\newline	GtkTreeIter child_iter;\newline\newline	gtk_tree_store_append(GTK_TREE_STORE(model), &ampchild_iter, &ampiter);\newline	gtk_tree_store_set(GTK_TREE_STORE(model), &ampchild_iter,\newline			   0, module_name, -1);\newline}\newline","\newline Name\newline add_module_to_prayerlist_folder\newline \newline Synopsis\newline #include &quotmain/sidebar.h&quot\newline \newline void add_module_to_prayerlist_folder(GtkTreeModel model,\newline GtkTreeIter iter, gchar module_name)\newline \newline Description\newline \newline \newline Return value\newline void\newline \newline","4132536","server.c","lscp_status_t lscp_server_broadcast ( lscp_server_t *pServer, lscp_event_t event, const char *pchData, int cchData )\newline{\newline	lscp_connect_t *p;\newline	const char *pszEvent;\newline	char  achBuffer[LSCP_BUFSIZ];\newline	int   cchBuffer;\newline\newline	if (pServer == NULL)\newline		return LSCP_FAILED;\newline	if (pchData == NULL || cchData &lt 1)\newline		return LSCP_FAILED;\newline\newline	// Which (single) event?\newline	pszEvent = lscp_event_to_text(event);\newline	if (pszEvent == NULL)\newline		return LSCP_FAILED;\newline\newline	// Build the event message string...\newline	cchBuffer = sprintf(achBuffer, &quotNOTIFY:%s:&quot, pszEvent);\newline	if (pchData) {\newline		if (cchData &gt LSCP_BUFSIZ - cchBuffer - 2)\newline			cchData = LSCP_BUFSIZ - cchBuffer - 2;\newline		strncpy(&ampachBuffer[cchBuffer], pchData, cchData);\newline		cchBuffer += cchData;\newline	}\newline	achBuffer[cchBuffer++] = &#039\\r&#039;\newline	achBuffer[cchBuffer++] = &#039\\n&#039;\newline\newline	// And do the direct broadcasting...\newline	\newline	lscp_mutex_lock(pServer-&gtconnects.mutex);\newline\newline	for (p = pServer-&gtconnects.first; p; p = p-&gtnext) {\newline		if (p-&gtevents &amp event)\newline			send(p-&gtclient.sock, achBuffer, cchBuffer, 0);\newline	}\newline\newline	lscp_mutex_unlock(pServer-&gtconnects.mutex);\newline\newline	return LSCP_OK;\newline}\newline","\newline Send an event notification message to all subscribed clients.\newline \newline @param pServer Pointer to server instance structure.\newline @param event Event type flag to send to all subscribed clients.\newline @param pchData Pointer to event data to be sent to all clients.\newline @param cchData Length of the event data to be sent in bytes.\newline \newline @returns LSCP_OK on success, LSCP_FAILED otherwise.\newline \newline","3130533","msg_renderers.c","int summcmp_rsender(const void *s1, const void *s2) {\newline	message_summary *summ1;\newline	message_summary *summ2;\newline	\newline	summ1 = (message_summary *)GetSearchPayload(s1);\newline	summ2 = (message_summary *)GetSearchPayload(s2);\newline	return strcasecmp(ChrPtr(summ2-&gtfrom), ChrPtr(summ1-&gtfrom));\newline}\newline","\newline comparator for message summary structs by descending sender.\newline \newline","4500528","mooproxy.c","static void print_help_text( void )\newline{\newline	printf( &quotMooproxy - a buffering proxy for MOO connections\\n&quot\newline	&quotCopyright (C) %s Marcel L. Moreaux &ltmarcelm@qvdr.net&gt\\n&quot\newline	&quot\\n&quot\newline	&quotUsage: mooproxy [options]\\n&quot\newline	&quot\\n&quot\newline	&quot  -h, --help        shows this help screen and exits\\n&quot\newline	&quot  -V, --version     shows version information and exits\\n&quot\newline	&quot  -L, --license     shows licensing information and exits\\n&quot\newline	&quot  -w, --world       world to load\\n&quot\newline	&quot  -d, --no-daemon   forces mooproxy to stay in the foreground\\n&quot\newline	&quot  -m, --md5crypt    prompts for a string to create an md5 hash of\\n&quot\newline	&quot\\n&quot\newline	&quotReleased under the GPL v2, report bugs to &ltmarcelm@qvdr.net&gt\\n&quot\newline	&quotMooproxy comes with ABSOLUTELY NO WARRANTY; &quot\newline	&quotfor details run mooproxy --license\\n&quot,\newline	COPYYEARS );\newline}\newline","Print the help output (-h, --help) \newline","5687784","ne_openssl.c","static char *dup_ia5string(const ASN1_IA5STRING *as)\newline{\newline    return ne_strnqdup(as-&gtdata, as-&gtlength);\newline}\newline","Returns a malloc-allocated version of IA5 string AS, escaped for\newline safety. \newline","4226552","bitmap.c","static int convert_ARGB(guiImage *img)\newline{\newline    unsigned char *orgImage;\newline    unsigned int i, c;\newline\newline    if (img-&gtBpp == 24) {\newline        orgImage = img-&gtImage;\newline\newline        img-&gtBpp       = 32;\newline        img-&gtImageSize = img-&gtWidth * img-&gtHeight * 4;\newline        img-&gtImage     = calloc(1, img-&gtImageSize);\newline\newline        if (!img-&gtImage) {\newline            free(orgImage);\newline            mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] not enough memory: %u\\n&quot, img-&gtImageSize);\newline            return False;\newline        }\newline\newline        mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] 32 bpp conversion size: %u\\n&quot, img-&gtImageSize);\newline\newline        for (i = 0, c = 0; i &lt img-&gtImageSize; i += 4, c += 3)\newline            *(uint32_t *)&ampimg-&gtImage[i] = ALPHA_OPAQUE | AV_RB24(&amporgImage[c]);\newline\newline        free(orgImage);\newline    } else if (img-&gtBpp == 32) {\newline        mp_msg(MSGT_GPLAYER, MSGL_DBG2, &quot[bitmap] 32 bpp ARGB conversion\\n&quot);\newline\newline        for (i = 0; i &lt img-&gtImageSize; i += 4)\newline            *(uint32_t *)&ampimg-&gtImage[i] = (img-&gtImage[i + 3] &lt&lt 24) | AV_RB24(&ampimg-&gtImage[i]);\newline    } else\newline        return False;\newline\newline    return True;\newline}\newline","\newline @brief Convert a 24-bit RGB or 32-bit RGBA image into a 32-bit ARGB image.\newline \newline @param img image to be converted\newline \newline @return #True (ok) or #False (error)\newline \newline @note This is an in-place conversion,\newline new memory will be allocated for @a img if necessary.\newline \newline","407571","libusb-utils.c","int init_usb(libusb_context *ctx) {\newline  int result;\newline\newline  result = libusb_init(&ampctx); //initialize the library for the session\newline  \newline  if (result &lt LIBUSB_SUCCESS) {\newline    \newline#ifdef DEBUG\newline\newline    printf(&quotInit Error: %d\\n&quot, result);\newline\newline#endif\newline\newline    return USB_FAILURE;\newline  }\newline\newline#ifdef DEBUG\newline\newline#if (HOST_OS == LINUX)\newline\newline  libusb_set_debug(ctx, 4); //set verbosity level to 4\newline\newline#elif (HOST_OS == FREEBSD)\newline\newline  libusb_set_debug(ctx, 1); //set verbosity level to 1\newline\newline#endif\newline\newline#endif\newline\newline  return USB_SUCCESS;\newline}\newline","\newline Initializes libusb.\newline \newline Returns USB_SUCCESS or USB_FAILURE.\newline \newline","6550419","gkrelluim.c","static gint panel_expose_event( GtkWidget *widget, GdkEventExpose *ev ) {\newline  gdk_draw_pixmap( widget-&gtwindow,\newline    widget-&gtstyle-&gtfg_gc[ GTK_WIDGET_STATE( widget ) ],\newline    panel-&gtpixmap, ev-&gtarea.x, ev-&gtarea.y, ev-&gtarea.x, ev-&gtarea.y,\newline    ev-&gtarea.width, ev-&gtarea.height );\newline  return FALSE;\newline}\newline","\newline taken from gkrellm2-demos/demo2.c\newline \newline","5692844","test_bus.c","int  test_sysfs_close_bus(int flag)\newline{\newline	struct sysfs_bus *bus = NULL;\newline	char *bus_name = NULL;\newline\newline	switch (flag) {\newline	case 0:\newline		bus_name = val_bus_name;\newline		bus = sysfs_open_bus(bus_name);\newline		if (bus == NULL) {\newline			dbg_print(&quot%s: sysfs_open_bus() failed\\n&quot,__FUNCTION__);\newline			return 0;\newline		}\newline		break;\newline	case 1:\newline		bus = NULL;\newline		break;\newline	default:\newline		return -1;\newline	}\newline	sysfs_close_bus(bus);\newline\newline	dbg_print(&quot%s: returns void\\n&quot, __FUNCTION__);\newline	return 0;\newline}\newline","\newline extern void sysfs_close_bus(struct sysfs_bus bus);\newline \newline flags:\newline 0 -&gt bus -&gt valid\newline 1 -&gt bus -&gt null.\newline \newline","4102148","tag.c","int tag_insert(\newline  const char *zTag,        /* Name of the tag (w/o the &quot+&quot or &quot-&quot prefix */\newline  int tagtype,             /* 0:cancel  1:singleton  2:propagated */\newline  const char *zValue,      /* Value if the tag is really a property */\newline  int srcId,               /* Artifact that contains this tag */\newline  double mtime,            /* Timestamp.  Use default if &lt=0.0 */\newline  int rid                  /* Artifact to which the tag is to attached */\newline){\newline  Stmt s;\newline  const char *zCol;\newline  int tagid = tag_findid(zTag, 1);\newline  int rc;\newline\newline  if( mtime&lt=0.0 ){\newline    mtime = db_double(0.0, &quotSELECT julianday(&#039now&#039)&quot);\newline  }\newline  db_prepare(&amps,\newline    &quotSELECT 1 FROM tagxref&quot\newline    &quot WHERE tagid=%d&quot\newline    &quot   AND rid=%d&quot\newline    &quot   AND mtime&gt=:mtime&quot,\newline    tagid, rid\newline  );\newline  db_bind_double(&amps, &quot:mtime&quot, mtime);\newline  rc = db_step(&amps);\newline  db_finalize(&amps);\newline  if( rc==SQLITE_ROW ){\newline    /* Another entry that is more recent already exists.  Do nothing */\newline    return tagid;\newline  }\newline  db_prepare(&amps,\newline    &quotREPLACE INTO tagxref(tagid,tagtype,srcId,origid,value,mtime,rid)&quot\newline    &quot VALUES(%d,%d,%d,%d,%Q,:mtime,%d)&quot,\newline    tagid, tagtype, srcId, rid, zValue, rid\newline  );\newline  db_bind_double(&amps, &quot:mtime&quot, mtime);\newline  db_step(&amps);\newline  db_finalize(&amps);\newline  if( tagid==TAG_BRANCH ) leaf_eventually_check(rid);\newline  if( tagtype==0 ){\newline    zValue = 0;\newline  }\newline  zCol = 0;\newline  switch( tagid ){\newline    case TAG_BGCOLOR: {\newline      zCol = &quotbgcolor&quot;\newline      break;\newline    }\newline    case TAG_COMMENT: {\newline      zCol = &quotecomment&quot;\newline      break;\newline    }\newline    case TAG_USER: {\newline      zCol = &quoteuser&quot;\newline      break;\newline    }\newline    case TAG_PRIVATE: {\newline      db_multi_exec(\newline        &quotINSERT OR IGNORE INTO private(rid) VALUES(%d);&quot,\newline        rid\newline      );\newline    }\newline  }\newline  if( zCol ){\newline    db_multi_exec(&quotUPDATE event SET \\&quot%w\\&quot=%Q WHERE objid=%d&quot,\newline                  zCol, zValue, rid);\newline    if( tagid==TAG_COMMENT ){\newline      char *zCopy = mprintf(&quot%s&quot, zValue);\newline      wiki_extract_links(zCopy, rid, 0, mtime, 1, WIKI_INLINE);\newline      free(zCopy);\newline    }\newline  }\newline  if( tagid==TAG_DATE ){\newline    db_multi_exec(&quotUPDATE event &quot\newline                  &quot   SET mtime=julianday(%Q),&quot\newline                  &quot       omtime=coalesce(omtime,mtime)&quot\newline                  &quot WHERE objid=%d&quot,\newline                  zValue, rid);\newline  }\newline  if( tagid==TAG_PARENT &amp&amp tagtype==1 ){\newline    manifest_reparent_checkin(rid, zValue);\newline  }\newline  if( tagtype==1 ) tagtype = 0;\newline  tag_propagate(rid, tagid, tagtype, rid, zValue, mtime);\newline  return tagid;\newline}\newline","\newline Insert a tag into the database.\newline \newline Also translate zTag into a tagid and return the tagid. (In other words\newline if zTag is &quotbgcolor&quot then return TAG_BGCOLOR.)\newline \newline","6629709","uuid_dce.c","void uuid_dce_create_nil(uuid_dce_t *uuid_dce, int *status)\newline{\newline    /* initialize status */\newline    if (status != NULL)\newline        *status = uuid_s_error;\newline\newline    /* sanity check argument(s) */\newline    if (uuid_dce == NULL)\newline        return;\newline\newline    /* short-circuit implementation, because Nil UUID is trivial to\newline       create, so no need to use regular OSSP uuid API */\newline    memset(uuid_dce, 0, UUID_LEN_BIN);\newline\newline    /* return successfully */\newline    if (status != NULL)\newline        *status = uuid_s_ok;\newline    return;\newline}\newline","create a Nil UUID \newline","2907458","gtk-ui.c","static void make_settings_ui(GtkWidget *vbox)\newline{\newline    GtkWidget *fbox;\newline    GtkWidget *frame;\newline\newline    frame = gtk_frame_new(_(&quotDefault OTR Settings&quot));\newline    gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, FALSE, 0);\newline\newline    fbox = gtk_vbox_new(FALSE, 0);\newline    gtk_container_set_border_width(GTK_CONTAINER(fbox), 10);\newline    gtk_container_add(GTK_CONTAINER(frame), fbox);\newline\newline    create_otrsettings_buttons(&amp(ui_layout.os), fbox);\newline\newline    load_otrsettings(&amp(ui_layout.os));\newline\newline    g_signal_connect(G_OBJECT(ui_layout.os.enablebox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.automaticbox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.onlyprivatebox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline    g_signal_connect(G_OBJECT(ui_layout.os.avoidloggingotrbox), &quotclicked&quot,\newline	    G_CALLBACK(otrsettings_save_cb), &amp(ui_layout.os));\newline}\newline","Make the settings UI, and pack it into the vbox \newline","1626060","cfgfile.c","const int *getJP2KCSamplingRGBA (int width, int height)\newline{\newline	int imgcat;\newline\newline	imgcat = getImgSizeCategory (width, height);\newline\newline	return (JP2CSamplingRGBA + (16 * imgcat));\newline}\newline","return a pointer to a array[16] with the components&#039 sampling parameters JP2K RGBA components \newline","6061729","imagescalertest.cpp","void ImageScalerTest::testDontCrashWithoutImage()\newline{\newline    Gwenview::ImageScaler scaler;\newline    scaler.setZoom(1.0);\newline    scaler.setDestinationRegion(QRect(0, 0, 10, 10));\newline}\newline","\newline Test instantiating a scaler without setting an image won&#039t crash\newline \newline","1471463","plugin.c","static void usage_controller_onResourceAppearing_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {\newline	usage_controller_onResourceAppearingData* _data_;\newline	_data_ = _user_data_;\newline	_data_-&gt_source_object_ = source_object;\newline	_data_-&gt_res_ = _res_;\newline	usage_controller_onResourceAppearing_co (_data_);\newline}\newline","\newline Handle a resource appearing on the bus. This will send out a notification and\newline enable or disables the resource depending on which debug option is set.\newline \newline","","","","","","on","on","","","","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","interface implementation","Print the help output","Returns a malloc-allocated version of IA5 string","Convert a 24-bit RGB or 32-bit RGBA image","Initializes libusb.","{}","{}","Insert a tag into the database.","create a Nil UUID","Make the settings UI, and pack it into the vbox","{}","Remove a TLV of a given type.","Test instantiating a scaler","Handle a resource appearing on the bus.","join the elements of the ktable","{}","Free channel object and all streams associated with it.","Gets the value of @cl's flag wrap.","add_module_to_prayerlist_folder","Send an event notification message to all subscribed clients.","comparator for message summary structs by descending sender."
"33TGB4G0LPHG2P7OPC38JOG1G63TXS","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","37C0GNLMHF3YP5OOS1Z43QHKW4ID65","AVC62JNYAXA45","Approved","Wed Apr 17 14:12:31 PDT 2019","Wed Apr 17 14:35:16 PDT 2019","Fri Apr 19 14:35:16 PDT 2019","2019-04-19 21:35:21 UTC","","","1365","100% (24/24)","100% (24/24)","100% (24/24)","1562242","system_area.c","static int write_mbr_partition_entry(int partition_number, int partition_type,\newline                  uint64_t partition_offset, uint64_t partition_size,\newline                  int sph, int hpc, uint8_t *buf, int flag)\newline{\newline    uint8_t *wpt;\newline    uint32_t end_lba, end_sec, end_head, end_cyl;\newline    uint32_t start_lba, start_sec, start_head, start_cyl;\newline    uint32_t after_end;\newline    int i;\newline\newline    after_end = partition_offset + partition_size;\newline    iso_compute_cyl_head_sec((uint64_t) partition_offset, hpc, sph,\newline                             &ampstart_lba, &ampstart_sec, &ampstart_head, &ampstart_cyl,\newline                             1 | (flag &amp 2));\newline    iso_compute_cyl_head_sec((uint64_t) after_end, hpc, sph,\newline                             &ampend_lba, &ampend_sec, &ampend_head, &ampend_cyl,\newline                             (flag &amp 2));\newline    wpt = buf + 446 + (partition_number - 1) * 16;\newline\newline    /* Not bootable */\newline    *(wpt++) = 0x00;\newline\newline    /* C/H/S of the start */\newline    *(wpt++) = start_head;\newline    *(wpt++) = start_sec | ((start_cyl &amp 0x300) &gt&gt 2);\newline    *(wpt++) = start_cyl &amp 0xff;\newline\newline    /* (partition type) */\newline    *(wpt++) = partition_type;\newline\newline    /* 3 bytes of C/H/S end */\newline    *(wpt++) = end_head;\newline    *(wpt++) = end_sec | ((end_cyl &amp 0x300) &gt&gt 2);\newline    *(wpt++) = end_cyl &amp 0xff;\newline    \newline    /* LBA start in little endian */\newline    for (i = 0; i &lt 4; i++)\newline       *(wpt++) = (start_lba &gt&gt (8 * i)) &amp 0xff;\newline\newline    /* Number of sectors in partition, little endian */\newline    end_lba = end_lba - start_lba + 1;\newline    for (i = 0; i &lt 4; i++)\newline       *(wpt++) = (end_lba &gt&gt (8 * i)) &amp 0xff;\newline\newline    /* Afaik, partition tables are recognize donly with MBR signature */\newline    buf[510] = 0x55;\newline    buf[511] = 0xAA;\newline\newline    return ISO_SUCCESS;\newline}\newline","@param flag\newlinebit1= partition_offset and partition_size are counted in\newlineblocks of 512 rather than 2048\newline \newline","4463213","signals.c","static void pthread_null_sighandler(int sig attribute_unused) { }\newline","A signal handler that does nothing \newline","85229","udo.c","LOCAL void c_win_charwidth ( void )\newline{\newline	iDocCharwidth= atoi(token[1]);\newline	\newline	if (iDocCharwidth&lt=0)\newline	{	iDocCharwidth= 150;\newline	}\newline}	/* c_win_charwidth */\newline","--------------------------------------------------------------\newline c_win_charwidth() / c_rtf_charwidth\newline Setzen der Zeichenbreite eines Zeichens fuer WinHelp und RTF\newline Die Zeichenbreiten werden zur Berechnung von Einrueckungen\newline in Listen und Tabellen verwendet und koennen von UDO nicht\newline ueber das System abgefragt werden.\newline -------------------------------------------------------------- \newline","1332699","db.c","int extract_third_party(char *call,\newline                        char *path,\newline                        int path_size,\newline                        char **info,\newline                        char *origin,\newline                        int origin_size) {\newline    int ok;\newline    char *p_call;\newline    char *p_path;\newline\newline    p_call = NULL;                              // to make the compiler happy...\newline    p_path = NULL;                              // to make the compiler happy...\newline    ok = 0;\newline    if (!is_my_call(call,1)) { // Check SSID also\newline        // todo: add reporting station call to database ??\newline        //       but only if not identical to reported call\newline        (*info) = (*info) +1;                   // strip &#039}&#039 character\newline        p_call = strtok((*info),&quot&gt&quot);           // extract call\newline        if (p_call != NULL) {\newline            p_path = strtok(NULL,&quot:&quot);          // extract path\newline            if (p_path != NULL) {\newline                (*info) = strtok(NULL,&quot&quot);      // rest is information field\newline                if ((*info) != NULL)            // the above looks dangerous, but works on same string\newline                    if (strlen(p_path) &lt 100)\newline                        ok = 1;                 // we have found all three components\newline            }\newline        }\newline    }\newline","\newline Extract third-party traffic from information field before processing\newline \newline","5249510","sdlgui.c","static void SDLGui_DrawUserObj(const SGOBJ *bdlg, int objnum)\newline{\newline	int x, y, w, h;\newline	char (*userfun)(int x, int y, int w, int h);\newline\newline	x = bdlg[objnum].x*sdlgui_fontwidth;\newline	y = bdlg[objnum].y*sdlgui_fontheight;\newline\newline	/* add absolute coordinates */\newline	x += bdlg[0].x*sdlgui_fontwidth;\newline	y += bdlg[0].y*sdlgui_fontheight;\newline\newline	w = bdlg[objnum].w*sdlgui_fontwidth;\newline	h = bdlg[objnum].h*sdlgui_fontheight;\newline\newline	userfun = (void*)bdlg[objnum].txt;\newline\newline	userfun(x, y, w, h);\newline}\newline","\newline Draw a user object.\newline \newline","5108754","stack.c","fnprocinfo pop_fn(void) {\newline  stack_fn *p = basicvars.stacktop.fnsp;\newline#ifdef DEBUG\newline  if (basicvars.debug_flags.stack) fprintf(stderr, &quotDiscard &#039FN&#039 block at %p, restart = %p\\n&quot, p, p-&gtlastrestart);\newline#endif\newline  basicvars.opstop = p-&gtlastopstop;\newline  basicvars.opstlimit = p-&gtlastopstlimit;\newline  basicvars.local_restart = p-&gtlastrestart;\newline  basicvars.procstack = p-&gtfnprocblock.lastcall;\newline  basicvars.stacktop.bytesp+=ALIGNSIZE(stack_fn);\newline  return p-&gtfnprocblock;\newline}\newline","\newline &#039pop_fn&#039 removes a function return control block from the Basic stack,\newline updating the procedure/function call chain as well\newline \newline","5792594","libfat.c","DWORD get_fstclus(Volume_t *V, DirEntry_t *D) {\newline	DWORD val = 0;\newline	\newline	char *dst = (char *) &ampval;\newline	char *src = (char *) &amp(D-&gtDIR_FstClusLO);\newline	\newline	dst[0] = src[0];\newline	dst[1] = src[1];\newline\newline	if (V-&gtFatType == FAT32) {\newline		src = (char *) &amp(D-&gtDIR_FstClusHI);\newline		dst[2] = src[0];\newline		dst[3] = src[1];\newline	}\newline	\newline	val=EFD(val);\newline	return val;\newline}\newline","get first cluster \newline","3067163","qwt_dial_needle.cpp","void QwtDialNeedle::setPalette(const QPalette &amppalette) \newline{ \newline    d_palette = palette; \newline}\newline","!\newlineSets the palette for the needle.\newline\\param palette New Palette\newline \newline","4835409","suspend.c","extern int slurm_suspend2(char *job_id, job_array_resp_msg_t **resp)\newline{\newline	return _suspend_op2(SUSPEND_JOB, job_id, resp);\newline}\newline","\newline slurm_suspend2 - suspend execution of a job.\newline IN job_id in string form - job on which to perform operation\newline OUT resp - per task response to the request,\newline free using slurm_free_job_array_resp()\newline RET 0 or a slurm error code\newline \newline","5744904","thyme.c","void VGSim_loadFiles(VGSim *vg, List *load_files)\newline{\newline  ListElem *E;\newline\newline  for (E = List_first(load_files);E;E = List_next(load_files,E)) {\newline    const char *fileName = (const char*)ListElem_obj(E);\newline\newline    if (VerilogLoad(fileName) &lt 0) {\newline      errorCmd(ERR_NOREAD,fileName);\newline    }\newline  }\newline}\newline","\newline \newline Load a list of files\newline \newline Parameters:\newline vg The vgsim object\newline load_files List of files to be loaded.\newline \newline \newline","5831478","net.c","void setsock(int sock, int options)\newline{\newline  int i = allocsock(sock, options), parm;\newline  struct threaddata *td = threaddata();\newline\newline  if (i == -1) {\newline    putlog(LOG_MISC, &quot*&quot, &quotSockettable full.&quot);\newline    return;\newline  }\newline  if (((sock != STDOUT) || backgrd) &amp&amp !(td-&gtsocklist[i].flags &amp SOCK_NONSOCK)) {\newline    parm = 1;\newline    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *) &ampparm, sizeof(int));\newline\newline    parm = 0;\newline    setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *) &ampparm, sizeof(int));\newline  }\newline  if (options &amp SOCK_LISTEN) {\newline    /* Tris says this lets us grab the same port again next time */\newline    parm = 1;\newline    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &ampparm, sizeof(int));\newline  }\newline  /* Yay async i/o ! */\newline  fcntl(sock, F_SETFL, O_NONBLOCK);\newline}\newline","Request a normal socket for i/o\newline \newline","5104609","launch.c","static void cmd_parse(char *buf, char **args) {\newlineint i, argnum;\newline\newline	i = argnum = 0;\newline    while ( (i &lt MAXCMDLEN) &amp&amp (buf[i] != 0) ) {\newline\newline        /*\newline         * Strip whitespace.  Use nulls, so\newline         * that the previous argument is terminated\newline         * automatically.\newline         */\newline        while ( (i &lt MAXCMDLEN) &amp&amp ((buf[i] == &#039 &#039) || (buf[i] == &#039\\t&#039)))\newline            buf[i++] = 0;\newline\newline        /*\newline         * Save the argument.\newline         */\newline		if ( argnum &lt MAXARGS ) \newline        	args[argnum++] = &amp(buf[i]);\newline\newline        /*\newline         * Skip over the argument.\newline         */\newline        while ( (i &lt MAXCMDLEN) &amp&amp ((buf[i] != 0) &amp&amp (buf[i] != &#039 &#039) &amp&amp (buf[i] != &#039\\t&#039)))\newline            i++;\newline    }\newline\newline	if ( argnum &lt MAXARGS ) \newline    	args[argnum] = NULL;\newline\newline	if ( (i &gt= MAXCMDLEN) || (argnum &gt= MAXARGS) ) {\newline		// for safety reason, disable the command\newline    	args[0] = NULL;	\newline		syslog(LOG_ERR, &quotLauncher: Unable to parse command: &#039%s&#039&quot, buf);\newline	}\newline\newline} // End of cmd_parse\newline","\newline split the command in buf into individual arguments.\newline \newline","1255717","extent_tree.c","static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\newline					struct ocfs2_extent_list *el,\newline					struct ocfs2_extent_rec *insert_rec)\newline{\newline	int i;\newline	uint32_t cpos = insert_rec-&gte_cpos;\newline	struct ocfs2_extent_rec *rec;\newline\newline	insert-&gtins_appending = APPEND_NONE;\newline\newline	assert(el-&gtl_tree_depth == 0);\newline\newline	if (!el-&gtl_next_free_rec)\newline		goto set_tail_append;\newline\newline	if (ocfs2_is_empty_extent(&ampel-&gtl_recs[0])) {\newline		/* Were all records empty? */\newline		if (el-&gtl_next_free_rec == 1)\newline			goto set_tail_append;\newline	}\newline\newline	i = el-&gtl_next_free_rec - 1;\newline	rec = &ampel-&gtl_recs[i];\newline\newline	if (cpos &gt= (rec-&gte_cpos + rec-&gte_leaf_clusters))\newline		goto set_tail_append;\newline\newline	return;\newline\newlineset_tail_append:\newline	insert-&gtins_appending = APPEND_TAIL;\newline}\newline","\newline This should only be called against the righmost leaf extent list.\newline \newline ocfs2_figure_appending_type() will figure out whether we&#039ll have to\newline insert at the tail of the rightmost leaf.\newline \newline This should also work against the dinode list for tree&#039s with 0\newline depth. If we consider the dinode list to be the rightmost leaf node\newline then the logic here makes sense.\newline \newline","5071778","script.c","void InitObjTabCase(int HasMainLoop)\newline{\newline if (nbobj==0)\newline {\newline  TabIObj=(Bloc**)safecalloc(1,sizeof(long));\newline  TabCObj=(CaseObj*)safecalloc(1,sizeof(CaseObj));\newline }\newline else\newline {\newline  TabIObj=(Bloc**)realloc(TabIObj,sizeof(long)*(nbobj+1));\newline  TabCObj=(CaseObj*)realloc(TabCObj,sizeof(CaseObj)*(nbobj+1));\newline }\newline\newline if (!HasMainLoop)\newline  TabIObj[nbobj]=NULL;\newline CurrCase=-1;\newline TabCObj[nbobj].NbCase=-1;\newline}\newline","Initialisation pour un objet \newline","327812","service.c","static http_error check_passwd(\newline        const char *username, const char *current_password,\newline        xmlXPathContextPtr xpath_ctx,\newline        char **code, char **pass_message) {\newline    http_error error = HTTP_ERROR_SUCCESS;\newline    char *message = NULL;\newline    char *old_password = NULL, *new_password = NULL;\newline    size_t length;\newline\newline    if (NULL == username || NULL == current_password ||\newline            NULL == code || NULL == pass_message) {\newline        return HTTP_ERROR_SERVER;\newline    }\newline\newline    *code = &quot9999&quot;\newline\newline\newline    /* Parse request */\newline    EXTRACT_STRING(&quotisds:dbOldPassword&quot, old_password);\newline    if (NULL == old_password) {\newline        message = strdup(&quotEmpty isds:dbOldPassword&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline    EXTRACT_STRING(&quotisds:dbNewPassword&quot, new_password);\newline    if (NULL == new_password) {\newline        message = strdup(&quotEmpty isds:dbOldPassword&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    /* Check defined cases */\newline    if (strcmp(current_password, old_password)) {\newline        *code = &quot1090&quot;\newline        message = strdup(&quotBad current password&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    length = strlen(new_password);\newline\newline    if (length &lt 8 || length &gt 32) {\newline        *code = &quot1066&quot;\newline        message = strdup(&quotToo short or too long&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    {\newline        const char lower[] = &quotabcdefghijklmnopqrstuvwxyz&quot;\newline        const char upper[] = &quotABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\newline        const char digit[] = &quot0123456789&quot;\newline        const char special[] = &quot!#$%&amp()*+,-.:=?@[]_{}|~&quot;\newline        _Bool has_lower = 0, has_upper = 0, has_digit=0;\newline\newline        for (size_t i = 0; i &lt length; i++) {\newline            if (NULL != strchr(lower, new_password[i]))\newline                has_lower = 1;\newline            else if (NULL != strchr(upper, new_password[i]))\newline                has_upper = 1;\newline            else if (NULL != strchr(digit, new_password[i]))\newline                has_digit = 1;\newline            else if (NULL == strchr(special, new_password[i])) {\newline                *code = &quot1079&quot;\newline                message = strdup(&quotPassword contains forbidden character&quot);\newline                error = HTTP_ERROR_CLIENT;\newline                goto leave;\newline            }\newline        }\newline\newline        if (!has_lower || !has_upper || !has_digit) {\newline            *code = &quot1080&quot;\newline            message = strdup(&quotPassword does not contain lower cased letter, &quot\newline                    &quotupper cased letter and a digit&quot);\newline            error = HTTP_ERROR_CLIENT;\newline            goto leave;\newline        }\newline    }\newline\newline    if (!strcmp(old_password, new_password)) {\newline        *code = &quot1067&quot;\newline        message = strdup(&quotNew password same as current one&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    if (NULL != strstr(new_password, username)) {\newline        *code = &quot1082&quot;\newline        message = strdup(&quotNew password contains user ID&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    for (size_t i = 0; i &lt length - 2; i++) {\newline        if (new_password[i] == new_password[i+1] &amp&amp\newline                new_password[i] == new_password[i+2]) {\newline            *code = &quot1083&quot;\newline            message = strdup(&quotPassword contains sequence &quot\newline                    &quotof three identical characters&quot);\newline            error = HTTP_ERROR_CLIENT;\newline            goto leave;\newline        }\newline    }\newline    \newline    {\newline        const char *forbidden_prefix[] = { &quotqwert&quot, &quotasdgf&quot, &quot12345&quot };\newline        for (size_t i = 0; i &lt sizeof(forbidden_prefix)/sizeof(*forbidden_prefix);\newline                i++) {\newline            if (!strncmp(new_password, forbidden_prefix[i],\newline                        strlen(forbidden_prefix[i]))) {\newline                *code = &quot1083&quot;\newline                message = strdup(&quotPassword has forbidden prefix&quot);\newline                error = HTTP_ERROR_CLIENT;\newline                goto leave;\newline            }\newline        }\newline    }\newline\newline    *code = &quot0000&quot;\newline    message = strdup(&quotSuccess&quot);\newlineleave:\newline    free(old_password);\newline    free(new_password);\newline    *pass_message = message;\newline    return error;\newline}\newline","Common part for ChangeISDSPassword and ChangePasswordOTP.\newline @code is output pointer to static string\newline @pass_message is output pointer to auto-allocated string\newline @arguments is pointer to struct arguments_DS_DsManage_ChangeISDSPassword \newline","2642779","surface.c","GSList * gts_surface_split (GtsSurface * s)\newline{\newline  gpointer data[2];\newline  GSList * components = NULL;\newline\newline  g_return_val_if_fail (s != NULL, NULL);\newline\newline  data[0] = s;\newline  data[1] = &ampcomponents;\newline\newline  /* boundary components */\newline  gts_surface_foreach_edge (s, (GtsFunc) traverse_boundary, data);\newline\newline  /* remaining components */\newline  gts_surface_foreach_face (s, (GtsFunc) traverse_remaining, data);\newline\newline  return components;\newline}\newline","\newline gts_surface_split:\newline @s: a #GtsSurface.\newline \newline Splits a surface into connected and manifold components.\newline \newline Returns: a list of new #GtsSurface.\newline \newline","5981333","cre_jnl_file.c","uint4	cre_jnl_file(jnl_create_info *info)\newline{\newline	mstr 		filestr;\newline	int 		org_fn_len, rename_fn_len, fstat;\newline	char		*org_fn, rename_fn[MAX_FN_LEN];\newline	boolean_t	no_rename;\newline\newline	assert(0 != jgbl.gbl_jrec_time);\newline	if (!info-&gtno_rename)	/* ***MAYBE*** rename is required */\newline	{\newline		no_rename = FALSE;\newline		if (SS_NORMAL != (info-&gtstatus = prepare_unique_name((char *)info-&gtjnl, info-&gtjnl_len, &quot&quot, &quot&quot,\newline				rename_fn, &amprename_fn_len, jgbl.gbl_jrec_time, &ampinfo-&gtstatus2)))\newline		{\newline			no_rename = TRUE;\newline		} else\newline		{\newline			filestr.addr = (char *)info-&gtjnl;\newline			filestr.len = info-&gtjnl_len;\newline			if (FILE_PRESENT != (fstat = gtm_file_stat(&ampfilestr, NULL, NULL, FALSE, (uint4 *)&ampinfo-&gtstatus)))\newline			{\newline				if (FILE_NOT_FOUND != fstat)\newline				{\newline					STATUS_MSG(info);\newline					return EXIT_ERR;\newline				}\newline				if (IS_GTM_IMAGE)\newline					send_msg_csa(CSA_ARG(info-&gtcsa) VARLSTCNT(4) ERR_JNLFNF, 2, filestr.len, filestr.addr);\newline				else\newline					gtm_putmsg_csa(CSA_ARG(info-&gtcsa) VARLSTCNT(4) ERR_JNLFNF, 2, filestr.len, filestr.addr);\newline				no_rename = TRUE;\newline			}\newline			/* Note if info-&gtno_prev_link == TRUE, we do not keep previous link, though rename can happen */\newline			if (JNL_ENABLED(info) &amp&amp !info-&gtno_prev_link)\newline			{\newline				memcpy(info-&gtprev_jnl, rename_fn, rename_fn_len + 1);\newline				info-&gtprev_jnl_len = rename_fn_len;\newline			} else\newline				assert(info-&gtno_prev_link);\newline		}\newline		if (no_rename)\newline		{\newline			STATUS_MSG(info);\newline			info-&gtstatus = info-&gtstatus2 = SS_NORMAL;\newline			info-&gtno_rename = TRUE; /* We wanted to rename, but not required anymore */\newline			info-&gtno_prev_link = TRUE;	/* No rename =&gt no prev_link */\newline		}\newline	} /* else we know for sure rename is not required */\newline	return (cre_jnl_file_common(info, rename_fn, rename_fn_len));\newline}\newline","Create a journal file from info.\newline If necessary, it renames journal file of same name.\newline Note: jgbl.gbl_jrec_time must be set by callers\newline \newline","2760461","cpick.c","static void cpick_area_update_cursors(cpicker *cp)\newline{\newline	int x, y, l;\newline\newline	l = cp-&gtarea_size[CPICK_AREA_PICKER][0] - 1;\newline	x = (cp-&gtinput_vals[CPICK_INPUT_VALUE] * l + l - 1) / 255;\newline	l = cp-&gtarea_size[CPICK_AREA_PICKER][1] - 1;\newline	y = ((255 - cp-&gtinput_vals[CPICK_INPUT_SATURATION]) * l + l - 1) / 255;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_PICKER], x, y);\newline\newline	x = cp-&gtarea_size[CPICK_AREA_HUE][0] / 2;\newline	l = cp-&gtarea_size[CPICK_AREA_HUE][1] - 1;\newline	y = ((1529 - cp-&gtinput_vals[CPICK_INPUT_HUE]) * l + l - 1) / 1529;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_HUE], x, y);\newline\newline	x = cp-&gtarea_size[CPICK_AREA_OPACITY][0] / 2;\newline	l = cp-&gtarea_size[CPICK_AREA_OPACITY][1] - 1;\newline	y = ((255 - cp-&gtinput_vals[CPICK_INPUT_OPACITY]) * l + l - 1) / 255;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_OPACITY], x, y);\newline}\newline","These formulas perfectly reverse ones in cpick_area_mouse() when possible;\newline however, for sizes &gt 255 it&#039s impossible in principle - WJ \newline","4361184","background.c","void _dxf_ExBackgroundRedo (void)\newline{\newline    _dxf_ExVCRRedo();\newline\newline    if (! background.tree)\newline	return;\newline\newline    if (background.graph != NULL)\newline    {\newline	_dxf_ExGraphDelete(background.graph);\newline	background.graph = NULL;\newline    }\newline\newline    background.change = TRUE;\newline}\newline","\newline Called whenever a macro is redefined.\newline \newline","5182537","modexlib.c","void VL_CopyPlanarPageToMemory ( byte * src, byte * dest )\newline{\newline   byte * ptr;\newline   int plane,a,b;\newline\newline   for (plane=0;plane&lt4;plane++)\newline      {\newline      ptr=dest+plane;\newline      VGAREADMAP(plane);\newline      for (a=0;a&lt200;a++)\newline         for (b=0;b&lt80;b++,ptr+=4)\newline            *(ptr)=*(src+(a*linewidth)+b);\newline      }\newline}\newline","\newline=======================\newline=\newline= VL_CopyPlanarPageToMemory\newline=\newline=======================\newline \newline","2204935","psf.c","void	psf_makeresi(psfstruct *psf, setstruct *set, int centflag,\newline		double prof_accuracy)\newline  {\newline   samplestruct		*sample;\newline   static double	pos[MAXCONTEXT], amat[9], bmat[3];\newline   double		*dresi, *dresit, *amatt,\newline			*cvigx,*cvigxt, *cvigy,*cvigyt,\newline			nm1, chi2, dx,dy, ddx,ddy, dval,dvalx,dvaly,dwval,\newline			radmin2,radmax2, hcw,hch, yb, mx2,my2,mxy,\newline			xc,yc,rmax2,x,y, mse, xi2, xyi, resival, resinorm;\newline   float		*vigresi, *vig, *vigw, *fresi,*fresit, *vigchi,\newline			*cbasis,*cbasist, *cdata,*cdatat, *cvigw,*cvigwt,\newline			norm, fval, vigstep, psf_extraccu2, wval, sval;\newline   int			i,j,n,ix,iy, ndim,npix,nsample, cw,ch,ncpix, okflag,\newline			accuflag, nchi2;\newline\newline  accuflag = (prof_accuracy &gt 1.0/BIG);\newline  vigstep = 1/psf-&gtpixstep;\newline  nsample = set-&gtnsample;\newline  npix = set-&gtvigsize[0]*set-&gtvigsize[1];\newline  ndim = psf-&gtpoly-&gtndim;\newline  QCALLOC(dresi, double, npix);\newline\newline  if (centflag)\newline    {\newline/*-- Compute Centering sub-vignet size (containing most of the signal) */\newline    cw=ch=(int)(2*set-&gtfwhm+1.0);\newline    if (cw&gtset-&gtvigsize[0])\newline      cw=set-&gtvigsize[0];\newline    if (ch&gtset-&gtvigsize[1])\newline      ch=set-&gtvigsize[1];\newline/*-- Allocate memory for the sub-vignet */\newline    ncpix = cw*ch;\newline    QMALLOC(cdata, float, ncpix);\newline    QMALLOC(cbasis, float, ncpix);\newline    QMALLOC(cvigw, float, ncpix);\newline    QMALLOC(cvigx, double, ncpix);\newline    QMALLOC(cvigy, double, ncpix);\newline/*-- Initialize gradient image */\newline    hcw = (double)(cw/2);\newline    hch = (double)(ch/2);\newline    cvigxt = cvigx;\newline    cvigyt = cvigy;\newline    for (iy=0; iy&ltch; iy++)\newline      {\newline      yb = iy-hch;\newline      for (ix=0; ix&ltcw; ix++)\newline        {\newline        *(cvigxt++) = ix-hcw;\newline        *(cvigyt++) = yb;\newline        }\newline      }\newline    }\newline  else\newline    {\newline    cvigx = cvigy = (double *)NULL;	/* To avoid gcc -Wall warnings */\newline    cbasis = cdata = cvigw = (float *)NULL;	/* ditto */\newline    cw = ch = ncpix = 0;			/* ibid */\newline    }\newline\newline/* Set convergence boundaries */\newline  radmin2 = PSF_MINSHIFT*PSF_MINSHIFT;\newline  radmax2 = PSF_MAXSHIFT*PSF_MAXSHIFT;\newline  okflag = nchi2 = 0;\newline  mse = 0.0; 				/* To avoid gcc -Wall warnings */\newline\newline/* Compute the chi2 */\newline  for (sample=set-&gtsample, n=nsample; n--; sample++)\newline    {\newline/*-- Build the local PSF */\newline    for (i=0; i&ltndim; i++)\newline      pos[i] = (sample-&gtcontext[i]-set-&gtcontextoffset[i])\newline		/set-&gtcontextscale[i];\newline    psf_build(psf, pos);\newline\newline/*-- Delta-x and Delta-y in vignet-pixel units */\newline    dx = sample-&gtdx;\newline    dy = sample-&gtdy;\newline\newline    if (centflag)\newline      {\newline/*---- Copy the data into the sub-vignet */\newline      vignet_copy(sample-&gtvig, set-&gtvigsize[0], set-&gtvigsize[1],\newline		cdata, cw,ch, 0,0, VIGNET_CPY);\newline/*---- Weight the data */\newline      vignet_copy(sample-&gtvigweight, set-&gtvigsize[0], set-&gtvigsize[1],\newline		cvigw, cw,ch, 0,0, VIGNET_CPY);\newline\newline      for (cdatat=cdata, cvigwt=cvigw, i=ncpix; i--;)\newline        *(cdatat++) *= *(cvigwt++);\newline\newline      for (j=0; j&ltPSF_NITER; j++)\newline        {\newline/*------ Map the PSF model at the current position */\newline        vignet_resample(psf-&gtloc, psf-&gtsize[0], psf-&gtsize[1],\newline		cbasis, cw,ch, -dx*vigstep, -dy*vigstep, vigstep, 1.0);\newline\newline/*------ Build the a and b matrices */\newline        memset(amat, 0, 9*sizeof(double));\newline        bmat[0] = bmat[1] = bmat[2] = mx2=my2=mxy = 0.0;\newline        for (cvigxt=cvigx,cvigyt=cvigy,cvigwt=cvigw,\newline		cbasist=cbasis,cdatat=cdata, i=ncpix; i--;)\newline          {\newline          dval = (double)*(cbasist++);\newline          bmat[0] += (dwval = dval*(double)*(cdatat++));\newline          bmat[1] += dwval*(dvalx = *(cvigxt++) - dx);\newline          bmat[2] += dwval*(dvaly = *(cvigyt++) - dy);\newline          mx2 += dval*dvalx*dvalx;\newline          my2 += dval*dvaly*dvaly;\newline          mxy += dval*dvalx*dvaly;\newline          amatt=amat;\newline          *(amatt++) += (dval *= dval*(double)*(cvigwt++));\newline          *(amatt++) += dval*dvalx;\newline          *(amatt++) += dval*dvaly;\newline          *(++amatt) += dval*dvalx*dvalx;\newline          *(++amatt) += dval*dvalx*dvaly;\newline          *(amatt+3) += dval*dvaly*dvaly;\newline          }\newline\newline/*------ Solve the system */\newline#if defined(HAVE_LAPACKE)\newline #ifdef MATSTORAGE_PACKED\newline        if (LAPACKE_dppsv(LAPACK_COL_MAJOR,&#039L&#039,3,1,amat,bmat,3) != 0)\newline #else\newline        if (LAPACKE_dposv(LAPACK_COL_MAJOR,&#039L&#039,3,1,amat,3,bmat,3) != 0)\newline #endif\newline#else\newline        if (clapack_dposv(CblasRowMajor,CblasUpper,3,1,amat,3,bmat,3) != 0)\newline#endif\newline          warning(&quotNot a positive definite matrix&quot, &quot in PSF model solver&quot);\newline\newline/*------ Convert to a shift */\newline        dx += 0.5*(ddx = (bmat[1]*mx2 + bmat[2]*mxy) / bmat[0]); \newline        dy += 0.5*(ddy = (bmat[2]*my2 + bmat[1]*mxy) / bmat[0]); \newline/*------ Exit if it converges or diverges */\newline        if (ddx*ddx+ddy*ddy &lt radmin2)\newline          {\newline          okflag = 1;\newline          break;\newline	  }\newline        else if (dx*dx+dy*dy &gt radmax2)\newline          break;\newline        }\newline      if (okflag)\newline        {\newline        sample-&gtdx = dx;\newline        sample-&gtdy = dy;\newline        }\newline      }\newline\newline\newline/*-- Map the PSF model at the current position */\newline    vignet_resample(psf-&gtloc, psf-&gtsize[0], psf-&gtsize[1],\newline	sample-&gtvigresi, set-&gtvigsize[0], set-&gtvigsize[1],\newline	-dx*vigstep, -dy*vigstep, vigstep, 1.0);\newline/*-- Fit the flux */\newline    xi2 = xyi = 0.0;\newline    for (cvigwt=sample-&gtvigweight,cbasist=sample-&gtvigresi,cdatat=sample-&gtvig,\newline	i=npix; i--;)\newline      {\newline      dwval = *(cvigwt++);\newline      dval = (double)*(cbasist++);\newline      xi2 += dwval*dval*dval;\newline      xyi += dwval*dval*(double)*(cdatat++);\newline      }\newline\newline    norm = (xi2&gt0.0)? xyi/xi2 : sample-&gtnorm;\newline\newline/*-- Subtract the PSF model and compute Chi2 */\newline    chi2 = mse = resival = resinorm = 0.0;\newline    dresit = dresi;\newline    psf_extraccu2 = prof_accuracy*prof_accuracy*norm*norm;\newline    xc = (double)(set-&gtvigsize[0]/2)+sample-&gtdx;\newline    yc = (double)(set-&gtvigsize[1]/2)+sample-&gtdy;\newline    y = -yc;\newline    rmax2 = psf-&gtpixstep*(psf-&gtsize[0]&ltpsf-&gtsize[1]?\newline		(double)(psf-&gtsize[0]/2) : (double)(psf-&gtsize[1]/2));\newline    rmax2 *= rmax2;\newline    nchi2 = 0;\newline    vig = sample-&gtvig;\newline    vigw = sample-&gtvigweight;\newline    vigresi=sample-&gtvigresi;\newline    vigchi = sample-&gtvigchi;\newline    for (iy=set-&gtvigsize[1]; iy--; y+=1.0)\newline      {\newline      x = -xc;\newline#pragma ivdep\newline      for (ix=set-&gtvigsize[0]; ix--; x+=1.0, vig++, vigresi++, dresit++,\newline						vigchi++)\newline        {\newline        *vigchi = 0;\newline        if ((wval=*(vigw++))&gt0.0)\newline          {\newline          if (accuflag)\newline            wval = 1.0/(1.0 / wval + psf_extraccu2**vigresi**vigresi);\newline          *vigresi = fval = (*vig-*vigresi*norm);\newline          if (x*x+y*y&ltrmax2)\newline            {\newline            mse += fval*fval;\newline            nchi2++;\newline            chi2 += (double)(*vigchi=wval*fval*fval);\newline            *dresit += fval;\newline            sval = *vig+*vigresi*norm;\newline            resival += sval*fabsf(fval);\newline            resinorm += sval*sval;\newline            }\newline          }\newline        }\newline      }\newline\newline    sample-&gtchi2 = (nchi2&gt 1)? chi2/(nchi2-1) : chi2;\newline    sample-&gtmodresi = (resinorm &gt 0.0)? 2.0*resival/resinorm : resival;\newline    }\newline\newline/* Normalize and convert to floats the Residual array */\newline  mse = sqrt(mse/nsample/nchi2);\newline/*printf(&quot%g\\n&quot, mse);*/\newline  QMALLOC(fresi, float, npix); \newline  nm1 = nsample &gt 1?  (double)(nsample - 1): 1.0;\newline  for (dresit=dresi,fresit=fresi, i=npix; i--;)\newline      *(fresit++) = sqrt(*(dresit++)/nm1);\newline\newline/*-- Map the residuals to PSF coordinates */\newline  vignet_resample(fresi, set-&gtvigsize[0], set-&gtvigsize[1],\newline	psf-&gtresi, psf-&gtsize[0], psf-&gtsize[1], 0.0,0.0, psf-&gtpixstep, 1.0);\newline\newline/* Free memory */\newline  free(dresi);\newline  free(fresi);\newline  if (centflag)\newline    {\newline    free(cvigx);\newline    free(cvigy);\newline    free(cvigw);\newline    free(cbasis);\newline    free(cdata);\newline    }\newline\newline  return;\newline  }\newline","psf_makeresi \newlinePROTO void psf_makeresi(psfstruct psf, setstruct set, int centflag,\newline double prof_accuracy)\newlinePURPOSE Compute PSF residuals.\newlineINPUT Pointer to the PSF,\newline Pointer to the sample set,\newline Re-centering flag (0=no),\newline PSF accuracy parameter.\newlineOUTPUT -.\newlineNOTES -.\newlineAUTHOR E. Bertin (IAP)\newlineVERSION 10/07/2012\newline \newline","on","","","","","","on","","","","on","","on","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","","{}","Load a list of files","Request a normal socket for i/o","split the command in buf into individual arguments.","insert at the tail of the rightmost leaf.","Initialisation pour un objet","{}","Splits a surface into connected and manifold components.","Create a journal file from info.","reverse ones in cpick_area_mouse() when possible;","{}","does nothing","{}","Compute PSF residuals.","Setzen der Zeichenbreite eines Zeichens fuer WinHelp und RTF","Extract third-party traffic from information field","Draw a user object.","removes a function return control block from the Basic stack,","get first cluster","Sets the palette for the needle.","suspend execution of a job."
"33TGB4G0LPHG2P7OPC38JOG1G63TXS","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3C8HJ7UOP7U3H9EC7ZVIJEX9AMFZM8","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:52:35 PDT 2019","Wed Apr 17 14:57:41 PDT 2019","Fri Apr 19 14:57:41 PDT 2019","2019-04-19 21:58:21 UTC","","","306","100% (27/27)","100% (27/27)","100% (27/27)","1562242","system_area.c","static int write_mbr_partition_entry(int partition_number, int partition_type,\newline                  uint64_t partition_offset, uint64_t partition_size,\newline                  int sph, int hpc, uint8_t *buf, int flag)\newline{\newline    uint8_t *wpt;\newline    uint32_t end_lba, end_sec, end_head, end_cyl;\newline    uint32_t start_lba, start_sec, start_head, start_cyl;\newline    uint32_t after_end;\newline    int i;\newline\newline    after_end = partition_offset + partition_size;\newline    iso_compute_cyl_head_sec((uint64_t) partition_offset, hpc, sph,\newline                             &ampstart_lba, &ampstart_sec, &ampstart_head, &ampstart_cyl,\newline                             1 | (flag &amp 2));\newline    iso_compute_cyl_head_sec((uint64_t) after_end, hpc, sph,\newline                             &ampend_lba, &ampend_sec, &ampend_head, &ampend_cyl,\newline                             (flag &amp 2));\newline    wpt = buf + 446 + (partition_number - 1) * 16;\newline\newline    /* Not bootable */\newline    *(wpt++) = 0x00;\newline\newline    /* C/H/S of the start */\newline    *(wpt++) = start_head;\newline    *(wpt++) = start_sec | ((start_cyl &amp 0x300) &gt&gt 2);\newline    *(wpt++) = start_cyl &amp 0xff;\newline\newline    /* (partition type) */\newline    *(wpt++) = partition_type;\newline\newline    /* 3 bytes of C/H/S end */\newline    *(wpt++) = end_head;\newline    *(wpt++) = end_sec | ((end_cyl &amp 0x300) &gt&gt 2);\newline    *(wpt++) = end_cyl &amp 0xff;\newline    \newline    /* LBA start in little endian */\newline    for (i = 0; i &lt 4; i++)\newline       *(wpt++) = (start_lba &gt&gt (8 * i)) &amp 0xff;\newline\newline    /* Number of sectors in partition, little endian */\newline    end_lba = end_lba - start_lba + 1;\newline    for (i = 0; i &lt 4; i++)\newline       *(wpt++) = (end_lba &gt&gt (8 * i)) &amp 0xff;\newline\newline    /* Afaik, partition tables are recognize donly with MBR signature */\newline    buf[510] = 0x55;\newline    buf[511] = 0xAA;\newline\newline    return ISO_SUCCESS;\newline}\newline","@param flag\newlinebit1= partition_offset and partition_size are counted in\newlineblocks of 512 rather than 2048\newline \newline","4463213","signals.c","static void pthread_null_sighandler(int sig attribute_unused) { }\newline","A signal handler that does nothing \newline","85229","udo.c","LOCAL void c_win_charwidth ( void )\newline{\newline	iDocCharwidth= atoi(token[1]);\newline	\newline	if (iDocCharwidth&lt=0)\newline	{	iDocCharwidth= 150;\newline	}\newline}	/* c_win_charwidth */\newline","--------------------------------------------------------------\newline c_win_charwidth() / c_rtf_charwidth\newline Setzen der Zeichenbreite eines Zeichens fuer WinHelp und RTF\newline Die Zeichenbreiten werden zur Berechnung von Einrueckungen\newline in Listen und Tabellen verwendet und koennen von UDO nicht\newline ueber das System abgefragt werden.\newline -------------------------------------------------------------- \newline","1332699","db.c","int extract_third_party(char *call,\newline                        char *path,\newline                        int path_size,\newline                        char **info,\newline                        char *origin,\newline                        int origin_size) {\newline    int ok;\newline    char *p_call;\newline    char *p_path;\newline\newline    p_call = NULL;                              // to make the compiler happy...\newline    p_path = NULL;                              // to make the compiler happy...\newline    ok = 0;\newline    if (!is_my_call(call,1)) { // Check SSID also\newline        // todo: add reporting station call to database ??\newline        //       but only if not identical to reported call\newline        (*info) = (*info) +1;                   // strip &#039}&#039 character\newline        p_call = strtok((*info),&quot&gt&quot);           // extract call\newline        if (p_call != NULL) {\newline            p_path = strtok(NULL,&quot:&quot);          // extract path\newline            if (p_path != NULL) {\newline                (*info) = strtok(NULL,&quot&quot);      // rest is information field\newline                if ((*info) != NULL)            // the above looks dangerous, but works on same string\newline                    if (strlen(p_path) &lt 100)\newline                        ok = 1;                 // we have found all three components\newline            }\newline        }\newline    }\newline","\newline Extract third-party traffic from information field before processing\newline \newline","5249510","sdlgui.c","static void SDLGui_DrawUserObj(const SGOBJ *bdlg, int objnum)\newline{\newline	int x, y, w, h;\newline	char (*userfun)(int x, int y, int w, int h);\newline\newline	x = bdlg[objnum].x*sdlgui_fontwidth;\newline	y = bdlg[objnum].y*sdlgui_fontheight;\newline\newline	/* add absolute coordinates */\newline	x += bdlg[0].x*sdlgui_fontwidth;\newline	y += bdlg[0].y*sdlgui_fontheight;\newline\newline	w = bdlg[objnum].w*sdlgui_fontwidth;\newline	h = bdlg[objnum].h*sdlgui_fontheight;\newline\newline	userfun = (void*)bdlg[objnum].txt;\newline\newline	userfun(x, y, w, h);\newline}\newline","\newline Draw a user object.\newline \newline","5108754","stack.c","fnprocinfo pop_fn(void) {\newline  stack_fn *p = basicvars.stacktop.fnsp;\newline#ifdef DEBUG\newline  if (basicvars.debug_flags.stack) fprintf(stderr, &quotDiscard &#039FN&#039 block at %p, restart = %p\\n&quot, p, p-&gtlastrestart);\newline#endif\newline  basicvars.opstop = p-&gtlastopstop;\newline  basicvars.opstlimit = p-&gtlastopstlimit;\newline  basicvars.local_restart = p-&gtlastrestart;\newline  basicvars.procstack = p-&gtfnprocblock.lastcall;\newline  basicvars.stacktop.bytesp+=ALIGNSIZE(stack_fn);\newline  return p-&gtfnprocblock;\newline}\newline","\newline &#039pop_fn&#039 removes a function return control block from the Basic stack,\newline updating the procedure/function call chain as well\newline \newline","5792594","libfat.c","DWORD get_fstclus(Volume_t *V, DirEntry_t *D) {\newline	DWORD val = 0;\newline	\newline	char *dst = (char *) &ampval;\newline	char *src = (char *) &amp(D-&gtDIR_FstClusLO);\newline	\newline	dst[0] = src[0];\newline	dst[1] = src[1];\newline\newline	if (V-&gtFatType == FAT32) {\newline		src = (char *) &amp(D-&gtDIR_FstClusHI);\newline		dst[2] = src[0];\newline		dst[3] = src[1];\newline	}\newline	\newline	val=EFD(val);\newline	return val;\newline}\newline","get first cluster \newline","3067163","qwt_dial_needle.cpp","void QwtDialNeedle::setPalette(const QPalette &amppalette) \newline{ \newline    d_palette = palette; \newline}\newline","!\newlineSets the palette for the needle.\newline\\param palette New Palette\newline \newline","4835409","suspend.c","extern int slurm_suspend2(char *job_id, job_array_resp_msg_t **resp)\newline{\newline	return _suspend_op2(SUSPEND_JOB, job_id, resp);\newline}\newline","\newline slurm_suspend2 - suspend execution of a job.\newline IN job_id in string form - job on which to perform operation\newline OUT resp - per task response to the request,\newline free using slurm_free_job_array_resp()\newline RET 0 or a slurm error code\newline \newline","5744904","thyme.c","void VGSim_loadFiles(VGSim *vg, List *load_files)\newline{\newline  ListElem *E;\newline\newline  for (E = List_first(load_files);E;E = List_next(load_files,E)) {\newline    const char *fileName = (const char*)ListElem_obj(E);\newline\newline    if (VerilogLoad(fileName) &lt 0) {\newline      errorCmd(ERR_NOREAD,fileName);\newline    }\newline  }\newline}\newline","\newline \newline Load a list of files\newline \newline Parameters:\newline vg The vgsim object\newline load_files List of files to be loaded.\newline \newline \newline","5831478","net.c","void setsock(int sock, int options)\newline{\newline  int i = allocsock(sock, options), parm;\newline  struct threaddata *td = threaddata();\newline\newline  if (i == -1) {\newline    putlog(LOG_MISC, &quot*&quot, &quotSockettable full.&quot);\newline    return;\newline  }\newline  if (((sock != STDOUT) || backgrd) &amp&amp !(td-&gtsocklist[i].flags &amp SOCK_NONSOCK)) {\newline    parm = 1;\newline    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *) &ampparm, sizeof(int));\newline\newline    parm = 0;\newline    setsockopt(sock, SOL_SOCKET, SO_LINGER, (void *) &ampparm, sizeof(int));\newline  }\newline  if (options &amp SOCK_LISTEN) {\newline    /* Tris says this lets us grab the same port again next time */\newline    parm = 1;\newline    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &ampparm, sizeof(int));\newline  }\newline  /* Yay async i/o ! */\newline  fcntl(sock, F_SETFL, O_NONBLOCK);\newline}\newline","Request a normal socket for i/o\newline \newline","5104609","launch.c","static void cmd_parse(char *buf, char **args) {\newlineint i, argnum;\newline\newline	i = argnum = 0;\newline    while ( (i &lt MAXCMDLEN) &amp&amp (buf[i] != 0) ) {\newline\newline        /*\newline         * Strip whitespace.  Use nulls, so\newline         * that the previous argument is terminated\newline         * automatically.\newline         */\newline        while ( (i &lt MAXCMDLEN) &amp&amp ((buf[i] == &#039 &#039) || (buf[i] == &#039\\t&#039)))\newline            buf[i++] = 0;\newline\newline        /*\newline         * Save the argument.\newline         */\newline		if ( argnum &lt MAXARGS ) \newline        	args[argnum++] = &amp(buf[i]);\newline\newline        /*\newline         * Skip over the argument.\newline         */\newline        while ( (i &lt MAXCMDLEN) &amp&amp ((buf[i] != 0) &amp&amp (buf[i] != &#039 &#039) &amp&amp (buf[i] != &#039\\t&#039)))\newline            i++;\newline    }\newline\newline	if ( argnum &lt MAXARGS ) \newline    	args[argnum] = NULL;\newline\newline	if ( (i &gt= MAXCMDLEN) || (argnum &gt= MAXARGS) ) {\newline		// for safety reason, disable the command\newline    	args[0] = NULL;	\newline		syslog(LOG_ERR, &quotLauncher: Unable to parse command: &#039%s&#039&quot, buf);\newline	}\newline\newline} // End of cmd_parse\newline","\newline split the command in buf into individual arguments.\newline \newline","1255717","extent_tree.c","static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,\newline					struct ocfs2_extent_list *el,\newline					struct ocfs2_extent_rec *insert_rec)\newline{\newline	int i;\newline	uint32_t cpos = insert_rec-&gte_cpos;\newline	struct ocfs2_extent_rec *rec;\newline\newline	insert-&gtins_appending = APPEND_NONE;\newline\newline	assert(el-&gtl_tree_depth == 0);\newline\newline	if (!el-&gtl_next_free_rec)\newline		goto set_tail_append;\newline\newline	if (ocfs2_is_empty_extent(&ampel-&gtl_recs[0])) {\newline		/* Were all records empty? */\newline		if (el-&gtl_next_free_rec == 1)\newline			goto set_tail_append;\newline	}\newline\newline	i = el-&gtl_next_free_rec - 1;\newline	rec = &ampel-&gtl_recs[i];\newline\newline	if (cpos &gt= (rec-&gte_cpos + rec-&gte_leaf_clusters))\newline		goto set_tail_append;\newline\newline	return;\newline\newlineset_tail_append:\newline	insert-&gtins_appending = APPEND_TAIL;\newline}\newline","\newline This should only be called against the righmost leaf extent list.\newline \newline ocfs2_figure_appending_type() will figure out whether we&#039ll have to\newline insert at the tail of the rightmost leaf.\newline \newline This should also work against the dinode list for tree&#039s with 0\newline depth. If we consider the dinode list to be the rightmost leaf node\newline then the logic here makes sense.\newline \newline","5071778","script.c","void InitObjTabCase(int HasMainLoop)\newline{\newline if (nbobj==0)\newline {\newline  TabIObj=(Bloc**)safecalloc(1,sizeof(long));\newline  TabCObj=(CaseObj*)safecalloc(1,sizeof(CaseObj));\newline }\newline else\newline {\newline  TabIObj=(Bloc**)realloc(TabIObj,sizeof(long)*(nbobj+1));\newline  TabCObj=(CaseObj*)realloc(TabCObj,sizeof(CaseObj)*(nbobj+1));\newline }\newline\newline if (!HasMainLoop)\newline  TabIObj[nbobj]=NULL;\newline CurrCase=-1;\newline TabCObj[nbobj].NbCase=-1;\newline}\newline","Initialisation pour un objet \newline","327812","service.c","static http_error check_passwd(\newline        const char *username, const char *current_password,\newline        xmlXPathContextPtr xpath_ctx,\newline        char **code, char **pass_message) {\newline    http_error error = HTTP_ERROR_SUCCESS;\newline    char *message = NULL;\newline    char *old_password = NULL, *new_password = NULL;\newline    size_t length;\newline\newline    if (NULL == username || NULL == current_password ||\newline            NULL == code || NULL == pass_message) {\newline        return HTTP_ERROR_SERVER;\newline    }\newline\newline    *code = &quot9999&quot;\newline\newline\newline    /* Parse request */\newline    EXTRACT_STRING(&quotisds:dbOldPassword&quot, old_password);\newline    if (NULL == old_password) {\newline        message = strdup(&quotEmpty isds:dbOldPassword&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline    EXTRACT_STRING(&quotisds:dbNewPassword&quot, new_password);\newline    if (NULL == new_password) {\newline        message = strdup(&quotEmpty isds:dbOldPassword&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    /* Check defined cases */\newline    if (strcmp(current_password, old_password)) {\newline        *code = &quot1090&quot;\newline        message = strdup(&quotBad current password&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    length = strlen(new_password);\newline\newline    if (length &lt 8 || length &gt 32) {\newline        *code = &quot1066&quot;\newline        message = strdup(&quotToo short or too long&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    {\newline        const char lower[] = &quotabcdefghijklmnopqrstuvwxyz&quot;\newline        const char upper[] = &quotABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\newline        const char digit[] = &quot0123456789&quot;\newline        const char special[] = &quot!#$%&amp()*+,-.:=?@[]_{}|~&quot;\newline        _Bool has_lower = 0, has_upper = 0, has_digit=0;\newline\newline        for (size_t i = 0; i &lt length; i++) {\newline            if (NULL != strchr(lower, new_password[i]))\newline                has_lower = 1;\newline            else if (NULL != strchr(upper, new_password[i]))\newline                has_upper = 1;\newline            else if (NULL != strchr(digit, new_password[i]))\newline                has_digit = 1;\newline            else if (NULL == strchr(special, new_password[i])) {\newline                *code = &quot1079&quot;\newline                message = strdup(&quotPassword contains forbidden character&quot);\newline                error = HTTP_ERROR_CLIENT;\newline                goto leave;\newline            }\newline        }\newline\newline        if (!has_lower || !has_upper || !has_digit) {\newline            *code = &quot1080&quot;\newline            message = strdup(&quotPassword does not contain lower cased letter, &quot\newline                    &quotupper cased letter and a digit&quot);\newline            error = HTTP_ERROR_CLIENT;\newline            goto leave;\newline        }\newline    }\newline\newline    if (!strcmp(old_password, new_password)) {\newline        *code = &quot1067&quot;\newline        message = strdup(&quotNew password same as current one&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    if (NULL != strstr(new_password, username)) {\newline        *code = &quot1082&quot;\newline        message = strdup(&quotNew password contains user ID&quot);\newline        error = HTTP_ERROR_CLIENT;\newline        goto leave;\newline    }\newline\newline    for (size_t i = 0; i &lt length - 2; i++) {\newline        if (new_password[i] == new_password[i+1] &amp&amp\newline                new_password[i] == new_password[i+2]) {\newline            *code = &quot1083&quot;\newline            message = strdup(&quotPassword contains sequence &quot\newline                    &quotof three identical characters&quot);\newline            error = HTTP_ERROR_CLIENT;\newline            goto leave;\newline        }\newline    }\newline    \newline    {\newline        const char *forbidden_prefix[] = { &quotqwert&quot, &quotasdgf&quot, &quot12345&quot };\newline        for (size_t i = 0; i &lt sizeof(forbidden_prefix)/sizeof(*forbidden_prefix);\newline                i++) {\newline            if (!strncmp(new_password, forbidden_prefix[i],\newline                        strlen(forbidden_prefix[i]))) {\newline                *code = &quot1083&quot;\newline                message = strdup(&quotPassword has forbidden prefix&quot);\newline                error = HTTP_ERROR_CLIENT;\newline                goto leave;\newline            }\newline        }\newline    }\newline\newline    *code = &quot0000&quot;\newline    message = strdup(&quotSuccess&quot);\newlineleave:\newline    free(old_password);\newline    free(new_password);\newline    *pass_message = message;\newline    return error;\newline}\newline","Common part for ChangeISDSPassword and ChangePasswordOTP.\newline @code is output pointer to static string\newline @pass_message is output pointer to auto-allocated string\newline @arguments is pointer to struct arguments_DS_DsManage_ChangeISDSPassword \newline","2642779","surface.c","GSList * gts_surface_split (GtsSurface * s)\newline{\newline  gpointer data[2];\newline  GSList * components = NULL;\newline\newline  g_return_val_if_fail (s != NULL, NULL);\newline\newline  data[0] = s;\newline  data[1] = &ampcomponents;\newline\newline  /* boundary components */\newline  gts_surface_foreach_edge (s, (GtsFunc) traverse_boundary, data);\newline\newline  /* remaining components */\newline  gts_surface_foreach_face (s, (GtsFunc) traverse_remaining, data);\newline\newline  return components;\newline}\newline","\newline gts_surface_split:\newline @s: a #GtsSurface.\newline \newline Splits a surface into connected and manifold components.\newline \newline Returns: a list of new #GtsSurface.\newline \newline","5981333","cre_jnl_file.c","uint4	cre_jnl_file(jnl_create_info *info)\newline{\newline	mstr 		filestr;\newline	int 		org_fn_len, rename_fn_len, fstat;\newline	char		*org_fn, rename_fn[MAX_FN_LEN];\newline	boolean_t	no_rename;\newline\newline	assert(0 != jgbl.gbl_jrec_time);\newline	if (!info-&gtno_rename)	/* ***MAYBE*** rename is required */\newline	{\newline		no_rename = FALSE;\newline		if (SS_NORMAL != (info-&gtstatus = prepare_unique_name((char *)info-&gtjnl, info-&gtjnl_len, &quot&quot, &quot&quot,\newline				rename_fn, &amprename_fn_len, jgbl.gbl_jrec_time, &ampinfo-&gtstatus2)))\newline		{\newline			no_rename = TRUE;\newline		} else\newline		{\newline			filestr.addr = (char *)info-&gtjnl;\newline			filestr.len = info-&gtjnl_len;\newline			if (FILE_PRESENT != (fstat = gtm_file_stat(&ampfilestr, NULL, NULL, FALSE, (uint4 *)&ampinfo-&gtstatus)))\newline			{\newline				if (FILE_NOT_FOUND != fstat)\newline				{\newline					STATUS_MSG(info);\newline					return EXIT_ERR;\newline				}\newline				if (IS_GTM_IMAGE)\newline					send_msg_csa(CSA_ARG(info-&gtcsa) VARLSTCNT(4) ERR_JNLFNF, 2, filestr.len, filestr.addr);\newline				else\newline					gtm_putmsg_csa(CSA_ARG(info-&gtcsa) VARLSTCNT(4) ERR_JNLFNF, 2, filestr.len, filestr.addr);\newline				no_rename = TRUE;\newline			}\newline			/* Note if info-&gtno_prev_link == TRUE, we do not keep previous link, though rename can happen */\newline			if (JNL_ENABLED(info) &amp&amp !info-&gtno_prev_link)\newline			{\newline				memcpy(info-&gtprev_jnl, rename_fn, rename_fn_len + 1);\newline				info-&gtprev_jnl_len = rename_fn_len;\newline			} else\newline				assert(info-&gtno_prev_link);\newline		}\newline		if (no_rename)\newline		{\newline			STATUS_MSG(info);\newline			info-&gtstatus = info-&gtstatus2 = SS_NORMAL;\newline			info-&gtno_rename = TRUE; /* We wanted to rename, but not required anymore */\newline			info-&gtno_prev_link = TRUE;	/* No rename =&gt no prev_link */\newline		}\newline	} /* else we know for sure rename is not required */\newline	return (cre_jnl_file_common(info, rename_fn, rename_fn_len));\newline}\newline","Create a journal file from info.\newline If necessary, it renames journal file of same name.\newline Note: jgbl.gbl_jrec_time must be set by callers\newline \newline","2760461","cpick.c","static void cpick_area_update_cursors(cpicker *cp)\newline{\newline	int x, y, l;\newline\newline	l = cp-&gtarea_size[CPICK_AREA_PICKER][0] - 1;\newline	x = (cp-&gtinput_vals[CPICK_INPUT_VALUE] * l + l - 1) / 255;\newline	l = cp-&gtarea_size[CPICK_AREA_PICKER][1] - 1;\newline	y = ((255 - cp-&gtinput_vals[CPICK_INPUT_SATURATION]) * l + l - 1) / 255;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_PICKER], x, y);\newline\newline	x = cp-&gtarea_size[CPICK_AREA_HUE][0] / 2;\newline	l = cp-&gtarea_size[CPICK_AREA_HUE][1] - 1;\newline	y = ((1529 - cp-&gtinput_vals[CPICK_INPUT_HUE]) * l + l - 1) / 1529;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_HUE], x, y);\newline\newline	x = cp-&gtarea_size[CPICK_AREA_OPACITY][0] / 2;\newline	l = cp-&gtarea_size[CPICK_AREA_OPACITY][1] - 1;\newline	y = ((255 - cp-&gtinput_vals[CPICK_INPUT_OPACITY]) * l + l - 1) / 255;\newline	wjpixmap_move_cursor(cp-&gtareas[CPICK_AREA_OPACITY], x, y);\newline}\newline","These formulas perfectly reverse ones in cpick_area_mouse() when possible;\newline however, for sizes &gt 255 it&#039s impossible in principle - WJ \newline","4361184","background.c","void _dxf_ExBackgroundRedo (void)\newline{\newline    _dxf_ExVCRRedo();\newline\newline    if (! background.tree)\newline	return;\newline\newline    if (background.graph != NULL)\newline    {\newline	_dxf_ExGraphDelete(background.graph);\newline	background.graph = NULL;\newline    }\newline\newline    background.change = TRUE;\newline}\newline","\newline Called whenever a macro is redefined.\newline \newline","5182537","modexlib.c","void VL_CopyPlanarPageToMemory ( byte * src, byte * dest )\newline{\newline   byte * ptr;\newline   int plane,a,b;\newline\newline   for (plane=0;plane&lt4;plane++)\newline      {\newline      ptr=dest+plane;\newline      VGAREADMAP(plane);\newline      for (a=0;a&lt200;a++)\newline         for (b=0;b&lt80;b++,ptr+=4)\newline            *(ptr)=*(src+(a*linewidth)+b);\newline      }\newline}\newline","\newline=======================\newline=\newline= VL_CopyPlanarPageToMemory\newline=\newline=======================\newline \newline","2204935","psf.c","void	psf_makeresi(psfstruct *psf, setstruct *set, int centflag,\newline		double prof_accuracy)\newline  {\newline   samplestruct		*sample;\newline   static double	pos[MAXCONTEXT], amat[9], bmat[3];\newline   double		*dresi, *dresit, *amatt,\newline			*cvigx,*cvigxt, *cvigy,*cvigyt,\newline			nm1, chi2, dx,dy, ddx,ddy, dval,dvalx,dvaly,dwval,\newline			radmin2,radmax2, hcw,hch, yb, mx2,my2,mxy,\newline			xc,yc,rmax2,x,y, mse, xi2, xyi, resival, resinorm;\newline   float		*vigresi, *vig, *vigw, *fresi,*fresit, *vigchi,\newline			*cbasis,*cbasist, *cdata,*cdatat, *cvigw,*cvigwt,\newline			norm, fval, vigstep, psf_extraccu2, wval, sval;\newline   int			i,j,n,ix,iy, ndim,npix,nsample, cw,ch,ncpix, okflag,\newline			accuflag, nchi2;\newline\newline  accuflag = (prof_accuracy &gt 1.0/BIG);\newline  vigstep = 1/psf-&gtpixstep;\newline  nsample = set-&gtnsample;\newline  npix = set-&gtvigsize[0]*set-&gtvigsize[1];\newline  ndim = psf-&gtpoly-&gtndim;\newline  QCALLOC(dresi, double, npix);\newline\newline  if (centflag)\newline    {\newline/*-- Compute Centering sub-vignet size (containing most of the signal) */\newline    cw=ch=(int)(2*set-&gtfwhm+1.0);\newline    if (cw&gtset-&gtvigsize[0])\newline      cw=set-&gtvigsize[0];\newline    if (ch&gtset-&gtvigsize[1])\newline      ch=set-&gtvigsize[1];\newline/*-- Allocate memory for the sub-vignet */\newline    ncpix = cw*ch;\newline    QMALLOC(cdata, float, ncpix);\newline    QMALLOC(cbasis, float, ncpix);\newline    QMALLOC(cvigw, float, ncpix);\newline    QMALLOC(cvigx, double, ncpix);\newline    QMALLOC(cvigy, double, ncpix);\newline/*-- Initialize gradient image */\newline    hcw = (double)(cw/2);\newline    hch = (double)(ch/2);\newline    cvigxt = cvigx;\newline    cvigyt = cvigy;\newline    for (iy=0; iy&ltch; iy++)\newline      {\newline      yb = iy-hch;\newline      for (ix=0; ix&ltcw; ix++)\newline        {\newline        *(cvigxt++) = ix-hcw;\newline        *(cvigyt++) = yb;\newline        }\newline      }\newline    }\newline  else\newline    {\newline    cvigx = cvigy = (double *)NULL;	/* To avoid gcc -Wall warnings */\newline    cbasis = cdata = cvigw = (float *)NULL;	/* ditto */\newline    cw = ch = ncpix = 0;			/* ibid */\newline    }\newline\newline/* Set convergence boundaries */\newline  radmin2 = PSF_MINSHIFT*PSF_MINSHIFT;\newline  radmax2 = PSF_MAXSHIFT*PSF_MAXSHIFT;\newline  okflag = nchi2 = 0;\newline  mse = 0.0; 				/* To avoid gcc -Wall warnings */\newline\newline/* Compute the chi2 */\newline  for (sample=set-&gtsample, n=nsample; n--; sample++)\newline    {\newline/*-- Build the local PSF */\newline    for (i=0; i&ltndim; i++)\newline      pos[i] = (sample-&gtcontext[i]-set-&gtcontextoffset[i])\newline		/set-&gtcontextscale[i];\newline    psf_build(psf, pos);\newline\newline/*-- Delta-x and Delta-y in vignet-pixel units */\newline    dx = sample-&gtdx;\newline    dy = sample-&gtdy;\newline\newline    if (centflag)\newline      {\newline/*---- Copy the data into the sub-vignet */\newline      vignet_copy(sample-&gtvig, set-&gtvigsize[0], set-&gtvigsize[1],\newline		cdata, cw,ch, 0,0, VIGNET_CPY);\newline/*---- Weight the data */\newline      vignet_copy(sample-&gtvigweight, set-&gtvigsize[0], set-&gtvigsize[1],\newline		cvigw, cw,ch, 0,0, VIGNET_CPY);\newline\newline      for (cdatat=cdata, cvigwt=cvigw, i=ncpix; i--;)\newline        *(cdatat++) *= *(cvigwt++);\newline\newline      for (j=0; j&ltPSF_NITER; j++)\newline        {\newline/*------ Map the PSF model at the current position */\newline        vignet_resample(psf-&gtloc, psf-&gtsize[0], psf-&gtsize[1],\newline		cbasis, cw,ch, -dx*vigstep, -dy*vigstep, vigstep, 1.0);\newline\newline/*------ Build the a and b matrices */\newline        memset(amat, 0, 9*sizeof(double));\newline        bmat[0] = bmat[1] = bmat[2] = mx2=my2=mxy = 0.0;\newline        for (cvigxt=cvigx,cvigyt=cvigy,cvigwt=cvigw,\newline		cbasist=cbasis,cdatat=cdata, i=ncpix; i--;)\newline          {\newline          dval = (double)*(cbasist++);\newline          bmat[0] += (dwval = dval*(double)*(cdatat++));\newline          bmat[1] += dwval*(dvalx = *(cvigxt++) - dx);\newline          bmat[2] += dwval*(dvaly = *(cvigyt++) - dy);\newline          mx2 += dval*dvalx*dvalx;\newline          my2 += dval*dvaly*dvaly;\newline          mxy += dval*dvalx*dvaly;\newline          amatt=amat;\newline          *(amatt++) += (dval *= dval*(double)*(cvigwt++));\newline          *(amatt++) += dval*dvalx;\newline          *(amatt++) += dval*dvaly;\newline          *(++amatt) += dval*dvalx*dvalx;\newline          *(++amatt) += dval*dvalx*dvaly;\newline          *(amatt+3) += dval*dvaly*dvaly;\newline          }\newline\newline/*------ Solve the system */\newline#if defined(HAVE_LAPACKE)\newline #ifdef MATSTORAGE_PACKED\newline        if (LAPACKE_dppsv(LAPACK_COL_MAJOR,&#039L&#039,3,1,amat,bmat,3) != 0)\newline #else\newline        if (LAPACKE_dposv(LAPACK_COL_MAJOR,&#039L&#039,3,1,amat,3,bmat,3) != 0)\newline #endif\newline#else\newline        if (clapack_dposv(CblasRowMajor,CblasUpper,3,1,amat,3,bmat,3) != 0)\newline#endif\newline          warning(&quotNot a positive definite matrix&quot, &quot in PSF model solver&quot);\newline\newline/*------ Convert to a shift */\newline        dx += 0.5*(ddx = (bmat[1]*mx2 + bmat[2]*mxy) / bmat[0]); \newline        dy += 0.5*(ddy = (bmat[2]*my2 + bmat[1]*mxy) / bmat[0]); \newline/*------ Exit if it converges or diverges */\newline        if (ddx*ddx+ddy*ddy &lt radmin2)\newline          {\newline          okflag = 1;\newline          break;\newline	  }\newline        else if (dx*dx+dy*dy &gt radmax2)\newline          break;\newline        }\newline      if (okflag)\newline        {\newline        sample-&gtdx = dx;\newline        sample-&gtdy = dy;\newline        }\newline      }\newline\newline\newline/*-- Map the PSF model at the current position */\newline    vignet_resample(psf-&gtloc, psf-&gtsize[0], psf-&gtsize[1],\newline	sample-&gtvigresi, set-&gtvigsize[0], set-&gtvigsize[1],\newline	-dx*vigstep, -dy*vigstep, vigstep, 1.0);\newline/*-- Fit the flux */\newline    xi2 = xyi = 0.0;\newline    for (cvigwt=sample-&gtvigweight,cbasist=sample-&gtvigresi,cdatat=sample-&gtvig,\newline	i=npix; i--;)\newline      {\newline      dwval = *(cvigwt++);\newline      dval = (double)*(cbasist++);\newline      xi2 += dwval*dval*dval;\newline      xyi += dwval*dval*(double)*(cdatat++);\newline      }\newline\newline    norm = (xi2&gt0.0)? xyi/xi2 : sample-&gtnorm;\newline\newline/*-- Subtract the PSF model and compute Chi2 */\newline    chi2 = mse = resival = resinorm = 0.0;\newline    dresit = dresi;\newline    psf_extraccu2 = prof_accuracy*prof_accuracy*norm*norm;\newline    xc = (double)(set-&gtvigsize[0]/2)+sample-&gtdx;\newline    yc = (double)(set-&gtvigsize[1]/2)+sample-&gtdy;\newline    y = -yc;\newline    rmax2 = psf-&gtpixstep*(psf-&gtsize[0]&ltpsf-&gtsize[1]?\newline		(double)(psf-&gtsize[0]/2) : (double)(psf-&gtsize[1]/2));\newline    rmax2 *= rmax2;\newline    nchi2 = 0;\newline    vig = sample-&gtvig;\newline    vigw = sample-&gtvigweight;\newline    vigresi=sample-&gtvigresi;\newline    vigchi = sample-&gtvigchi;\newline    for (iy=set-&gtvigsize[1]; iy--; y+=1.0)\newline      {\newline      x = -xc;\newline#pragma ivdep\newline      for (ix=set-&gtvigsize[0]; ix--; x+=1.0, vig++, vigresi++, dresit++,\newline						vigchi++)\newline        {\newline        *vigchi = 0;\newline        if ((wval=*(vigw++))&gt0.0)\newline          {\newline          if (accuflag)\newline            wval = 1.0/(1.0 / wval + psf_extraccu2**vigresi**vigresi);\newline          *vigresi = fval = (*vig-*vigresi*norm);\newline          if (x*x+y*y&ltrmax2)\newline            {\newline            mse += fval*fval;\newline            nchi2++;\newline            chi2 += (double)(*vigchi=wval*fval*fval);\newline            *dresit += fval;\newline            sval = *vig+*vigresi*norm;\newline            resival += sval*fabsf(fval);\newline            resinorm += sval*sval;\newline            }\newline          }\newline        }\newline      }\newline\newline    sample-&gtchi2 = (nchi2&gt 1)? chi2/(nchi2-1) : chi2;\newline    sample-&gtmodresi = (resinorm &gt 0.0)? 2.0*resival/resinorm : resival;\newline    }\newline\newline/* Normalize and convert to floats the Residual array */\newline  mse = sqrt(mse/nsample/nchi2);\newline/*printf(&quot%g\\n&quot, mse);*/\newline  QMALLOC(fresi, float, npix); \newline  nm1 = nsample &gt 1?  (double)(nsample - 1): 1.0;\newline  for (dresit=dresi,fresit=fresi, i=npix; i--;)\newline      *(fresit++) = sqrt(*(dresit++)/nm1);\newline\newline/*-- Map the residuals to PSF coordinates */\newline  vignet_resample(fresi, set-&gtvigsize[0], set-&gtvigsize[1],\newline	psf-&gtresi, psf-&gtsize[0], psf-&gtsize[1], 0.0,0.0, psf-&gtpixstep, 1.0);\newline\newline/* Free memory */\newline  free(dresi);\newline  free(fresi);\newline  if (centflag)\newline    {\newline    free(cvigx);\newline    free(cvigy);\newline    free(cvigw);\newline    free(cbasis);\newline    free(cdata);\newline    }\newline\newline  return;\newline  }\newline","psf_makeresi \newlinePROTO void psf_makeresi(psfstruct psf, setstruct set, int centflag,\newline double prof_accuracy)\newlinePURPOSE Compute PSF residuals.\newlineINPUT Pointer to the PSF,\newline Pointer to the sample set,\newline Re-centering flag (0=no),\newline PSF accuracy parameter.\newlineOUTPUT -.\newlineNOTES -.\newlineAUTHOR E. Bertin (IAP)\newlineVERSION 10/07/2012\newline \newline","on","","","","","","on","","","on","on","on","on","","on","","","","","","","","","","","","","","","on","","","","","","","","","on","","","","{}","Load a list of files","Request a normal socket for i/o","split the command in buf into individual arguments.","insert at the tail of the rightmost leaf.","Initialisation pour un objet","{}","Splits a surface into connected and manifold components.","Create a journal file from info.","{}","{}","{}","{}","Compute PSF residuals.","{}","Extract third-party traffic from information field","Draw a user object.","removes a function return control block from the Basic stack,","get first cluster","Sets the palette for the needle.","suspend execution of a job."
"33W1NHWFYHL57K73QURTG9WCO61TZP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","33C7UALJVLYR1OR05NC7M2C2D2M186","A3DBG3IETULYCN","Approved","Wed Apr 17 15:22:01 PDT 2019","Wed Apr 17 15:26:03 PDT 2019","Fri Apr 19 15:26:03 PDT 2019","2019-04-19 22:26:21 UTC","","","242","100% (37/37)","100% (37/37)","100% (37/37)","277763","read-filter-redact.c","static rc_t SpotIteratorReadLine(SpotIterator* self)\newline{\newline    rc_t rc = 0;\newline    bool overflow = false; /* input buffer overflow */\newline\newline    /* to skip leading/traling spaces */\newline    enum ELane {\newline        eBefore,\newline        eIn,\newline        eAfter\newline    } state = eBefore;\newline\newline    if (self-&gteof) {\newline        return rc;\newline    }\newline\newline    assert(self);\newline\newline    ++self-&gtline;\newline    self-&gtinBuffer = 0;\newline\newline    while (!overflow &amp&amp !self-&gteof) /* do until in-buffer overflow or EOF*/{\newline        char ch = 0;\newline        /* get next characted */\newline        if ((rc = SpotIteratorFileReadCharWithEof(self, &ampch)) != 0) {\newline            return rc;\newline        }\newline\newline        if (!self-&gteof) {\newline            /* treat leading/trailing spaces */\newline            switch (state) {\newline                /* skip leading spaces */\newline                case eBefore:\newline                    if (isblank(ch)) {\newline                        continue;\newline                    }\newline                    else {\newline                        state = eIn;\newline                    }\newline                    break;\newline                case eIn:\newline                    if (isblank(ch)) {\newline                        state = eAfter;\newline                        continue;\newline                    }\newline                    break;\newline                /* skip trailing spaces */\newline                case eAfter:\newline                    if (isblank(ch)) {\newline                        continue;\newline                    }\newline                    else if (ch != &#039\\n&#039 &amp&amp ch != &#039\\r&#039) {\newline                        rc = RC(rcExe, rcFile, rcReading, rcChar, rcUnexpected);\newline                        PLOGERR(klogErr, (klogErr, rc, &quotbad symbol &#039$(char)&#039 &quot\newline                            &quoton line $(lineno) in file &#039$(path)&#039: &#039$(line)...&#039&quot,\newline                            &quotchar=%c,&quot PLOG_U64(lineno) &quot,path=%s,line=%s&quot,\newline                            ch, self-&gtline, self-&gtfilename, self-&gtbuffer))\newline                        ;\newline                        return rc;\newline                    }\newline                    break;\newline            }\newline\newline            /* add next non-blank characted */\newline            overflow = !SpotIteratorBufferAdd(self, ch);\newline            if (!overflow) {\newline      /* all combinations as &quot\\r&quot, &quot\\n&quot, &quot\\r\\n&quot, &quot\\n\\r&quot are considered as EOL */\newline                if (ch == &#039\\n&#039 || ch == &#039\\r&#039) {\newline                    char c1 = 0;\newline                    if ((rc = SpotIteratorFileReadCharWithEof(self, &ampc1)) != 0)\newline                    {\newline                        return rc;\newline                    }\newline                    if (self-&gteof) {\newline                        break;\newline                    }\newline                    else if ((c1 != &#039\\n&#039 &amp&amp c1 != &#039\\r&#039) || (ch == c1)) {\newline       /* save the character when EOL is a single character (WINDOWS):\newline          will be get back in SpotIteratorFileReadCharWithEof */\newline                        self-&gtch = c1;\newline                        self-&gthasCh = true;\newline                        break;\newline                    }\newline                    else {\newline                        overflow = !SpotIteratorBufferAdd(self, c1);\newline                        break;\newline                    }\newline                }\newline            }\newline        }\newline    }\newline\newline    /* remove EOL */\newline    if (!overflow) {\newline        bool done = false;\newline\newline        while (self-&gtinBuffer &gt 0 &amp&amp !done) {\newline            switch (self-&gtbuffer[self-&gtinBuffer - 1]) {\newline                case &#039\\n&#039: case &#039\\r&#039:\newline                    self-&gtbuffer[--self-&gtinBuffer] = &#039\\0&#039;\newline                    break;\newline                default:\newline                    done = true;\newline                    break;\newline            }\newline        }\newline    }\newline    else {\newline        rc = RC(rcExe, rcFile, rcReading, rcString, rcTooLong);\newline        PLOGERR(klogErr, (klogErr, rc,\newline            &quoton line $(lineno) while reading file &#039$(path)&#039: &#039$(line)...&#039&quot,\newline            PLOG_U64(lineno) &quot,path=%s,line=%s&quot,\newline            self-&gtline, self-&gtfilename, self-&gtbuffer));\newline    }\newline\newline    return rc;\newline}\newline","Read a line from input file \newline","2973580","dvb_ecmg.c","static void build_ecm(stream_t *p_stream, uint16_t i_cp_number,\newline                      uint8_t * const ppi_cw[2],\newline                      uint8_t *p_accesscrit_param)\newline{\newline    /* you will want to customize this function */\newline    static const uint8_t pi_xor[8] =\newline        {0x42, 0x12, 0x02, 0x24, 0x21, 0x20, 0x66, 0x88};\newline    PSI_DECLARE(p_section);\newline    uint8_t *pi_ecm;\newline    int i, j;\newline\newline    psi_init(p_section, false);\newline    psi_set_tableid(p_section, 0x80 | (i_cp_number &amp 0x1));\newline    psi_set_length(p_section, 16);\newline\newline    pi_ecm = p_section + 3;\newline    for (i = 0; i &lt 2; i++)\newline        for (j = 0; j &lt 8; j++)\newline            pi_ecm[i * 8 + j] = ppi_cw[i][j] ^ pi_xor[j];\newline\newline    send_ecm(p_stream, i_cp_number, p_section,\newline             psi_get_length(p_section) + PSI_HEADER_SIZE);\newline}\newline","\newline build_ecm\newline \newline","1886670","libtcc.c","LIBTCCAPI void tcc_define_symbol(TCCState *s1, const char *sym, const char *value)\newline{\newline    int len1, len2;\newline    /* default value */\newline    if (!value)\newline        value = &quot1&quot;\newline    len1 = strlen(sym);\newline    len2 = strlen(value);\newline\newline    /* init file structure */\newline    tcc_open_bf(s1, &quot&ltdefine&gt&quot, len1 + len2 + 1);\newline    memcpy(file-&gtbuffer, sym, len1);\newline    file-&gtbuffer[len1] = &#039 &#039;\newline    memcpy(file-&gtbuffer + len1 + 1, value, len2);\newline\newline    /* parse with define parser */\newline    ch = file-&gtbuf_ptr[0];\newline    next_nomacro();\newline    parse_define();\newline\newline    tcc_close();\newline}\newline","define a preprocessor symbol. A value can also be provided with the &#039=&#039 operator \newline","155690","irc_log.c","static struct logfile *_irclog_getlog(struct ircproxy *p, const char *to) {\newline  struct ircchannel *c;\newline  \newline  if (!to)\newline    return 0;\newline\newline  c = ircnet_fetchchannel(p, to);\newline  if (c) {\newline    return &amp(c-&gtlog);\newline  } else {\newline    return &amp(p-&gtother_log);\newline  }\newline}\newline","Get a log file structure out of an ircproxy \newline","4223768","ao_sndio.c","static int init(int rate, int channels, int format, int flags)\newline{\newline    int bpf;\newline\newline    hdl = sio_open(SIO_DEVANY, SIO_PLAY, 0);\newline    if (hdl == NULL) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: can&#039t open sndio\\n&quot);\newline        return 0;\newline    }\newline    sio_initpar(&amppar);\newline    par.bits = af_fmt2bits(format);\newline    par.bps = (par.bits + 7) &gt&gt 3;\newline    // normally bits == 8*bps so this makes no difference\newline    // but we can support more formats for msb == 1, see &quotif&quot below\newline    par.msb = 1;\newline    par.sig = (format &amp AF_FORMAT_SIGN_MASK) == AF_FORMAT_SI;\newline    if (par.bits &gt 8)\newline        par.le = (format &amp AF_FORMAT_END_MASK) == AF_FORMAT_LE;\newline    par.rate = rate;\newline    par.pchan = channels;\newline    par.appbufsz = par.rate * 250 / 1000;    /* 250ms buffer */\newline    par.round = par.rate * 10 / 1000;        /*  10ms block size */\newline    if (!sio_setpar(hdl, &amppar)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t set params\\n&quot);\newline        goto err_out;\newline    }\newline    if (!sio_getpar(hdl, &amppar)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t get params\\n&quot);\newline        goto err_out;\newline    }\newline    // we do not care if LSBs are discarded\newline    if (par.bits &lt 8 * par.bps &amp&amp !par.msb) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: unsupported format\\n&quot);\newline        goto err_out;\newline    }\newline    pfds = calloc(sio_nfds(hdl), sizeof(*pfds));\newline    if (pfds == NULL) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t allocate poll fds\\n&quot);\newline        goto err_out;\newline    }\newline    bpf = par.bps * par.pchan;\newline    ao_data.format = af_bits2fmt(8 * par.bps);\newline    ao_data.format |= par.sig ? AF_FORMAT_SI : AF_FORMAT_US;\newline    ao_data.format |= par.le ? AF_FORMAT_LE : AF_FORMAT_BE;\newline    ao_data.channels = par.pchan;\newline    ao_data.bps = bpf * par.rate;\newline    ao_data.buffersize = par.bufsz * bpf;\newline    ao_data.outburst = par.round * bpf;\newline    ao_data.samplerate = rate;\newline    havevol = sio_onvol(hdl, volcb, NULL);\newline    sio_onmove(hdl, movecb, NULL);\newline\newline    /*\newline     * prepare the device to start. It will start as soon there&#039s enough\newline     * data in the buffer to not underrun\newline     */\newline    delay = 0;\newline    if (!sio_start(hdl)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: init: couldn&#039t start\\n&quot);\newline        goto err_out;\newline    }\newline    return 1;\newlineerr_out:\newline    free(pfds);\newline    pfds = NULL;\newline    sio_close(hdl);\newline    hdl = NULL;\newline    return 0;\newline}\newline","\newline open device and setup parameters\newline return: 1 = success, 0 = failure\newline \newline","6443309","display.c","static void display_set_line (char *string, int line, char *tag)\newline{\newline	char 		*separator_string;\newline	GtkTextIter	start;\newline\newline	/* at first clear the result field */\newline	display_delete_line (buffer, line, &ampstart);\newline	\newline	separator_string = string_add_separator(string, get_sep(current_status.number), \newline		get_sep_length(current_status.number), get_sep_char(current_status.number), dec_point[0]);\newline	/* DISPLAY RESULT MODIFIED */\newline	gtk_text_buffer_insert_with_tags_by_name (buffer, &ampstart, separator_string, -1, tag, NULL);\newline	g_free (separator_string);\newline	if (line == display_result_line) {\newline		display_result_counter = strlen (string);\newline		/* this is some cosmetics. try to keep counter up2date */\newline		if (strchr (string, &#039e&#039) != NULL) {\newline			display_result_counter -= (strchr(string, &#039e&#039) + sizeof(char) - string)/sizeof(char);\newline			display_result_counter += get_display_number_length(current_status.number) - DISPLAY_RESULT_E_LENGTH - 1;\newline		}\newline		else if (strchr (string, dec_point[0]) != NULL) display_result_counter--;\newline	}\newline}\newline","these is the most basic routine. all functions here finally result in a call\newline to this.\newline \newline","5821228","libiscsi.c","void iscsi_session_teardown(struct iscsi_cls_session *cls_session)\newline{\newline	struct iscsi_session *session = cls_session-&gtdd_data;\newline	struct module *owner = cls_session-&gttransport-&gtowner;\newline	struct Scsi_Host *shost = session-&gthost;\newline\newline	iscsi_pool_free(&ampsession-&gtcmdpool);\newline\newline	kfree(session-&gtpassword);\newline	kfree(session-&gtpassword_in);\newline	kfree(session-&gtusername);\newline	kfree(session-&gtusername_in);\newline	kfree(session-&gttargetname);\newline	kfree(session-&gtinitiatorname);\newline	kfree(session-&gtifacename);\newline\newline	iscsi_destroy_session(cls_session);\newline	iscsi_host_dec_session_cnt(shost);\newline	module_put(owner);\newline}\newline","\newline iscsi_session_teardown - destroy session, host, and cls_session\newline @cls_session: iscsi session\newline \newline The driver must have called iscsi_remove_session before\newline calling this.\newline \newline","46438","ssmtp.c","void log_event(int priority, char *format, ...)\newline{\newline	char buf[(BUF_SZ + 1)];\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	(void)vsnprintf(buf, BUF_SZ, format, ap);\newline	va_end(ap);\newline\newline#ifdef LOGFILE\newline	FILE *fp;\newline\newline	if((fp = fopen(&quot/tmp/ssmtp.log&quot, &quota&quot)) != (FILE *)NULL) {\newline		(void)fprintf(fp, &quot%s\\n&quot, buf);\newline		(void)fclose(fp);\newline	}\newline	else {\newline		(void)fprintf(stderr, &quotCan&#039t write to /tmp/ssmtp.log\\n&quot);\newline	}\newline#endif\newline\newline#if HAVE_SYSLOG_H\newline#if OLDSYSLOG\newline	openlog(&quotsSMTP&quot, LOG_PID);\newline#else\newline	openlog(&quotsSMTP&quot, LOG_PID, LOG_MAIL);\newline#endif\newline	syslog(priority, &quot%s&quot, buf);\newline	closelog();\newline#endif\newline}\newline","\newlinelog_event() -- Write event to syslog (or log file if defined)\newline \newline","3280094","readline.c","static int do_readline_save_history(ReadLine *readp)\newline{\newline    int i, offset, start, length;\newline    LineBuffer *linep;\newline    FILE *filep;\newline\newline    if(*readp-&gtfilename == 0)\newline        return -1;\newline    if((filep = fopen(readp-&gtfilename, &quotw&quot)) == NULL)\newline        return -1;\newline\newline    offset = readp-&gtoffset;\newline    start = readp-&gtstart;\newline    length = readp-&gtlength;\newline    for(i = 0; i &lt length; i++) {\newline        linep = readp-&gthistory + ((start + i) % MAX_HISTORY_LENGTH);\newline        linep-&gtbuffer[linep-&gtlength] = 0;\newline        fprintf(filep, &quot%5d %s\\n&quot, offset + i, linep-&gtbuffer);\newline    }\newline\newline    fclose(filep);\newline    return 0;\newline}\newline","\newline Save the history to a file.\newline \newline","4514098","wap_push_pap_compiler.c","static int parse_state(Octstr *attr_value)\newline{\newline    long attr_as_number;\newline\newline    attr_as_number = -2;\newline    if (octstr_case_compare(attr_value, octstr_imm(&quotundeliverable&quot)) == 0)\newline        attr_as_number = PAP_UNDELIVERABLE; \newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotpending&quot)) == 0)\newline        attr_as_number = PAP_PENDING; \newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotexpired&quot)) == 0)\newline        attr_as_number = PAP_EXPIRED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotdelivered&quot)) == 0)\newline        attr_as_number = PAP_DELIVERED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotaborted&quot)) == 0)\newline        attr_as_number = PAP_ABORTED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quottimeout&quot)) == 0)\newline        attr_as_number = PAP_TIMEOUT;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotcancelled&quot)) == 0)\newline        attr_as_number = PAP_CANCELLED;\newline    else \newline         warning(0, &quotillegal ppg state&quot);\newline\newline    return attr_as_number;\newline}\newline","\newline PAP states are defined in ppg, chapter 6.\newline \newline","3785595","easy.c","static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\newline{\newline    PyObject *ret = NULL;\newline    struct curl_slist *slist_start = slist;\newline\newline    ret = PyList_New((Py_ssize_t)0);\newline    if (ret == NULL) goto error;\newline\newline    for ( ; slist != NULL; slist = slist-&gtnext) {\newline        PyObject *v = NULL;\newline\newline        if (slist-&gtdata == NULL) {\newline            v = Py_None; Py_INCREF(v);\newline        } else {\newline            v = PyText_FromString(slist-&gtdata);\newline        }\newline        if (v == NULL || PyList_Append(ret, v) != 0) {\newline            Py_XDECREF(v);\newline            goto error;\newline        }\newline        Py_DECREF(v);\newline    }\newline\newline    if ((free_flags &amp 1) &amp&amp slist_start)\newline        curl_slist_free_all(slist_start);\newline    return ret;\newline\newlineerror:\newline    Py_XDECREF(ret);\newline    if ((free_flags &amp 2) &amp&amp slist_start)\newline        curl_slist_free_all(slist_start);\newline    return NULL;\newline}\newline","Convert a curl slist (a list of strings) to a Python list.\newline In case of error return NULL with an exception set.\newline \newline","65633","frontend.c","int cgmanager_remove (void *data, NihDBusMessage *message, const char *controller,\newline			const char *cgroup, int recursive, int32_t *existed)\newline{\newline	int fd = 0, ret;\newline	struct ucred rcred;\newline	socklen_t len;\newline\newline	*existed = -1;\newline	if (message == NULL) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline			&quotmessage was null&quot);\newline		return -1;\newline	}\newline\newline	if (!dbus_connection_get_socket(message-&gtconnection, &ampfd)) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotCould not get client socket.&quot);\newline		return -1;\newline	}\newline\newline	len = sizeof(struct ucred);\newline	if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &amprcred, &amplen) &lt 0) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotCould not get peer cred: %s&quot,\newline					     strerror(errno));\newline		return -1;\newline	}\newline\newline	nih_info (_(&quotRemove: Client fd is: %d (pid=%d, uid=%u, gid=%u)&quot),\newline			fd, rcred.pid, rcred.uid, rcred.gid);\newline\newline	ret = remove_main(controller, cgroup, rcred, rcred, recursive, existed);\newline	if (ret)\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotinvalid request&quot);\newline	return ret;\newline}\newline","\newline This is one of the dbus callbacks.\newline Caller requests creating a new @cgroup name of type @controller.\newline @name is taken to be relative to the caller&#039s cgroup and may not\newline start with / or .. .\newline \newline","2936321","new_hblk.c","ptr_t GC_build_fl_clear4(struct hblk *h, ptr_t ofl)\newline{\newline    word * p = (word *)(h -&gt hb_body);\newline    word * lim = (word *)(h + 1);\newline    \newline    p[0] = (word)ofl;\newline    p[1] = 0;\newline    p[2] = 0;\newline    p[3] = 0;\newline    p += 4;\newline    for (; p &lt lim; p += 4) {\newline	PREFETCH_FOR_WRITE((ptr_t)(p+64));\newline        p[0] = (word)(p-4);\newline        p[1] = 0;\newline	CLEAR_DOUBLE(p+2);\newline    };\newline    return((ptr_t)(p-4));\newline}\newline","The same for size 4 cleared objects \newline","4513119","wtp.c","List *wtp_unpack_wdp_datagram(WAPEvent *datagram)\newline{\newline     List *events = NULL;\newline     WAPEvent *event = NULL;\newline     WAPEvent *subdgram = NULL;\newline     Octstr *data = NULL;\newline     long pdu_len;\newline\newline     gw_assert(datagram-&gttype == T_DUnitdata_Ind);\newline\newline     events = gwlist_create();\newline        \newline     if (concatenated_message(datagram-&gtu.T_DUnitdata_Ind.user_data)) {\newline        data = octstr_duplicate(datagram-&gtu.T_DUnitdata_Ind.user_data);\newline        octstr_delete(data, 0, 1);\newline\newline        while (octstr_len(data) != 0) {\newline\newline            if (octstr_get_bits(data, 0, 1) == 0) {\newline                pdu_len = octstr_get_char(data, 0);\newline                octstr_delete(data, 0, 1);\newline            } else {\newline                pdu_len = octstr_get_bits(data, 1, 15);\newline                octstr_delete(data, 0, 2);\newline            }\newline      \newline            subdgram = wap_event_duplicate(datagram);\newline            octstr_destroy(subdgram-&gtu.T_DUnitdata_Ind.user_data);\newline            subdgram-&gtu.T_DUnitdata_Ind.user_data = octstr_copy(data, 0, pdu_len);\newline            wap_event_assert(subdgram);\newline            if ((event = unpack_wdp_datagram_real(subdgram)) != NULL) {\newline                wap_event_assert(event);\newline                gwlist_append(events, event);\newline            }\newline            octstr_delete(data, 0, pdu_len);\newline            wap_event_destroy(subdgram);\newline        }\newline\newline        octstr_destroy(data);\newline\newline    } else if ((event = unpack_wdp_datagram_real(datagram)) != NULL) { \newline        wap_event_assert(event);\newline        gwlist_append(events, event);\newline    } else {\newline        warning(0, &quotWTP: Dropping unhandled datagram data:&quot);\newline        octstr_dump(datagram-&gtu.T_DUnitdata_Ind.user_data, 0, GW_WARNING);\newline    }\newline\newline    return events;\newline}\newline","\newline \newline EXTERNAL FUNCTIONS:\newline \newline Handles a possible concatenated message. Creates a list of wap events.\newline \newline","4200126","qeditor.cpp","void QEditor::emitCursorPositionChanged()\newline{\newline	m_cursorLinesFromViewTop = m_cursor.documentPosition().y() / m_doc-&gtgetLineSpacing() - verticalScrollBar()-&gtvalue();\newline	emit cursorPositionChanged();\newline	emit copyAvailable(m_cursor.hasSelection());\newline\newline	if ( m_definition )\newline		m_definition-&gtmatch(m_cursor);\newline\newline	if ( m_doc-&gtimpl()-&gthasMarks() )\newline		QLineMarksInfoCenter::instance()-&gtcursorMoved(this);\newline\newline}\newline","!\newline \\brief Emitted whenever the position of the cursor changes\newline \newline","3682419","usdf_wait.c","static int usdf_wait_close(struct fid *waitset)\newline{\newline	struct usdf_wait *wait_priv;\newline\newline	USDF_TRACE_SYS(FABRIC, &quot\\n&quot);\newline	if (!waitset) {\newline		USDF_WARN_SYS(FABRIC, &quotinvalid input.\\n&quot);\newline		return -FI_EINVAL;\newline	}\newline\newline	wait_priv = wait_ftou(waitset);\newline\newline	if (atomic_get(&ampwait_priv-&gtwait_refcnt) &gt 0) {\newline		USDF_DBG_SYS(FABRIC,\newline				&quotfailed to close waitset with non-zero refcnt&quot);\newline		return -FI_EBUSY;\newline	}\newline\newline	switch (wait_priv-&gtwait_obj) {\newline	case FI_WAIT_UNSPEC:\newline	case FI_WAIT_FD:\newline		close(wait_priv-&gtobject.epfd);\newline		break;\newline	default:\newline		USDF_WARN_SYS(FABRIC,\newline				&quotunsupported wait object type\\n&quot);\newline		return -FI_EINVAL;\newline	}\newline\newline	atomic_dec(&ampwait_priv-&gtwait_fabric-&gtfab_refcnt);\newline	free(wait_priv);\newline\newline	return FI_SUCCESS;\newline}\newline","Close a wait object. Make sure all resources associated with the wait object\newline have been closed.\newline \newline","4891036","p11_key.c","int pkcs11_get_key_type(PKCS11_KEY *key)\newline{\newline	PKCS11_KEY_private *kpriv = PRIVKEY(key);\newline\newline	return kpriv-&gtops-&gttype;\newline}\newline","\newline Get the key type\newline \newline","5494921","function.c","void\newlineexpand_dummy_function_end (void)\newline{\newline  /* End any sequences that failed to be closed due to syntax errors.  */\newline  while (in_sequence_p ())\newline    end_sequence ();\newline\newline  /* Outside function body, can&#039t compute type&#039s actual size\newline     until next function&#039s body starts.  */\newline\newline  free_after_parsing (cfun);\newline  free_after_compilation (cfun);\newline  cfun = 0;\newline}\newline","Undo the effects of init_dummy_function_start. \newline","116827","cram_external.c","int32_t cram_slice_hdr_get_num_blocks(cram_block_slice_hdr *hdr) {\newline    return hdr-&gtnum_blocks;\newline}\newline","\newline -----------------------------------------------------------------------------\newline cram_slice\newline \newline","2524548","parser_macros.h","void enqueue(const char *lang, const char *entity, int s, int e, void *udata) {\newline  Callback *item = (Callback *) malloc(sizeof(Callback));\newline  if (!item) printf(&quotFailed to allocate memory for enqueued callback.\\n&quot);\newline\newline  item-&gtlang = lang;\newline  item-&gtentity = entity;\newline  item-&gts = s;\newline  item-&gte = e;\newline  item-&gtudata = udata;\newline  item-&gtnext = NULL;\newline\newline  if (!callback_list_head) {\newline    callback_list_head = item;\newline    callback_list_tail = item;\newline  } else {\newline    callback_list_tail-&gtnext = item;\newline    callback_list_tail = item;\newline  }\newline}\newline","\newline Enqueues a callback for calling upon commit.\newline This is only necessary for line counting machines.\newline Ragel will execute actions in real-time rather than after a complete match.\newline This is a problem for entities that contain internal newlines, since there is\newline a callback for each internal newline whether or not the end of the entity\newline matches. This means that if, for example, the beginning of a string entity is\newline matched, the text following is treated as code until the ending delimiter. If\newline there is no ending delimiter (it was not actually a string entity), Ragel\newline will jump back to the beginning of the string and reparse the text again.\newline This means all the callbacks called were probably not accurate.\newline To remedy this, any entity which needs an ending delimiter that may not\newline appear will have its callbacks enqueued and then committed when the ending\newline delimitter is reached. If that delimitter is not reached, the callbacks are\newline never called.\newline @param lang The language name.\newline @param entity The entity (lcode, lcomment, lblank).\newline @param s The start position of the entity in the buffer.\newline @param e The end position of the entity in the buffer.\newline @param udata Userdata.\newline \newline","373936","plugins.cpp","bool PluginManagerUncached::loadPluginByFileName(const Common::String &ampfilename) {\newline	if (filename.empty())\newline		return false;\newline\newline	unloadPluginsExcept(PLUGIN_TYPE_ENGINE, NULL, false);\newline\newline	PluginList::iterator i;\newline	for (i = _allEnginePlugins.begin(); i != _allEnginePlugins.end(); ++i) {\newline		if (Common::String((*i)-&gtgetFileName()) == filename &amp&amp (*i)-&gtloadPlugin()) {\newline			addToPluginsInMemList(*i);\newline			_currentPlugin = i;\newline			return true;\newline		}\newline	}\newline	return false;\newline}\newline","\newline Load a plugin with a filename taken from ConfigManager.\newline \newline","","on","","on","on","","on","","","","on","on","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","Read a line from input file","{}","Convert a curl slist (a list of strings) to a Python list.","{}","{}","Handles a possible concatenated message. Creates a list of wap events.","{}","Close a wait object.","Get the key type","Undo the effects of init_dummy_function_start.","{}","{}","Enqueues a callback for calling upon commit.","Load a plugin with a filename taken from ConfigManager.","define a preprocessor symbol.","Get a log file structure out of an ircproxy","open device and setup parameters","{}","destroy session, host, and cls_session","Write event to syslog (or log file if defined)","Save the history to a file."
"33W1NHWFYHL57K73QURTG9WCO61TZP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3NGI5ARFTT5C7GQHR4EI8O7S2CTP1L","AVC62JNYAXA45","Approved","Wed Apr 17 14:10:39 PDT 2019","Wed Apr 17 14:29:32 PDT 2019","Fri Apr 19 14:29:32 PDT 2019","2019-04-19 21:30:21 UTC","","","1133","100% (24/24)","100% (24/24)","100% (24/24)","277763","read-filter-redact.c","static rc_t SpotIteratorReadLine(SpotIterator* self)\newline{\newline    rc_t rc = 0;\newline    bool overflow = false; /* input buffer overflow */\newline\newline    /* to skip leading/traling spaces */\newline    enum ELane {\newline        eBefore,\newline        eIn,\newline        eAfter\newline    } state = eBefore;\newline\newline    if (self-&gteof) {\newline        return rc;\newline    }\newline\newline    assert(self);\newline\newline    ++self-&gtline;\newline    self-&gtinBuffer = 0;\newline\newline    while (!overflow &amp&amp !self-&gteof) /* do until in-buffer overflow or EOF*/{\newline        char ch = 0;\newline        /* get next characted */\newline        if ((rc = SpotIteratorFileReadCharWithEof(self, &ampch)) != 0) {\newline            return rc;\newline        }\newline\newline        if (!self-&gteof) {\newline            /* treat leading/trailing spaces */\newline            switch (state) {\newline                /* skip leading spaces */\newline                case eBefore:\newline                    if (isblank(ch)) {\newline                        continue;\newline                    }\newline                    else {\newline                        state = eIn;\newline                    }\newline                    break;\newline                case eIn:\newline                    if (isblank(ch)) {\newline                        state = eAfter;\newline                        continue;\newline                    }\newline                    break;\newline                /* skip trailing spaces */\newline                case eAfter:\newline                    if (isblank(ch)) {\newline                        continue;\newline                    }\newline                    else if (ch != &#039\\n&#039 &amp&amp ch != &#039\\r&#039) {\newline                        rc = RC(rcExe, rcFile, rcReading, rcChar, rcUnexpected);\newline                        PLOGERR(klogErr, (klogErr, rc, &quotbad symbol &#039$(char)&#039 &quot\newline                            &quoton line $(lineno) in file &#039$(path)&#039: &#039$(line)...&#039&quot,\newline                            &quotchar=%c,&quot PLOG_U64(lineno) &quot,path=%s,line=%s&quot,\newline                            ch, self-&gtline, self-&gtfilename, self-&gtbuffer))\newline                        ;\newline                        return rc;\newline                    }\newline                    break;\newline            }\newline\newline            /* add next non-blank characted */\newline            overflow = !SpotIteratorBufferAdd(self, ch);\newline            if (!overflow) {\newline      /* all combinations as &quot\\r&quot, &quot\\n&quot, &quot\\r\\n&quot, &quot\\n\\r&quot are considered as EOL */\newline                if (ch == &#039\\n&#039 || ch == &#039\\r&#039) {\newline                    char c1 = 0;\newline                    if ((rc = SpotIteratorFileReadCharWithEof(self, &ampc1)) != 0)\newline                    {\newline                        return rc;\newline                    }\newline                    if (self-&gteof) {\newline                        break;\newline                    }\newline                    else if ((c1 != &#039\\n&#039 &amp&amp c1 != &#039\\r&#039) || (ch == c1)) {\newline       /* save the character when EOL is a single character (WINDOWS):\newline          will be get back in SpotIteratorFileReadCharWithEof */\newline                        self-&gtch = c1;\newline                        self-&gthasCh = true;\newline                        break;\newline                    }\newline                    else {\newline                        overflow = !SpotIteratorBufferAdd(self, c1);\newline                        break;\newline                    }\newline                }\newline            }\newline        }\newline    }\newline\newline    /* remove EOL */\newline    if (!overflow) {\newline        bool done = false;\newline\newline        while (self-&gtinBuffer &gt 0 &amp&amp !done) {\newline            switch (self-&gtbuffer[self-&gtinBuffer - 1]) {\newline                case &#039\\n&#039: case &#039\\r&#039:\newline                    self-&gtbuffer[--self-&gtinBuffer] = &#039\\0&#039;\newline                    break;\newline                default:\newline                    done = true;\newline                    break;\newline            }\newline        }\newline    }\newline    else {\newline        rc = RC(rcExe, rcFile, rcReading, rcString, rcTooLong);\newline        PLOGERR(klogErr, (klogErr, rc,\newline            &quoton line $(lineno) while reading file &#039$(path)&#039: &#039$(line)...&#039&quot,\newline            PLOG_U64(lineno) &quot,path=%s,line=%s&quot,\newline            self-&gtline, self-&gtfilename, self-&gtbuffer));\newline    }\newline\newline    return rc;\newline}\newline","Read a line from input file \newline","2973580","dvb_ecmg.c","static void build_ecm(stream_t *p_stream, uint16_t i_cp_number,\newline                      uint8_t * const ppi_cw[2],\newline                      uint8_t *p_accesscrit_param)\newline{\newline    /* you will want to customize this function */\newline    static const uint8_t pi_xor[8] =\newline        {0x42, 0x12, 0x02, 0x24, 0x21, 0x20, 0x66, 0x88};\newline    PSI_DECLARE(p_section);\newline    uint8_t *pi_ecm;\newline    int i, j;\newline\newline    psi_init(p_section, false);\newline    psi_set_tableid(p_section, 0x80 | (i_cp_number &amp 0x1));\newline    psi_set_length(p_section, 16);\newline\newline    pi_ecm = p_section + 3;\newline    for (i = 0; i &lt 2; i++)\newline        for (j = 0; j &lt 8; j++)\newline            pi_ecm[i * 8 + j] = ppi_cw[i][j] ^ pi_xor[j];\newline\newline    send_ecm(p_stream, i_cp_number, p_section,\newline             psi_get_length(p_section) + PSI_HEADER_SIZE);\newline}\newline","\newline build_ecm\newline \newline","1886670","libtcc.c","LIBTCCAPI void tcc_define_symbol(TCCState *s1, const char *sym, const char *value)\newline{\newline    int len1, len2;\newline    /* default value */\newline    if (!value)\newline        value = &quot1&quot;\newline    len1 = strlen(sym);\newline    len2 = strlen(value);\newline\newline    /* init file structure */\newline    tcc_open_bf(s1, &quot&ltdefine&gt&quot, len1 + len2 + 1);\newline    memcpy(file-&gtbuffer, sym, len1);\newline    file-&gtbuffer[len1] = &#039 &#039;\newline    memcpy(file-&gtbuffer + len1 + 1, value, len2);\newline\newline    /* parse with define parser */\newline    ch = file-&gtbuf_ptr[0];\newline    next_nomacro();\newline    parse_define();\newline\newline    tcc_close();\newline}\newline","define a preprocessor symbol. A value can also be provided with the &#039=&#039 operator \newline","155690","irc_log.c","static struct logfile *_irclog_getlog(struct ircproxy *p, const char *to) {\newline  struct ircchannel *c;\newline  \newline  if (!to)\newline    return 0;\newline\newline  c = ircnet_fetchchannel(p, to);\newline  if (c) {\newline    return &amp(c-&gtlog);\newline  } else {\newline    return &amp(p-&gtother_log);\newline  }\newline}\newline","Get a log file structure out of an ircproxy \newline","4223768","ao_sndio.c","static int init(int rate, int channels, int format, int flags)\newline{\newline    int bpf;\newline\newline    hdl = sio_open(SIO_DEVANY, SIO_PLAY, 0);\newline    if (hdl == NULL) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: can&#039t open sndio\\n&quot);\newline        return 0;\newline    }\newline    sio_initpar(&amppar);\newline    par.bits = af_fmt2bits(format);\newline    par.bps = (par.bits + 7) &gt&gt 3;\newline    // normally bits == 8*bps so this makes no difference\newline    // but we can support more formats for msb == 1, see &quotif&quot below\newline    par.msb = 1;\newline    par.sig = (format &amp AF_FORMAT_SIGN_MASK) == AF_FORMAT_SI;\newline    if (par.bits &gt 8)\newline        par.le = (format &amp AF_FORMAT_END_MASK) == AF_FORMAT_LE;\newline    par.rate = rate;\newline    par.pchan = channels;\newline    par.appbufsz = par.rate * 250 / 1000;    /* 250ms buffer */\newline    par.round = par.rate * 10 / 1000;        /*  10ms block size */\newline    if (!sio_setpar(hdl, &amppar)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t set params\\n&quot);\newline        goto err_out;\newline    }\newline    if (!sio_getpar(hdl, &amppar)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t get params\\n&quot);\newline        goto err_out;\newline    }\newline    // we do not care if LSBs are discarded\newline    if (par.bits &lt 8 * par.bps &amp&amp !par.msb) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: unsupported format\\n&quot);\newline        goto err_out;\newline    }\newline    pfds = calloc(sio_nfds(hdl), sizeof(*pfds));\newline    if (pfds == NULL) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: couldn&#039t allocate poll fds\\n&quot);\newline        goto err_out;\newline    }\newline    bpf = par.bps * par.pchan;\newline    ao_data.format = af_bits2fmt(8 * par.bps);\newline    ao_data.format |= par.sig ? AF_FORMAT_SI : AF_FORMAT_US;\newline    ao_data.format |= par.le ? AF_FORMAT_LE : AF_FORMAT_BE;\newline    ao_data.channels = par.pchan;\newline    ao_data.bps = bpf * par.rate;\newline    ao_data.buffersize = par.bufsz * bpf;\newline    ao_data.outburst = par.round * bpf;\newline    ao_data.samplerate = rate;\newline    havevol = sio_onvol(hdl, volcb, NULL);\newline    sio_onmove(hdl, movecb, NULL);\newline\newline    /*\newline     * prepare the device to start. It will start as soon there&#039s enough\newline     * data in the buffer to not underrun\newline     */\newline    delay = 0;\newline    if (!sio_start(hdl)) {\newline        mp_msg(MSGT_AO, MSGL_ERR, &quotao2: init: couldn&#039t start\\n&quot);\newline        goto err_out;\newline    }\newline    return 1;\newlineerr_out:\newline    free(pfds);\newline    pfds = NULL;\newline    sio_close(hdl);\newline    hdl = NULL;\newline    return 0;\newline}\newline","\newline open device and setup parameters\newline return: 1 = success, 0 = failure\newline \newline","6443309","display.c","static void display_set_line (char *string, int line, char *tag)\newline{\newline	char 		*separator_string;\newline	GtkTextIter	start;\newline\newline	/* at first clear the result field */\newline	display_delete_line (buffer, line, &ampstart);\newline	\newline	separator_string = string_add_separator(string, get_sep(current_status.number), \newline		get_sep_length(current_status.number), get_sep_char(current_status.number), dec_point[0]);\newline	/* DISPLAY RESULT MODIFIED */\newline	gtk_text_buffer_insert_with_tags_by_name (buffer, &ampstart, separator_string, -1, tag, NULL);\newline	g_free (separator_string);\newline	if (line == display_result_line) {\newline		display_result_counter = strlen (string);\newline		/* this is some cosmetics. try to keep counter up2date */\newline		if (strchr (string, &#039e&#039) != NULL) {\newline			display_result_counter -= (strchr(string, &#039e&#039) + sizeof(char) - string)/sizeof(char);\newline			display_result_counter += get_display_number_length(current_status.number) - DISPLAY_RESULT_E_LENGTH - 1;\newline		}\newline		else if (strchr (string, dec_point[0]) != NULL) display_result_counter--;\newline	}\newline}\newline","these is the most basic routine. all functions here finally result in a call\newline to this.\newline \newline","5821228","libiscsi.c","void iscsi_session_teardown(struct iscsi_cls_session *cls_session)\newline{\newline	struct iscsi_session *session = cls_session-&gtdd_data;\newline	struct module *owner = cls_session-&gttransport-&gtowner;\newline	struct Scsi_Host *shost = session-&gthost;\newline\newline	iscsi_pool_free(&ampsession-&gtcmdpool);\newline\newline	kfree(session-&gtpassword);\newline	kfree(session-&gtpassword_in);\newline	kfree(session-&gtusername);\newline	kfree(session-&gtusername_in);\newline	kfree(session-&gttargetname);\newline	kfree(session-&gtinitiatorname);\newline	kfree(session-&gtifacename);\newline\newline	iscsi_destroy_session(cls_session);\newline	iscsi_host_dec_session_cnt(shost);\newline	module_put(owner);\newline}\newline","\newline iscsi_session_teardown - destroy session, host, and cls_session\newline @cls_session: iscsi session\newline \newline The driver must have called iscsi_remove_session before\newline calling this.\newline \newline","46438","ssmtp.c","void log_event(int priority, char *format, ...)\newline{\newline	char buf[(BUF_SZ + 1)];\newline	va_list ap;\newline\newline	va_start(ap, format);\newline	(void)vsnprintf(buf, BUF_SZ, format, ap);\newline	va_end(ap);\newline\newline#ifdef LOGFILE\newline	FILE *fp;\newline\newline	if((fp = fopen(&quot/tmp/ssmtp.log&quot, &quota&quot)) != (FILE *)NULL) {\newline		(void)fprintf(fp, &quot%s\\n&quot, buf);\newline		(void)fclose(fp);\newline	}\newline	else {\newline		(void)fprintf(stderr, &quotCan&#039t write to /tmp/ssmtp.log\\n&quot);\newline	}\newline#endif\newline\newline#if HAVE_SYSLOG_H\newline#if OLDSYSLOG\newline	openlog(&quotsSMTP&quot, LOG_PID);\newline#else\newline	openlog(&quotsSMTP&quot, LOG_PID, LOG_MAIL);\newline#endif\newline	syslog(priority, &quot%s&quot, buf);\newline	closelog();\newline#endif\newline}\newline","\newlinelog_event() -- Write event to syslog (or log file if defined)\newline \newline","3280094","readline.c","static int do_readline_save_history(ReadLine *readp)\newline{\newline    int i, offset, start, length;\newline    LineBuffer *linep;\newline    FILE *filep;\newline\newline    if(*readp-&gtfilename == 0)\newline        return -1;\newline    if((filep = fopen(readp-&gtfilename, &quotw&quot)) == NULL)\newline        return -1;\newline\newline    offset = readp-&gtoffset;\newline    start = readp-&gtstart;\newline    length = readp-&gtlength;\newline    for(i = 0; i &lt length; i++) {\newline        linep = readp-&gthistory + ((start + i) % MAX_HISTORY_LENGTH);\newline        linep-&gtbuffer[linep-&gtlength] = 0;\newline        fprintf(filep, &quot%5d %s\\n&quot, offset + i, linep-&gtbuffer);\newline    }\newline\newline    fclose(filep);\newline    return 0;\newline}\newline","\newline Save the history to a file.\newline \newline","4514098","wap_push_pap_compiler.c","static int parse_state(Octstr *attr_value)\newline{\newline    long attr_as_number;\newline\newline    attr_as_number = -2;\newline    if (octstr_case_compare(attr_value, octstr_imm(&quotundeliverable&quot)) == 0)\newline        attr_as_number = PAP_UNDELIVERABLE; \newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotpending&quot)) == 0)\newline        attr_as_number = PAP_PENDING; \newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotexpired&quot)) == 0)\newline        attr_as_number = PAP_EXPIRED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotdelivered&quot)) == 0)\newline        attr_as_number = PAP_DELIVERED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotaborted&quot)) == 0)\newline        attr_as_number = PAP_ABORTED;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quottimeout&quot)) == 0)\newline        attr_as_number = PAP_TIMEOUT;\newline    else if (octstr_case_compare(attr_value, octstr_imm(&quotcancelled&quot)) == 0)\newline        attr_as_number = PAP_CANCELLED;\newline    else \newline         warning(0, &quotillegal ppg state&quot);\newline\newline    return attr_as_number;\newline}\newline","\newline PAP states are defined in ppg, chapter 6.\newline \newline","3785595","easy.c","static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\newline{\newline    PyObject *ret = NULL;\newline    struct curl_slist *slist_start = slist;\newline\newline    ret = PyList_New((Py_ssize_t)0);\newline    if (ret == NULL) goto error;\newline\newline    for ( ; slist != NULL; slist = slist-&gtnext) {\newline        PyObject *v = NULL;\newline\newline        if (slist-&gtdata == NULL) {\newline            v = Py_None; Py_INCREF(v);\newline        } else {\newline            v = PyText_FromString(slist-&gtdata);\newline        }\newline        if (v == NULL || PyList_Append(ret, v) != 0) {\newline            Py_XDECREF(v);\newline            goto error;\newline        }\newline        Py_DECREF(v);\newline    }\newline\newline    if ((free_flags &amp 1) &amp&amp slist_start)\newline        curl_slist_free_all(slist_start);\newline    return ret;\newline\newlineerror:\newline    Py_XDECREF(ret);\newline    if ((free_flags &amp 2) &amp&amp slist_start)\newline        curl_slist_free_all(slist_start);\newline    return NULL;\newline}\newline","Convert a curl slist (a list of strings) to a Python list.\newline In case of error return NULL with an exception set.\newline \newline","65633","frontend.c","int cgmanager_remove (void *data, NihDBusMessage *message, const char *controller,\newline			const char *cgroup, int recursive, int32_t *existed)\newline{\newline	int fd = 0, ret;\newline	struct ucred rcred;\newline	socklen_t len;\newline\newline	*existed = -1;\newline	if (message == NULL) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline			&quotmessage was null&quot);\newline		return -1;\newline	}\newline\newline	if (!dbus_connection_get_socket(message-&gtconnection, &ampfd)) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotCould not get client socket.&quot);\newline		return -1;\newline	}\newline\newline	len = sizeof(struct ucred);\newline	if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &amprcred, &amplen) &lt 0) {\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotCould not get peer cred: %s&quot,\newline					     strerror(errno));\newline		return -1;\newline	}\newline\newline	nih_info (_(&quotRemove: Client fd is: %d (pid=%d, uid=%u, gid=%u)&quot),\newline			fd, rcred.pid, rcred.uid, rcred.gid);\newline\newline	ret = remove_main(controller, cgroup, rcred, rcred, recursive, existed);\newline	if (ret)\newline		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,\newline					     &quotinvalid request&quot);\newline	return ret;\newline}\newline","\newline This is one of the dbus callbacks.\newline Caller requests creating a new @cgroup name of type @controller.\newline @name is taken to be relative to the caller&#039s cgroup and may not\newline start with / or .. .\newline \newline","2936321","new_hblk.c","ptr_t GC_build_fl_clear4(struct hblk *h, ptr_t ofl)\newline{\newline    word * p = (word *)(h -&gt hb_body);\newline    word * lim = (word *)(h + 1);\newline    \newline    p[0] = (word)ofl;\newline    p[1] = 0;\newline    p[2] = 0;\newline    p[3] = 0;\newline    p += 4;\newline    for (; p &lt lim; p += 4) {\newline	PREFETCH_FOR_WRITE((ptr_t)(p+64));\newline        p[0] = (word)(p-4);\newline        p[1] = 0;\newline	CLEAR_DOUBLE(p+2);\newline    };\newline    return((ptr_t)(p-4));\newline}\newline","The same for size 4 cleared objects \newline","4513119","wtp.c","List *wtp_unpack_wdp_datagram(WAPEvent *datagram)\newline{\newline     List *events = NULL;\newline     WAPEvent *event = NULL;\newline     WAPEvent *subdgram = NULL;\newline     Octstr *data = NULL;\newline     long pdu_len;\newline\newline     gw_assert(datagram-&gttype == T_DUnitdata_Ind);\newline\newline     events = gwlist_create();\newline        \newline     if (concatenated_message(datagram-&gtu.T_DUnitdata_Ind.user_data)) {\newline        data = octstr_duplicate(datagram-&gtu.T_DUnitdata_Ind.user_data);\newline        octstr_delete(data, 0, 1);\newline\newline        while (octstr_len(data) != 0) {\newline\newline            if (octstr_get_bits(data, 0, 1) == 0) {\newline                pdu_len = octstr_get_char(data, 0);\newline                octstr_delete(data, 0, 1);\newline            } else {\newline                pdu_len = octstr_get_bits(data, 1, 15);\newline                octstr_delete(data, 0, 2);\newline            }\newline      \newline            subdgram = wap_event_duplicate(datagram);\newline            octstr_destroy(subdgram-&gtu.T_DUnitdata_Ind.user_data);\newline            subdgram-&gtu.T_DUnitdata_Ind.user_data = octstr_copy(data, 0, pdu_len);\newline            wap_event_assert(subdgram);\newline            if ((event = unpack_wdp_datagram_real(subdgram)) != NULL) {\newline                wap_event_assert(event);\newline                gwlist_append(events, event);\newline            }\newline            octstr_delete(data, 0, pdu_len);\newline            wap_event_destroy(subdgram);\newline        }\newline\newline        octstr_destroy(data);\newline\newline    } else if ((event = unpack_wdp_datagram_real(datagram)) != NULL) { \newline        wap_event_assert(event);\newline        gwlist_append(events, event);\newline    } else {\newline        warning(0, &quotWTP: Dropping unhandled datagram data:&quot);\newline        octstr_dump(datagram-&gtu.T_DUnitdata_Ind.user_data, 0, GW_WARNING);\newline    }\newline\newline    return events;\newline}\newline","\newline \newline EXTERNAL FUNCTIONS:\newline \newline Handles a possible concatenated message. Creates a list of wap events.\newline \newline","4200126","qeditor.cpp","void QEditor::emitCursorPositionChanged()\newline{\newline	m_cursorLinesFromViewTop = m_cursor.documentPosition().y() / m_doc-&gtgetLineSpacing() - verticalScrollBar()-&gtvalue();\newline	emit cursorPositionChanged();\newline	emit copyAvailable(m_cursor.hasSelection());\newline\newline	if ( m_definition )\newline		m_definition-&gtmatch(m_cursor);\newline\newline	if ( m_doc-&gtimpl()-&gthasMarks() )\newline		QLineMarksInfoCenter::instance()-&gtcursorMoved(this);\newline\newline}\newline","!\newline \\brief Emitted whenever the position of the cursor changes\newline \newline","3682419","usdf_wait.c","static int usdf_wait_close(struct fid *waitset)\newline{\newline	struct usdf_wait *wait_priv;\newline\newline	USDF_TRACE_SYS(FABRIC, &quot\\n&quot);\newline	if (!waitset) {\newline		USDF_WARN_SYS(FABRIC, &quotinvalid input.\\n&quot);\newline		return -FI_EINVAL;\newline	}\newline\newline	wait_priv = wait_ftou(waitset);\newline\newline	if (atomic_get(&ampwait_priv-&gtwait_refcnt) &gt 0) {\newline		USDF_DBG_SYS(FABRIC,\newline				&quotfailed to close waitset with non-zero refcnt&quot);\newline		return -FI_EBUSY;\newline	}\newline\newline	switch (wait_priv-&gtwait_obj) {\newline	case FI_WAIT_UNSPEC:\newline	case FI_WAIT_FD:\newline		close(wait_priv-&gtobject.epfd);\newline		break;\newline	default:\newline		USDF_WARN_SYS(FABRIC,\newline				&quotunsupported wait object type\\n&quot);\newline		return -FI_EINVAL;\newline	}\newline\newline	atomic_dec(&ampwait_priv-&gtwait_fabric-&gtfab_refcnt);\newline	free(wait_priv);\newline\newline	return FI_SUCCESS;\newline}\newline","Close a wait object. Make sure all resources associated with the wait object\newline have been closed.\newline \newline","4891036","p11_key.c","int pkcs11_get_key_type(PKCS11_KEY *key)\newline{\newline	PKCS11_KEY_private *kpriv = PRIVKEY(key);\newline\newline	return kpriv-&gtops-&gttype;\newline}\newline","\newline Get the key type\newline \newline","5494921","function.c","void\newlineexpand_dummy_function_end (void)\newline{\newline  /* End any sequences that failed to be closed due to syntax errors.  */\newline  while (in_sequence_p ())\newline    end_sequence ();\newline\newline  /* Outside function body, can&#039t compute type&#039s actual size\newline     until next function&#039s body starts.  */\newline\newline  free_after_parsing (cfun);\newline  free_after_compilation (cfun);\newline  cfun = 0;\newline}\newline","Undo the effects of init_dummy_function_start. \newline","116827","cram_external.c","int32_t cram_slice_hdr_get_num_blocks(cram_block_slice_hdr *hdr) {\newline    return hdr-&gtnum_blocks;\newline}\newline","\newline -----------------------------------------------------------------------------\newline cram_slice\newline \newline","2524548","parser_macros.h","void enqueue(const char *lang, const char *entity, int s, int e, void *udata) {\newline  Callback *item = (Callback *) malloc(sizeof(Callback));\newline  if (!item) printf(&quotFailed to allocate memory for enqueued callback.\\n&quot);\newline\newline  item-&gtlang = lang;\newline  item-&gtentity = entity;\newline  item-&gts = s;\newline  item-&gte = e;\newline  item-&gtudata = udata;\newline  item-&gtnext = NULL;\newline\newline  if (!callback_list_head) {\newline    callback_list_head = item;\newline    callback_list_tail = item;\newline  } else {\newline    callback_list_tail-&gtnext = item;\newline    callback_list_tail = item;\newline  }\newline}\newline","\newline Enqueues a callback for calling upon commit.\newline This is only necessary for line counting machines.\newline Ragel will execute actions in real-time rather than after a complete match.\newline This is a problem for entities that contain internal newlines, since there is\newline a callback for each internal newline whether or not the end of the entity\newline matches. This means that if, for example, the beginning of a string entity is\newline matched, the text following is treated as code until the ending delimiter. If\newline there is no ending delimiter (it was not actually a string entity), Ragel\newline will jump back to the beginning of the string and reparse the text again.\newline This means all the callbacks called were probably not accurate.\newline To remedy this, any entity which needs an ending delimiter that may not\newline appear will have its callbacks enqueued and then committed when the ending\newline delimitter is reached. If that delimitter is not reached, the callbacks are\newline never called.\newline @param lang The language name.\newline @param entity The entity (lcode, lcomment, lblank).\newline @param s The start position of the entity in the buffer.\newline @param e The end position of the entity in the buffer.\newline @param udata Userdata.\newline \newline","373936","plugins.cpp","bool PluginManagerUncached::loadPluginByFileName(const Common::String &ampfilename) {\newline	if (filename.empty())\newline		return false;\newline\newline	unloadPluginsExcept(PLUGIN_TYPE_ENGINE, NULL, false);\newline\newline	PluginList::iterator i;\newline	for (i = _allEnginePlugins.begin(); i != _allEnginePlugins.end(); ++i) {\newline		if (Common::String((*i)-&gtgetFileName()) == filename &amp&amp (*i)-&gtloadPlugin()) {\newline			addToPluginsInMemList(*i);\newline			_currentPlugin = i;\newline			return true;\newline		}\newline	}\newline	return false;\newline}\newline","\newline Load a plugin with a filename taken from ConfigManager.\newline \newline","","on","","","on","","on","","","","on","on","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","Read a line from input file","{}","Convert a curl slist (a list of strings) to a Python list.","creating a new @cgroup name of type @controller.","{}","Handles a possible concatenated message. Creates a list of wap events.","{}","Close a wait object.","Get the key type","Undo the effects of init_dummy_function_start.","{}","{}","Enqueues a callback for calling upon commit.","Load a plugin","define a preprocessor symbol.","Get a log file structure out of an ircproxy","open device and setup parameters","{}","destroy session, host, and cls_session","Write event to syslog (or log file if defined)","Save the history to a file."
"360ZO6N6J1JMOYZ6DZWIH7ZRFVG9MO","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","33FOTY3KEMLTDRHDMZSCOO8L3T4C1K","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:10:59 PDT 2019","Wed Apr 17 15:16:47 PDT 2019","Fri Apr 19 15:16:47 PDT 2019","2019-04-19 22:17:21 UTC","","","348","100% (27/27)","100% (27/27)","100% (27/27)","4476506","seas_action.c","int process_action(as_p the_as)\newline{\newline   unsigned int ac_len;\newline   ac_len=(the_as-&gtac_buffer.s[0]&lt&lt24)|(the_as-&gtac_buffer.s[1]&lt&lt16)|(the_as-&gtac_buffer.s[2]&lt&lt8)|((the_as-&gtac_buffer.s[3])&amp0xFF);\newline   /*yeah, it comes in network byte order*/\newline   /*if ac_len &gt BUF_SIZE then a flag should be put on the AS so that the whole length\newline    * of the action is skipped, until a mechanism for handling big packets is implemented*/\newline   if(use_stats)\newline      stats_reply();\newline   if(ac_len&gtAS_BUF_SIZE){\newline      LM_WARN(&quotaction too big (%d)!!! should be skipped and&quot\newline			  &quot an error returned!\\n&quot,ac_len);\newline      return -1;\newline   }\newline   while (the_as-&gtac_buffer.len&gt=ac_len) {\newline      LM_DBG(&quotProcessing action %d bytes long\\n&quot,ac_len);\newline      switch(the_as-&gtac_buffer.s[4]){\newline	 case REPLY_PROV:\newline	 case REPLY_FIN:\newline	    LM_DBG(&quotProcessing a REPLY action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_reply(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case UAC_REQ:\newline	    LM_DBG(&quotProcessing an UAC REQUEST action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_uac_req(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case AC_CANCEL:\newline	    LM_DBG(&quotProcessing a CANCEL REQUEST action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_cancel(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case SL_MSG:\newline	    LM_DBG(&quotProcessing a STATELESS MESSAGE action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_sl_msg(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case JAIN_PONG:\newline	    LM_DBG(&quotProcessing a PONG\\n&quot);\newline	    ac_jain_pong(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 default:\newline	    LM_DBG(&quotProcessing a UNKNOWN TYPE action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    break;\newline      }\newline      memmove(the_as-&gtac_buffer.s,the_as-&gtac_buffer.s+ac_len,(the_as-&gtac_buffer.len)-ac_len);\newline      (the_as-&gtac_buffer.len)-=ac_len;\newline      if(the_as-&gtac_buffer.len&gt5){\newline	 ac_len=(the_as-&gtac_buffer.s[0]&lt&lt24)|(the_as-&gtac_buffer.s[1]&lt&lt16)|(the_as-&gtac_buffer.s[2]&lt&lt8)|((the_as-&gtac_buffer.s[3])&amp0xFF);\newline      }else{\newline	 return 0;\newline      }\newline   }\newline   return 0;\newline}\newline","Processes the actions received from the socket.\newline returns\newline -1 on error\newline 0 on success\newline \newline","1086027","nvidia_vid.c","static void rivatv_overlay_stop (struct rivatv_info *info) {\newline	switch (info-&gtchip.arch ) {\newline	case NV_ARCH_10:\newline	case NV_ARCH_20:\newline    case NV_ARCH_30:\newline		/* NV_PVIDEO_COLOR_KEY */\newline		/* Xv-Extension-Hack: Restore previously saved value. */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0xB00, info-&gtcolorkey);\newline		/* NV_PVIDEO_STOP */\newline		VID_OR32 (info-&gtchip.PVIDEO, 0x704, 0x11);\newline		/* NV_PVIDEO_BUFFER */\newline		VID_AND32 (info-&gtchip.PVIDEO, 0x700, ~0x11);\newline		/* NV_PVIDEO_INTR_EN_BUFFER */\newline//		VID_AND32 (info-&gtchip.PVIDEO, 0x140, ~0x11);\newline		break;\newline	case NV_ARCH_03:\newline	case NV_ARCH_04:\newline		/* NV_PVIDEO_KEY */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x240, info-&gtcolorkey);\newline		/* NV_PVIDEO_OVERLAY_VIDEO_OFF */\newline		VID_AND32 (info-&gtchip.PVIDEO, 0x244, ~0x01);\newline		/* NV_PVIDEO_INTR_EN_0_NOTIFY */\newline//		VID_AND32 (info-&gtchip.PVIDEO, 0x140, ~0x01);\newline		/* NV_PVIDEO_OE_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x224, 0);\newline		/* NV_PVIDEO_SU_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x228, 0);\newline		/* NV_PVIDEO_RM_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x22C, 0);\newline		break;\newline	}\newline}\newline","Stop overlay video. \newline","3672130","lnp-logical.c","int lnp_logical_write(const void* buf,size_t len) {\newline  unsigned char tmp;\newline\newline#ifdef CONF_TM\newline  if (sem_wait(&amptx_sem) == -1)\newline  	return tx_state;\newline#endif\newline\newline#ifdef CONF_AUTOSHUTOFF\newline  shutoff_restart();\newline#endif\newline\newline	if (wait_event(write_allow,0) != 0)\newline	{\newline	  lnp_timeout_reset();\newline\newline  	tx_verify=tx_ptr=buf;                 // what to transmit\newline	  tx_end=buf+len;\newline\newline	  tx_state=TX_ACTIVE;\newline	  S_SR&amp=~(SSR_TRANS_EMPTY | SSR_TRANS_END); // clear flags\newline	  S_CR|=SCR_TRANSMIT | SCR_TX_IRQ | SCR_TE_IRQ; // enable transmit &amp irqs\newline\newline	  wait_event(write_complete,0);\newline\newline	  // determine delay before next transmission\newline	  //\newline	  if(tx_state==TX_IDLE)\newline	    tmp=LNP_WAIT_TXOK;\newline	  else\newline	    tmp=LNP_WAIT_COLL + ( ((unsigned char) 0x0f) &amp\newline	        ( ((unsigned char) len)+\newline	          ((unsigned char*)buf)[len-1]+\newline	          ((unsigned char) get_system_up_time())    ) );\newline	  allow_tx=get_system_up_time()+tmp;\newline	}\newline\newline#ifdef CONF_TM\newline  sem_post(&amptx_sem);\newline#endif\newline\newline  return tx_state;\newline}\newline","! \\param buf data to transmit\newline\\param len number of bytes to transmit\newline\\return 0 on success, else collision\newline \newline","6008320","objrtcmp.c","static void IntermediatePatternNodeReference(\newline  void *theEnv,\newline  OBJECT_PATTERN_NODE *thePattern,\newline  FILE *theFile,\newline  int imageID,\newline  int maxIndices)\newline  {\newline   if (thePattern == NULL)\newline     fprintf(theFile,&quotNULL&quot);\newline   else\newline     {\newline      fprintf(theFile,&quot&amp%s%d_%d[%d]&quot,\newline                    ObjectPNPrefix(),imageID,\newline                    (((int) thePattern-&gtbsaveID) / maxIndices) + 1,\newline                    ((int) thePattern-&gtbsaveID) % maxIndices);\newline     }\newline  }\newline","\newlineNAME : IntermediatePatternNodeReference\newlineDESCRIPTION : Prints out a reference to an\newlineobject pattern intermediate node\newlineINPUTS : 1) A pointer to the object pattern\newlineintermediate node\newline2) A pointer to the output file\newline3) The id of constructs-to-c image\newline4) The maximum number of indices\newlineallowed in any single array\newlinein the image\newlineRETURNS : 1 if OK, 0 if could not open a file\newlineSIDE EFFECTS : Reference to object pattern alpha\newlinememory printed\newlineNOTES : None\newline \newline","5436470","header.c","void *snag_float(FILE *fpin, char *s, char *value, int *group, int *type)\newline{\newline  float *item;\newline\newline  get_next_group(fpin, REQUIRED, s, value, group, type);\newline\newline  if (*group &gt 59 || *group &lt 10) {\newline    rewind_file();\newline    return NULL;\newline  }\newline  \newline  item = (float *)malloc(sizeof(float));\newline  if (!item) {\newline    fprintf(stderr,&quotmalloc failed\\n&quot);\newline    exit(0);\newline  }\newline\newline  *item = atof(value);\newline  return (void *)item;\newline}\newline","\newline Snag a single float type variable\newline \newline","6375060","jmt.c","static void parse_add_scan(struct jmt_parse *parse, ind_t j,\newline                           struct state *s, ind_t i,\newline                           ind_t lens, ind_t k, ind_t item) {\newline    ensure(item &lt parse-&gtsets[k]-&gtitems.used, parse);\newline\newline    parse_add_item(parse, j, s, i, R_SCAN, lens, k, item, EPS, IND_MAX);\newline error:\newline    return;\newline}\newline","Add item (s,i) to E_j and record that it was added because of scanning\newline with lens starting from item item in E_k.\newline \newline [j, (s,i)] -&gt [k, item]\newline \newline","3687271","reportgenerator.cpp","void ReportGenerator::createPdfFromArchive( const QString&amp docID, dbID archId )\newline{\newline  mDocId = docID;\newline  mArchId = archId;\newline  fillupTemplateFromArchive( archId );\newline  // Method fillupTemplateFromArchive raises a signal when the archive was\newline  // generated. This signal gets connected to slotConvertTemplate in the\newline  // constructor of this class.\newline}\newline","\newline docID: document ID\newline dbId: database ID of the archived doc.\newline \newline","2228920","metadata_view.c","uint32_t views(dt_lib_module_t *self)\newline{\newline  return DT_VIEW_ALL;\newline}\newline","show module in left panel in all views \newline","6199359","proxyd.c","static void vbi_proxyd_init( void )\newline{\newline   struct sigaction  act;\newline\newline   if (opt_no_detach == FALSE)\newline   {\newline      if (fork() &gt 0)\newline         exit(0);\newline      close(0); \newline      open(&quot/dev/null&quot, O_RDONLY, 0);\newline\newline      if (opt_debug_level == 0)\newline      {\newline         close(1);\newline         open(&quot/dev/null&quot, O_WRONLY, 0);\newline         close(2);\newline         dup(1);\newline\newline         setsid();\newline      }\newline   }\newline\newline   /* ignore broken pipes (handled by select/read) */\newline   memset(&ampact, 0, sizeof(act));\newline   act.sa_handler = SIG_IGN;\newline   sigaction(SIGPIPE, &ampact, NULL);\newline\newline   /* handle alarm timers (for channel change scheduling) */\newline   memset(&ampact, 0, sizeof(act));\newline   act.sa_handler = vbi_proxyd_alarm_handler;\newline   sigaction(SIGALRM, &ampact, NULL);\newline\newline   /* catch deadly signals for a clean shutdown (remove socket file) */\newline   memset(&ampact, 0, sizeof(act));\newline   sigemptyset(&ampact.sa_mask);\newline   sigaddset(&ampact.sa_mask, SIGINT);\newline   sigaddset(&ampact.sa_mask, SIGTERM);\newline   sigaddset(&ampact.sa_mask, SIGHUP);\newline   act.sa_handler = vbi_proxyd_signal_handler;\newline   act.sa_flags = SA_ONESHOT;\newline   sigaction(SIGINT, &ampact, NULL);\newline   sigaction(SIGTERM, &ampact, NULL);\newline   sigaction(SIGHUP, &ampact, NULL);\newline}\newline","----------------------------------------------------------------------------\newline Initialize DB server\newline \newline","101386","handlers.c","static bool handle_windowrole_change(void *data, xcb_connection_t *conn, uint8_t state,\newline                                     xcb_window_t window, xcb_atom_t atom, xcb_get_property_reply_t *prop) {\newline    Con *con;\newline    if ((con = con_by_window_id(window)) == NULL || con-&gtwindow == NULL)\newline        return false;\newline\newline    window_update_role(con-&gtwindow, prop, false);\newline\newline    return true;\newline}\newline","\newline Called when a window changes its WM_WINDOW_ROLE.\newline \newline \newline","5750936","gfal_srm_readdir.c","static struct dirent *gfal_srm_readdir_pipeline(plugin_handle ch,\newline    gfal_srm_opendir_handle oh, struct stat *st, GError **err)\newline{\newline    GError *tmp_err = NULL;\newline\newline    // Nothing yet, so get the bulk\newline    if (oh-&gtsrm_file_statuses == NULL) {\newline        gfal_srm_readdir_internal(ch, oh, &amptmp_err);\newline        if (tmp_err) {\newline            gfal2_propagate_prefixed_error(err, tmp_err, __func__);\newline            return NULL;\newline        }\newline    }\newline\newline    // Empty directory\newline    if (oh-&gtsrm_file_statuses == NULL || oh-&gtsrm_file_statuses-&gtnbsubpaths == 0) {\newline        return NULL;\newline    }\newline\newline    // Done here\newline    if (oh-&gtresponse_index &gt= oh-&gtsrm_file_statuses-&gtnbsubpaths) {\newline        return NULL;\newline    }\newline\newline    // Iterate and return statuses\newline    struct dirent *ret = gfal_srm_readdir_convert_result(ch, oh-&gtsurl,\newline        &ampoh-&gtsrm_file_statuses-&gtsubpaths[oh-&gtresponse_index], &ampoh-&gtdirent_buffer,\newline        st, &amptmp_err);\newline    oh-&gtresponse_index++;\newline\newline    // If chunk listing, and the index passed the last entry in the buffer,\newline    // release, and prepare next bulk\newline    if (oh-&gtis_chunked_listing &amp&amp oh-&gtresponse_index &gt= oh-&gtchunk_size) {\newline        oh-&gtchunk_offset += oh-&gtchunk_size;\newline        gfal_srm_external_call.srm_srmv2_mdfilestatus_delete(oh-&gtsrm_file_statuses, 1);\newline        oh-&gtsrm_file_statuses = NULL;\newline    }\newline\newline    return ret;\newline}\newline","\newline Wraps the SRM request.\newline Request each chunks, then iterates through the responses as readdir is called\newline \newline","4251155","fec_read.cpp","static inline bool is_zero(fec_handle *f, uint64_t offset)\newline{\newline    verity_info *v = &ampf-&gtverity;\newline\newline    if (!v-&gthash || unlikely(offset &gt= f-&gtdata_size)) {\newline        return false;\newline    }\newline\newline    uint64_t hash_offset = (offset / FEC_BLOCKSIZE) * SHA256_DIGEST_LENGTH;\newline\newline    if (unlikely(hash_offset &gt\newline            v-&gthash_data_blocks * FEC_BLOCKSIZE - SHA256_DIGEST_LENGTH)) {\newline        return false;\newline    }\newline\newline    return !memcmp(v-&gtzero_hash, &ampv-&gthash[hash_offset], SHA256_DIGEST_LENGTH);\newline}\newline","check if `offset&#039 is within a block expected to contain zeros \newline","6009438","bsdstubs.c","char *strndup(const char *src, size_t len)\newline{\newline	char *out = malloc(len + 1);\newline\newline	strlcpy(out, src, len + 1);\newline\newline	return out;\newline}\newline","\newline Creates a memory buffer and copies at most &#039len&#039 characters to it.\newline If &#039len&#039 is less than the length of the source string, truncation occured.\newline \newline","3661007","nbd-server.c","static inline void consume(CLIENT* c, size_t len, void * buf, size_t bufsiz) {\newline	size_t curlen;\newline	while (len&gt0) {\newline		curlen = (len&gtbufsiz)?bufsiz:len;\newline		socket_read(c, buf, curlen);\newline		len -= curlen;\newline	}\newline}\newline","\newline Consume data from a socket that we don&#039t want\newline \newline @param c the client to read from\newline @param len the number of bytes to consume\newline @param buf a buffer\newline @param bufsiz the size of the buffer\newline \newline","177389","zookeeper.c","void free_duplicate_path(const char *free_path, const char* path) {\newline    if (free_path != path) {\newline        free((void*)free_path);\newline    }\newline}\newline","\newline deallocated the free_path only its beeen allocated\newline and not equal to path\newline \newline","1345397","verify_packages.c","void CleanScheduledPackages(void)\newline{\newline    DeletePackageManagers(PACKAGE_SCHEDULE);\newline    PACKAGE_SCHEDULE = NULL;\newline    DeletePackageManagers(INSTALLED_PACKAGE_LISTS);\newline    INSTALLED_PACKAGE_LISTS = NULL;\newline}\newline","\newline @brief Clean the package schedule and installed lists.\newline \newline Called by cf-agent only. Cleans bookkeeping data.\newline \newline \newline","216177","scan_next_media_url.c","const char *quvi_scan_next_media_url(quvi_scan_t handle)\newline{\newline  _quvi_scan_t qs = (_quvi_scan_t) handle;\newline\newline  /* If G_DISABLE_CHECKS is defined then the check is not performed. */\newline  g_return_val_if_fail(handle != NULL, NULL);\newline\newline  qs-&gturl.curr.media = (qs-&gturl.curr.media != NULL)\newline                       ? g_slist_next(qs-&gturl.curr.media)\newline                       : qs-&gturl.media;\newline\newline  return ((qs-&gturl.curr.media != NULL)\newline          ? qs-&gturl.curr.media-&gtdata\newline          : NULL);\newline}\newline","@return Next detected media URL (NULL-terminated) string or NULL\newline@note Do not attempt to free the returned string\newline@sa @ref scan_media\newline@ingroup scan\newline \newline","3599205","tabbed_browser.c","void gui_recompute_view_menu_choices(void)\newline{\newline	change_tabs_no_redisplay = TRUE;\newline\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewtexts_item),\newline				       settings.showtexts);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewcomms_item),\newline				       settings.showcomms);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewdicts_item),\newline				       settings.showdicts);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewpreview_item),\newline				       settings.showpreview);\newline\newline	change_tabs_no_redisplay = FALSE;\newline}\newline","\newline Name\newline gui_recompute_view_menu_choices\newline \newline Synopsis\newline #include &quottabbed_browser.h&quot\newline \newline void gui_recompute_view_menu_choices(void)\newline \newline Description\newline formerly part of gui_recompute_shows, but moved here to keep from\newline triggering toggled signals on these items before new content is\newline ready to be displayed\newline \newline Return value\newline void\newline \newline","4120501","wire2str.c","static int gldns_wire2str_ipseckey_scan_internal(uint8_t** d, size_t* dl,\newline	char** s, size_t* sl, uint8_t* pkt, size_t pktlen)\newline{\newline	/* http://www.ietf.org/internet-drafts/draft-ietf-ipseckey-rr-12.txt*/\newline	uint8_t precedence, gateway_type, algorithm;\newline	int w = 0;\newline\newline	if(*dl &lt 3) return -1;\newline	precedence = (*d)[0];\newline	gateway_type = (*d)[1];\newline	algorithm = (*d)[2];\newline	if(gateway_type &gt 3)\newline		return -1; /* unknown */\newline	(*d)+=3;\newline	(*dl)-=3;\newline	w += gldns_str_print(s, sl, &quot%d %d %d &quot,\newline		(int)precedence, (int)gateway_type, (int)algorithm);\newline\newline	switch(gateway_type) {\newline	case 0: /* no gateway */\newline		w += gldns_str_print(s, sl, &quot.&quot);\newline		break;\newline	case 1: /* ip4 */\newline		w += gldns_wire2str_a_scan(d, dl, s, sl);\newline		break;\newline	case 2: /* ip6 */\newline		w += gldns_wire2str_aaaa_scan(d, dl, s, sl);\newline		break;\newline	case 3: /* dname */\newline		w += gldns_wire2str_dname_scan(d, dl, s, sl, pkt, pktlen);\newline		break;\newline	default: /* unknown */\newline		return -1;\newline	}\newline\newline	if(*dl &lt 1)\newline		return -1;\newline	w += gldns_str_print(s, sl, &quot &quot);\newline	w += gldns_wire2str_b64_scan_num(d, dl, s, sl, *dl);\newline	return w;\newline}\newline","internal scan routine that can modify arguments on failure \newline","3687838","drive.c","unsigned int burn_drive_count(void)\newline{\newline	return drivetop + 1;\newline}\newline","\newlinevoid drive_read_lead_in(int dnum)\newline{\newline mmc_read_lead_in(&ampdrive_array[dnum], get_4k());\newline}\newline \newline","685357","strftime.c","#define ISDIGIT(Ch) ((unsigned int) (Ch) - L_(&#0390&#039) &lt= 9)\newline\newline#if FPRINTFTIME\newlinestatic void\newlinefwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\newline{\newline  while (len-- &gt 0)\newline    {\newline      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\newline      ++src;\newline    }\newline}\newline","We don&#039t use &#039isdigit&#039 here since the locale dependent\newlineinterpretation is not what we want here. We only need to accept\newlinethe arabic digits in the ASCII range. One day there is perhaps a\newlinemore reliable way to accept other sets of digits. \newline","","","","","","","","","","on","","","on","","on","","","on","on","","","","","","","","","","","","","","","","","","","","","","","","Processes the actions received from the socket.","Called when a window changes its WM_WINDOW_ROLE.","Wraps the SRM request.","check if `offset' is within a block expected to contain zeros","Creates a memory buffer and copies at most 'len' characters to it.","Consume data from a socket","deallocated the free_path only its beeen allocatedand not equal to path","Clean the package schedule and installed lists.","@return Next detected media URL (NULL-terminated) string","{}","internal scan routine that can modify arguments on failure","Stop overlay video.","{}","acceptthe arabic digits in the ASCII range.","{}","Prints out a reference to anobject pattern intermediate node","Snag a single float type variable","{}","{}","show module in left panel in all views","Initialize DB server"
"360ZO6N6J1JMOYZ6DZWIH7ZRFVG9MO","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3ND9UOO81K2FHWRMW0AWKXO2TIKWLI","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 21:26:32 PDT 2019","Wed Apr 17 21:32:59 PDT 2019","Fri Apr 19 21:32:59 PDT 2019","2019-04-20 04:33:21 UTC","","","387","100% (10/10)","100% (10/10)","100% (10/10)","4476506","seas_action.c","int process_action(as_p the_as)\newline{\newline   unsigned int ac_len;\newline   ac_len=(the_as-&gtac_buffer.s[0]&lt&lt24)|(the_as-&gtac_buffer.s[1]&lt&lt16)|(the_as-&gtac_buffer.s[2]&lt&lt8)|((the_as-&gtac_buffer.s[3])&amp0xFF);\newline   /*yeah, it comes in network byte order*/\newline   /*if ac_len &gt BUF_SIZE then a flag should be put on the AS so that the whole length\newline    * of the action is skipped, until a mechanism for handling big packets is implemented*/\newline   if(use_stats)\newline      stats_reply();\newline   if(ac_len&gtAS_BUF_SIZE){\newline      LM_WARN(&quotaction too big (%d)!!! should be skipped and&quot\newline			  &quot an error returned!\\n&quot,ac_len);\newline      return -1;\newline   }\newline   while (the_as-&gtac_buffer.len&gt=ac_len) {\newline      LM_DBG(&quotProcessing action %d bytes long\\n&quot,ac_len);\newline      switch(the_as-&gtac_buffer.s[4]){\newline	 case REPLY_PROV:\newline	 case REPLY_FIN:\newline	    LM_DBG(&quotProcessing a REPLY action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_reply(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case UAC_REQ:\newline	    LM_DBG(&quotProcessing an UAC REQUEST action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_uac_req(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case AC_CANCEL:\newline	    LM_DBG(&quotProcessing a CANCEL REQUEST action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_cancel(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case SL_MSG:\newline	    LM_DBG(&quotProcessing a STATELESS MESSAGE action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    ac_sl_msg(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 case JAIN_PONG:\newline	    LM_DBG(&quotProcessing a PONG\\n&quot);\newline	    ac_jain_pong(the_as,the_as-&gtac_buffer.s+5,ac_len-5);\newline	    break;\newline	 default:\newline	    LM_DBG(&quotProcessing a UNKNOWN TYPE action from AS (length=%d): %.*s\\n&quot,\newline				ac_len,the_as-&gtname.len,the_as-&gtname.s);\newline	    break;\newline      }\newline      memmove(the_as-&gtac_buffer.s,the_as-&gtac_buffer.s+ac_len,(the_as-&gtac_buffer.len)-ac_len);\newline      (the_as-&gtac_buffer.len)-=ac_len;\newline      if(the_as-&gtac_buffer.len&gt5){\newline	 ac_len=(the_as-&gtac_buffer.s[0]&lt&lt24)|(the_as-&gtac_buffer.s[1]&lt&lt16)|(the_as-&gtac_buffer.s[2]&lt&lt8)|((the_as-&gtac_buffer.s[3])&amp0xFF);\newline      }else{\newline	 return 0;\newline      }\newline   }\newline   return 0;\newline}\newline","Processes the actions received from the socket.\newline returns\newline -1 on error\newline 0 on success\newline \newline","1086027","nvidia_vid.c","static void rivatv_overlay_stop (struct rivatv_info *info) {\newline	switch (info-&gtchip.arch ) {\newline	case NV_ARCH_10:\newline	case NV_ARCH_20:\newline    case NV_ARCH_30:\newline		/* NV_PVIDEO_COLOR_KEY */\newline		/* Xv-Extension-Hack: Restore previously saved value. */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0xB00, info-&gtcolorkey);\newline		/* NV_PVIDEO_STOP */\newline		VID_OR32 (info-&gtchip.PVIDEO, 0x704, 0x11);\newline		/* NV_PVIDEO_BUFFER */\newline		VID_AND32 (info-&gtchip.PVIDEO, 0x700, ~0x11);\newline		/* NV_PVIDEO_INTR_EN_BUFFER */\newline//		VID_AND32 (info-&gtchip.PVIDEO, 0x140, ~0x11);\newline		break;\newline	case NV_ARCH_03:\newline	case NV_ARCH_04:\newline		/* NV_PVIDEO_KEY */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x240, info-&gtcolorkey);\newline		/* NV_PVIDEO_OVERLAY_VIDEO_OFF */\newline		VID_AND32 (info-&gtchip.PVIDEO, 0x244, ~0x01);\newline		/* NV_PVIDEO_INTR_EN_0_NOTIFY */\newline//		VID_AND32 (info-&gtchip.PVIDEO, 0x140, ~0x01);\newline		/* NV_PVIDEO_OE_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x224, 0);\newline		/* NV_PVIDEO_SU_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x228, 0);\newline		/* NV_PVIDEO_RM_STATE */\newline		VID_WR32 (info-&gtchip.PVIDEO, 0x22C, 0);\newline		break;\newline	}\newline}\newline","Stop overlay video. \newline","3672130","lnp-logical.c","int lnp_logical_write(const void* buf,size_t len) {\newline  unsigned char tmp;\newline\newline#ifdef CONF_TM\newline  if (sem_wait(&amptx_sem) == -1)\newline  	return tx_state;\newline#endif\newline\newline#ifdef CONF_AUTOSHUTOFF\newline  shutoff_restart();\newline#endif\newline\newline	if (wait_event(write_allow,0) != 0)\newline	{\newline	  lnp_timeout_reset();\newline\newline  	tx_verify=tx_ptr=buf;                 // what to transmit\newline	  tx_end=buf+len;\newline\newline	  tx_state=TX_ACTIVE;\newline	  S_SR&amp=~(SSR_TRANS_EMPTY | SSR_TRANS_END); // clear flags\newline	  S_CR|=SCR_TRANSMIT | SCR_TX_IRQ | SCR_TE_IRQ; // enable transmit &amp irqs\newline\newline	  wait_event(write_complete,0);\newline\newline	  // determine delay before next transmission\newline	  //\newline	  if(tx_state==TX_IDLE)\newline	    tmp=LNP_WAIT_TXOK;\newline	  else\newline	    tmp=LNP_WAIT_COLL + ( ((unsigned char) 0x0f) &amp\newline	        ( ((unsigned char) len)+\newline	          ((unsigned char*)buf)[len-1]+\newline	          ((unsigned char) get_system_up_time())    ) );\newline	  allow_tx=get_system_up_time()+tmp;\newline	}\newline\newline#ifdef CONF_TM\newline  sem_post(&amptx_sem);\newline#endif\newline\newline  return tx_state;\newline}\newline","! \\param buf data to transmit\newline\\param len number of bytes to transmit\newline\\return 0 on success, else collision\newline \newline","6008320","objrtcmp.c","static void IntermediatePatternNodeReference(\newline  void *theEnv,\newline  OBJECT_PATTERN_NODE *thePattern,\newline  FILE *theFile,\newline  int imageID,\newline  int maxIndices)\newline  {\newline   if (thePattern == NULL)\newline     fprintf(theFile,&quotNULL&quot);\newline   else\newline     {\newline      fprintf(theFile,&quot&amp%s%d_%d[%d]&quot,\newline                    ObjectPNPrefix(),imageID,\newline                    (((int) thePattern-&gtbsaveID) / maxIndices) + 1,\newline                    ((int) thePattern-&gtbsaveID) % maxIndices);\newline     }\newline  }\newline","\newlineNAME : IntermediatePatternNodeReference\newlineDESCRIPTION : Prints out a reference to an\newlineobject pattern intermediate node\newlineINPUTS : 1) A pointer to the object pattern\newlineintermediate node\newline2) A pointer to the output file\newline3) The id of constructs-to-c image\newline4) The maximum number of indices\newlineallowed in any single array\newlinein the image\newlineRETURNS : 1 if OK, 0 if could not open a file\newlineSIDE EFFECTS : Reference to object pattern alpha\newlinememory printed\newlineNOTES : None\newline \newline","5436470","header.c","void *snag_float(FILE *fpin, char *s, char *value, int *group, int *type)\newline{\newline  float *item;\newline\newline  get_next_group(fpin, REQUIRED, s, value, group, type);\newline\newline  if (*group &gt 59 || *group &lt 10) {\newline    rewind_file();\newline    return NULL;\newline  }\newline  \newline  item = (float *)malloc(sizeof(float));\newline  if (!item) {\newline    fprintf(stderr,&quotmalloc failed\\n&quot);\newline    exit(0);\newline  }\newline\newline  *item = atof(value);\newline  return (void *)item;\newline}\newline","\newline Snag a single float type variable\newline \newline","6375060","jmt.c","static void parse_add_scan(struct jmt_parse *parse, ind_t j,\newline                           struct state *s, ind_t i,\newline                           ind_t lens, ind_t k, ind_t item) {\newline    ensure(item &lt parse-&gtsets[k]-&gtitems.used, parse);\newline\newline    parse_add_item(parse, j, s, i, R_SCAN, lens, k, item, EPS, IND_MAX);\newline error:\newline    return;\newline}\newline","Add item (s,i) to E_j and record that it was added because of scanning\newline with lens starting from item item in E_k.\newline \newline [j, (s,i)] -&gt [k, item]\newline \newline","3687271","reportgenerator.cpp","void ReportGenerator::createPdfFromArchive( const QString&amp docID, dbID archId )\newline{\newline  mDocId = docID;\newline  mArchId = archId;\newline  fillupTemplateFromArchive( archId );\newline  // Method fillupTemplateFromArchive raises a signal when the archive was\newline  // generated. This signal gets connected to slotConvertTemplate in the\newline  // constructor of this class.\newline}\newline","\newline docID: document ID\newline dbId: database ID of the archived doc.\newline \newline","2228920","metadata_view.c","uint32_t views(dt_lib_module_t *self)\newline{\newline  return DT_VIEW_ALL;\newline}\newline","show module in left panel in all views \newline","6199359","proxyd.c","static void vbi_proxyd_init( void )\newline{\newline   struct sigaction  act;\newline\newline   if (opt_no_detach == FALSE)\newline   {\newline      if (fork() &gt 0)\newline         exit(0);\newline      close(0); \newline      open(&quot/dev/null&quot, O_RDONLY, 0);\newline\newline      if (opt_debug_level == 0)\newline      {\newline         close(1);\newline         open(&quot/dev/null&quot, O_WRONLY, 0);\newline         close(2);\newline         dup(1);\newline\newline         setsid();\newline      }\newline   }\newline\newline   /* ignore broken pipes (handled by select/read) */\newline   memset(&ampact, 0, sizeof(act));\newline   act.sa_handler = SIG_IGN;\newline   sigaction(SIGPIPE, &ampact, NULL);\newline\newline   /* handle alarm timers (for channel change scheduling) */\newline   memset(&ampact, 0, sizeof(act));\newline   act.sa_handler = vbi_proxyd_alarm_handler;\newline   sigaction(SIGALRM, &ampact, NULL);\newline\newline   /* catch deadly signals for a clean shutdown (remove socket file) */\newline   memset(&ampact, 0, sizeof(act));\newline   sigemptyset(&ampact.sa_mask);\newline   sigaddset(&ampact.sa_mask, SIGINT);\newline   sigaddset(&ampact.sa_mask, SIGTERM);\newline   sigaddset(&ampact.sa_mask, SIGHUP);\newline   act.sa_handler = vbi_proxyd_signal_handler;\newline   act.sa_flags = SA_ONESHOT;\newline   sigaction(SIGINT, &ampact, NULL);\newline   sigaction(SIGTERM, &ampact, NULL);\newline   sigaction(SIGHUP, &ampact, NULL);\newline}\newline","----------------------------------------------------------------------------\newline Initialize DB server\newline \newline","101386","handlers.c","static bool handle_windowrole_change(void *data, xcb_connection_t *conn, uint8_t state,\newline                                     xcb_window_t window, xcb_atom_t atom, xcb_get_property_reply_t *prop) {\newline    Con *con;\newline    if ((con = con_by_window_id(window)) == NULL || con-&gtwindow == NULL)\newline        return false;\newline\newline    window_update_role(con-&gtwindow, prop, false);\newline\newline    return true;\newline}\newline","\newline Called when a window changes its WM_WINDOW_ROLE.\newline \newline \newline","5750936","gfal_srm_readdir.c","static struct dirent *gfal_srm_readdir_pipeline(plugin_handle ch,\newline    gfal_srm_opendir_handle oh, struct stat *st, GError **err)\newline{\newline    GError *tmp_err = NULL;\newline\newline    // Nothing yet, so get the bulk\newline    if (oh-&gtsrm_file_statuses == NULL) {\newline        gfal_srm_readdir_internal(ch, oh, &amptmp_err);\newline        if (tmp_err) {\newline            gfal2_propagate_prefixed_error(err, tmp_err, __func__);\newline            return NULL;\newline        }\newline    }\newline\newline    // Empty directory\newline    if (oh-&gtsrm_file_statuses == NULL || oh-&gtsrm_file_statuses-&gtnbsubpaths == 0) {\newline        return NULL;\newline    }\newline\newline    // Done here\newline    if (oh-&gtresponse_index &gt= oh-&gtsrm_file_statuses-&gtnbsubpaths) {\newline        return NULL;\newline    }\newline\newline    // Iterate and return statuses\newline    struct dirent *ret = gfal_srm_readdir_convert_result(ch, oh-&gtsurl,\newline        &ampoh-&gtsrm_file_statuses-&gtsubpaths[oh-&gtresponse_index], &ampoh-&gtdirent_buffer,\newline        st, &amptmp_err);\newline    oh-&gtresponse_index++;\newline\newline    // If chunk listing, and the index passed the last entry in the buffer,\newline    // release, and prepare next bulk\newline    if (oh-&gtis_chunked_listing &amp&amp oh-&gtresponse_index &gt= oh-&gtchunk_size) {\newline        oh-&gtchunk_offset += oh-&gtchunk_size;\newline        gfal_srm_external_call.srm_srmv2_mdfilestatus_delete(oh-&gtsrm_file_statuses, 1);\newline        oh-&gtsrm_file_statuses = NULL;\newline    }\newline\newline    return ret;\newline}\newline","\newline Wraps the SRM request.\newline Request each chunks, then iterates through the responses as readdir is called\newline \newline","4251155","fec_read.cpp","static inline bool is_zero(fec_handle *f, uint64_t offset)\newline{\newline    verity_info *v = &ampf-&gtverity;\newline\newline    if (!v-&gthash || unlikely(offset &gt= f-&gtdata_size)) {\newline        return false;\newline    }\newline\newline    uint64_t hash_offset = (offset / FEC_BLOCKSIZE) * SHA256_DIGEST_LENGTH;\newline\newline    if (unlikely(hash_offset &gt\newline            v-&gthash_data_blocks * FEC_BLOCKSIZE - SHA256_DIGEST_LENGTH)) {\newline        return false;\newline    }\newline\newline    return !memcmp(v-&gtzero_hash, &ampv-&gthash[hash_offset], SHA256_DIGEST_LENGTH);\newline}\newline","check if `offset&#039 is within a block expected to contain zeros \newline","6009438","bsdstubs.c","char *strndup(const char *src, size_t len)\newline{\newline	char *out = malloc(len + 1);\newline\newline	strlcpy(out, src, len + 1);\newline\newline	return out;\newline}\newline","\newline Creates a memory buffer and copies at most &#039len&#039 characters to it.\newline If &#039len&#039 is less than the length of the source string, truncation occured.\newline \newline","3661007","nbd-server.c","static inline void consume(CLIENT* c, size_t len, void * buf, size_t bufsiz) {\newline	size_t curlen;\newline	while (len&gt0) {\newline		curlen = (len&gtbufsiz)?bufsiz:len;\newline		socket_read(c, buf, curlen);\newline		len -= curlen;\newline	}\newline}\newline","\newline Consume data from a socket that we don&#039t want\newline \newline @param c the client to read from\newline @param len the number of bytes to consume\newline @param buf a buffer\newline @param bufsiz the size of the buffer\newline \newline","177389","zookeeper.c","void free_duplicate_path(const char *free_path, const char* path) {\newline    if (free_path != path) {\newline        free((void*)free_path);\newline    }\newline}\newline","\newline deallocated the free_path only its beeen allocated\newline and not equal to path\newline \newline","1345397","verify_packages.c","void CleanScheduledPackages(void)\newline{\newline    DeletePackageManagers(PACKAGE_SCHEDULE);\newline    PACKAGE_SCHEDULE = NULL;\newline    DeletePackageManagers(INSTALLED_PACKAGE_LISTS);\newline    INSTALLED_PACKAGE_LISTS = NULL;\newline}\newline","\newline @brief Clean the package schedule and installed lists.\newline \newline Called by cf-agent only. Cleans bookkeeping data.\newline \newline \newline","216177","scan_next_media_url.c","const char *quvi_scan_next_media_url(quvi_scan_t handle)\newline{\newline  _quvi_scan_t qs = (_quvi_scan_t) handle;\newline\newline  /* If G_DISABLE_CHECKS is defined then the check is not performed. */\newline  g_return_val_if_fail(handle != NULL, NULL);\newline\newline  qs-&gturl.curr.media = (qs-&gturl.curr.media != NULL)\newline                       ? g_slist_next(qs-&gturl.curr.media)\newline                       : qs-&gturl.media;\newline\newline  return ((qs-&gturl.curr.media != NULL)\newline          ? qs-&gturl.curr.media-&gtdata\newline          : NULL);\newline}\newline","@return Next detected media URL (NULL-terminated) string or NULL\newline@note Do not attempt to free the returned string\newline@sa @ref scan_media\newline@ingroup scan\newline \newline","3599205","tabbed_browser.c","void gui_recompute_view_menu_choices(void)\newline{\newline	change_tabs_no_redisplay = TRUE;\newline\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewtexts_item),\newline				       settings.showtexts);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewcomms_item),\newline				       settings.showcomms);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewdicts_item),\newline				       settings.showdicts);\newline	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widgets.viewpreview_item),\newline				       settings.showpreview);\newline\newline	change_tabs_no_redisplay = FALSE;\newline}\newline","\newline Name\newline gui_recompute_view_menu_choices\newline \newline Synopsis\newline #include &quottabbed_browser.h&quot\newline \newline void gui_recompute_view_menu_choices(void)\newline \newline Description\newline formerly part of gui_recompute_shows, but moved here to keep from\newline triggering toggled signals on these items before new content is\newline ready to be displayed\newline \newline Return value\newline void\newline \newline","4120501","wire2str.c","static int gldns_wire2str_ipseckey_scan_internal(uint8_t** d, size_t* dl,\newline	char** s, size_t* sl, uint8_t* pkt, size_t pktlen)\newline{\newline	/* http://www.ietf.org/internet-drafts/draft-ietf-ipseckey-rr-12.txt*/\newline	uint8_t precedence, gateway_type, algorithm;\newline	int w = 0;\newline\newline	if(*dl &lt 3) return -1;\newline	precedence = (*d)[0];\newline	gateway_type = (*d)[1];\newline	algorithm = (*d)[2];\newline	if(gateway_type &gt 3)\newline		return -1; /* unknown */\newline	(*d)+=3;\newline	(*dl)-=3;\newline	w += gldns_str_print(s, sl, &quot%d %d %d &quot,\newline		(int)precedence, (int)gateway_type, (int)algorithm);\newline\newline	switch(gateway_type) {\newline	case 0: /* no gateway */\newline		w += gldns_str_print(s, sl, &quot.&quot);\newline		break;\newline	case 1: /* ip4 */\newline		w += gldns_wire2str_a_scan(d, dl, s, sl);\newline		break;\newline	case 2: /* ip6 */\newline		w += gldns_wire2str_aaaa_scan(d, dl, s, sl);\newline		break;\newline	case 3: /* dname */\newline		w += gldns_wire2str_dname_scan(d, dl, s, sl, pkt, pktlen);\newline		break;\newline	default: /* unknown */\newline		return -1;\newline	}\newline\newline	if(*dl &lt 1)\newline		return -1;\newline	w += gldns_str_print(s, sl, &quot &quot);\newline	w += gldns_wire2str_b64_scan_num(d, dl, s, sl, *dl);\newline	return w;\newline}\newline","internal scan routine that can modify arguments on failure \newline","3687838","drive.c","unsigned int burn_drive_count(void)\newline{\newline	return drivetop + 1;\newline}\newline","\newlinevoid drive_read_lead_in(int dnum)\newline{\newline mmc_read_lead_in(&ampdrive_array[dnum], get_4k());\newline}\newline \newline","685357","strftime.c","#define ISDIGIT(Ch) ((unsigned int) (Ch) - L_(&#0390&#039) &lt= 9)\newline\newline#if FPRINTFTIME\newlinestatic void\newlinefwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\newline{\newline  while (len-- &gt 0)\newline    {\newline      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\newline      ++src;\newline    }\newline}\newline","We don&#039t use &#039isdigit&#039 here since the locale dependent\newlineinterpretation is not what we want here. We only need to accept\newlinethe arabic digits in the ASCII range. One day there is perhaps a\newlinemore reliable way to accept other sets of digits. \newline","","","","","","","","","","","","","on","","on","","","","on","","","","","","","","","","","","","","","","","","on","","","","","","Processes the actions received from the socket.","Called when a window changes","Request each chunks,","check if `offset' is within a block expected to contain zeros","Creates a memory buffer and copies at most 'len' characters to it.","Consume data from a socket that we don't want","deallocated the free_path","Clean the package schedule and installed lists.","Do not attempt to free the returned string","moved here to keep from triggering toggled signals","modify arguments on failure","Stop overlay video.","{}","We only need to accept the arabic digits in the ASCII range.","{}","Prints out a reference to an object pattern intermediate node","Snag a single float type variable","Add item (s,i) to E_j and record that","{}","show module in left panel in all views","Initialize DB server"
"37AQKJ12TXO9L8Y4K22BULVV3AFTT9","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","37XITHEISW9H6WGUKT7RUFQY7SCRCB","A2M2K3PO5ALBE2","Approved","Wed Apr 17 16:07:18 PDT 2019","Wed Apr 17 16:12:25 PDT 2019","Fri Apr 19 16:12:25 PDT 2019","2019-04-19 23:13:21 UTC","","","307","100% (13/13)","100% (13/13)","100% (13/13)","6372539","io_update.c","static int test_update(int type)\newline{\newline	struct ubi_mkvol_request req;\newline	const char *name = PROGRAM_NAME &quot:io_update()&quot;\newline	int alignments[] = ALIGNMENTS(dev_info.leb_size);\newline	struct ubi_vol_info vol_info;\newline	char vol_node[strlen(UBI_VOLUME_PATTERN) + 100];\newline	unsigned int i;\newline\newline	for (i = 0; i &lt sizeof(alignments)/sizeof(int); i++) {\newline		int leb_size;\newline\newline		req.vol_id = UBI_VOL_NUM_AUTO;\newline		req.vol_type = type;\newline		req.name = name;\newline\newline		req.alignment = alignments[i];\newline		req.alignment -= req.alignment % dev_info.min_io_size;\newline		if (req.alignment == 0)\newline			req.alignment = dev_info.min_io_size;\newline\newline		leb_size = dev_info.leb_size - dev_info.leb_size % req.alignment;\newline		req.bytes =  MIN_AVAIL_EBS * leb_size;\newline\newline		if (ubi_mkvol(libubi, node, &ampreq)) {\newline			failed(&quotubi_mkvol&quot);\newline			return -1;\newline		}\newline\newline		sprintf(vol_node, UBI_VOLUME_PATTERN, dev_info.dev_num,\newline			req.vol_id);\newline		if (ubi_get_vol_info(libubi, vol_node, &ampvol_info)) {\newline			failed(&quotubi_get_vol_info&quot);\newline			goto remove;\newline		}\newline\newline		if (test_update1(&ampvol_info, 0)) {\newline			errorm(&quotalignment = %d&quot, req.alignment);\newline			goto remove;\newline		}\newline\newline		if (vol_info.type != UBI_STATIC_VOLUME) {\newline			if (test_update1(&ampvol_info, 1)) {\newline				errorm(&quotalignment = %d&quot, req.alignment);\newline				goto remove;\newline			}\newline		}\newline\newline		if (ubi_rmvol(libubi, node, req.vol_id)) {\newline			failed(&quotubi_rmvol&quot);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline\newlineremove:\newline	ubi_rmvol(libubi, node, req.vol_id);\newline	return -1;\newline}\newline","\newline test_update - check volume update and atomic LEB change capabilities.\newline \newline @type volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)\newline \newline This function returns %0 in case of success and %-1 in case of failure.\newline \newline","6193619","goa-generated.c","void goa_object_skeleton_set_account (GoaObjectSkeleton *object, GoaAccount *interface_)\newline{\newline  g_object_set (G_OBJECT (object), &quotaccount&quot, interface_, NULL);\newline}\newline","\newline goa_object_skeleton_set_account:\newline @object: A #GoaObjectSkeleton.\newline @interface_: (allow-none): A #GoaAccount or %NULL to clear the interface.\newline \newline Sets the #GoaAccount instance for the D-Bus interface &ltlink linkend=&quotgdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page&quot&gtorg.gnome.OnlineAccounts.Account&lt/link&gt on @object.\newline \newline","287239","list.c","static int list_ust_events(void)\newline{\newline	int i, size, ret = CMD_SUCCESS;\newline	struct lttng_domain domain;\newline	struct lttng_handle *handle;\newline	struct lttng_event *event_list = NULL;\newline	pid_t cur_pid = 0;\newline	char *cmdline = NULL;\newline\newline	memset(&ampdomain, 0, sizeof(domain));\newline\newline	DBG(&quotGetting UST tracing events&quot);\newline\newline	domain.type = LTTNG_DOMAIN_UST;\newline\newline	handle = lttng_create_handle(NULL, &ampdomain);\newline	if (handle == NULL) {\newline		ret = CMD_ERROR;\newline		goto end;\newline	}\newline\newline	size = lttng_list_tracepoints(handle, &ampevent_list);\newline	if (size &lt 0) {\newline		ERR(&quotUnable to list UST events: %s&quot, lttng_strerror(size));\newline		ret = CMD_ERROR;\newline		goto error;\newline	}\newline\newline	if (lttng_opt_mi) {\newline		/* Mi print */\newline		ret = mi_list_agent_ust_events(event_list, size, &ampdomain);\newline	} else {\newline		/* Pretty print */\newline		MSG(&quotUST events:\\n-------------&quot);\newline\newline		if (size == 0) {\newline			MSG(&quotNone&quot);\newline		}\newline\newline		for (i = 0; i &lt size; i++) {\newline			if (cur_pid != event_list[i].pid) {\newline				cur_pid = event_list[i].pid;\newline				cmdline = get_cmdline_by_pid(cur_pid);\newline				if (cmdline == NULL) {\newline					ret = CMD_ERROR;\newline					goto error;\newline				}\newline				MSG(&quot\\nPID: %d - Name: %s&quot, cur_pid, cmdline);\newline				free(cmdline);\newline			}\newline			print_events(&ampevent_list[i]);\newline		}\newline\newline		MSG(&quot&quot);\newline	}\newline\newlineerror:\newline	free(event_list);\newlineend:\newline	lttng_destroy_handle(handle);\newline	return ret;\newline}\newline","\newline Ask session daemon for all user space tracepoints available.\newline \newline","287788","consumer.c","static void validate_endpoint_status_data_stream(void)\newline{\newline	struct lttng_ht_iter iter;\newline	struct lttng_consumer_stream *stream;\newline\newline	DBG(&quotConsumer delete flagged data stream&quot);\newline\newline	rcu_read_lock();\newline	cds_lfht_for_each_entry(data_ht-&gtht, &ampiter.iter, stream, node.node) {\newline		/* Validate delete flag of the stream */\newline		if (stream-&gtendpoint_status == CONSUMER_ENDPOINT_ACTIVE) {\newline			continue;\newline		}\newline		/* Delete it right now */\newline		consumer_del_stream(stream, data_ht);\newline	}\newline	rcu_read_unlock();\newline}\newline","\newline Delete data stream that are flagged for deletion (endpoint_status).\newline \newline","4978466","nesc-doc.c","static inline void start_html_banner() {\newline  output(&quot&lttable BORDER=\\&quot1\\&quot CELLPADDING=\\&quot3\\&quot CELLSPACING=\\&quot0\\&quot WIDTH=\\&quot100%%\\&quot&gt\\n&quot);\newline  output(&quot&lttr BGCOLOR=\\&quot#CCCCFF\\&quot&gt&lttd&gt\\n&quot);\newline}\newline","\newline Print a nicer looking HTML banner\newline \newline","3591487","clamping.h","static INLINE uint8_t clamp_8bit(int val)\newline{\newline   if (val &gt 255)\newline      return 255;\newline   if (val &lt 0)\newline      return 0;\newline   return (uint8_t)val;\newline}\newline","\newline clamp_8bit:\newline @val : initial value\newline \newline Clamps an unsigned 8-bit value.\newline \newline Returns: a clamped value of initial unsigned 8-bit value @val.\newline \newline","972832","kstyle.cpp","static bool preceeds(const QPoint &amppt, const QRect &ampbound,\newline                     const QStyleOption* opt)\newline{\newline    if (opt-&gtstate &amp QStyle::State_Horizontal)\newline    {\newline        //What&#039s earlier depends on RTL or not\newline        if (opt-&gtdirection == Qt::LeftToRight)\newline            return pt.x() &lt bound.right();\newline        else\newline            return pt.x() &gt bound.x();\newline    }\newline    else\newline    {\newline        return pt.y() &lt bound.y();\newline    }\newline}\newline","\newlineChecks whether the point is before the bound rect for\newlinebound of given orientation\newline \newline","1629529","qtvariantproperty.cpp","QtVariantProperty *QtVariantPropertyManager::addProperty(int propertyType, const QString &ampname)\newline{\newline    if (!isPropertyTypeSupported(propertyType))\newline        return 0;\newline\newline    bool wasCreating = d_ptr-&gtm_creatingProperty;\newline    d_ptr-&gtm_creatingProperty = true;\newline    d_ptr-&gtm_propertyType = propertyType;\newline    QtProperty *property = QtAbstractPropertyManager::addProperty(name);\newline    d_ptr-&gtm_creatingProperty = wasCreating;\newline    d_ptr-&gtm_propertyType = 0;\newline\newline    if (!property)\newline        return 0;\newline\newline    return variantProperty(property);\newline}\newline","!\newlineCreates and returns a variant property of the given \\a propertyType\newlinewith the given \\a name.\newlineIf the specified \\a propertyType is not supported by this variant\newlinemanager, this function returns 0.\newlineDo not use the inherited\newlineQtAbstractPropertyManager::addProperty() function to create a\newlinevariant property (that function will always return 0 since it will\newlinenot be clear what type the property should have).\newline\\sa isPropertyTypeSupported()\newline \newline","3414913","wtree.c","static void on_render_name(GtkTreeViewColumn *tree_column,\newline	 GtkCellRenderer *cell,\newline	 GtkTreeModel *tree_model,\newline	 GtkTreeIter *iter,\newline	 gpointer data)\newline{\newline	/* sets editable to true only for root items */\newline	GtkTreePath *path = gtk_tree_model_get_path(tree_model, iter);\newline	g_object_set (cell, &quoteditable&quot, gtk_tree_path_get_depth(path) &lt= 1, NULL);\newline	gtk_tree_path_free(path);\newline}\newline","\newline name column renderer\newline \newline","5269676","jk_connect.c","int jk_tcp_socket_sendfull(jk_sock_t sd, const unsigned char *b, int len, jk_logger_t *l)\newline{\newline    int sent = 0;\newline    int wr;\newline\newline    JK_TRACE_ENTER(l);\newline\newline    errno = 0;\newline    while (sent &lt len) {\newline        do {\newline#if defined(WIN32) || (defined(NETWARE) &amp&amp defined(__NOVELL_LIBC__))\newline            wr = send(sd, (const char*)(b + sent),\newline                      len - sent, 0);\newline            if (JK_IS_SOCKET_ERROR(wr))\newline                JK_GET_SOCKET_ERRNO();\newline#else\newline            wr = write(sd, b + sent, len - sent);\newline#endif\newline        } while (JK_IS_SOCKET_ERROR(wr) &amp&amp (errno == EINTR || errno == EAGAIN));\newline\newline        if (JK_IS_SOCKET_ERROR(wr)) {\newline            int err;\newline            jk_shutdown_socket(sd, l);\newline            err = (errno &gt 0) ? -errno : errno;\newline            JK_TRACE_EXIT(l);\newline            return err;\newline        }\newline        else if (wr == 0) {\newline            jk_shutdown_socket(sd, l);\newline            JK_TRACE_EXIT(l);\newline            return JK_SOCKET_EOF;\newline        }\newline        sent += wr;\newline    }\newline\newline    JK_TRACE_EXIT(l);\newline    return sent;\newline}\newline","send a message\newline @param sd socket to use\newline @param b buffer containing the data\newline @param len length to send\newline @param l logger\newline @return negative errno: write returns a fatal -1 (!WIN32)\newline negative pseudo errno: send returns SOCKET_ERROR (WIN32)\newline JK_SOCKET_EOF: no bytes could be sent\newline &gt0: success, provided number of bytes send\newline @remark Always closes socket in case of error\newline @remark Cares about errno\newline @bug this fails on Unixes if len is too big for the underlying\newline protocol\newline \newline","6234932","pgm2asc.c","int setc(struct box *box2, wchar_t cc){\newline  int ret=0, w1, w2;\newline  w1=((box2-&gtnum_ac) ? box2-&gtwac[0] : 0);  // weight of replaced char\newline  w2=testac(box2,cc);\newline  if (JOB-&gtcfg.verbose)\newline    fprintf(stderr, &quot\\n#  change %s (%d) to %s (%d to %d) at (%d,%d)&quot,\newline    decode(box2-&gtc,ASCII), w1, decode(cc,ASCII), w2, (100+w2+1)/2,\newline           box2-&gtx0, box2-&gty0);\newline  if (w2) { if (box2-&gtc!=cc) { ret=1; setac(box2,cc,(100+w2+1)/2); } }\newline  // if(JOB-&gtcfg.verbose &amp 4) out_x(box2);\newline  // ToDo: modify per setac (shift ac)\newline  return ret;\newline}\newline","set box2-&gtc to cc if cc is in the ac-list of box2, return 1 on success \newline","3923195","rawtominc.c","static int get_attribute(char *dst, char *key, char *nextarg)\newline     /* ARGSUSED */\newline{\newline   int need_string, need_double;\newline   char *variable;\newline   char *attribute;\newline   char *value;\newline   char *end;\newline   double dvalue;\newline\newline   /* Check for a following argument */\newline   if (nextarg == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot\\&quot%s\\&quot option requires an additional argument\\n&quot,\newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline\newline   /* Figure out whether we need a string or a double */\newline   need_string = (strcmp(key, &quot-sattribute&quot) == 0);\newline   need_double = (strcmp(key, &quot-dattribute&quot) == 0);\newline\newline   /* Get the variable name */\newline   variable = nextarg;\newline   attribute = strchr(variable, &#039:&#039);\newline   if (attribute == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot%s option requires argument &ltvar&gt:&ltattr&gt=&ltval&gt\\n&quot, \newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline   *attribute = &#039\\0&#039;\newline   attribute++;\newline\newline   /* Get the value */\newline   value = strchr(attribute, &#039=&#039);\newline   if (value == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot%s option requires argument &ltvar&gt:&ltattr&gt=&ltval&gt\\n&quot, \newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline   *value = &#039\\0&#039;\newline   value++;\newline\newline   /* Save the information */\newline   attribute_list_size++;\newline   if (attribute_list_size &gt attribute_list_alloc) {\newline      attribute_list_alloc += 10;\newline      if (attribute_list == NULL) {\newline         attribute_list = \newline            malloc(attribute_list_alloc * sizeof(*attribute_list));\newline      }\newline      else {\newline         attribute_list = \newline            realloc(attribute_list, \newline                    attribute_list_alloc * sizeof(*attribute_list));\newline      }\newline   }\newline   attribute_list[attribute_list_size-1].variable = variable;\newline   attribute_list[attribute_list_size-1].attribute = attribute;\newline   attribute_list[attribute_list_size-1].value = value;\newline\newline   /* Try to get a double precision value */\newline   if (!need_string) {\newline      dvalue = strtod(value, &ampend);\newline      if ((end != value) &amp&amp (*end == &#039\\0&#039)) {\newline         attribute_list[attribute_list_size-1].value = NULL;\newline         attribute_list[attribute_list_size-1].double_value = dvalue;\newline      }\newline      else if (need_double) {\newline         (void) fprintf(stderr, \newline                        &quot\\&quot%s\\&quot option requires a numeric argument\\n&quot,\newline                        key);\newline         exit(EXIT_FAILURE);\newline      }\newline   }\newline\newline   return TRUE;\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : get_attribute\newline@INPUT : dst - client data passed by ParseArgv\newlinekey - matching key in argv\newlinenextarg - argument following key in argv\newline@OUTPUT : (none)\newline@RETURNS : TRUE since nextarg is used.\newline@DESCRIPTION: Gets attributes from command line. Syntax for argument is\newline&quot&ltvar&gt:&ltatt&gt=&ltvalue&gt&quot. Numeric values are converted to\newlinedouble precision.\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : May 3, 1994 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4488111","g_cmds_ext.c","int G_ClientNumberFromString( char *s )\newline{\newline  gclient_t *cl;\newline  int       i;\newline  char      s2[ MAX_NAME_LENGTH ];\newline  char      n2[ MAX_NAME_LENGTH ];\newline\newline  // numeric values are just slot numbers\newline  for( i = 0; s[ i ] &amp&amp isdigit( s[ i ] ); i++ );\newline  if( !s[ i ] )\newline  {\newline    i = atoi( s );\newline\newline    if( i &lt 0 || i &gt= level.maxclients )\newline      return -1;\newline\newline    cl = &amplevel.clients[ i ];\newline\newline    if( cl-&gtpers.connected == CON_DISCONNECTED )\newline      return -1;\newline\newline    return i;\newline  }\newline\newline  // check for a name match\newline  G_SanitiseString( s, s2, sizeof( s2 ) );\newline\newline  for( i = 0, cl = level.clients; i &lt level.maxclients; i++, cl++ )\newline  {\newline    if( cl-&gtpers.connected == CON_DISCONNECTED )\newline      continue;\newline\newline    G_SanitiseString( cl-&gtpers.netname, n2, sizeof( n2 ) );\newline\newline    if( !strcmp( n2, s2 ) )\newline      return i;\newline  }\newline\newline  return -1;\newline}\newline","\newline==================\newlineG_ClientNumberFromString\newlineReturns a player number for either a number or name string\newlineReturns -1 if invalid\newline==================\newline \newline","5830315","dbcompat.c","static void convert_version1(FILE *fdb_s, FILE *fdb_t)\newline{\newline  filedb1 fdb1;\newline\newline  fseek(fdb_s, 0L, SEEK_SET);\newline  while (!feof(fdb_s)) {\newline    fread(&ampfdb1, sizeof(filedb1), 1, fdb_s);\newline    if (!feof(fdb_s)) {\newline      if (!(fdb1.stat &amp FILE_UNUSED)) {\newline        filedb_entry *fdbe = malloc_fdbe();\newline\newline        fdbe-&gtstat = fdb1.stat;\newline        if (fdb1.filename[0])\newline          malloc_strcpy(fdbe-&gtfilename, fdb1.filename);\newline        if (fdb1.desc[0])\newline          malloc_strcpy(fdbe-&gtdesc, fdb1.desc);\newline        if (fdb1.uploader[0])\newline          malloc_strcpy(fdbe-&gtuploader, fdb1.uploader);\newline        if (fdb1.flags_req[0])\newline          malloc_strcpy(fdbe-&gtflags_req, (char *) fdb1.flags_req);\newline        fdbe-&gtuploaded = fdb1.uploaded;\newline        fdbe-&gtsize = fdb1.size;\newline        fdbe-&gtgots = fdb1.gots;\newline        if (fdb1.sharelink[0])\newline          malloc_strcpy(fdbe-&gtsharelink, fdb1.sharelink);\newline        filedb_addfile(fdb_s, fdbe);\newline        free_fdbe(&ampfdbe);\newline      }\newline    }\newline  }\newline}\newline","Reads file DB v1 entries from fdb_s and saves them to fdb_t in\newline v3 format.\newline \newline","1889395","pulse.c","int volume_pulseaudio(uint32_t sink_idx, const char *sink_name) {\newline    if (!context_ready || default_sink_idx == DEFAULT_SINK_INDEX)\newline        return -1;\newline\newline    pthread_mutex_lock(&amppulse_mutex);\newline    const indexed_volume_t *entry;\newline    TAILQ_FOREACH(entry, &ampcached_volume, entries) {\newline        if (sink_name) {\newline            if (!entry-&gtname || strcmp(entry-&gtname, sink_name)) {\newline                continue;\newline            }\newline        } else {\newline            if (entry-&gtidx != sink_idx) {\newline                continue;\newline            }\newline        }\newline        int vol = entry-&gtvolume;\newline        pthread_mutex_unlock(&amppulse_mutex);\newline        return vol;\newline    }\newline    pthread_mutex_unlock(&amppulse_mutex);\newline    /* first time requires a prime callback call because we only get\newline     * updates when the volume actually changes, but we need it to\newline     * be correct even if it never changes */\newline    pa_threaded_mainloop_lock(main_loop);\newline    get_sink_info(context, sink_idx, sink_name);\newline    pa_threaded_mainloop_unlock(main_loop);\newline    /* show 0 while we don&#039t have this information */\newline    return 0;\newline}\newline","\newline returns the current volume in percent, which, as per PulseAudio,\newline may be &gt 100%\newline \newline","6075469","vqgen.c","void vqgen_unquantize(vqgen *v,quant_meta *q){\newline  long j,k;\newline  float mindel=_float32_unpack(q-&gtmin);\newline  float delta=_float32_unpack(q-&gtdelta);\newline\newline  for(j=0;j&ltv-&gtentries;j++){\newline    float last=0.f;\newline    for(k=0;k&ltv-&gtelements;k++){\newline      float now=_now(v,j)[k];\newline      now=fabs(now)*delta+last+mindel;\newline      if(q-&gtsequencep)last=now;\newline      _now(v,j)[k]=now;\newline    }\newline  }\newline}\newline","much easier :-). Unlike in the codebook, we don&#039t un-log log\newlinescales; we just make sure they&#039re properly offset. \newline","5975093","gd_matrix.c","BGD_DECLARE(int) gdAffineConcat (double dst[6], const double m1[6], const double m2[6])\newline{\newline	double dst0, dst1, dst2, dst3, dst4, dst5;\newline\newline	dst0 = m1[0] * m2[0] + m1[1] * m2[2];\newline	dst1 = m1[0] * m2[1] + m1[1] * m2[3];\newline	dst2 = m1[2] * m2[0] + m1[3] * m2[2];\newline	dst3 = m1[2] * m2[1] + m1[3] * m2[3];\newline	dst4 = m1[4] * m2[0] + m1[5] * m2[2] + m2[4];\newline	dst5 = m1[4] * m2[1] + m1[5] * m2[3] + m2[5];\newline	dst[0] = dst0;\newline	dst[1] = dst1;\newline	dst[2] = dst2;\newline	dst[3] = dst3;\newline	dst[4] = dst4;\newline	dst[5] = dst5;\newline	return GD_TRUE;\newline}\newline","\newline Function: gdAffineConcat\newline Concat (Multiply) two affine transformation matrices.\newline \newline Concats two affine transforms together, i.e. the result\newline will be the equivalent of doing first the transformation m1 and then\newline m2. All parameters can be the same matrix (safe to call using\newline the same array for all three arguments).\newline \newline Parameters:\newline dst - Where to store the resulting affine transform\newline m1 - First affine matrix\newline m2 - Second affine matrix\newline \newline Returns:\newline GD_TRUE on success or GD_FALSE\newline \newline","2285304","rrd_parsetime.c","static char *tod(\newline    rrd_time_value_t * ptv)\newline{\newline    int       hour, minute = 0;\newline    int       tlen;\newline\newline    /* save token status in  case we must abort */\newline    int       scc_sv = scc;\newline    const char *sct_sv = sct;\newline    int       sc_tokid_sv = sc_tokid;\newline\newline    tlen = strlen(sc_token);\newline\newline    /* first pick out the time of day - we assume a HH (COLON|DOT) MM time\newline     */\newline    if (tlen &gt 2) {\newline        return TIME_OK;\newline    }\newline\newline    hour = atoi(sc_token);\newline\newline    token();\newline    if (sc_tokid == SLASH || sc_tokid == DOT) {\newline        /* guess we are looking at a date */\newline        scc = scc_sv;\newline        sct = sct_sv;\newline        sc_tokid = sc_tokid_sv;\newline        snprintf(sc_token, sc_len, &quot%d&quot, hour);\newline        return TIME_OK;\newline    }\newline    if (sc_tokid == COLON) {\newline        try(expect2(NUMBER,\newline                    &quotParsing HH:MM syntax, expecting MM as number, got none&quot));\newline        minute = atoi(sc_token);\newline        if (minute &gt 59) {\newline            panic(e(&quotparsing HH:MM syntax, got MM = %d (&gt59!)&quot, minute));\newline        }\newline        token();\newline    }\newline\newline    /* check if an AM or PM specifier was given\newline     */\newline    if (sc_tokid == AM || sc_tokid == PM) {\newline        if (hour &gt 12) {\newline            panic(e(&quotthere cannot be more than 12 AM or PM hours&quot));\newline        }\newline        if (sc_tokid == PM) {\newline            if (hour != 12) /* 12:xx PM is 12:xx, not 24:xx */\newline                hour += 12;\newline        } else {\newline            if (hour == 12) /* 12:xx AM is 00:xx, not 12:xx */\newline                hour = 0;\newline        }\newline        token();\newline    } else if (hour &gt 23) {\newline        /* guess it was not a time then ... */\newline        scc = scc_sv;\newline        sct = sct_sv;\newline        sc_tokid = sc_tokid_sv;\newline        snprintf(sc_token, sc_len, &quot%d&quot, hour);\newline        return TIME_OK;\newline    }\newline    ptv-&gttm.  tm_hour = hour;\newline    ptv-&gttm.  tm_min = minute;\newline    ptv-&gttm.  tm_sec = 0;\newline\newline    if (ptv-&gttm.tm_hour == 24) {\newline        ptv-&gttm.  tm_hour = 0;\newline        ptv-&gttm.  tm_mday++;\newline    }\newline    return TIME_OK;\newline}                       /* tod */\newline","\newline tod() computes the time of day (TIME-OF-DAY-SPEC)\newline \newline","384772","ib_srp.c","static int ib_srp_parse_integer ( const char *rp_comp, int default_value ) {\newline	int value;\newline	char *end;\newline\newline	value = strtoul ( rp_comp, &ampend, 16 );\newline	if ( *end )\newline		return -EINVAL_INTEGER;\newline\newline	if ( end == rp_comp )\newline		return default_value;\newline\newline	return value;\newline}\newline","\newline Parse IB SRP root path integer value\newline \newline @v rp_comp Root path component string\newline @v default_value Default value to use if component string is empty\newline @ret value Value\newline \newline","4713095","ximage.cpp","void CxImage::Copy(const CxImage &ampsrc, bool copypixels, bool copyselection, bool copyalpha)\newline{\newline	//copy the attributes\newline	memcpy(&ampinfo,&ampsrc.info,sizeof(CXIMAGEINFO));\newline	//rebuild the image\newline	Create(src.GetWidth(),src.GetHeight(),src.GetBpp(),src.GetType());\newline	//copy the pixels and the palette, or at least copy the palette only.\newline	if (copypixels &amp&amp pDib &amp&amp src.pDib) memcpy(pDib,src.pDib,GetSize());\newline	else SetPalette(src.GetPalette());\newline	long nSize = head.biWidth * head.biHeight;\newline	//copy the selection\newline	if (copyselection &amp&amp src.pSelection){\newline		if (pSelection) free(pSelection);\newline		pSelection = (BYTE*)malloc(nSize);\newline		memcpy(pSelection,src.pSelection,nSize);\newline	}\newline	//copy the alpha channel\newline	if (copyalpha &amp&amp src.pAlpha){\newline		if (pAlpha) free(pAlpha);\newline		pAlpha = (BYTE*)malloc(nSize);\newline		memcpy(pAlpha,src.pAlpha,nSize);\newline	}\newline}\newline","\newline Copies the image from an exsisting source\newline \\param src: source image.\newline \\param copypixels: copy the pixels from the source image into the new image.\newline \\param copyselection: copy the selection from source\newline \\param copyalpha: copy the alpha channel from source\newline \newline","321337","procutils.c","static char *safe_strncpy(char *dest, char *src, int n)\newline{\newline	if (!dest || !src)\newline		return NULL;\newline	dest[n] = 0;\newline	return strncpy(dest, src, n);\newline}\newline","\newline Version of strncpy() that returns NULL if either src or dest is NULL\newline and also makes sure destination string is always terminated.\newline \newline","","","on","","","","","on","","","","","","","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","check volume update and atomic LEB change capabilities.","send a message","{}","Numeric values are converted todouble precision.","Returns a player number for either a number or name string","Reads file DB v1 entries from fdb_s","returns the current volume in percent,","{}","Concats two affine transforms together,","computes the time of day","Parse IB SRP root path integer value","Sets the #GoaAccount instance for the D-Bus interface","Copies the image from an exsisting source","makes sure destination string is always terminated.","Ask session daemon for all user space tracepoints available.","Delete data stream that are flagged for deletion","Print a nicer looking HTML banner","Clamps an unsigned 8-bit value.","Checks whether the point is before the bound rect","returns a variant property of the given \a propertyType","name column renderer"
"37AQKJ12TXO9L8Y4K22BULVV3AFTT9","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3ND9UOO81K2FHWRMW0AWKXO2TF1WLT","AVC62JNYAXA45","Approved","Wed Apr 17 14:14:07 PDT 2019","Wed Apr 17 14:45:27 PDT 2019","Fri Apr 19 14:45:27 PDT 2019","2019-04-19 21:46:21 UTC","","","1880","100% (24/24)","100% (24/24)","100% (24/24)","6372539","io_update.c","static int test_update(int type)\newline{\newline	struct ubi_mkvol_request req;\newline	const char *name = PROGRAM_NAME &quot:io_update()&quot;\newline	int alignments[] = ALIGNMENTS(dev_info.leb_size);\newline	struct ubi_vol_info vol_info;\newline	char vol_node[strlen(UBI_VOLUME_PATTERN) + 100];\newline	unsigned int i;\newline\newline	for (i = 0; i &lt sizeof(alignments)/sizeof(int); i++) {\newline		int leb_size;\newline\newline		req.vol_id = UBI_VOL_NUM_AUTO;\newline		req.vol_type = type;\newline		req.name = name;\newline\newline		req.alignment = alignments[i];\newline		req.alignment -= req.alignment % dev_info.min_io_size;\newline		if (req.alignment == 0)\newline			req.alignment = dev_info.min_io_size;\newline\newline		leb_size = dev_info.leb_size - dev_info.leb_size % req.alignment;\newline		req.bytes =  MIN_AVAIL_EBS * leb_size;\newline\newline		if (ubi_mkvol(libubi, node, &ampreq)) {\newline			failed(&quotubi_mkvol&quot);\newline			return -1;\newline		}\newline\newline		sprintf(vol_node, UBI_VOLUME_PATTERN, dev_info.dev_num,\newline			req.vol_id);\newline		if (ubi_get_vol_info(libubi, vol_node, &ampvol_info)) {\newline			failed(&quotubi_get_vol_info&quot);\newline			goto remove;\newline		}\newline\newline		if (test_update1(&ampvol_info, 0)) {\newline			errorm(&quotalignment = %d&quot, req.alignment);\newline			goto remove;\newline		}\newline\newline		if (vol_info.type != UBI_STATIC_VOLUME) {\newline			if (test_update1(&ampvol_info, 1)) {\newline				errorm(&quotalignment = %d&quot, req.alignment);\newline				goto remove;\newline			}\newline		}\newline\newline		if (ubi_rmvol(libubi, node, req.vol_id)) {\newline			failed(&quotubi_rmvol&quot);\newline			return -1;\newline		}\newline	}\newline\newline	return 0;\newline\newlineremove:\newline	ubi_rmvol(libubi, node, req.vol_id);\newline	return -1;\newline}\newline","\newline test_update - check volume update and atomic LEB change capabilities.\newline \newline @type volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)\newline \newline This function returns %0 in case of success and %-1 in case of failure.\newline \newline","6193619","goa-generated.c","void goa_object_skeleton_set_account (GoaObjectSkeleton *object, GoaAccount *interface_)\newline{\newline  g_object_set (G_OBJECT (object), &quotaccount&quot, interface_, NULL);\newline}\newline","\newline goa_object_skeleton_set_account:\newline @object: A #GoaObjectSkeleton.\newline @interface_: (allow-none): A #GoaAccount or %NULL to clear the interface.\newline \newline Sets the #GoaAccount instance for the D-Bus interface &ltlink linkend=&quotgdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page&quot&gtorg.gnome.OnlineAccounts.Account&lt/link&gt on @object.\newline \newline","287239","list.c","static int list_ust_events(void)\newline{\newline	int i, size, ret = CMD_SUCCESS;\newline	struct lttng_domain domain;\newline	struct lttng_handle *handle;\newline	struct lttng_event *event_list = NULL;\newline	pid_t cur_pid = 0;\newline	char *cmdline = NULL;\newline\newline	memset(&ampdomain, 0, sizeof(domain));\newline\newline	DBG(&quotGetting UST tracing events&quot);\newline\newline	domain.type = LTTNG_DOMAIN_UST;\newline\newline	handle = lttng_create_handle(NULL, &ampdomain);\newline	if (handle == NULL) {\newline		ret = CMD_ERROR;\newline		goto end;\newline	}\newline\newline	size = lttng_list_tracepoints(handle, &ampevent_list);\newline	if (size &lt 0) {\newline		ERR(&quotUnable to list UST events: %s&quot, lttng_strerror(size));\newline		ret = CMD_ERROR;\newline		goto error;\newline	}\newline\newline	if (lttng_opt_mi) {\newline		/* Mi print */\newline		ret = mi_list_agent_ust_events(event_list, size, &ampdomain);\newline	} else {\newline		/* Pretty print */\newline		MSG(&quotUST events:\\n-------------&quot);\newline\newline		if (size == 0) {\newline			MSG(&quotNone&quot);\newline		}\newline\newline		for (i = 0; i &lt size; i++) {\newline			if (cur_pid != event_list[i].pid) {\newline				cur_pid = event_list[i].pid;\newline				cmdline = get_cmdline_by_pid(cur_pid);\newline				if (cmdline == NULL) {\newline					ret = CMD_ERROR;\newline					goto error;\newline				}\newline				MSG(&quot\\nPID: %d - Name: %s&quot, cur_pid, cmdline);\newline				free(cmdline);\newline			}\newline			print_events(&ampevent_list[i]);\newline		}\newline\newline		MSG(&quot&quot);\newline	}\newline\newlineerror:\newline	free(event_list);\newlineend:\newline	lttng_destroy_handle(handle);\newline	return ret;\newline}\newline","\newline Ask session daemon for all user space tracepoints available.\newline \newline","287788","consumer.c","static void validate_endpoint_status_data_stream(void)\newline{\newline	struct lttng_ht_iter iter;\newline	struct lttng_consumer_stream *stream;\newline\newline	DBG(&quotConsumer delete flagged data stream&quot);\newline\newline	rcu_read_lock();\newline	cds_lfht_for_each_entry(data_ht-&gtht, &ampiter.iter, stream, node.node) {\newline		/* Validate delete flag of the stream */\newline		if (stream-&gtendpoint_status == CONSUMER_ENDPOINT_ACTIVE) {\newline			continue;\newline		}\newline		/* Delete it right now */\newline		consumer_del_stream(stream, data_ht);\newline	}\newline	rcu_read_unlock();\newline}\newline","\newline Delete data stream that are flagged for deletion (endpoint_status).\newline \newline","4978466","nesc-doc.c","static inline void start_html_banner() {\newline  output(&quot&lttable BORDER=\\&quot1\\&quot CELLPADDING=\\&quot3\\&quot CELLSPACING=\\&quot0\\&quot WIDTH=\\&quot100%%\\&quot&gt\\n&quot);\newline  output(&quot&lttr BGCOLOR=\\&quot#CCCCFF\\&quot&gt&lttd&gt\\n&quot);\newline}\newline","\newline Print a nicer looking HTML banner\newline \newline","3591487","clamping.h","static INLINE uint8_t clamp_8bit(int val)\newline{\newline   if (val &gt 255)\newline      return 255;\newline   if (val &lt 0)\newline      return 0;\newline   return (uint8_t)val;\newline}\newline","\newline clamp_8bit:\newline @val : initial value\newline \newline Clamps an unsigned 8-bit value.\newline \newline Returns: a clamped value of initial unsigned 8-bit value @val.\newline \newline","972832","kstyle.cpp","static bool preceeds(const QPoint &amppt, const QRect &ampbound,\newline                     const QStyleOption* opt)\newline{\newline    if (opt-&gtstate &amp QStyle::State_Horizontal)\newline    {\newline        //What&#039s earlier depends on RTL or not\newline        if (opt-&gtdirection == Qt::LeftToRight)\newline            return pt.x() &lt bound.right();\newline        else\newline            return pt.x() &gt bound.x();\newline    }\newline    else\newline    {\newline        return pt.y() &lt bound.y();\newline    }\newline}\newline","\newlineChecks whether the point is before the bound rect for\newlinebound of given orientation\newline \newline","1629529","qtvariantproperty.cpp","QtVariantProperty *QtVariantPropertyManager::addProperty(int propertyType, const QString &ampname)\newline{\newline    if (!isPropertyTypeSupported(propertyType))\newline        return 0;\newline\newline    bool wasCreating = d_ptr-&gtm_creatingProperty;\newline    d_ptr-&gtm_creatingProperty = true;\newline    d_ptr-&gtm_propertyType = propertyType;\newline    QtProperty *property = QtAbstractPropertyManager::addProperty(name);\newline    d_ptr-&gtm_creatingProperty = wasCreating;\newline    d_ptr-&gtm_propertyType = 0;\newline\newline    if (!property)\newline        return 0;\newline\newline    return variantProperty(property);\newline}\newline","!\newlineCreates and returns a variant property of the given \\a propertyType\newlinewith the given \\a name.\newlineIf the specified \\a propertyType is not supported by this variant\newlinemanager, this function returns 0.\newlineDo not use the inherited\newlineQtAbstractPropertyManager::addProperty() function to create a\newlinevariant property (that function will always return 0 since it will\newlinenot be clear what type the property should have).\newline\\sa isPropertyTypeSupported()\newline \newline","3414913","wtree.c","static void on_render_name(GtkTreeViewColumn *tree_column,\newline	 GtkCellRenderer *cell,\newline	 GtkTreeModel *tree_model,\newline	 GtkTreeIter *iter,\newline	 gpointer data)\newline{\newline	/* sets editable to true only for root items */\newline	GtkTreePath *path = gtk_tree_model_get_path(tree_model, iter);\newline	g_object_set (cell, &quoteditable&quot, gtk_tree_path_get_depth(path) &lt= 1, NULL);\newline	gtk_tree_path_free(path);\newline}\newline","\newline name column renderer\newline \newline","5269676","jk_connect.c","int jk_tcp_socket_sendfull(jk_sock_t sd, const unsigned char *b, int len, jk_logger_t *l)\newline{\newline    int sent = 0;\newline    int wr;\newline\newline    JK_TRACE_ENTER(l);\newline\newline    errno = 0;\newline    while (sent &lt len) {\newline        do {\newline#if defined(WIN32) || (defined(NETWARE) &amp&amp defined(__NOVELL_LIBC__))\newline            wr = send(sd, (const char*)(b + sent),\newline                      len - sent, 0);\newline            if (JK_IS_SOCKET_ERROR(wr))\newline                JK_GET_SOCKET_ERRNO();\newline#else\newline            wr = write(sd, b + sent, len - sent);\newline#endif\newline        } while (JK_IS_SOCKET_ERROR(wr) &amp&amp (errno == EINTR || errno == EAGAIN));\newline\newline        if (JK_IS_SOCKET_ERROR(wr)) {\newline            int err;\newline            jk_shutdown_socket(sd, l);\newline            err = (errno &gt 0) ? -errno : errno;\newline            JK_TRACE_EXIT(l);\newline            return err;\newline        }\newline        else if (wr == 0) {\newline            jk_shutdown_socket(sd, l);\newline            JK_TRACE_EXIT(l);\newline            return JK_SOCKET_EOF;\newline        }\newline        sent += wr;\newline    }\newline\newline    JK_TRACE_EXIT(l);\newline    return sent;\newline}\newline","send a message\newline @param sd socket to use\newline @param b buffer containing the data\newline @param len length to send\newline @param l logger\newline @return negative errno: write returns a fatal -1 (!WIN32)\newline negative pseudo errno: send returns SOCKET_ERROR (WIN32)\newline JK_SOCKET_EOF: no bytes could be sent\newline &gt0: success, provided number of bytes send\newline @remark Always closes socket in case of error\newline @remark Cares about errno\newline @bug this fails on Unixes if len is too big for the underlying\newline protocol\newline \newline","6234932","pgm2asc.c","int setc(struct box *box2, wchar_t cc){\newline  int ret=0, w1, w2;\newline  w1=((box2-&gtnum_ac) ? box2-&gtwac[0] : 0);  // weight of replaced char\newline  w2=testac(box2,cc);\newline  if (JOB-&gtcfg.verbose)\newline    fprintf(stderr, &quot\\n#  change %s (%d) to %s (%d to %d) at (%d,%d)&quot,\newline    decode(box2-&gtc,ASCII), w1, decode(cc,ASCII), w2, (100+w2+1)/2,\newline           box2-&gtx0, box2-&gty0);\newline  if (w2) { if (box2-&gtc!=cc) { ret=1; setac(box2,cc,(100+w2+1)/2); } }\newline  // if(JOB-&gtcfg.verbose &amp 4) out_x(box2);\newline  // ToDo: modify per setac (shift ac)\newline  return ret;\newline}\newline","set box2-&gtc to cc if cc is in the ac-list of box2, return 1 on success \newline","3923195","rawtominc.c","static int get_attribute(char *dst, char *key, char *nextarg)\newline     /* ARGSUSED */\newline{\newline   int need_string, need_double;\newline   char *variable;\newline   char *attribute;\newline   char *value;\newline   char *end;\newline   double dvalue;\newline\newline   /* Check for a following argument */\newline   if (nextarg == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot\\&quot%s\\&quot option requires an additional argument\\n&quot,\newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline\newline   /* Figure out whether we need a string or a double */\newline   need_string = (strcmp(key, &quot-sattribute&quot) == 0);\newline   need_double = (strcmp(key, &quot-dattribute&quot) == 0);\newline\newline   /* Get the variable name */\newline   variable = nextarg;\newline   attribute = strchr(variable, &#039:&#039);\newline   if (attribute == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot%s option requires argument &ltvar&gt:&ltattr&gt=&ltval&gt\\n&quot, \newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline   *attribute = &#039\\0&#039;\newline   attribute++;\newline\newline   /* Get the value */\newline   value = strchr(attribute, &#039=&#039);\newline   if (value == NULL) {\newline      (void) fprintf(stderr, \newline                     &quot%s option requires argument &ltvar&gt:&ltattr&gt=&ltval&gt\\n&quot, \newline                     key);\newline      exit(EXIT_FAILURE);\newline   }\newline   *value = &#039\\0&#039;\newline   value++;\newline\newline   /* Save the information */\newline   attribute_list_size++;\newline   if (attribute_list_size &gt attribute_list_alloc) {\newline      attribute_list_alloc += 10;\newline      if (attribute_list == NULL) {\newline         attribute_list = \newline            malloc(attribute_list_alloc * sizeof(*attribute_list));\newline      }\newline      else {\newline         attribute_list = \newline            realloc(attribute_list, \newline                    attribute_list_alloc * sizeof(*attribute_list));\newline      }\newline   }\newline   attribute_list[attribute_list_size-1].variable = variable;\newline   attribute_list[attribute_list_size-1].attribute = attribute;\newline   attribute_list[attribute_list_size-1].value = value;\newline\newline   /* Try to get a double precision value */\newline   if (!need_string) {\newline      dvalue = strtod(value, &ampend);\newline      if ((end != value) &amp&amp (*end == &#039\\0&#039)) {\newline         attribute_list[attribute_list_size-1].value = NULL;\newline         attribute_list[attribute_list_size-1].double_value = dvalue;\newline      }\newline      else if (need_double) {\newline         (void) fprintf(stderr, \newline                        &quot\\&quot%s\\&quot option requires a numeric argument\\n&quot,\newline                        key);\newline         exit(EXIT_FAILURE);\newline      }\newline   }\newline\newline   return TRUE;\newline\newline}\newline","----------------------------- MNI Header -----------------------------------\newline@NAME : get_attribute\newline@INPUT : dst - client data passed by ParseArgv\newlinekey - matching key in argv\newlinenextarg - argument following key in argv\newline@OUTPUT : (none)\newline@RETURNS : TRUE since nextarg is used.\newline@DESCRIPTION: Gets attributes from command line. Syntax for argument is\newline&quot&ltvar&gt:&ltatt&gt=&ltvalue&gt&quot. Numeric values are converted to\newlinedouble precision.\newline@METHOD : \newline@GLOBALS : \newline@CALLS : \newline@CREATED : May 3, 1994 (Peter Neelin)\newline@MODIFIED : \newline---------------------------------------------------------------------------- \newline","4488111","g_cmds_ext.c","int G_ClientNumberFromString( char *s )\newline{\newline  gclient_t *cl;\newline  int       i;\newline  char      s2[ MAX_NAME_LENGTH ];\newline  char      n2[ MAX_NAME_LENGTH ];\newline\newline  // numeric values are just slot numbers\newline  for( i = 0; s[ i ] &amp&amp isdigit( s[ i ] ); i++ );\newline  if( !s[ i ] )\newline  {\newline    i = atoi( s );\newline\newline    if( i &lt 0 || i &gt= level.maxclients )\newline      return -1;\newline\newline    cl = &amplevel.clients[ i ];\newline\newline    if( cl-&gtpers.connected == CON_DISCONNECTED )\newline      return -1;\newline\newline    return i;\newline  }\newline\newline  // check for a name match\newline  G_SanitiseString( s, s2, sizeof( s2 ) );\newline\newline  for( i = 0, cl = level.clients; i &lt level.maxclients; i++, cl++ )\newline  {\newline    if( cl-&gtpers.connected == CON_DISCONNECTED )\newline      continue;\newline\newline    G_SanitiseString( cl-&gtpers.netname, n2, sizeof( n2 ) );\newline\newline    if( !strcmp( n2, s2 ) )\newline      return i;\newline  }\newline\newline  return -1;\newline}\newline","\newline==================\newlineG_ClientNumberFromString\newlineReturns a player number for either a number or name string\newlineReturns -1 if invalid\newline==================\newline \newline","5830315","dbcompat.c","static void convert_version1(FILE *fdb_s, FILE *fdb_t)\newline{\newline  filedb1 fdb1;\newline\newline  fseek(fdb_s, 0L, SEEK_SET);\newline  while (!feof(fdb_s)) {\newline    fread(&ampfdb1, sizeof(filedb1), 1, fdb_s);\newline    if (!feof(fdb_s)) {\newline      if (!(fdb1.stat &amp FILE_UNUSED)) {\newline        filedb_entry *fdbe = malloc_fdbe();\newline\newline        fdbe-&gtstat = fdb1.stat;\newline        if (fdb1.filename[0])\newline          malloc_strcpy(fdbe-&gtfilename, fdb1.filename);\newline        if (fdb1.desc[0])\newline          malloc_strcpy(fdbe-&gtdesc, fdb1.desc);\newline        if (fdb1.uploader[0])\newline          malloc_strcpy(fdbe-&gtuploader, fdb1.uploader);\newline        if (fdb1.flags_req[0])\newline          malloc_strcpy(fdbe-&gtflags_req, (char *) fdb1.flags_req);\newline        fdbe-&gtuploaded = fdb1.uploaded;\newline        fdbe-&gtsize = fdb1.size;\newline        fdbe-&gtgots = fdb1.gots;\newline        if (fdb1.sharelink[0])\newline          malloc_strcpy(fdbe-&gtsharelink, fdb1.sharelink);\newline        filedb_addfile(fdb_s, fdbe);\newline        free_fdbe(&ampfdbe);\newline      }\newline    }\newline  }\newline}\newline","Reads file DB v1 entries from fdb_s and saves them to fdb_t in\newline v3 format.\newline \newline","1889395","pulse.c","int volume_pulseaudio(uint32_t sink_idx, const char *sink_name) {\newline    if (!context_ready || default_sink_idx == DEFAULT_SINK_INDEX)\newline        return -1;\newline\newline    pthread_mutex_lock(&amppulse_mutex);\newline    const indexed_volume_t *entry;\newline    TAILQ_FOREACH(entry, &ampcached_volume, entries) {\newline        if (sink_name) {\newline            if (!entry-&gtname || strcmp(entry-&gtname, sink_name)) {\newline                continue;\newline            }\newline        } else {\newline            if (entry-&gtidx != sink_idx) {\newline                continue;\newline            }\newline        }\newline        int vol = entry-&gtvolume;\newline        pthread_mutex_unlock(&amppulse_mutex);\newline        return vol;\newline    }\newline    pthread_mutex_unlock(&amppulse_mutex);\newline    /* first time requires a prime callback call because we only get\newline     * updates when the volume actually changes, but we need it to\newline     * be correct even if it never changes */\newline    pa_threaded_mainloop_lock(main_loop);\newline    get_sink_info(context, sink_idx, sink_name);\newline    pa_threaded_mainloop_unlock(main_loop);\newline    /* show 0 while we don&#039t have this information */\newline    return 0;\newline}\newline","\newline returns the current volume in percent, which, as per PulseAudio,\newline may be &gt 100%\newline \newline","6075469","vqgen.c","void vqgen_unquantize(vqgen *v,quant_meta *q){\newline  long j,k;\newline  float mindel=_float32_unpack(q-&gtmin);\newline  float delta=_float32_unpack(q-&gtdelta);\newline\newline  for(j=0;j&ltv-&gtentries;j++){\newline    float last=0.f;\newline    for(k=0;k&ltv-&gtelements;k++){\newline      float now=_now(v,j)[k];\newline      now=fabs(now)*delta+last+mindel;\newline      if(q-&gtsequencep)last=now;\newline      _now(v,j)[k]=now;\newline    }\newline  }\newline}\newline","much easier :-). Unlike in the codebook, we don&#039t un-log log\newlinescales; we just make sure they&#039re properly offset. \newline","5975093","gd_matrix.c","BGD_DECLARE(int) gdAffineConcat (double dst[6], const double m1[6], const double m2[6])\newline{\newline	double dst0, dst1, dst2, dst3, dst4, dst5;\newline\newline	dst0 = m1[0] * m2[0] + m1[1] * m2[2];\newline	dst1 = m1[0] * m2[1] + m1[1] * m2[3];\newline	dst2 = m1[2] * m2[0] + m1[3] * m2[2];\newline	dst3 = m1[2] * m2[1] + m1[3] * m2[3];\newline	dst4 = m1[4] * m2[0] + m1[5] * m2[2] + m2[4];\newline	dst5 = m1[4] * m2[1] + m1[5] * m2[3] + m2[5];\newline	dst[0] = dst0;\newline	dst[1] = dst1;\newline	dst[2] = dst2;\newline	dst[3] = dst3;\newline	dst[4] = dst4;\newline	dst[5] = dst5;\newline	return GD_TRUE;\newline}\newline","\newline Function: gdAffineConcat\newline Concat (Multiply) two affine transformation matrices.\newline \newline Concats two affine transforms together, i.e. the result\newline will be the equivalent of doing first the transformation m1 and then\newline m2. All parameters can be the same matrix (safe to call using\newline the same array for all three arguments).\newline \newline Parameters:\newline dst - Where to store the resulting affine transform\newline m1 - First affine matrix\newline m2 - Second affine matrix\newline \newline Returns:\newline GD_TRUE on success or GD_FALSE\newline \newline","2285304","rrd_parsetime.c","static char *tod(\newline    rrd_time_value_t * ptv)\newline{\newline    int       hour, minute = 0;\newline    int       tlen;\newline\newline    /* save token status in  case we must abort */\newline    int       scc_sv = scc;\newline    const char *sct_sv = sct;\newline    int       sc_tokid_sv = sc_tokid;\newline\newline    tlen = strlen(sc_token);\newline\newline    /* first pick out the time of day - we assume a HH (COLON|DOT) MM time\newline     */\newline    if (tlen &gt 2) {\newline        return TIME_OK;\newline    }\newline\newline    hour = atoi(sc_token);\newline\newline    token();\newline    if (sc_tokid == SLASH || sc_tokid == DOT) {\newline        /* guess we are looking at a date */\newline        scc = scc_sv;\newline        sct = sct_sv;\newline        sc_tokid = sc_tokid_sv;\newline        snprintf(sc_token, sc_len, &quot%d&quot, hour);\newline        return TIME_OK;\newline    }\newline    if (sc_tokid == COLON) {\newline        try(expect2(NUMBER,\newline                    &quotParsing HH:MM syntax, expecting MM as number, got none&quot));\newline        minute = atoi(sc_token);\newline        if (minute &gt 59) {\newline            panic(e(&quotparsing HH:MM syntax, got MM = %d (&gt59!)&quot, minute));\newline        }\newline        token();\newline    }\newline\newline    /* check if an AM or PM specifier was given\newline     */\newline    if (sc_tokid == AM || sc_tokid == PM) {\newline        if (hour &gt 12) {\newline            panic(e(&quotthere cannot be more than 12 AM or PM hours&quot));\newline        }\newline        if (sc_tokid == PM) {\newline            if (hour != 12) /* 12:xx PM is 12:xx, not 24:xx */\newline                hour += 12;\newline        } else {\newline            if (hour == 12) /* 12:xx AM is 00:xx, not 12:xx */\newline                hour = 0;\newline        }\newline        token();\newline    } else if (hour &gt 23) {\newline        /* guess it was not a time then ... */\newline        scc = scc_sv;\newline        sct = sct_sv;\newline        sc_tokid = sc_tokid_sv;\newline        snprintf(sc_token, sc_len, &quot%d&quot, hour);\newline        return TIME_OK;\newline    }\newline    ptv-&gttm.  tm_hour = hour;\newline    ptv-&gttm.  tm_min = minute;\newline    ptv-&gttm.  tm_sec = 0;\newline\newline    if (ptv-&gttm.tm_hour == 24) {\newline        ptv-&gttm.  tm_hour = 0;\newline        ptv-&gttm.  tm_mday++;\newline    }\newline    return TIME_OK;\newline}                       /* tod */\newline","\newline tod() computes the time of day (TIME-OF-DAY-SPEC)\newline \newline","384772","ib_srp.c","static int ib_srp_parse_integer ( const char *rp_comp, int default_value ) {\newline	int value;\newline	char *end;\newline\newline	value = strtoul ( rp_comp, &ampend, 16 );\newline	if ( *end )\newline		return -EINVAL_INTEGER;\newline\newline	if ( end == rp_comp )\newline		return default_value;\newline\newline	return value;\newline}\newline","\newline Parse IB SRP root path integer value\newline \newline @v rp_comp Root path component string\newline @v default_value Default value to use if component string is empty\newline @ret value Value\newline \newline","4713095","ximage.cpp","void CxImage::Copy(const CxImage &ampsrc, bool copypixels, bool copyselection, bool copyalpha)\newline{\newline	//copy the attributes\newline	memcpy(&ampinfo,&ampsrc.info,sizeof(CXIMAGEINFO));\newline	//rebuild the image\newline	Create(src.GetWidth(),src.GetHeight(),src.GetBpp(),src.GetType());\newline	//copy the pixels and the palette, or at least copy the palette only.\newline	if (copypixels &amp&amp pDib &amp&amp src.pDib) memcpy(pDib,src.pDib,GetSize());\newline	else SetPalette(src.GetPalette());\newline	long nSize = head.biWidth * head.biHeight;\newline	//copy the selection\newline	if (copyselection &amp&amp src.pSelection){\newline		if (pSelection) free(pSelection);\newline		pSelection = (BYTE*)malloc(nSize);\newline		memcpy(pSelection,src.pSelection,nSize);\newline	}\newline	//copy the alpha channel\newline	if (copyalpha &amp&amp src.pAlpha){\newline		if (pAlpha) free(pAlpha);\newline		pAlpha = (BYTE*)malloc(nSize);\newline		memcpy(pAlpha,src.pAlpha,nSize);\newline	}\newline}\newline","\newline Copies the image from an exsisting source\newline \\param src: source image.\newline \\param copypixels: copy the pixels from the source image into the new image.\newline \\param copyselection: copy the selection from source\newline \\param copyalpha: copy the alpha channel from source\newline \newline","321337","procutils.c","static char *safe_strncpy(char *dest, char *src, int n)\newline{\newline	if (!dest || !src)\newline		return NULL;\newline	dest[n] = 0;\newline	return strncpy(dest, src, n);\newline}\newline","\newline Version of strncpy() that returns NULL if either src or dest is NULL\newline and also makes sure destination string is always terminated.\newline \newline","","","","","","","","on","","","","","","on","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","check volume update and atomic LEB change capabilities.","send a message","set box2->c to cc if cc is in the ac-list of box2,","Gets attributes from command line.","Returns a player number","Reads file DB v1 entries from fdb_s and saves them","returns the current volume in percent,","{}","Concats two affine transforms together,","computes the time of day","Parse IB SRP root path integer value","Sets the #GoaAccount instance for the D-Bus interface","Copies the image from an exsisting source","{}","Ask session daemon for all user space tracepoints available.","Delete data stream that are flagged for deletion","Print a nicer looking HTML banner","Clamps an unsigned 8-bit value.","Checks whether the point is before the bound rect","Creates and returns a variant property","{}"
"38DCH97KHH22FPA7R4UCNAXZL1PJQG","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","34BBWHLWHABDRVJGBXDJSHWACBLWIT","AVC62JNYAXA45","Approved","Wed Apr 17 14:23:35 PDT 2019","Wed Apr 17 14:59:30 PDT 2019","Fri Apr 19 14:59:30 PDT 2019","2019-04-19 22:00:21 UTC","","","2155","100% (24/24)","100% (24/24)","100% (24/24)","6510619","modes_noglobals.c","static const split_cb_params * split_cb_high (void)\newline{\newline  return speex_split_cb_params_new (\newline   8,               /*subvect_size*/\newline   5,               /*nb_subvect*/\newline   hexc_table,       /*shape_cb*/\newline   7,               /*shape_bits*/\newline   1\newline   );\newline}\newline","Split-VQ innovation for high-band wideband \newline","4287340","rjb.c","static void rv2jobject(JNIEnv* jenv, VALUE val, jvalue* jv, const char* psig, int release)\newline{\newline    if (!release)\newline    {\newline	jv-&gtl = NULL;\newline	if (val == Qtrue || val == Qfalse)\newline	{\newline	    jv-&gtl = (*jenv)-&gtCallStaticObjectMethod(jenv,\newline		    jpcvt[PRM_BOOLEAN].klass, jpcvt[PRM_BOOLEAN].ctr_id,\newline				    (val == Qtrue) ? JNI_TRUE : JNI_FALSE);\newline	}\newline	else if (NIL_P(val))\newline	{\newline	    /* no-op */\newline	}\newline	else if (FIXNUM_P(val))\newline	{\newline	    jvalue arg;\newline	    int idx = PRM_INT;\newline#if HAVE_LONG_LONG\newline	    arg.j = FIX2LONG(val);\newline	    if (arg.j &lt INT_MIN || arg.j &gt INT_MAX)\newline	    {\newline		idx = PRM_LONG;\newline	    }\newline#else\newline	    arg.i = FIX2LONG(val);\newline#endif\newline	    jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[idx].klass,\newline				       jpcvt[idx].ctr_id, arg);\newline	}\newline	else\newline	{\newline	    jvalue arg;\newline	    switch (TYPE(val))\newline	    {\newline	    case T_DATA:\newline                if (IS_RJB_OBJECT(val))\newline		{\newline                    /* TODO: check instanceof (class (in psig) ) */\newline		    struct jvi_data* ptr;\newline		    Data_Get_Struct(val, struct jvi_data, ptr);\newline		    jv-&gtl = ptr-&gtobj;\newline		}\newline		else if (rb_obj_class(val) == rjbb)\newline		{\newline		    struct rj_bridge* ptr;\newline		    Data_Get_Struct(val, struct rj_bridge, ptr);\newline		    jv-&gtl = ptr-&gtproxy;\newline		}\newline		else if (CLASS_INHERITED(rjbc, rb_obj_class(val))) \newline		{\newline		    struct jv_data* ptr;\newline		    Data_Get_Struct(val, struct jv_data, ptr);\newline		    jv-&gtl = ptr-&gtidata.obj;\newline		}\newline		break;\newline	    case T_STRING:\newline                if (psig &amp&amp *psig == &#039[&#039 &amp&amp *(psig + 1) == &#039B&#039) {\newline                    jv-&gtl = r2barray(jenv, val, NULL);\newline                } else {\newline                    rv2jstring(jenv, val, jv, NULL, 0);\newline                }\newline		break;\newline	    case T_FLOAT:\newline		arg.d = NUM2DBL(val);\newline		jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[PRM_DOUBLE].klass,\newline				       jpcvt[PRM_DOUBLE].ctr_id, arg.d);\newline		break;\newline	    case T_ARRAY:\newline		jv-&gtl = r2objarray(jenv, val, &quotLjava/lang/Object;&quot);\newline		break;\newline#if HAVE_LONG_LONG                \newline            case T_BIGNUM:\newline                arg.j = rb_big2ll(val);\newline                jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[PRM_LONG].klass,\newline				       jpcvt[PRM_LONG].ctr_id, arg);\newline                break;\newline#endif                \newline            case T_OBJECT:\newline            default:\newline#if defined(DEBUG)\newline              {\newline                VALUE v = rb_funcall(val, rb_intern(&quotinspect&quot), 0);\newline                fprintf(stderr, &quotrtype:%d, sig=%s\\n&quot, TYPE(val), psig);\newline                fprintf(stderr, &quotobj:%s\\n&quot, StringValueCStr(v));\newline                fflush(stderr);\newline              }\newline#endif\newline                rb_raise(rb_eRuntimeError, &quotcan&#039t convert to java type&quot);\newline                break;\newline	    }\newline	}\newline    }\newline    else\newline    {\newline        switch (TYPE(val)) \newline	{\newline        case T_STRING:\newline        case T_FLOAT:\newline        case T_ARRAY:\newline        case T_BIGNUM:\newline            if (jv-&gtl) (*jenv)-&gtDeleteLocalRef(jenv, jv-&gtl);\newline            break;\newline        }\newline    }\newline}\newline","\newline psig may be NULL (from proxy/array call)\newline \newline","5246255","ow_1820.c","static ZERO_OR_ERROR FS_r_trimvalid(struct one_wire_query *owq)\newline{\newline	BYTE trim[2];\newline	switch (OW_die(PN(owq))) {\newline	case eB7:\newline	case eC2:\newline		RETURN_ERROR_IF_BAD(OW_r_trim(trim, PN(owq))) ;\newline		OWQ_Y(owq) = (((trim[0] &amp 0x07) == 0x05)\newline					  || ((trim[0] &amp 0x07) == 0x03))\newline			&amp&amp (trim[1] == 0xBB);\newline		break;\newline	default:\newline		OWQ_Y(owq) = 1;			/* Assume true */\newline	}\newline	return 0;\newline}\newline","Are the trim values valid-looking? \newline","2795585","libfvalue_binary_data.c","int libfvalue_binary_data_initialize(\newline     libfvalue_binary_data_t **binary_data,\newline     libcerror_error_t **error )\newline{\newline	static char *function = &quotlibfvalue_binary_data_initialize&quot;\newline\newline	if( binary_data == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid binary data.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *binary_data != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid binary data value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*binary_data = memory_allocate_structure(\newline	                libfvalue_binary_data_t );\newline\newline	if( *binary_data == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create binary data.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     *binary_data,\newline	     0,\newline	     sizeof( libfvalue_binary_data_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear binary data.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	return( 1 );\newline\newlineon_error:\newline	if( *binary_data != NULL )\newline	{\newline		memory_free(\newline		 *binary_data );\newline\newline		*binary_data = NULL;\newline	}\newline	return( -1 );\newline}\newline","Creates a binary data\newline Make sure the value binary_data is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","386380","xfer.c","int xfer_seek ( struct xfer_interface *xfer, off_t offset, int whence ) {\newline	struct io_buffer *iobuf;\newline	struct xfer_metadata meta = {\newline		.offset = offset,\newline		.whence = whence,\newline	};\newline\newline	DBGC ( xfer, &quotXFER %p seek %s+%ld\\n&quot, xfer,\newline	       whence_text ( whence ), offset );\newline\newline	/* Allocate and send a zero-length data buffer */\newline	iobuf = xfer_alloc_iob ( xfer, 0 );\newline	if ( ! iobuf )\newline		return -ENOMEM;\newline	return xfer_deliver_iob_meta ( xfer, iobuf, &ampmeta );\newline}\newline","\newline Seek to position\newline \newline @v xfer Data transfer interface\newline @v offset Offset to new position\newline @v whence Basis for new position\newline @ret rc Return status code\newline \newline","3785522","extract.c","unsigned char *extract_reg(f_state *s, u_int64_t c_offset, unsigned char *foundat, u_int64_t buflen,\newline						   s_spec *needle, u_int64_t f_offset)\newline{\newline	unsigned char	*buf = foundat;\newline	unsigned char	*extractbuf = NULL;\newline	int sizeofreg = htoi(&ampfoundat[0x28], FOREMOST_LITTLE_ENDIAN);\newline	int file_size=0;\newline	if(sizeofreg &lt 0 || sizeofreg &gt needle-&gtmax_len)	\newline	{\newline		return (foundat+4);\newline	}	\newline	foundat+=sizeofreg;\newline	file_size = (foundat - buf);\newline\newline	extractbuf = buf;\newline\newline\newline	write_to_disk(s, needle, file_size , extractbuf, c_offset + f_offset);\newline\newline			\newline	return NULL;\newline}\newline","\newline Function: extract_reg\newline Description:\newline Return: A pointer to where the EOF of the\newline \newline","6394458","mgribtoken.c","bool line_initializer(int token)\newline{\newline    /* THIS IS HACKISH - IT WILL CREATE A LINE FEED BEFORE */\newline    /* IT CREATES THE NEW LINE, WHICH ISN&#039T ALWAYS GOOD!!  */\newline    if(token&ltSTRINGBASE||token==mr_comment||token==mr_section||\newline       (token&gt=mr_P &amp&amp token&lt=mr_Os)) return true;\newline    else return false;\newline}\newline","return 1 when supplied token requires its own (ascii) line, 0 otherwise \newline","6006830","classinf.c","globle void EnvClassSubclasses(\newline  void *theEnv,\newline  void *clsptr,\newline  DATA_OBJECT *result,\newline  int inhp)\newline  {\newline   register unsigned i;\newline   register int id;\newline\newline   if ((id = GetTraversalID(theEnv)) == -1)\newline     return;\newline   i = CountSubclasses((DEFCLASS *) clsptr,inhp,id);\newline   ReleaseTraversalID(theEnv);\newline   result-&gttype = MULTIFIELD;\newline   result-&gtbegin = 0;\newline   SetpDOEnd(result,i);\newline   result-&gtvalue = (void *) EnvCreateMultifield(theEnv,i);\newline   if (i == 0)\newline     return;\newline   if ((id = GetTraversalID(theEnv)) == -1)\newline     return;\newline   StoreSubclasses(result-&gtvalue,1,(DEFCLASS *) clsptr,inhp,id,TRUE);\newline   ReleaseTraversalID(theEnv);\newline  }\newline","\newlineNAME : EnvClassSubclasses\newlineDESCRIPTION : Groups the names of subclasses for a class into a\newlinemultifield value for dynamic perusal\newlineINPUTS : 1) Generic pointer to class\newline2) Data object buffer to hold the sublclasses of the class\newline3) Include (1) or exclude (0) indirect subclasses\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Creates a multifield storing the names\newlinethe subclasses of the class\newlineNOTES : None\newline \newline","5745178","systask.c","static void string_expand(char *s, ModuleInst *mi)\newline{\newline  const char *path = ModuleInst_getPath(mi);\newline  int path_len = strlen(path);\newline\newline  while ((s = strstr(s,&quot%m&quot))) {\newline    memmove(s+path_len,s+2,strlen(s+2)+1);\newline    memmove(s,path,path_len);\newline    s += path_len;\newline  }\newline}\newline","\newline \newline Expand any %m substrings in a string to the current module path.\newline \newline Parameters:\newline s String to manipulate\newline mi Module instance\newline \newline \newline","384954","iscsi.c","static void iscsi_socket_close ( struct xfer_interface *socket, int rc ) {\newline	struct iscsi_session *iscsi =\newline		container_of ( socket, struct iscsi_session, socket );\newline\newline	/* Even a graceful close counts as an error for iSCSI */\newline	if ( ! rc )\newline		rc = -ECONNRESET;\newline\newline	/* Close session cleanly */\newline	iscsi_close_connection ( iscsi, rc );\newline\newline	/* Retry connection if within the retry limit, otherwise fail */\newline	if ( ++iscsi-&gtretry_count &lt= ISCSI_MAX_RETRIES ) {\newline		DBGC ( iscsi, &quotiSCSI %p retrying connection (retry #%d)\\n&quot,\newline		       iscsi, iscsi-&gtretry_count );\newline		if ( ( rc = iscsi_open_connection ( iscsi ) ) != 0 ) {\newline			DBGC ( iscsi, &quotiSCSI %p could not reconnect: %s\\n&quot,\newline			       iscsi, strerror ( rc ) );\newline			iscsi_scsi_done ( iscsi, rc );\newline		}\newline	} else {\newline		DBGC ( iscsi, &quotiSCSI %p retry count exceeded\\n&quot, iscsi );\newline		iscsi-&gtinstant_rc = rc;\newline		iscsi_scsi_done ( iscsi, rc );\newline	}\newline}\newline","\newline Handle stream connection closure\newline \newline @v socket Transport layer interface\newline @v rc Reason for close\newline \newline \newline","282907","msg.c","void nlmsg_free(struct nl_msg *msg)\newline{\newline	if (!msg)\newline		return;\newline\newline	msg-&gtnm_refcnt--;\newline	NL_DBG(4, &quotReturned message reference %p, %d remaining\\n&quot,\newline	       msg, msg-&gtnm_refcnt);\newline\newline	if (msg-&gtnm_refcnt &lt 0)\newline		BUG();\newline\newline	if (msg-&gtnm_refcnt &lt= 0) {\newline		free(msg-&gtnm_nlh);\newline		NL_DBG(2, &quotmsg %p: Freed\\n&quot, msg);\newline		free(msg);\newline	}\newline}\newline","\newline Release a reference from an netlink message\newline @arg msg message to release reference from\newline \newline Frees memory after the last reference has been released.\newline \newline","2638319","test_c.cpp","static void testminqpunit_setrandomalgoallmodern(minqpstate* s,\newline     ae_state *_state)\newline{\newline    ae_int_t i;\newline\newline\newline    i = 1+ae_randominteger(2, _state);\newline    if( i==1 )\newline    {\newline        minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0, _state);\newline    }\newline    if( i==2 )\newline    {\newline        minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, ae_fp_greater(ae_randomreal(_state),0.5), _state);\newline    }\newline}\newline","\newlineset random type of the QP solver.\newlineAll &quotmodern&quot solvers can be chosen.\newline \newline","5751013","lfc_register.c","int gfal_lfc_register(plugin_handle handle, gfal2_context_t context,\newline        gfalt_params_t params, const char* src_url, const char* dst_url, GError** error)\newline{\newline    struct lfc_ops* ops = (struct lfc_ops*) handle;\newline    char* lfc_host = NULL;\newline    char* lfc_path = NULL;\newline    char* src_host = NULL;\newline    int   ret_status = 0;\newline    int   lfc_errno = 0;\newline    gboolean file_existed = FALSE;\newline    GError *tmp_err = NULL;\newline\newline    // Get URL components\newline    ret_status = url_converter(handle, dst_url, &amplfc_host, &amplfc_path, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    ret_status = _get_host(src_url, &ampsrc_host, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: %s -&gt %s:%s&quot, src_url, lfc_host, lfc_path);\newline\newline    // Information about the replica\newline    struct size_and_checksum replica_info;\newline    ret_status = _get_replica_info(context, &ampreplica_info, src_url, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    // Set up LFC environment\newline    ret_status = lfc_configure_environment(ops, lfc_host, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    gfal_lfc_init_thread(ops);\newline\newline    // Stat LFC entry\newline    struct lfc_filestatg statg;\newline    ret_status = ops-&gtstatg(lfc_path, NULL, &ampstatg);\newline    lfc_errno = gfal_lfc_get_errno(ops);\newline\newline    // File exists, validate the incoming replica\newline    if (ret_status == 0) {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: lfc exists, validate&quot);\newline        file_existed = TRUE;\newline        ret_status = _validate_new_replica(context, &ampstatg, &ampreplica_info, &amptmp_err);\newline    }\newline    // File do not exist, try to create\newline    else if (lfc_errno == ENOENT) {\newline        gfal_generate_guidG(statg.guid, NULL);\newline        ret_status = _lfc_touch(ops, lfc_path, statg.guid, &ampreplica_info, &amptmp_err);\newline    }\newline    // Failure\newline    else {\newline        ret_status = -1;\newline        gfal2_set_error(error, gfal2_get_plugin_lfc_quark(), errno, __func__,\newline                    &quotFailed to stat the file: %s (%d)&quot, gfal_lfc_get_strerror(ops), lfc_errno);\newline    }\newline\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    struct lfc_fileid unique_id = {{0}, 0};\newline    unique_id.fileid = statg.fileid;\newline    g_strlcpy(unique_id.server, lfc_host, sizeof(unique_id.server));\newline\newline    ret_status = ops-&gtaddreplica(statg.guid,\newline                                 file_existed?&ampunique_id:NULL,\newline                                 src_host, src_url,\newline                                 &#039-&#039, &#039P&#039,\newline                                 NULL, NULL);\newline    if (ret_status != 0) {\newline        int err_code = gfal_lfc_get_errno(ops);\newline\newline        if (err_code != EEXIST) {\newline            gfal2_set_error(error, gfal2_get_plugin_lfc_quark(), err_code, __func__,\newline                        &quotCould not register the replica : %s &quot, gfal_lfc_get_strerror(ops));\newline        }\newline        else {\newline            gfal2_log(G_LOG_LEVEL_MESSAGE, &quotlfc register: the replica is already registered, that is ok&quot);\newline            ret_status = 0;\newline        }\newline    }\newline    else {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: done&quot);\newline    }\newline\newlineregister_end:\newline    if (tmp_err)\newline        gfal2_propagate_prefixed_error(error, tmp_err, __func__);\newline    g_free(lfc_host);\newline    g_free(lfc_path);\newline    g_free(src_host);\newline    return ret_status;\newline}\newline","\newline src_url can be anything\newline dst_url must be an LFC url\newline \newline","2960634","eval.c","NODE *evaluator(NODE *list, enum labels where) {\newline\newline    FIXNUM  cont   = 0;	    /* where to go next */\newline    int i;\newline    BOOLEAN tracing = FALSE; /* are we tracing the current procedure? */\newline	\newline    inside_evaluator++;\newline    eval_save();\newline    var = var_stack;\newline    newcont(all_done);\newline    newcont(where);\newline    goto fetch_cont;\newline\newlineall_done:\newline    reset_args(var);\newline    eval_restore();\newline    if (dont_fix_ift) {\newline        ift_iff_flag = dont_fix_ift-1;\newline        dont_fix_ift = 0;\newline    }\newlineinside_evaluator--;\newlinereturn(val);\newline\newlinebegin_line:\newline    this_line = list;\newline    val_status = NO_VALUE_OK;\newline    newcont(end_line);\newlinebegin_seq:\newline    debprint(&quotbegin_seq&quot);\newline    make_tree(list);\newline    if (!is_tree(list)) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    unev = tree__tree(list);\newline    goto eval_sequence;\newline\newlineend_line:\newline    if (val != UNBOUND) {\newline	if (NOT_THROWING) err_logo(DK_WHAT, val);\newline    }\newline/*    val = NIL;    */\newline    goto fetch_cont;\newline\newline\newline/* ----------------- EVAL ---------------------------------- */\newline/* Get here for actual argument, from eval_sequence (non-tail), or\newline   from tail call. */\newline\newlinetail_eval_dispatch:\newline    tailcall = 1;\newlineeval_dispatch:\newline    debprint(&quoteval_dispatch&quot);\newline    switch (nodetype(exp)) {\newline	case QUOTE:			/* quoted literal */\newline	    val = /* deep_copy */ (node__quote(exp));\newline	    goto fetch_cont;\newline	case COLON:			/* variable */\newline\newline#ifdef OBJECTS\newline	    val = varValue(node__colon(exp));\newline#else\newline	    val = valnode__colon(exp);\newline#endif\newline	    while (val == UNBOUND &amp&amp NOT_THROWING)\newline		val = err_logo(NO_VALUE, node__colon(exp));\newline	    goto fetch_cont;\newline	case CONS:			/* procedure application */\newline	    if (tailcall == 1 &amp&amp is_macro(car(exp)) &amp&amp\newline				 (is_list(procnode__caseobj(car(exp)))\newline		   || isName(car(exp), Name_goto))) {\newline		/* tail call to user-defined macro must be treated as non-tail\newline		 * because the expression returned by the macro\newline		 * remains to be evaluated in the caller&#039s context */\newline		unev = NIL;\newline		goto non_tail_eval;\newline	    }\newline	    fun = car(exp);\newline	    if (fun == Not_Enough_Node) {\newline		err_logo(TOO_MUCH, NIL);    /* When does this happen? */\newline		val = UNBOUND;\newline		goto fetch_cont;\newline	    }\newline	    if (flag__caseobj(fun, PROC_SPECFORM)) {\newline		argl = cdr(exp);\newline		goto apply_dispatch;\newline	    }\newline	    if (cdr(exp) != NIL)\newline		goto ev_application;\newline	    else\newline		goto ev_no_args;\newline	case ARRAY:			/* array must be copied */\newline	    val = deep_copy(exp);\newline	    goto fetch_cont;\newline	default:\newline	    val = exp;		/* self-evaluating */\newline	    goto fetch_cont;\newline    }\newline\newlineev_no_args:\newline    /* Evaluate an application of a procedure with no arguments. */\newline    argl = NIL;\newline    goto apply_dispatch;    /* apply the procedure */\newline\newlineev_application:\newline    /* Evaluate an application of a procedure with arguments. */\newline    unev = cdr(exp);\newline    argl = NIL;\newlineeval_arg_loop:\newline    debprint(&quoteval_arg_loop&quot);\newline    if (unev == NIL) goto eval_args_done;\newline    exp = car(unev);\newline    if (exp == Not_Enough_Node) {\newline	if (NOT_THROWING)\newline	    err_logo(NOT_ENOUGH, NIL);\newline	goto eval_args_done;\newline    }\newlinearg_from_macro:\newline    if (nodetype(exp) != CONS) {    /* Don&#039t bother saving registers */\newline	newcont(after_const_arg);    /* if the exp isn&#039t a proc call */\newline	goto eval_dispatch;\newline    }\newline    eval_save();\newline    save(current_unode);\newline    var = var_stack;\newline    tailcall = -1;\newline    didnt_output_name = NIL;\newline    didnt_get_output = cons_list(0, fun, ufun, this_line, END_OF_LIST);\newline    val_status = VALUE_OK;\newline	/* in case of apply or catch */\newline    newcont(accumulate_arg);\newline    goto eval_dispatch;	    /* evaluate the current argument */\newline\newlineaccumulate_arg:\newline    debprint(&quotaccumulate_arg&quot);\newline    /* Put the evaluated argument into the argl list. */\newline    reset_args(var);\newline    restore(current_unode);\newline    last_call = fun;\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    if (stopping_flag == OUTPUT || STOPPING) {\newline	didnt_output_name = NIL;\newline	err_logo(DIDNT_OUTPUT, fun);\newline    }\newline    while (NOT_THROWING &amp&amp val == UNBOUND) {\newline	val = err_logo(DIDNT_OUTPUT, NIL);\newline    }\newline    eval_restore();\newline    if (stopping_flag == MACRO_RETURN) {\newline	if (val == NIL || val == UNBOUND || cdr(val) != NIL) {\newline	    if (NOT_THROWING) {\newline		if (tree_dk_how != NIL &amp&amp tree_dk_how != UNBOUND)\newline		    err_logo(DK_HOW_UNREC, tree_dk_how);\newline		else\newline\newline		    err_logo((val!=NIL &amp&amp val!=UNBOUND) ?\newline				 RUNNABLE_ARG : ERR_MACRO, val);\newline	    }\newline	    goto eval_args_done;\newline	}\newline	exp = car(val);\newline	stopping_flag = RUN;\newline	goto arg_from_macro;\newline    }\newlineafter_const_arg:\newline    if (stopping_flag == THROWING) goto eval_args_done;\newline    push(val, argl);\newline    pop(unev);\newline    goto eval_arg_loop;\newline\newlineeval_args_done:\newline    if (stopping_flag == THROWING) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    argl = reverse(argl);\newline/* --------------------- APPLY ---------------------------- */\newlineapply_dispatch:\newline    debprint(&quotapply_dispatch&quot);\newline    /* Load in the procedure&#039s definition and decide whether it&#039s a compound\newline     * procedure or a primitive procedure.\newline     */\newline    proc = procnode__caseobj(fun);\newline    if (is_macro(fun)) {\newline	num2save(val_status,tailcall);\newline	save2(didnt_get_output,current_unode);\newline	didnt_get_output = the_generation; /* (cons nil nil) */\newline	    /* We want a value, but not as actual arg */\newline	newcont(macro_return);\newline    }\newline    if (proc == UNDEFINED) {	/* 5.0 punctuationless variables */\newline	if (!varTrue(AllowGetSet)) {    /* No getter/setter allowed, punt */\newline	    val = err_logo(DK_HOW, fun);\newline	    goto fetch_cont;\newline	} else if (argl == NIL) {	/* possible var getter */\newline	    val = valnode__caseobj(fun);\newline	    if (val == UNBOUND &amp&amp NOT_THROWING)\newline		val = err_logo(DK_HOW, fun);\newline	    else if (val != UNBOUND) {\newline		(void)ldefine(cons(fun, cons(\newline		   cons(NIL,cons(cons(theName(Name_output),\newline				      cons(make_colon(fun),NIL)),\newline				 NIL)),\newline		  NIL)));    /* make real proc so no disk load next time */\newline		setflag__caseobj(fun,PROC_BURIED);\newline	    }\newline	    goto fetch_cont;\newline	} else {		/* var setter */\newline	    NODE *name = intern(bf3(fun));\newline	    if (valnode__caseobj(name) == UNBOUND &amp&amp\newline		!(flag__caseobj(name, (HAS_GLOBAL_VALUE|IS_LOCAL_VALUE)))) {\newline		    val = err_logo(DK_HOW, fun);\newline		    goto fetch_cont;\newline	    }\newline	    (void)ldefine(cons(fun, cons(\newline		cons(Listvalue,\newline		     cons(cons(Make,\newline			       cons(make_quote(bf3(fun)),\newline				    cons(Dotsvalue,NIL))),\newline			  NIL))\newline		,NIL)));\newline	    setflag__caseobj(fun,PROC_BURIED);\newline	    argl = cons(bf3(fun), argl);\newline	    if (NOT_THROWING)\newline		val = lmake(argl);\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (is_list(proc)) goto compound_apply;\newline    /* primitive_apply */\newline    debprint(&quotprimitive_apply&quot);\newline    if (NOT_THROWING) {\newline	if ((tracing = flag__caseobj(fun, PROC_TRACED))) {\newline	    for (i = 0; i &lt trace_level; i++) {\newline		print_space(stdout);\newline	    }\newline	    ndprintf(stdout, &quot( %s &quot, fun);\newline	    if (argl != NIL) {\newline		arg = argl;\newline		while (arg != NIL) {\newline		    print_node(stdout, maybe_quote(car(arg)));\newline		    print_space(stdout);\newline		    arg = cdr(arg);\newline		}\newline	    }\newline		print_char(stdout, &#039)&#039);\newline	    new_line(stdout);\newline	}\newline	val = (*getprimfun(proc))(argl);\newline        if (tracing &amp&amp NOT_THROWING) {\newline	    for (i = 0; i &lt trace_level; i++) {\newline		print_space(stdout);\newline	    }\newline	    print_node(stdout, fun);\newline	    if (val == UNBOUND)\newline	        ndprintf(stdout, &quot %t\\n&quot, message_texts[TRACE_STOPS]);\newline	    else {\newline	        ndprintf(stdout, &quot %t %s\\n&quot, message_texts[TRACE_OUTPUTS],\newline					     maybe_quote(val));\newline	    }\newline        }\newline    } else\newline	val = UNBOUND;\newline	/* falls into fetch_cont */\newline\newline#if DEB_CONT\newline#define do_case(x) case x: debprint(&quotFetch_cont = &quot #x); goto x;\newline#else\newline#define do_case(x) case x: goto x;\newline#endif\newline\newlinefetch_cont:\newline    {\newline	enum labels x = (enum labels)cont;\newline	cont = (FIXNUM)car(numstack);\newline	numstack=cdr(numstack);\newline	switch (x) {\newline	    do_list(do_case)\newline	    default: abort();\newline	}\newline    }\newline\newline\newline/* ----------------- COMPOUND_APPLY ---------------------------------- */\newline\newlinecompound_apply:\newline    debprint(&quotcompound_apply&quot);\newline#ifdef mac\newline    check_mac_stop();\newline#endif\newline#ifdef ibm\newline    check_ibm_stop();\newline#endif\newline#ifdef HAVE_WX\newline    check_wx_stop();\newline#endif\newline    if ((tracing = flag__caseobj(fun, PROC_TRACED))) {\newline	for (i = 0; i &lt trace_level; i++) print_space(writestream);\newline	trace_level++;\newline	ndprintf(writestream, &quot( %s &quot, fun);\newline    }\newline/* Bind the actuals to the formals */\newlinelambda_apply:\newline    vsp = var_stack;	/* remember where we came in */\newline    for (formals = formals__procnode(proc);\newline    	 formals != NIL;\newline	 formals = cdr(formals)) {\newline	    parm = car(formals);\newline	    if (nodetype(parm) == INT) break;	/* default # args */\newline	    if (argl != NIL) {\newline		arg = car(argl);\newline		if (tracing) {\newline		    print_node(writestream, maybe_quote(arg));\newline		    print_space(writestream);\newline		}\newline	    } else\newline		arg = UNBOUND;\newline	    if (nodetype(parm) == CASEOBJ) {\newline		if (not_local(parm,vsp)) {\newline		    push(parm, var_stack);\newline		    if (flag__caseobj(parm, IS_LOCAL_VALUE))\newline			settype(var_stack, LOCALSAVE);\newline		    var_stack-&gtn_obj = valnode__caseobj(parm);\newline		    setflag__caseobj(parm, IS_LOCAL_VALUE);\newline		}\newline		tell_shadow(parm);\newline		setvalnode__caseobj(parm, arg);\newline		if (arg == UNBOUND)\newline		    err_logo(NOT_ENOUGH, fun);\newline	    } else if (nodetype(parm) == CONS) {\newline		/* parm is optional or rest */\newline		if (not_local(car(parm),vsp)) {\newline		    push(car(parm), var_stack);\newline		    if (flag__caseobj(car(parm), IS_LOCAL_VALUE))\newline			settype(var_stack, LOCALSAVE);\newline		    var_stack-&gtn_obj = valnode__caseobj(car(parm));\newline		    setflag__caseobj(car(parm), IS_LOCAL_VALUE);\newline		}\newline		tell_shadow(car(parm));\newline		if (cdr(parm) == NIL) {		    /* parm is rest */\newline		    setvalnode__caseobj(car(parm), argl);\newline		    if (tracing) {\newline			if (argl != NIL) pop(argl);\newline			while (argl != NIL) {\newline			    arg = car(argl);\newline			    print_node(writestream, maybe_quote(arg));\newline			    print_space(writestream);\newline			    pop(argl);\newline			}\newline		    } else argl = NIL;\newline		    break;\newline		}\newline		if (arg == UNBOUND) {		    /* use default */\newline		    eval_save();\newline		    save(current_unode);\newline		    var = var_stack;\newline		    tailcall = -1;\newline		    list = cdr(parm);\newline		    didnt_get_output = cons_list(0, fun, ufun,\newline						 list, END_OF_LIST);\newline		    didnt_output_name = NIL;\newline		    if (NOT_THROWING)\newline			make_tree(list);\newline		    else\newline			list = NIL;\newline		    if (!is_tree(list)) {\newline			val = UNBOUND;\newline			goto set_args_continue;\newline		    }\newline		    unev = tree__tree(list);\newline		    val = UNBOUND;\newline		    exp = car(unev);\newline		    pop(unev);\newline		    if (unev != NIL) {\newline			err_logo(BAD_DEFAULT, parm);\newline			val = UNBOUND;\newline			goto set_args_continue;\newline		    }\newline		    newcont(set_args_continue);\newline		    goto eval_dispatch;\newline\newlineset_args_continue:\newline		    if (stopping_flag == MACRO_RETURN) {\newline			if (val == NIL || val == UNBOUND || cdr(val) != NIL) {\newline			    if (NOT_THROWING)\newline				err_logo((val!=NIL &amp&amp val!=UNBOUND) ?\newline				 RUNNABLE_ARG : ERR_MACRO, val);\newline			} else {\newline			    reset_args(var);\newline			    exp = car(val);\newline			    stopping_flag = RUN;\newline			    didnt_get_output = cons_list(0, fun, ufun,\newline							 list, END_OF_LIST);\newline			    didnt_output_name = NIL;\newline			    tailcall = -1;\newline			    newcont(set_args_continue);\newline			    goto eval_dispatch;\newline			}\newline		    }\newline		    restore(current_unode);\newline		    last_call = fun;\newline		    if (current_unode != output_unode) {\newline			if (STOPPING || RUNNING) output_node = UNBOUND;\newline			if (stopping_flag == OUTPUT || STOPPING) {\newline			    stopping_flag = RUN;\newline			    val = output_node;\newline			}\newline		    }\newline		    if (stopping_flag == OUTPUT || STOPPING) {\newline			didnt_output_name = NIL;\newline			err_logo(DIDNT_OUTPUT, fun);\newline		    }\newline		    while (NOT_THROWING &amp&amp val == UNBOUND) {\newline			val = err_logo(DIDNT_OUTPUT, NIL);\newline		    }\newline		    reset_args(var);\newline		    eval_restore();\newline		    parm = car(formals);\newline		    if (stopping_flag == THROWING) {\newline			val = UNBOUND;\newline			goto fetch_cont;\newline		    }\newline		    arg = val;\newline		}\newline		setvalnode__caseobj(car(parm), arg);\newline	    }\newline	    if (argl != NIL) pop(argl);\newline    }\newline    if (argl != NIL) {\newline	err_logo(TOO_MUCH, fun);\newline    }\newline    if (check_throwing) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    vsp = NIL;\newline    if ((tracing = !is_list(fun) &amp&amp flag__caseobj(fun, PROC_TRACED))) {\newline	if (NOT_THROWING) print_char(writestream, &#039)&#039);\newline	new_line(writestream);\newline	save(fun);\newline	newcont(compound_apply_continue);\newline    }\newline    last_ufun = ufun;\newline    if (!is_list(fun)) ufun = fun;\newline    last_line = this_line;\newline    this_line = NIL;\newline/*    proc = (is_list(fun) ? anonymous_function(fun) : procnode__caseobj(fun)); */\newline/*  If that&#039s uncommented, begin_apply must get proc from fun, not exp  */\newline    list = bodylist__procnode(proc);	/* get the body ... */\newline    make_tree_from_body(list);\newline    if (!is_tree(list) || treepair__tree(list)==NIL) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    debprint(&quottreeified body&quot);\newline/*    printf(&quotlist = 0x%x = &quot,list); dbprint(list); */\newline    unev = tree__tree(list);\newline    if (NOT_THROWING) stopping_flag = RUN;\newline    output_node = UNBOUND;\newline    if (didnt_get_output == UNBOUND)\newline	val_status = NO_VALUE_OK | STOP_OK | STOP_TAIL;\newline    else if (didnt_get_output == NIL)\newline	val_status = NO_VALUE_OK | STOP_OK | STOP_TAIL |\newline		     OUTPUT_OK | OUTPUT_TAIL;\newline    else val_status = OUTPUT_OK | OUTPUT_TAIL;\newline    if (didnt_output_name == NIL) didnt_output_name = fun;\newline    current_unode = cons(NIL,NIL);  /* a marker for this proc call */\newline\newline/* ----------------- EVAL_SEQUENCE ---------------------------------- */\newline/* Fall through from proc body, call from start or fsubr argument */\newline\newlineeval_sequence:\newline    debprint(&quoteval_sequence&quot);\newline    /* Evaluate each expression in the sequence.\newline       Most of the complexity is in recognizing tail calls.\newline     */\newline    if (eval_buttonact != NIL) {\newline	make_tree(eval_buttonact);\newline	if (NOT_THROWING) {\newline	    if (is_tree(eval_buttonact)) {\newline		unev = append(tree__tree(eval_buttonact), unev);\newline		eval_buttonact = NIL;\newline	    }\newline	}\newline    }\newline    if (!RUNNING) goto fetch_cont;\newline    if (nodetype(unev) == LINE) {\newline	if (the_generation != (generation__line(unev))) {\newline	    /* something redefined while we&#039re running */\newline	    int linenum = 0;\newline	    this_line = tree__tree(bodylist__procnode(proc));\newline	    while (this_line != unev) {\newline		/* If redef isn&#039t end of line, don&#039t try to fix,\newline		   but don&#039t blow up either. (Maybe not called from here.) */\newline		if (this_line == NULL) goto nofix;\newline		if (nodetype(this_line) == LINE) linenum++;\newline		this_line = cdr(this_line);\newline	    }\newline	    untreeify_proc(proc);\newline	    make_tree_from_body(bodylist__procnode(proc));\newline	    unev = tree__tree(bodylist__procnode(proc));\newline	    while (--linenum &gt= 0) {\newline		do pop(unev);\newline		while (unev != NIL &amp&amp nodetype(unev) != LINE);\newline	    }\newline	}\newlinenofix:	this_line = unparsed__line(unev);\newline	if (ufun != NIL &amp&amp flag__caseobj(ufun, PROC_STEPPED)) {\newline	    if (tracing) {\newline		int i = 1;\newline		while (i++ &lt trace_level) print_space(stdout);\newline	    }\newline	    print_node(stdout, this_line);\newline	    (void)reader(stdin, &quot &gt&gt&gt &quot);\newline	}\newline    }\newline    exp = car(unev);\newline    pop(unev);\newline    if (exp != NIL &amp&amp\newline        is_list(exp) &amp&amp (is_tailform(procnode__caseobj(car(exp))))) {\newline      i = (int)getprimpri(procnode__caseobj(car(exp)));\newline      if (i == OUTPUT_PRIORITY) {\newline	if (cadr(exp) == Not_Enough_Node) {\newline	    err_logo(NOT_ENOUGH,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	didnt_output_name = NIL;\newline	if (val_status &amp OUTPUT_TAIL) {\newline	    didnt_get_output = cons_list(0,car(exp),ufun,this_line,\newline					 END_OF_LIST);\newline	    fun = car(exp);\newline	    exp = cadr(exp);\newline	    val_status = VALUE_OK;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    goto tail_eval_dispatch;\newline	} else if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	} else if (val_status &amp STOP_OK) {\newline	    didnt_get_output = cons_list(0,car(exp),ufun,this_line,\newline					 END_OF_LIST);\newline	    val_status = VALUE_OK;\newline	    exp = cadr(exp);\newline	    newcont(op_want_stop);\newline	    goto eval_dispatch;\newlineop_want_stop:\newline	    if (NOT_THROWING) err_logo(DK_WHAT_UP, val);\newline	    goto fetch_cont;\newline	} else if (val_status &amp VALUE_OK) {\newline	    /* pr apply [output ?] [3] */\newline	    debprint(&quotOp with VALUE_OK&quot);\newline	    didnt_output_name = fun;\newline	    goto tail_eval_dispatch;\newline	} else {\newline	    debprint(&quotOp with none of the above&quot);\newline	    goto tail_eval_dispatch;\newline	}\newline      } else if (i == STOP_PRIORITY) {\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	} else if (val_status &amp STOP_TAIL) {\newline	} else if (val_status &amp STOP_OK) {\newline	    stopping_flag = STOP;\newline	    output_unode = current_unode;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    if (NOT_THROWING) {\newline		if (didnt_get_output == NIL || didnt_get_output == UNBOUND) {\newline		/*  actually can happen: PRINT FOREACH ...\newline		    will give didn&#039t output message uplevel  */\newline		} else\newline		    err_logo(DIDNT_OUTPUT, NIL);\newline	    }\newline	} else {    /* show runresult [stop] inside a procedure */\newline	    didnt_output_name = car(exp);\newline	    if (NOT_THROWING) {\newline		if (didnt_get_output == NIL || didnt_get_output == UNBOUND) {\newline		/*  actually can happen: STOP during PAUSE */\newline		    err_logo(AT_TOPLEVEL, car(exp));\newline		} else\newline		    err_logo(DIDNT_OUTPUT, NIL);\newline	    }\newline	}\newline	val = UNBOUND;\newline	goto fetch_cont;\newline      } else { /* maybeoutput */\newline	debprint(&quotmaybeoutput&quot);\newline	if (cadr(exp) == Not_Enough_Node) {\newline	    err_logo(NOT_ENOUGH,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	if (val_status &amp OUTPUT_TAIL) {\newline	    didnt_output_name = NIL;\newline	    if (val_status &amp STOP_TAIL) {\newline		exp = cadr(exp);\newline		didnt_get_output = NIL;\newline		val_status = VALUE_OK | NO_VALUE_OK;\newline	    } else {\newline		didnt_get_output = cons_list(0,car(exp),ufun,\newline					     this_line,END_OF_LIST);\newline		exp = cadr(exp);\newline		val_status = VALUE_OK;\newline	    }\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    didnt_output_name = NIL;\newline	    if (val_status &amp STOP_OK) {\newline		didnt_get_output = NIL;\newline		val_status = NO_VALUE_OK | VALUE_OK;\newline		exp = cadr(exp);\newline		newcont(after_maybeoutput);\newline		goto eval_dispatch;\newlineafter_maybeoutput:\newline		if (val == UNBOUND)\newline		    lstop(NIL);\newline		else\newline		    loutput(cons(val, NIL));\newline		goto fetch_cont;\newline	    } else {\newline		goto eval_dispatch;\newline	    }\newline	} else if (val_status &amp STOP_TAIL) {\newline	    exp = cadr(exp);\newline	    didnt_get_output = UNBOUND;\newline	    val_status = NO_VALUE_OK;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp STOP_OK) {\newline	    exp = cadr(exp);\newline	    didnt_get_output = UNBOUND;\newline	    val_status = NO_VALUE_OK;\newline	    newcont(after_maybeoutput);\newline	    goto eval_dispatch;\newline	} else {\newline	    goto tail_eval_dispatch;\newline	}\newline      }\newline    }\newline\newline    if (unev == NIL) {	/* falling off tail of sequence */\newline	debprint(&quotfalling off&quot);\newline	if (val_status &amp NO_VALUE_OK) {\newline	    if (val_status &amp VALUE_OK)	/* from runresult */\newline		didnt_get_output = NIL;\newline	    else\newline		didnt_get_output = UNBOUND;\newline	} else if (val_status &amp VALUE_OK) {\newline	} else if (val_status &amp OUTPUT_OK) {\newlinenext_stop_want_output:\newline	    save(didnt_get_output);\newline	    didnt_get_output = UNBOUND;\newline	    val_status &amp= ~OUTPUT_TAIL;\newline	    newcont(fall_off_want_output);\newline	    goto tail_eval_dispatch;\newlinefall_off_want_output:\newline	    restore(didnt_get_output);\newline	    if (stopping_flag == OUTPUT) {\newline		goto fetch_cont;    /* repeat body did output */\newline	    }\newline	    if (NOT_THROWING &amp&amp val != UNBOUND) {\newline		/* Don&#039t allow just value expr w/o OUTPUT */\newline		err_logo(DK_WHAT, val);\newline	    }\newline	    goto fetch_cont;\newline	}\newline	goto tail_eval_dispatch;\newline    }\newline\newline    if (car(unev) != NIL &amp&amp is_list(car(unev)) &amp&amp   /* next is STOP */\newline	  (is_tailform(procnode__caseobj(car(car(unev))))) &amp&amp\newline	  getprimpri(procnode__caseobj(car(car(unev)))) == STOP_PRIORITY) {\newline	if (val_status &amp STOP_TAIL) {\newline	    didnt_get_output = UNBOUND;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp STOP_OK) {\newline	    goto non_tail_eval;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    goto next_stop_want_output;\newline	}   /* else treat as non-tail and the STOP will be caught later */\newline    }\newline\newlinenon_tail_eval:\newline    debprint(&quotnon_tail_eval&quot);\newline    if (nodetype(exp) != CONS) {    /* Don&#039t bother saving registers */\newline	newcont(after_constant);    /* if the exp isn&#039t a proc call */\newline	goto eval_dispatch;\newline    }\newline    eval_save();\newline    didnt_get_output = UNBOUND;    /* tell EVAL we don&#039t want a value */\newline    tailcall = 0;\newline    if (nodetype(exp) == CONS &amp&amp is_prim(procnode__caseobj(car(exp)))) {\newline	newcont(no_reset_args);	    /* primitive */\newline    } else {\newline	var = var_stack;\newline	newcont(eval_sequence_continue);\newline    }\newline    goto eval_dispatch;\newline\newlineeval_sequence_continue:\newline    reset_args(var);\newlineno_reset_args:	/* allows catch &quotfoo [local ...] to work */\newline    eval_restore();\newline    if (dont_fix_ift) {\newline	ift_iff_flag = dont_fix_ift-1;\newline	dont_fix_ift = 0;\newline    }\newline    debprint(&quoteval_sequence_continue&quot);\newline    if (stopping_flag == MACRO_RETURN) {\newline	if (val != NIL &amp&amp is_list(val) &amp&amp (isName(car(val), Name_tag)))\newline	    unev = cdr(val);	/* from goto */\newline	else\newline	    unev = append(val, unev);\newline	val = UNBOUND;\newline	stopping_flag = RUN;\newline	if (unev == NIL) goto fetch_cont;\newline    } else {\newline	if (current_unode != output_unode) {\newline	    if (STOPPING || RUNNING) output_node = UNBOUND;\newline	    if (stopping_flag == OUTPUT || STOPPING) {\newline		stopping_flag = RUN;\newline		val = output_node;\newline		goto fetch_cont;\newline	    }\newline	}\newline    }\newlineafter_constant:\newline    if (val != UNBOUND &amp&amp NOT_THROWING) {\newline	err_logo(DK_WHAT, val);\newline	val = UNBOUND;\newline    }\newline    if (NOT_THROWING &amp&amp unev == NIL) {\newline	goto fetch_cont;\newline    }\newline    goto eval_sequence;\newline\newlinecompound_apply_continue:\newline    /* Only get here if tracing */\newline    restore(parm);  /* saved from fun */\newline    --trace_level;\newline    if (NOT_THROWING) {\newline	for (i = 0; i &lt trace_level; i++) print_space(writestream);\newline	print_node(writestream, parm);\newline	if (val == UNBOUND)\newline	    ndprintf(writestream, &quot %t\\n&quot, message_texts[TRACE_STOPS]);\newline	else {\newline	    ndprintf(writestream, &quot %t %s\\n&quot, message_texts[TRACE_OUTPUTS],\newline					      maybe_quote(val));\newline	}\newline    }\newline    goto fetch_cont;\newline\newline/* --------------------- MACROS ---------------------------- */\newline\newlinemacro_return:\newline    restore2(didnt_get_output,current_unode);\newline    num2restore(val_status,tailcall);\newline    debprint(&quotmacro_return&quot);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    while (!is_list(val) &amp&amp NOT_THROWING) {\newline	val = err_logo(ERR_MACRO,val);\newline    }\newline    if (NOT_THROWING) {\newline	if (didnt_get_output != UNBOUND)\newline	    didnt_output_name = fun;\newline	if (is_cont(val)) {\newline	    newcont(cont__cont(val));\newline	    val = val__cont(val);\newline	    goto fetch_cont;\newline	}\newline	if (tailcall &lt= 0) {\newline	    list = val;\newline	    make_tree(list);\newline	    if (NOT_THROWING) {\newline		stopping_flag = MACRO_RETURN;\newline		if (!is_tree(list)) val = NIL;\newline		else val = tree__tree(list);\newline	    } else val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	list = val;\newline	goto begin_seq;\newline    }\newline    val = UNBOUND;\newline    goto fetch_cont;\newline\newline#define RUNRESULT_OUTPUT_LEGAL 0\newline\newlinerunresult_continuation:\newline    list = val;\newline#if RUNRESULT_OUTPUT_LEGAL\newline    val_status |= VALUE_OK | NO_VALUE_OK;\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline#else\newline    val_status = VALUE_OK | NO_VALUE_OK | OUTPUT_OK | STOP_OK;\newline    /* output and stop are not okay, but we give our own err message */\newline#endif\newline    save(current_unode);\newline    newcont(runresult_followup);\newline    goto begin_seq;\newline\newlinerunresult_followup:\newline    restore(current_unode);\newline    debprint(&quotrunresult_followup&quot);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    if (STOPPING || stopping_flag == OUTPUT)\newline	err_logo(RUNRES_STOP, NIL);\newline    if (val == UNBOUND) {\newline	val = NIL;\newline    } else {\newline	val = cons(val, NIL);\newline    }\newline    goto fetch_cont;\newline\newlinerepeat_continuation:\newline    list = cdr(val);\newline    num2save(repcount,user_repcount);\newline    repcount = getint(car(val));\newline    user_repcount = 0;\newlinerepeat_again:\newline    val = UNBOUND;\newline    if (repcount == 0) {\newlinerepeat_done:\newline	num2restore(repcount,user_repcount);\newline	goto fetch_cont;\newline    }\newline    user_repcount++;\newline    save2(list,var);\newline    var = var_stack;\newline    num2save(repcount,user_repcount);\newline    num2save(val_status,tailcall);\newline    val_status &amp= ~(VALUE_OK|OUTPUT_TAIL|STOP_TAIL);\newline    if (tailcall == 0) val_status |= NO_VALUE_OK;   /* embedded repeat */\newline    newcont(repeat_followup);\newline    goto begin_seq;\newline\newlinerepeat_followup:\newline    if (val != UNBOUND &amp&amp NOT_THROWING) {\newline	err_logo(DK_WHAT, val);\newline    }\newline    num2restore(val_status,tailcall);\newline    num2restore(repcount,user_repcount);\newline    reset_args(var);\newline    restore2(list,var);\newline    if (current_unode != output_unode) {\newline	debprint(&quotrep_foll tailcall&quot);\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto repeat_done;\newline	}\newline    }\newline    if (repcount &gt 0)    /* negative means forever */\newline	--repcount;\newline#ifdef mac\newline    check_mac_stop();\newline#endif\newline#ifdef ibm\newline    check_ibm_stop();\newline#endif\newline    if (RUNNING) goto repeat_again;\newline    val = UNBOUND;\newline    goto repeat_done;\newline\newlinecatch_continuation:\newline    list = cdr(val);\newline    catch_tag = car(val);\newline    if (isName(catch_tag, Name_error)) {\newline	push(Erract, var_stack);\newline	if (flag__caseobj(Erract, IS_LOCAL_VALUE))\newline	    settype(var_stack, LOCALSAVE);\newline	var_stack-&gtn_obj = valnode__caseobj(Erract);\newline	setflag__caseobj(Erract, IS_LOCAL_VALUE);\newline	setvalnode__caseobj(Erract, UNBOUND);\newline    }\newline    save2(didnt_output_name,didnt_get_output);\newline    num2save(val_status,tailcall);\newline    save2(current_unode,catch_tag);\newline    newcont(catch_followup);\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline    goto begin_seq;\newline\newlinecatch_followup:\newline    restore2(current_unode,catch_tag);\newline    num2restore(val_status,tailcall);\newline    restore2(didnt_output_name,didnt_get_output);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (NOT_THROWING &amp&amp val != UNBOUND &amp&amp !(val_status &amp VALUE_OK))\newline	err_logo(DK_WHAT, val);\newline    if (stopping_flag == THROWING &amp&amp\newline	((compare_node(throw_node, catch_tag, TRUE) == 0) ||\newline	 (isName(throw_node, Name_error) &amp&amp isName(catch_tag, Name_error)))) {\newline	    throw_node = UNBOUND;\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline    }\newline    goto fetch_cont;\newline\newline#ifdef OBJECTS\newline\newlinewithobject_continuation:\newline    save2(didnt_output_name,didnt_get_output);\newline    num2save(val_status,tailcall);\newline    save2(current_unode,current_object);\newline    newcont(withobject_followup);\newline    current_object = car(val);\newline    newcont(cont__cont(cdr(val)));\newline    list = val = val__cont(cdr(val));\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline    goto fetch_cont;\newline\newlinewithobject_followup:\newline    restore2(current_unode,current_object);\newline    num2restore(val_status,tailcall);\newline    restore2(didnt_output_name,didnt_get_output);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (NOT_THROWING &amp&amp val != UNBOUND &amp&amp !(val_status &amp VALUE_OK))\newline	err_logo(DK_WHAT, val);\newline    goto fetch_cont;\newline\newline#endif /* OBJECTS */\newline\newlinegoto_continuation:\newline    if (NOT_THROWING) {\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL, theName(Name_goto));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	proc = procnode__caseobj(ufun);\newline	list = bodylist__procnode(proc);\newline	unev = tree__tree(list);\newline	while (unev != NIL &amp&amp !check_throwing) {\newline	    if (nodetype(unev) == LINE)\newline		this_line = unparsed__line(unev);\newline	    exp = car(unev);\newline	    pop(unev);\newline	    if (is_list (exp) &amp&amp\newline		    (isName(car(exp), Name_tag)) &amp&amp\newline		    (nodetype(cadr(exp)) == QUOTE) &amp&amp\newline		    compare_node(val, node__quote(cadr(exp)), TRUE) == 0) {\newline		val = cons(theName(Name_tag), unev);\newline		stopping_flag = MACRO_RETURN;\newline		goto fetch_cont;\newline	    }\newline	}\newline	err_logo(BAD_DATA_UNREC, val);\newline    }\newline    val = UNBOUND;\newline    goto fetch_cont;\newline\newlinebegin_apply:\newline    /* This is for lapply. */\newline    exp = car(val);\newline    while (nodetype(exp) == ARRAY &amp&amp NOT_THROWING)\newline	exp = err_logo(APPLY_BAD_DATA, exp);\newline    argl = append(cadr(val), NIL);\newline    val = UNBOUND;\newline    while (!is_list(argl) &amp&amp NOT_THROWING)\newline	argl = err_logo(APPLY_BAD_DATA, argl);\newline    if (NOT_THROWING &amp&amp exp != NIL) {\newline	if (is_list(exp)) {		    /* template */\newline	    if (is_list(car(exp)) &amp&amp cdr(exp) != NIL) {\newline		if (is_list(cadr(exp))) {\newline		    /* procedure text form [[param ...] [instr ...] ...] */\newline		    proc = anonymous_function(exp);\newline		    debprint(&quotanon func&quot);\newline		    if (stopping_flag == THROWING) goto fetch_cont;\newline		    tracing = 0;\newline		    if (tailcall &lt= 0) {\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		    }\newline		    goto lambda_apply;\newline		}\newline		/* lambda form [[param ...] instr ...] */\newline		formals = car(exp);\newline		if (tailcall &lt= 0) {\newline		    save(var);\newline		    var = var_stack;\newline		    newcont(after_lambda);\newline		}\newline/*		numsave(tailcall);  */\newline		tailcall = 0;\newline		llocal(formals);    /* bind the formals locally */\newline/*		numrestore(tailcall);	*/\newline		for ( ;\newline		      formals != NIL &amp&amp argl != NIL &amp&amp NOT_THROWING;\newline		      formals = cdr(formals),\newline		      argl = cdr(argl))\newline		    setvalnode__caseobj(car(formals), car(argl));\newline		if (formals != NIL) {\newline		    err_logo(NOT_ENOUGH, exp);\newline		    goto fetch_cont;\newline		} else if (argl != NIL) {\newline		    err_logo(DK_WHAT, car(argl));\newline		    goto fetch_cont;\newline		}\newline		list = cdr(exp);\newline		goto lambda_qm;\newline	    } else {		/* question-mark form [instr ...] */\newline		qm_list = argl;\newline		list = exp;\newlinelambda_qm:\newline		make_tree(list);\newline		if (list == NIL || !is_tree(list)) {\newline		    goto fetch_cont;\newline		}\newline		unev = tree__tree(list);\newline		if (tailcall &lt= 0) {\newline		    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		}\newline		goto eval_sequence;\newline	    }\newline	} else {    /* name of procedure to apply */\newline	    int min, max, n;\newline	    NODE *arg;\newline	    fun = intern(exp);\newline	    check_library(fun);\newline	    proc = procnode__caseobj(fun);\newline	    while (proc == UNDEFINED &amp&amp NOT_THROWING) {\newline		val = err_logo(DK_HOW_UNREC, fun);\newline	    }\newline	    if (NOT_THROWING) {\newline		if (nodetype(proc) == CONS) {\newline		    min = getint(minargs__procnode(proc));\newline		    max = getint(maxargs__procnode(proc));\newline		} else {\newline		    if (getprimdflt(proc) &lt 0) {        /* special form */\newline			err_logo(DK_HOW_UNREC, fun);    /* can&#039t apply */\newline			goto fetch_cont;\newline		    } else {\newline			min = getprimmin(proc);\newline			if (min == OK_NO_ARG) min = 0;\newline			max = getprimmax(proc);\newline		    }\newline		}\newline		for (n = 0, arg = argl; arg != NIL; n++, arg = cdr(arg));\newline		if (n &lt min) {\newline		    err_logo(NOT_ENOUGH, NIL);\newline		} else if (n &gt max &amp&amp max &gt= 0) {\newline		    err_logo(TOO_MUCH, fun);\newline		} else {\newline		    if (tailcall &lt= 0) {\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		    }\newline		    goto apply_dispatch;\newline		}\newline	    }\newline	}\newline    }\newline    goto fetch_cont;\newline\newlineafter_lambda:\newline    reset_args(var);\newline    restore(var);\newline    goto fetch_cont;\newline}\newline","An explicit control evaluator, taken almost directly from SICP, section\newline 5.2. list is a flat list of expressions to evaluate. where is a label to\newline begin at. Return value depends on where.\newline \newline","3628372","pptp_ctrl.c","void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,\newline		       u_int16_t * call_id, u_int16_t * peer_call_id)\newline{\newline    assert(conn != NULL); assert(call != NULL);\newline    *call_id = call-&gtcall_id;\newline    *peer_call_id = call-&gtpeer_call_id;\newline}\newline","NOTE: The peer_call_id is undefined until we get a server response. \newline","4851220","vo_osdscaler.c","static osd_data_t *osd_data_init(vo_overlay_t *ovl, osd_data_t *next,\newline                                 uint32_t factor_x, uint32_t factor_y)\newline{\newline  osd_data_t *data = calloc(1, sizeof(osd_data_t));\newline\newline  data-&gtsource = ovl;\newline  data-&gtnext   = next;\newline\newline  memcpy(&ampdata-&gtovl, ovl, sizeof(vo_overlay_t));\newline\newline  int num_rle = data-&gtovl.num_rle;\newline\newline  /* new position and size */\newline  int x2 = ovl-&gtx + ovl-&gtwidth + 1;\newline  int y2 = ovl-&gty + ovl-&gtheight + 1;\newline  x2  = ((x2+1) * factor_x) &gt&gt 16;\newline  y2  = ((y2+1) * factor_y) &gt&gt 16;\newline  data-&gtovl.x       = (ovl-&gtx * factor_x) &gt&gt 16;\newline  data-&gtovl.y       = (ovl-&gty * factor_y) &gt&gt 16;\newline  data-&gtovl.width   = x2 - data-&gtovl.x - 1;\newline  data-&gtovl.height  = y2 - data-&gtovl.y - 1;\newline\newline#ifdef VO_CAP_VIDEO_WINDOW_OVERLAY\newline  if (ovl-&gtvideo_window_x      &gt= 0 &amp&amp\newline      ovl-&gtvideo_window_y      &gt= 0 &amp&amp\newline      ovl-&gtvideo_window_width  &gt  0 &amp&amp\newline      ovl-&gtvideo_window_height &gt  0) {\newline    data-&gtovl.video_window_x      = (ovl-&gtvideo_window_x      * factor_x) &gt&gt 16;\newline    data-&gtovl.video_window_y      = (ovl-&gtvideo_window_y      * factor_y) &gt&gt 16;\newline    data-&gtovl.video_window_width  = (ovl-&gtvideo_window_width  * factor_x) &gt&gt 16;\newline    data-&gtovl.video_window_height = (ovl-&gtvideo_window_height * factor_y) &gt&gt 16;\newline  }\newline#endif\newline\newline  data-&gtovl.rle     = (rle_elem_t*)\newline    rle_scale_nearest((struct osd_rle_elem_s*)ovl-&gtrle, &ampnum_rle,\newline                      ovl-&gtwidth, ovl-&gtheight,\newline                      data-&gtovl.width, data-&gtovl.height);\newline  data-&gtovl.num_rle = num_rle;\newline  data-&gtscaled      = 1;\newline\newline  LOGOSD(&quotI: %d,%d %dx%d&quot, ovl-&gtx, ovl-&gty, ovl-&gtwidth, ovl-&gtheight);\newline  LOGOSD(&quotO: %d,%d %dx%d&quot, data-&gtovl.x, data-&gtovl.y, data-&gtovl.width, data-&gtovl.height);\newline\newline  return data;\newline}\newline","\newline osd_data_init()\newline \newline - allocate and fill new osd_data_t\newline \newline \newline","6092061","muscle_upgma.c","void CalcDistRange(symmatrix_t *distmat, uint i, dist_t *row)\newline{\newline    uint j;\newline    for (j = 0; j &lt i; ++j) {\newline        row[j] = SymMatrixGetValue(distmat, i, j);\newline    }\newline}\newline","CalcDistRange\newline \newline Imitation of DistCalc.DistRange\newline \newline Sets values of row (vector / matrix row) to distances for object i with index j&lti\newline \newline row must be preallocated\newline \newline","2332316","utils.c","static SDL_Surface *load_image_prefix(const char *prefix, const char *lang, const char *name)\newline{\newline	SDL_Surface *surface = NULL;\newline	char *path = malloc(strlen(prefix)+ strlen (DIR_SEP) + strlen(name) \newline			+ strlen(lang) + strlen(DIR_SEP) + 1);\newline\newline	strcpy(path, prefix);\newline	strcat(path, DIR_SEP);\newline	strcat(path, lang);\newline	strcat(path, DIR_SEP);\newline	strcat(path, name);\newline\newline	surface = IMG_Load(path);\newline	free(path);\newline\newline	if (surface == NULL &amp&amp strcmp(lang, &quotcommon&quot))\newline		return load_image_prefix(prefix, &quotcommon&quot, name);\newline\newline	return surface;\newline}\newline","\newline Load an image from a directory\newline \newline @param[in] prefix The directory where the image file is\newline @param[in] lang The language we want\newline @param[in] name The image file to load\newline \newline @return an SDL_Surface representing the image, or NULL if loading\newline failed.\newline \newline","5814164","http.c","static struct addrinfo *get_bind_addr(\newline    const char *bindaddr, const unsigned short bindport)\newline{\newline    struct addrinfo hints, *ai;\newline    char portstr[6];\newline    int ret;\newline\newline    memset(&amphints, 0, sizeof(hints));\newline    hints.ai_family = AF_UNSPEC;\newline    hints.ai_socktype = SOCK_STREAM;\newline    hints.ai_flags = AI_PASSIVE;\newline\newline    snprintf(portstr, sizeof(portstr), &quot%u&quot, bindport);\newline    if ((ret = getaddrinfo(bindaddr, portstr, &amphints, &ampai)))\newline        err(1, &quotgetaddrinfo(%s, %s) failed: %s&quot,\newline            bindaddr ? bindaddr : &quotNULL&quot, portstr, gai_strerror(ret));\newline    if (ai == NULL)\newline        err(1, &quotgetaddrinfo() returned NULL pointer&quot);\newline    return ai;\newline}\newline","Use getaddrinfo to figure out what type of socket to create and\newline what to bind it to. &quotbindaddr&quot can be NULL. Remember to freeaddrinfo()\newline the result.\newline \newline","2961751","new.c","static struct node *\newlinedoit(char *cur, char *folders, char *sequences[])\newline{\newline    struct node *first, *cur_node, *node, *last, *prev;\newline    size_t folder_len;\newline    int count, total = 0;\newline    char *command = NULL, *sequences_s = NULL;\newline\newline    if (cur == NULL || cur[0] == &#039\\0&#039) {\newline        cur = &quotinbox&quot;\newline    }\newline\newline    check_folders(&ampfirst, &amplast, &ampcur_node, &ampfolder_len, cur,\newline		  folders, sequences);\newline\newline    if (run_mode == FNEXT || run_mode == FPREV) {\newline	if (first == NULL) {\newline	    /* No folders at all... */\newline	    return NULL;\newline	} else if (first-&gtn_next == NULL) {\newline	    /* We have only one node; any desired messages in it? */\newline	    if (first-&gtn_field == NULL) {\newline		return NULL;\newline	    } else {\newline		return first;\newline	    }\newline	} else if (cur_node == NULL) {\newline	    /* Current folder is not listed in .folders, return first. */\newline	    return first;\newline	}\newline    } else if (run_mode == UNSEEN) {\newline	sequences_s = join_sequences(sequences);\newline    }\newline\newline    for (node = first, prev = NULL;\newline	 node != NULL;\newline	 prev = node, node = node-&gtn_next) {\newline        if (run_mode == FNEXT) {\newline            /* If we have a previous node and it is the current\newline             * folder, return this node. */\newline            if (prev != NULL &amp&amp strcmp(prev-&gtn_name, cur) == 0) {\newline                return node;\newline            }\newline        } else if (run_mode == FPREV) {\newline            if (strcmp(node-&gtn_name, cur) == 0) {\newline                /* Found current folder in fprev mode; if we have a\newline                 * previous node in the list, return it; else return\newline                 * the last node. */\newline                if (prev == NULL) {\newline                    return last;\newline                }\newline                return prev;\newline            }\newline        } else if (run_mode == UNSEEN) {\newline            if (node-&gtn_field == NULL) {\newline                continue;\newline            }\newline\newline            printf(&quot\\n%d %s messages in %s&quot,\newline                   count_messages(node-&gtn_field),\newline		   sequences_s,\newline                   node-&gtn_name);\newline            if (strcmp(node-&gtn_name, cur) == 0) {\newline                puts(&quot (*: current folder)&quot);\newline            } else {\newline                puts(&quot&quot);\newline            }\newline            fflush(stdout);\newline\newline	    /* TODO: Split enough of scan.c out so that we can call it here. */\newline	    command = concat(&quotscan +&quot, node-&gtn_name, &quot &quot, sequences_s,\newline			     (void *)NULL);\newline	    system(command);\newline	    free(command);\newline        } else {\newline            if (node-&gtn_field == NULL) {\newline                continue;\newline            }\newline\newline            count = count_messages(node-&gtn_field);\newline            total += count;\newline\newline            printf(&quot%-*s %6d.%c %s\\n&quot,\newline                   (int) folder_len, node-&gtn_name,\newline                   count,\newline                   (strcmp(node-&gtn_name, cur) == 0 ? &#039*&#039 : &#039 &#039),\newline                   node-&gtn_field);\newline        }\newline    }\newline\newline    /* If we&#039re fnext, we haven&#039t checked the last node yet.  If it&#039s the\newline     * current folder, return the first node. */\newline    if (run_mode == FNEXT) {\newline	assert(last != NULL);\newline	if (strcmp(last-&gtn_name, cur) == 0) {\newline            return first;\newline	}\newline    }\newline\newline    if (run_mode == NEW) {\newline        printf(&quot%-*s %6d.\\n&quot, (int) folder_len, &quot total&quot, total);\newline    }\newline\newline    return cur_node;\newline}\newline","Return a struct node for the folder to change to. This is the next\newline (previous, if FPREV mode) folder with desired messages, or the current\newline folder if no folders have desired. If NEW or UNSEEN mode, print the\newline output but don&#039t change folders.\newline \newline n_name is the folder to change to, and n_field is the string list of\newline desired message numbers.\newline \newline","2183478","smtp.c","static const char * message_cb (void **buf, int *len, void *arg)\newline{\newline	message_t *message = (message_t *)arg;\newline\newline	if (len == NULL)\newline	{\newline		/* only allow rewinding in the beginning of a message otherwise\newline		 * it will break the pipes */\newline		assert(*buf == NULL);\newline		return NULL;\newline	}\newline\newline	if (*buf == NULL)\newline		*buf = malloc (BUFSIZ);\newline\newline	*len = message_read(message, *buf, BUFSIZ);\newline	\newline	return *buf;\newline}\newline","\newline Callback function to read the message from a file. \newline \newline Since libESMTP does not provide callbacks which translate line endings, one\newline must be provided by the application.\newline \newline","on","","","","on","on","on","","","","","on","","","on","","","on","","","","","","","","","","","","","","on","","","","","","","","","","","{}","Handle stream connection closure","Release a reference from an netlink message","set random type of the QP solver.","{}","{}","{}","allocate and fill new osd_data_t","Sets values of row (vector / matrix row) to distances","Load an image from a directory","figure out what type of socket to create","{}","Return a struct node for the folder to change to.","read the message from a file.","{}","Creates a binary data","Seek to position","{}","return 1 when supplied token requires its own (ascii) line,","Groups the names of subclasses for a class into amultifield value","Expand any %m substrings in a string to the current module path."
"38DCH97KHH22FPA7R4UCNAXZL1PJQG","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3KAKFY4PGU2G0XHS1D2HNKLDEI5I3N","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:23:42 PDT 2019","Wed Apr 17 15:30:10 PDT 2019","Fri Apr 19 15:30:10 PDT 2019","2019-04-19 22:30:21 UTC","","","388","100% (27/27)","100% (27/27)","100% (27/27)","6510619","modes_noglobals.c","static const split_cb_params * split_cb_high (void)\newline{\newline  return speex_split_cb_params_new (\newline   8,               /*subvect_size*/\newline   5,               /*nb_subvect*/\newline   hexc_table,       /*shape_cb*/\newline   7,               /*shape_bits*/\newline   1\newline   );\newline}\newline","Split-VQ innovation for high-band wideband \newline","4287340","rjb.c","static void rv2jobject(JNIEnv* jenv, VALUE val, jvalue* jv, const char* psig, int release)\newline{\newline    if (!release)\newline    {\newline	jv-&gtl = NULL;\newline	if (val == Qtrue || val == Qfalse)\newline	{\newline	    jv-&gtl = (*jenv)-&gtCallStaticObjectMethod(jenv,\newline		    jpcvt[PRM_BOOLEAN].klass, jpcvt[PRM_BOOLEAN].ctr_id,\newline				    (val == Qtrue) ? JNI_TRUE : JNI_FALSE);\newline	}\newline	else if (NIL_P(val))\newline	{\newline	    /* no-op */\newline	}\newline	else if (FIXNUM_P(val))\newline	{\newline	    jvalue arg;\newline	    int idx = PRM_INT;\newline#if HAVE_LONG_LONG\newline	    arg.j = FIX2LONG(val);\newline	    if (arg.j &lt INT_MIN || arg.j &gt INT_MAX)\newline	    {\newline		idx = PRM_LONG;\newline	    }\newline#else\newline	    arg.i = FIX2LONG(val);\newline#endif\newline	    jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[idx].klass,\newline				       jpcvt[idx].ctr_id, arg);\newline	}\newline	else\newline	{\newline	    jvalue arg;\newline	    switch (TYPE(val))\newline	    {\newline	    case T_DATA:\newline                if (IS_RJB_OBJECT(val))\newline		{\newline                    /* TODO: check instanceof (class (in psig) ) */\newline		    struct jvi_data* ptr;\newline		    Data_Get_Struct(val, struct jvi_data, ptr);\newline		    jv-&gtl = ptr-&gtobj;\newline		}\newline		else if (rb_obj_class(val) == rjbb)\newline		{\newline		    struct rj_bridge* ptr;\newline		    Data_Get_Struct(val, struct rj_bridge, ptr);\newline		    jv-&gtl = ptr-&gtproxy;\newline		}\newline		else if (CLASS_INHERITED(rjbc, rb_obj_class(val))) \newline		{\newline		    struct jv_data* ptr;\newline		    Data_Get_Struct(val, struct jv_data, ptr);\newline		    jv-&gtl = ptr-&gtidata.obj;\newline		}\newline		break;\newline	    case T_STRING:\newline                if (psig &amp&amp *psig == &#039[&#039 &amp&amp *(psig + 1) == &#039B&#039) {\newline                    jv-&gtl = r2barray(jenv, val, NULL);\newline                } else {\newline                    rv2jstring(jenv, val, jv, NULL, 0);\newline                }\newline		break;\newline	    case T_FLOAT:\newline		arg.d = NUM2DBL(val);\newline		jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[PRM_DOUBLE].klass,\newline				       jpcvt[PRM_DOUBLE].ctr_id, arg.d);\newline		break;\newline	    case T_ARRAY:\newline		jv-&gtl = r2objarray(jenv, val, &quotLjava/lang/Object;&quot);\newline		break;\newline#if HAVE_LONG_LONG                \newline            case T_BIGNUM:\newline                arg.j = rb_big2ll(val);\newline                jv-&gtl = (*jenv)-&gtNewObject(jenv, jpcvt[PRM_LONG].klass,\newline				       jpcvt[PRM_LONG].ctr_id, arg);\newline                break;\newline#endif                \newline            case T_OBJECT:\newline            default:\newline#if defined(DEBUG)\newline              {\newline                VALUE v = rb_funcall(val, rb_intern(&quotinspect&quot), 0);\newline                fprintf(stderr, &quotrtype:%d, sig=%s\\n&quot, TYPE(val), psig);\newline                fprintf(stderr, &quotobj:%s\\n&quot, StringValueCStr(v));\newline                fflush(stderr);\newline              }\newline#endif\newline                rb_raise(rb_eRuntimeError, &quotcan&#039t convert to java type&quot);\newline                break;\newline	    }\newline	}\newline    }\newline    else\newline    {\newline        switch (TYPE(val)) \newline	{\newline        case T_STRING:\newline        case T_FLOAT:\newline        case T_ARRAY:\newline        case T_BIGNUM:\newline            if (jv-&gtl) (*jenv)-&gtDeleteLocalRef(jenv, jv-&gtl);\newline            break;\newline        }\newline    }\newline}\newline","\newline psig may be NULL (from proxy/array call)\newline \newline","5246255","ow_1820.c","static ZERO_OR_ERROR FS_r_trimvalid(struct one_wire_query *owq)\newline{\newline	BYTE trim[2];\newline	switch (OW_die(PN(owq))) {\newline	case eB7:\newline	case eC2:\newline		RETURN_ERROR_IF_BAD(OW_r_trim(trim, PN(owq))) ;\newline		OWQ_Y(owq) = (((trim[0] &amp 0x07) == 0x05)\newline					  || ((trim[0] &amp 0x07) == 0x03))\newline			&amp&amp (trim[1] == 0xBB);\newline		break;\newline	default:\newline		OWQ_Y(owq) = 1;			/* Assume true */\newline	}\newline	return 0;\newline}\newline","Are the trim values valid-looking? \newline","2795585","libfvalue_binary_data.c","int libfvalue_binary_data_initialize(\newline     libfvalue_binary_data_t **binary_data,\newline     libcerror_error_t **error )\newline{\newline	static char *function = &quotlibfvalue_binary_data_initialize&quot;\newline\newline	if( binary_data == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid binary data.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *binary_data != NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\newline		 &quot%s: invalid binary data value already set.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	*binary_data = memory_allocate_structure(\newline	                libfvalue_binary_data_t );\newline\newline	if( *binary_data == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\newline		 &quot%s: unable to create binary data.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	if( memory_set(\newline	     *binary_data,\newline	     0,\newline	     sizeof( libfvalue_binary_data_t ) ) == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_MEMORY,\newline		 LIBCERROR_MEMORY_ERROR_SET_FAILED,\newline		 &quot%s: unable to clear binary data.&quot,\newline		 function );\newline\newline		goto on_error;\newline	}\newline	return( 1 );\newline\newlineon_error:\newline	if( *binary_data != NULL )\newline	{\newline		memory_free(\newline		 *binary_data );\newline\newline		*binary_data = NULL;\newline	}\newline	return( -1 );\newline}\newline","Creates a binary data\newline Make sure the value binary_data is referencing, is set to NULL\newline Returns 1 if successful or -1 on error\newline \newline","386380","xfer.c","int xfer_seek ( struct xfer_interface *xfer, off_t offset, int whence ) {\newline	struct io_buffer *iobuf;\newline	struct xfer_metadata meta = {\newline		.offset = offset,\newline		.whence = whence,\newline	};\newline\newline	DBGC ( xfer, &quotXFER %p seek %s+%ld\\n&quot, xfer,\newline	       whence_text ( whence ), offset );\newline\newline	/* Allocate and send a zero-length data buffer */\newline	iobuf = xfer_alloc_iob ( xfer, 0 );\newline	if ( ! iobuf )\newline		return -ENOMEM;\newline	return xfer_deliver_iob_meta ( xfer, iobuf, &ampmeta );\newline}\newline","\newline Seek to position\newline \newline @v xfer Data transfer interface\newline @v offset Offset to new position\newline @v whence Basis for new position\newline @ret rc Return status code\newline \newline","3785522","extract.c","unsigned char *extract_reg(f_state *s, u_int64_t c_offset, unsigned char *foundat, u_int64_t buflen,\newline						   s_spec *needle, u_int64_t f_offset)\newline{\newline	unsigned char	*buf = foundat;\newline	unsigned char	*extractbuf = NULL;\newline	int sizeofreg = htoi(&ampfoundat[0x28], FOREMOST_LITTLE_ENDIAN);\newline	int file_size=0;\newline	if(sizeofreg &lt 0 || sizeofreg &gt needle-&gtmax_len)	\newline	{\newline		return (foundat+4);\newline	}	\newline	foundat+=sizeofreg;\newline	file_size = (foundat - buf);\newline\newline	extractbuf = buf;\newline\newline\newline	write_to_disk(s, needle, file_size , extractbuf, c_offset + f_offset);\newline\newline			\newline	return NULL;\newline}\newline","\newline Function: extract_reg\newline Description:\newline Return: A pointer to where the EOF of the\newline \newline","6394458","mgribtoken.c","bool line_initializer(int token)\newline{\newline    /* THIS IS HACKISH - IT WILL CREATE A LINE FEED BEFORE */\newline    /* IT CREATES THE NEW LINE, WHICH ISN&#039T ALWAYS GOOD!!  */\newline    if(token&ltSTRINGBASE||token==mr_comment||token==mr_section||\newline       (token&gt=mr_P &amp&amp token&lt=mr_Os)) return true;\newline    else return false;\newline}\newline","return 1 when supplied token requires its own (ascii) line, 0 otherwise \newline","6006830","classinf.c","globle void EnvClassSubclasses(\newline  void *theEnv,\newline  void *clsptr,\newline  DATA_OBJECT *result,\newline  int inhp)\newline  {\newline   register unsigned i;\newline   register int id;\newline\newline   if ((id = GetTraversalID(theEnv)) == -1)\newline     return;\newline   i = CountSubclasses((DEFCLASS *) clsptr,inhp,id);\newline   ReleaseTraversalID(theEnv);\newline   result-&gttype = MULTIFIELD;\newline   result-&gtbegin = 0;\newline   SetpDOEnd(result,i);\newline   result-&gtvalue = (void *) EnvCreateMultifield(theEnv,i);\newline   if (i == 0)\newline     return;\newline   if ((id = GetTraversalID(theEnv)) == -1)\newline     return;\newline   StoreSubclasses(result-&gtvalue,1,(DEFCLASS *) clsptr,inhp,id,TRUE);\newline   ReleaseTraversalID(theEnv);\newline  }\newline","\newlineNAME : EnvClassSubclasses\newlineDESCRIPTION : Groups the names of subclasses for a class into a\newlinemultifield value for dynamic perusal\newlineINPUTS : 1) Generic pointer to class\newline2) Data object buffer to hold the sublclasses of the class\newline3) Include (1) or exclude (0) indirect subclasses\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Creates a multifield storing the names\newlinethe subclasses of the class\newlineNOTES : None\newline \newline","5745178","systask.c","static void string_expand(char *s, ModuleInst *mi)\newline{\newline  const char *path = ModuleInst_getPath(mi);\newline  int path_len = strlen(path);\newline\newline  while ((s = strstr(s,&quot%m&quot))) {\newline    memmove(s+path_len,s+2,strlen(s+2)+1);\newline    memmove(s,path,path_len);\newline    s += path_len;\newline  }\newline}\newline","\newline \newline Expand any %m substrings in a string to the current module path.\newline \newline Parameters:\newline s String to manipulate\newline mi Module instance\newline \newline \newline","384954","iscsi.c","static void iscsi_socket_close ( struct xfer_interface *socket, int rc ) {\newline	struct iscsi_session *iscsi =\newline		container_of ( socket, struct iscsi_session, socket );\newline\newline	/* Even a graceful close counts as an error for iSCSI */\newline	if ( ! rc )\newline		rc = -ECONNRESET;\newline\newline	/* Close session cleanly */\newline	iscsi_close_connection ( iscsi, rc );\newline\newline	/* Retry connection if within the retry limit, otherwise fail */\newline	if ( ++iscsi-&gtretry_count &lt= ISCSI_MAX_RETRIES ) {\newline		DBGC ( iscsi, &quotiSCSI %p retrying connection (retry #%d)\\n&quot,\newline		       iscsi, iscsi-&gtretry_count );\newline		if ( ( rc = iscsi_open_connection ( iscsi ) ) != 0 ) {\newline			DBGC ( iscsi, &quotiSCSI %p could not reconnect: %s\\n&quot,\newline			       iscsi, strerror ( rc ) );\newline			iscsi_scsi_done ( iscsi, rc );\newline		}\newline	} else {\newline		DBGC ( iscsi, &quotiSCSI %p retry count exceeded\\n&quot, iscsi );\newline		iscsi-&gtinstant_rc = rc;\newline		iscsi_scsi_done ( iscsi, rc );\newline	}\newline}\newline","\newline Handle stream connection closure\newline \newline @v socket Transport layer interface\newline @v rc Reason for close\newline \newline \newline","282907","msg.c","void nlmsg_free(struct nl_msg *msg)\newline{\newline	if (!msg)\newline		return;\newline\newline	msg-&gtnm_refcnt--;\newline	NL_DBG(4, &quotReturned message reference %p, %d remaining\\n&quot,\newline	       msg, msg-&gtnm_refcnt);\newline\newline	if (msg-&gtnm_refcnt &lt 0)\newline		BUG();\newline\newline	if (msg-&gtnm_refcnt &lt= 0) {\newline		free(msg-&gtnm_nlh);\newline		NL_DBG(2, &quotmsg %p: Freed\\n&quot, msg);\newline		free(msg);\newline	}\newline}\newline","\newline Release a reference from an netlink message\newline @arg msg message to release reference from\newline \newline Frees memory after the last reference has been released.\newline \newline","2638319","test_c.cpp","static void testminqpunit_setrandomalgoallmodern(minqpstate* s,\newline     ae_state *_state)\newline{\newline    ae_int_t i;\newline\newline\newline    i = 1+ae_randominteger(2, _state);\newline    if( i==1 )\newline    {\newline        minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0, _state);\newline    }\newline    if( i==2 )\newline    {\newline        minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, ae_fp_greater(ae_randomreal(_state),0.5), _state);\newline    }\newline}\newline","\newlineset random type of the QP solver.\newlineAll &quotmodern&quot solvers can be chosen.\newline \newline","5751013","lfc_register.c","int gfal_lfc_register(plugin_handle handle, gfal2_context_t context,\newline        gfalt_params_t params, const char* src_url, const char* dst_url, GError** error)\newline{\newline    struct lfc_ops* ops = (struct lfc_ops*) handle;\newline    char* lfc_host = NULL;\newline    char* lfc_path = NULL;\newline    char* src_host = NULL;\newline    int   ret_status = 0;\newline    int   lfc_errno = 0;\newline    gboolean file_existed = FALSE;\newline    GError *tmp_err = NULL;\newline\newline    // Get URL components\newline    ret_status = url_converter(handle, dst_url, &amplfc_host, &amplfc_path, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    ret_status = _get_host(src_url, &ampsrc_host, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: %s -&gt %s:%s&quot, src_url, lfc_host, lfc_path);\newline\newline    // Information about the replica\newline    struct size_and_checksum replica_info;\newline    ret_status = _get_replica_info(context, &ampreplica_info, src_url, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    // Set up LFC environment\newline    ret_status = lfc_configure_environment(ops, lfc_host, &amptmp_err);\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    gfal_lfc_init_thread(ops);\newline\newline    // Stat LFC entry\newline    struct lfc_filestatg statg;\newline    ret_status = ops-&gtstatg(lfc_path, NULL, &ampstatg);\newline    lfc_errno = gfal_lfc_get_errno(ops);\newline\newline    // File exists, validate the incoming replica\newline    if (ret_status == 0) {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: lfc exists, validate&quot);\newline        file_existed = TRUE;\newline        ret_status = _validate_new_replica(context, &ampstatg, &ampreplica_info, &amptmp_err);\newline    }\newline    // File do not exist, try to create\newline    else if (lfc_errno == ENOENT) {\newline        gfal_generate_guidG(statg.guid, NULL);\newline        ret_status = _lfc_touch(ops, lfc_path, statg.guid, &ampreplica_info, &amptmp_err);\newline    }\newline    // Failure\newline    else {\newline        ret_status = -1;\newline        gfal2_set_error(error, gfal2_get_plugin_lfc_quark(), errno, __func__,\newline                    &quotFailed to stat the file: %s (%d)&quot, gfal_lfc_get_strerror(ops), lfc_errno);\newline    }\newline\newline    if (ret_status != 0)\newline        goto register_end;\newline\newline    struct lfc_fileid unique_id = {{0}, 0};\newline    unique_id.fileid = statg.fileid;\newline    g_strlcpy(unique_id.server, lfc_host, sizeof(unique_id.server));\newline\newline    ret_status = ops-&gtaddreplica(statg.guid,\newline                                 file_existed?&ampunique_id:NULL,\newline                                 src_host, src_url,\newline                                 &#039-&#039, &#039P&#039,\newline                                 NULL, NULL);\newline    if (ret_status != 0) {\newline        int err_code = gfal_lfc_get_errno(ops);\newline\newline        if (err_code != EEXIST) {\newline            gfal2_set_error(error, gfal2_get_plugin_lfc_quark(), err_code, __func__,\newline                        &quotCould not register the replica : %s &quot, gfal_lfc_get_strerror(ops));\newline        }\newline        else {\newline            gfal2_log(G_LOG_LEVEL_MESSAGE, &quotlfc register: the replica is already registered, that is ok&quot);\newline            ret_status = 0;\newline        }\newline    }\newline    else {\newline        gfal2_log(G_LOG_LEVEL_DEBUG, &quotlfc register: done&quot);\newline    }\newline\newlineregister_end:\newline    if (tmp_err)\newline        gfal2_propagate_prefixed_error(error, tmp_err, __func__);\newline    g_free(lfc_host);\newline    g_free(lfc_path);\newline    g_free(src_host);\newline    return ret_status;\newline}\newline","\newline src_url can be anything\newline dst_url must be an LFC url\newline \newline","2960634","eval.c","NODE *evaluator(NODE *list, enum labels where) {\newline\newline    FIXNUM  cont   = 0;	    /* where to go next */\newline    int i;\newline    BOOLEAN tracing = FALSE; /* are we tracing the current procedure? */\newline	\newline    inside_evaluator++;\newline    eval_save();\newline    var = var_stack;\newline    newcont(all_done);\newline    newcont(where);\newline    goto fetch_cont;\newline\newlineall_done:\newline    reset_args(var);\newline    eval_restore();\newline    if (dont_fix_ift) {\newline        ift_iff_flag = dont_fix_ift-1;\newline        dont_fix_ift = 0;\newline    }\newlineinside_evaluator--;\newlinereturn(val);\newline\newlinebegin_line:\newline    this_line = list;\newline    val_status = NO_VALUE_OK;\newline    newcont(end_line);\newlinebegin_seq:\newline    debprint(&quotbegin_seq&quot);\newline    make_tree(list);\newline    if (!is_tree(list)) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    unev = tree__tree(list);\newline    goto eval_sequence;\newline\newlineend_line:\newline    if (val != UNBOUND) {\newline	if (NOT_THROWING) err_logo(DK_WHAT, val);\newline    }\newline/*    val = NIL;    */\newline    goto fetch_cont;\newline\newline\newline/* ----------------- EVAL ---------------------------------- */\newline/* Get here for actual argument, from eval_sequence (non-tail), or\newline   from tail call. */\newline\newlinetail_eval_dispatch:\newline    tailcall = 1;\newlineeval_dispatch:\newline    debprint(&quoteval_dispatch&quot);\newline    switch (nodetype(exp)) {\newline	case QUOTE:			/* quoted literal */\newline	    val = /* deep_copy */ (node__quote(exp));\newline	    goto fetch_cont;\newline	case COLON:			/* variable */\newline\newline#ifdef OBJECTS\newline	    val = varValue(node__colon(exp));\newline#else\newline	    val = valnode__colon(exp);\newline#endif\newline	    while (val == UNBOUND &amp&amp NOT_THROWING)\newline		val = err_logo(NO_VALUE, node__colon(exp));\newline	    goto fetch_cont;\newline	case CONS:			/* procedure application */\newline	    if (tailcall == 1 &amp&amp is_macro(car(exp)) &amp&amp\newline				 (is_list(procnode__caseobj(car(exp)))\newline		   || isName(car(exp), Name_goto))) {\newline		/* tail call to user-defined macro must be treated as non-tail\newline		 * because the expression returned by the macro\newline		 * remains to be evaluated in the caller&#039s context */\newline		unev = NIL;\newline		goto non_tail_eval;\newline	    }\newline	    fun = car(exp);\newline	    if (fun == Not_Enough_Node) {\newline		err_logo(TOO_MUCH, NIL);    /* When does this happen? */\newline		val = UNBOUND;\newline		goto fetch_cont;\newline	    }\newline	    if (flag__caseobj(fun, PROC_SPECFORM)) {\newline		argl = cdr(exp);\newline		goto apply_dispatch;\newline	    }\newline	    if (cdr(exp) != NIL)\newline		goto ev_application;\newline	    else\newline		goto ev_no_args;\newline	case ARRAY:			/* array must be copied */\newline	    val = deep_copy(exp);\newline	    goto fetch_cont;\newline	default:\newline	    val = exp;		/* self-evaluating */\newline	    goto fetch_cont;\newline    }\newline\newlineev_no_args:\newline    /* Evaluate an application of a procedure with no arguments. */\newline    argl = NIL;\newline    goto apply_dispatch;    /* apply the procedure */\newline\newlineev_application:\newline    /* Evaluate an application of a procedure with arguments. */\newline    unev = cdr(exp);\newline    argl = NIL;\newlineeval_arg_loop:\newline    debprint(&quoteval_arg_loop&quot);\newline    if (unev == NIL) goto eval_args_done;\newline    exp = car(unev);\newline    if (exp == Not_Enough_Node) {\newline	if (NOT_THROWING)\newline	    err_logo(NOT_ENOUGH, NIL);\newline	goto eval_args_done;\newline    }\newlinearg_from_macro:\newline    if (nodetype(exp) != CONS) {    /* Don&#039t bother saving registers */\newline	newcont(after_const_arg);    /* if the exp isn&#039t a proc call */\newline	goto eval_dispatch;\newline    }\newline    eval_save();\newline    save(current_unode);\newline    var = var_stack;\newline    tailcall = -1;\newline    didnt_output_name = NIL;\newline    didnt_get_output = cons_list(0, fun, ufun, this_line, END_OF_LIST);\newline    val_status = VALUE_OK;\newline	/* in case of apply or catch */\newline    newcont(accumulate_arg);\newline    goto eval_dispatch;	    /* evaluate the current argument */\newline\newlineaccumulate_arg:\newline    debprint(&quotaccumulate_arg&quot);\newline    /* Put the evaluated argument into the argl list. */\newline    reset_args(var);\newline    restore(current_unode);\newline    last_call = fun;\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    if (stopping_flag == OUTPUT || STOPPING) {\newline	didnt_output_name = NIL;\newline	err_logo(DIDNT_OUTPUT, fun);\newline    }\newline    while (NOT_THROWING &amp&amp val == UNBOUND) {\newline	val = err_logo(DIDNT_OUTPUT, NIL);\newline    }\newline    eval_restore();\newline    if (stopping_flag == MACRO_RETURN) {\newline	if (val == NIL || val == UNBOUND || cdr(val) != NIL) {\newline	    if (NOT_THROWING) {\newline		if (tree_dk_how != NIL &amp&amp tree_dk_how != UNBOUND)\newline		    err_logo(DK_HOW_UNREC, tree_dk_how);\newline		else\newline\newline		    err_logo((val!=NIL &amp&amp val!=UNBOUND) ?\newline				 RUNNABLE_ARG : ERR_MACRO, val);\newline	    }\newline	    goto eval_args_done;\newline	}\newline	exp = car(val);\newline	stopping_flag = RUN;\newline	goto arg_from_macro;\newline    }\newlineafter_const_arg:\newline    if (stopping_flag == THROWING) goto eval_args_done;\newline    push(val, argl);\newline    pop(unev);\newline    goto eval_arg_loop;\newline\newlineeval_args_done:\newline    if (stopping_flag == THROWING) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    argl = reverse(argl);\newline/* --------------------- APPLY ---------------------------- */\newlineapply_dispatch:\newline    debprint(&quotapply_dispatch&quot);\newline    /* Load in the procedure&#039s definition and decide whether it&#039s a compound\newline     * procedure or a primitive procedure.\newline     */\newline    proc = procnode__caseobj(fun);\newline    if (is_macro(fun)) {\newline	num2save(val_status,tailcall);\newline	save2(didnt_get_output,current_unode);\newline	didnt_get_output = the_generation; /* (cons nil nil) */\newline	    /* We want a value, but not as actual arg */\newline	newcont(macro_return);\newline    }\newline    if (proc == UNDEFINED) {	/* 5.0 punctuationless variables */\newline	if (!varTrue(AllowGetSet)) {    /* No getter/setter allowed, punt */\newline	    val = err_logo(DK_HOW, fun);\newline	    goto fetch_cont;\newline	} else if (argl == NIL) {	/* possible var getter */\newline	    val = valnode__caseobj(fun);\newline	    if (val == UNBOUND &amp&amp NOT_THROWING)\newline		val = err_logo(DK_HOW, fun);\newline	    else if (val != UNBOUND) {\newline		(void)ldefine(cons(fun, cons(\newline		   cons(NIL,cons(cons(theName(Name_output),\newline				      cons(make_colon(fun),NIL)),\newline				 NIL)),\newline		  NIL)));    /* make real proc so no disk load next time */\newline		setflag__caseobj(fun,PROC_BURIED);\newline	    }\newline	    goto fetch_cont;\newline	} else {		/* var setter */\newline	    NODE *name = intern(bf3(fun));\newline	    if (valnode__caseobj(name) == UNBOUND &amp&amp\newline		!(flag__caseobj(name, (HAS_GLOBAL_VALUE|IS_LOCAL_VALUE)))) {\newline		    val = err_logo(DK_HOW, fun);\newline		    goto fetch_cont;\newline	    }\newline	    (void)ldefine(cons(fun, cons(\newline		cons(Listvalue,\newline		     cons(cons(Make,\newline			       cons(make_quote(bf3(fun)),\newline				    cons(Dotsvalue,NIL))),\newline			  NIL))\newline		,NIL)));\newline	    setflag__caseobj(fun,PROC_BURIED);\newline	    argl = cons(bf3(fun), argl);\newline	    if (NOT_THROWING)\newline		val = lmake(argl);\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (is_list(proc)) goto compound_apply;\newline    /* primitive_apply */\newline    debprint(&quotprimitive_apply&quot);\newline    if (NOT_THROWING) {\newline	if ((tracing = flag__caseobj(fun, PROC_TRACED))) {\newline	    for (i = 0; i &lt trace_level; i++) {\newline		print_space(stdout);\newline	    }\newline	    ndprintf(stdout, &quot( %s &quot, fun);\newline	    if (argl != NIL) {\newline		arg = argl;\newline		while (arg != NIL) {\newline		    print_node(stdout, maybe_quote(car(arg)));\newline		    print_space(stdout);\newline		    arg = cdr(arg);\newline		}\newline	    }\newline		print_char(stdout, &#039)&#039);\newline	    new_line(stdout);\newline	}\newline	val = (*getprimfun(proc))(argl);\newline        if (tracing &amp&amp NOT_THROWING) {\newline	    for (i = 0; i &lt trace_level; i++) {\newline		print_space(stdout);\newline	    }\newline	    print_node(stdout, fun);\newline	    if (val == UNBOUND)\newline	        ndprintf(stdout, &quot %t\\n&quot, message_texts[TRACE_STOPS]);\newline	    else {\newline	        ndprintf(stdout, &quot %t %s\\n&quot, message_texts[TRACE_OUTPUTS],\newline					     maybe_quote(val));\newline	    }\newline        }\newline    } else\newline	val = UNBOUND;\newline	/* falls into fetch_cont */\newline\newline#if DEB_CONT\newline#define do_case(x) case x: debprint(&quotFetch_cont = &quot #x); goto x;\newline#else\newline#define do_case(x) case x: goto x;\newline#endif\newline\newlinefetch_cont:\newline    {\newline	enum labels x = (enum labels)cont;\newline	cont = (FIXNUM)car(numstack);\newline	numstack=cdr(numstack);\newline	switch (x) {\newline	    do_list(do_case)\newline	    default: abort();\newline	}\newline    }\newline\newline\newline/* ----------------- COMPOUND_APPLY ---------------------------------- */\newline\newlinecompound_apply:\newline    debprint(&quotcompound_apply&quot);\newline#ifdef mac\newline    check_mac_stop();\newline#endif\newline#ifdef ibm\newline    check_ibm_stop();\newline#endif\newline#ifdef HAVE_WX\newline    check_wx_stop();\newline#endif\newline    if ((tracing = flag__caseobj(fun, PROC_TRACED))) {\newline	for (i = 0; i &lt trace_level; i++) print_space(writestream);\newline	trace_level++;\newline	ndprintf(writestream, &quot( %s &quot, fun);\newline    }\newline/* Bind the actuals to the formals */\newlinelambda_apply:\newline    vsp = var_stack;	/* remember where we came in */\newline    for (formals = formals__procnode(proc);\newline    	 formals != NIL;\newline	 formals = cdr(formals)) {\newline	    parm = car(formals);\newline	    if (nodetype(parm) == INT) break;	/* default # args */\newline	    if (argl != NIL) {\newline		arg = car(argl);\newline		if (tracing) {\newline		    print_node(writestream, maybe_quote(arg));\newline		    print_space(writestream);\newline		}\newline	    } else\newline		arg = UNBOUND;\newline	    if (nodetype(parm) == CASEOBJ) {\newline		if (not_local(parm,vsp)) {\newline		    push(parm, var_stack);\newline		    if (flag__caseobj(parm, IS_LOCAL_VALUE))\newline			settype(var_stack, LOCALSAVE);\newline		    var_stack-&gtn_obj = valnode__caseobj(parm);\newline		    setflag__caseobj(parm, IS_LOCAL_VALUE);\newline		}\newline		tell_shadow(parm);\newline		setvalnode__caseobj(parm, arg);\newline		if (arg == UNBOUND)\newline		    err_logo(NOT_ENOUGH, fun);\newline	    } else if (nodetype(parm) == CONS) {\newline		/* parm is optional or rest */\newline		if (not_local(car(parm),vsp)) {\newline		    push(car(parm), var_stack);\newline		    if (flag__caseobj(car(parm), IS_LOCAL_VALUE))\newline			settype(var_stack, LOCALSAVE);\newline		    var_stack-&gtn_obj = valnode__caseobj(car(parm));\newline		    setflag__caseobj(car(parm), IS_LOCAL_VALUE);\newline		}\newline		tell_shadow(car(parm));\newline		if (cdr(parm) == NIL) {		    /* parm is rest */\newline		    setvalnode__caseobj(car(parm), argl);\newline		    if (tracing) {\newline			if (argl != NIL) pop(argl);\newline			while (argl != NIL) {\newline			    arg = car(argl);\newline			    print_node(writestream, maybe_quote(arg));\newline			    print_space(writestream);\newline			    pop(argl);\newline			}\newline		    } else argl = NIL;\newline		    break;\newline		}\newline		if (arg == UNBOUND) {		    /* use default */\newline		    eval_save();\newline		    save(current_unode);\newline		    var = var_stack;\newline		    tailcall = -1;\newline		    list = cdr(parm);\newline		    didnt_get_output = cons_list(0, fun, ufun,\newline						 list, END_OF_LIST);\newline		    didnt_output_name = NIL;\newline		    if (NOT_THROWING)\newline			make_tree(list);\newline		    else\newline			list = NIL;\newline		    if (!is_tree(list)) {\newline			val = UNBOUND;\newline			goto set_args_continue;\newline		    }\newline		    unev = tree__tree(list);\newline		    val = UNBOUND;\newline		    exp = car(unev);\newline		    pop(unev);\newline		    if (unev != NIL) {\newline			err_logo(BAD_DEFAULT, parm);\newline			val = UNBOUND;\newline			goto set_args_continue;\newline		    }\newline		    newcont(set_args_continue);\newline		    goto eval_dispatch;\newline\newlineset_args_continue:\newline		    if (stopping_flag == MACRO_RETURN) {\newline			if (val == NIL || val == UNBOUND || cdr(val) != NIL) {\newline			    if (NOT_THROWING)\newline				err_logo((val!=NIL &amp&amp val!=UNBOUND) ?\newline				 RUNNABLE_ARG : ERR_MACRO, val);\newline			} else {\newline			    reset_args(var);\newline			    exp = car(val);\newline			    stopping_flag = RUN;\newline			    didnt_get_output = cons_list(0, fun, ufun,\newline							 list, END_OF_LIST);\newline			    didnt_output_name = NIL;\newline			    tailcall = -1;\newline			    newcont(set_args_continue);\newline			    goto eval_dispatch;\newline			}\newline		    }\newline		    restore(current_unode);\newline		    last_call = fun;\newline		    if (current_unode != output_unode) {\newline			if (STOPPING || RUNNING) output_node = UNBOUND;\newline			if (stopping_flag == OUTPUT || STOPPING) {\newline			    stopping_flag = RUN;\newline			    val = output_node;\newline			}\newline		    }\newline		    if (stopping_flag == OUTPUT || STOPPING) {\newline			didnt_output_name = NIL;\newline			err_logo(DIDNT_OUTPUT, fun);\newline		    }\newline		    while (NOT_THROWING &amp&amp val == UNBOUND) {\newline			val = err_logo(DIDNT_OUTPUT, NIL);\newline		    }\newline		    reset_args(var);\newline		    eval_restore();\newline		    parm = car(formals);\newline		    if (stopping_flag == THROWING) {\newline			val = UNBOUND;\newline			goto fetch_cont;\newline		    }\newline		    arg = val;\newline		}\newline		setvalnode__caseobj(car(parm), arg);\newline	    }\newline	    if (argl != NIL) pop(argl);\newline    }\newline    if (argl != NIL) {\newline	err_logo(TOO_MUCH, fun);\newline    }\newline    if (check_throwing) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    vsp = NIL;\newline    if ((tracing = !is_list(fun) &amp&amp flag__caseobj(fun, PROC_TRACED))) {\newline	if (NOT_THROWING) print_char(writestream, &#039)&#039);\newline	new_line(writestream);\newline	save(fun);\newline	newcont(compound_apply_continue);\newline    }\newline    last_ufun = ufun;\newline    if (!is_list(fun)) ufun = fun;\newline    last_line = this_line;\newline    this_line = NIL;\newline/*    proc = (is_list(fun) ? anonymous_function(fun) : procnode__caseobj(fun)); */\newline/*  If that&#039s uncommented, begin_apply must get proc from fun, not exp  */\newline    list = bodylist__procnode(proc);	/* get the body ... */\newline    make_tree_from_body(list);\newline    if (!is_tree(list) || treepair__tree(list)==NIL) {\newline	val = UNBOUND;\newline	goto fetch_cont;\newline    }\newline    debprint(&quottreeified body&quot);\newline/*    printf(&quotlist = 0x%x = &quot,list); dbprint(list); */\newline    unev = tree__tree(list);\newline    if (NOT_THROWING) stopping_flag = RUN;\newline    output_node = UNBOUND;\newline    if (didnt_get_output == UNBOUND)\newline	val_status = NO_VALUE_OK | STOP_OK | STOP_TAIL;\newline    else if (didnt_get_output == NIL)\newline	val_status = NO_VALUE_OK | STOP_OK | STOP_TAIL |\newline		     OUTPUT_OK | OUTPUT_TAIL;\newline    else val_status = OUTPUT_OK | OUTPUT_TAIL;\newline    if (didnt_output_name == NIL) didnt_output_name = fun;\newline    current_unode = cons(NIL,NIL);  /* a marker for this proc call */\newline\newline/* ----------------- EVAL_SEQUENCE ---------------------------------- */\newline/* Fall through from proc body, call from start or fsubr argument */\newline\newlineeval_sequence:\newline    debprint(&quoteval_sequence&quot);\newline    /* Evaluate each expression in the sequence.\newline       Most of the complexity is in recognizing tail calls.\newline     */\newline    if (eval_buttonact != NIL) {\newline	make_tree(eval_buttonact);\newline	if (NOT_THROWING) {\newline	    if (is_tree(eval_buttonact)) {\newline		unev = append(tree__tree(eval_buttonact), unev);\newline		eval_buttonact = NIL;\newline	    }\newline	}\newline    }\newline    if (!RUNNING) goto fetch_cont;\newline    if (nodetype(unev) == LINE) {\newline	if (the_generation != (generation__line(unev))) {\newline	    /* something redefined while we&#039re running */\newline	    int linenum = 0;\newline	    this_line = tree__tree(bodylist__procnode(proc));\newline	    while (this_line != unev) {\newline		/* If redef isn&#039t end of line, don&#039t try to fix,\newline		   but don&#039t blow up either. (Maybe not called from here.) */\newline		if (this_line == NULL) goto nofix;\newline		if (nodetype(this_line) == LINE) linenum++;\newline		this_line = cdr(this_line);\newline	    }\newline	    untreeify_proc(proc);\newline	    make_tree_from_body(bodylist__procnode(proc));\newline	    unev = tree__tree(bodylist__procnode(proc));\newline	    while (--linenum &gt= 0) {\newline		do pop(unev);\newline		while (unev != NIL &amp&amp nodetype(unev) != LINE);\newline	    }\newline	}\newlinenofix:	this_line = unparsed__line(unev);\newline	if (ufun != NIL &amp&amp flag__caseobj(ufun, PROC_STEPPED)) {\newline	    if (tracing) {\newline		int i = 1;\newline		while (i++ &lt trace_level) print_space(stdout);\newline	    }\newline	    print_node(stdout, this_line);\newline	    (void)reader(stdin, &quot &gt&gt&gt &quot);\newline	}\newline    }\newline    exp = car(unev);\newline    pop(unev);\newline    if (exp != NIL &amp&amp\newline        is_list(exp) &amp&amp (is_tailform(procnode__caseobj(car(exp))))) {\newline      i = (int)getprimpri(procnode__caseobj(car(exp)));\newline      if (i == OUTPUT_PRIORITY) {\newline	if (cadr(exp) == Not_Enough_Node) {\newline	    err_logo(NOT_ENOUGH,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	didnt_output_name = NIL;\newline	if (val_status &amp OUTPUT_TAIL) {\newline	    didnt_get_output = cons_list(0,car(exp),ufun,this_line,\newline					 END_OF_LIST);\newline	    fun = car(exp);\newline	    exp = cadr(exp);\newline	    val_status = VALUE_OK;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    goto tail_eval_dispatch;\newline	} else if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	} else if (val_status &amp STOP_OK) {\newline	    didnt_get_output = cons_list(0,car(exp),ufun,this_line,\newline					 END_OF_LIST);\newline	    val_status = VALUE_OK;\newline	    exp = cadr(exp);\newline	    newcont(op_want_stop);\newline	    goto eval_dispatch;\newlineop_want_stop:\newline	    if (NOT_THROWING) err_logo(DK_WHAT_UP, val);\newline	    goto fetch_cont;\newline	} else if (val_status &amp VALUE_OK) {\newline	    /* pr apply [output ?] [3] */\newline	    debprint(&quotOp with VALUE_OK&quot);\newline	    didnt_output_name = fun;\newline	    goto tail_eval_dispatch;\newline	} else {\newline	    debprint(&quotOp with none of the above&quot);\newline	    goto tail_eval_dispatch;\newline	}\newline      } else if (i == STOP_PRIORITY) {\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	} else if (val_status &amp STOP_TAIL) {\newline	} else if (val_status &amp STOP_OK) {\newline	    stopping_flag = STOP;\newline	    output_unode = current_unode;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    if (NOT_THROWING) {\newline		if (didnt_get_output == NIL || didnt_get_output == UNBOUND) {\newline		/*  actually can happen: PRINT FOREACH ...\newline		    will give didn&#039t output message uplevel  */\newline		} else\newline		    err_logo(DIDNT_OUTPUT, NIL);\newline	    }\newline	} else {    /* show runresult [stop] inside a procedure */\newline	    didnt_output_name = car(exp);\newline	    if (NOT_THROWING) {\newline		if (didnt_get_output == NIL || didnt_get_output == UNBOUND) {\newline		/*  actually can happen: STOP during PAUSE */\newline		    err_logo(AT_TOPLEVEL, car(exp));\newline		} else\newline		    err_logo(DIDNT_OUTPUT, NIL);\newline	    }\newline	}\newline	val = UNBOUND;\newline	goto fetch_cont;\newline      } else { /* maybeoutput */\newline	debprint(&quotmaybeoutput&quot);\newline	if (cadr(exp) == Not_Enough_Node) {\newline	    err_logo(NOT_ENOUGH,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL,car(exp));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	if (val_status &amp OUTPUT_TAIL) {\newline	    didnt_output_name = NIL;\newline	    if (val_status &amp STOP_TAIL) {\newline		exp = cadr(exp);\newline		didnt_get_output = NIL;\newline		val_status = VALUE_OK | NO_VALUE_OK;\newline	    } else {\newline		didnt_get_output = cons_list(0,car(exp),ufun,\newline					     this_line,END_OF_LIST);\newline		exp = cadr(exp);\newline		val_status = VALUE_OK;\newline	    }\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    didnt_output_name = NIL;\newline	    if (val_status &amp STOP_OK) {\newline		didnt_get_output = NIL;\newline		val_status = NO_VALUE_OK | VALUE_OK;\newline		exp = cadr(exp);\newline		newcont(after_maybeoutput);\newline		goto eval_dispatch;\newlineafter_maybeoutput:\newline		if (val == UNBOUND)\newline		    lstop(NIL);\newline		else\newline		    loutput(cons(val, NIL));\newline		goto fetch_cont;\newline	    } else {\newline		goto eval_dispatch;\newline	    }\newline	} else if (val_status &amp STOP_TAIL) {\newline	    exp = cadr(exp);\newline	    didnt_get_output = UNBOUND;\newline	    val_status = NO_VALUE_OK;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp STOP_OK) {\newline	    exp = cadr(exp);\newline	    didnt_get_output = UNBOUND;\newline	    val_status = NO_VALUE_OK;\newline	    newcont(after_maybeoutput);\newline	    goto eval_dispatch;\newline	} else {\newline	    goto tail_eval_dispatch;\newline	}\newline      }\newline    }\newline\newline    if (unev == NIL) {	/* falling off tail of sequence */\newline	debprint(&quotfalling off&quot);\newline	if (val_status &amp NO_VALUE_OK) {\newline	    if (val_status &amp VALUE_OK)	/* from runresult */\newline		didnt_get_output = NIL;\newline	    else\newline		didnt_get_output = UNBOUND;\newline	} else if (val_status &amp VALUE_OK) {\newline	} else if (val_status &amp OUTPUT_OK) {\newlinenext_stop_want_output:\newline	    save(didnt_get_output);\newline	    didnt_get_output = UNBOUND;\newline	    val_status &amp= ~OUTPUT_TAIL;\newline	    newcont(fall_off_want_output);\newline	    goto tail_eval_dispatch;\newlinefall_off_want_output:\newline	    restore(didnt_get_output);\newline	    if (stopping_flag == OUTPUT) {\newline		goto fetch_cont;    /* repeat body did output */\newline	    }\newline	    if (NOT_THROWING &amp&amp val != UNBOUND) {\newline		/* Don&#039t allow just value expr w/o OUTPUT */\newline		err_logo(DK_WHAT, val);\newline	    }\newline	    goto fetch_cont;\newline	}\newline	goto tail_eval_dispatch;\newline    }\newline\newline    if (car(unev) != NIL &amp&amp is_list(car(unev)) &amp&amp   /* next is STOP */\newline	  (is_tailform(procnode__caseobj(car(car(unev))))) &amp&amp\newline	  getprimpri(procnode__caseobj(car(car(unev)))) == STOP_PRIORITY) {\newline	if (val_status &amp STOP_TAIL) {\newline	    didnt_get_output = UNBOUND;\newline	    goto tail_eval_dispatch;\newline	} else if (val_status &amp STOP_OK) {\newline	    goto non_tail_eval;\newline	} else if (val_status &amp OUTPUT_OK) {\newline	    goto next_stop_want_output;\newline	}   /* else treat as non-tail and the STOP will be caught later */\newline    }\newline\newlinenon_tail_eval:\newline    debprint(&quotnon_tail_eval&quot);\newline    if (nodetype(exp) != CONS) {    /* Don&#039t bother saving registers */\newline	newcont(after_constant);    /* if the exp isn&#039t a proc call */\newline	goto eval_dispatch;\newline    }\newline    eval_save();\newline    didnt_get_output = UNBOUND;    /* tell EVAL we don&#039t want a value */\newline    tailcall = 0;\newline    if (nodetype(exp) == CONS &amp&amp is_prim(procnode__caseobj(car(exp)))) {\newline	newcont(no_reset_args);	    /* primitive */\newline    } else {\newline	var = var_stack;\newline	newcont(eval_sequence_continue);\newline    }\newline    goto eval_dispatch;\newline\newlineeval_sequence_continue:\newline    reset_args(var);\newlineno_reset_args:	/* allows catch &quotfoo [local ...] to work */\newline    eval_restore();\newline    if (dont_fix_ift) {\newline	ift_iff_flag = dont_fix_ift-1;\newline	dont_fix_ift = 0;\newline    }\newline    debprint(&quoteval_sequence_continue&quot);\newline    if (stopping_flag == MACRO_RETURN) {\newline	if (val != NIL &amp&amp is_list(val) &amp&amp (isName(car(val), Name_tag)))\newline	    unev = cdr(val);	/* from goto */\newline	else\newline	    unev = append(val, unev);\newline	val = UNBOUND;\newline	stopping_flag = RUN;\newline	if (unev == NIL) goto fetch_cont;\newline    } else {\newline	if (current_unode != output_unode) {\newline	    if (STOPPING || RUNNING) output_node = UNBOUND;\newline	    if (stopping_flag == OUTPUT || STOPPING) {\newline		stopping_flag = RUN;\newline		val = output_node;\newline		goto fetch_cont;\newline	    }\newline	}\newline    }\newlineafter_constant:\newline    if (val != UNBOUND &amp&amp NOT_THROWING) {\newline	err_logo(DK_WHAT, val);\newline	val = UNBOUND;\newline    }\newline    if (NOT_THROWING &amp&amp unev == NIL) {\newline	goto fetch_cont;\newline    }\newline    goto eval_sequence;\newline\newlinecompound_apply_continue:\newline    /* Only get here if tracing */\newline    restore(parm);  /* saved from fun */\newline    --trace_level;\newline    if (NOT_THROWING) {\newline	for (i = 0; i &lt trace_level; i++) print_space(writestream);\newline	print_node(writestream, parm);\newline	if (val == UNBOUND)\newline	    ndprintf(writestream, &quot %t\\n&quot, message_texts[TRACE_STOPS]);\newline	else {\newline	    ndprintf(writestream, &quot %t %s\\n&quot, message_texts[TRACE_OUTPUTS],\newline					      maybe_quote(val));\newline	}\newline    }\newline    goto fetch_cont;\newline\newline/* --------------------- MACROS ---------------------------- */\newline\newlinemacro_return:\newline    restore2(didnt_get_output,current_unode);\newline    num2restore(val_status,tailcall);\newline    debprint(&quotmacro_return&quot);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    while (!is_list(val) &amp&amp NOT_THROWING) {\newline	val = err_logo(ERR_MACRO,val);\newline    }\newline    if (NOT_THROWING) {\newline	if (didnt_get_output != UNBOUND)\newline	    didnt_output_name = fun;\newline	if (is_cont(val)) {\newline	    newcont(cont__cont(val));\newline	    val = val__cont(val);\newline	    goto fetch_cont;\newline	}\newline	if (tailcall &lt= 0) {\newline	    list = val;\newline	    make_tree(list);\newline	    if (NOT_THROWING) {\newline		stopping_flag = MACRO_RETURN;\newline		if (!is_tree(list)) val = NIL;\newline		else val = tree__tree(list);\newline	    } else val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	list = val;\newline	goto begin_seq;\newline    }\newline    val = UNBOUND;\newline    goto fetch_cont;\newline\newline#define RUNRESULT_OUTPUT_LEGAL 0\newline\newlinerunresult_continuation:\newline    list = val;\newline#if RUNRESULT_OUTPUT_LEGAL\newline    val_status |= VALUE_OK | NO_VALUE_OK;\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline#else\newline    val_status = VALUE_OK | NO_VALUE_OK | OUTPUT_OK | STOP_OK;\newline    /* output and stop are not okay, but we give our own err message */\newline#endif\newline    save(current_unode);\newline    newcont(runresult_followup);\newline    goto begin_seq;\newline\newlinerunresult_followup:\newline    restore(current_unode);\newline    debprint(&quotrunresult_followup&quot);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	}\newline    }\newline    if (STOPPING || stopping_flag == OUTPUT)\newline	err_logo(RUNRES_STOP, NIL);\newline    if (val == UNBOUND) {\newline	val = NIL;\newline    } else {\newline	val = cons(val, NIL);\newline    }\newline    goto fetch_cont;\newline\newlinerepeat_continuation:\newline    list = cdr(val);\newline    num2save(repcount,user_repcount);\newline    repcount = getint(car(val));\newline    user_repcount = 0;\newlinerepeat_again:\newline    val = UNBOUND;\newline    if (repcount == 0) {\newlinerepeat_done:\newline	num2restore(repcount,user_repcount);\newline	goto fetch_cont;\newline    }\newline    user_repcount++;\newline    save2(list,var);\newline    var = var_stack;\newline    num2save(repcount,user_repcount);\newline    num2save(val_status,tailcall);\newline    val_status &amp= ~(VALUE_OK|OUTPUT_TAIL|STOP_TAIL);\newline    if (tailcall == 0) val_status |= NO_VALUE_OK;   /* embedded repeat */\newline    newcont(repeat_followup);\newline    goto begin_seq;\newline\newlinerepeat_followup:\newline    if (val != UNBOUND &amp&amp NOT_THROWING) {\newline	err_logo(DK_WHAT, val);\newline    }\newline    num2restore(val_status,tailcall);\newline    num2restore(repcount,user_repcount);\newline    reset_args(var);\newline    restore2(list,var);\newline    if (current_unode != output_unode) {\newline	debprint(&quotrep_foll tailcall&quot);\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto repeat_done;\newline	}\newline    }\newline    if (repcount &gt 0)    /* negative means forever */\newline	--repcount;\newline#ifdef mac\newline    check_mac_stop();\newline#endif\newline#ifdef ibm\newline    check_ibm_stop();\newline#endif\newline    if (RUNNING) goto repeat_again;\newline    val = UNBOUND;\newline    goto repeat_done;\newline\newlinecatch_continuation:\newline    list = cdr(val);\newline    catch_tag = car(val);\newline    if (isName(catch_tag, Name_error)) {\newline	push(Erract, var_stack);\newline	if (flag__caseobj(Erract, IS_LOCAL_VALUE))\newline	    settype(var_stack, LOCALSAVE);\newline	var_stack-&gtn_obj = valnode__caseobj(Erract);\newline	setflag__caseobj(Erract, IS_LOCAL_VALUE);\newline	setvalnode__caseobj(Erract, UNBOUND);\newline    }\newline    save2(didnt_output_name,didnt_get_output);\newline    num2save(val_status,tailcall);\newline    save2(current_unode,catch_tag);\newline    newcont(catch_followup);\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline    goto begin_seq;\newline\newlinecatch_followup:\newline    restore2(current_unode,catch_tag);\newline    num2restore(val_status,tailcall);\newline    restore2(didnt_output_name,didnt_get_output);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (NOT_THROWING &amp&amp val != UNBOUND &amp&amp !(val_status &amp VALUE_OK))\newline	err_logo(DK_WHAT, val);\newline    if (stopping_flag == THROWING &amp&amp\newline	((compare_node(throw_node, catch_tag, TRUE) == 0) ||\newline	 (isName(throw_node, Name_error) &amp&amp isName(catch_tag, Name_error)))) {\newline	    throw_node = UNBOUND;\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline    }\newline    goto fetch_cont;\newline\newline#ifdef OBJECTS\newline\newlinewithobject_continuation:\newline    save2(didnt_output_name,didnt_get_output);\newline    num2save(val_status,tailcall);\newline    save2(current_unode,current_object);\newline    newcont(withobject_followup);\newline    current_object = car(val);\newline    newcont(cont__cont(cdr(val)));\newline    list = val = val__cont(cdr(val));\newline    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline    goto fetch_cont;\newline\newlinewithobject_followup:\newline    restore2(current_unode,current_object);\newline    num2restore(val_status,tailcall);\newline    restore2(didnt_output_name,didnt_get_output);\newline    if (current_unode != output_unode) {\newline	if (STOPPING || RUNNING) output_node = UNBOUND;\newline	if (stopping_flag == OUTPUT || STOPPING) {\newline	    stopping_flag = RUN;\newline	    val = output_node;\newline	    goto fetch_cont;\newline	}\newline    }\newline    if (NOT_THROWING &amp&amp val != UNBOUND &amp&amp !(val_status &amp VALUE_OK))\newline	err_logo(DK_WHAT, val);\newline    goto fetch_cont;\newline\newline#endif /* OBJECTS */\newline\newlinegoto_continuation:\newline    if (NOT_THROWING) {\newline	if (ufun == NIL) {\newline	    err_logo(AT_TOPLEVEL, theName(Name_goto));\newline	    val = UNBOUND;\newline	    goto fetch_cont;\newline	}\newline	proc = procnode__caseobj(ufun);\newline	list = bodylist__procnode(proc);\newline	unev = tree__tree(list);\newline	while (unev != NIL &amp&amp !check_throwing) {\newline	    if (nodetype(unev) == LINE)\newline		this_line = unparsed__line(unev);\newline	    exp = car(unev);\newline	    pop(unev);\newline	    if (is_list (exp) &amp&amp\newline		    (isName(car(exp), Name_tag)) &amp&amp\newline		    (nodetype(cadr(exp)) == QUOTE) &amp&amp\newline		    compare_node(val, node__quote(cadr(exp)), TRUE) == 0) {\newline		val = cons(theName(Name_tag), unev);\newline		stopping_flag = MACRO_RETURN;\newline		goto fetch_cont;\newline	    }\newline	}\newline	err_logo(BAD_DATA_UNREC, val);\newline    }\newline    val = UNBOUND;\newline    goto fetch_cont;\newline\newlinebegin_apply:\newline    /* This is for lapply. */\newline    exp = car(val);\newline    while (nodetype(exp) == ARRAY &amp&amp NOT_THROWING)\newline	exp = err_logo(APPLY_BAD_DATA, exp);\newline    argl = append(cadr(val), NIL);\newline    val = UNBOUND;\newline    while (!is_list(argl) &amp&amp NOT_THROWING)\newline	argl = err_logo(APPLY_BAD_DATA, argl);\newline    if (NOT_THROWING &amp&amp exp != NIL) {\newline	if (is_list(exp)) {		    /* template */\newline	    if (is_list(car(exp)) &amp&amp cdr(exp) != NIL) {\newline		if (is_list(cadr(exp))) {\newline		    /* procedure text form [[param ...] [instr ...] ...] */\newline		    proc = anonymous_function(exp);\newline		    debprint(&quotanon func&quot);\newline		    if (stopping_flag == THROWING) goto fetch_cont;\newline		    tracing = 0;\newline		    if (tailcall &lt= 0) {\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		    }\newline		    goto lambda_apply;\newline		}\newline		/* lambda form [[param ...] instr ...] */\newline		formals = car(exp);\newline		if (tailcall &lt= 0) {\newline		    save(var);\newline		    var = var_stack;\newline		    newcont(after_lambda);\newline		}\newline/*		numsave(tailcall);  */\newline		tailcall = 0;\newline		llocal(formals);    /* bind the formals locally */\newline/*		numrestore(tailcall);	*/\newline		for ( ;\newline		      formals != NIL &amp&amp argl != NIL &amp&amp NOT_THROWING;\newline		      formals = cdr(formals),\newline		      argl = cdr(argl))\newline		    setvalnode__caseobj(car(formals), car(argl));\newline		if (formals != NIL) {\newline		    err_logo(NOT_ENOUGH, exp);\newline		    goto fetch_cont;\newline		} else if (argl != NIL) {\newline		    err_logo(DK_WHAT, car(argl));\newline		    goto fetch_cont;\newline		}\newline		list = cdr(exp);\newline		goto lambda_qm;\newline	    } else {		/* question-mark form [instr ...] */\newline		qm_list = argl;\newline		list = exp;\newlinelambda_qm:\newline		make_tree(list);\newline		if (list == NIL || !is_tree(list)) {\newline		    goto fetch_cont;\newline		}\newline		unev = tree__tree(list);\newline		if (tailcall &lt= 0) {\newline		    val_status &amp= ~(STOP_TAIL | OUTPUT_TAIL);\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		}\newline		goto eval_sequence;\newline	    }\newline	} else {    /* name of procedure to apply */\newline	    int min, max, n;\newline	    NODE *arg;\newline	    fun = intern(exp);\newline	    check_library(fun);\newline	    proc = procnode__caseobj(fun);\newline	    while (proc == UNDEFINED &amp&amp NOT_THROWING) {\newline		val = err_logo(DK_HOW_UNREC, fun);\newline	    }\newline	    if (NOT_THROWING) {\newline		if (nodetype(proc) == CONS) {\newline		    min = getint(minargs__procnode(proc));\newline		    max = getint(maxargs__procnode(proc));\newline		} else {\newline		    if (getprimdflt(proc) &lt 0) {        /* special form */\newline			err_logo(DK_HOW_UNREC, fun);    /* can&#039t apply */\newline			goto fetch_cont;\newline		    } else {\newline			min = getprimmin(proc);\newline			if (min == OK_NO_ARG) min = 0;\newline			max = getprimmax(proc);\newline		    }\newline		}\newline		for (n = 0, arg = argl; arg != NIL; n++, arg = cdr(arg));\newline		if (n &lt min) {\newline		    err_logo(NOT_ENOUGH, NIL);\newline		} else if (n &gt max &amp&amp max &gt= 0) {\newline		    err_logo(TOO_MUCH, fun);\newline		} else {\newline		    if (tailcall &lt= 0) {\newline			save(var);\newline			var = var_stack;\newline			newcont(after_lambda);\newline		    }\newline		    goto apply_dispatch;\newline		}\newline	    }\newline	}\newline    }\newline    goto fetch_cont;\newline\newlineafter_lambda:\newline    reset_args(var);\newline    restore(var);\newline    goto fetch_cont;\newline}\newline","An explicit control evaluator, taken almost directly from SICP, section\newline 5.2. list is a flat list of expressions to evaluate. where is a label to\newline begin at. Return value depends on where.\newline \newline","3628372","pptp_ctrl.c","void pptp_call_get_ids(PPTP_CONN * conn, PPTP_CALL * call,\newline		       u_int16_t * call_id, u_int16_t * peer_call_id)\newline{\newline    assert(conn != NULL); assert(call != NULL);\newline    *call_id = call-&gtcall_id;\newline    *peer_call_id = call-&gtpeer_call_id;\newline}\newline","NOTE: The peer_call_id is undefined until we get a server response. \newline","4851220","vo_osdscaler.c","static osd_data_t *osd_data_init(vo_overlay_t *ovl, osd_data_t *next,\newline                                 uint32_t factor_x, uint32_t factor_y)\newline{\newline  osd_data_t *data = calloc(1, sizeof(osd_data_t));\newline\newline  data-&gtsource = ovl;\newline  data-&gtnext   = next;\newline\newline  memcpy(&ampdata-&gtovl, ovl, sizeof(vo_overlay_t));\newline\newline  int num_rle = data-&gtovl.num_rle;\newline\newline  /* new position and size */\newline  int x2 = ovl-&gtx + ovl-&gtwidth + 1;\newline  int y2 = ovl-&gty + ovl-&gtheight + 1;\newline  x2  = ((x2+1) * factor_x) &gt&gt 16;\newline  y2  = ((y2+1) * factor_y) &gt&gt 16;\newline  data-&gtovl.x       = (ovl-&gtx * factor_x) &gt&gt 16;\newline  data-&gtovl.y       = (ovl-&gty * factor_y) &gt&gt 16;\newline  data-&gtovl.width   = x2 - data-&gtovl.x - 1;\newline  data-&gtovl.height  = y2 - data-&gtovl.y - 1;\newline\newline#ifdef VO_CAP_VIDEO_WINDOW_OVERLAY\newline  if (ovl-&gtvideo_window_x      &gt= 0 &amp&amp\newline      ovl-&gtvideo_window_y      &gt= 0 &amp&amp\newline      ovl-&gtvideo_window_width  &gt  0 &amp&amp\newline      ovl-&gtvideo_window_height &gt  0) {\newline    data-&gtovl.video_window_x      = (ovl-&gtvideo_window_x      * factor_x) &gt&gt 16;\newline    data-&gtovl.video_window_y      = (ovl-&gtvideo_window_y      * factor_y) &gt&gt 16;\newline    data-&gtovl.video_window_width  = (ovl-&gtvideo_window_width  * factor_x) &gt&gt 16;\newline    data-&gtovl.video_window_height = (ovl-&gtvideo_window_height * factor_y) &gt&gt 16;\newline  }\newline#endif\newline\newline  data-&gtovl.rle     = (rle_elem_t*)\newline    rle_scale_nearest((struct osd_rle_elem_s*)ovl-&gtrle, &ampnum_rle,\newline                      ovl-&gtwidth, ovl-&gtheight,\newline                      data-&gtovl.width, data-&gtovl.height);\newline  data-&gtovl.num_rle = num_rle;\newline  data-&gtscaled      = 1;\newline\newline  LOGOSD(&quotI: %d,%d %dx%d&quot, ovl-&gtx, ovl-&gty, ovl-&gtwidth, ovl-&gtheight);\newline  LOGOSD(&quotO: %d,%d %dx%d&quot, data-&gtovl.x, data-&gtovl.y, data-&gtovl.width, data-&gtovl.height);\newline\newline  return data;\newline}\newline","\newline osd_data_init()\newline \newline - allocate and fill new osd_data_t\newline \newline \newline","6092061","muscle_upgma.c","void CalcDistRange(symmatrix_t *distmat, uint i, dist_t *row)\newline{\newline    uint j;\newline    for (j = 0; j &lt i; ++j) {\newline        row[j] = SymMatrixGetValue(distmat, i, j);\newline    }\newline}\newline","CalcDistRange\newline \newline Imitation of DistCalc.DistRange\newline \newline Sets values of row (vector / matrix row) to distances for object i with index j&lti\newline \newline row must be preallocated\newline \newline","2332316","utils.c","static SDL_Surface *load_image_prefix(const char *prefix, const char *lang, const char *name)\newline{\newline	SDL_Surface *surface = NULL;\newline	char *path = malloc(strlen(prefix)+ strlen (DIR_SEP) + strlen(name) \newline			+ strlen(lang) + strlen(DIR_SEP) + 1);\newline\newline	strcpy(path, prefix);\newline	strcat(path, DIR_SEP);\newline	strcat(path, lang);\newline	strcat(path, DIR_SEP);\newline	strcat(path, name);\newline\newline	surface = IMG_Load(path);\newline	free(path);\newline\newline	if (surface == NULL &amp&amp strcmp(lang, &quotcommon&quot))\newline		return load_image_prefix(prefix, &quotcommon&quot, name);\newline\newline	return surface;\newline}\newline","\newline Load an image from a directory\newline \newline @param[in] prefix The directory where the image file is\newline @param[in] lang The language we want\newline @param[in] name The image file to load\newline \newline @return an SDL_Surface representing the image, or NULL if loading\newline failed.\newline \newline","5814164","http.c","static struct addrinfo *get_bind_addr(\newline    const char *bindaddr, const unsigned short bindport)\newline{\newline    struct addrinfo hints, *ai;\newline    char portstr[6];\newline    int ret;\newline\newline    memset(&amphints, 0, sizeof(hints));\newline    hints.ai_family = AF_UNSPEC;\newline    hints.ai_socktype = SOCK_STREAM;\newline    hints.ai_flags = AI_PASSIVE;\newline\newline    snprintf(portstr, sizeof(portstr), &quot%u&quot, bindport);\newline    if ((ret = getaddrinfo(bindaddr, portstr, &amphints, &ampai)))\newline        err(1, &quotgetaddrinfo(%s, %s) failed: %s&quot,\newline            bindaddr ? bindaddr : &quotNULL&quot, portstr, gai_strerror(ret));\newline    if (ai == NULL)\newline        err(1, &quotgetaddrinfo() returned NULL pointer&quot);\newline    return ai;\newline}\newline","Use getaddrinfo to figure out what type of socket to create and\newline what to bind it to. &quotbindaddr&quot can be NULL. Remember to freeaddrinfo()\newline the result.\newline \newline","2961751","new.c","static struct node *\newlinedoit(char *cur, char *folders, char *sequences[])\newline{\newline    struct node *first, *cur_node, *node, *last, *prev;\newline    size_t folder_len;\newline    int count, total = 0;\newline    char *command = NULL, *sequences_s = NULL;\newline\newline    if (cur == NULL || cur[0] == &#039\\0&#039) {\newline        cur = &quotinbox&quot;\newline    }\newline\newline    check_folders(&ampfirst, &amplast, &ampcur_node, &ampfolder_len, cur,\newline		  folders, sequences);\newline\newline    if (run_mode == FNEXT || run_mode == FPREV) {\newline	if (first == NULL) {\newline	    /* No folders at all... */\newline	    return NULL;\newline	} else if (first-&gtn_next == NULL) {\newline	    /* We have only one node; any desired messages in it? */\newline	    if (first-&gtn_field == NULL) {\newline		return NULL;\newline	    } else {\newline		return first;\newline	    }\newline	} else if (cur_node == NULL) {\newline	    /* Current folder is not listed in .folders, return first. */\newline	    return first;\newline	}\newline    } else if (run_mode == UNSEEN) {\newline	sequences_s = join_sequences(sequences);\newline    }\newline\newline    for (node = first, prev = NULL;\newline	 node != NULL;\newline	 prev = node, node = node-&gtn_next) {\newline        if (run_mode == FNEXT) {\newline            /* If we have a previous node and it is the current\newline             * folder, return this node. */\newline            if (prev != NULL &amp&amp strcmp(prev-&gtn_name, cur) == 0) {\newline                return node;\newline            }\newline        } else if (run_mode == FPREV) {\newline            if (strcmp(node-&gtn_name, cur) == 0) {\newline                /* Found current folder in fprev mode; if we have a\newline                 * previous node in the list, return it; else return\newline                 * the last node. */\newline                if (prev == NULL) {\newline                    return last;\newline                }\newline                return prev;\newline            }\newline        } else if (run_mode == UNSEEN) {\newline            if (node-&gtn_field == NULL) {\newline                continue;\newline            }\newline\newline            printf(&quot\\n%d %s messages in %s&quot,\newline                   count_messages(node-&gtn_field),\newline		   sequences_s,\newline                   node-&gtn_name);\newline            if (strcmp(node-&gtn_name, cur) == 0) {\newline                puts(&quot (*: current folder)&quot);\newline            } else {\newline                puts(&quot&quot);\newline            }\newline            fflush(stdout);\newline\newline	    /* TODO: Split enough of scan.c out so that we can call it here. */\newline	    command = concat(&quotscan +&quot, node-&gtn_name, &quot &quot, sequences_s,\newline			     (void *)NULL);\newline	    system(command);\newline	    free(command);\newline        } else {\newline            if (node-&gtn_field == NULL) {\newline                continue;\newline            }\newline\newline            count = count_messages(node-&gtn_field);\newline            total += count;\newline\newline            printf(&quot%-*s %6d.%c %s\\n&quot,\newline                   (int) folder_len, node-&gtn_name,\newline                   count,\newline                   (strcmp(node-&gtn_name, cur) == 0 ? &#039*&#039 : &#039 &#039),\newline                   node-&gtn_field);\newline        }\newline    }\newline\newline    /* If we&#039re fnext, we haven&#039t checked the last node yet.  If it&#039s the\newline     * current folder, return the first node. */\newline    if (run_mode == FNEXT) {\newline	assert(last != NULL);\newline	if (strcmp(last-&gtn_name, cur) == 0) {\newline            return first;\newline	}\newline    }\newline\newline    if (run_mode == NEW) {\newline        printf(&quot%-*s %6d.\\n&quot, (int) folder_len, &quot total&quot, total);\newline    }\newline\newline    return cur_node;\newline}\newline","Return a struct node for the folder to change to. This is the next\newline (previous, if FPREV mode) folder with desired messages, or the current\newline folder if no folders have desired. If NEW or UNSEEN mode, print the\newline output but don&#039t change folders.\newline \newline n_name is the folder to change to, and n_field is the string list of\newline desired message numbers.\newline \newline","2183478","smtp.c","static const char * message_cb (void **buf, int *len, void *arg)\newline{\newline	message_t *message = (message_t *)arg;\newline\newline	if (len == NULL)\newline	{\newline		/* only allow rewinding in the beginning of a message otherwise\newline		 * it will break the pipes */\newline		assert(*buf == NULL);\newline		return NULL;\newline	}\newline\newline	if (*buf == NULL)\newline		*buf = malloc (BUFSIZ);\newline\newline	*len = message_read(message, *buf, BUFSIZ);\newline	\newline	return *buf;\newline}\newline","\newline Callback function to read the message from a file. \newline \newline Since libESMTP does not provide callbacks which translate line endings, one\newline must be provided by the application.\newline \newline","on","","","","on","on","on","","on","","on","on","","","on","","","on","on","","","","","on","","","","","","","","","","","","","","","","","","","{}","Handle stream connection closure","Release a reference from an netlink message","set random type of the QP solver.","{}","{}","{}","allocate and fill new osd_data_t","{}","Load an image from a directory","{}","{}","Return a struct node for the folder to change to.","Callback function to read the message from a file.","{}","Creates a binary data","Seek to position","{}","{}","Groups the names of subclasses for a class","Expand any %m substrings in a string to the current module path."
"38EHZ67RIMS138MER52S9OLEJ8BMGS","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","34MAJL3QP4NMSQIDGO0DTJBU91743Z","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:33:47 PDT 2019","Wed Apr 17 15:40:33 PDT 2019","Fri Apr 19 15:40:33 PDT 2019","2019-04-19 22:41:21 UTC","","","406","100% (27/27)","100% (27/27)","100% (27/27)","6365586","edit_paint.cpp","inline void EditPaintPlugin::updateSelection(MeshModel &ampm, vector&lt pair&ltCVertexO *, PickingData&gt &gt * vertex_result)\newline{\newline	vector&ltCMeshO::FacePointer&gt::iterator fpi;\newline	vector&ltCMeshO::FacePointer&gt temp; //TODO maybe temp can be placed inside the class for better performance\newline	\newline	vector &ltCFaceO *&gt surround; /*&lt surrounding faces of a given face*/\newline	surround.reserve(6);\newline	\newline	if (current_options &amp EPP_AVG_NORMAL ) normal = Point3f(0.0, 0.0, 0.0);\newline	\newline  tri::UnMarkAll(m.cm);\newline	\newline	if (selection-&gtsize() == 0) {\newline		CMeshO::FaceIterator fi;\newline		temp.reserve(m.cm.fn); //avoid unnecessary expansions\newline        for(fi = m.cm.face.begin(); fi != m.cm.face.end(); ++fi){ \newline        	if(!(*fi).IsD()) {\newline        		temp.push_back((&amp*fi));\newline        	}\newline        } \newline	} else \newline	{\newline		temp.reserve(selection-&gtsize()); //avoid unnecessary expansions\newline		vertex_result-&gtreserve(selection-&gtsize());\newline		for(fpi = selection-&gtbegin();fpi != selection-&gtend(); ++fpi) \newline		{\newline			temp.push_back(*fpi);\newline		}\newline	}\newline	\newline	selection-&gtclear();\newline\newline	QPointF gl_cursorf = QPointF(latest_event.gl_position);\newline	QPointF gl_prev_cursorf = QPointF(previous_event.gl_position);\newline\newline	QPointF p[3],z[3]; //p stores vertex coordinates in screen space, z the corresponding depth value\newline	double tx,ty,tz;\newline\newline	bool backface = paintbox-&gtgetPaintBackFace();\newline	bool invisible = paintbox-&gtgetPaintInvisible();\newline	bool percentual = paintbox-&gtgetSizeUnit() == 1;\newline	\newline	double EPSILON = 0.003;\newline	\newline	double scale_fac = 1.0;\newline	float fov = 1.0;\newline	double distance[3];\newline	\newline	if (percentual)\newline	{\newline		double dX, dY, dZ;\newline\newline		fastMultiply(0,0,0,modelview_matrix,&ampdX,&ampdY,&ampdZ);\newline		fastMultiply(0,1,0,modelview_matrix,&amptx,&ampty,&amptz);\newline		\newline		scale_fac=sqrt((ty-dY)*(ty-dY)+(tx-dX)*(tx-dX)+(tz-dZ)*(tz-dZ));\newline\newline		/** to get the correct radius depending on distance but on fov too */\newline		float fo = glarea-&gtgetFov()*0.5;\newline		fov = 1.0/tan(fo*M_PI/180.0)*0.5;\newline	}\newline		\newline	for (unsigned int k = 0; k &lt temp.size(); k++) //for each face \newline	{\newline		CFaceO * fac = temp.at(k);\newline		bool intern = false;\newline		int checkable = 0; /*&lt counts how many valid vertices there are in this face*/\newline		\newline		for (int i = 0; i &lt 3; i++) //for each vertex defining the face\newline		{	\newline			if (gluProject((fac)-&gtV(i)-&gtP()[0], (fac)-&gtV(i)-&gtP()[1], (fac)-&gtV(i)-&gtP()[2],\newline					modelview_matrix, projection_matrix, viewport, &amptx, &ampty, &amptz) == GL_TRUE) checkable++; //if gluProjection works\newline			\newline			if (tz &lt 0 || tz &gt 1) checkable--; //but if outside depth bounds\newline			\newline			p[i].setX(tx); p[i].setY(ty); //store the position of the vertex on the screen\newline			\newline			//if the vertex is projected within the screen (i.e. it&#039s visible)\newline			if (tx&gt=0 &amp&amp tx&ltviewport[2] &amp&amp ty&gt=0 &amp&amp ty&ltviewport[3])\newline			{\newline				z[i].setX(tz); //the screen depth of the point\newline				z[i].setY((float)zbuffer[(int)(((int)ty)*viewport[2]+(int)tx)]); //the screen depth of the closest point at the same coors\newline			}else \newline			{ \newline				z[i].setX(1); //far\newline				z[i].setY(0); //near\newline			}\newline			\newline			if (percentual){\newline				double dx,dy,dz; // distance\newline				fastMultiply((fac)-&gtV(i)-&gtP()[0],(fac)-&gtV(i)-&gtP()[1],(fac)-&gtV(i)-&gtP()[2], modelview_matrix, &ampdx, &ampdy, &ampdz);\newline				distance[i]=dz;\newline			}\newline		}\newline\newline		if (backface || isFront(p[0],p[1],p[2]))\newline		{\newline			for (int j=0; j&lt3; j++) if (invisible || (z[j].x() &lt= z[j].y() + EPSILON))\newline			{\newline				PickingData vd; //TODO make it a pointer\newline				\newline				float radius = percentual ? vcg::math::Abs(current_brush.radius * scale_fac * viewport[3] * fov / distance[j]) : current_brush.size;\newline				\newline				if (isIn(gl_cursorf, gl_prev_cursorf, p[j].x(), p[j].y(), radius , &amp vd.distance, vd.rel_position)) \newline				{\newline					intern = true;\newline					if (vertex_result == NULL) continue;\newline          else if (!tri::IsMarked(m.cm,fac-&gtV(j)))\newline					{\newline						vd.position.setX((int)p[j].x()); vd.position.setY((int)p[j].y());\newline						pair&ltCVertexO *, PickingData&gt data(fac-&gtV(j), vd);\newline						vertex_result-&gtpush_back(data);\newline						\newline						if (current_options &amp EPP_AVG_NORMAL ) normal += fac-&gtV(j)-&gtN();\newline						\newline            tri::Mark(m.cm,fac-&gtV(j));\newline					}\newline				}\newline				\newline				if (vertex_result == NULL &amp&amp !intern &amp&amp lineHitsCircle(p[j],p[(j+1)%3], gl_cursorf, radius)) \newline				{\newline					intern = true; \newline					continue;\newline				}\newline			}\newline		\newline			if (checkable==3 &amp&amp !intern &amp&amp (pointInTriangle(gl_cursorf,p[0],p[1],p[2]) || pointInTriangle(gl_prev_cursorf,p[0],p[1],p[2]))) \newline			{\newline				intern = true;\newline			} \newline		}\newline		\newline    if (intern &amp&amp !tri::IsMarked(m.cm,fac))\newline		{\newline      tri::Mark(m.cm,fac);\newline			selection-&gtpush_back(fac);\newline			surround.clear();\newline			for (int lauf=0; lauf&lt3; lauf++) getSurroundingFacesVF(fac,lauf,&ampsurround);\newline\newline			for (unsigned int lauf3=0; lauf3&ltsurround.size(); lauf3++)\newline			{\newline        if (!tri::IsMarked(m.cm,surround[lauf3]))\newline				{\newline						temp.push_back(surround[lauf3]);\newline				} \newline			}\newline		}\newline	} //end of for each face loop\newline	\newline	if (current_options &amp EPP_AVG_NORMAL ) normal /= vertex_result-&gtsize();\newline}\newline","\newline Updates currently selected faces by using one of the\newline two methods. Just a new version of computeBrushedFaces\newline \newline It&#039s inlined because it&#039s only called once, inside Decorate.\newline Should it be called in other places, the inlining must be removed!\newline \newline","1484259","libbitmask.c","int bitmask_intersects(const struct bitmask *bmp1, const struct bitmask *bmp2)\newline{\newline	unsigned int i;\newline	for (i = 0; i &lt bmp1-&gtsize; i++)\newline		if (_getbit(bmp1, i) &amp _getbit(bmp2, i))\newline			return 1;\newline	return 0;\newline}\newline","True if two bitmasks do overlap \newline","2631739","xsltproc.c","static void startTimer(void)\newline{\newline    gettimeofday(&ampbegin,NULL);\newline}\newline","\newline startTimer: call where you want to start timing\newline \newline","4327940","db.c","struct db_filter_col *db_col_init(uint32_t def_action)\newline{\newline	struct db_filter_col *col;\newline\newline	col = malloc(sizeof(*col));\newline	if (col == NULL)\newline		return NULL;\newline\newline	/* clear the buffer for the first time */\newline	memset(col, 0, sizeof(*col));\newline\newline	/* reset the DB to a known state */\newline	if (db_col_reset(col, def_action) &lt 0)\newline		goto init_failure;\newline\newline	return col;\newline\newlineinit_failure:\newline	db_col_release(col);\newline	return NULL;\newline}\newline","\newline Intitalize a seccomp filter collection\newline @param def_action the default filter action\newline \newline This function initializes a seccomp filter collection and readies it for\newline use. Returns a pointer to the collection on success, NULL on failure.\newline \newline \newline","6575452","compiled_file.cpp","void bf::compiled_file::output_string_as_text( const std::string&amp s )\newline{\newline  m_file &lt&lt s &lt&lt std::endl;\newline} // compiled_file::output_string_as_text()\newline","\newline \\brief Write a string in the file.\newline \\param s The string to write.\newline \newline","1892552","frame.c","gboolean visu_gl_ext_frame_setGlView(VisuGlExtFrame *frame, VisuGlView *view)\newline{\newline  g_return_val_if_fail(VISU_IS_GL_EXT_FRAME(frame), FALSE);\newline\newline  if (frame-&gtpriv-&gtview)\newline    {\newline      g_signal_handler_disconnect(G_OBJECT(frame-&gtpriv-&gtview), frame-&gtpriv-&gtwidthHeight_signal);\newline      g_object_unref(frame-&gtpriv-&gtview);\newline    }\newline  if (view)\newline    {\newline      g_object_ref(view);\newline      frame-&gtpriv-&gtwidthHeight_signal =\newline        g_signal_connect(G_OBJECT(view), &quotWidthHeightChanged&quot,\newline                         G_CALLBACK(onViewChanged), (gpointer)frame);\newline    }\newline  else\newline    frame-&gtpriv-&gtwidthHeight_signal = 0;\newline  frame-&gtpriv-&gtview = view;\newline\newline  frame-&gtisBuilt = FALSE;\newline  return visu_gl_ext_getActive(VISU_GL_EXT(frame));\newline}\newline","\newline visu_gl_ext_frame_setGlView:\newline @frame: The #VisuGlExtFrame to attached to.\newline @view: the nodes to get the population of.\newline \newline Attach an #VisuGlView to render to and setup the frame.\newline \newline Since: 3.7\newline \newline Returns: TRUE if visu_gl_ext_frame_draw() should be called and\newline then &#039OpenGLAskForReDraw&#039 signal be emitted.\newline \newline","4480211","carrierroute.c","static int domain_fixup(void ** param) {\newline	pv_spec_t avp_spec;\newline	struct multiparam_t *mp;\newline	str s;\newline\newline	mp = (struct multiparam_t *)pkg_malloc(sizeof(struct multiparam_t));\newline	if (mp == NULL) {\newline		LM_ERR(&quotno more memory\\n&quot);\newline		return -1;\newline	}\newline	memset(mp, 0, sizeof(struct multiparam_t));\newline\newline	s.s = (char *)(*param);\newline	s.len = strlen(s.s);\newline\newline	if (s.s[0]!=&#039$&#039) {\newline		/* This is a name string */\newline		mp-&gttype=MP_INT;\newline\newline		/* get domain id */\newline		if ((mp-&gtu.n = add_domain(&amps)) &lt 0) {\newline			LM_ERR(&quotcould not add domain\\n&quot);\newline			pkg_free(mp);\newline			return -1;\newline		}\newline		pkg_free(*param);\newline		*param = (void *)mp;\newline	}\newline	else {\newline		/* This is a pseudo-variable */\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0) {\newline			LM_ERR(&quotpv_parse_spec failed for &#039%s&#039\\n&quot, (char *)(*param));\newline			pkg_free(mp);\newline			return -1;\newline		}\newline		if (avp_spec.type==PVT_AVP) {\newline			/* This is an AVP - could be an id or name */\newline			mp-&gttype=MP_AVP;\newline			if(pv_get_avp_name(0, &amp(avp_spec.pvp), &amp(mp-&gtu.a.name), &amp(mp-&gtu.a.flags))!=0) {\newline				LM_ERR(&quotInvalid AVP definition &lt%s&gt\\n&quot, (char *)(*param));\newline				pkg_free(mp);\newline				return -1;\newline			}\newline		} else {\newline			mp-&gttype=MP_PVE;\newline			if(pv_parse_format(&amps, &amp(mp-&gtu.p))&lt0) {\newline				LM_ERR(&quotpv_parse_format failed for &#039%s&#039\\n&quot, (char *)(*param));\newline				pkg_free(mp);\newline				return -1;\newline			}\newline		}\newline	}\newline	*param = (void*)mp;\newline\newline	return 0;\newline}\newline","\newline fixes the module functions&#039 parameters if it is a domain.\newline supports name string, and AVPs.\newline \newline @param param the parameter\newline \newline @return 0 on success, -1 on failure\newline \newline","3237262","attackpanel.cpp","void waitWithUpdate( int millisecs ) \newline{\newline   int frameDelay;\newline   if ( CGameOptions::Instance()-&gtvideo.ascframeratelimit  &gt 0 )\newline      frameDelay = 100 / CGameOptions::Instance()-&gtvideo.ascframeratelimit ;\newline   else\newline      frameDelay = 10;\newline   \newline   int t = ticker;\newline   do {\newline      int t2 = ticker;\newline      do {\newline         releasetimeslice();\newline      } while ( t2 + frameDelay &gt ticker );\newline      postScreenUpdate( PG_Application::GetScreen() );\newline   } while ( t + millisecs/20 &gt ticker ); \newline}\newline","\newlineWaits the given time, but still updates the screen.\newlineThese is of no use to the user, but are needed by the video recorder\newline \newline","6442068","str_mem.c","void *malloc2(size_t size)\newline{\newline	void	*free_block = NULL;\newline\newline	if (size == 0)\newline		big_error_in_lib(ZERO_RQ_SIZE, &quotmalloc2()&quot);\newline	/*else if (size &lt 0)\newline		big_error_in_lib(NEG_RQ_SIZE, &quotmalloc2()&quot);*/\newline	else if ((free_block = malloc(size)) == NULL)\newline		big_error_in_lib(OUT_OF_MEMORY, &quotmalloc2()&quot);\newline\newline	return free_block;\newline}\newline","\newline Wrappers for malloc(), realloc(), calloc() and free() which check returned value.\newline \newline","4285827","slabs.c","void* pool_new(slabs_t* pst) {\newline    void *ptr;\newline    slabheader_t *shp;\newline    if (pst-&gtpool_freelist == NULL) {\newline        if (pst-&gtmem_limit &amp&amp \newline            (pst-&gtmem_malloced + SETTING_ITEM_SIZE_MAX &gt pst-&gtmem_limit)) {\newline            return NULL;\newline        }\newline        ptr = memory_allocate(pst, SETTING_ITEM_SIZE_MAX);\newline        if (!ptr) return NULL;\newline        pst-&gtmem_malloced += SETTING_ITEM_SIZE_MAX;\newline        shp = (slabheader_t*)ptr;\newline        shp-&gtnext = NULL;\newline        pst-&gtpool_freelist = ptr;\newline    }\newline    shp = pst-&gtpool_freelist;\newline    pst-&gtpool_freelist = shp-&gtnext;\newline    return (void*)shp;\newline}\newline","\newline slab pool management\newline \newline","5048458","tool_object.cpp","bool ToolObject::fileSaveDialog( QString fname/*=QString()*/ )\newline{\newline   cerr &lt&lt &quotToolObject::fileSaveDialog( &#039&quot &lt&lt qPrintable( fname ) &lt&lt &quot&#039 )&quot &lt&lt endl;\newline   vk_assert( toolView != 0 );\newline\newline#if 0\newline   // TODO\newline   QFileDialog dlg;\newline   dlg.setShowHiddenFiles( true );\newline   QString flt = &quotXML Files (*.xml);;Log Files (*.log.*);;All Files (*)&quot;\newline   QString cptn = &quotSave Log File As&quot;\newline\newline   /* Ask fname if don&#039t have one already */\newline   if ( fname.isEmpty() ) {\newline      /* Start save-dialog in User-configured default log dir*/\newline      QString start_path = vkCfgProj-&gtrdEntry( &quotdefault-logdir&quot, &quotvalkyrie&quot );\newline      fname = dlg.getSaveFileName( start_path, flt, toolView, &quotfsdlg&quot, cptn );\newline\newline      if ( fname.isEmpty() ) {\newline         return false;\newline      }\newline   }\newline\newline   /* try to save file until succeed, or user Cancels */\newline   while ( !saveParsedOutput( fname ) ) {\newline      QString start_path = QFileInfo( fname ).dirPath();\newline      fname = dlg.getSaveFileName( start_path, flt, toolView, &quotfsdlg&quot, cptn );\newline\newline      if ( fname.isEmpty() ) { /* Cancelled */\newline         return false;\newline      }\newline   }\newline\newline#endif\newline   return true;\newline}\newline","!\newlineBrings up a fileSaveDialog until successfully saved,\newlineor user pressed Cancel.\newlineIf fname.isEmpty, ask user for a name first.\newlinereturns false on user pressing Cancel, else true.\newlineSave-dialog started in user-configured default log dir\newline \newline","2959308","edge_inline.h","inline void Edge::setSucc( Node *n)\newline{\newline    setNode( n, GRAPH_DIR_DOWN);\newline}\newline","\newline Connect edge with given node as a successor\newline \newline","5173338","pbuf.c","void\newlinepbuf_ref(struct pbuf *p)\newline{\newline  SYS_ARCH_DECL_PROTECT(old_level);\newline  /* pbuf given? */\newline  if (p != NULL) {\newline  LWIP_DEBUGF(PBUF_DEBUG, (&quotpbuf_ref: %p ref %d\\n&quot, (void *)p, p-&gtref));\newline    SYS_ARCH_PROTECT(old_level);\newline    ++(p-&gtref);\newline    SYS_ARCH_UNPROTECT(old_level);\newline  }\newline}\newline","\newline Increment the reference count of the pbuf.\newline \newline @param p pbuf to increase reference counter of\newline \newline \newline","3370276","generator.cpp","static bool hasExceptions(const Node* node,\newline                          NodeList&amp reentrant,\newline                          NodeList&amp threadsafe,\newline                          NodeList&amp nonreentrant)\newline{\newline    bool result = false;\newline    Node::ThreadSafeness ts = node-&gtthreadSafeness();\newline    const Aggregate* a = static_cast&ltconst Aggregate*&gt(node);\newline    NodeList::ConstIterator c = a-&gtchildNodes().constBegin();\newline    while (c != a-&gtchildNodes().constEnd()) {\newline        if (!(*c)-&gtisObsolete()){\newline            switch ((*c)-&gtthreadSafeness()) {\newline            case Node::Reentrant:\newline                reentrant.append(*c);\newline                if (ts == Node::ThreadSafe)\newline                    result = true;\newline                break;\newline            case Node::ThreadSafe:\newline                threadsafe.append(*c);\newline                if (ts == Node::Reentrant)\newline                    result = true;\newline                break;\newline            case Node::NonReentrant:\newline                nonreentrant.append(*c);\newline                result = true;\newline                break;\newline            default:\newline                break;\newline            }\newline        }\newline        ++c;\newline    }\newline    return result;\newline}\newline","\newlineThe node is an aggregate, typically a class node, which has\newlinea threadsafeness level. This function checks all the children\newlineof the node to see if they are exceptions to the node&#039s\newlinethreadsafeness. If there are any exceptions, the exceptions\newlineare added to the appropriate set (reentrant, threadsafe, and\newlinenonreentrant, and true is returned. If there are no exceptions,\newlinethe three node lists remain empty and false is returned.\newline \newline","6467987","hkl-pseudoaxis.c","const darray_string *hkl_engine_axis_names_get(const HklEngine *self,\newline					       HklEngineAxisNamesGet mode)\newline{\newline	switch(mode){\newline	case HKL_ENGINE_AXIS_NAMES_GET_READ:\newline		return &ampself-&gtmode-&gtinfo-&gtaxes_r;\newline	case HKL_ENGINE_AXIS_NAMES_GET_WRITE:\newline		return &ampself-&gtmode-&gtinfo-&gtaxes_w;\newline	default:\newline		return NULL;\newline	}\newline}\newline","\newline hkl_engine_axis_names_get:\newline @self: the this ptr\newline @mode:\newline \newline return a list of axes relevant when reading or writing on the\newline #HklEngine.\newline \newline exemple, for a K6C diffractometer in &quotlifting detector&quot mode, your\newline Engine control only 3 motors when writing, but the hkl values\newline depends on the 6 motors when reading.\newline \newline Returns: (type gpointer):\newline \newline","2072626","fstab.c","struct mntentchn *getmntoptfile(const char *file)\newline{\newline	struct mntentchn *mc;\newline	char *opts, *s;\newline	int l;\newline\newline	if (!file)\newline		return NULL;\newline\newline	l = strlen(file);\newline\newline	for (mc = mtab_head()-&gtnxt; mc; mc = mc-&gtnxt)\newline		if ((opts = mc-&gtmnt_opts) != NULL &amp&amp (s = strstr(opts, &quotloop=&quot))\newline		    &amp&amp !strncmp(s + 5, file, l)\newline		    &amp&amp (s == opts || s[-1] == &#039,&#039)\newline		    &amp&amp (s[l + 5] == 0 || s[l + 5] == &#039,&#039))\newline			return mc;\newline\newline	return NULL;\newline}\newline","Given the name FILE, try to find the option &quotloop=FILE&quot in mtab. \newline","4328021","gen_bpf.c","void gen_bpf_release(struct bpf_program *program)\newline{\newline	_program_free(program);\newline}\newline","\newline Free memory associated with a BPF representation\newline @param program the BPF representation\newline \newline Free the memory associated with a BPF representation generated by the\newline gen_bpf_generate() function.\newline \newline \newline","5974762","interpreter.cpp","static void vsConj(MKL_INT n, const float* x1, float* dest)\newline{\newline    MKL_INT j;\newline    for (j=0; j&ltn; j++) {\newline        dest[j] = x1[j];\newline    };\newline};\newline","Fake vsConj function just for casting purposes inside numexpr \newline","92119","ocateth.c","void free_ckbuf(uint16_t *buf)\newline{\newline   free(buf);\newline}\newline","! Free checksum buffer.\newline \newline","1236013","tmo_pattanaik00.cpp","void calculateLocalAdaptation(const pfstmo::Array2D* Y, int x, int y, float&amp Acone, float&amp Arod)\newline{\newline  int width = Y-&gtgetCols();\newline  int height = Y-&gtgetRows();\newline  \newline  int kernel_size = 4;\newline  static float LOG5 = log(5);\newline  float logLc = log((*Y)(x,y))/LOG5;\newline\newline  float pix_num = 0.0;\newline  float pix_sum = 0.0;\newline  for( int kx = -kernel_size ; kx &lt= kernel_size ; kx++ )\newline    for( int ky = -kernel_size ; ky &lt= kernel_size ; ky++ )\newline      if( (kx*kx+ky*ky)&lt=(kernel_size*kernel_size) &amp&amp\newline        x+kx&gt0 &amp&amp x+kx&ltwidth &amp&amp y+ky&gt0 &amp&amp y+ky&ltheight )\newline      {\newline	float L = (*Y)(x+kx,y+ky);\newline	float w = exp( -pow(fabs(log(L)/LOG5-logLc),6.0) );\newline	pix_sum +=  w*L;\newline	pix_num +=  w;\newline      }\newline\newline  if( pix_num&gt0.0 )\newline    Acone = Arod = (pix_sum / pix_num);\newline  else\newline    Acone = Arod = (*Y)(x,y);\newline}\newline","\newline @brief Calculate local adaptation for specified pixel coordinates\newline \newline Calculation based on article &quotAdaptive Gain Control&quot by Pattanaik\newline 2002.\newline \newline @param Y luminance map\newline @param x x-coordinate of pixel\newline @param y x-coordinate of pixel\newline @param Acone [out] calculated adaptation for cones\newline @param Arod [out] calculated adaptation for rods\newline \newline","4477247","dlg.c","static inline int get_route_set(struct sip_msg* _m, rr_t** _rs, unsigned char _order)\newline{\newline	struct hdr_field* ptr;\newline	rr_t* last, *p, *t;\newline\newline	last = 0;\newline	*_rs = 0;\newline\newline	ptr = _m-&gtrecord_route;\newline	while(ptr) {\newline		if (ptr-&gttype == HDR_RECORDROUTE_T) {\newline			if (parse_rr(ptr) &lt 0) {\newline				LM_ERR(&quotfailed to parse Record-Route body\\n&quot);\newline				goto error;\newline			}\newline\newline			p = (rr_t*)ptr-&gtparsed;\newline			while(p) {\newline				if (shm_duplicate_rr(&ampt, p, 1/*only first*/) &lt 0) {\newline					LM_ERR(&quotduplicating rr_t\\n&quot);\newline					goto error;\newline				}\newline				if (_order == NORMAL_ORDER) {\newline					if (!*_rs) *_rs = t;\newline					if (last) last-&gtnext = t;\newline					last = t;\newline				} else {\newline					t-&gtnext = *_rs;\newline					*_rs = t;\newline				}\newline\newline				p = p-&gtnext;\newline			}\newline\newline		}\newline		ptr = ptr-&gtnext;\newline	}\newline\newline	return 0;\newline\newline error:\newline        shm_free_rr(_rs);\newline	return -1;\newline}\newline","\newline Create a copy of route set either in normal or reverse order\newline \newline","","on","","","","","","","","on","","","","","","","","on","","","on","","","","","","on","","","","","","","","","","","","","","","","Updates currently selected faces","{}","returns false on user pressing Cancel, else true.","Connect edge with given node as a successor","Increment the reference count of the pbuf.","exceptionsare added to the appropriate set","return a list of axes relevant when reading or writing","try to find the option ""loop=FILE"" in mtab.","Free memory associated with a BPF representation","{}","Free checksum buffer.","True if two bitmasks do overlap","Calculate local adaptation for specified pixel coordinates","Create a copy of route set either in normal or reverse order","call where you want to start timing","initializes a seccomp filter collection and readies it foruse.","Write a string in the file.","{}","fixes the module functions' parameters if it is a domain.","Waits the given time, but still updates the screen.","{}"
"38EHZ67RIMS138MER52S9OLEJ8BMGS","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","34Z02EIMISDASJY6C2J2ZTPFMQO0TK","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 21:15:34 PDT 2019","Wed Apr 17 21:23:18 PDT 2019","Fri Apr 19 21:23:18 PDT 2019","2019-04-20 04:23:21 UTC","","","464","100% (10/10)","100% (10/10)","100% (10/10)","6365586","edit_paint.cpp","inline void EditPaintPlugin::updateSelection(MeshModel &ampm, vector&lt pair&ltCVertexO *, PickingData&gt &gt * vertex_result)\newline{\newline	vector&ltCMeshO::FacePointer&gt::iterator fpi;\newline	vector&ltCMeshO::FacePointer&gt temp; //TODO maybe temp can be placed inside the class for better performance\newline	\newline	vector &ltCFaceO *&gt surround; /*&lt surrounding faces of a given face*/\newline	surround.reserve(6);\newline	\newline	if (current_options &amp EPP_AVG_NORMAL ) normal = Point3f(0.0, 0.0, 0.0);\newline	\newline  tri::UnMarkAll(m.cm);\newline	\newline	if (selection-&gtsize() == 0) {\newline		CMeshO::FaceIterator fi;\newline		temp.reserve(m.cm.fn); //avoid unnecessary expansions\newline        for(fi = m.cm.face.begin(); fi != m.cm.face.end(); ++fi){ \newline        	if(!(*fi).IsD()) {\newline        		temp.push_back((&amp*fi));\newline        	}\newline        } \newline	} else \newline	{\newline		temp.reserve(selection-&gtsize()); //avoid unnecessary expansions\newline		vertex_result-&gtreserve(selection-&gtsize());\newline		for(fpi = selection-&gtbegin();fpi != selection-&gtend(); ++fpi) \newline		{\newline			temp.push_back(*fpi);\newline		}\newline	}\newline	\newline	selection-&gtclear();\newline\newline	QPointF gl_cursorf = QPointF(latest_event.gl_position);\newline	QPointF gl_prev_cursorf = QPointF(previous_event.gl_position);\newline\newline	QPointF p[3],z[3]; //p stores vertex coordinates in screen space, z the corresponding depth value\newline	double tx,ty,tz;\newline\newline	bool backface = paintbox-&gtgetPaintBackFace();\newline	bool invisible = paintbox-&gtgetPaintInvisible();\newline	bool percentual = paintbox-&gtgetSizeUnit() == 1;\newline	\newline	double EPSILON = 0.003;\newline	\newline	double scale_fac = 1.0;\newline	float fov = 1.0;\newline	double distance[3];\newline	\newline	if (percentual)\newline	{\newline		double dX, dY, dZ;\newline\newline		fastMultiply(0,0,0,modelview_matrix,&ampdX,&ampdY,&ampdZ);\newline		fastMultiply(0,1,0,modelview_matrix,&amptx,&ampty,&amptz);\newline		\newline		scale_fac=sqrt((ty-dY)*(ty-dY)+(tx-dX)*(tx-dX)+(tz-dZ)*(tz-dZ));\newline\newline		/** to get the correct radius depending on distance but on fov too */\newline		float fo = glarea-&gtgetFov()*0.5;\newline		fov = 1.0/tan(fo*M_PI/180.0)*0.5;\newline	}\newline		\newline	for (unsigned int k = 0; k &lt temp.size(); k++) //for each face \newline	{\newline		CFaceO * fac = temp.at(k);\newline		bool intern = false;\newline		int checkable = 0; /*&lt counts how many valid vertices there are in this face*/\newline		\newline		for (int i = 0; i &lt 3; i++) //for each vertex defining the face\newline		{	\newline			if (gluProject((fac)-&gtV(i)-&gtP()[0], (fac)-&gtV(i)-&gtP()[1], (fac)-&gtV(i)-&gtP()[2],\newline					modelview_matrix, projection_matrix, viewport, &amptx, &ampty, &amptz) == GL_TRUE) checkable++; //if gluProjection works\newline			\newline			if (tz &lt 0 || tz &gt 1) checkable--; //but if outside depth bounds\newline			\newline			p[i].setX(tx); p[i].setY(ty); //store the position of the vertex on the screen\newline			\newline			//if the vertex is projected within the screen (i.e. it&#039s visible)\newline			if (tx&gt=0 &amp&amp tx&ltviewport[2] &amp&amp ty&gt=0 &amp&amp ty&ltviewport[3])\newline			{\newline				z[i].setX(tz); //the screen depth of the point\newline				z[i].setY((float)zbuffer[(int)(((int)ty)*viewport[2]+(int)tx)]); //the screen depth of the closest point at the same coors\newline			}else \newline			{ \newline				z[i].setX(1); //far\newline				z[i].setY(0); //near\newline			}\newline			\newline			if (percentual){\newline				double dx,dy,dz; // distance\newline				fastMultiply((fac)-&gtV(i)-&gtP()[0],(fac)-&gtV(i)-&gtP()[1],(fac)-&gtV(i)-&gtP()[2], modelview_matrix, &ampdx, &ampdy, &ampdz);\newline				distance[i]=dz;\newline			}\newline		}\newline\newline		if (backface || isFront(p[0],p[1],p[2]))\newline		{\newline			for (int j=0; j&lt3; j++) if (invisible || (z[j].x() &lt= z[j].y() + EPSILON))\newline			{\newline				PickingData vd; //TODO make it a pointer\newline				\newline				float radius = percentual ? vcg::math::Abs(current_brush.radius * scale_fac * viewport[3] * fov / distance[j]) : current_brush.size;\newline				\newline				if (isIn(gl_cursorf, gl_prev_cursorf, p[j].x(), p[j].y(), radius , &amp vd.distance, vd.rel_position)) \newline				{\newline					intern = true;\newline					if (vertex_result == NULL) continue;\newline          else if (!tri::IsMarked(m.cm,fac-&gtV(j)))\newline					{\newline						vd.position.setX((int)p[j].x()); vd.position.setY((int)p[j].y());\newline						pair&ltCVertexO *, PickingData&gt data(fac-&gtV(j), vd);\newline						vertex_result-&gtpush_back(data);\newline						\newline						if (current_options &amp EPP_AVG_NORMAL ) normal += fac-&gtV(j)-&gtN();\newline						\newline            tri::Mark(m.cm,fac-&gtV(j));\newline					}\newline				}\newline				\newline				if (vertex_result == NULL &amp&amp !intern &amp&amp lineHitsCircle(p[j],p[(j+1)%3], gl_cursorf, radius)) \newline				{\newline					intern = true; \newline					continue;\newline				}\newline			}\newline		\newline			if (checkable==3 &amp&amp !intern &amp&amp (pointInTriangle(gl_cursorf,p[0],p[1],p[2]) || pointInTriangle(gl_prev_cursorf,p[0],p[1],p[2]))) \newline			{\newline				intern = true;\newline			} \newline		}\newline		\newline    if (intern &amp&amp !tri::IsMarked(m.cm,fac))\newline		{\newline      tri::Mark(m.cm,fac);\newline			selection-&gtpush_back(fac);\newline			surround.clear();\newline			for (int lauf=0; lauf&lt3; lauf++) getSurroundingFacesVF(fac,lauf,&ampsurround);\newline\newline			for (unsigned int lauf3=0; lauf3&ltsurround.size(); lauf3++)\newline			{\newline        if (!tri::IsMarked(m.cm,surround[lauf3]))\newline				{\newline						temp.push_back(surround[lauf3]);\newline				} \newline			}\newline		}\newline	} //end of for each face loop\newline	\newline	if (current_options &amp EPP_AVG_NORMAL ) normal /= vertex_result-&gtsize();\newline}\newline","\newline Updates currently selected faces by using one of the\newline two methods. Just a new version of computeBrushedFaces\newline \newline It&#039s inlined because it&#039s only called once, inside Decorate.\newline Should it be called in other places, the inlining must be removed!\newline \newline","1484259","libbitmask.c","int bitmask_intersects(const struct bitmask *bmp1, const struct bitmask *bmp2)\newline{\newline	unsigned int i;\newline	for (i = 0; i &lt bmp1-&gtsize; i++)\newline		if (_getbit(bmp1, i) &amp _getbit(bmp2, i))\newline			return 1;\newline	return 0;\newline}\newline","True if two bitmasks do overlap \newline","2631739","xsltproc.c","static void startTimer(void)\newline{\newline    gettimeofday(&ampbegin,NULL);\newline}\newline","\newline startTimer: call where you want to start timing\newline \newline","4327940","db.c","struct db_filter_col *db_col_init(uint32_t def_action)\newline{\newline	struct db_filter_col *col;\newline\newline	col = malloc(sizeof(*col));\newline	if (col == NULL)\newline		return NULL;\newline\newline	/* clear the buffer for the first time */\newline	memset(col, 0, sizeof(*col));\newline\newline	/* reset the DB to a known state */\newline	if (db_col_reset(col, def_action) &lt 0)\newline		goto init_failure;\newline\newline	return col;\newline\newlineinit_failure:\newline	db_col_release(col);\newline	return NULL;\newline}\newline","\newline Intitalize a seccomp filter collection\newline @param def_action the default filter action\newline \newline This function initializes a seccomp filter collection and readies it for\newline use. Returns a pointer to the collection on success, NULL on failure.\newline \newline \newline","6575452","compiled_file.cpp","void bf::compiled_file::output_string_as_text( const std::string&amp s )\newline{\newline  m_file &lt&lt s &lt&lt std::endl;\newline} // compiled_file::output_string_as_text()\newline","\newline \\brief Write a string in the file.\newline \\param s The string to write.\newline \newline","1892552","frame.c","gboolean visu_gl_ext_frame_setGlView(VisuGlExtFrame *frame, VisuGlView *view)\newline{\newline  g_return_val_if_fail(VISU_IS_GL_EXT_FRAME(frame), FALSE);\newline\newline  if (frame-&gtpriv-&gtview)\newline    {\newline      g_signal_handler_disconnect(G_OBJECT(frame-&gtpriv-&gtview), frame-&gtpriv-&gtwidthHeight_signal);\newline      g_object_unref(frame-&gtpriv-&gtview);\newline    }\newline  if (view)\newline    {\newline      g_object_ref(view);\newline      frame-&gtpriv-&gtwidthHeight_signal =\newline        g_signal_connect(G_OBJECT(view), &quotWidthHeightChanged&quot,\newline                         G_CALLBACK(onViewChanged), (gpointer)frame);\newline    }\newline  else\newline    frame-&gtpriv-&gtwidthHeight_signal = 0;\newline  frame-&gtpriv-&gtview = view;\newline\newline  frame-&gtisBuilt = FALSE;\newline  return visu_gl_ext_getActive(VISU_GL_EXT(frame));\newline}\newline","\newline visu_gl_ext_frame_setGlView:\newline @frame: The #VisuGlExtFrame to attached to.\newline @view: the nodes to get the population of.\newline \newline Attach an #VisuGlView to render to and setup the frame.\newline \newline Since: 3.7\newline \newline Returns: TRUE if visu_gl_ext_frame_draw() should be called and\newline then &#039OpenGLAskForReDraw&#039 signal be emitted.\newline \newline","4480211","carrierroute.c","static int domain_fixup(void ** param) {\newline	pv_spec_t avp_spec;\newline	struct multiparam_t *mp;\newline	str s;\newline\newline	mp = (struct multiparam_t *)pkg_malloc(sizeof(struct multiparam_t));\newline	if (mp == NULL) {\newline		LM_ERR(&quotno more memory\\n&quot);\newline		return -1;\newline	}\newline	memset(mp, 0, sizeof(struct multiparam_t));\newline\newline	s.s = (char *)(*param);\newline	s.len = strlen(s.s);\newline\newline	if (s.s[0]!=&#039$&#039) {\newline		/* This is a name string */\newline		mp-&gttype=MP_INT;\newline\newline		/* get domain id */\newline		if ((mp-&gtu.n = add_domain(&amps)) &lt 0) {\newline			LM_ERR(&quotcould not add domain\\n&quot);\newline			pkg_free(mp);\newline			return -1;\newline		}\newline		pkg_free(*param);\newline		*param = (void *)mp;\newline	}\newline	else {\newline		/* This is a pseudo-variable */\newline		if (pv_parse_spec(&amps, &ampavp_spec)==0) {\newline			LM_ERR(&quotpv_parse_spec failed for &#039%s&#039\\n&quot, (char *)(*param));\newline			pkg_free(mp);\newline			return -1;\newline		}\newline		if (avp_spec.type==PVT_AVP) {\newline			/* This is an AVP - could be an id or name */\newline			mp-&gttype=MP_AVP;\newline			if(pv_get_avp_name(0, &amp(avp_spec.pvp), &amp(mp-&gtu.a.name), &amp(mp-&gtu.a.flags))!=0) {\newline				LM_ERR(&quotInvalid AVP definition &lt%s&gt\\n&quot, (char *)(*param));\newline				pkg_free(mp);\newline				return -1;\newline			}\newline		} else {\newline			mp-&gttype=MP_PVE;\newline			if(pv_parse_format(&amps, &amp(mp-&gtu.p))&lt0) {\newline				LM_ERR(&quotpv_parse_format failed for &#039%s&#039\\n&quot, (char *)(*param));\newline				pkg_free(mp);\newline				return -1;\newline			}\newline		}\newline	}\newline	*param = (void*)mp;\newline\newline	return 0;\newline}\newline","\newline fixes the module functions&#039 parameters if it is a domain.\newline supports name string, and AVPs.\newline \newline @param param the parameter\newline \newline @return 0 on success, -1 on failure\newline \newline","3237262","attackpanel.cpp","void waitWithUpdate( int millisecs ) \newline{\newline   int frameDelay;\newline   if ( CGameOptions::Instance()-&gtvideo.ascframeratelimit  &gt 0 )\newline      frameDelay = 100 / CGameOptions::Instance()-&gtvideo.ascframeratelimit ;\newline   else\newline      frameDelay = 10;\newline   \newline   int t = ticker;\newline   do {\newline      int t2 = ticker;\newline      do {\newline         releasetimeslice();\newline      } while ( t2 + frameDelay &gt ticker );\newline      postScreenUpdate( PG_Application::GetScreen() );\newline   } while ( t + millisecs/20 &gt ticker ); \newline}\newline","\newlineWaits the given time, but still updates the screen.\newlineThese is of no use to the user, but are needed by the video recorder\newline \newline","6442068","str_mem.c","void *malloc2(size_t size)\newline{\newline	void	*free_block = NULL;\newline\newline	if (size == 0)\newline		big_error_in_lib(ZERO_RQ_SIZE, &quotmalloc2()&quot);\newline	/*else if (size &lt 0)\newline		big_error_in_lib(NEG_RQ_SIZE, &quotmalloc2()&quot);*/\newline	else if ((free_block = malloc(size)) == NULL)\newline		big_error_in_lib(OUT_OF_MEMORY, &quotmalloc2()&quot);\newline\newline	return free_block;\newline}\newline","\newline Wrappers for malloc(), realloc(), calloc() and free() which check returned value.\newline \newline","4285827","slabs.c","void* pool_new(slabs_t* pst) {\newline    void *ptr;\newline    slabheader_t *shp;\newline    if (pst-&gtpool_freelist == NULL) {\newline        if (pst-&gtmem_limit &amp&amp \newline            (pst-&gtmem_malloced + SETTING_ITEM_SIZE_MAX &gt pst-&gtmem_limit)) {\newline            return NULL;\newline        }\newline        ptr = memory_allocate(pst, SETTING_ITEM_SIZE_MAX);\newline        if (!ptr) return NULL;\newline        pst-&gtmem_malloced += SETTING_ITEM_SIZE_MAX;\newline        shp = (slabheader_t*)ptr;\newline        shp-&gtnext = NULL;\newline        pst-&gtpool_freelist = ptr;\newline    }\newline    shp = pst-&gtpool_freelist;\newline    pst-&gtpool_freelist = shp-&gtnext;\newline    return (void*)shp;\newline}\newline","\newline slab pool management\newline \newline","5048458","tool_object.cpp","bool ToolObject::fileSaveDialog( QString fname/*=QString()*/ )\newline{\newline   cerr &lt&lt &quotToolObject::fileSaveDialog( &#039&quot &lt&lt qPrintable( fname ) &lt&lt &quot&#039 )&quot &lt&lt endl;\newline   vk_assert( toolView != 0 );\newline\newline#if 0\newline   // TODO\newline   QFileDialog dlg;\newline   dlg.setShowHiddenFiles( true );\newline   QString flt = &quotXML Files (*.xml);;Log Files (*.log.*);;All Files (*)&quot;\newline   QString cptn = &quotSave Log File As&quot;\newline\newline   /* Ask fname if don&#039t have one already */\newline   if ( fname.isEmpty() ) {\newline      /* Start save-dialog in User-configured default log dir*/\newline      QString start_path = vkCfgProj-&gtrdEntry( &quotdefault-logdir&quot, &quotvalkyrie&quot );\newline      fname = dlg.getSaveFileName( start_path, flt, toolView, &quotfsdlg&quot, cptn );\newline\newline      if ( fname.isEmpty() ) {\newline         return false;\newline      }\newline   }\newline\newline   /* try to save file until succeed, or user Cancels */\newline   while ( !saveParsedOutput( fname ) ) {\newline      QString start_path = QFileInfo( fname ).dirPath();\newline      fname = dlg.getSaveFileName( start_path, flt, toolView, &quotfsdlg&quot, cptn );\newline\newline      if ( fname.isEmpty() ) { /* Cancelled */\newline         return false;\newline      }\newline   }\newline\newline#endif\newline   return true;\newline}\newline","!\newlineBrings up a fileSaveDialog until successfully saved,\newlineor user pressed Cancel.\newlineIf fname.isEmpty, ask user for a name first.\newlinereturns false on user pressing Cancel, else true.\newlineSave-dialog started in user-configured default log dir\newline \newline","2959308","edge_inline.h","inline void Edge::setSucc( Node *n)\newline{\newline    setNode( n, GRAPH_DIR_DOWN);\newline}\newline","\newline Connect edge with given node as a successor\newline \newline","5173338","pbuf.c","void\newlinepbuf_ref(struct pbuf *p)\newline{\newline  SYS_ARCH_DECL_PROTECT(old_level);\newline  /* pbuf given? */\newline  if (p != NULL) {\newline  LWIP_DEBUGF(PBUF_DEBUG, (&quotpbuf_ref: %p ref %d\\n&quot, (void *)p, p-&gtref));\newline    SYS_ARCH_PROTECT(old_level);\newline    ++(p-&gtref);\newline    SYS_ARCH_UNPROTECT(old_level);\newline  }\newline}\newline","\newline Increment the reference count of the pbuf.\newline \newline @param p pbuf to increase reference counter of\newline \newline \newline","3370276","generator.cpp","static bool hasExceptions(const Node* node,\newline                          NodeList&amp reentrant,\newline                          NodeList&amp threadsafe,\newline                          NodeList&amp nonreentrant)\newline{\newline    bool result = false;\newline    Node::ThreadSafeness ts = node-&gtthreadSafeness();\newline    const Aggregate* a = static_cast&ltconst Aggregate*&gt(node);\newline    NodeList::ConstIterator c = a-&gtchildNodes().constBegin();\newline    while (c != a-&gtchildNodes().constEnd()) {\newline        if (!(*c)-&gtisObsolete()){\newline            switch ((*c)-&gtthreadSafeness()) {\newline            case Node::Reentrant:\newline                reentrant.append(*c);\newline                if (ts == Node::ThreadSafe)\newline                    result = true;\newline                break;\newline            case Node::ThreadSafe:\newline                threadsafe.append(*c);\newline                if (ts == Node::Reentrant)\newline                    result = true;\newline                break;\newline            case Node::NonReentrant:\newline                nonreentrant.append(*c);\newline                result = true;\newline                break;\newline            default:\newline                break;\newline            }\newline        }\newline        ++c;\newline    }\newline    return result;\newline}\newline","\newlineThe node is an aggregate, typically a class node, which has\newlinea threadsafeness level. This function checks all the children\newlineof the node to see if they are exceptions to the node&#039s\newlinethreadsafeness. If there are any exceptions, the exceptions\newlineare added to the appropriate set (reentrant, threadsafe, and\newlinenonreentrant, and true is returned. If there are no exceptions,\newlinethe three node lists remain empty and false is returned.\newline \newline","6467987","hkl-pseudoaxis.c","const darray_string *hkl_engine_axis_names_get(const HklEngine *self,\newline					       HklEngineAxisNamesGet mode)\newline{\newline	switch(mode){\newline	case HKL_ENGINE_AXIS_NAMES_GET_READ:\newline		return &ampself-&gtmode-&gtinfo-&gtaxes_r;\newline	case HKL_ENGINE_AXIS_NAMES_GET_WRITE:\newline		return &ampself-&gtmode-&gtinfo-&gtaxes_w;\newline	default:\newline		return NULL;\newline	}\newline}\newline","\newline hkl_engine_axis_names_get:\newline @self: the this ptr\newline @mode:\newline \newline return a list of axes relevant when reading or writing on the\newline #HklEngine.\newline \newline exemple, for a K6C diffractometer in &quotlifting detector&quot mode, your\newline Engine control only 3 motors when writing, but the hkl values\newline depends on the 6 motors when reading.\newline \newline Returns: (type gpointer):\newline \newline","2072626","fstab.c","struct mntentchn *getmntoptfile(const char *file)\newline{\newline	struct mntentchn *mc;\newline	char *opts, *s;\newline	int l;\newline\newline	if (!file)\newline		return NULL;\newline\newline	l = strlen(file);\newline\newline	for (mc = mtab_head()-&gtnxt; mc; mc = mc-&gtnxt)\newline		if ((opts = mc-&gtmnt_opts) != NULL &amp&amp (s = strstr(opts, &quotloop=&quot))\newline		    &amp&amp !strncmp(s + 5, file, l)\newline		    &amp&amp (s == opts || s[-1] == &#039,&#039)\newline		    &amp&amp (s[l + 5] == 0 || s[l + 5] == &#039,&#039))\newline			return mc;\newline\newline	return NULL;\newline}\newline","Given the name FILE, try to find the option &quotloop=FILE&quot in mtab. \newline","4328021","gen_bpf.c","void gen_bpf_release(struct bpf_program *program)\newline{\newline	_program_free(program);\newline}\newline","\newline Free memory associated with a BPF representation\newline @param program the BPF representation\newline \newline Free the memory associated with a BPF representation generated by the\newline gen_bpf_generate() function.\newline \newline \newline","5974762","interpreter.cpp","static void vsConj(MKL_INT n, const float* x1, float* dest)\newline{\newline    MKL_INT j;\newline    for (j=0; j&ltn; j++) {\newline        dest[j] = x1[j];\newline    };\newline};\newline","Fake vsConj function just for casting purposes inside numexpr \newline","92119","ocateth.c","void free_ckbuf(uint16_t *buf)\newline{\newline   free(buf);\newline}\newline","! Free checksum buffer.\newline \newline","1236013","tmo_pattanaik00.cpp","void calculateLocalAdaptation(const pfstmo::Array2D* Y, int x, int y, float&amp Acone, float&amp Arod)\newline{\newline  int width = Y-&gtgetCols();\newline  int height = Y-&gtgetRows();\newline  \newline  int kernel_size = 4;\newline  static float LOG5 = log(5);\newline  float logLc = log((*Y)(x,y))/LOG5;\newline\newline  float pix_num = 0.0;\newline  float pix_sum = 0.0;\newline  for( int kx = -kernel_size ; kx &lt= kernel_size ; kx++ )\newline    for( int ky = -kernel_size ; ky &lt= kernel_size ; ky++ )\newline      if( (kx*kx+ky*ky)&lt=(kernel_size*kernel_size) &amp&amp\newline        x+kx&gt0 &amp&amp x+kx&ltwidth &amp&amp y+ky&gt0 &amp&amp y+ky&ltheight )\newline      {\newline	float L = (*Y)(x+kx,y+ky);\newline	float w = exp( -pow(fabs(log(L)/LOG5-logLc),6.0) );\newline	pix_sum +=  w*L;\newline	pix_num +=  w;\newline      }\newline\newline  if( pix_num&gt0.0 )\newline    Acone = Arod = (pix_sum / pix_num);\newline  else\newline    Acone = Arod = (*Y)(x,y);\newline}\newline","\newline @brief Calculate local adaptation for specified pixel coordinates\newline \newline Calculation based on article &quotAdaptive Gain Control&quot by Pattanaik\newline 2002.\newline \newline @param Y luminance map\newline @param x x-coordinate of pixel\newline @param y x-coordinate of pixel\newline @param Acone [out] calculated adaptation for cones\newline @param Arod [out] calculated adaptation for rods\newline \newline","4477247","dlg.c","static inline int get_route_set(struct sip_msg* _m, rr_t** _rs, unsigned char _order)\newline{\newline	struct hdr_field* ptr;\newline	rr_t* last, *p, *t;\newline\newline	last = 0;\newline	*_rs = 0;\newline\newline	ptr = _m-&gtrecord_route;\newline	while(ptr) {\newline		if (ptr-&gttype == HDR_RECORDROUTE_T) {\newline			if (parse_rr(ptr) &lt 0) {\newline				LM_ERR(&quotfailed to parse Record-Route body\\n&quot);\newline				goto error;\newline			}\newline\newline			p = (rr_t*)ptr-&gtparsed;\newline			while(p) {\newline				if (shm_duplicate_rr(&ampt, p, 1/*only first*/) &lt 0) {\newline					LM_ERR(&quotduplicating rr_t\\n&quot);\newline					goto error;\newline				}\newline				if (_order == NORMAL_ORDER) {\newline					if (!*_rs) *_rs = t;\newline					if (last) last-&gtnext = t;\newline					last = t;\newline				} else {\newline					t-&gtnext = *_rs;\newline					*_rs = t;\newline				}\newline\newline				p = p-&gtnext;\newline			}\newline\newline		}\newline		ptr = ptr-&gtnext;\newline	}\newline\newline	return 0;\newline\newline error:\newline        shm_free_rr(_rs);\newline	return -1;\newline}\newline","\newline Create a copy of route set either in normal or reverse order\newline \newline","","","","","","","","","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","Updates currently selected faces","slab pool management","Save-dialog started in user-configured default log","Connect edge with given node as a successor","Increment the reference count of the pbuf.","the exceptions are added to the appropriate set","return a list of axes relevant when reading or writing","try to find the option ""loop=FILE"" in mtab.","Free the memory associated with a BPF representation","just for casting purposes inside numexpr","Free checksum buffer.","True if two bitmasks do overlap","Calculate local adaptation for specified pixel coordinates","Create a copy of route set either in normal or reverse order","call where you want to start timing","seccomp filter collection and readies it for use.","Write a string in the file.","render to and setup the frame.","supports name string, and AVPs.","Waits the given time,","{}"
"39HYCOOPKOLYROCNPF1K33IH6GVMDI","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","31N2WW6R9RQWQ6F205WWKN8LYQX3F1","AVC62JNYAXA45","Approved","Wed Apr 17 14:17:39 PDT 2019","Wed Apr 17 14:49:09 PDT 2019","Fri Apr 19 14:49:09 PDT 2019","2019-04-19 21:49:21 UTC","","","1890","100% (24/24)","100% (24/24)","100% (24/24)","4517088","dec_lpc.c","void D_LPC_isf_2s5s_decode(Word16 *indice, Word16 *isf_q, Word16 *past_isfq,\newline                           Word16 *isfold, Word16 *isf_buf, Word16 bfi)\newline{\newline   Word32 ref_isf[M];\newline   Word32 i, j, L_tmp;\newline   Word16 tmp;\newline\newline   if(bfi == 0) /* Good frame */\newline   {\newline      for(i = 0; i &lt 9; i++)\newline      {\newline         isf_q[i] = D_ROM_dico1_isf[indice[0] * 9 + i];\newline      }\newline\newline      for(i = 0; i &lt 7; i++)\newline      {\newline         isf_q[i + 9] = D_ROM_dico2_isf[indice[1] * 7 + i];\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i] = (Word16)(isf_q[i] + D_ROM_dico21_isf[indice[2] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 3] =\newline            (Word16)(isf_q[i + 3] + D_ROM_dico22_isf[indice[3] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 6] =\newline            (Word16)(isf_q[i + 6] + D_ROM_dico23_isf[indice[4] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 9] =\newline            (Word16)(isf_q[i + 9] + D_ROM_dico24_isf[indice[5] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 4; i++)\newline      {\newline         isf_q[i + 12] =\newline            (Word16)(isf_q[i + 12] + D_ROM_dico25_isf[indice[6] * 4 + i]);\newline      }\newline\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         tmp = isf_q[i];\newline         isf_q[i] =\newline            (Word16)((tmp + D_ROM_mean_isf[i]) + ((MU * past_isfq[i]) &gt&gt 15));\newline         past_isfq[i] = tmp;\newline      }\newline\newline\newline      for(i = 0; i &lt M; i++)\newline      {\newline         for(j = (L_MEANBUF - 1); j &gt 0; j--)\newline         {\newline            isf_buf[j * M + i] = isf_buf[(j - 1) * M + i];\newline         }\newline         isf_buf[i] = isf_q[i];\newline      }\newline\newline   }\newline   else\newline   {   /* bad frame */\newline\newline      for(i = 0; i &lt M; i++)\newline      {\newline         L_tmp = D_ROM_mean_isf[i];\newline\newline         for(j = 0; j &lt L_MEANBUF; j++)\newline         {\newline            L_tmp = L_tmp + isf_buf[j * M + i];\newline         }\newline\newline         ref_isf[i] = (L_tmp + 0x1) &gt&gt 2;\newline      }\newline\newline      /* use the past ISFs slightly shifted towards their mean */\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         isf_q[i] = (Word16)(((ALPHA * isfold[i]) &gt&gt 15) +\newline            ((ONE_ALPHA * ref_isf[i]) &gt&gt 15));\newline      }\newline\newline      /* estimate past quantized residual to be used in next frame */\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         /* predicted ISF */\newline         L_tmp = ref_isf[i] + ((past_isfq[i] * MU) &gt&gt 15);\newline         /* past_isfq[i] *= 0.5 */\newline         past_isfq[i] = (Word16)((isf_q[i] - L_tmp) &gt&gt 1);\newline      }\newline   }\newline\newline   D_LPC_isf_reorder(isf_q, ISF_GAP, ORDER);\newline\newline   return;\newline}\newline","\newline D_LPC_isf_2s5s_decode\newline \newline Parameters:\newline indice I: quantization indices\newline isf_q O: quantized ISFs in the cosine domain\newline past_isfq I/O: past ISF quantizer\newline isfold I: past quantized ISF\newline isf_buf O: isf buffer\newline bfi I: Bad frame indicator\newline \newline Function:\newline Decoding of ISF parameters.\newline \newline Returns:\newline void\newline \newline","6164696","non-ascii.c","void Curl_convert_init(struct Curl_easy *data)\newline{\newline#if defined(CURL_DOES_CONVERSIONS) &amp&amp defined(HAVE_ICONV)\newline  /* conversion descriptors for iconv calls */\newline  data-&gtoutbound_cd = (iconv_t)-1;\newline  data-&gtinbound_cd  = (iconv_t)-1;\newline  data-&gtutf8_cd     = (iconv_t)-1;\newline#else\newline  (void)data;\newline#endif /* CURL_DOES_CONVERSIONS &amp&amp HAVE_ICONV */\newline}\newline","\newline Init conversion stuff for a Curl_easy\newline \newline","5693040","dlist.c","void dlist_delete(Dlist *list,int direction)\newline{\newline  if((list-&gtmarker != list-&gthead)&amp&amp(list-&gtmarker!=NULL)) \newline    {\newline      DL_node *corpse;\newline      corpse=list-&gtmarker;\newline      _dlist_mark_move(list,direction);\newline      if(list-&gthead-&gtnext==corpse)\newline	list-&gthead-&gtnext=corpse-&gtnext;\newline      if(list-&gthead-&gtprev==corpse)\newline	list-&gthead-&gtprev=corpse-&gtprev;\newline      if(corpse-&gtprev!=NULL) //should be impossible\newline	corpse-&gtprev-&gtnext=corpse-&gtnext;\newline      if(corpse-&gtnext!=NULL) //should be impossible\newline	corpse-&gtnext-&gtprev=corpse-&gtprev;\newline      list-&gtdel_func(corpse-&gtdata);\newline      list-&gtcount--;\newline      free(corpse);\newline    }\newline}\newline","\newline remove marker node from list\newline call data_delete function on data if registered.\newline otherwise call free.\newline when direction true it moves marker after \newline when direction false it moves marker before.\newline free marker node\newline return nothing.\newline \newline","689046","manage.c","static void remove_selected()\newline{\newline  GtkTreeSelection* search_selection = gtk_tree_view_get_selection((GtkTreeView*)treeview_search);\newline  gint selected_count = gtk_tree_selection_count_selected_rows(search_selection);\newline  if (selected_count &gt 0) {\newline    gint i;\newline    GtkListStore *store = GTK_LIST_STORE(gtk_tree_view_get_model((GtkTreeView*)treeview_search));\newline    GArray *sel = g_array_new(FALSE, FALSE, sizeof(GtkTreeIter));\newline    gtk_tree_selection_selected_foreach(search_selection, add_iter, sel);\newline    gtk_tree_selection_unselect_all(search_selection);\newline    for (i = 0; i &lt sel-&gtlen; i++) {\newline        gint remove_item;\newline        GtkTreeIter *iter = &ampg_array_index(sel, GtkTreeIter, i);\newline        gtk_tree_model_get((GtkTreeModel*)search_list, iter, 0, &ampremove_item, -1);\newline        history = g_list_remove(history, g_list_nth_data(history, remove_item-i));\newline        gtk_list_store_remove(store, iter);\newline    }\newline    g_array_free(sel, TRUE);\newline  }\newline}\newline","Called when Remove is selected from Manage dialog \newline","1241279","consensus.c","void quartsupport(int splitnum, cmatrix consbipartsvec, qsupportarr_t *qsupparr)\newline\newline{\newline	int  n;\newline	int *clusterA;\newline	int *clusterB;\newline	int  clustA = 0;\newline	int  clustB = 0;\newline\newline	int a1, a2, b1, b2;\newline	int aa1, aa2, bb1, bb2;\newline	uli  fullres_pro = 0;\newline	uli  fullres_con = 0;\newline	uli  partres_pro = 0;\newline	uli  partres_con = 0;\newline	uli  unres = 0;\newline	uli  missing = 0;\newline	uli  qsum = 0;\newline\newline	cvector splitstr;\newline	unsigned char tmpweight;\newline\newline	clusterA = calloc((size_t) Maxspc, (sizeof(int)));\newline	if (clusterA == NULL) maerror(&quotclusterA in quartsupport&quot);\newline	clusterB = calloc((size_t) Maxspc, (sizeof(int)));\newline	if (clusterA == NULL) maerror(&quotclusterB in quartsupport&quot);\newline\newline	splitstr = consbipartsvec[splitnum];\newline\newline	for(n=0; n&ltMaxspc; n++) {\newline		if (splitstr[n] == &#0390&#039) clusterA[clustA++] = n;\newline		else                    clusterB[clustB++] = n;\newline	}\newline\newline	if ((clustA &lt= 1) ||  (clustB &lt= 1)) {\newline		/* split in outer edge */\newline		fprintf(STDOUT, &quot\\n\\n\\nHALT: PLEASE REPORT ERROR HS1 TO DEVELOPERS\\n\\n\\n&quot);\newline#		if PARALLEL\newline			PP_Finalize();\newline#		endif\newline		exit(1);\newline	}\newline\newline	for (aa1 = 0; aa1 &lt clustA-1; aa1++)\newline	  for (aa2 = aa1+1; aa2 &lt clustA; aa2++)\newline	     for (bb1 = 0; bb1 &lt clustB-1; bb1++)\newline		for (bb2 = bb1+1; bb2 &lt clustB; bb2++) {\newline		   a1 = clusterA[aa1];\newline		   a2 = clusterA[aa2];\newline		   b1 = clusterB[bb1];\newline		   b2 = clusterB[bb2];\newline\newline		   if (a1 &lt b1) {\newline		      if (b1 &lt a2) {\newline		         if (a2 &lt b2) { /* a1&ltb1&lta2&ltb2 */\newline		             tmpweight = readquartet(a1, b1, a2, b2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_pro++; break;\newline				case 3: partres_pro++; break;\newline				case 4: fullres_con++; break;\newline				case 5: partres_con++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         } else { /* a1&ltb1&ltb2&lta2 */\newline		             tmpweight = readquartet(a1, b1, b2, a2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_con++; break;\newline				case 3: partres_con++; break;\newline				case 4: fullres_pro++; break;\newline				case 5: partres_pro++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         }\newline		      } else { /* a1&lta2&ltb1&ltb2 */\newline		          tmpweight = readquartet(a1, a2, b1, b2);\newline			  qsum++;\newline			  switch (tmpweight) {\newline			     case 1: fullres_pro++; break;\newline			     case 2: fullres_con++; break;\newline			     case 3: partres_pro++; break;\newline			     case 4: fullres_con++; break;\newline			     case 5: partres_pro++; break;\newline			     case 6: partres_con++; break;\newline			     case 7: unres++; break;\newline			     case 0: missing++; break;\newline		          }\newline		      }\newline		   } else {\newline		      if (a1 &lt b2) {\newline		         if (b2 &lt a2) { /* b1&lta1&ltb2&lta2 */\newline		             tmpweight = readquartet(b1, a1, b2, a2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_pro++; break;\newline				case 3: partres_pro++; break;\newline				case 4: fullres_con++; break;\newline				case 5: partres_con++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         } else { /* b1&lta1&lta2&ltb2 */\newline		             tmpweight = readquartet(b1, a1, a2, b2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_con++; break;\newline				case 3: partres_con++; break;\newline				case 4: fullres_pro++; break;\newline				case 5: partres_pro++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         }\newline		      } else { /* b1&ltb2&lta1&lta2 */\newline		          tmpweight = readquartet(b1, b2, a1, a2);\newline			  qsum++;\newline			  switch (tmpweight) {\newline			     case 1: fullres_pro++; break;\newline			     case 2: fullres_con++; break;\newline			     case 3: partres_pro++; break;\newline			     case 4: fullres_con++; break;\newline			     case 5: partres_pro++; break;\newline			     case 6: partres_con++; break;\newline			     case 7: unres++; break;\newline			     case 0: missing++; break;\newline		          }\newline		      }\newline		   }\newline	}\newline\newline	qsupparr[splitnum].fullres_pro = fullres_pro;\newline	qsupparr[splitnum].fullres_con = fullres_con;\newline	qsupparr[splitnum].partres_pro = partres_pro;\newline	qsupparr[splitnum].partres_con = partres_con;\newline	qsupparr[splitnum].unres= unres;\newline	qsupparr[splitnum].missing = missing;\newline	qsupparr[splitnum].qsum = qsum;\newline\newline	free(clusterA);\newline	free(clusterB);\newline} /* quartsupport */\newline","missing parameter: quartetinfo \newline","1523760","bgp_util.c","void write_neighbors_file(char *filename, int type)\newline{\newline  struct bgp_misc_structs *bms = bgp_select_misc_db(type);\newline  FILE *file;\newline  char neighbor[INET6_ADDRSTRLEN+1];\newline  int idx, len, ret;\newline  uid_t owner = -1;\newline  gid_t group = -1;\newline\newline  if (!bms) return;\newline\newline  unlink(filename);\newline\newline  if (config.files_uid) owner = config.files_uid; \newline  if (config.files_gid) group = config.files_gid; \newline\newline  file = fopen(filename,&quotw&quot);\newline  if (file) {\newline    if ((ret = chown(filename, owner, group)) == -1)\newline      Log(LOG_WARNING, &quotWARN ( %s/%s ): [%s] Unable to chown() (%s).\\n&quot, config.name, bms-&gtlog_str, filename, strerror(errno));\newline\newline    if (file_lock(fileno(file))) {\newline      Log(LOG_ERR, &quotERROR ( %s/%s ): [%s] Unable to obtain lock.\\n&quot, config.name, bms-&gtlog_str, filename);\newline      return;\newline    }\newline    for (idx = 0; idx &lt bms-&gtmax_peers; idx++) {\newline      if (peers[idx].fd) {\newline        if (peers[idx].addr.family == AF_INET) {\newline          inet_ntop(AF_INET, &amppeers[idx].addr.address.ipv4, neighbor, INET6_ADDRSTRLEN);\newline	  len = strlen(neighbor);\newline	  neighbor[len] = &#039\\n&#039; len++;\newline	  neighbor[len] = &#039\\0&#039;\newline          fwrite(neighbor, len, 1, file);\newline        }\newline#if defined ENABLE_IPV6\newline	else if (peers[idx].addr.family == AF_INET6) {\newline          inet_ntop(AF_INET6, &amppeers[idx].addr.address.ipv6, neighbor, INET6_ADDRSTRLEN);\newline          len = strlen(neighbor);\newline          neighbor[len] = &#039\\n&#039; len++;\newline          neighbor[len] = &#039\\0&#039;\newline          fwrite(neighbor, len, 1, file);\newline        }\newline#endif\newline      }\newline    }\newline\newline    file_unlock(fileno(file));\newline    fclose(file);\newline  }\newline  else {\newline    Log(LOG_ERR, &quotERROR ( %s/%s ): [%s] fopen() failed.\\n&quot, config.name, bms-&gtlog_str, filename);\newline    return;\newline  }\newline}\newline","XXX: currently only BGP is supported due to use of peers struct \newline","2659520","integration.c","void workshop_set_option_first(char *name, char *value)\newline{\newline	/* Currently value can only be on/off. This may change later (for\newline	 * example to set an option like &quotballoon evaluate delay&quot, but\newline	 * for now just convert it into a boolean */\newline	Boolean on = !strcmp(value, &quoton&quot);\newline\newline	if (!strcmp(name, &quotworkshopkeys&quot)) {\newline		workshop_hotkeys(on);\newline	} else if (!strcmp(name, &quotsavefiles&quot)) {\newline		save_files = on;\newline	} else if (!strcmp(name, &quotballoon&quot)) {\newline		workshop_balloon_mode(on);\newline	} else if (!strcmp(name, &quotballoondelay&quot)) {\newline		int delay = atoi(value);\newline		/* Should I validate the number here?? */\newline		workshop_balloon_delay(delay);\newline	} else {\newline		/* Let editor interpret it */\newline		workshop_set_option(name, value);\newline	}\newline}\newline","Set an editor option.\newline IGNORE an option if you do not recognize it.\newline \newline","5898741","kmo_priv_std_star-test.c","void test_kmo_interpolate_vector_wcs()\newline{\newline    kmo_test_verbose_off();\newline    // missing inputs\newline    cpl_test_null(kmo_interpolate_vector_wcs(NULL, NULL));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    cpl_frame *fr = cpl_frame_new();\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, NULL));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    // empty frame\newline    cpl_vector *x_out = cpl_vector_new(100);\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, x_out));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    // not overlapping\newline    char *my_path = cpl_sprintf(&quot%s/ref_data/kmos_atmos_k.fits&quot, getenv(&quotsrcdir&quot));\newline    cpl_frame_set_filename(fr, my_path);\newline    cpl_free(my_path);\newline    cpl_frame_set_tag(fr, &quotgaga_tag&quot);\newline    cpl_vector_fill(x_out, 0);\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, x_out));\newline    cpl_test_error(CPL_ERROR_ILLEGAL_INPUT);\newline\newline    kmo_test_verbose_on();\newline\newline    cpl_vector *solar_y = NULL;\newline    cpl_vector *solar_x = kmo_create_lambda_vec(2460, 1, 1.91, 0.000252033);\newline    cpl_test_nonnull(solar_y = kmo_interpolate_vector_wcs(fr, solar_x));\newline    cpl_test_error(CPL_ERROR_NONE);\newlinekmclipm_vector *ddd = kmclipm_vector_create(solar_y);\newline    cpl_test_abs(0.793042, kmclipm_vector_get_mean(ddd), 0.001);\newline\newline    cpl_frame_delete(fr);\newline    cpl_vector_delete(x_out);\newline    cpl_vector_delete(solar_x);\newline//    cpl_vector_delete(solar_y);\newlinekmclipm_vector_delete(ddd);\newline}\newline","\newline@brief Test for kmo_interpolate_vector_wcs()\newline \newline","336526","xmlstream.cpp","XmlStreamNamespaceDeclaration::XmlStreamNamespaceDeclaration()\newline{\newline}\newline","!\newlineCreates an empty namespace declaration.\newline \newline","1260408","tidylib.c","int TIDY_CALL        tidyStatus( TidyDoc tdoc )\newline{\newline    TidyDocImpl* impl = tidyDocToImpl( tdoc );\newline    int tidyStat = -EINVAL;\newline    if ( impl )\newline        tidyStat = tidyDocStatus( impl );\newline    return tidyStat;\newline}\newline","Document info \newline","2945299","wcs.c","static void rot_vect(double *x, double *y, double a)\newline{\newline	double nx, ny;\newline\newline	a *= PI / 180.0;\newline	nx = *x * cos(a) - *y * sin(a);\newline	ny = *x * sin(a) + *y * cos(a);\newline	*x = nx; *y = ny;\newline}\newline","in-place rotation about origin (angle in degrees) \newline","3188945","ne_dates.c","time_t ne_rfc1036_parse(const char *date) \newline{\newline    struct tm gmt = {0};\newline    int n;\newline    char wkday[11], mon[4];\newline    /* RFC850/1036 style dates: Sunday, 06-Nov-94 08:49:37 GMT */\newline    n = sscanf(date, RFC1036_FORMAT,\newline		wkday, &ampgmt.tm_mday, mon, &ampgmt.tm_year,\newline		&ampgmt.tm_hour, &ampgmt.tm_min, &ampgmt.tm_sec);\newline    if (n != 7) {\newline	return (time_t)-1;\newline    }\newline\newline    /* portable to check n here? */\newline    for (n=0; n&lt12; n++)\newline	if (strcmp(mon, short_months[n]) == 0)\newline	    break;\newline    /* tm_mon comes out as 12 if the month is corrupt, which is desired,\newline     * since the mktime will then fail */\newline\newline    /* Defeat Y2K bug. */\newline    if (gmt.tm_year &lt 50)\newline	gmt.tm_year += 100;\newline\newline    gmt.tm_mon = n;\newline    gmt.tm_isdst = -1;\newline    return mktime(&ampgmt) + GMTOFF(gmt);\newline}\newline","Takes a string containing a RFC1036-style date and returns the time_t \newline","672290","qtcolortriangle.cpp","static void swap(Vertex **a, Vertex **b)\newline{\newline    Vertex *tmp = *a;\newline    *a = *b;\newline    *b = tmp;\newline}\newline","! \\internal\newlineSwaps the Vertex at a with the one at b.\newline \newline","5102522","tour1d_pp.c","void t1d_ppdraw_think(displayd *dsp, ggobid *gg)\newline{\newline  splotd *sp = (splotd *) g_list_nth_data (dsp-&gtsplots, 0);\newline  colorschemed *scheme = gg-&gtactiveColorScheme;\newline  gint wid = dsp-&gtt1d_ppda-&gtallocation.width, \newline    hgt = dsp-&gtt1d_ppda-&gtallocation.height;\newline  PangoLayout *layout = gtk_widget_create_pango_layout(sp-&gtda, &quotThinking...&quot);\newline  \newline  gdk_gc_set_foreground (gg-&gtplot_GC, &ampscheme-&gtrgb_accent);\newline  gdk_draw_layout(dsp-&gtt1d_pp_pixmap, gg-&gtplot_GC, 10, 10, layout);\newline  g_object_unref(G_OBJECT(layout));\newline  /*gdk_text_extents (\newline    gtk_style_get_font (style),\newline    varlab, strlen (varlab),\newline    &amplbearing, &amprbearing, &ampwidth, &ampascent, &ampdescent);\newline    gdk_draw_string (dsp-&gtt1d_pp_pixmap,\newline    gtk_style_get_font (style),\newline      gg-&gtplot_GC, 10, 10, varlab);*/\newline  gdk_draw_pixmap (dsp-&gtt1d_ppda-&gtwindow, gg-&gtplot_GC, dsp-&gtt1d_pp_pixmap,\newline    0, 0, 0, 0, wid, hgt);\newline}\newline","This is writes text to the pp window to in form the\newlineuser that optimize is finding a new maximum \newline","2681016","qambientlightsensor.cpp","void QAmbientLightReading::setLightLevel(QAmbientLightReading::LightLevel lightLevel)\newline{\newline    switch (lightLevel) {\newline    case Dark:\newline    case Twilight:\newline    case Light:\newline    case Bright:\newline    case Sunny:\newline        d-&gtlightLevel = lightLevel;\newline        break;\newline    default:\newline        d-&gtlightLevel = Undefined;\newline        break;\newline    }\newline}\newline","!\newlineSets the ambient light level to \\a lightLevel.\newline \newline","261031","dockapp.c","void wmdock_dockapp_event_after_handler(GtkWidget *window, GdkEvent *ev, DockappNode *dapp)\newline{\newline//	if( ! IS_PANELOFF(wmdock) )\newline//		return;\newline\newline	debug(&quotdockapp.c: Window event-after: %d. (dapp: `%s&#039), dappOnMove: %s&quot, ev-&gttype, dapp-&gtname, dappOnMotion ? &quotYes&quot: &quotNo&quot);\newline\newline	switch(ev-&gttype) {\newline	case GDK_FOCUS_CHANGE:\newline		if(ev-&gtfocus_change.in == TRUE) {\newline			/* `in&#039 is true if window window got the focus. */\newline			g_list_foreach(wmdock-&gtdapps, (GFunc) wmdock_dockapp_tofront, NULL);\newline		}\newline		break;\newline	case GDK_VISIBILITY_NOTIFY:\newline		wmdock_redraw_dockapp(dapp);\newline		break;\newline	default:\newline		break;\newline	}\newline}\newline","\newline Event handler for the tile in panel off mode (event_after).\newline \newline @param tile The window of the event.\newline @param ev Event informations.\newline @param dapp DockappNode of the event.\newline \newline","1517584","lj_debug.c","BCLine LJ_FASTCALL lj_debug_line(GCproto *pt, BCPos pc)\newline{\newline  const void *lineinfo = proto_lineinfo(pt);\newline  if (pc &lt= pt-&gtsizebc &amp&amp lineinfo) {\newline    BCLine first = pt-&gtfirstline;\newline    if (pc == pt-&gtsizebc) return first + pt-&gtnumline;\newline    if (pc-- == 0) return first;\newline    if (pt-&gtnumline &lt 256)\newline      return first + (BCLine)((const uint8_t *)lineinfo)[pc];\newline    else if (pt-&gtnumline &lt 65536)\newline      return first + (BCLine)((const uint16_t *)lineinfo)[pc];\newline    else\newline      return first + (BCLine)((const uint32_t *)lineinfo)[pc];\newline  }\newline  return 0;\newline}\newline","Get line number for a bytecode position. \newline","5833319","solution.c","static int opensolutionfile(fileinfo *file, char const *datname, int mode)\newline{\newline    static int	savedirchecked = FALSE;\newline    char       *buf = NULL;\newline    char const *filename;\newline    int		n;\newline\newline    if (mode != F_READ &amp&amp readonly)\newline	return FALSE;\newline\newline    if (file-&gtname) {\newline	filename = file-&gtname;\newline    } else {\newline	n = strlen(datname);\newline	if (datname[n - 4] == &#039.&#039 &amp&amp tolower(datname[n - 3]) == &#039d&#039\newline				  &amp&amp tolower(datname[n - 2]) == &#039a&#039\newline				  &amp&amp tolower(datname[n - 1]) == &#039t&#039)\newline	    n -= 4;\newline	xalloc(buf, n + 5);\newline	memcpy(buf, datname, n);\newline	memcpy(buf + n, &quot.tws&quot, 5);\newline	filename = buf;\newline    }\newline\newline    if (mode != F_WRITE) {\newline	if (!savedirchecked &amp&amp savedir &amp&amp *savedir &amp&amp !haspathname(filename)) {\newline	    savedirchecked = TRUE;\newline	    if (!finddir(savedir)) {\newline		setsavedir(&quot&quot);\newline		fileerr(file, &quotcan&#039t access directory&quot);\newline	    }\newline	}\newline    }\newline\newline    n = openfileindir(file, savedir, filename,\newline		      mode == F_WRITE ? &quotwb&quot : mode == F_MODIFY ? &quotr+b&quot : &quotrb&quot,\newline		      mode == F_WRITE ? &quotcan&#039t access file&quot : NULL);\newline    if (buf)\newline	free(buf);\newline    return n;\newline}\newline","Locate the solution file for the given data file and open it.\newline \newline","2136734","tests.c","double f_monomial(double x, void * params)\newline{\newline  struct monomial_params * p = (struct monomial_params *) params;\newline\newline  return p-&gtconstant * gsl_pow_int(x, p-&gtdegree);\newline}\newline","f_monomial = constant x^degree \newline","1255552","image.c","errcode_t ocfs2_image_load_bitmap(ocfs2_filesys *ofs)\newline{\newline	struct ocfs2_image_state *ost;\newline	struct ocfs2_image_hdr *hdr;\newline	uint64_t blk_off, bits_set;\newline	int i, j, fd;\newline	ssize_t count;\newline	errcode_t ret;\newline	char *blk;\newline\newline	ret = ocfs2_malloc0(sizeof(struct ocfs2_image_state), &ampofs-&gtost);\newline	if (ret)\newline		return ret;\newline\newline	ost = ofs-&gtost;\newline	ret = ocfs2_malloc_block(ofs-&gtfs_io, &ampblk);\newline	if (ret)\newline		return ret;\newline\newline	/* read ocfs2 image header */\newline	ret = io_read_block(ofs-&gtfs_io, 0, 1, blk);\newline	if (ret)\newline		goto out;\newline\newline	hdr = (struct ocfs2_image_hdr *)blk;\newline	ocfs2_image_swap_header(hdr);\newline\newline	ret = OCFS2_ET_BAD_MAGIC;\newline	if (hdr-&gthdr_magic != OCFS2_IMAGE_MAGIC)\newline		goto out;\newline\newline	if (memcmp(hdr-&gthdr_magic_desc, OCFS2_IMAGE_DESC,\newline		   sizeof(OCFS2_IMAGE_DESC)))\newline		goto out;\newline\newline	ret = OCFS2_ET_OCFS_REV;\newline	if (hdr-&gthdr_version &gt OCFS2_IMAGE_VERSION)\newline		goto out;\newline\newline	ost-&gtost_fsblkcnt 	= hdr-&gthdr_fsblkcnt;\newline	ost-&gtost_fsblksz 	= hdr-&gthdr_fsblksz;\newline	ost-&gtost_imgblkcnt 	= hdr-&gthdr_imgblkcnt;\newline	ost-&gtost_bmpblksz 	= hdr-&gthdr_bmpblksz;\newline\newline	ret = ocfs2_image_alloc_bitmap(ofs);\newline	if (ret)\newline		return ret;\newline\newline	/* load bitmap blocks ocfs2 image state */\newline	bits_set = 0;\newline	fd 	= io_get_fd(ofs-&gtfs_io);\newline	blk_off = (ost-&gtost_imgblkcnt + 1) * ost-&gtost_fsblksz;\newline\newline	for (i = 0; i &lt ost-&gtost_bmpblks; i++) {\newline		ost-&gtost_bmparr[i].arr_set_bit_cnt = bits_set;\newline		/*\newline		 * we don&#039t use io_read_block as ocfs2 image bitmap block size\newline		 * could be different from filesystem block size\newline		 */\newline		count = pread64(fd, ost-&gtost_bmparr[i].arr_map,\newline				ost-&gtost_bmpblksz, blk_off);\newline		if (count &lt 0) {\newline			ret = OCFS2_ET_IO;\newline			goto out;\newline		}\newline\newline		/* add bits set in this bitmap */\newline		for (j = 0; j &lt (ost-&gtost_bmpblksz * 8); j++)\newline			if (ocfs2_test_bit(j, ost-&gtost_bmparr[i].arr_map))\newline				bits_set++;\newline\newline		blk_off += ost-&gtost_bmpblksz;\newline	}\newline\newlineout:\newline	if (blk)\newline		ocfs2_free(&ampblk);\newline	return ret;\newline}\newline","\newline This routine loads bitmap blocks from an o2image image file into memory.\newline This process happens during file open. bitmap blocks reside towards\newline the end of the imagefile.\newline \newline","6397198","qlgc_vnic_dyn_update_daemon.c","void compare_results()\newline{\newline	struct ibvexdm_output *conn;\newline	struct hca_port_list  *port;\newline\newline	for (conn = ibvexdm_op; conn != NULL; conn = conn-&gtnext) {\newline		if (conn-&gtport_list != NULL) {\newline			for (port = conn-&gtport_list; port != NULL; port = port-&gtnext)\newline				scan_vnic_interfaces(conn, port);\newline		}\newline	}\newline}\newline","\newline Function : compare_results.\newline \newline Description : compares the output of ibvexdm with the information about the vnic interfaces\newline on given host to check if there is possibility of any connection re-establishment.\newline \newline","","on","on","","","","","","","","on","on","","","","on","on","on","","on","","","","","","","","","","","","","","","","","","","","","","","Decoding of ISF parameters.","{}","{}","Takes a string containing a RFC1036-style date and returns the time_t","Swaps the Vertex at a with the one at b.","writes text to the pp window","Sets the ambient light level to \a lightLevel.","Event handler for the tile in panel off mode","Get line number for a bytecode position.","Locate the solution file for the given data file and open it.","{}","{}","loads bitmap blocks from an o2image image file into memory.","compares the output of ibvexdm with the information about the vnic interfaces","remove marker node from list","{}","{}","{}","Set an editor option.","{}","Creates an empty namespace declaration."
"39HYCOOPKOLYROCNPF1K33IH6GVMDI","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3C44YUNSI1P6ZB6T7XYD9Q81R9BDPE","A17QHU5Q0FS3GW","Approved","Wed Apr 17 14:25:06 PDT 2019","Wed Apr 17 15:11:12 PDT 2019","Fri Apr 19 15:11:12 PDT 2019","2019-04-19 22:11:21 UTC","","","2766","100% (2/2)","100% (2/2)","100% (2/2)","4517088","dec_lpc.c","void D_LPC_isf_2s5s_decode(Word16 *indice, Word16 *isf_q, Word16 *past_isfq,\newline                           Word16 *isfold, Word16 *isf_buf, Word16 bfi)\newline{\newline   Word32 ref_isf[M];\newline   Word32 i, j, L_tmp;\newline   Word16 tmp;\newline\newline   if(bfi == 0) /* Good frame */\newline   {\newline      for(i = 0; i &lt 9; i++)\newline      {\newline         isf_q[i] = D_ROM_dico1_isf[indice[0] * 9 + i];\newline      }\newline\newline      for(i = 0; i &lt 7; i++)\newline      {\newline         isf_q[i + 9] = D_ROM_dico2_isf[indice[1] * 7 + i];\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i] = (Word16)(isf_q[i] + D_ROM_dico21_isf[indice[2] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 3] =\newline            (Word16)(isf_q[i + 3] + D_ROM_dico22_isf[indice[3] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 6] =\newline            (Word16)(isf_q[i + 6] + D_ROM_dico23_isf[indice[4] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 3; i++)\newline      {\newline         isf_q[i + 9] =\newline            (Word16)(isf_q[i + 9] + D_ROM_dico24_isf[indice[5] * 3 + i]);\newline      }\newline\newline      for(i = 0; i &lt 4; i++)\newline      {\newline         isf_q[i + 12] =\newline            (Word16)(isf_q[i + 12] + D_ROM_dico25_isf[indice[6] * 4 + i]);\newline      }\newline\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         tmp = isf_q[i];\newline         isf_q[i] =\newline            (Word16)((tmp + D_ROM_mean_isf[i]) + ((MU * past_isfq[i]) &gt&gt 15));\newline         past_isfq[i] = tmp;\newline      }\newline\newline\newline      for(i = 0; i &lt M; i++)\newline      {\newline         for(j = (L_MEANBUF - 1); j &gt 0; j--)\newline         {\newline            isf_buf[j * M + i] = isf_buf[(j - 1) * M + i];\newline         }\newline         isf_buf[i] = isf_q[i];\newline      }\newline\newline   }\newline   else\newline   {   /* bad frame */\newline\newline      for(i = 0; i &lt M; i++)\newline      {\newline         L_tmp = D_ROM_mean_isf[i];\newline\newline         for(j = 0; j &lt L_MEANBUF; j++)\newline         {\newline            L_tmp = L_tmp + isf_buf[j * M + i];\newline         }\newline\newline         ref_isf[i] = (L_tmp + 0x1) &gt&gt 2;\newline      }\newline\newline      /* use the past ISFs slightly shifted towards their mean */\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         isf_q[i] = (Word16)(((ALPHA * isfold[i]) &gt&gt 15) +\newline            ((ONE_ALPHA * ref_isf[i]) &gt&gt 15));\newline      }\newline\newline      /* estimate past quantized residual to be used in next frame */\newline      for(i = 0; i &lt ORDER; i++)\newline      {\newline         /* predicted ISF */\newline         L_tmp = ref_isf[i] + ((past_isfq[i] * MU) &gt&gt 15);\newline         /* past_isfq[i] *= 0.5 */\newline         past_isfq[i] = (Word16)((isf_q[i] - L_tmp) &gt&gt 1);\newline      }\newline   }\newline\newline   D_LPC_isf_reorder(isf_q, ISF_GAP, ORDER);\newline\newline   return;\newline}\newline","\newline D_LPC_isf_2s5s_decode\newline \newline Parameters:\newline indice I: quantization indices\newline isf_q O: quantized ISFs in the cosine domain\newline past_isfq I/O: past ISF quantizer\newline isfold I: past quantized ISF\newline isf_buf O: isf buffer\newline bfi I: Bad frame indicator\newline \newline Function:\newline Decoding of ISF parameters.\newline \newline Returns:\newline void\newline \newline","6164696","non-ascii.c","void Curl_convert_init(struct Curl_easy *data)\newline{\newline#if defined(CURL_DOES_CONVERSIONS) &amp&amp defined(HAVE_ICONV)\newline  /* conversion descriptors for iconv calls */\newline  data-&gtoutbound_cd = (iconv_t)-1;\newline  data-&gtinbound_cd  = (iconv_t)-1;\newline  data-&gtutf8_cd     = (iconv_t)-1;\newline#else\newline  (void)data;\newline#endif /* CURL_DOES_CONVERSIONS &amp&amp HAVE_ICONV */\newline}\newline","\newline Init conversion stuff for a Curl_easy\newline \newline","5693040","dlist.c","void dlist_delete(Dlist *list,int direction)\newline{\newline  if((list-&gtmarker != list-&gthead)&amp&amp(list-&gtmarker!=NULL)) \newline    {\newline      DL_node *corpse;\newline      corpse=list-&gtmarker;\newline      _dlist_mark_move(list,direction);\newline      if(list-&gthead-&gtnext==corpse)\newline	list-&gthead-&gtnext=corpse-&gtnext;\newline      if(list-&gthead-&gtprev==corpse)\newline	list-&gthead-&gtprev=corpse-&gtprev;\newline      if(corpse-&gtprev!=NULL) //should be impossible\newline	corpse-&gtprev-&gtnext=corpse-&gtnext;\newline      if(corpse-&gtnext!=NULL) //should be impossible\newline	corpse-&gtnext-&gtprev=corpse-&gtprev;\newline      list-&gtdel_func(corpse-&gtdata);\newline      list-&gtcount--;\newline      free(corpse);\newline    }\newline}\newline","\newline remove marker node from list\newline call data_delete function on data if registered.\newline otherwise call free.\newline when direction true it moves marker after \newline when direction false it moves marker before.\newline free marker node\newline return nothing.\newline \newline","689046","manage.c","static void remove_selected()\newline{\newline  GtkTreeSelection* search_selection = gtk_tree_view_get_selection((GtkTreeView*)treeview_search);\newline  gint selected_count = gtk_tree_selection_count_selected_rows(search_selection);\newline  if (selected_count &gt 0) {\newline    gint i;\newline    GtkListStore *store = GTK_LIST_STORE(gtk_tree_view_get_model((GtkTreeView*)treeview_search));\newline    GArray *sel = g_array_new(FALSE, FALSE, sizeof(GtkTreeIter));\newline    gtk_tree_selection_selected_foreach(search_selection, add_iter, sel);\newline    gtk_tree_selection_unselect_all(search_selection);\newline    for (i = 0; i &lt sel-&gtlen; i++) {\newline        gint remove_item;\newline        GtkTreeIter *iter = &ampg_array_index(sel, GtkTreeIter, i);\newline        gtk_tree_model_get((GtkTreeModel*)search_list, iter, 0, &ampremove_item, -1);\newline        history = g_list_remove(history, g_list_nth_data(history, remove_item-i));\newline        gtk_list_store_remove(store, iter);\newline    }\newline    g_array_free(sel, TRUE);\newline  }\newline}\newline","Called when Remove is selected from Manage dialog \newline","1241279","consensus.c","void quartsupport(int splitnum, cmatrix consbipartsvec, qsupportarr_t *qsupparr)\newline\newline{\newline	int  n;\newline	int *clusterA;\newline	int *clusterB;\newline	int  clustA = 0;\newline	int  clustB = 0;\newline\newline	int a1, a2, b1, b2;\newline	int aa1, aa2, bb1, bb2;\newline	uli  fullres_pro = 0;\newline	uli  fullres_con = 0;\newline	uli  partres_pro = 0;\newline	uli  partres_con = 0;\newline	uli  unres = 0;\newline	uli  missing = 0;\newline	uli  qsum = 0;\newline\newline	cvector splitstr;\newline	unsigned char tmpweight;\newline\newline	clusterA = calloc((size_t) Maxspc, (sizeof(int)));\newline	if (clusterA == NULL) maerror(&quotclusterA in quartsupport&quot);\newline	clusterB = calloc((size_t) Maxspc, (sizeof(int)));\newline	if (clusterA == NULL) maerror(&quotclusterB in quartsupport&quot);\newline\newline	splitstr = consbipartsvec[splitnum];\newline\newline	for(n=0; n&ltMaxspc; n++) {\newline		if (splitstr[n] == &#0390&#039) clusterA[clustA++] = n;\newline		else                    clusterB[clustB++] = n;\newline	}\newline\newline	if ((clustA &lt= 1) ||  (clustB &lt= 1)) {\newline		/* split in outer edge */\newline		fprintf(STDOUT, &quot\\n\\n\\nHALT: PLEASE REPORT ERROR HS1 TO DEVELOPERS\\n\\n\\n&quot);\newline#		if PARALLEL\newline			PP_Finalize();\newline#		endif\newline		exit(1);\newline	}\newline\newline	for (aa1 = 0; aa1 &lt clustA-1; aa1++)\newline	  for (aa2 = aa1+1; aa2 &lt clustA; aa2++)\newline	     for (bb1 = 0; bb1 &lt clustB-1; bb1++)\newline		for (bb2 = bb1+1; bb2 &lt clustB; bb2++) {\newline		   a1 = clusterA[aa1];\newline		   a2 = clusterA[aa2];\newline		   b1 = clusterB[bb1];\newline		   b2 = clusterB[bb2];\newline\newline		   if (a1 &lt b1) {\newline		      if (b1 &lt a2) {\newline		         if (a2 &lt b2) { /* a1&ltb1&lta2&ltb2 */\newline		             tmpweight = readquartet(a1, b1, a2, b2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_pro++; break;\newline				case 3: partres_pro++; break;\newline				case 4: fullres_con++; break;\newline				case 5: partres_con++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         } else { /* a1&ltb1&ltb2&lta2 */\newline		             tmpweight = readquartet(a1, b1, b2, a2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_con++; break;\newline				case 3: partres_con++; break;\newline				case 4: fullres_pro++; break;\newline				case 5: partres_pro++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         }\newline		      } else { /* a1&lta2&ltb1&ltb2 */\newline		          tmpweight = readquartet(a1, a2, b1, b2);\newline			  qsum++;\newline			  switch (tmpweight) {\newline			     case 1: fullres_pro++; break;\newline			     case 2: fullres_con++; break;\newline			     case 3: partres_pro++; break;\newline			     case 4: fullres_con++; break;\newline			     case 5: partres_pro++; break;\newline			     case 6: partres_con++; break;\newline			     case 7: unres++; break;\newline			     case 0: missing++; break;\newline		          }\newline		      }\newline		   } else {\newline		      if (a1 &lt b2) {\newline		         if (b2 &lt a2) { /* b1&lta1&ltb2&lta2 */\newline		             tmpweight = readquartet(b1, a1, b2, a2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_pro++; break;\newline				case 3: partres_pro++; break;\newline				case 4: fullres_con++; break;\newline				case 5: partres_con++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         } else { /* b1&lta1&lta2&ltb2 */\newline		             tmpweight = readquartet(b1, a1, a2, b2);\newline			     qsum++;\newline			     switch (tmpweight) {\newline				case 1: fullres_con++; break;\newline				case 2: fullres_con++; break;\newline				case 3: partres_con++; break;\newline				case 4: fullres_pro++; break;\newline				case 5: partres_pro++; break;\newline				case 6: partres_pro++; break;\newline				case 7: unres++; break;\newline				case 0: missing++; break;\newline			     }\newline		         }\newline		      } else { /* b1&ltb2&lta1&lta2 */\newline		          tmpweight = readquartet(b1, b2, a1, a2);\newline			  qsum++;\newline			  switch (tmpweight) {\newline			     case 1: fullres_pro++; break;\newline			     case 2: fullres_con++; break;\newline			     case 3: partres_pro++; break;\newline			     case 4: fullres_con++; break;\newline			     case 5: partres_pro++; break;\newline			     case 6: partres_con++; break;\newline			     case 7: unres++; break;\newline			     case 0: missing++; break;\newline		          }\newline		      }\newline		   }\newline	}\newline\newline	qsupparr[splitnum].fullres_pro = fullres_pro;\newline	qsupparr[splitnum].fullres_con = fullres_con;\newline	qsupparr[splitnum].partres_pro = partres_pro;\newline	qsupparr[splitnum].partres_con = partres_con;\newline	qsupparr[splitnum].unres= unres;\newline	qsupparr[splitnum].missing = missing;\newline	qsupparr[splitnum].qsum = qsum;\newline\newline	free(clusterA);\newline	free(clusterB);\newline} /* quartsupport */\newline","missing parameter: quartetinfo \newline","1523760","bgp_util.c","void write_neighbors_file(char *filename, int type)\newline{\newline  struct bgp_misc_structs *bms = bgp_select_misc_db(type);\newline  FILE *file;\newline  char neighbor[INET6_ADDRSTRLEN+1];\newline  int idx, len, ret;\newline  uid_t owner = -1;\newline  gid_t group = -1;\newline\newline  if (!bms) return;\newline\newline  unlink(filename);\newline\newline  if (config.files_uid) owner = config.files_uid; \newline  if (config.files_gid) group = config.files_gid; \newline\newline  file = fopen(filename,&quotw&quot);\newline  if (file) {\newline    if ((ret = chown(filename, owner, group)) == -1)\newline      Log(LOG_WARNING, &quotWARN ( %s/%s ): [%s] Unable to chown() (%s).\\n&quot, config.name, bms-&gtlog_str, filename, strerror(errno));\newline\newline    if (file_lock(fileno(file))) {\newline      Log(LOG_ERR, &quotERROR ( %s/%s ): [%s] Unable to obtain lock.\\n&quot, config.name, bms-&gtlog_str, filename);\newline      return;\newline    }\newline    for (idx = 0; idx &lt bms-&gtmax_peers; idx++) {\newline      if (peers[idx].fd) {\newline        if (peers[idx].addr.family == AF_INET) {\newline          inet_ntop(AF_INET, &amppeers[idx].addr.address.ipv4, neighbor, INET6_ADDRSTRLEN);\newline	  len = strlen(neighbor);\newline	  neighbor[len] = &#039\\n&#039; len++;\newline	  neighbor[len] = &#039\\0&#039;\newline          fwrite(neighbor, len, 1, file);\newline        }\newline#if defined ENABLE_IPV6\newline	else if (peers[idx].addr.family == AF_INET6) {\newline          inet_ntop(AF_INET6, &amppeers[idx].addr.address.ipv6, neighbor, INET6_ADDRSTRLEN);\newline          len = strlen(neighbor);\newline          neighbor[len] = &#039\\n&#039; len++;\newline          neighbor[len] = &#039\\0&#039;\newline          fwrite(neighbor, len, 1, file);\newline        }\newline#endif\newline      }\newline    }\newline\newline    file_unlock(fileno(file));\newline    fclose(file);\newline  }\newline  else {\newline    Log(LOG_ERR, &quotERROR ( %s/%s ): [%s] fopen() failed.\\n&quot, config.name, bms-&gtlog_str, filename);\newline    return;\newline  }\newline}\newline","XXX: currently only BGP is supported due to use of peers struct \newline","2659520","integration.c","void workshop_set_option_first(char *name, char *value)\newline{\newline	/* Currently value can only be on/off. This may change later (for\newline	 * example to set an option like &quotballoon evaluate delay&quot, but\newline	 * for now just convert it into a boolean */\newline	Boolean on = !strcmp(value, &quoton&quot);\newline\newline	if (!strcmp(name, &quotworkshopkeys&quot)) {\newline		workshop_hotkeys(on);\newline	} else if (!strcmp(name, &quotsavefiles&quot)) {\newline		save_files = on;\newline	} else if (!strcmp(name, &quotballoon&quot)) {\newline		workshop_balloon_mode(on);\newline	} else if (!strcmp(name, &quotballoondelay&quot)) {\newline		int delay = atoi(value);\newline		/* Should I validate the number here?? */\newline		workshop_balloon_delay(delay);\newline	} else {\newline		/* Let editor interpret it */\newline		workshop_set_option(name, value);\newline	}\newline}\newline","Set an editor option.\newline IGNORE an option if you do not recognize it.\newline \newline","5898741","kmo_priv_std_star-test.c","void test_kmo_interpolate_vector_wcs()\newline{\newline    kmo_test_verbose_off();\newline    // missing inputs\newline    cpl_test_null(kmo_interpolate_vector_wcs(NULL, NULL));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    cpl_frame *fr = cpl_frame_new();\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, NULL));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    // empty frame\newline    cpl_vector *x_out = cpl_vector_new(100);\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, x_out));\newline    cpl_test_error(CPL_ERROR_NULL_INPUT);\newline\newline    // not overlapping\newline    char *my_path = cpl_sprintf(&quot%s/ref_data/kmos_atmos_k.fits&quot, getenv(&quotsrcdir&quot));\newline    cpl_frame_set_filename(fr, my_path);\newline    cpl_free(my_path);\newline    cpl_frame_set_tag(fr, &quotgaga_tag&quot);\newline    cpl_vector_fill(x_out, 0);\newline    cpl_test_null(kmo_interpolate_vector_wcs(fr, x_out));\newline    cpl_test_error(CPL_ERROR_ILLEGAL_INPUT);\newline\newline    kmo_test_verbose_on();\newline\newline    cpl_vector *solar_y = NULL;\newline    cpl_vector *solar_x = kmo_create_lambda_vec(2460, 1, 1.91, 0.000252033);\newline    cpl_test_nonnull(solar_y = kmo_interpolate_vector_wcs(fr, solar_x));\newline    cpl_test_error(CPL_ERROR_NONE);\newlinekmclipm_vector *ddd = kmclipm_vector_create(solar_y);\newline    cpl_test_abs(0.793042, kmclipm_vector_get_mean(ddd), 0.001);\newline\newline    cpl_frame_delete(fr);\newline    cpl_vector_delete(x_out);\newline    cpl_vector_delete(solar_x);\newline//    cpl_vector_delete(solar_y);\newlinekmclipm_vector_delete(ddd);\newline}\newline","\newline@brief Test for kmo_interpolate_vector_wcs()\newline \newline","336526","xmlstream.cpp","XmlStreamNamespaceDeclaration::XmlStreamNamespaceDeclaration()\newline{\newline}\newline","!\newlineCreates an empty namespace declaration.\newline \newline","1260408","tidylib.c","int TIDY_CALL        tidyStatus( TidyDoc tdoc )\newline{\newline    TidyDocImpl* impl = tidyDocToImpl( tdoc );\newline    int tidyStat = -EINVAL;\newline    if ( impl )\newline        tidyStat = tidyDocStatus( impl );\newline    return tidyStat;\newline}\newline","Document info \newline","2945299","wcs.c","static void rot_vect(double *x, double *y, double a)\newline{\newline	double nx, ny;\newline\newline	a *= PI / 180.0;\newline	nx = *x * cos(a) - *y * sin(a);\newline	ny = *x * sin(a) + *y * cos(a);\newline	*x = nx; *y = ny;\newline}\newline","in-place rotation about origin (angle in degrees) \newline","3188945","ne_dates.c","time_t ne_rfc1036_parse(const char *date) \newline{\newline    struct tm gmt = {0};\newline    int n;\newline    char wkday[11], mon[4];\newline    /* RFC850/1036 style dates: Sunday, 06-Nov-94 08:49:37 GMT */\newline    n = sscanf(date, RFC1036_FORMAT,\newline		wkday, &ampgmt.tm_mday, mon, &ampgmt.tm_year,\newline		&ampgmt.tm_hour, &ampgmt.tm_min, &ampgmt.tm_sec);\newline    if (n != 7) {\newline	return (time_t)-1;\newline    }\newline\newline    /* portable to check n here? */\newline    for (n=0; n&lt12; n++)\newline	if (strcmp(mon, short_months[n]) == 0)\newline	    break;\newline    /* tm_mon comes out as 12 if the month is corrupt, which is desired,\newline     * since the mktime will then fail */\newline\newline    /* Defeat Y2K bug. */\newline    if (gmt.tm_year &lt 50)\newline	gmt.tm_year += 100;\newline\newline    gmt.tm_mon = n;\newline    gmt.tm_isdst = -1;\newline    return mktime(&ampgmt) + GMTOFF(gmt);\newline}\newline","Takes a string containing a RFC1036-style date and returns the time_t \newline","672290","qtcolortriangle.cpp","static void swap(Vertex **a, Vertex **b)\newline{\newline    Vertex *tmp = *a;\newline    *a = *b;\newline    *b = tmp;\newline}\newline","! \\internal\newlineSwaps the Vertex at a with the one at b.\newline \newline","5102522","tour1d_pp.c","void t1d_ppdraw_think(displayd *dsp, ggobid *gg)\newline{\newline  splotd *sp = (splotd *) g_list_nth_data (dsp-&gtsplots, 0);\newline  colorschemed *scheme = gg-&gtactiveColorScheme;\newline  gint wid = dsp-&gtt1d_ppda-&gtallocation.width, \newline    hgt = dsp-&gtt1d_ppda-&gtallocation.height;\newline  PangoLayout *layout = gtk_widget_create_pango_layout(sp-&gtda, &quotThinking...&quot);\newline  \newline  gdk_gc_set_foreground (gg-&gtplot_GC, &ampscheme-&gtrgb_accent);\newline  gdk_draw_layout(dsp-&gtt1d_pp_pixmap, gg-&gtplot_GC, 10, 10, layout);\newline  g_object_unref(G_OBJECT(layout));\newline  /*gdk_text_extents (\newline    gtk_style_get_font (style),\newline    varlab, strlen (varlab),\newline    &amplbearing, &amprbearing, &ampwidth, &ampascent, &ampdescent);\newline    gdk_draw_string (dsp-&gtt1d_pp_pixmap,\newline    gtk_style_get_font (style),\newline      gg-&gtplot_GC, 10, 10, varlab);*/\newline  gdk_draw_pixmap (dsp-&gtt1d_ppda-&gtwindow, gg-&gtplot_GC, dsp-&gtt1d_pp_pixmap,\newline    0, 0, 0, 0, wid, hgt);\newline}\newline","This is writes text to the pp window to in form the\newlineuser that optimize is finding a new maximum \newline","2681016","qambientlightsensor.cpp","void QAmbientLightReading::setLightLevel(QAmbientLightReading::LightLevel lightLevel)\newline{\newline    switch (lightLevel) {\newline    case Dark:\newline    case Twilight:\newline    case Light:\newline    case Bright:\newline    case Sunny:\newline        d-&gtlightLevel = lightLevel;\newline        break;\newline    default:\newline        d-&gtlightLevel = Undefined;\newline        break;\newline    }\newline}\newline","!\newlineSets the ambient light level to \\a lightLevel.\newline \newline","261031","dockapp.c","void wmdock_dockapp_event_after_handler(GtkWidget *window, GdkEvent *ev, DockappNode *dapp)\newline{\newline//	if( ! IS_PANELOFF(wmdock) )\newline//		return;\newline\newline	debug(&quotdockapp.c: Window event-after: %d. (dapp: `%s&#039), dappOnMove: %s&quot, ev-&gttype, dapp-&gtname, dappOnMotion ? &quotYes&quot: &quotNo&quot);\newline\newline	switch(ev-&gttype) {\newline	case GDK_FOCUS_CHANGE:\newline		if(ev-&gtfocus_change.in == TRUE) {\newline			/* `in&#039 is true if window window got the focus. */\newline			g_list_foreach(wmdock-&gtdapps, (GFunc) wmdock_dockapp_tofront, NULL);\newline		}\newline		break;\newline	case GDK_VISIBILITY_NOTIFY:\newline		wmdock_redraw_dockapp(dapp);\newline		break;\newline	default:\newline		break;\newline	}\newline}\newline","\newline Event handler for the tile in panel off mode (event_after).\newline \newline @param tile The window of the event.\newline @param ev Event informations.\newline @param dapp DockappNode of the event.\newline \newline","1517584","lj_debug.c","BCLine LJ_FASTCALL lj_debug_line(GCproto *pt, BCPos pc)\newline{\newline  const void *lineinfo = proto_lineinfo(pt);\newline  if (pc &lt= pt-&gtsizebc &amp&amp lineinfo) {\newline    BCLine first = pt-&gtfirstline;\newline    if (pc == pt-&gtsizebc) return first + pt-&gtnumline;\newline    if (pc-- == 0) return first;\newline    if (pt-&gtnumline &lt 256)\newline      return first + (BCLine)((const uint8_t *)lineinfo)[pc];\newline    else if (pt-&gtnumline &lt 65536)\newline      return first + (BCLine)((const uint16_t *)lineinfo)[pc];\newline    else\newline      return first + (BCLine)((const uint32_t *)lineinfo)[pc];\newline  }\newline  return 0;\newline}\newline","Get line number for a bytecode position. \newline","5833319","solution.c","static int opensolutionfile(fileinfo *file, char const *datname, int mode)\newline{\newline    static int	savedirchecked = FALSE;\newline    char       *buf = NULL;\newline    char const *filename;\newline    int		n;\newline\newline    if (mode != F_READ &amp&amp readonly)\newline	return FALSE;\newline\newline    if (file-&gtname) {\newline	filename = file-&gtname;\newline    } else {\newline	n = strlen(datname);\newline	if (datname[n - 4] == &#039.&#039 &amp&amp tolower(datname[n - 3]) == &#039d&#039\newline				  &amp&amp tolower(datname[n - 2]) == &#039a&#039\newline				  &amp&amp tolower(datname[n - 1]) == &#039t&#039)\newline	    n -= 4;\newline	xalloc(buf, n + 5);\newline	memcpy(buf, datname, n);\newline	memcpy(buf + n, &quot.tws&quot, 5);\newline	filename = buf;\newline    }\newline\newline    if (mode != F_WRITE) {\newline	if (!savedirchecked &amp&amp savedir &amp&amp *savedir &amp&amp !haspathname(filename)) {\newline	    savedirchecked = TRUE;\newline	    if (!finddir(savedir)) {\newline		setsavedir(&quot&quot);\newline		fileerr(file, &quotcan&#039t access directory&quot);\newline	    }\newline	}\newline    }\newline\newline    n = openfileindir(file, savedir, filename,\newline		      mode == F_WRITE ? &quotwb&quot : mode == F_MODIFY ? &quotr+b&quot : &quotrb&quot,\newline		      mode == F_WRITE ? &quotcan&#039t access file&quot : NULL);\newline    if (buf)\newline	free(buf);\newline    return n;\newline}\newline","Locate the solution file for the given data file and open it.\newline \newline","2136734","tests.c","double f_monomial(double x, void * params)\newline{\newline  struct monomial_params * p = (struct monomial_params *) params;\newline\newline  return p-&gtconstant * gsl_pow_int(x, p-&gtdegree);\newline}\newline","f_monomial = constant x^degree \newline","1255552","image.c","errcode_t ocfs2_image_load_bitmap(ocfs2_filesys *ofs)\newline{\newline	struct ocfs2_image_state *ost;\newline	struct ocfs2_image_hdr *hdr;\newline	uint64_t blk_off, bits_set;\newline	int i, j, fd;\newline	ssize_t count;\newline	errcode_t ret;\newline	char *blk;\newline\newline	ret = ocfs2_malloc0(sizeof(struct ocfs2_image_state), &ampofs-&gtost);\newline	if (ret)\newline		return ret;\newline\newline	ost = ofs-&gtost;\newline	ret = ocfs2_malloc_block(ofs-&gtfs_io, &ampblk);\newline	if (ret)\newline		return ret;\newline\newline	/* read ocfs2 image header */\newline	ret = io_read_block(ofs-&gtfs_io, 0, 1, blk);\newline	if (ret)\newline		goto out;\newline\newline	hdr = (struct ocfs2_image_hdr *)blk;\newline	ocfs2_image_swap_header(hdr);\newline\newline	ret = OCFS2_ET_BAD_MAGIC;\newline	if (hdr-&gthdr_magic != OCFS2_IMAGE_MAGIC)\newline		goto out;\newline\newline	if (memcmp(hdr-&gthdr_magic_desc, OCFS2_IMAGE_DESC,\newline		   sizeof(OCFS2_IMAGE_DESC)))\newline		goto out;\newline\newline	ret = OCFS2_ET_OCFS_REV;\newline	if (hdr-&gthdr_version &gt OCFS2_IMAGE_VERSION)\newline		goto out;\newline\newline	ost-&gtost_fsblkcnt 	= hdr-&gthdr_fsblkcnt;\newline	ost-&gtost_fsblksz 	= hdr-&gthdr_fsblksz;\newline	ost-&gtost_imgblkcnt 	= hdr-&gthdr_imgblkcnt;\newline	ost-&gtost_bmpblksz 	= hdr-&gthdr_bmpblksz;\newline\newline	ret = ocfs2_image_alloc_bitmap(ofs);\newline	if (ret)\newline		return ret;\newline\newline	/* load bitmap blocks ocfs2 image state */\newline	bits_set = 0;\newline	fd 	= io_get_fd(ofs-&gtfs_io);\newline	blk_off = (ost-&gtost_imgblkcnt + 1) * ost-&gtost_fsblksz;\newline\newline	for (i = 0; i &lt ost-&gtost_bmpblks; i++) {\newline		ost-&gtost_bmparr[i].arr_set_bit_cnt = bits_set;\newline		/*\newline		 * we don&#039t use io_read_block as ocfs2 image bitmap block size\newline		 * could be different from filesystem block size\newline		 */\newline		count = pread64(fd, ost-&gtost_bmparr[i].arr_map,\newline				ost-&gtost_bmpblksz, blk_off);\newline		if (count &lt 0) {\newline			ret = OCFS2_ET_IO;\newline			goto out;\newline		}\newline\newline		/* add bits set in this bitmap */\newline		for (j = 0; j &lt (ost-&gtost_bmpblksz * 8); j++)\newline			if (ocfs2_test_bit(j, ost-&gtost_bmparr[i].arr_map))\newline				bits_set++;\newline\newline		blk_off += ost-&gtost_bmpblksz;\newline	}\newline\newlineout:\newline	if (blk)\newline		ocfs2_free(&ampblk);\newline	return ret;\newline}\newline","\newline This routine loads bitmap blocks from an o2image image file into memory.\newline This process happens during file open. bitmap blocks reside towards\newline the end of the imagefile.\newline \newline","6397198","qlgc_vnic_dyn_update_daemon.c","void compare_results()\newline{\newline	struct ibvexdm_output *conn;\newline	struct hca_port_list  *port;\newline\newline	for (conn = ibvexdm_op; conn != NULL; conn = conn-&gtnext) {\newline		if (conn-&gtport_list != NULL) {\newline			for (port = conn-&gtport_list; port != NULL; port = port-&gtnext)\newline				scan_vnic_interfaces(conn, port);\newline		}\newline	}\newline}\newline","\newline Function : compare_results.\newline \newline Description : compares the output of ibvexdm with the information about the vnic interfaces\newline on given host to check if there is possibility of any connection re-establishment.\newline \newline","","","","","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Decoding of ISF parameters.","Document info","rotation about origin","returns the time_t","Swaps the Vertex","writes text to the pp window","Sets the ambient light level","Event handler for the tile","Get line number","Locate the solution file","{}","Init conversion stuff","loads bitmap blocks from an o2image","compares the output of ibvexdm","remove marker node from list","Called when Remove is selected from Manage dialog","missing parameter:","only BGP is supported","Set an editor option.","Test for kmo_interpolate_vector_wcs()","Creates an empty namespace declaration."
"39I4RL8QGJHZZESJ57KE8UGFCH3H4R","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3DEL4X4EL6LE6V3BPKV8GO45BWXXY1","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:57:47 PDT 2019","Wed Apr 17 15:03:26 PDT 2019","Fri Apr 19 15:03:26 PDT 2019","2019-04-19 22:04:21 UTC","","","339","100% (27/27)","100% (27/27)","100% (27/27)","2807492","parameters.c","static void set_wakeup_timer()\newline{\newline    if (g_par.wakeup_timer) { /* need to stop it if running */\newline        g_source_remove(g_par.wakeup_timer);\newline        g_par.wakeup_timer=0;\newline    }\newline    if (g_par.use_wakeup_timer) {\newline        check_wakeup(&ampg_par); /* init */\newline        g_par.wakeup_timer = \newline                g_timeout_add_seconds(ORAGE_WAKEUP_TIMER_PERIOD\newline                        , (GtkFunction)check_wakeup, NULL);\newline    }\newline}\newline","start monitoring lost seconds due to hibernate or suspend \newline","5097538","main_loop.c","static bool get_third_addr( const char ** const ibufpp, int * const addr )\newline  {\newline  const int old1 = first_addr;\newline  const int old2 = second_addr;\newline  int addr_cnt = extract_addr_range( ibufpp );\newline\newline  if( addr_cnt &lt 0 ) return false;\newline  if( traditional() &amp&amp addr_cnt == 0 )\newline    { set_error_msg( &quotDestination expected&quot ); return false; }\newline  if( second_addr &lt 0 || second_addr &gt last_addr() )\newline    { invalid_address(); return false; }\newline  *addr = second_addr;\newline  first_addr = old1; second_addr = old2;\newline  return true;\newline  }\newline","get a valid address from the command buffer \newline","808786","cabac.c","static void x264_partition_size_cabac( x264_t *h, x264_cabac_t *cb, int i8, int i_pixel )\newline{\newline    const int i_mb_type = h-&gtmb.i_type;\newline    int b_8x16 = h-&gtmb.i_partition == D_8x16;\newline    int plane_count = CHROMA444 ? 3 : 1;\newline\newline    if( i_mb_type == P_8x8 )\newline    {\newline        x264_cabac_8x8_mvd( h, cb, i8 );\newline        x264_cabac_subpartition_p( cb, h-&gtmb.i_sub_partition[i8] );\newline    }\newline    else if( i_mb_type == P_L0 )\newline        x264_cabac_mvd( h, cb, 0, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline    else if( i_mb_type &gt B_DIRECT &amp&amp i_mb_type &lt B_8x8 )\newline    {\newline        if( x264_mb_type_list_table[ i_mb_type ][0][!!i8] ) x264_cabac_mvd( h, cb, 0, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline        if( x264_mb_type_list_table[ i_mb_type ][1][!!i8] ) x264_cabac_mvd( h, cb, 1, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline    }\newline    else //if( i_mb_type == B_8x8 )\newline    {\newline        if( x264_mb_partition_listX_table[0][ h-&gtmb.i_sub_partition[i8] ] )\newline            x264_cabac_mvd( h, cb, 0, 4*i8, 2, 2 );\newline        if( x264_mb_partition_listX_table[1][ h-&gtmb.i_sub_partition[i8] ] )\newline            x264_cabac_mvd( h, cb, 1, 4*i8, 2, 2 );\newline    }\newline\newline    for( int j = (i_pixel &lt PIXEL_8x8); j &gt= 0; j-- )\newline    {\newline        if( h-&gtmb.i_cbp_luma &amp (1 &lt&lt i8) )\newline        {\newline            if( h-&gtmb.b_transform_8x8 )\newline            {\newline                if( CHROMA444 )\newline                    for( int p = 0; p &lt 3; p++ )\newline                        x264_cabac_block_residual_8x8_cbf( h, cb, ctx_cat_plane[DCT_LUMA_8x8][p], i8*4+p*16, h-&gtdct.luma8x8[i8+p*4], 0 );\newline                else\newline                    x264_cabac_block_residual_8x8( h, cb, DCT_LUMA_8x8, h-&gtdct.luma8x8[i8] );\newline            }\newline            else\newline                for( int p = 0; p &lt plane_count; p++ )\newline                    for( int i4 = 0; i4 &lt 4; i4++ )\newline                        x264_cabac_block_residual_cbf( h, cb, ctx_cat_plane[DCT_LUMA_4x4][p], i4+i8*4+p*16, h-&gtdct.luma4x4[i4+i8*4+p*16], 0 );\newline        }\newline\newline        if( h-&gtmb.i_cbp_chroma )\newline        {\newline            if( CHROMA_FORMAT == CHROMA_422 )\newline            {\newline                int offset = (5*i8) &amp 0x09;\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 16+offset, h-&gtdct.luma4x4[16+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 18+offset, h-&gtdct.luma4x4[18+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 32+offset, h-&gtdct.luma4x4[32+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 34+offset, h-&gtdct.luma4x4[34+offset]+1, 0 );\newline            }\newline            else\newline            {\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 16+i8, h-&gtdct.luma4x4[16+i8]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 32+i8, h-&gtdct.luma4x4[32+i8]+1, 0 );\newline            }\newline        }\newline\newline        i8 += x264_pixel_size[i_pixel].h &gt&gt 3;\newline    }\newline}\newline","\newline RD only; doesn&#039t generate a valid bitstream\newline doesn&#039t write cbp or chroma dc (I don&#039t know how much this matters)\newline doesn&#039t write ref (never varies between calls, so no point in doing so)\newline only writes subpartition for p8x8, needed for sub-8x8 mode decision RDO\newline works on all partition sizes except 16x16\newline \newline","2296435","_verify_log.c","void verify_log( int msg_level, const char *fmt, ...)\newline{\newline    va_list argp;\newline    \newline#ifndef ENABLE_LCMAPS_LOGGING\newline    \newline    if ( log_level &gt= msg_level )\newline    {\newline        if (msg_level == L_WARN )  fprintf( stderr, &quotWarning: &quot );\newline        if (msg_level == L_INFO )  fprintf( stderr, &quotInfo:    &quot );\newline        if (msg_level == L_DEBUG ) fprintf( stderr, &quotDebug:   &quot );\newline        \newline        va_start( argp, fmt );\newline        vfprintf (stderr, fmt, argp);\newline        va_end( argp );\newline        fprintf( stderr, &quot\\n&quot );\newline    }\newline#else\newline    char bericht[VERIFY_LOG_BUFFER_SIZE];\newline    int  num = 0; \newline    \newline    va_start( argp, fmt );\newline    num = vsnprintf (bericht, VERIFY_LOG_BUFFER_SIZE, fmt, argp);\newline    va_end( argp );\newline\newline    if (num&lt0)	{\newline	lcmaps_log(LOG_WARNING,\newline		&quot%s: Cannot log message with format string %s\\n&quot,__func__, fmt);\newline	return;\newline    }\newline    /* Message doesn&#039t fit */\newline    if ((size_t)num &gt= VERIFY_LOG_BUFFER_SIZE)\newline    {\newline        /* Adding to &quot...&quot to end of bericht */\newline        bericht [VERIFY_LOG_BUFFER_SIZE - 4] = bericht [VERIFY_LOG_BUFFER_SIZE - 3] = bericht [VERIFY_LOG_BUFFER_SIZE - 2] = &#039.&#039;\newline        bericht [VERIFY_LOG_BUFFER_SIZE - 1] = &#039\\0&#039;\newline    }\newline    \newline\newline    if (msg_level == L_WARN)\newline        lcmaps_log(LOG_WARNING, &quot%s: Warning: %s\\n&quot, __func__, bericht);\newline        /* lcmaps_log_debug (msg_level + 1, &quotWarning: %s\\n&quot, bericht); */\newline    else if (msg_level == L_INFO)\newline        lcmaps_log (LOG_INFO, &quot%s: %s\\n&quot, __func__, bericht);\newline    else if (msg_level == L_DEBUG)\newline        lcmaps_log_debug (msg_level + 1, &quot%s: %s\\n&quot, __func__, bericht);\newline#endif\newline}\newline","\newline Logs log message with format string msg on loglevel msg_level\newline \newline","2585474","libev_vfd.h","static vfd_socket_t vfd_get(int fd)\newline{\newline	int handle = -1;\newline	VFD_LOCK_ENTER;\newline	if (vfd_entries != NULL &amp&amp fd &gt= 0 &amp&amp fd &lt vfd_num)\newline		handle = vfd_entries[fd].handle;\newline	VFD_LOCK_LEAVE;\newline	return handle;\newline}\newline","\newline Given a virtual fd returns an OS handle or -1\newline This function is speed critical, so it cannot use GIL\newline \newline","2215630","vfs101.c","static void async_load_cb(struct libusb_transfer *transfer)\newline{\newline	struct fpi_ssm *ssm = transfer-&gtuser_data;\newline	struct fp_img_dev *dev = ssm-&gtpriv;\newline	struct vfs101_dev *vdev = dev-&gtpriv;\newline\newline	/* Cleanup transfer */\newline	vdev-&gttransfer = NULL;\newline\newline	/* Skip error check if ignore_error is set */\newline	if (!vdev-&gtignore_error)\newline	{\newline		if (transfer-&gtstatus != LIBUSB_TRANSFER_COMPLETED)\newline		{\newline			/* Transfer not completed */\newline			fp_err(&quottransfer not completed, status = %d, length = %d&quot, transfer-&gtstatus, vdev-&gtlength);\newline			fpi_imgdev_session_error(dev, -EIO);\newline			fpi_ssm_mark_aborted(ssm, -EIO);\newline			goto out;\newline		}\newline\newline		if (transfer-&gtactual_length % VFS_FRAME_SIZE)\newline		{\newline			/* Received incomplete frame, return protocol error */\newline			fp_err(&quotreceived incomplete frame&quot);\newline			fpi_imgdev_session_error(dev, -EIO);\newline			fpi_ssm_mark_aborted(ssm, -EIO);\newline			goto out;\newline		}\newline	}\newline\newline	/* Increase image length */\newline	vdev-&gtlength += transfer-&gtactual_length;\newline\newline	if (transfer-&gtactual_length == VFS_BLOCK_SIZE)\newline	{\newline		if ((VFS_BUFFER_SIZE - vdev-&gtlength) &lt VFS_BLOCK_SIZE)\newline		{\newline			/* Buffer full, image too large, return no memory error */\newline			fp_err(&quotbuffer full, image too large&quot);\newline			fpi_imgdev_session_error(dev, -ENOMEM);\newline			fpi_ssm_mark_aborted(ssm, -ENOMEM);\newline			goto out;\newline		}\newline		else\newline			/* Image load not completed, submit another asynchronous load */\newline			async_load(ssm);\newline	}\newline	else\newline	{\newline		/* Reset ignore_error flag */\newline		if (vdev-&gtignore_error)\newline			vdev-&gtignore_error = FALSE;\newline\newline		/* Image load completed, go to next state */\newline		vdev-&gtheight = vdev-&gtlength / VFS_FRAME_SIZE;\newline		fp_dbg(&quotimage loaded, height = %d&quot, vdev-&gtheight);\newline		fpi_ssm_next_state(ssm);\newline	}\newline\newlineout:\newline	libusb_free_transfer(transfer);\newline}\newline","Callback of asynchronous load \newline","4606816","type2str.c","TIEXPORT2 const char *TICALL tifiles_model_to_string(CalcModel model)\newline{\newline	switch (model)\newline	{\newline	case CALC_NONE:  return &quotnone&quot;\newline	case CALC_V200:  return &quotV200&quot;\newline	case CALC_TI92P: return &quotTI92+&quot;\newline	case CALC_TI92:  return &quotTI92&quot;\newline	case CALC_TI89T: return &quotTI89t&quot;\newline	case CALC_TI89:  return &quotTI89&quot;\newline	case CALC_TI86:  return &quotTI86&quot;\newline	case CALC_TI85:  return &quotTI85&quot;\newline	case CALC_TI84P: return &quotTI84+&quot;\newline	case CALC_TI83P: return &quotTI83+&quot;\newline	case CALC_TI83:  return &quotTI83&quot;\newline	case CALC_TI82:  return &quotTI82&quot;\newline	case CALC_TI73:  return &quotTI73&quot;\newline	case CALC_TI84P_USB: return &quotTI84+ USB&quot;\newline	case CALC_TI89T_USB: return &quotTI89t USB&quot;\newline	case CALC_NSPIRE: return &quotNSpire&quot;\newline	case CALC_TI80: return &quotTI80&quot;\newline	default: return &quotunknown&quot;\newline	}\newline}\newline","\newline tifiles_model_to_string:\newline @model: a calculator model.\newline \newline Do an integer to string conversion.\newline \newline Return value: a string like &quotTI92+&quot.\newline \newline","6451123","luafuncs.c","int lf_table_walk(struct lua_State *L)\newline{\newline	struct WALKDATA *data;\newline\newline	if(lua_gettop(L) != 1)\newline		luaL_error(L, &quottable_walk: incorrect number of arguments&quot);\newline	luaL_checktype(L, 1, LUA_TTABLE);\newline	\newline	/* 1: table to iterate over */\newline	lua_pushcfunction(L, lf_table_walk_iter); /* 2: iterator function */\newline	lua_createtable(L, 4, 0); /* 3: table stack */\newline	\newline	data = (struct WALKDATA *)lua_newuserdata(L, sizeof(struct WALKDATA));\newline	data-&gtdepth = 1;\newline	data-&gtindex[data-&gtdepth] = 0;\newline	lua_rawseti(L, 3, 1);\newline	\newline	lua_pushvalue(L, 1);\newline	lua_rawseti(L, 3, 2);\newline	lua_pushnil(L);\newline	\newline	return 3;\newline}\newline","\newline the walk table looks like this\newline t = {\newline [1] = walk data\newline [2] = table 1\newline [3] = table 2\newline [N] = table N\newline }\newline \newline","986014","process-stdio.c","void uv_disable_stdio_inheritance(void) {\newline  HANDLE handle;\newline  STARTUPINFOW si;\newline\newline  /* Make the windows stdio handles non-inheritable. */\newline  handle = GetStdHandle(STD_INPUT_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  handle = GetStdHandle(STD_OUTPUT_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  handle = GetStdHandle(STD_ERROR_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  /* Make inherited CRT FDs non-inheritable. */\newline  GetStartupInfoW(&ampsi);\newline  if (uv__stdio_verify(si.lpReserved2, si.cbReserved2))\newline    uv__stdio_noinherit(si.lpReserved2);\newline}\newline","\newline Clear the HANDLE_FLAG_INHERIT flag from all HANDLEs that were inherited\newline the parent process. Don&#039t check for errors - the stdio handles may not be\newline valid, or may be closed already. There is no guarantee that this function\newline does a perfect job.\newline \newline","5245475","ow_1821.c","static GOOD_OR_BAD OW_current_temperature_lowres(_FLOAT * temp, const struct parsedname *pn)\newline{\newline	BYTE read_temp[] = { _1W_READ_TEMPERATURE, };\newline	BYTE temp_read;\newline	struct transaction_log t[] = {\newline		TRXN_START,\newline		TRXN_WRITE1(read_temp),\newline		TRXN_READ1(&amptemp_read),\newline		TRXN_END,\newline	};\newline\newline	RETURN_BAD_IF_BAD(BUS_transaction(t, pn)) ;\newline	temp[0] = (_FLOAT) ((int8_t) temp_read);\newline\newline	return gbGOOD;\newline}\newline","Read temperature register but do not attempt to increase the resolution,\newline because, for instance, the chip is in continuous conversion mode.\newline \newline","3964356","vmfs_file.c","int vmfs_file_stat_at(vmfs_dir_t *dir,const char *path,struct stat *buf)\newline{\newline   uint32_t blk_id;\newline\newline   if (!(blk_id = vmfs_dir_resolve_path(dir,path,1)))\newline      return(-ENOENT);\newline\newline   return(vmfs_inode_stat_from_blkid(vmfs_dir_get_fs(dir),blk_id,buf));\newline}\newline","Get file file status (follow symlink) \newline","4675230","backtrack.cpp","bool Algorithm::visit_new_node()\newline{\newline  // If the current node is the rightmost child we must backtrack\newline  // one level because there are no more children at this level.\newline  // So we back up until we find a non-rightmost child, then\newline  // generate the child to the right. If we back up to the top\newline  // without finding an unvisted child, then all nodes have been\newline  // generated.\newline  while (level &gt= 0 &amp&amp solution.is_last_at(level))\newline  {\newline    solution.reset_at(level);\newline    --level;\newline  }\newline  if (level &lt 0)\newline    return false;\newline  solution.set_next_at(level);\newline  return true;\newline}\newline","Backtrack through the decision tree until a node was found that hasn&#039t\newline been visited, return true if an unvisited node was found.\newline \newline","557182","bbrun.c","int bb_run_fork(char **argv, int detached) {\newline  int exitcode = -1;\newline\newline  check_handler();\newline  /* Fork and attempt to run given application */\newline  pid_t pid = fork();\newline  if (pid == 0) {\newline    /* child process after fork */\newline    if (detached) {\newline      bb_run_exec_detached(argv);\newline    } else {\newline      bb_run_exec(argv);\newline    }\newline  } else if (pid &gt 0) {\newline    /* parent process after fork */\newline    int status = 0;\newline\newline    bb_log(LOG_DEBUG, &quotProcess %s started, PID %i.\\n&quot, argv[0], pid);\newline    pidlist_add(pid);\newline\newline    if (waitpid(pid, &ampstatus, 0) != -1) {\newline      if (WIFEXITED(status)) {\newline        /* program exited normally, return status */\newline        exitcode = WEXITSTATUS(status);\newline      } else if (WIFSIGNALED(status)) {\newline        /* program was terminated by a signal */\newline        exitcode = 128 + WTERMSIG(status);\newline      }\newline    } else {\newline      bb_log(LOG_ERR, &quotwaitpid(%i) failed with %s\\n&quot, pid, strerror(errno));\newline    }\newline    pidlist_remove(pid);\newline  } else {\newline    /* Fork failed */\newline    bb_log(LOG_ERR, &quotProcess %s could not be started. fork() failed.\\n&quot, argv[0]);\newline  }\newline\newline  /* could not determine return value */\newline  return exitcode;\newline}\newline","\newline Forks and runs the given application and waits for the process to finish\newline \newline @param argv The arguments values, the first one is the program\newline @param detached non-zero if the std in/output must be redirected to /dev/null, zero otherwise\newline @return Exit code of the program (between 0 and 255) or -1 on failure\newline \newline","2120816","std_expr.h","extern inline const concatenation_exprt &ampto_concatenation_expr(const exprt &ampexpr)\newline{\newline  assert(expr.id()==ID_concatenation);\newline  return static_cast&ltconst concatenation_exprt &amp&gt(expr);\newline}\newline","! \\brief Cast a generic exprt to a \\ref concatenation_exprt\newline \newline This is an unchecked conversion. \\a expr must be known to be \\ref\newline concatenation_exprt.\newline \newline \\param expr Source expression\newline \\return Object of type \\ref concatenation_exprt\newline \newline \\ingroup gr_std_expr\newline \newline","3341265","utils.c","void clear_buffer(char *buffer, int buffer_length){\newline\newline	/* NULL all bytes of buffer */\newline	memset(buffer,&#039\\x0&#039,buffer_length);\newline\newline	return;\newline        }\newline","wipes an area of memory clean \newline","1525098","glm.cpp","void glm::enableTab3()\newline{\newline  if (!tab2_lb2-&gtcount()) {\newline    QMessageBox::information(0, &quotError!&quot, &quotNo TES files selected yet.&quot);\newline    return;\newline  }\newline\newline  //tabSection-&gtsetTabEnabled(tab3, true);\newline  tabSection-&gtsetCurrentPage(2);\newline}\newline","Slot for &quotDONE&quot button: When files are selected, click the button will enable tab3\newline But if no file selected, an error message will pop out. \newline","2680922","qsensorgesture.cpp","void QSensorGesture::startDetection()\newline{\newline    if (d_ptr-&gtm_sensorRecognizers.count() &lt 1)\newline        return;\newline    if (d_ptr-&gtisActive)\newline        return;\newline\newline    Q_FOREACH (QSensorGestureRecognizer *recognizer,  d_ptr-&gtm_sensorRecognizers) {\newline\newline        Q_ASSERT(recognizer !=0);\newline\newline        connect(recognizer,SIGNAL(detected(QString)),\newline                this,SIGNAL(detected(QString)),Qt::UniqueConnection);\newline\newline        //connect recognizer signals\newline        Q_FOREACH (QString method, recognizer-&gtgestureSignals()) {\newline            method.prepend(QLatin1String(&quot2&quot));\newline            connect(recognizer, method.toLatin1(),\newline                    this, method.toLatin1(), Qt::UniqueConnection);\newline        }\newline\newline        recognizer-&gtstartBackend();\newline    }\newline    d_ptr-&gtisActive = true;\newline}\newline","!\newlineStarts the gesture detection routines in the recognizer.\newline \newline","2789685","gserialized_gist_nd.c","static void gidx_dimensionality_check(GIDX **a, GIDX **b)\newline{		\newline	if ( GIDX_NDIMS(*a) &lt GIDX_NDIMS(*b) )\newline	{\newline		GIDX *tmp = *b;\newline		*b = *a;\newline		*a = tmp;\newline	}\newline}\newline","Ensure the first argument has the higher dimensionality. \newline","4169750","rc.c","char * rc_get_path(char * package)\newline{\newline    const char * rc_name = &quotoptions&quot;\newline    char * path;\newline    char * dirname = NULL;\newline    char * filename = NULL;\newline    int length = 0;\newline\newline    /* find the base path */\newline    if (!(path=getenv(&quotHOME&quot))) {\newline        fprintf(stderr,_(&quotCannot find your &#039HOME&#039 environment variable.\\n&quot));\newline        path=&quot.&quot; /* default to current directory */\newline    }\newline\newline    /* create directory name */\newline    length=strlen(path)+strlen(package)+3; /* &quot/&quot, &quot.&quot, and NULL */\newline    if (!(dirname=(char*)malloc(length))) {\newline            perror(&quotmalloc&quot);\newline            return NULL;\newline    }\newline    sprintf(dirname,&quot%s/.%s&quot,path,package);\newline\newline    /* check for the package directory */\newline    if (access(dirname,W_OK)) {\newline        if (errno==ENOENT) {\newline            /* doesn&#039t exist: make it */\newline            if (mkdir(dirname,0700)) {\newline                perror(dirname);\newline                goto need_free;\newline            }\newline        }\newline        else {\newline            perror(dirname);\newline            goto need_free;\newline        }\newline    }\newline\newline    length=strlen(dirname)+strlen(rc_name)+2; /* need &quot/&quot and NULL */\newline    if (!(filename=(char*)malloc(length))) {\newline        perror(&quotmalloc&quot);\newline        goto need_free;\newline    }\newline    sprintf(filename,&quot%s/%s&quot,dirname,rc_name);\newline\newlineneed_free:\newline    free(dirname);\newline    return filename;\newline}\newline","\newline Figure out the rc file&#039s path name.\newline Caller must free the allocated filename.\newline \newline","738388","aj_crypto_field_p256.c","boolean_t fpvalidate_p256(digit256_tc a)\newline{\newline    AJ_ASSERT(a != NULL);\newline    return validate_256(a, P256_MODULUS);\newline}\newline","Validate that a 256-bit value is in [0, P256_MODULUS-1]\newline Returns = B_TRUE if 0 &lt= a &lt modulus, else returns B_FALSE. \newline","2194609","disconnect_manager.cpp","void disconnect_manager::end_process()\newline{\newline	debugQt(&quotdisconnect_manager::end_process()&quot);\newline	deleteLater (); // delete this object\newline}\newline","\newline Process ending\newline \newline","","","","","","","","","","","","","","","on","","on","","","on","","","","","","","","","","","","","","","","","","","","","","","monitoring lost seconds due to hibernate or suspend","Read temperature register","Get file file status","Backtrack through the decision tree until a node was found","runs the given application and waits for the process to finish","Cast a generic exprt","wipes an area of memory clean","Slot for ""DONE"" button:","Starts the gesture detection routines in the recognizer.","Ensure the first argument has the higher dimensionality.","Figure out the rc file's path name.","get a valid address from the command buffer","Validate that a 256-bit value","Process ending","{}","Logs log message","{}","Callback of asynchronous load","integer to string conversion.","{}","Clear the HANDLE_FLAG_INHERIT flag"
"39I4RL8QGJHZZESJ57KE8UGFCH3H4R","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3VELCLL3GKJ0G31ND1IDWUTO0671FV","AVC62JNYAXA45","Approved","Wed Apr 17 14:12:15 PDT 2019","Wed Apr 17 14:33:32 PDT 2019","Fri Apr 19 14:33:32 PDT 2019","2019-04-19 21:34:21 UTC","","","1277","100% (24/24)","100% (24/24)","100% (24/24)","2807492","parameters.c","static void set_wakeup_timer()\newline{\newline    if (g_par.wakeup_timer) { /* need to stop it if running */\newline        g_source_remove(g_par.wakeup_timer);\newline        g_par.wakeup_timer=0;\newline    }\newline    if (g_par.use_wakeup_timer) {\newline        check_wakeup(&ampg_par); /* init */\newline        g_par.wakeup_timer = \newline                g_timeout_add_seconds(ORAGE_WAKEUP_TIMER_PERIOD\newline                        , (GtkFunction)check_wakeup, NULL);\newline    }\newline}\newline","start monitoring lost seconds due to hibernate or suspend \newline","5097538","main_loop.c","static bool get_third_addr( const char ** const ibufpp, int * const addr )\newline  {\newline  const int old1 = first_addr;\newline  const int old2 = second_addr;\newline  int addr_cnt = extract_addr_range( ibufpp );\newline\newline  if( addr_cnt &lt 0 ) return false;\newline  if( traditional() &amp&amp addr_cnt == 0 )\newline    { set_error_msg( &quotDestination expected&quot ); return false; }\newline  if( second_addr &lt 0 || second_addr &gt last_addr() )\newline    { invalid_address(); return false; }\newline  *addr = second_addr;\newline  first_addr = old1; second_addr = old2;\newline  return true;\newline  }\newline","get a valid address from the command buffer \newline","808786","cabac.c","static void x264_partition_size_cabac( x264_t *h, x264_cabac_t *cb, int i8, int i_pixel )\newline{\newline    const int i_mb_type = h-&gtmb.i_type;\newline    int b_8x16 = h-&gtmb.i_partition == D_8x16;\newline    int plane_count = CHROMA444 ? 3 : 1;\newline\newline    if( i_mb_type == P_8x8 )\newline    {\newline        x264_cabac_8x8_mvd( h, cb, i8 );\newline        x264_cabac_subpartition_p( cb, h-&gtmb.i_sub_partition[i8] );\newline    }\newline    else if( i_mb_type == P_L0 )\newline        x264_cabac_mvd( h, cb, 0, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline    else if( i_mb_type &gt B_DIRECT &amp&amp i_mb_type &lt B_8x8 )\newline    {\newline        if( x264_mb_type_list_table[ i_mb_type ][0][!!i8] ) x264_cabac_mvd( h, cb, 0, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline        if( x264_mb_type_list_table[ i_mb_type ][1][!!i8] ) x264_cabac_mvd( h, cb, 1, 4*i8, 4&gt&gtb_8x16, 2&lt&ltb_8x16 );\newline    }\newline    else //if( i_mb_type == B_8x8 )\newline    {\newline        if( x264_mb_partition_listX_table[0][ h-&gtmb.i_sub_partition[i8] ] )\newline            x264_cabac_mvd( h, cb, 0, 4*i8, 2, 2 );\newline        if( x264_mb_partition_listX_table[1][ h-&gtmb.i_sub_partition[i8] ] )\newline            x264_cabac_mvd( h, cb, 1, 4*i8, 2, 2 );\newline    }\newline\newline    for( int j = (i_pixel &lt PIXEL_8x8); j &gt= 0; j-- )\newline    {\newline        if( h-&gtmb.i_cbp_luma &amp (1 &lt&lt i8) )\newline        {\newline            if( h-&gtmb.b_transform_8x8 )\newline            {\newline                if( CHROMA444 )\newline                    for( int p = 0; p &lt 3; p++ )\newline                        x264_cabac_block_residual_8x8_cbf( h, cb, ctx_cat_plane[DCT_LUMA_8x8][p], i8*4+p*16, h-&gtdct.luma8x8[i8+p*4], 0 );\newline                else\newline                    x264_cabac_block_residual_8x8( h, cb, DCT_LUMA_8x8, h-&gtdct.luma8x8[i8] );\newline            }\newline            else\newline                for( int p = 0; p &lt plane_count; p++ )\newline                    for( int i4 = 0; i4 &lt 4; i4++ )\newline                        x264_cabac_block_residual_cbf( h, cb, ctx_cat_plane[DCT_LUMA_4x4][p], i4+i8*4+p*16, h-&gtdct.luma4x4[i4+i8*4+p*16], 0 );\newline        }\newline\newline        if( h-&gtmb.i_cbp_chroma )\newline        {\newline            if( CHROMA_FORMAT == CHROMA_422 )\newline            {\newline                int offset = (5*i8) &amp 0x09;\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 16+offset, h-&gtdct.luma4x4[16+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 18+offset, h-&gtdct.luma4x4[18+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 32+offset, h-&gtdct.luma4x4[32+offset]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 34+offset, h-&gtdct.luma4x4[34+offset]+1, 0 );\newline            }\newline            else\newline            {\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 16+i8, h-&gtdct.luma4x4[16+i8]+1, 0 );\newline                x264_cabac_block_residual_cbf( h, cb, DCT_CHROMA_AC, 32+i8, h-&gtdct.luma4x4[32+i8]+1, 0 );\newline            }\newline        }\newline\newline        i8 += x264_pixel_size[i_pixel].h &gt&gt 3;\newline    }\newline}\newline","\newline RD only; doesn&#039t generate a valid bitstream\newline doesn&#039t write cbp or chroma dc (I don&#039t know how much this matters)\newline doesn&#039t write ref (never varies between calls, so no point in doing so)\newline only writes subpartition for p8x8, needed for sub-8x8 mode decision RDO\newline works on all partition sizes except 16x16\newline \newline","2296435","_verify_log.c","void verify_log( int msg_level, const char *fmt, ...)\newline{\newline    va_list argp;\newline    \newline#ifndef ENABLE_LCMAPS_LOGGING\newline    \newline    if ( log_level &gt= msg_level )\newline    {\newline        if (msg_level == L_WARN )  fprintf( stderr, &quotWarning: &quot );\newline        if (msg_level == L_INFO )  fprintf( stderr, &quotInfo:    &quot );\newline        if (msg_level == L_DEBUG ) fprintf( stderr, &quotDebug:   &quot );\newline        \newline        va_start( argp, fmt );\newline        vfprintf (stderr, fmt, argp);\newline        va_end( argp );\newline        fprintf( stderr, &quot\\n&quot );\newline    }\newline#else\newline    char bericht[VERIFY_LOG_BUFFER_SIZE];\newline    int  num = 0; \newline    \newline    va_start( argp, fmt );\newline    num = vsnprintf (bericht, VERIFY_LOG_BUFFER_SIZE, fmt, argp);\newline    va_end( argp );\newline\newline    if (num&lt0)	{\newline	lcmaps_log(LOG_WARNING,\newline		&quot%s: Cannot log message with format string %s\\n&quot,__func__, fmt);\newline	return;\newline    }\newline    /* Message doesn&#039t fit */\newline    if ((size_t)num &gt= VERIFY_LOG_BUFFER_SIZE)\newline    {\newline        /* Adding to &quot...&quot to end of bericht */\newline        bericht [VERIFY_LOG_BUFFER_SIZE - 4] = bericht [VERIFY_LOG_BUFFER_SIZE - 3] = bericht [VERIFY_LOG_BUFFER_SIZE - 2] = &#039.&#039;\newline        bericht [VERIFY_LOG_BUFFER_SIZE - 1] = &#039\\0&#039;\newline    }\newline    \newline\newline    if (msg_level == L_WARN)\newline        lcmaps_log(LOG_WARNING, &quot%s: Warning: %s\\n&quot, __func__, bericht);\newline        /* lcmaps_log_debug (msg_level + 1, &quotWarning: %s\\n&quot, bericht); */\newline    else if (msg_level == L_INFO)\newline        lcmaps_log (LOG_INFO, &quot%s: %s\\n&quot, __func__, bericht);\newline    else if (msg_level == L_DEBUG)\newline        lcmaps_log_debug (msg_level + 1, &quot%s: %s\\n&quot, __func__, bericht);\newline#endif\newline}\newline","\newline Logs log message with format string msg on loglevel msg_level\newline \newline","2585474","libev_vfd.h","static vfd_socket_t vfd_get(int fd)\newline{\newline	int handle = -1;\newline	VFD_LOCK_ENTER;\newline	if (vfd_entries != NULL &amp&amp fd &gt= 0 &amp&amp fd &lt vfd_num)\newline		handle = vfd_entries[fd].handle;\newline	VFD_LOCK_LEAVE;\newline	return handle;\newline}\newline","\newline Given a virtual fd returns an OS handle or -1\newline This function is speed critical, so it cannot use GIL\newline \newline","2215630","vfs101.c","static void async_load_cb(struct libusb_transfer *transfer)\newline{\newline	struct fpi_ssm *ssm = transfer-&gtuser_data;\newline	struct fp_img_dev *dev = ssm-&gtpriv;\newline	struct vfs101_dev *vdev = dev-&gtpriv;\newline\newline	/* Cleanup transfer */\newline	vdev-&gttransfer = NULL;\newline\newline	/* Skip error check if ignore_error is set */\newline	if (!vdev-&gtignore_error)\newline	{\newline		if (transfer-&gtstatus != LIBUSB_TRANSFER_COMPLETED)\newline		{\newline			/* Transfer not completed */\newline			fp_err(&quottransfer not completed, status = %d, length = %d&quot, transfer-&gtstatus, vdev-&gtlength);\newline			fpi_imgdev_session_error(dev, -EIO);\newline			fpi_ssm_mark_aborted(ssm, -EIO);\newline			goto out;\newline		}\newline\newline		if (transfer-&gtactual_length % VFS_FRAME_SIZE)\newline		{\newline			/* Received incomplete frame, return protocol error */\newline			fp_err(&quotreceived incomplete frame&quot);\newline			fpi_imgdev_session_error(dev, -EIO);\newline			fpi_ssm_mark_aborted(ssm, -EIO);\newline			goto out;\newline		}\newline	}\newline\newline	/* Increase image length */\newline	vdev-&gtlength += transfer-&gtactual_length;\newline\newline	if (transfer-&gtactual_length == VFS_BLOCK_SIZE)\newline	{\newline		if ((VFS_BUFFER_SIZE - vdev-&gtlength) &lt VFS_BLOCK_SIZE)\newline		{\newline			/* Buffer full, image too large, return no memory error */\newline			fp_err(&quotbuffer full, image too large&quot);\newline			fpi_imgdev_session_error(dev, -ENOMEM);\newline			fpi_ssm_mark_aborted(ssm, -ENOMEM);\newline			goto out;\newline		}\newline		else\newline			/* Image load not completed, submit another asynchronous load */\newline			async_load(ssm);\newline	}\newline	else\newline	{\newline		/* Reset ignore_error flag */\newline		if (vdev-&gtignore_error)\newline			vdev-&gtignore_error = FALSE;\newline\newline		/* Image load completed, go to next state */\newline		vdev-&gtheight = vdev-&gtlength / VFS_FRAME_SIZE;\newline		fp_dbg(&quotimage loaded, height = %d&quot, vdev-&gtheight);\newline		fpi_ssm_next_state(ssm);\newline	}\newline\newlineout:\newline	libusb_free_transfer(transfer);\newline}\newline","Callback of asynchronous load \newline","4606816","type2str.c","TIEXPORT2 const char *TICALL tifiles_model_to_string(CalcModel model)\newline{\newline	switch (model)\newline	{\newline	case CALC_NONE:  return &quotnone&quot;\newline	case CALC_V200:  return &quotV200&quot;\newline	case CALC_TI92P: return &quotTI92+&quot;\newline	case CALC_TI92:  return &quotTI92&quot;\newline	case CALC_TI89T: return &quotTI89t&quot;\newline	case CALC_TI89:  return &quotTI89&quot;\newline	case CALC_TI86:  return &quotTI86&quot;\newline	case CALC_TI85:  return &quotTI85&quot;\newline	case CALC_TI84P: return &quotTI84+&quot;\newline	case CALC_TI83P: return &quotTI83+&quot;\newline	case CALC_TI83:  return &quotTI83&quot;\newline	case CALC_TI82:  return &quotTI82&quot;\newline	case CALC_TI73:  return &quotTI73&quot;\newline	case CALC_TI84P_USB: return &quotTI84+ USB&quot;\newline	case CALC_TI89T_USB: return &quotTI89t USB&quot;\newline	case CALC_NSPIRE: return &quotNSpire&quot;\newline	case CALC_TI80: return &quotTI80&quot;\newline	default: return &quotunknown&quot;\newline	}\newline}\newline","\newline tifiles_model_to_string:\newline @model: a calculator model.\newline \newline Do an integer to string conversion.\newline \newline Return value: a string like &quotTI92+&quot.\newline \newline","6451123","luafuncs.c","int lf_table_walk(struct lua_State *L)\newline{\newline	struct WALKDATA *data;\newline\newline	if(lua_gettop(L) != 1)\newline		luaL_error(L, &quottable_walk: incorrect number of arguments&quot);\newline	luaL_checktype(L, 1, LUA_TTABLE);\newline	\newline	/* 1: table to iterate over */\newline	lua_pushcfunction(L, lf_table_walk_iter); /* 2: iterator function */\newline	lua_createtable(L, 4, 0); /* 3: table stack */\newline	\newline	data = (struct WALKDATA *)lua_newuserdata(L, sizeof(struct WALKDATA));\newline	data-&gtdepth = 1;\newline	data-&gtindex[data-&gtdepth] = 0;\newline	lua_rawseti(L, 3, 1);\newline	\newline	lua_pushvalue(L, 1);\newline	lua_rawseti(L, 3, 2);\newline	lua_pushnil(L);\newline	\newline	return 3;\newline}\newline","\newline the walk table looks like this\newline t = {\newline [1] = walk data\newline [2] = table 1\newline [3] = table 2\newline [N] = table N\newline }\newline \newline","986014","process-stdio.c","void uv_disable_stdio_inheritance(void) {\newline  HANDLE handle;\newline  STARTUPINFOW si;\newline\newline  /* Make the windows stdio handles non-inheritable. */\newline  handle = GetStdHandle(STD_INPUT_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  handle = GetStdHandle(STD_OUTPUT_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  handle = GetStdHandle(STD_ERROR_HANDLE);\newline  if (handle != NULL &amp&amp handle != INVALID_HANDLE_VALUE)\newline    SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);\newline\newline  /* Make inherited CRT FDs non-inheritable. */\newline  GetStartupInfoW(&ampsi);\newline  if (uv__stdio_verify(si.lpReserved2, si.cbReserved2))\newline    uv__stdio_noinherit(si.lpReserved2);\newline}\newline","\newline Clear the HANDLE_FLAG_INHERIT flag from all HANDLEs that were inherited\newline the parent process. Don&#039t check for errors - the stdio handles may not be\newline valid, or may be closed already. There is no guarantee that this function\newline does a perfect job.\newline \newline","5245475","ow_1821.c","static GOOD_OR_BAD OW_current_temperature_lowres(_FLOAT * temp, const struct parsedname *pn)\newline{\newline	BYTE read_temp[] = { _1W_READ_TEMPERATURE, };\newline	BYTE temp_read;\newline	struct transaction_log t[] = {\newline		TRXN_START,\newline		TRXN_WRITE1(read_temp),\newline		TRXN_READ1(&amptemp_read),\newline		TRXN_END,\newline	};\newline\newline	RETURN_BAD_IF_BAD(BUS_transaction(t, pn)) ;\newline	temp[0] = (_FLOAT) ((int8_t) temp_read);\newline\newline	return gbGOOD;\newline}\newline","Read temperature register but do not attempt to increase the resolution,\newline because, for instance, the chip is in continuous conversion mode.\newline \newline","3964356","vmfs_file.c","int vmfs_file_stat_at(vmfs_dir_t *dir,const char *path,struct stat *buf)\newline{\newline   uint32_t blk_id;\newline\newline   if (!(blk_id = vmfs_dir_resolve_path(dir,path,1)))\newline      return(-ENOENT);\newline\newline   return(vmfs_inode_stat_from_blkid(vmfs_dir_get_fs(dir),blk_id,buf));\newline}\newline","Get file file status (follow symlink) \newline","4675230","backtrack.cpp","bool Algorithm::visit_new_node()\newline{\newline  // If the current node is the rightmost child we must backtrack\newline  // one level because there are no more children at this level.\newline  // So we back up until we find a non-rightmost child, then\newline  // generate the child to the right. If we back up to the top\newline  // without finding an unvisted child, then all nodes have been\newline  // generated.\newline  while (level &gt= 0 &amp&amp solution.is_last_at(level))\newline  {\newline    solution.reset_at(level);\newline    --level;\newline  }\newline  if (level &lt 0)\newline    return false;\newline  solution.set_next_at(level);\newline  return true;\newline}\newline","Backtrack through the decision tree until a node was found that hasn&#039t\newline been visited, return true if an unvisited node was found.\newline \newline","557182","bbrun.c","int bb_run_fork(char **argv, int detached) {\newline  int exitcode = -1;\newline\newline  check_handler();\newline  /* Fork and attempt to run given application */\newline  pid_t pid = fork();\newline  if (pid == 0) {\newline    /* child process after fork */\newline    if (detached) {\newline      bb_run_exec_detached(argv);\newline    } else {\newline      bb_run_exec(argv);\newline    }\newline  } else if (pid &gt 0) {\newline    /* parent process after fork */\newline    int status = 0;\newline\newline    bb_log(LOG_DEBUG, &quotProcess %s started, PID %i.\\n&quot, argv[0], pid);\newline    pidlist_add(pid);\newline\newline    if (waitpid(pid, &ampstatus, 0) != -1) {\newline      if (WIFEXITED(status)) {\newline        /* program exited normally, return status */\newline        exitcode = WEXITSTATUS(status);\newline      } else if (WIFSIGNALED(status)) {\newline        /* program was terminated by a signal */\newline        exitcode = 128 + WTERMSIG(status);\newline      }\newline    } else {\newline      bb_log(LOG_ERR, &quotwaitpid(%i) failed with %s\\n&quot, pid, strerror(errno));\newline    }\newline    pidlist_remove(pid);\newline  } else {\newline    /* Fork failed */\newline    bb_log(LOG_ERR, &quotProcess %s could not be started. fork() failed.\\n&quot, argv[0]);\newline  }\newline\newline  /* could not determine return value */\newline  return exitcode;\newline}\newline","\newline Forks and runs the given application and waits for the process to finish\newline \newline @param argv The arguments values, the first one is the program\newline @param detached non-zero if the std in/output must be redirected to /dev/null, zero otherwise\newline @return Exit code of the program (between 0 and 255) or -1 on failure\newline \newline","2120816","std_expr.h","extern inline const concatenation_exprt &ampto_concatenation_expr(const exprt &ampexpr)\newline{\newline  assert(expr.id()==ID_concatenation);\newline  return static_cast&ltconst concatenation_exprt &amp&gt(expr);\newline}\newline","! \\brief Cast a generic exprt to a \\ref concatenation_exprt\newline \newline This is an unchecked conversion. \\a expr must be known to be \\ref\newline concatenation_exprt.\newline \newline \\param expr Source expression\newline \\return Object of type \\ref concatenation_exprt\newline \newline \\ingroup gr_std_expr\newline \newline","3341265","utils.c","void clear_buffer(char *buffer, int buffer_length){\newline\newline	/* NULL all bytes of buffer */\newline	memset(buffer,&#039\\x0&#039,buffer_length);\newline\newline	return;\newline        }\newline","wipes an area of memory clean \newline","1525098","glm.cpp","void glm::enableTab3()\newline{\newline  if (!tab2_lb2-&gtcount()) {\newline    QMessageBox::information(0, &quotError!&quot, &quotNo TES files selected yet.&quot);\newline    return;\newline  }\newline\newline  //tabSection-&gtsetTabEnabled(tab3, true);\newline  tabSection-&gtsetCurrentPage(2);\newline}\newline","Slot for &quotDONE&quot button: When files are selected, click the button will enable tab3\newline But if no file selected, an error message will pop out. \newline","2680922","qsensorgesture.cpp","void QSensorGesture::startDetection()\newline{\newline    if (d_ptr-&gtm_sensorRecognizers.count() &lt 1)\newline        return;\newline    if (d_ptr-&gtisActive)\newline        return;\newline\newline    Q_FOREACH (QSensorGestureRecognizer *recognizer,  d_ptr-&gtm_sensorRecognizers) {\newline\newline        Q_ASSERT(recognizer !=0);\newline\newline        connect(recognizer,SIGNAL(detected(QString)),\newline                this,SIGNAL(detected(QString)),Qt::UniqueConnection);\newline\newline        //connect recognizer signals\newline        Q_FOREACH (QString method, recognizer-&gtgestureSignals()) {\newline            method.prepend(QLatin1String(&quot2&quot));\newline            connect(recognizer, method.toLatin1(),\newline                    this, method.toLatin1(), Qt::UniqueConnection);\newline        }\newline\newline        recognizer-&gtstartBackend();\newline    }\newline    d_ptr-&gtisActive = true;\newline}\newline","!\newlineStarts the gesture detection routines in the recognizer.\newline \newline","2789685","gserialized_gist_nd.c","static void gidx_dimensionality_check(GIDX **a, GIDX **b)\newline{		\newline	if ( GIDX_NDIMS(*a) &lt GIDX_NDIMS(*b) )\newline	{\newline		GIDX *tmp = *b;\newline		*b = *a;\newline		*a = tmp;\newline	}\newline}\newline","Ensure the first argument has the higher dimensionality. \newline","4169750","rc.c","char * rc_get_path(char * package)\newline{\newline    const char * rc_name = &quotoptions&quot;\newline    char * path;\newline    char * dirname = NULL;\newline    char * filename = NULL;\newline    int length = 0;\newline\newline    /* find the base path */\newline    if (!(path=getenv(&quotHOME&quot))) {\newline        fprintf(stderr,_(&quotCannot find your &#039HOME&#039 environment variable.\\n&quot));\newline        path=&quot.&quot; /* default to current directory */\newline    }\newline\newline    /* create directory name */\newline    length=strlen(path)+strlen(package)+3; /* &quot/&quot, &quot.&quot, and NULL */\newline    if (!(dirname=(char*)malloc(length))) {\newline            perror(&quotmalloc&quot);\newline            return NULL;\newline    }\newline    sprintf(dirname,&quot%s/.%s&quot,path,package);\newline\newline    /* check for the package directory */\newline    if (access(dirname,W_OK)) {\newline        if (errno==ENOENT) {\newline            /* doesn&#039t exist: make it */\newline            if (mkdir(dirname,0700)) {\newline                perror(dirname);\newline                goto need_free;\newline            }\newline        }\newline        else {\newline            perror(dirname);\newline            goto need_free;\newline        }\newline    }\newline\newline    length=strlen(dirname)+strlen(rc_name)+2; /* need &quot/&quot and NULL */\newline    if (!(filename=(char*)malloc(length))) {\newline        perror(&quotmalloc&quot);\newline        goto need_free;\newline    }\newline    sprintf(filename,&quot%s/%s&quot,dirname,rc_name);\newline\newlineneed_free:\newline    free(dirname);\newline    return filename;\newline}\newline","\newline Figure out the rc file&#039s path name.\newline Caller must free the allocated filename.\newline \newline","738388","aj_crypto_field_p256.c","boolean_t fpvalidate_p256(digit256_tc a)\newline{\newline    AJ_ASSERT(a != NULL);\newline    return validate_256(a, P256_MODULUS);\newline}\newline","Validate that a 256-bit value is in [0, P256_MODULUS-1]\newline Returns = B_TRUE if 0 &lt= a &lt modulus, else returns B_FALSE. \newline","2194609","disconnect_manager.cpp","void disconnect_manager::end_process()\newline{\newline	debugQt(&quotdisconnect_manager::end_process()&quot);\newline	deleteLater (); // delete this object\newline}\newline","\newline Process ending\newline \newline","","","","","","","","","","","","","","on","on","","","on","","on","","","","","on","","","","","","","","","","","","","","","","","","start monitoring lost seconds","Read temperature register","Get file file status","Backtrack through the decision tree","runs the given application and waits for the process to finish","Cast a generic exprt to a \ref concatenation_exprt","wipes an area of memory clean","will enable tab3","Starts the gesture detection routines","Ensure the first argument has the higher dimensionality.","Figure out the rc file's path name.","get a valid address from the command buffer","Validate that a 256-bit value is in [0, P256_MODULUS-1]","{}","{}","Logs log message","Given a virtual fd returns an OS handle","{}","Do an integer to string conversion.","{}","Clear the HANDLE_FLAG_INHERIT flag from all HANDLEs"
"3A520CCNWN02HTHYO7MZ0U52CB7EAJ","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3AZHRG4CU4K5T20CXNDBHGLHSO630V","AVC62JNYAXA45","Approved","Wed Apr 17 14:07:39 PDT 2019","Wed Apr 17 14:14:53 PDT 2019","Fri Apr 19 14:14:53 PDT 2019","2019-04-19 21:15:25 UTC","","","434","100% (24/24)","100% (24/24)","100% (24/24)","813097","webkitwebframe.cpp","void webkit_web_frame_load_request(WebKitWebFrame* frame, WebKitNetworkRequest* request)\newline{\newline    g_return_if_fail(WEBKIT_IS_WEB_FRAME(frame));\newline    g_return_if_fail(WEBKIT_IS_NETWORK_REQUEST(request));\newline\newline    Frame* coreFrame = core(frame);\newline    if (!coreFrame)\newline        return;\newline\newline    coreFrame-&gtloader()-&gtload(FrameLoadRequest(coreFrame-&gtdocument()-&gtsecurityOrigin(), core(request)));\newline}\newline","\newline webkit_web_frame_load_request:\newline @frame: a #WebKitWebFrame\newline @request: a #WebKitNetworkRequest\newline \newline Connects to a given URI by initiating an asynchronous client request.\newline \newline Creates a provisional data source that will transition to a committed data\newline source once any data has been received. Use webkit_web_frame_stop_loading() to\newline stop the load. This function is typically invoked on the main frame.\newline \newline","5108683","statement.c","void exec_statements(byte *lp) {\newline  basicvars.current = lp;\newline  do {	/* This is the main statement execution loop */\newline    (*statements[*basicvars.current])();	/* Dispatch a statement */\newline  } while (TRUE);\newline}\newline","\newline &#039exec_statements&#039 deals with the statements in either a procedure\newline or the main program\newline \newline","4358779","genimp_io.c","int _dxf_gi_read_file(void **XF,FILE **fp)\newline{\newline  int size,s,nitems,i,f;\newline\newline  /* \newline   * DXRead the raw data into the XF[i].\newline   */\newline  if(!(_dxf_gi_importDatafile(XF,fp)))\newline    goto error;\newline\newline  /*size = _dxfnumGridPoints();*/ \newline\newline  /* \newline   * Change the majority if the input data is in column majority order. \newline   */\newline  if ( _dxd_gi_majority == COL ) {\newline    for (s=i=0 ; i&lt_dxd_gi_series ; i++, s+=_dxd_gi_numflds) {\newline	for (f=0 ; f&lt_dxd_gi_numflds ; f++) {\newline	    size = _dxfnumGridPoints(f); \newline	    if (XF[s+f]) {\newline                XF[s+f] = reorderData(XF[s+f],f);\newline		if (!XF[s+f])\newline            		goto error;\newline	    }\newline	}\newline    }\newline  }\newline\newline  /* \newline   * Change the byte order if necessary. \newline   */\newline  if ((_dxd_gi_format == BINARY) &amp&amp \newline      (_dxfLocalByteOrder() != _dxd_gi_byteorder)) {\newline	for (f=0 ; f&lt_dxd_gi_numflds ; f++) {\newline	    if (_dxd_gi_whichflds[f]  == ON) {\newline	        size = _dxfnumGridPoints(f); \newline	        nitems = size * _dxd_gi_var[f]-&gtdatadim;\newline	        for (s=i=0 ; i&lt_dxd_gi_series ; i++, s+=_dxd_gi_numflds) \newline		    if ((_dxd_gi_whichser[i] == ON)  &amp&amp\newline	            	!_dxfByteSwap(XF[s+f], XF[s+f], \newline				nitems, _dxd_gi_var[f]-&gtdatatype))\newline			goto error;\newline	    }\newline	}\newline  }\newline\newline#if !defined(DXD_STANDARD_IEEE)\newline  /* \newline   * Denormalize the IEEE floating point numbers. \newline   */\newline   _dxfdenormalize(XF);\newline#endif /* !normal ieee */\newline\newline  /*\newline   * If user has used the &#039locations&#039 keyword and the locations are \newline   * not type float, then convert them to floats. \newline   * Note that if we convert, then we free the old array.\newline   */\newline    if ((_dxd_gi_positions == FIELD_PRODUCT) &amp&amp \newline	(_dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype != TYPE_FLOAT)) {\newline	int nfloats=0;\newline	Type ltype;\newline        size = _dxfnumGridPoints(_dxd_gi_loc_index); \newline	nfloats = _dxd_gi_var[_dxd_gi_loc_index]-&gtdatadim * size;\newline	ltype = _dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype;\newline	for (s=0 ; s&lt_dxd_gi_series ; s++) {\newline	    if (_dxd_gi_whichser[s] == ON) {\newline		Pointer new_XF;\newline	        i = s*_dxd_gi_numflds + _dxd_gi_loc_index;\newline		new_XF = locations2float( XF[i], ltype, nfloats);\newline		if (!new_XF) goto error;\newline		DXFree(XF[i]);\newline		XF[i] = new_XF;\newline       	    }\newline	}\newline	_dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype = TYPE_FLOAT;\newline	_dxd_gi_var[_dxd_gi_loc_index]-&gtdatabytes = DXTypeSize(TYPE_FLOAT);\newline   }\newline\newline   return OK;\newline\newlineerror:\newline  return ERROR;\newline}\newline","\newline DXRead the data file as specified by the general import file.\newline The data for series s and field f is placed in the buffer pointed\newline to by XF[s _dxd_gi_numflds + f]. After reading in the raw data from the\newline file, we must\newline 1) Change column majority data to row majority.\newline 2) DXSwap byte order if they differ and it was binary data.\newline 3) Denormalize floating point data for the PVS.\newline So what is a returned in each XF[i] buffer is the data for each field\newline of each requested series, in the correct majority and byte order.\newline \newline See genimp.c:import_Group for a discussion of XF.\newline \newline","2186587","theta.c","int SetThetaData(DSDP dsdp, SDPCone sdpcone, int nodes, int edges, EdgeMat Edge[]){\newline\newline  int i,info;\newline\newline  /* Create data matrices -  these are all custom types */\newline\newline  /* The c matrix has all elements equal to 1.0 */\newline  info=OneMatOpsInitialize(&amponematops);\newline  info=SDPConeAddDataMatrix(sdpcone,0,0,nodes,&#039P&#039,&amponematops,0);\newline\newline  /* For each edge connecting nodes i and j, X(i,j)=X(j,i)=0 */\newline  info=EdgeMatOperationsInitialize(&ampedgematop);\newline  for (i=0; i&ltedges; i++){\newline    info = SDPConeAddDataMatrix(sdpcone,0,i+1,nodes,&#039P&#039,&ampedgematop,(void*)&ampEdge[i]);\newline    info = DSDPSetDualObjective(dsdp,i+1,0.0);\newline    info = DSDPSetY0(dsdp,i+1,0.0);\newline    if (info) return info; \newline  }\newline\newline  /* The trace of X must equal 1.0 */\newline  info = IdentitymatOperationsInitialize(&ampidentitymatops);\newline  info = SDPConeAddDataMatrix(sdpcone,0,edges+1,nodes,&#039P&#039,&ampidentitymatops,0);\newline  info = DSDPSetDualObjective(dsdp,edges+1,1.0);\newline  info = DSDPSetY0(dsdp,edges+1,-10*nodes-1);\newline\newline  /* The initial point y is feasible and near the central path */\newline  info = DSDPSetR0(dsdp,0);\newline  \newline  return(0);\newline}\newline","!\newline\\fn int SetThetaData(DSDP dsdp, SDPCone sdpcone, int nodes, int edges, EdgeMat Edge[]);\newline\\param dsdp the solver\newline\\param sdpcone the semidefinite cone\newline\\param nodes number of nodes in graph\newline\\param edges number of edges in graph\newline\\param Edge edges in graph\newline\\brief Given a graph, formulate Lovasz problem and set data.\newline\\ingroup Examples\newline\\sa LovaszTheta\newline \newline","4378135","cdebconf_gtk.c","static int cdebconf_gtk_initialize(struct frontend * fe,\newline                                   struct configuration * conf)\newline{\newline    /* INFO(INFO_DEBUG, &quotGTK_DI - gtk_initialize() called&quot); */\newline    gdk_threads_init();\newline    gtk_init(NULL /* no argc */, NULL /* no argv */);\newline\newline    if (!create_frontend_data(fe)) {\newline        g_critical(&quotcreate_frontend_data failed.&quot);\newline        goto failed;\newline    }\newline    if (!cdebconf_gtk_create_main_window(fe)) {\newline        g_critical(&quotcdebconf_gtk_create_main_window failed.&quot);\newline        goto failed;\newline    }\newline    fe-&gtinteractive = TRUE;\newline\newline#ifdef DI_UDEB\newline    if (!cdebconf_gtk_di_setup(fe)) {\newline        g_critical(&quotcdebconf_gtk_di_setup failed.&quot);\newline        goto failed;\newline    }\newline#endif /* DI_UDEB */\newline\newline    /* XXX: here? */\newline    show_main_window(fe);\newline\newline    if (!create_event_listener_thread(fe)) {\newline        g_critical(&quotcreate_event_listener_thread failed.&quot);\newline        goto failed;\newline    }\newline\newline    return DC_OK;\newline\newlinefailed:\newline    cdebconf_gtk_shutdown(fe);\newline    return DC_NOTOK;\newline}\newline","Implements the initialize method of cdebconf frontends.\newline \newline This will initialize the GTK+ frontend data, the GTK+ window and common\newline widgets and forks the event handling thread.\newline \newline @return DC_OK if initialization goes fine, DC_NOTOK if something went wrong\newline \newline","5981039","cli_port.c","boolean_t cli_str_to_uint64(char *str, gtm_uint64_t *dst)\newline{\newline	gtm_uint64_t	result;\newline	int		save_errno;\newline\newline	save_errno = errno;\newline	errno = 0;\newline        result = STRTOU64L(str, NULL, 10);\newline	if ((ERANGE == errno &amp&amp GTM_UINT64_MAX == result) || (0 == result &amp&amp 0 != errno))\newline	{	/* out of range or other error */\newline		*dst = 0;\newline		errno = save_errno;\newline		return FALSE;\newline	} else\newline	{\newline		*dst = result;\newline		errno = save_errno;\newline		return TRUE;\newline	}\newline}\newline","\newline --------------------------------------------------\newline Convert string to 64 bit unsigned int.\newline \newline Return:\newline TRUE - OK\newline FALSE - Could not convert to int\newline --------------------------------------------------\newline \newline","1418744","st04c.c","void get_2d_array(\newline    float *array,\newline    long latlen,\newline    long lonlen,\newline    int fid,\newline    int aid,\newline    long timestep                  \newline)\newline{\newline    long start[3], count[3];\newline\newline    start[0] = timestep;\newline    start[1] = start[2] = 0;\newline    count[0] = 1; count[1] = latlen; count[2] = lonlen;\newline    ncvarget(fid,aid,(long const *)start,(long const *)count,array);\newline    return;\newline}\newline","\newline function for reading in 3-d array from netCDF\newline file and converting it to a 2-d array.\newline \newline","1783367","sv_world.c","void SV_UnlinkEdict (edict_t *ent)\newline{\newline	if (!ent-&gtarea.prev)\newline		return;		// not linked in anywhere\newline	RemoveLink (&ampent-&gtarea);\newline	ent-&gtarea.prev = ent-&gtarea.next = NULL;\newline}\newline","\newline===============\newlineSV_UnlinkEdict\newline===============\newline \newline","6375487","info.c","char *format_info(struct info *info) {\newline    const char *fname;\newline    char *result = NULL;\newline    int r = 0;\newline\newline    if (info == NULL) {\newline        return strdup(&quot(no file info)&quot);\newline    }\newline\newline    int fl = info-&gtfirst_line, ll = info-&gtlast_line;\newline    int fc = info-&gtfirst_column, lc = info-&gtlast_column;\newline    fname = (info-&gtfilename != NULL) ? info-&gtfilename-&gtstr : &quot(unknown file)&quot;\newline\newline    if (fl &gt 0) {\newline        if (fl == ll) {\newline            if (fc == lc) {\newline                r = xasprintf(&ampresult, &quot%s:%d.%d:&quot, fname, fl, fc);\newline            } else {\newline                r = xasprintf(&ampresult, &quot%s:%d.%d-.%d:&quot, fname, fl, fc, lc);\newline            }\newline        } else {\newline            r = xasprintf(&ampresult, &quot%s:%d.%d-%d.%d:&quot, fname, fl, fc, ll, lc);\newline        }\newline    } else {\newline        r = xasprintf(&ampresult, &quot%s:&quot, fname);\newline    }\newline    return (r == -1) ? NULL : result;\newline}\newline","\newline struct info\newline \newline","3295747","nsp_cs.c","static int nsphw_init(nsp_hw_data *data)\newline{\newline	unsigned int base     = data-&gtBaseAddress;\newline\newline	DEBUG(0, &quot%s: in base=0x%x\\n&quot, __FUNCTION__, base);\newline\newline	data-&gtScsiClockDiv = CLOCK_40M | FAST_20;\newline	data-&gtCurrentSC    = NULL;\newline	data-&gtFifoCount    = 0;\newline	data-&gtTransferMode = MODE_IO8;\newline\newline	nsphw_init_sync(data);\newline\newline	/* block all interrupts */\newline	nsp_write(base,	      IRQCONTROL,   IRQCONTROL_ALLMASK);\newline\newline	/* setup SCSI interface */\newline	nsp_write(base,	      IFSELECT,	    IF_IFSEL);\newline\newline	nsp_index_write(base, SCSIIRQMODE,  0);\newline\newline	nsp_index_write(base, TRANSFERMODE, MODE_IO8);\newline	nsp_index_write(base, CLOCKDIV,	    data-&gtScsiClockDiv);\newline\newline	nsp_index_write(base, PARITYCTRL,   0);\newline	nsp_index_write(base, POINTERCLR,   POINTER_CLEAR     |\newline					    ACK_COUNTER_CLEAR |\newline					    REQ_COUNTER_CLEAR |\newline					    HOST_COUNTER_CLEAR);\newline\newline	/* setup fifo asic */\newline	nsp_write(base,	      IFSELECT,	    IF_REGSEL);\newline	nsp_index_write(base, TERMPWRCTRL,  0);\newline	if ((nsp_index_read(base, OTHERCONTROL) &amp TPWR_SENSE) == 0) {\newline		printk(KERN_INFO &quotnsp_cs: terminator power on\\n&quot);\newline		nsp_index_write(base, TERMPWRCTRL, POWER_ON);\newline	}\newline\newline	nsp_index_write(base, TIMERCOUNT,   0);\newline	nsp_index_write(base, TIMERCOUNT,   0); /* requires 2 times!! */\newline\newline	nsp_index_write(base, SYNCREG,	    0);\newline	nsp_index_write(base, ACKWIDTH,	    0);\newline\newline	/* enable interrupts and ack them */\newline	nsp_index_write(base, SCSIIRQMODE,  SCSI_PHASE_CHANGE_EI |\newline					    RESELECT_EI		 |\newline					    SCSI_RESET_IRQ_EI	 );\newline	nsp_write(base,	      IRQCONTROL,   IRQCONTROL_ALLCLEAR);\newline\newline	nsp_setup_fifo(data, FALSE);\newline\newline	return TRUE;\newline}\newline","\newline Initialize Ninja hardware\newline \newline","6483857","ocproxy.c","static err_t lwip_data_out(struct netif *netif, struct pbuf *p, ip_addr_t *ipaddr)\newline{\newline	struct ocp_sock *s = netif-&gtstate;\newline	int i = 0, total = 0;\newline	ssize_t ret;\newline	struct iovec iov[MAX_IOVEC];\newline\newline	if (tcpdump_enabled)\newline		tcpdump(p);\newline\newline	for (; p; p = p-&gtnext) {\newline		if (i &gt= MAX_IOVEC) {\newline			warn(&quot%s: too many chunks, dropping packet\\n&quot, __func__);\newline			return ERR_OK;\newline		}\newline		iov[i].iov_base = p-&gtpayload;\newline		iov[i++].iov_len = p-&gtlen;\newline		total += p-&gtlen;\newline	}\newline\newline	ret = writev(s-&gtfd, iov, i);\newline	if (ret &lt 0) {\newline		if (errno == ECONNREFUSED || errno == ENOTCONN)\newline			vpn_conn_down();\newline		else\newline			LINK_STATS_INC(link.drop);\newline	} else if (ret != total)\newline		LINK_STATS_INC(link.lenerr);\newline	else\newline		LINK_STATS_INC(link.xmit);\newline\newline	return ERR_OK;\newline}\newline","Called when lwIP has data to send up to the VPN \newline","2914477","bug-2803.c","static int do_test( struct timeval timetv, struct timeval tvlast )\newline{\newline	struct timeval tvdiff_old;\newline	struct timeval tvdiff_new;\newline\newline	int cond_old;\newline	int cond_new;\newline	int failed;\newline\newline	cond_old = 0;\newline	cond_new = 0;\newline\newline	// Here is the old code:\newline	tvdiff_old = abs_tval(sub_tval(timetv, tvlast));\newline	if (tvdiff_old.tv_sec &gt 0) {\newline		cond_old = 1;\newline	}\newline\newline	// Here is the new code:\newline	tvdiff_new = sub_tval(timetv, tvlast);\newline	if (tvdiff_new.tv_sec != 0) {\newline		cond_new = 1;\newline	}\newline\newline	failed = cond_new != cond_old;\newline\newline	if ( failed || verbose )\newline		printf( &quottimetv %lli|%07li, tvlast  %lli|%07li: tvdiff_old: %lli|%07li -&gt %i, tvdiff_new: %lli|%07li -&gt %i, same cond: %s\\n&quot,\newline			(long long) timetv.tv_sec, timetv.tv_usec,\newline			(long long) tvlast.tv_sec, tvlast.tv_usec,\newline			(long long) tvdiff_old.tv_sec, tvdiff_old.tv_usec, cond_old,\newline			(long long) tvdiff_new.tv_sec, tvdiff_new.tv_usec, cond_new,\newline			failed ? &quotNO &lt&lt&quot : &quotyes&quot );\newline\newline	return failed ? -1 : 0;\newline}\newline","\newline Test function calling the old and new code mentioned in\newline http://bugs.ntp.org/show_bug.cgi?id=2803#c22\newline \newline","2748895","pth_time.c","intern void pth_time_usleep(unsigned long usec)\newline{\newline#ifdef HAVE_USLEEP\newline    usleep((unsigned int )usec);\newline#else\newline    struct timeval timeout;\newline    timeout.tv_sec  = usec / 1000000;\newline    timeout.tv_usec = usec - (1000000 * timeout.tv_sec);\newline    while (pth_sc(select)(1, NULL, NULL, NULL, &amptimeout) &lt 0 &amp&amp errno == EINTR) ;\newline#endif\newline    return;\newline}\newline","sleep for a specified amount of microseconds \newline","2311863","vncbaseframebuffer.c","VncBaseFramebuffer *vnc_base_framebuffer_new(guint8 *buffer,\newline                                             guint16 width,\newline                                             guint16 height,\newline                                             int rowstride,\newline                                             const VncPixelFormat *localFormat,\newline                                             const VncPixelFormat *remoteFormat)\newline{\newline    return VNC_BASE_FRAMEBUFFER(g_object_new(VNC_TYPE_BASE_FRAMEBUFFER,\newline                                             &quotbuffer&quot, buffer,\newline                                             &quotwidth&quot, width,\newline                                             &quotheight&quot, height,\newline                                             &quotrowstride&quot, rowstride,\newline                                             &quotlocal-format&quot, localFormat,\newline                                             &quotremote-format&quot, remoteFormat,\newline                                             NULL));\newline}\newline","\newline vnc_base_framebuffer_new:\newline @buffer: (array): the buffer representing the screen\newline @width: the width of the screen\newline @height: the height of the screen\newline @rowstride: the number of bytes per line in @buffer\newline @localFormat: the format for data stored in @buffer\newline @remoteFormat: the format for data before storage in @buffer\newline \newline Allocate a new general purpose framebuffer object storing\newline screen updates in @buffer. @buffer must be @height \newline @rowstride bytes in size. The returned object will\newline store a pointer to @buffer, so it should not be free&#039d\newline for as long as the framebuffer object exists\newline \newline Returns: (transfer full): the new framebuffer\newline \newline","3352638","simutil.c","gboolean ber_tlv_builder_set_length(struct ber_tlv_builder *builder,\newline					unsigned int new_len)\newline{\newline	unsigned int new_pos = builder-&gtpos + MAX_BER_TLV_HEADER + new_len;\newline\newline	if (new_pos &gt builder-&gtmax)\newline		return FALSE;\newline\newline	if (builder-&gtparent)\newline		ber_tlv_builder_set_length(builder-&gtparent, new_pos);\newline\newline	builder-&gtlen = new_len;\newline\newline	return TRUE;\newline}\newline","\newline Resize the TLV because the content of Value field needs more space.\newline If this TLV is part of another TLV, resize that one too.\newline \newline","3733235","bindings.c","static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)\newline{\newline	struct cgfs_files *k = NULL;\newline	bool ret = false;\newline\newline	k = cgfs_get_key(contrl, cg, file);\newline	if (!k)\newline		return false;\newline\newline	if (is_privileged_over(fc-&gtpid, fc-&gtuid, k-&gtuid, NS_ROOT_OPT)) {\newline		if (perms_include(k-&gtmode &gt&gt 6, mode)) {\newline			ret = true;\newline			goto out;\newline		}\newline	}\newline	if (fc-&gtgid == k-&gtgid) {\newline		if (perms_include(k-&gtmode &gt&gt 3, mode)) {\newline			ret = true;\newline			goto out;\newline		}\newline	}\newline	ret = perms_include(k-&gtmode, mode);\newline\newlineout:\newline	free_key(k);\newline	return ret;\newline}\newline","\newline check whether a fuse context may access a cgroup dir or file\newline \newline If file is not null, it is a cgroup file to check under cg.\newline If file is null, then we are checking perms on cg itself.\newline \newline For files we can check the mode of the list_keys result.\newline For cgroups, we must make assumptions based on the files under the\newline cgroup, because cgmanager doesn&#039t tell us ownership/perms of cgroups\newline yet.\newline \newline","782393","procedural.cpp","TqPopenStream* CqRunProgramRepository::startNewRunProgram(\newline		const std::string&amp command)\newline{\newline	// Get the program name and command line arguments.\newline	std::vector&ltstd::string&gt argv;\newline	splitCommandLine(command, argv);\newline	if(argv.empty())\newline		AQSIS_THROW_XQERROR(XqValidation, EqE_BadToken, &quotprogram name not present&quot);\newline	// Attempt to find the program in the procedural path\newline	std::string progName = native(QGetRenderContext()-&gtpoptCurrent()\newline		-&gtfindRiFileNothrow(argv[0], &quotprocedural&quot));\newline	if(progName.empty())\newline	{\newline		progName = argv[0];\newline		Aqsis::log() &lt&lt info\newline			&lt&lt &quotRiProcRunProgram: Could not find \\&quot&quot &lt&lt progName\newline			&lt&lt &quot\\&quot in \\&quotprocedural\\&quot searchpath, will rely on system path.\\n&quot;\newline	}\newline	try\newline	{\newline		// Attempt to open a pipe to the new procedural.\newline		TqPopenStreamPtr newPipe(new TqPopenStream(progName, argv));\newline		newPipe-&gtexceptions(std::ios::badbit | std::ios::failbit | std::ios::eofbit);\newline		m_activeRunPrograms.insert(std::make_pair(command, newPipe));\newline		return newPipe.get();\newline	}\newline	catch(XqEnvironment&amp e)\newline	{\newline		// Install a null pointer to indicate that we shouldn&#039t try to run this\newline		// procedural again, and rethrow.\newline		m_activeRunPrograms.insert(std::make_pair(command, TqPopenStreamPtr()));\newline		AQSIS_THROW_XQERROR(XqEnvironment, e.code(),\newline			&quoterror starting runprogram [&quot &lt&lt command &lt&lt &quot] : &quot &lt&lt e.what() );\newline	}\newline}\newline","\\brief Start a new child process for the given RunProgram command\newline \newline","4196230","r_analysis.c","static VALUE frb_get_locale(VALUE self, VALUE locale)\newline{\newline    return (frb_locale ? rb_str_new2(frb_locale) : Qnil);\newline}\newline","\newline call-seq:\newline Ferret.locale -&gt locale_str\newline \newline Returns a string corresponding to the locale set. For example;\newline \newline puts Ferret.locale #=&gt &quoten_US.UTF-8&quot\newline \newline","3062449","libtelnet.c","void telnet_free(telnet_t *telnet) {\newline	/* free sub-request buffer */\newline	if (telnet-&gtbuffer != 0) {\newline		free(telnet-&gtbuffer);\newline		telnet-&gtbuffer = 0;\newline		telnet-&gtbuffer_size = 0;\newline		telnet-&gtbuffer_pos = 0;\newline	}\newline\newline#if defined(HAVE_ZLIB)\newline	/* free zlib box */\newline	if (telnet-&gtz != 0) {\newline		if (telnet-&gtflags &amp TELNET_PFLAG_DEFLATE)\newline			deflateEnd(telnet-&gtz);\newline		else\newline			inflateEnd(telnet-&gtz);\newline		free(telnet-&gtz);\newline		telnet-&gtz = 0;\newline	}\newline#endif /* defined(HAVE_ZLIB) */\newline\newline	/* free RFC1143 queue */\newline	if (telnet-&gtq) {\newline		free(telnet-&gtq);\newline		telnet-&gtq = 0;\newline		telnet-&gtq_size = 0;\newline	}\newline\newline	/* free the telnet structure itself */\newline	free(telnet);\newline}\newline","free up any memory allocated by a state tracker \newline","218319","fcd.c","EXTERN FCD_MODE_ENUM fcdAppReset(void)\newline{\newline    hid_device *phd=NULL;\newline    //unsigned char aucBufIn[65];\newline    unsigned char aucBufOut[65];\newline\newline    phd = fcdOpen();\newline\newline    if (phd == NULL)\newline    {\newline        return FCD_MODE_NONE;\newline    }\newline\newline    // Send an App reset command\newline    aucBufOut[0] = 0; // Report ID, ignored\newline    aucBufOut[1] = FCD_CMD_APP_RESET;\newline    hid_write(phd, aucBufOut, 65);\newline\newline    /** FIXME: hid_read() will occasionally hang due to a pthread_cond_wait() never returning.\newline        It seems that the read_callback() in hid-libusb.c will never receive any\newline        data during the reconfiguration. Since the same logic works in the native\newline        windows application, it could be a libusb thing. Anyhow, since the value\newline        returned by this function is not used, we may as well just skip the hid_read()\newline        and return FME_NONE.\newline        Correct switch from APP to BL mode can be observed in /var/log/messages (linux)\newline        (when in bootloader mode the device version includes &#039BL&#039)\newline    */\newline    /*\newline    memset(aucBufIn,0xCC,65); // Clear out the response buffer\newline    hid_read(phd,aucBufIn,65);\newline\newline    if (aucBufIn[0]==FCDCMDAPPRESET &amp&amp aucBufIn[1]==1)\newline    {\newline        FCDClose(phd);\newline        phd=NULL;\newline        return FME_APP;\newline    }\newline    FCDClose(phd);\newline    phd=NULL;\newline    return FME_BL;\newline    */\newline\newline    fcdClose(phd);\newline    phd = NULL;\newline\newline    return FCD_MODE_NONE;\newline\newline}\newline","\\brief Reset FCD to bootloader mode.\newline \\return FCD_MODE_NONE\newline \newline This function is used to switch the FCD into bootloader mode in which\newline various firmware operations can be performed.\newline \newline","501410","lexer.c","int lexer_read_filename_recursive(struct lexer_book *bk)\newline{\newline	int count = lexer_read_escaped_until(bk, FILENAME_LIMITS);\newline\newline	if(count &lt 1)\newline		return count;\newline\newline	if(lexer_next_peek(bk) == &#039-&#039 &amp&amp !lexer_peek_remote_rename_syntax(bk)) {\newline		lexer_add_to_lexeme(bk, &#039-&#039);\newline		count++;\newline		count += lexer_read_filename_recursive(bk);\newline	}\newline\newline	return count;\newline}\newline","Read a filename, adding &#039-&#039 to names when - is not followed by\newline&gt. The &#039recursive&#039 comes because the function calls itself when\newlinecompleting a name when it added a -. \newline","","","on","on","","","","","","","","","","","","on","","","","on","on","on","","","","","","","","","","","","","on","","","","","on","","","Connects to a given URI by initiating an asynchronous client request.","Initialize Ninja hardware","{}","{}","sleep for a specified amount of microseconds","Allocate a new general purpose framebuffer object storingscreen updates","Resize the TLV","check whether a fuse context may access a cgroup dir or file","Start a new child process for the given RunProgram command","Returns a string corresponding to the locale set.","free up any memory allocated by a state tracker","deals with the statements in either a procedureor the main program","switch the FCD into bootloader mode","Read a filename, adding '-' to names","DXRead the data file","{}","Implements the initialize method of cdebconf frontends.","Convert string to 64 bit unsigned int.","reading in 3-d array from netCDFfile and converting it","{}","{}"
"3A520CCNWN02HTHYO7MZ0U52CB7EAJ","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3VNXK88KKCI715Q8HT2ATMETMDN9V6","AMD1LYNQAH3R8","Approved","Wed Apr 17 16:08:39 PDT 2019","Wed Apr 17 16:15:19 PDT 2019","Fri Apr 19 16:15:19 PDT 2019","2019-04-19 23:15:21 UTC","","","400","100% (27/27)","100% (27/27)","100% (27/27)","813097","webkitwebframe.cpp","void webkit_web_frame_load_request(WebKitWebFrame* frame, WebKitNetworkRequest* request)\newline{\newline    g_return_if_fail(WEBKIT_IS_WEB_FRAME(frame));\newline    g_return_if_fail(WEBKIT_IS_NETWORK_REQUEST(request));\newline\newline    Frame* coreFrame = core(frame);\newline    if (!coreFrame)\newline        return;\newline\newline    coreFrame-&gtloader()-&gtload(FrameLoadRequest(coreFrame-&gtdocument()-&gtsecurityOrigin(), core(request)));\newline}\newline","\newline webkit_web_frame_load_request:\newline @frame: a #WebKitWebFrame\newline @request: a #WebKitNetworkRequest\newline \newline Connects to a given URI by initiating an asynchronous client request.\newline \newline Creates a provisional data source that will transition to a committed data\newline source once any data has been received. Use webkit_web_frame_stop_loading() to\newline stop the load. This function is typically invoked on the main frame.\newline \newline","5108683","statement.c","void exec_statements(byte *lp) {\newline  basicvars.current = lp;\newline  do {	/* This is the main statement execution loop */\newline    (*statements[*basicvars.current])();	/* Dispatch a statement */\newline  } while (TRUE);\newline}\newline","\newline &#039exec_statements&#039 deals with the statements in either a procedure\newline or the main program\newline \newline","4358779","genimp_io.c","int _dxf_gi_read_file(void **XF,FILE **fp)\newline{\newline  int size,s,nitems,i,f;\newline\newline  /* \newline   * DXRead the raw data into the XF[i].\newline   */\newline  if(!(_dxf_gi_importDatafile(XF,fp)))\newline    goto error;\newline\newline  /*size = _dxfnumGridPoints();*/ \newline\newline  /* \newline   * Change the majority if the input data is in column majority order. \newline   */\newline  if ( _dxd_gi_majority == COL ) {\newline    for (s=i=0 ; i&lt_dxd_gi_series ; i++, s+=_dxd_gi_numflds) {\newline	for (f=0 ; f&lt_dxd_gi_numflds ; f++) {\newline	    size = _dxfnumGridPoints(f); \newline	    if (XF[s+f]) {\newline                XF[s+f] = reorderData(XF[s+f],f);\newline		if (!XF[s+f])\newline            		goto error;\newline	    }\newline	}\newline    }\newline  }\newline\newline  /* \newline   * Change the byte order if necessary. \newline   */\newline  if ((_dxd_gi_format == BINARY) &amp&amp \newline      (_dxfLocalByteOrder() != _dxd_gi_byteorder)) {\newline	for (f=0 ; f&lt_dxd_gi_numflds ; f++) {\newline	    if (_dxd_gi_whichflds[f]  == ON) {\newline	        size = _dxfnumGridPoints(f); \newline	        nitems = size * _dxd_gi_var[f]-&gtdatadim;\newline	        for (s=i=0 ; i&lt_dxd_gi_series ; i++, s+=_dxd_gi_numflds) \newline		    if ((_dxd_gi_whichser[i] == ON)  &amp&amp\newline	            	!_dxfByteSwap(XF[s+f], XF[s+f], \newline				nitems, _dxd_gi_var[f]-&gtdatatype))\newline			goto error;\newline	    }\newline	}\newline  }\newline\newline#if !defined(DXD_STANDARD_IEEE)\newline  /* \newline   * Denormalize the IEEE floating point numbers. \newline   */\newline   _dxfdenormalize(XF);\newline#endif /* !normal ieee */\newline\newline  /*\newline   * If user has used the &#039locations&#039 keyword and the locations are \newline   * not type float, then convert them to floats. \newline   * Note that if we convert, then we free the old array.\newline   */\newline    if ((_dxd_gi_positions == FIELD_PRODUCT) &amp&amp \newline	(_dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype != TYPE_FLOAT)) {\newline	int nfloats=0;\newline	Type ltype;\newline        size = _dxfnumGridPoints(_dxd_gi_loc_index); \newline	nfloats = _dxd_gi_var[_dxd_gi_loc_index]-&gtdatadim * size;\newline	ltype = _dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype;\newline	for (s=0 ; s&lt_dxd_gi_series ; s++) {\newline	    if (_dxd_gi_whichser[s] == ON) {\newline		Pointer new_XF;\newline	        i = s*_dxd_gi_numflds + _dxd_gi_loc_index;\newline		new_XF = locations2float( XF[i], ltype, nfloats);\newline		if (!new_XF) goto error;\newline		DXFree(XF[i]);\newline		XF[i] = new_XF;\newline       	    }\newline	}\newline	_dxd_gi_var[_dxd_gi_loc_index]-&gtdatatype = TYPE_FLOAT;\newline	_dxd_gi_var[_dxd_gi_loc_index]-&gtdatabytes = DXTypeSize(TYPE_FLOAT);\newline   }\newline\newline   return OK;\newline\newlineerror:\newline  return ERROR;\newline}\newline","\newline DXRead the data file as specified by the general import file.\newline The data for series s and field f is placed in the buffer pointed\newline to by XF[s _dxd_gi_numflds + f]. After reading in the raw data from the\newline file, we must\newline 1) Change column majority data to row majority.\newline 2) DXSwap byte order if they differ and it was binary data.\newline 3) Denormalize floating point data for the PVS.\newline So what is a returned in each XF[i] buffer is the data for each field\newline of each requested series, in the correct majority and byte order.\newline \newline See genimp.c:import_Group for a discussion of XF.\newline \newline","2186587","theta.c","int SetThetaData(DSDP dsdp, SDPCone sdpcone, int nodes, int edges, EdgeMat Edge[]){\newline\newline  int i,info;\newline\newline  /* Create data matrices -  these are all custom types */\newline\newline  /* The c matrix has all elements equal to 1.0 */\newline  info=OneMatOpsInitialize(&amponematops);\newline  info=SDPConeAddDataMatrix(sdpcone,0,0,nodes,&#039P&#039,&amponematops,0);\newline\newline  /* For each edge connecting nodes i and j, X(i,j)=X(j,i)=0 */\newline  info=EdgeMatOperationsInitialize(&ampedgematop);\newline  for (i=0; i&ltedges; i++){\newline    info = SDPConeAddDataMatrix(sdpcone,0,i+1,nodes,&#039P&#039,&ampedgematop,(void*)&ampEdge[i]);\newline    info = DSDPSetDualObjective(dsdp,i+1,0.0);\newline    info = DSDPSetY0(dsdp,i+1,0.0);\newline    if (info) return info; \newline  }\newline\newline  /* The trace of X must equal 1.0 */\newline  info = IdentitymatOperationsInitialize(&ampidentitymatops);\newline  info = SDPConeAddDataMatrix(sdpcone,0,edges+1,nodes,&#039P&#039,&ampidentitymatops,0);\newline  info = DSDPSetDualObjective(dsdp,edges+1,1.0);\newline  info = DSDPSetY0(dsdp,edges+1,-10*nodes-1);\newline\newline  /* The initial point y is feasible and near the central path */\newline  info = DSDPSetR0(dsdp,0);\newline  \newline  return(0);\newline}\newline","!\newline\\fn int SetThetaData(DSDP dsdp, SDPCone sdpcone, int nodes, int edges, EdgeMat Edge[]);\newline\\param dsdp the solver\newline\\param sdpcone the semidefinite cone\newline\\param nodes number of nodes in graph\newline\\param edges number of edges in graph\newline\\param Edge edges in graph\newline\\brief Given a graph, formulate Lovasz problem and set data.\newline\\ingroup Examples\newline\\sa LovaszTheta\newline \newline","4378135","cdebconf_gtk.c","static int cdebconf_gtk_initialize(struct frontend * fe,\newline                                   struct configuration * conf)\newline{\newline    /* INFO(INFO_DEBUG, &quotGTK_DI - gtk_initialize() called&quot); */\newline    gdk_threads_init();\newline    gtk_init(NULL /* no argc */, NULL /* no argv */);\newline\newline    if (!create_frontend_data(fe)) {\newline        g_critical(&quotcreate_frontend_data failed.&quot);\newline        goto failed;\newline    }\newline    if (!cdebconf_gtk_create_main_window(fe)) {\newline        g_critical(&quotcdebconf_gtk_create_main_window failed.&quot);\newline        goto failed;\newline    }\newline    fe-&gtinteractive = TRUE;\newline\newline#ifdef DI_UDEB\newline    if (!cdebconf_gtk_di_setup(fe)) {\newline        g_critical(&quotcdebconf_gtk_di_setup failed.&quot);\newline        goto failed;\newline    }\newline#endif /* DI_UDEB */\newline\newline    /* XXX: here? */\newline    show_main_window(fe);\newline\newline    if (!create_event_listener_thread(fe)) {\newline        g_critical(&quotcreate_event_listener_thread failed.&quot);\newline        goto failed;\newline    }\newline\newline    return DC_OK;\newline\newlinefailed:\newline    cdebconf_gtk_shutdown(fe);\newline    return DC_NOTOK;\newline}\newline","Implements the initialize method of cdebconf frontends.\newline \newline This will initialize the GTK+ frontend data, the GTK+ window and common\newline widgets and forks the event handling thread.\newline \newline @return DC_OK if initialization goes fine, DC_NOTOK if something went wrong\newline \newline","5981039","cli_port.c","boolean_t cli_str_to_uint64(char *str, gtm_uint64_t *dst)\newline{\newline	gtm_uint64_t	result;\newline	int		save_errno;\newline\newline	save_errno = errno;\newline	errno = 0;\newline        result = STRTOU64L(str, NULL, 10);\newline	if ((ERANGE == errno &amp&amp GTM_UINT64_MAX == result) || (0 == result &amp&amp 0 != errno))\newline	{	/* out of range or other error */\newline		*dst = 0;\newline		errno = save_errno;\newline		return FALSE;\newline	} else\newline	{\newline		*dst = result;\newline		errno = save_errno;\newline		return TRUE;\newline	}\newline}\newline","\newline --------------------------------------------------\newline Convert string to 64 bit unsigned int.\newline \newline Return:\newline TRUE - OK\newline FALSE - Could not convert to int\newline --------------------------------------------------\newline \newline","1418744","st04c.c","void get_2d_array(\newline    float *array,\newline    long latlen,\newline    long lonlen,\newline    int fid,\newline    int aid,\newline    long timestep                  \newline)\newline{\newline    long start[3], count[3];\newline\newline    start[0] = timestep;\newline    start[1] = start[2] = 0;\newline    count[0] = 1; count[1] = latlen; count[2] = lonlen;\newline    ncvarget(fid,aid,(long const *)start,(long const *)count,array);\newline    return;\newline}\newline","\newline function for reading in 3-d array from netCDF\newline file and converting it to a 2-d array.\newline \newline","1783367","sv_world.c","void SV_UnlinkEdict (edict_t *ent)\newline{\newline	if (!ent-&gtarea.prev)\newline		return;		// not linked in anywhere\newline	RemoveLink (&ampent-&gtarea);\newline	ent-&gtarea.prev = ent-&gtarea.next = NULL;\newline}\newline","\newline===============\newlineSV_UnlinkEdict\newline===============\newline \newline","6375487","info.c","char *format_info(struct info *info) {\newline    const char *fname;\newline    char *result = NULL;\newline    int r = 0;\newline\newline    if (info == NULL) {\newline        return strdup(&quot(no file info)&quot);\newline    }\newline\newline    int fl = info-&gtfirst_line, ll = info-&gtlast_line;\newline    int fc = info-&gtfirst_column, lc = info-&gtlast_column;\newline    fname = (info-&gtfilename != NULL) ? info-&gtfilename-&gtstr : &quot(unknown file)&quot;\newline\newline    if (fl &gt 0) {\newline        if (fl == ll) {\newline            if (fc == lc) {\newline                r = xasprintf(&ampresult, &quot%s:%d.%d:&quot, fname, fl, fc);\newline            } else {\newline                r = xasprintf(&ampresult, &quot%s:%d.%d-.%d:&quot, fname, fl, fc, lc);\newline            }\newline        } else {\newline            r = xasprintf(&ampresult, &quot%s:%d.%d-%d.%d:&quot, fname, fl, fc, ll, lc);\newline        }\newline    } else {\newline        r = xasprintf(&ampresult, &quot%s:&quot, fname);\newline    }\newline    return (r == -1) ? NULL : result;\newline}\newline","\newline struct info\newline \newline","3295747","nsp_cs.c","static int nsphw_init(nsp_hw_data *data)\newline{\newline	unsigned int base     = data-&gtBaseAddress;\newline\newline	DEBUG(0, &quot%s: in base=0x%x\\n&quot, __FUNCTION__, base);\newline\newline	data-&gtScsiClockDiv = CLOCK_40M | FAST_20;\newline	data-&gtCurrentSC    = NULL;\newline	data-&gtFifoCount    = 0;\newline	data-&gtTransferMode = MODE_IO8;\newline\newline	nsphw_init_sync(data);\newline\newline	/* block all interrupts */\newline	nsp_write(base,	      IRQCONTROL,   IRQCONTROL_ALLMASK);\newline\newline	/* setup SCSI interface */\newline	nsp_write(base,	      IFSELECT,	    IF_IFSEL);\newline\newline	nsp_index_write(base, SCSIIRQMODE,  0);\newline\newline	nsp_index_write(base, TRANSFERMODE, MODE_IO8);\newline	nsp_index_write(base, CLOCKDIV,	    data-&gtScsiClockDiv);\newline\newline	nsp_index_write(base, PARITYCTRL,   0);\newline	nsp_index_write(base, POINTERCLR,   POINTER_CLEAR     |\newline					    ACK_COUNTER_CLEAR |\newline					    REQ_COUNTER_CLEAR |\newline					    HOST_COUNTER_CLEAR);\newline\newline	/* setup fifo asic */\newline	nsp_write(base,	      IFSELECT,	    IF_REGSEL);\newline	nsp_index_write(base, TERMPWRCTRL,  0);\newline	if ((nsp_index_read(base, OTHERCONTROL) &amp TPWR_SENSE) == 0) {\newline		printk(KERN_INFO &quotnsp_cs: terminator power on\\n&quot);\newline		nsp_index_write(base, TERMPWRCTRL, POWER_ON);\newline	}\newline\newline	nsp_index_write(base, TIMERCOUNT,   0);\newline	nsp_index_write(base, TIMERCOUNT,   0); /* requires 2 times!! */\newline\newline	nsp_index_write(base, SYNCREG,	    0);\newline	nsp_index_write(base, ACKWIDTH,	    0);\newline\newline	/* enable interrupts and ack them */\newline	nsp_index_write(base, SCSIIRQMODE,  SCSI_PHASE_CHANGE_EI |\newline					    RESELECT_EI		 |\newline					    SCSI_RESET_IRQ_EI	 );\newline	nsp_write(base,	      IRQCONTROL,   IRQCONTROL_ALLCLEAR);\newline\newline	nsp_setup_fifo(data, FALSE);\newline\newline	return TRUE;\newline}\newline","\newline Initialize Ninja hardware\newline \newline","6483857","ocproxy.c","static err_t lwip_data_out(struct netif *netif, struct pbuf *p, ip_addr_t *ipaddr)\newline{\newline	struct ocp_sock *s = netif-&gtstate;\newline	int i = 0, total = 0;\newline	ssize_t ret;\newline	struct iovec iov[MAX_IOVEC];\newline\newline	if (tcpdump_enabled)\newline		tcpdump(p);\newline\newline	for (; p; p = p-&gtnext) {\newline		if (i &gt= MAX_IOVEC) {\newline			warn(&quot%s: too many chunks, dropping packet\\n&quot, __func__);\newline			return ERR_OK;\newline		}\newline		iov[i].iov_base = p-&gtpayload;\newline		iov[i++].iov_len = p-&gtlen;\newline		total += p-&gtlen;\newline	}\newline\newline	ret = writev(s-&gtfd, iov, i);\newline	if (ret &lt 0) {\newline		if (errno == ECONNREFUSED || errno == ENOTCONN)\newline			vpn_conn_down();\newline		else\newline			LINK_STATS_INC(link.drop);\newline	} else if (ret != total)\newline		LINK_STATS_INC(link.lenerr);\newline	else\newline		LINK_STATS_INC(link.xmit);\newline\newline	return ERR_OK;\newline}\newline","Called when lwIP has data to send up to the VPN \newline","2914477","bug-2803.c","static int do_test( struct timeval timetv, struct timeval tvlast )\newline{\newline	struct timeval tvdiff_old;\newline	struct timeval tvdiff_new;\newline\newline	int cond_old;\newline	int cond_new;\newline	int failed;\newline\newline	cond_old = 0;\newline	cond_new = 0;\newline\newline	// Here is the old code:\newline	tvdiff_old = abs_tval(sub_tval(timetv, tvlast));\newline	if (tvdiff_old.tv_sec &gt 0) {\newline		cond_old = 1;\newline	}\newline\newline	// Here is the new code:\newline	tvdiff_new = sub_tval(timetv, tvlast);\newline	if (tvdiff_new.tv_sec != 0) {\newline		cond_new = 1;\newline	}\newline\newline	failed = cond_new != cond_old;\newline\newline	if ( failed || verbose )\newline		printf( &quottimetv %lli|%07li, tvlast  %lli|%07li: tvdiff_old: %lli|%07li -&gt %i, tvdiff_new: %lli|%07li -&gt %i, same cond: %s\\n&quot,\newline			(long long) timetv.tv_sec, timetv.tv_usec,\newline			(long long) tvlast.tv_sec, tvlast.tv_usec,\newline			(long long) tvdiff_old.tv_sec, tvdiff_old.tv_usec, cond_old,\newline			(long long) tvdiff_new.tv_sec, tvdiff_new.tv_usec, cond_new,\newline			failed ? &quotNO &lt&lt&quot : &quotyes&quot );\newline\newline	return failed ? -1 : 0;\newline}\newline","\newline Test function calling the old and new code mentioned in\newline http://bugs.ntp.org/show_bug.cgi?id=2803#c22\newline \newline","2748895","pth_time.c","intern void pth_time_usleep(unsigned long usec)\newline{\newline#ifdef HAVE_USLEEP\newline    usleep((unsigned int )usec);\newline#else\newline    struct timeval timeout;\newline    timeout.tv_sec  = usec / 1000000;\newline    timeout.tv_usec = usec - (1000000 * timeout.tv_sec);\newline    while (pth_sc(select)(1, NULL, NULL, NULL, &amptimeout) &lt 0 &amp&amp errno == EINTR) ;\newline#endif\newline    return;\newline}\newline","sleep for a specified amount of microseconds \newline","2311863","vncbaseframebuffer.c","VncBaseFramebuffer *vnc_base_framebuffer_new(guint8 *buffer,\newline                                             guint16 width,\newline                                             guint16 height,\newline                                             int rowstride,\newline                                             const VncPixelFormat *localFormat,\newline                                             const VncPixelFormat *remoteFormat)\newline{\newline    return VNC_BASE_FRAMEBUFFER(g_object_new(VNC_TYPE_BASE_FRAMEBUFFER,\newline                                             &quotbuffer&quot, buffer,\newline                                             &quotwidth&quot, width,\newline                                             &quotheight&quot, height,\newline                                             &quotrowstride&quot, rowstride,\newline                                             &quotlocal-format&quot, localFormat,\newline                                             &quotremote-format&quot, remoteFormat,\newline                                             NULL));\newline}\newline","\newline vnc_base_framebuffer_new:\newline @buffer: (array): the buffer representing the screen\newline @width: the width of the screen\newline @height: the height of the screen\newline @rowstride: the number of bytes per line in @buffer\newline @localFormat: the format for data stored in @buffer\newline @remoteFormat: the format for data before storage in @buffer\newline \newline Allocate a new general purpose framebuffer object storing\newline screen updates in @buffer. @buffer must be @height \newline @rowstride bytes in size. The returned object will\newline store a pointer to @buffer, so it should not be free&#039d\newline for as long as the framebuffer object exists\newline \newline Returns: (transfer full): the new framebuffer\newline \newline","3352638","simutil.c","gboolean ber_tlv_builder_set_length(struct ber_tlv_builder *builder,\newline					unsigned int new_len)\newline{\newline	unsigned int new_pos = builder-&gtpos + MAX_BER_TLV_HEADER + new_len;\newline\newline	if (new_pos &gt builder-&gtmax)\newline		return FALSE;\newline\newline	if (builder-&gtparent)\newline		ber_tlv_builder_set_length(builder-&gtparent, new_pos);\newline\newline	builder-&gtlen = new_len;\newline\newline	return TRUE;\newline}\newline","\newline Resize the TLV because the content of Value field needs more space.\newline If this TLV is part of another TLV, resize that one too.\newline \newline","3733235","bindings.c","static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)\newline{\newline	struct cgfs_files *k = NULL;\newline	bool ret = false;\newline\newline	k = cgfs_get_key(contrl, cg, file);\newline	if (!k)\newline		return false;\newline\newline	if (is_privileged_over(fc-&gtpid, fc-&gtuid, k-&gtuid, NS_ROOT_OPT)) {\newline		if (perms_include(k-&gtmode &gt&gt 6, mode)) {\newline			ret = true;\newline			goto out;\newline		}\newline	}\newline	if (fc-&gtgid == k-&gtgid) {\newline		if (perms_include(k-&gtmode &gt&gt 3, mode)) {\newline			ret = true;\newline			goto out;\newline		}\newline	}\newline	ret = perms_include(k-&gtmode, mode);\newline\newlineout:\newline	free_key(k);\newline	return ret;\newline}\newline","\newline check whether a fuse context may access a cgroup dir or file\newline \newline If file is not null, it is a cgroup file to check under cg.\newline If file is null, then we are checking perms on cg itself.\newline \newline For files we can check the mode of the list_keys result.\newline For cgroups, we must make assumptions based on the files under the\newline cgroup, because cgmanager doesn&#039t tell us ownership/perms of cgroups\newline yet.\newline \newline","782393","procedural.cpp","TqPopenStream* CqRunProgramRepository::startNewRunProgram(\newline		const std::string&amp command)\newline{\newline	// Get the program name and command line arguments.\newline	std::vector&ltstd::string&gt argv;\newline	splitCommandLine(command, argv);\newline	if(argv.empty())\newline		AQSIS_THROW_XQERROR(XqValidation, EqE_BadToken, &quotprogram name not present&quot);\newline	// Attempt to find the program in the procedural path\newline	std::string progName = native(QGetRenderContext()-&gtpoptCurrent()\newline		-&gtfindRiFileNothrow(argv[0], &quotprocedural&quot));\newline	if(progName.empty())\newline	{\newline		progName = argv[0];\newline		Aqsis::log() &lt&lt info\newline			&lt&lt &quotRiProcRunProgram: Could not find \\&quot&quot &lt&lt progName\newline			&lt&lt &quot\\&quot in \\&quotprocedural\\&quot searchpath, will rely on system path.\\n&quot;\newline	}\newline	try\newline	{\newline		// Attempt to open a pipe to the new procedural.\newline		TqPopenStreamPtr newPipe(new TqPopenStream(progName, argv));\newline		newPipe-&gtexceptions(std::ios::badbit | std::ios::failbit | std::ios::eofbit);\newline		m_activeRunPrograms.insert(std::make_pair(command, newPipe));\newline		return newPipe.get();\newline	}\newline	catch(XqEnvironment&amp e)\newline	{\newline		// Install a null pointer to indicate that we shouldn&#039t try to run this\newline		// procedural again, and rethrow.\newline		m_activeRunPrograms.insert(std::make_pair(command, TqPopenStreamPtr()));\newline		AQSIS_THROW_XQERROR(XqEnvironment, e.code(),\newline			&quoterror starting runprogram [&quot &lt&lt command &lt&lt &quot] : &quot &lt&lt e.what() );\newline	}\newline}\newline","\\brief Start a new child process for the given RunProgram command\newline \newline","4196230","r_analysis.c","static VALUE frb_get_locale(VALUE self, VALUE locale)\newline{\newline    return (frb_locale ? rb_str_new2(frb_locale) : Qnil);\newline}\newline","\newline call-seq:\newline Ferret.locale -&gt locale_str\newline \newline Returns a string corresponding to the locale set. For example;\newline \newline puts Ferret.locale #=&gt &quoten_US.UTF-8&quot\newline \newline","3062449","libtelnet.c","void telnet_free(telnet_t *telnet) {\newline	/* free sub-request buffer */\newline	if (telnet-&gtbuffer != 0) {\newline		free(telnet-&gtbuffer);\newline		telnet-&gtbuffer = 0;\newline		telnet-&gtbuffer_size = 0;\newline		telnet-&gtbuffer_pos = 0;\newline	}\newline\newline#if defined(HAVE_ZLIB)\newline	/* free zlib box */\newline	if (telnet-&gtz != 0) {\newline		if (telnet-&gtflags &amp TELNET_PFLAG_DEFLATE)\newline			deflateEnd(telnet-&gtz);\newline		else\newline			inflateEnd(telnet-&gtz);\newline		free(telnet-&gtz);\newline		telnet-&gtz = 0;\newline	}\newline#endif /* defined(HAVE_ZLIB) */\newline\newline	/* free RFC1143 queue */\newline	if (telnet-&gtq) {\newline		free(telnet-&gtq);\newline		telnet-&gtq = 0;\newline		telnet-&gtq_size = 0;\newline	}\newline\newline	/* free the telnet structure itself */\newline	free(telnet);\newline}\newline","free up any memory allocated by a state tracker \newline","218319","fcd.c","EXTERN FCD_MODE_ENUM fcdAppReset(void)\newline{\newline    hid_device *phd=NULL;\newline    //unsigned char aucBufIn[65];\newline    unsigned char aucBufOut[65];\newline\newline    phd = fcdOpen();\newline\newline    if (phd == NULL)\newline    {\newline        return FCD_MODE_NONE;\newline    }\newline\newline    // Send an App reset command\newline    aucBufOut[0] = 0; // Report ID, ignored\newline    aucBufOut[1] = FCD_CMD_APP_RESET;\newline    hid_write(phd, aucBufOut, 65);\newline\newline    /** FIXME: hid_read() will occasionally hang due to a pthread_cond_wait() never returning.\newline        It seems that the read_callback() in hid-libusb.c will never receive any\newline        data during the reconfiguration. Since the same logic works in the native\newline        windows application, it could be a libusb thing. Anyhow, since the value\newline        returned by this function is not used, we may as well just skip the hid_read()\newline        and return FME_NONE.\newline        Correct switch from APP to BL mode can be observed in /var/log/messages (linux)\newline        (when in bootloader mode the device version includes &#039BL&#039)\newline    */\newline    /*\newline    memset(aucBufIn,0xCC,65); // Clear out the response buffer\newline    hid_read(phd,aucBufIn,65);\newline\newline    if (aucBufIn[0]==FCDCMDAPPRESET &amp&amp aucBufIn[1]==1)\newline    {\newline        FCDClose(phd);\newline        phd=NULL;\newline        return FME_APP;\newline    }\newline    FCDClose(phd);\newline    phd=NULL;\newline    return FME_BL;\newline    */\newline\newline    fcdClose(phd);\newline    phd = NULL;\newline\newline    return FCD_MODE_NONE;\newline\newline}\newline","\\brief Reset FCD to bootloader mode.\newline \\return FCD_MODE_NONE\newline \newline This function is used to switch the FCD into bootloader mode in which\newline various firmware operations can be performed.\newline \newline","501410","lexer.c","int lexer_read_filename_recursive(struct lexer_book *bk)\newline{\newline	int count = lexer_read_escaped_until(bk, FILENAME_LIMITS);\newline\newline	if(count &lt 1)\newline		return count;\newline\newline	if(lexer_next_peek(bk) == &#039-&#039 &amp&amp !lexer_peek_remote_rename_syntax(bk)) {\newline		lexer_add_to_lexeme(bk, &#039-&#039);\newline		count++;\newline		count += lexer_read_filename_recursive(bk);\newline	}\newline\newline	return count;\newline}\newline","Read a filename, adding &#039-&#039 to names when - is not followed by\newline&gt. The &#039recursive&#039 comes because the function calls itself when\newlinecompleting a name when it added a -. \newline","","","","","","","","","","","","","","","","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","Connects to a given URI by initiating an asynchronous client request.","Initialize Ninja hardware","Called when lwIP has data to send up to the VPN","calling the old and new code","sleep for a specified amount of microseconds","Allocate a new general purpose framebuffer object storingscreen updates","Resize the TLV","check whether a fuse context may access a cgroup dir or file","Start a new child process for the given RunProgram command","Returns a string corresponding to the locale set.","free up any memory allocated by a state tracker","deals with the statements in either a procedureor the main program","used to switch the FCD into bootloader mode","adding '-' to names when - is not followed by>.","DXRead the data file as specified by the general import file.","formulate Lovasz problem and set data.","Implements the initialize method of cdebconf frontends.","Convert string to 64 bit unsigned int.","3-d array from netCDFfile and converting it to a 2-d array.","{}","{}"
"3ACRLU860NE703MQULMVV5P8UTSEBE","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","31LM9EDVOLSJZCU81E7W8ZYJWE3JNY","AVC62JNYAXA45","Approved","Wed Apr 17 14:11:12 PDT 2019","Wed Apr 17 14:31:25 PDT 2019","Fri Apr 19 14:31:25 PDT 2019","2019-04-19 21:32:21 UTC","","","1213","100% (24/24)","100% (24/24)","100% (24/24)","1820801","pool_connection_pool.c","int pool_init_cp(void)\newline{\newline	int i;\newline	MemoryContext oldContext = MemoryContextSwitchTo(TopMemoryContext);\newline\newline	pool_connection_pool = (POOL_CONNECTION_POOL *)palloc(sizeof(POOL_CONNECTION_POOL)*pool_config-&gtmax_pool);\newline	memset(pool_connection_pool, 0, sizeof(POOL_CONNECTION_POOL)*pool_config-&gtmax_pool);\newline\newline	for (i = 0; i &lt pool_config-&gtmax_pool; i++)\newline	{\newline		pool_connection_pool[i].info = pool_coninfo(pool_get_process_context()-&gtproc_id, i, 0);\newline		memset(pool_connection_pool[i].info, 0, sizeof(ConnectionInfo) * MAX_NUM_BACKENDS);\newline	}\newline    MemoryContextSwitchTo(oldContext);\newline	return 0;\newline}\newline","\newline initialize connection pools. this should be called once at the startup.\newline \newline","1519995","irqbalance.c","static void build_object_tree(void)\newline{\newline	build_numa_node_list();\newline	parse_cpu_tree();\newline	rebuild_irq_db();\newline}\newline","\newline This builds our object tree. The Heirarchy is pretty straightforward\newline At the top are numa_nodes\newline All CPU packages belong to a single numa_node\newline All Cache domains belong to a CPU package\newline All CPU cores belong to a cache domain\newline \newline Objects are built in that order (top down)\newline \newline Object workload is the aggregate sum of the\newline workload of the objects below it\newline \newline","6419710","commands.c","int cmd_list_size(String *spec)\newline{\newline    const char *when = &quotis&quot;\newline\newline    if (spec)\newline    {\newline	int length = atoi(spec);\newline	if (length != lookup.list.size) /* no work if already that size */\newline	{\newline	    void *mem = 0;\newline	    if (length)\newline	    {\newline		mem = xmalloc(length * sizeof(lookup.list.array[0]));\newline		if (mem == 0)\newline		{\newline		    outputf(&quot%scan&#039t allocate memory for filter &quot\newline			    &quotlist of length %d.\\n&quot, lookup.where, length);\newline		    return COMMAND_HAS_ERROR;\newline		}\newline	    }\newline\newline	    if (lookup.list.array)\newline		free(lookup.list.array);\newline	    lookup.list.array = mem;\newline	    lookup.list.size = length;\newline	    lookup.list.used = 0;\newline	}\newline\newline	if (!lookup.flag.verbose)\newline	    return COMMAND_RUNS_OK;\newline	when = &quotnow&quot;\newline    }\newline    outputf(&quotmaximum filter list size %s: %d.\\n&quot, when, lookup.list.size);\newline    if (lookup.list.used)\newline	outputf(&quotcurrent lines held: %d.\\n&quot, lookup.list.used);\newline    return COMMAND_RUNS_OK;\newline}\newline","set the size of the filter, etc, list \newline","4945777","parttype.c","const char *fdisk_parttype_get_name(const struct fdisk_parttype *t)\newline{\newline	assert(t);\newline	return t-&gtname;\newline}\newline","\newline fdisk_parttype_get_name:\newline @t: type\newline \newline Returns: partition type human readable name\newline \newline","2691394","hap.c","static int hap_enable_log_dirty(struct domain *d, bool_t log_global)\newline{\newline    /* turn on PG_log_dirty bit in paging mode */\newline    paging_lock(d);\newline    d-&gtarch.paging.mode |= PG_log_dirty;\newline    paging_unlock(d);\newline\newline    /* Enable hardware-assisted log-dirty if it is supported. */\newline    p2m_enable_hardware_log_dirty(d);\newline\newline    if ( log_global )\newline    {\newline        /*\newline         * Switch to log dirty mode, either by setting l1e entries of P2M table\newline         * to be read-only, or via hardware-assisted log-dirty.\newline         */\newline        p2m_change_entry_type_global(d, p2m_ram_rw, p2m_ram_logdirty);\newline        flush_tlb_mask(d-&gtdomain_dirty_cpumask);\newline    }\newline    return 0;\newline}\newline","\newline hap code to call when log_dirty is enable. return 0 if no problem found.\newline \newline NB: Domain that having device assigned should not set log_global. Because\newline there is no way to track the memory updating from device.\newline \newline","4677134","mcrypt.c","static void check_keysize( int keysize) {\newline      int *siz, i, y, x;\newline\newline      if ( keysize &gt\newline	  mcrypt_module_get_algo_key_size(algorithm,\newline					  algorithms_directory)) {\newline	 err_quit(_\newline		  (&quotThe specified key size is too large for this algorithm.\\n&quot));\newline      }\newline\newline      siz =\newline	  mcrypt_module_get_algo_supported_key_sizes(algorithm,\newline						     algorithms_directory,\newline						     &ampi);\newline      x = 0;\newline      if (siz == NULL || i == 0)\newline	 x = 1;			/* we have already checked if it is\newline				   * less than the maximum supported\newline				   * by the algorithm\newline				 */\newline      else {\newline	 for (y = 0; y &lt i; y++) {\newline	    if (siz[y] == keysize) {\newline	       x = 1;\newline	       break;\newline	    }\newline	 }\newline	 free(siz);\newline      }\newline\newline      if (x == 0) {\newline	 err_quit(_\newline		  (&quotThe specified key size not valid for this algorithm.\\n&quot));\newline      }\newline}\newline","Checks if the given key size is supported by the algorithm\newline \newline","2062420","tcpspy.c","static void stopsig (int signo)\newline{\newline	logmsg (&quotcaught signal %d, shutting down&quot, signo);\newline	stopped = 1;\newline}\newline","\newline stopsig ()\newline \newline Stop the program when certain signals are received. \newline \newline","4705372","fs_mgr_fstab.c","struct fstab_rec *fs_mgr_get_entry_for_mount_point_after(struct fstab_rec *start_rec, struct fstab *fstab, const char *path)\newline{\newline    int i;\newline    if (!fstab) {\newline        return NULL;\newline    }\newline\newline    if (start_rec) {\newline        for (i = 0; i &lt fstab-&gtnum_entries; i++) {\newline            if (&ampfstab-&gtrecs[i] == start_rec) {\newline                i++;\newline                break;\newline            }\newline        }\newline    } else {\newline        i = 0;\newline    }\newline    for (; i &lt fstab-&gtnum_entries; i++) {\newline        int len = strlen(fstab-&gtrecs[i].mount_point);\newline        if (strncmp(path, fstab-&gtrecs[i].mount_point, len) == 0 &amp&amp\newline            (path[len] == &#039\\0&#039 || path[len] == &#039/&#039)) {\newline            return &ampfstab-&gtrecs[i];\newline        }\newline    }\newline    return NULL;\newline}\newline","\newline Returns the 1st matching fstab_rec that follows the start_rec.\newline start_rec is the result of a previous search or NULL.\newline \newline","2187111","cache.c","uint_t a_Cache_get_flags_with_redirection(const DilloUrl *url)\newline{\newline   CacheEntry_t *entry = Cache_entry_search_with_redirect(url);\newline   return (entry ? entry-&gtFlags : 0);\newline}\newline","\newline Get cache entry status (following redirections).\newline \newline","4218050","pr2_cmds.c","void PF2_changelevel(byte* base, unsigned int mask, pr2val_t* stack, pr2val_t*retval)\newline{\newline	static int last_spawncount;\newline	char *s = (char *) VM_POINTER(base,mask,stack[0].string);\newline	char expanded[MAX_QPATH];\newline\newline//	FILE *f;\newline	vfsfile_t *f;\newline\newline	// check to make sure the level exists.\newline	// this is work around for bellow check about two changelevels,\newline	// which lock server in one map if we trying switch to map which does&#039t exist\newline	snprintf(expanded, MAX_QPATH, &quotmaps/%s.bsp&quot, s);\newline\newline//	FS_FOpenFile (expanded, &ampf);\newline	f = FS_OpenVFS(expanded, &quotrb&quot, FS_ANY);\newline\newline	if (!f)\newline	{\newline		Sys_Printf (&quotCan&#039t find %s\\n&quot, expanded);\newline		return;\newline	}\newline\newline//	fclose (f);\newline	VFS_CLOSE(f);\newline\newline	// make sure we don&#039t issue two changelevels\newline	// this check is evil and cause lock on one map, if /map command fail for some reason\newline	if (svs.spawncount == last_spawncount)\newline		return;\newline	last_spawncount = svs.spawncount;\newline\newline	Cbuf_AddText(va(&quotmap %s\\n&quot, s));\newline}\newline","\newline==============\newlinePF2_changelevel\newline==============\newline \newline","2144135","parse.c","const char *oidc_parse_userinfo_refresh_interval(apr_pool_t *pool,\newline		const char *arg, int *int_value) {\newline	return oidc_parse_int_valid(pool, arg, int_value,\newline			oidc_valid_userinfo_refresh_interval);\newline}\newline","\newline parse a userinfo refresh interval from the provided string\newline \newline","5197780","mozplugger-helper.c","static void takeSwallowMutex(void)\newline{\newline     int countDown;\newline     const uint32_t ourPid = (uint32_t)getpid();\newline     const uint32_t ourHostId = getHostId();\newline     uint32_t otherPid;\newline     uint32_t otherHostId;\newline     uint32_t prevOtherPid = 0;\newline \newline     if((display == 0) || (swallowMutex == 0))\newline     {\newline	  return;\newline     }\newline\newline     D(&quotAttempting to take Swallow Mutex\\n&quot); \newline     /* Try up tp forty times ( 40 * 250ms = 10 seconds) to take \newline       the semaphore... */\newline\newline     countDown = 40;\newline     while(1)\newline     {\newline\newline          /* While someone owns the semaphore */\newline          while(getSwallowMutexOwner(&ampotherHostId, &ampotherPid))\newline          {\newline               if( otherHostId == ourHostId)    \newline               {\newline                    if(otherPid == ourPid)     \newline                    {\newline 	                /* Great we have either successfully taken the semaphore\newline                           OR (unlikely) we previously had the semaphore! Exit\newline                           the function...*/\newline	                 swallowMutexTaken = 1;\newline                         D(&quotTaken Swallow Mutex\\n&quot); \newline		         return;\newline                    }\newline\newline     	    	    D(&quotSemaphore currently taken by pid=%ld\\n&quot, (long) otherPid);\newline 		    /* Check that the process that has the semaphore exists...\newline        	     Bit of a hack, I cant find a function to directly check\newline                     if process exists. */\newline            	    if( (getsid(otherPid) &lt 0 ) &amp&amp (errno == ESRCH))\newline	            {\newline	    	         D(&quotStrange other Pid(%lu) cannot be found\\n&quot,(unsigned long) otherPid);\newline                         XDeleteProperty(display, wattr.root, swallowMutex);\newline                         break;    /* OK force early exit of inner while loop */\newline                    }\newline	       }\newline\newline               /* Check if the owner of semaphore hasn&#039t recently changed if it\newline                has restart timer */\newline               if(prevOtherPid != otherPid)\newline               {\newline   	            D(&quotLooks like semaphore&#039s owner has changed pid=%ld\\n&quot, \newline                        (long) otherPid);\newline	            countDown = 40;\newline                    prevOtherPid = otherPid;\newline               }\newline            \newline               /* Do one step of the timer... */\newline	       countDown--;\newline               if(countDown &lt= 0)\newline               {\newline	    	    D(&quotWaited long enough for Pid(%lu)\\n&quot, (unsigned long) otherPid);\newline                    XDeleteProperty(display, wattr.root, swallowMutex);\newline		    break;\newline               }\newline	\newline               usleep(250000);        /* 250ms */\newline 	  }\newline\newline          /* else no one has semaphore, timeout, or owner is dead -\newline           Set us as the owner, but we need to check if we weren&#039t \newline           beaten to it so once more around the loop.\newline           Note even doing the recheck does not work in 100% of all\newline           cases due to task switching occuring at just the wrong moment\newline           see Mozdev bug 20088 - the fix is done use the stillHaveMutex\newline           function */\newline\newline          setSwallowMutexOwner(ourHostId, ourPid);\newline     }\newline}\newline","\newline Take mutex semaphore ownership.\newline \newline @return none\newline \newline \newline","242872","test4.c","static void stop_thread(Thread *p){\newline  thread_wait(p);\newline  p-&gtxOp = 0;\newline  p-&gtopnum++;\newline  thread_wait(p);\newline  sqliteFree(p-&gtzArg);\newline  p-&gtzArg = 0;\newline  sqliteFree(p-&gtzFilename);\newline  p-&gtzFilename = 0;\newline  p-&gtbusy = 0;\newline}\newline","\newline Stop a thread.\newline \newline","1467069","u12-if.c","static SANE_Bool u12if_IsDeviceSupported( U12_Device *dev )\newline{\newline	int i;\newline\newline	for( i = 0; NULL != u12Devices[i].name; i++ ) {\newline\newline		if( !strcmp( dev-&gtusbId, u12Devices[i].vp )) {\newline			dev-&gtsane.model = u12Devices[i].name;\newline			return SANE_TRUE;\newline		}\newline	}\newline\newline	return SANE_FALSE;\newline}\newline","This function checks wether a device, described by a given\newline string(vendor and product ID), is supported by this backend or not\newline \newline @param usbIdStr - sting consisting out of product and vendor ID\newline format: &quot0xVVVV-0xPPPP&quot VVVV = Vendor ID, PPP = Product ID\newline @returns; SANE_TRUE if supported, SANE_FALSE if not\newline \newline","675722","read-dict.c","static Exp * in_parens(Dictionary dict)\newline{\newline	Exp * e;\newline\newline	if (is_equal(dict, &#039&amp&#039) || (strcmp(token, &quotand&quot)==0)) {\newline		if (!link_advance(dict)) {\newline			return NULL;\newline		}\newline		return operator_exp(dict, AND_type);\newline	} else if (is_equal(dict, &#039|&#039) || (strcmp(dict-&gttoken, &quotor&quot)==0)) {\newline		if (!link_advance(dict)) {\newline			return NULL;\newline		}\newline		return operator_exp(dict, OR_type);\newline	} else {\newline		return expression(dict);\newline	}\newline}\newline","\newline Looks for the stuff that is allowed to be inside of parentheses\newline either &amp or | followed by a list, or a terminal symbol.\newline \newline","2204986","cplot.c","int	cplot_counts(fieldstruct *field)\newline  {\newline   wcsstruct	*wcsptr[2],\newline		*wcs, *wcsout;\newline   PLFLT	**count,\newline		clevel[CPLOT_NSHADES], cpoint[3], r[3],g[3],b[3],\newline		cmin,cmax, mc,dc;\newline   PLINT	lwid;\newline   char		*ctype[NAXIS],\newline		str[80];\newline   double	crpix[NAXIS], cdelt[NAXIS], raw[NAXIS],\newline		xmin,ymin,xmax,ymax, xstep,ystep, dval;\newline   int		naxisn[NAXIS],\newline		**icount,\newline		i,j, e, n,nt, naxis, nsnap,nsnap2, flag;\newline\newline  if (cplot_init(field-&gtrcatname, 1,1, CPLOT_COUNTS) == RETURN_ERROR)\newline    {\newline    cplot_end(CPLOT_COUNTS);\newline    return RETURN_OK;\newline    }\newline\newline  wcs = field-&gtwcs[0];\newline  if (!wcs || wcs-&gtnaxis&lt2)\newline    return RETURN_ERROR;\newline  naxis = wcs-&gtnaxis;\newline  for (i=0; i&ltnaxis; i++)\newline    {\newline    QMALLOC(ctype[i], char, 16); \newline    strncpy(ctype[i],wcs-&gtctype[i], 16);\newline    crpix[i] = 50.0;\newline    cdelt[i] = field-&gtmaxradius/50.0;\newline    if (i==wcs-&gtlng)\newline      cdelt[i] = -cdelt[i];	/* Put East to the left */\newline    naxisn[i] = 100;\newline    }\newline\newline  wcsout = create_wcs(ctype,field-&gtmeanwcspos,crpix,cdelt,naxisn, naxis);\newline\newline  xmin = 0.5;\newline  xmax = 100.5;\newline  ymin = 0.5;\newline  ymax = 100.5;\newline  lwid = plotaaflag? ((CPLOT_AAFAC+1)/2) : 1;\newline  plwidth((double)lwid);\newline  plfont(2);\newline  plcol0(15);\newline  plenv((PLFLT)xmin, (PLFLT)xmax, (PLFLT)ymin, (PLFLT)ymax, 1, -1);\newline  sprintf(str, &quot#uField %.24s: source count map&quot, field-&gtrtcatname);\newline  plschr(0.0, 1.0);\newline  pllab(&quot&quot,&quot&quot, str);\newline  plwidth(0.0);\newline  plcol0(7);\newline  cplot_drawloccoordgrid(wcsout, xmin, xmax, ymin, ymax);\newline\newline  pllsty(1);\newline  plcol0(15);\newline  plscmap1n(256);\newline\newline  cmin = BIG;\newline  cmax = -BIG;\newline\newline/* First pass through the data to find min and max number counts */\newline  flag = 0;\newline  icount = field-&gtlcount;\newline  nsnap = prefs.context_nsnap;\newline  nt = nsnap*nsnap;\newline  for (e=0; e&ltfield-&gtnext; e++)\newline    for (n=0; n&ltnt; n++)\newline      {\newline      dval = (double)icount[e][n];\newline      if (dval &lt cmin)\newline        cmin = dval;\newline      if (dval &gt cmax)\newline        cmax = dval;\newline      }\newline\newline/* Lower bound to variability in counts is 1e-4 */\newline  if ((mc=(cmin+cmax)/2.0) &lt  1.0e-10)\newline    mc = 1.0e-10;\newline  if ((dc=cmax-cmin) &lt 1.0e-4*mc)\newline    dc = 1.0e-4*mc;\newline  cmin = mc - dc/2.0;\newline  cmax = mc + dc/2.0;\newline\newline  for (i=0; i&ltCPLOT_NSHADES; i++)\newline    clevel[i] = cmin + (i-0.5) * dc / (CPLOT_NSHADES-2);\newline  cpoint[0] = 0.0; r[0] = 0.5; g[0] = 0.5; b[0] = 1.0;\newline  cpoint[1] = 0.5; r[1] = 0.5; g[1] = 1.0; b[1] = 0.5;\newline  cpoint[2] = 1.0; r[2] = 1.0; g[2] = 0.5; b[2] = 0.5;\newline  plscmap1l(1, 3, cpoint, r, g, b, NULL);\newline\newline/* Now the real 2D count mapping */\newline  nsnap2 = nsnap&gt1? nsnap : 2;\newline  for (e=0; e&ltfield-&gtnext; e++)\newline    {\newline    wcs = field-&gtwcs[e];\newline    plAlloc2dGrid(&ampcount, nsnap2, nsnap2);\newline    for (i=0; i&ltnaxis; i++)\newline      raw[i] = wcs-&gtnaxisn[i]/2.0 + 0.5;\newline    xstep = wcs-&gtnaxisn[0] / (nsnap2-1);\newline    ystep = wcs-&gtnaxisn[1] / (nsnap2-1);\newline    if (nsnap &gt 1)\newline      for (j=0; j&ltnsnap2; j++)\newline        for (i=0; i&ltnsnap2; i++)\newline          count[i][j] = (PLFLT)icount[e][j*nsnap+i];\newline    else\newline      for (j=0; j&ltnsnap2; j++)\newline        for (i=0; i&ltnsnap2; i++)\newline          count[i][j] = (PLFLT)icount[e][0];\newline    wcsptr[0] = wcs;\newline    wcsptr[1] = wcsout;\newline    plshades(count, nsnap2, nsnap2, NULL,\newline	     xstep/2.0+0.5, wcs-&gtnaxisn[0]-xstep/2.0+0.5,\newline             ystep/2.0+0.5, wcs-&gtnaxisn[1]-ystep/2.0+0.5,\newline	     clevel, CPLOT_NSHADES, 1, 0, 0, plfill, 0, distort_map, wcsptr);\newline    plFree2dGrid(count, nsnap2, nsnap2);\newline    plcol0(7);\newline    plwidth((double)lwid);\newline    cplot_drawbounds(wcs, wcsout);\newline    }\newline\newline/* Draw left colour scale */\newline  plAlloc2dGrid(&ampcount, 2, CPLOT_NSHADES);\newline  for (j=0; j&ltCPLOT_NSHADES; j++)\newline    count[0][j] = count[1][j] = cmin + j * dc/(CPLOT_NSHADES-1);\newline\newline  plvpor(0.91,0.935,0.115,0.885);\newline  plwind(0.0,1.0,cmin,cmax);\newline  plshades(count, 2, CPLOT_NSHADES, NULL, 0.0, 1.0, cmin,cmax, clevel,\newline	   CPLOT_NSHADES, 1, 0, 0, plfill, 1, NULL, NULL);\newline  plcol0(15);\newline  plschr(0.0, 0.5);\newline  plbox(&quotbc&quot, 0.0, 0, &quotbnstv&quot, 0.0, 0);\newline  plschr(0.0, 0.6);\newline  plmtex(&quotl&quot, 5.0, 0.5, 0.5, &quotnumber&quot);\newline  plmtex(&quotb&quot, 2.0, 0.5, 0.5, &quotsource ##&quot);\newline\newline  plFree2dGrid(count, 2, CPLOT_NSHADES);\newline  plend();\newline  end_wcs(wcsout);\newline  for (i=0; i&ltnaxis; i++)\newline    free(ctype[i]);\newline\newline  cplot_counts(field);		/* Recursive stuff */\newline\newline  return RETURN_OK;\newline  }\newline","cplot_counts \newlinePROTO int cplot_counts(fieldstruct field)\newlinePURPOSE Plot an x,y map of the number of sources that has been loaded.\newlineINPUT Pointer to the field.\newlineOUTPUT RETURN_OK if everything went fine, RETURN_ERROR otherwise.\newlineNOTES -.\newlineAUTHOR E. Bertin (IAP)\newlineVERSION 16/04/2012\newline \newline","3681942","gnix_ep.c","DIRECT_FN STATIC ssize_t gnix_ep_tinjectdata(struct fid_ep *ep, const void *buf,\newline					     size_t len, uint64_t data,\newline					     fi_addr_t dest_addr, uint64_t tag)\newline{\newline	return __ep_inject(ep, buf, len, data, dest_addr,\newline			  FI_TAGGED | FI_REMOTE_CQ_DATA, tag);\newline}\newline","\newline Injects data into the data buffer and returns immediately.\newline \newline @param[in] ep the endpoint we are sending data from\newline @param[in] buf the data to send\newline @param[in] len the length of buf\newline @param[in] data remote CQ data to transfer with the data from buf\newline @param[in] dest_addr the desitnation address for connectionless transfers\newline @param[in] tag the tag associated with the message\newline \newline @return FI_SUCCESS upon successfully writing to the destination\newline @return -FI_ERRNO upon an error\newline @return -FI_ENOSYS if this operation is not supported\newline \newline","1886709","tccgen.c","void vpush64(int ty, unsigned long long v)\newline{\newline	CValue cval;\newline	CType ctype;\newline	ctype.t = ty;\newline	ctype.ref = NULL;\newline	cval.ull = v;\newline	vsetc(&ampctype, VT_CONST, &ampcval);\newline}\newline","push arbitrary 64 bit constant \newline","1653670","generate_custom_hufftables.c","void fprint_uint8_table(FILE * outfile, uint8_t * table, uint64_t length, char *header,\newline			char *footer, char *begin_line)\newline{\newline	int i;\newline	fprintf(outfile, &quot%s&quot, header);\newline	for (i = 0; i &lt length - 1; i++) {\newline		if ((i &amp 7) == 0)\newline			fprintf(outfile, &quot\\n%s&quot, begin_line);\newline		else\newline			fprintf(outfile, &quot &quot);\newline		fprintf(outfile, &quot0x%02x,&quot, table[i]);\newline	}\newline\newline	if ((i &amp 7) == 0)\newline		fprintf(outfile, &quot\\n%s&quot, begin_line);\newline	else\newline		fprintf(outfile, &quot &quot);\newline	fprintf(outfile, &quot0x%02x&quot, table[i]);\newline	fprintf(outfile, &quot%s&quot, footer);\newline\newline}\newline","\newline @brief Prints a table of uint8_t elements to a file.\newline @param outfile: the file the table is printed to.\newline @param table: the table to be printed.\newline @param length: number of elements to be printed.\newline @param header: header to append in front of the table.\newline @param footer: footer to append at the end of the table.\newline @param begin_line: string printed at beginning of new line\newline \newline","3465045","coerce.c","static SEXP coerceVectorList(SEXP v, SEXPTYPE type)\newline{\newline    int warn = 0, tmp;\newline    R_xlen_t i, n;\newline    SEXP rval, names;\newline\newline    names = v;\newline    rval = R_NilValue;	/* -Wall */\newline\newline    /* expression -&gt list, new in R 2.4.0 */\newline    if (type == VECSXP &amp&amp TYPEOF(v) == EXPRSXP) {\newline	/* This is sneaky but saves us rewriting a lot of the duplicate code */\newline	rval = MAYBE_REFERENCED(v) ? duplicate(v) : v;\newline	SET_TYPEOF(rval, VECSXP);\newline	return rval;\newline    }\newline\newline    if (type == EXPRSXP &amp&amp TYPEOF(v) == VECSXP) {\newline	rval = MAYBE_REFERENCED(v) ? duplicate(v) : v;\newline	SET_TYPEOF(rval, EXPRSXP);\newline	return rval;\newline    }\newline\newline    if (type == STRSXP) {\newline	n = xlength(v);\newline	PROTECT(rval = allocVector(type, n));\newline#ifdef R_MEMORY_PROFILING\newline	if (RTRACE(v)){\newline	   memtrace_report(v, rval);\newline	   SET_RTRACE(rval,1);\newline	}\newline#endif\newline	for (i = 0; i &lt n;  i++) {\newline	    if (isString(VECTOR_ELT(v, i)) &amp&amp xlength(VECTOR_ELT(v, i)) == 1)\newline		SET_STRING_ELT(rval, i, STRING_ELT(VECTOR_ELT(v, i), 0));\newline#if 0\newline	    /* this will make as.character(list(s)) not backquote\newline	     * non-syntactic name s. It is not entirely clear that\newline	     * that is really desirable though....\newline	     */\newline	    else if (isSymbol(VECTOR_ELT(v, i)))\newline		SET_STRING_ELT(rval, i, PRINTNAME(VECTOR_ELT(v, i)));\newline#endif\newline	    else\newline		SET_STRING_ELT(rval, i,\newline			       STRING_ELT(deparse1line(VECTOR_ELT(v, i), 0), 0));\newline	}\newline    }\newline    else if (type == LISTSXP) {\newline	rval = VectorToPairList(v);\newline	return rval;\newline    }\newline    else if (isVectorizable(v)) {\newline	n = xlength(v);\newline	PROTECT(rval = allocVector(type, n));\newline	switch (type) {\newline	case LGLSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		LOGICAL(rval)[i] = asLogical(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case INTSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		INTEGER(rval)[i] = asInteger(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case REALSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		REAL(rval)[i] = asReal(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case CPLXSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		COMPLEX(rval)[i] = asComplex(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case RAWSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		tmp = asInteger(VECTOR_ELT(v, i));\newline		if (tmp &lt 0 || tmp &gt 255) { /* includes NA_INTEGER */\newline		    tmp = 0;\newline		    warn |= WARN_RAW;\newline		}\newline		RAW(rval)[i] = (Rbyte) tmp;\newline	    }\newline	    break;\newline	default:\newline	    UNIMPLEMENTED_TYPE(&quotcoerceVectorList&quot, v);\newline	}\newline    }\newline    else\newline	error(_(&quot(list) object cannot be coerced to type &#039%s&#039&quot),\newline	      type2char(type));\newline\newline    if (warn) CoercionWarning(warn);\newline    names = getAttrib(v, R_NamesSymbol);\newline    if (names != R_NilValue)\newline	setAttrib(rval, R_NamesSymbol, names);\newline    UNPROTECT(1);\newline    return rval;\newline}\newline","Coerce a vector list to the given type \newline","5514970","utils.c","char match_p33_merge(char pA, char pB){\newline  pA = min(pA, maximum_quality);\newline  pB = min(pB, maximum_quality);\newline  char res = pA+(pB-33);\newline  return max(min(res,maximum_quality), MIN_QUAL);\newline}\newline","\newline Calculates the resulting phred 33 score given a match\newline \newline","","on","","","","","","","","","","","","","","on","on","","","","","","","","","","on","","","","","","","","","","","","","","","","initialize connection pools.","{}","parse a userinfo refresh interval","Take mutex semaphore ownership.","Stop a thread.","checks wether a device,","Looks for the stuff that is allowed to be inside of parentheses","Plot an x,y map","Injects data into the data buffer and returns","push arbitrary 64 bit constant","Prints a table of uint8_t elements to a file.","builds our object tree.","Coerce a vector list to the given type","Calculates the resulting phred 33 score","set the size of the filter, etc, list","{}","{}","Checks if the given key size is supported by the algorithm","Stop the program","Returns the 1st matching fstab_rec that follows the start_rec.","Get cache entry status"
"3ACRLU860NE703MQULMVV5P8UTSEBE","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3BWI6RSP7G9MLBGT76FGFMZ1RSQE7N","A3SYA8EDAEOOF7","Approved","Wed Apr 17 15:49:26 PDT 2019","Wed Apr 17 15:58:37 PDT 2019","Fri Apr 19 15:58:37 PDT 2019","2019-04-19 22:59:21 UTC","","","551","100% (17/17)","100% (17/17)","100% (17/17)","1820801","pool_connection_pool.c","int pool_init_cp(void)\newline{\newline	int i;\newline	MemoryContext oldContext = MemoryContextSwitchTo(TopMemoryContext);\newline\newline	pool_connection_pool = (POOL_CONNECTION_POOL *)palloc(sizeof(POOL_CONNECTION_POOL)*pool_config-&gtmax_pool);\newline	memset(pool_connection_pool, 0, sizeof(POOL_CONNECTION_POOL)*pool_config-&gtmax_pool);\newline\newline	for (i = 0; i &lt pool_config-&gtmax_pool; i++)\newline	{\newline		pool_connection_pool[i].info = pool_coninfo(pool_get_process_context()-&gtproc_id, i, 0);\newline		memset(pool_connection_pool[i].info, 0, sizeof(ConnectionInfo) * MAX_NUM_BACKENDS);\newline	}\newline    MemoryContextSwitchTo(oldContext);\newline	return 0;\newline}\newline","\newline initialize connection pools. this should be called once at the startup.\newline \newline","1519995","irqbalance.c","static void build_object_tree(void)\newline{\newline	build_numa_node_list();\newline	parse_cpu_tree();\newline	rebuild_irq_db();\newline}\newline","\newline This builds our object tree. The Heirarchy is pretty straightforward\newline At the top are numa_nodes\newline All CPU packages belong to a single numa_node\newline All Cache domains belong to a CPU package\newline All CPU cores belong to a cache domain\newline \newline Objects are built in that order (top down)\newline \newline Object workload is the aggregate sum of the\newline workload of the objects below it\newline \newline","6419710","commands.c","int cmd_list_size(String *spec)\newline{\newline    const char *when = &quotis&quot;\newline\newline    if (spec)\newline    {\newline	int length = atoi(spec);\newline	if (length != lookup.list.size) /* no work if already that size */\newline	{\newline	    void *mem = 0;\newline	    if (length)\newline	    {\newline		mem = xmalloc(length * sizeof(lookup.list.array[0]));\newline		if (mem == 0)\newline		{\newline		    outputf(&quot%scan&#039t allocate memory for filter &quot\newline			    &quotlist of length %d.\\n&quot, lookup.where, length);\newline		    return COMMAND_HAS_ERROR;\newline		}\newline	    }\newline\newline	    if (lookup.list.array)\newline		free(lookup.list.array);\newline	    lookup.list.array = mem;\newline	    lookup.list.size = length;\newline	    lookup.list.used = 0;\newline	}\newline\newline	if (!lookup.flag.verbose)\newline	    return COMMAND_RUNS_OK;\newline	when = &quotnow&quot;\newline    }\newline    outputf(&quotmaximum filter list size %s: %d.\\n&quot, when, lookup.list.size);\newline    if (lookup.list.used)\newline	outputf(&quotcurrent lines held: %d.\\n&quot, lookup.list.used);\newline    return COMMAND_RUNS_OK;\newline}\newline","set the size of the filter, etc, list \newline","4945777","parttype.c","const char *fdisk_parttype_get_name(const struct fdisk_parttype *t)\newline{\newline	assert(t);\newline	return t-&gtname;\newline}\newline","\newline fdisk_parttype_get_name:\newline @t: type\newline \newline Returns: partition type human readable name\newline \newline","2691394","hap.c","static int hap_enable_log_dirty(struct domain *d, bool_t log_global)\newline{\newline    /* turn on PG_log_dirty bit in paging mode */\newline    paging_lock(d);\newline    d-&gtarch.paging.mode |= PG_log_dirty;\newline    paging_unlock(d);\newline\newline    /* Enable hardware-assisted log-dirty if it is supported. */\newline    p2m_enable_hardware_log_dirty(d);\newline\newline    if ( log_global )\newline    {\newline        /*\newline         * Switch to log dirty mode, either by setting l1e entries of P2M table\newline         * to be read-only, or via hardware-assisted log-dirty.\newline         */\newline        p2m_change_entry_type_global(d, p2m_ram_rw, p2m_ram_logdirty);\newline        flush_tlb_mask(d-&gtdomain_dirty_cpumask);\newline    }\newline    return 0;\newline}\newline","\newline hap code to call when log_dirty is enable. return 0 if no problem found.\newline \newline NB: Domain that having device assigned should not set log_global. Because\newline there is no way to track the memory updating from device.\newline \newline","4677134","mcrypt.c","static void check_keysize( int keysize) {\newline      int *siz, i, y, x;\newline\newline      if ( keysize &gt\newline	  mcrypt_module_get_algo_key_size(algorithm,\newline					  algorithms_directory)) {\newline	 err_quit(_\newline		  (&quotThe specified key size is too large for this algorithm.\\n&quot));\newline      }\newline\newline      siz =\newline	  mcrypt_module_get_algo_supported_key_sizes(algorithm,\newline						     algorithms_directory,\newline						     &ampi);\newline      x = 0;\newline      if (siz == NULL || i == 0)\newline	 x = 1;			/* we have already checked if it is\newline				   * less than the maximum supported\newline				   * by the algorithm\newline				 */\newline      else {\newline	 for (y = 0; y &lt i; y++) {\newline	    if (siz[y] == keysize) {\newline	       x = 1;\newline	       break;\newline	    }\newline	 }\newline	 free(siz);\newline      }\newline\newline      if (x == 0) {\newline	 err_quit(_\newline		  (&quotThe specified key size not valid for this algorithm.\\n&quot));\newline      }\newline}\newline","Checks if the given key size is supported by the algorithm\newline \newline","2062420","tcpspy.c","static void stopsig (int signo)\newline{\newline	logmsg (&quotcaught signal %d, shutting down&quot, signo);\newline	stopped = 1;\newline}\newline","\newline stopsig ()\newline \newline Stop the program when certain signals are received. \newline \newline","4705372","fs_mgr_fstab.c","struct fstab_rec *fs_mgr_get_entry_for_mount_point_after(struct fstab_rec *start_rec, struct fstab *fstab, const char *path)\newline{\newline    int i;\newline    if (!fstab) {\newline        return NULL;\newline    }\newline\newline    if (start_rec) {\newline        for (i = 0; i &lt fstab-&gtnum_entries; i++) {\newline            if (&ampfstab-&gtrecs[i] == start_rec) {\newline                i++;\newline                break;\newline            }\newline        }\newline    } else {\newline        i = 0;\newline    }\newline    for (; i &lt fstab-&gtnum_entries; i++) {\newline        int len = strlen(fstab-&gtrecs[i].mount_point);\newline        if (strncmp(path, fstab-&gtrecs[i].mount_point, len) == 0 &amp&amp\newline            (path[len] == &#039\\0&#039 || path[len] == &#039/&#039)) {\newline            return &ampfstab-&gtrecs[i];\newline        }\newline    }\newline    return NULL;\newline}\newline","\newline Returns the 1st matching fstab_rec that follows the start_rec.\newline start_rec is the result of a previous search or NULL.\newline \newline","2187111","cache.c","uint_t a_Cache_get_flags_with_redirection(const DilloUrl *url)\newline{\newline   CacheEntry_t *entry = Cache_entry_search_with_redirect(url);\newline   return (entry ? entry-&gtFlags : 0);\newline}\newline","\newline Get cache entry status (following redirections).\newline \newline","4218050","pr2_cmds.c","void PF2_changelevel(byte* base, unsigned int mask, pr2val_t* stack, pr2val_t*retval)\newline{\newline	static int last_spawncount;\newline	char *s = (char *) VM_POINTER(base,mask,stack[0].string);\newline	char expanded[MAX_QPATH];\newline\newline//	FILE *f;\newline	vfsfile_t *f;\newline\newline	// check to make sure the level exists.\newline	// this is work around for bellow check about two changelevels,\newline	// which lock server in one map if we trying switch to map which does&#039t exist\newline	snprintf(expanded, MAX_QPATH, &quotmaps/%s.bsp&quot, s);\newline\newline//	FS_FOpenFile (expanded, &ampf);\newline	f = FS_OpenVFS(expanded, &quotrb&quot, FS_ANY);\newline\newline	if (!f)\newline	{\newline		Sys_Printf (&quotCan&#039t find %s\\n&quot, expanded);\newline		return;\newline	}\newline\newline//	fclose (f);\newline	VFS_CLOSE(f);\newline\newline	// make sure we don&#039t issue two changelevels\newline	// this check is evil and cause lock on one map, if /map command fail for some reason\newline	if (svs.spawncount == last_spawncount)\newline		return;\newline	last_spawncount = svs.spawncount;\newline\newline	Cbuf_AddText(va(&quotmap %s\\n&quot, s));\newline}\newline","\newline==============\newlinePF2_changelevel\newline==============\newline \newline","2144135","parse.c","const char *oidc_parse_userinfo_refresh_interval(apr_pool_t *pool,\newline		const char *arg, int *int_value) {\newline	return oidc_parse_int_valid(pool, arg, int_value,\newline			oidc_valid_userinfo_refresh_interval);\newline}\newline","\newline parse a userinfo refresh interval from the provided string\newline \newline","5197780","mozplugger-helper.c","static void takeSwallowMutex(void)\newline{\newline     int countDown;\newline     const uint32_t ourPid = (uint32_t)getpid();\newline     const uint32_t ourHostId = getHostId();\newline     uint32_t otherPid;\newline     uint32_t otherHostId;\newline     uint32_t prevOtherPid = 0;\newline \newline     if((display == 0) || (swallowMutex == 0))\newline     {\newline	  return;\newline     }\newline\newline     D(&quotAttempting to take Swallow Mutex\\n&quot); \newline     /* Try up tp forty times ( 40 * 250ms = 10 seconds) to take \newline       the semaphore... */\newline\newline     countDown = 40;\newline     while(1)\newline     {\newline\newline          /* While someone owns the semaphore */\newline          while(getSwallowMutexOwner(&ampotherHostId, &ampotherPid))\newline          {\newline               if( otherHostId == ourHostId)    \newline               {\newline                    if(otherPid == ourPid)     \newline                    {\newline 	                /* Great we have either successfully taken the semaphore\newline                           OR (unlikely) we previously had the semaphore! Exit\newline                           the function...*/\newline	                 swallowMutexTaken = 1;\newline                         D(&quotTaken Swallow Mutex\\n&quot); \newline		         return;\newline                    }\newline\newline     	    	    D(&quotSemaphore currently taken by pid=%ld\\n&quot, (long) otherPid);\newline 		    /* Check that the process that has the semaphore exists...\newline        	     Bit of a hack, I cant find a function to directly check\newline                     if process exists. */\newline            	    if( (getsid(otherPid) &lt 0 ) &amp&amp (errno == ESRCH))\newline	            {\newline	    	         D(&quotStrange other Pid(%lu) cannot be found\\n&quot,(unsigned long) otherPid);\newline                         XDeleteProperty(display, wattr.root, swallowMutex);\newline                         break;    /* OK force early exit of inner while loop */\newline                    }\newline	       }\newline\newline               /* Check if the owner of semaphore hasn&#039t recently changed if it\newline                has restart timer */\newline               if(prevOtherPid != otherPid)\newline               {\newline   	            D(&quotLooks like semaphore&#039s owner has changed pid=%ld\\n&quot, \newline                        (long) otherPid);\newline	            countDown = 40;\newline                    prevOtherPid = otherPid;\newline               }\newline            \newline               /* Do one step of the timer... */\newline	       countDown--;\newline               if(countDown &lt= 0)\newline               {\newline	    	    D(&quotWaited long enough for Pid(%lu)\\n&quot, (unsigned long) otherPid);\newline                    XDeleteProperty(display, wattr.root, swallowMutex);\newline		    break;\newline               }\newline	\newline               usleep(250000);        /* 250ms */\newline 	  }\newline\newline          /* else no one has semaphore, timeout, or owner is dead -\newline           Set us as the owner, but we need to check if we weren&#039t \newline           beaten to it so once more around the loop.\newline           Note even doing the recheck does not work in 100% of all\newline           cases due to task switching occuring at just the wrong moment\newline           see Mozdev bug 20088 - the fix is done use the stillHaveMutex\newline           function */\newline\newline          setSwallowMutexOwner(ourHostId, ourPid);\newline     }\newline}\newline","\newline Take mutex semaphore ownership.\newline \newline @return none\newline \newline \newline","242872","test4.c","static void stop_thread(Thread *p){\newline  thread_wait(p);\newline  p-&gtxOp = 0;\newline  p-&gtopnum++;\newline  thread_wait(p);\newline  sqliteFree(p-&gtzArg);\newline  p-&gtzArg = 0;\newline  sqliteFree(p-&gtzFilename);\newline  p-&gtzFilename = 0;\newline  p-&gtbusy = 0;\newline}\newline","\newline Stop a thread.\newline \newline","1467069","u12-if.c","static SANE_Bool u12if_IsDeviceSupported( U12_Device *dev )\newline{\newline	int i;\newline\newline	for( i = 0; NULL != u12Devices[i].name; i++ ) {\newline\newline		if( !strcmp( dev-&gtusbId, u12Devices[i].vp )) {\newline			dev-&gtsane.model = u12Devices[i].name;\newline			return SANE_TRUE;\newline		}\newline	}\newline\newline	return SANE_FALSE;\newline}\newline","This function checks wether a device, described by a given\newline string(vendor and product ID), is supported by this backend or not\newline \newline @param usbIdStr - sting consisting out of product and vendor ID\newline format: &quot0xVVVV-0xPPPP&quot VVVV = Vendor ID, PPP = Product ID\newline @returns; SANE_TRUE if supported, SANE_FALSE if not\newline \newline","675722","read-dict.c","static Exp * in_parens(Dictionary dict)\newline{\newline	Exp * e;\newline\newline	if (is_equal(dict, &#039&amp&#039) || (strcmp(token, &quotand&quot)==0)) {\newline		if (!link_advance(dict)) {\newline			return NULL;\newline		}\newline		return operator_exp(dict, AND_type);\newline	} else if (is_equal(dict, &#039|&#039) || (strcmp(dict-&gttoken, &quotor&quot)==0)) {\newline		if (!link_advance(dict)) {\newline			return NULL;\newline		}\newline		return operator_exp(dict, OR_type);\newline	} else {\newline		return expression(dict);\newline	}\newline}\newline","\newline Looks for the stuff that is allowed to be inside of parentheses\newline either &amp or | followed by a list, or a terminal symbol.\newline \newline","2204986","cplot.c","int	cplot_counts(fieldstruct *field)\newline  {\newline   wcsstruct	*wcsptr[2],\newline		*wcs, *wcsout;\newline   PLFLT	**count,\newline		clevel[CPLOT_NSHADES], cpoint[3], r[3],g[3],b[3],\newline		cmin,cmax, mc,dc;\newline   PLINT	lwid;\newline   char		*ctype[NAXIS],\newline		str[80];\newline   double	crpix[NAXIS], cdelt[NAXIS], raw[NAXIS],\newline		xmin,ymin,xmax,ymax, xstep,ystep, dval;\newline   int		naxisn[NAXIS],\newline		**icount,\newline		i,j, e, n,nt, naxis, nsnap,nsnap2, flag;\newline\newline  if (cplot_init(field-&gtrcatname, 1,1, CPLOT_COUNTS) == RETURN_ERROR)\newline    {\newline    cplot_end(CPLOT_COUNTS);\newline    return RETURN_OK;\newline    }\newline\newline  wcs = field-&gtwcs[0];\newline  if (!wcs || wcs-&gtnaxis&lt2)\newline    return RETURN_ERROR;\newline  naxis = wcs-&gtnaxis;\newline  for (i=0; i&ltnaxis; i++)\newline    {\newline    QMALLOC(ctype[i], char, 16); \newline    strncpy(ctype[i],wcs-&gtctype[i], 16);\newline    crpix[i] = 50.0;\newline    cdelt[i] = field-&gtmaxradius/50.0;\newline    if (i==wcs-&gtlng)\newline      cdelt[i] = -cdelt[i];	/* Put East to the left */\newline    naxisn[i] = 100;\newline    }\newline\newline  wcsout = create_wcs(ctype,field-&gtmeanwcspos,crpix,cdelt,naxisn, naxis);\newline\newline  xmin = 0.5;\newline  xmax = 100.5;\newline  ymin = 0.5;\newline  ymax = 100.5;\newline  lwid = plotaaflag? ((CPLOT_AAFAC+1)/2) : 1;\newline  plwidth((double)lwid);\newline  plfont(2);\newline  plcol0(15);\newline  plenv((PLFLT)xmin, (PLFLT)xmax, (PLFLT)ymin, (PLFLT)ymax, 1, -1);\newline  sprintf(str, &quot#uField %.24s: source count map&quot, field-&gtrtcatname);\newline  plschr(0.0, 1.0);\newline  pllab(&quot&quot,&quot&quot, str);\newline  plwidth(0.0);\newline  plcol0(7);\newline  cplot_drawloccoordgrid(wcsout, xmin, xmax, ymin, ymax);\newline\newline  pllsty(1);\newline  plcol0(15);\newline  plscmap1n(256);\newline\newline  cmin = BIG;\newline  cmax = -BIG;\newline\newline/* First pass through the data to find min and max number counts */\newline  flag = 0;\newline  icount = field-&gtlcount;\newline  nsnap = prefs.context_nsnap;\newline  nt = nsnap*nsnap;\newline  for (e=0; e&ltfield-&gtnext; e++)\newline    for (n=0; n&ltnt; n++)\newline      {\newline      dval = (double)icount[e][n];\newline      if (dval &lt cmin)\newline        cmin = dval;\newline      if (dval &gt cmax)\newline        cmax = dval;\newline      }\newline\newline/* Lower bound to variability in counts is 1e-4 */\newline  if ((mc=(cmin+cmax)/2.0) &lt  1.0e-10)\newline    mc = 1.0e-10;\newline  if ((dc=cmax-cmin) &lt 1.0e-4*mc)\newline    dc = 1.0e-4*mc;\newline  cmin = mc - dc/2.0;\newline  cmax = mc + dc/2.0;\newline\newline  for (i=0; i&ltCPLOT_NSHADES; i++)\newline    clevel[i] = cmin + (i-0.5) * dc / (CPLOT_NSHADES-2);\newline  cpoint[0] = 0.0; r[0] = 0.5; g[0] = 0.5; b[0] = 1.0;\newline  cpoint[1] = 0.5; r[1] = 0.5; g[1] = 1.0; b[1] = 0.5;\newline  cpoint[2] = 1.0; r[2] = 1.0; g[2] = 0.5; b[2] = 0.5;\newline  plscmap1l(1, 3, cpoint, r, g, b, NULL);\newline\newline/* Now the real 2D count mapping */\newline  nsnap2 = nsnap&gt1? nsnap : 2;\newline  for (e=0; e&ltfield-&gtnext; e++)\newline    {\newline    wcs = field-&gtwcs[e];\newline    plAlloc2dGrid(&ampcount, nsnap2, nsnap2);\newline    for (i=0; i&ltnaxis; i++)\newline      raw[i] = wcs-&gtnaxisn[i]/2.0 + 0.5;\newline    xstep = wcs-&gtnaxisn[0] / (nsnap2-1);\newline    ystep = wcs-&gtnaxisn[1] / (nsnap2-1);\newline    if (nsnap &gt 1)\newline      for (j=0; j&ltnsnap2; j++)\newline        for (i=0; i&ltnsnap2; i++)\newline          count[i][j] = (PLFLT)icount[e][j*nsnap+i];\newline    else\newline      for (j=0; j&ltnsnap2; j++)\newline        for (i=0; i&ltnsnap2; i++)\newline          count[i][j] = (PLFLT)icount[e][0];\newline    wcsptr[0] = wcs;\newline    wcsptr[1] = wcsout;\newline    plshades(count, nsnap2, nsnap2, NULL,\newline	     xstep/2.0+0.5, wcs-&gtnaxisn[0]-xstep/2.0+0.5,\newline             ystep/2.0+0.5, wcs-&gtnaxisn[1]-ystep/2.0+0.5,\newline	     clevel, CPLOT_NSHADES, 1, 0, 0, plfill, 0, distort_map, wcsptr);\newline    plFree2dGrid(count, nsnap2, nsnap2);\newline    plcol0(7);\newline    plwidth((double)lwid);\newline    cplot_drawbounds(wcs, wcsout);\newline    }\newline\newline/* Draw left colour scale */\newline  plAlloc2dGrid(&ampcount, 2, CPLOT_NSHADES);\newline  for (j=0; j&ltCPLOT_NSHADES; j++)\newline    count[0][j] = count[1][j] = cmin + j * dc/(CPLOT_NSHADES-1);\newline\newline  plvpor(0.91,0.935,0.115,0.885);\newline  plwind(0.0,1.0,cmin,cmax);\newline  plshades(count, 2, CPLOT_NSHADES, NULL, 0.0, 1.0, cmin,cmax, clevel,\newline	   CPLOT_NSHADES, 1, 0, 0, plfill, 1, NULL, NULL);\newline  plcol0(15);\newline  plschr(0.0, 0.5);\newline  plbox(&quotbc&quot, 0.0, 0, &quotbnstv&quot, 0.0, 0);\newline  plschr(0.0, 0.6);\newline  plmtex(&quotl&quot, 5.0, 0.5, 0.5, &quotnumber&quot);\newline  plmtex(&quotb&quot, 2.0, 0.5, 0.5, &quotsource ##&quot);\newline\newline  plFree2dGrid(count, 2, CPLOT_NSHADES);\newline  plend();\newline  end_wcs(wcsout);\newline  for (i=0; i&ltnaxis; i++)\newline    free(ctype[i]);\newline\newline  cplot_counts(field);		/* Recursive stuff */\newline\newline  return RETURN_OK;\newline  }\newline","cplot_counts \newlinePROTO int cplot_counts(fieldstruct field)\newlinePURPOSE Plot an x,y map of the number of sources that has been loaded.\newlineINPUT Pointer to the field.\newlineOUTPUT RETURN_OK if everything went fine, RETURN_ERROR otherwise.\newlineNOTES -.\newlineAUTHOR E. Bertin (IAP)\newlineVERSION 16/04/2012\newline \newline","3681942","gnix_ep.c","DIRECT_FN STATIC ssize_t gnix_ep_tinjectdata(struct fid_ep *ep, const void *buf,\newline					     size_t len, uint64_t data,\newline					     fi_addr_t dest_addr, uint64_t tag)\newline{\newline	return __ep_inject(ep, buf, len, data, dest_addr,\newline			  FI_TAGGED | FI_REMOTE_CQ_DATA, tag);\newline}\newline","\newline Injects data into the data buffer and returns immediately.\newline \newline @param[in] ep the endpoint we are sending data from\newline @param[in] buf the data to send\newline @param[in] len the length of buf\newline @param[in] data remote CQ data to transfer with the data from buf\newline @param[in] dest_addr the desitnation address for connectionless transfers\newline @param[in] tag the tag associated with the message\newline \newline @return FI_SUCCESS upon successfully writing to the destination\newline @return -FI_ERRNO upon an error\newline @return -FI_ENOSYS if this operation is not supported\newline \newline","1886709","tccgen.c","void vpush64(int ty, unsigned long long v)\newline{\newline	CValue cval;\newline	CType ctype;\newline	ctype.t = ty;\newline	ctype.ref = NULL;\newline	cval.ull = v;\newline	vsetc(&ampctype, VT_CONST, &ampcval);\newline}\newline","push arbitrary 64 bit constant \newline","1653670","generate_custom_hufftables.c","void fprint_uint8_table(FILE * outfile, uint8_t * table, uint64_t length, char *header,\newline			char *footer, char *begin_line)\newline{\newline	int i;\newline	fprintf(outfile, &quot%s&quot, header);\newline	for (i = 0; i &lt length - 1; i++) {\newline		if ((i &amp 7) == 0)\newline			fprintf(outfile, &quot\\n%s&quot, begin_line);\newline		else\newline			fprintf(outfile, &quot &quot);\newline		fprintf(outfile, &quot0x%02x,&quot, table[i]);\newline	}\newline\newline	if ((i &amp 7) == 0)\newline		fprintf(outfile, &quot\\n%s&quot, begin_line);\newline	else\newline		fprintf(outfile, &quot &quot);\newline	fprintf(outfile, &quot0x%02x&quot, table[i]);\newline	fprintf(outfile, &quot%s&quot, footer);\newline\newline}\newline","\newline @brief Prints a table of uint8_t elements to a file.\newline @param outfile: the file the table is printed to.\newline @param table: the table to be printed.\newline @param length: number of elements to be printed.\newline @param header: header to append in front of the table.\newline @param footer: footer to append at the end of the table.\newline @param begin_line: string printed at beginning of new line\newline \newline","3465045","coerce.c","static SEXP coerceVectorList(SEXP v, SEXPTYPE type)\newline{\newline    int warn = 0, tmp;\newline    R_xlen_t i, n;\newline    SEXP rval, names;\newline\newline    names = v;\newline    rval = R_NilValue;	/* -Wall */\newline\newline    /* expression -&gt list, new in R 2.4.0 */\newline    if (type == VECSXP &amp&amp TYPEOF(v) == EXPRSXP) {\newline	/* This is sneaky but saves us rewriting a lot of the duplicate code */\newline	rval = MAYBE_REFERENCED(v) ? duplicate(v) : v;\newline	SET_TYPEOF(rval, VECSXP);\newline	return rval;\newline    }\newline\newline    if (type == EXPRSXP &amp&amp TYPEOF(v) == VECSXP) {\newline	rval = MAYBE_REFERENCED(v) ? duplicate(v) : v;\newline	SET_TYPEOF(rval, EXPRSXP);\newline	return rval;\newline    }\newline\newline    if (type == STRSXP) {\newline	n = xlength(v);\newline	PROTECT(rval = allocVector(type, n));\newline#ifdef R_MEMORY_PROFILING\newline	if (RTRACE(v)){\newline	   memtrace_report(v, rval);\newline	   SET_RTRACE(rval,1);\newline	}\newline#endif\newline	for (i = 0; i &lt n;  i++) {\newline	    if (isString(VECTOR_ELT(v, i)) &amp&amp xlength(VECTOR_ELT(v, i)) == 1)\newline		SET_STRING_ELT(rval, i, STRING_ELT(VECTOR_ELT(v, i), 0));\newline#if 0\newline	    /* this will make as.character(list(s)) not backquote\newline	     * non-syntactic name s. It is not entirely clear that\newline	     * that is really desirable though....\newline	     */\newline	    else if (isSymbol(VECTOR_ELT(v, i)))\newline		SET_STRING_ELT(rval, i, PRINTNAME(VECTOR_ELT(v, i)));\newline#endif\newline	    else\newline		SET_STRING_ELT(rval, i,\newline			       STRING_ELT(deparse1line(VECTOR_ELT(v, i), 0), 0));\newline	}\newline    }\newline    else if (type == LISTSXP) {\newline	rval = VectorToPairList(v);\newline	return rval;\newline    }\newline    else if (isVectorizable(v)) {\newline	n = xlength(v);\newline	PROTECT(rval = allocVector(type, n));\newline	switch (type) {\newline	case LGLSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		LOGICAL(rval)[i] = asLogical(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case INTSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		INTEGER(rval)[i] = asInteger(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case REALSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		REAL(rval)[i] = asReal(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case CPLXSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		COMPLEX(rval)[i] = asComplex(VECTOR_ELT(v, i));\newline	    }\newline	    break;\newline	case RAWSXP:\newline	    for (i = 0; i &lt n; i++) {\newline//		if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt();\newline		tmp = asInteger(VECTOR_ELT(v, i));\newline		if (tmp &lt 0 || tmp &gt 255) { /* includes NA_INTEGER */\newline		    tmp = 0;\newline		    warn |= WARN_RAW;\newline		}\newline		RAW(rval)[i] = (Rbyte) tmp;\newline	    }\newline	    break;\newline	default:\newline	    UNIMPLEMENTED_TYPE(&quotcoerceVectorList&quot, v);\newline	}\newline    }\newline    else\newline	error(_(&quot(list) object cannot be coerced to type &#039%s&#039&quot),\newline	      type2char(type));\newline\newline    if (warn) CoercionWarning(warn);\newline    names = getAttrib(v, R_NamesSymbol);\newline    if (names != R_NilValue)\newline	setAttrib(rval, R_NamesSymbol, names);\newline    UNPROTECT(1);\newline    return rval;\newline}\newline","Coerce a vector list to the given type \newline","5514970","utils.c","char match_p33_merge(char pA, char pB){\newline  pA = min(pA, maximum_quality);\newline  pB = min(pB, maximum_quality);\newline  char res = pA+(pB-33);\newline  return max(min(res,maximum_quality), MIN_QUAL);\newline}\newline","\newline Calculates the resulting phred 33 score given a match\newline \newline","","on","on","on","","","","","","on","","","","","on","on","","","","","","","","","","","on","","","","","","","","","","","","","","","","initialize connection pools.","{}","{}","{}","Stop a thread.","checks wether a device,","Looks for the stuff that is allowed to be inside of parentheses","Plot an x,y map","Injects data into the data buffer and returns immediately.","{}","Prints a table of uint8_t elements to a file.","This builds our object tree.","Coerce a vector list","Calculates the resulting phred 33 score","{}","{}","track the memory updating from device.","Checks if the given key size is supported by the algorithm","Stop the program","Returns the 1st matching fstab_rec that follows the start_rec.","Get cache entry status"
"3BFF0DJK8XC868LPV2XLKGZ91R1TSK","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3NJM2BJS4W6WUJ0F7132PKQJ69YPCP","AVC62JNYAXA45","Approved","Wed Apr 17 14:23:51 PDT 2019","Wed Apr 17 15:01:28 PDT 2019","Fri Apr 19 15:01:28 PDT 2019","2019-04-19 22:02:21 UTC","","","2257","100% (24/24)","100% (24/24)","100% (24/24)","2029903","bmc.c","void p1(PtpClock *ptpClock, const RunTimeOpts *rtOpts)\newline{\newline	/* make sure we revert to ARB timescale in Passive mode*/\newline	if(ptpClock-&gtportState == PTP_PASSIVE){\newline		ptpClock-&gttimePropertiesDS.currentUtcOffsetValid = rtOpts-&gttimeProperties.currentUtcOffsetValid;\newline		ptpClock-&gttimePropertiesDS.currentUtcOffset = rtOpts-&gttimeProperties.currentUtcOffset;\newline	}\newline	\newline}\newline","first cut on a passive mode specific BMC actions \newline","2936668","pthread_support.c","void GC_fork_prepare_proc(void)\newline{\newline    /* Acquire all relevant locks, so that after releasing the locks	*/\newline    /* the child will see a consistent state in which monitor 		*/\newline    /* invariants hold.	 Unfortunately, we can&#039t acquire libc locks	*/\newline    /* we might need, and there seems to be no guarantee that libc	*/\newline    /* must install a suitable fork handler.				*/\newline    /* Wait for an ongoing GC to finish, since we can&#039t finish it in	*/\newline    /* the (one remaining thread in) the child.				*/\newline      LOCK();\newline#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\newline        GC_wait_for_reclaim();\newline#     endif\newline      GC_wait_for_gc_completion(TRUE);\newline#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\newline        GC_acquire_mark_lock();\newline#     endif\newline}\newline","Called before a fork() \newline","85399","abo.c","LOCAL void output_about_udo_eng ( FILE *f )\newline{\newline	fprintf(f, &quot%s\\n&quot, CMD_BEGIN_CENTER);\newline	fprintf(f, &quotThis text was made with\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot(!B)UDO(!b)\\t(!nl)\\n&quot);\newline	fprintf(f, &quotVersion %s.%s.%s\\t(!nl)\\n&quot, UDO_REL, UDO_SUBVER, UDO_PL);\newline	fprintf(f, &quot%s\\n&quot, UDO_OS);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, UDO_COPYRIGHT_TEXT);\newline	fprintf(f, &quotUDO is Open Source\\t(!nl)\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot!udolink\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quotUDO is a program that converts files that are written\\n&quot);\newline	fprintf(f, &quotin the Universal Document Format into ASCII, ST-Guide, LaTeX,\\n&quot);\newline	fprintf(f, &quotRich Text Format, Pure C Help, Manualpage, HTML, WinHelp\\n,&quot);\newline	fprintf(f, &quotTexinfo, Linuxdoc-SGML, LyX, Apple QuickView and Turbo-Vision-Help.\\n&quot);\newline	fprintf(f, &quotFurther information and the current versions can be found at\\t(!nl)\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot(!url [%s] [])\\n&quot, UDO_URL);\newline	fprintf(f, &quot%s\\n\\n&quot, CMD_END_CENTER);\newline\newline}	/* output_about_udo_eng */\newline","############################################################\newline # Englischer Text fuer !english, !french\newline ############################################################ \newline","6200517","load_m15.c","static int CheckPatternType(int numpat)\newline{\newline	int t;\newline	UBYTE eff, dat;\newline\newline	for(t=0;t&ltnumpat*(64U*4);t++) {\newline		/* Load the pattern into the temp buffer and scan it */\newline		_mm_skip_BYTE(modreader);_mm_skip_BYTE(modreader);\newline		eff = _mm_read_UBYTE(modreader);\newline		dat = _mm_read_UBYTE(modreader);\newline\newline		switch(eff) {\newline			case 1:\newline				if(dat&gt0x1f) return 1;\newline				if(dat&lt0x3)  return 2;\newline				break;\newline			case 2:\newline				if(dat&gt0x1f) return 1;\newline				return 2;\newline			case 3:\newline				if (dat) return 2;\newline				break;\newline			default:\newline				return 2;\newline		}\newline	}\newline	return 0;\newline}\newline","Checks the patterns in the modfile for UST / 15-inst indications.\newlineFor example, if an effect 3xx is found, it is assumed that the song\newlineis 15-inst. If a 1xx effect has dat greater than 0x20, it is UST.\newlineReturns: 0 indecisive; 1 = UST; 2 = 15-inst \newline","4660114","object.c","void z_remove_obj (void)\newline{\newline    /* If we are monitoring object movements display a short note */\newline\newline    if (f_setup.object_movement) {\newline	stream_mssg_on ();\newline	print_string (&quot@remove_obj &quot);\newline	print_object (zargs[0]);\newline	stream_mssg_off ();\newline    }\newline\newline    /* Call unlink_object to do the job */\newline\newline    unlink_object (zargs[0]);\newline\newline}/* z_remove_obj */\newline","\newline z_remove_obj, unlink an object from its parent and siblings.\newline \newline zargs[0] = object\newline \newline \newline","1784623","g_svcmds.c","void SVCmd_ListIP_f (void)\newline{\newline	int		i;\newline	byte	b[4];\newline\newline	safe_cprintf (NULL, PRINT_HIGH, &quotFilter list:\\n&quot);\newline	for (i=0 ; i&ltnumipfilters ; i++)\newline	{\newline		*(unsigned *)b = ipfilters[i].compare;\newline		safe_cprintf (NULL, PRINT_HIGH, &quot%3i.%3i.%3i.%3i\\n&quot, b[0], b[1], b[2], b[3]);\newline	}\newline}\newline","\newline=================\newlineSV_ListIP_f\newline=================\newline \newline","313312","objects.c","contactsmember *add_contact_to_object(contactsmember **object_ptr, char *contactname) {\newline	contactsmember *new_contactsmember = NULL;\newline\newline	/* make sure we have the data we need */\newline	if (object_ptr == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Contact object is NULL\\n&quot);\newline		return NULL;\newline	}\newline\newline	if (contactname == NULL || !strcmp(contactname, &quot&quot)) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Contact name is NULL\\n&quot);\newline		return NULL;\newline	}\newline\newline	/* allocate memory for a new member */\newline	if ((new_contactsmember = malloc(sizeof(contactsmember))) == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Could not allocate memory for contact\\n&quot);\newline		return NULL;\newline	}\newline	if ((new_contactsmember-&gtcontact_name = (char *)strdup(contactname)) == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Could not allocate memory for contact name\\n&quot);\newline		my_free(new_contactsmember);\newline		return NULL;\newline	}\newline\newline	/* set initial values */\newline#ifdef NSCORE\newline	new_contactsmember-&gtcontact_ptr = NULL;\newline#endif\newline\newline	/* add the new contact to the head of the contact list */\newline	new_contactsmember-&gtnext = *object_ptr;\newline	*object_ptr = new_contactsmember;\newline\newline	return new_contactsmember;\newline}\newline","adds a contact to an object \newline","5068911","html2.c","static GList *pointer_arr2glist(gchar **arr) {\newline	gchar **tmp;\newline	GList *retlist = NULL;\newline\newline	if (!arr) {\newline		return NULL;\newline	}\newline	tmp = arr;\newline	while (*tmp) {\newline		retlist = g_list_append(retlist, *tmp);\newline		tmp++;\newline	}\newline	return retlist;\newline}\newline","the list should be freed, the contents of the list should NOT \newline","5097521","io.c","static long read_stream( FILE * const fp, const int addr )\newline  {\newline  line_t * lp = search_line_node( addr );\newline  undo_t * up = 0;\newline  long total_size = 0;\newline  const bool o_isbinary = isbinary();\newline  const bool appended = ( addr == last_addr() );\newline  bool newline_added_now = false;\newline\newline  set_current_addr( addr );\newline  while( true )\newline    {\newline    int size = 0;\newline    const char * const s = read_stream_line( fp, &ampsize, &ampnewline_added_now );\newline    if( !s ) return -1;\newline    if( size &gt 0 ) total_size += size;\newline    else break;\newline    disable_interrupts();\newline    if( !put_sbuf_line( s, size + newline_added_now, current_addr() ) )\newline      { enable_interrupts(); return -1; }\newline    lp = lp-&gtq_forw;\newline    if( up ) up-&gttail = lp;\newline    else\newline      {\newline      up = push_undo_atom( UADD, current_addr(), current_addr() );\newline      if( !up ) { enable_interrupts(); return -1; }\newline      }\newline    enable_interrupts();\newline    }\newline  if( addr &amp&amp appended &amp&amp total_size &amp&amp o_isbinary &amp&amp newline_added() )\newline    fputs( &quotNewline inserted\\n&quot, stderr );\newline  else if( newline_added_now &amp&amp ( !appended || !isbinary() ) )\newline    fputs( &quotNewline appended\\n&quot, stderr );\newline  if( isbinary() &amp&amp !o_isbinary &amp&amp newline_added_now &amp&amp !appended )\newline    ++total_size;\newline  if( !total_size ) newline_added_now = true;\newline  if( appended &amp&amp newline_added_now ) set_newline_added();\newline  return total_size;\newline  }\newline","read a stream into the editor buffer; return total size of data read \newline","4514145","ota_prov.c","static void ota_pack_udh(Msg **msg, Octstr *doc_type)\newline{\newline    (*msg)-&gtsms.udhdata = octstr_create(&quot&quot);\newline    if (octstr_case_compare(doc_type, octstr_imm(&quotoma-settings&quot)) == 0) \newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot0605040B840B84&quot);    \newline    else if (octstr_case_compare(doc_type, octstr_imm(&quotsyncsettings&quot)) == 0) {\newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot060504C34CC002&quot);\newline    } else \newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot060504C34FC002&quot);    \newline }\newline","\newline Append the User Data Header (UDH) including the length (UDHL). Only ports \newline UDH here - SAR UDH is added when (or if) we split the message. This is our\newline specific WDP layer.\newline \newline","6073938","ucftp.c","static int ucftp_open_check(struct ucftpnode *nod, int flags)\newline{\newline    if(nod == NULL) {\newline        if(!(flags &amp AVO_CREAT))\newline            return -ENOENT;\newline        return 0;\newline    }\newline\newline    if((flags &amp AVO_EXCL) != 0)\newline        return -EEXIST;\newline\newline    return ucftp_open_check_type(nod-&gtst.mode, flags);\newline}\newline","called by ucftp_open \newline","6583589","lptree.c","static void fillseq (TTree *tree, int tag, int n, const char *s) {\newline  int i;\newline  for (i = 0; i &lt n - 1; i++) {  /* initial n-1 copies of Seq tag; Seq ... */\newline    tree-&gttag = TSeq; tree-&gtu.ps = 2;\newline    sib1(tree)-&gttag = tag;\newline    sib1(tree)-&gtu.n = s ? (byte)s[i] : 0;\newline    tree = sib2(tree);\newline  }\newline  tree-&gttag = tag;  /* last one does not need TSeq */\newline  tree-&gtu.n = s ? (byte)s[i] : 0;\newline}\newline","\newline Build a sequence of &#039n&#039 nodes, each with tag &#039tag&#039 and &#039u.n&#039 got\newline from the array &#039s&#039 (or 0 if array is NULL). (TSeq is binary, so it\newline must build a sequence of sequence of sequence...)\newline \newline","522578","test_eh_tasks.cpp","void TestMovableException () {\newline    REMARK( &quotTestMovableException\\n&quot );\newline    ResetGlobals();\newline    bool bUnsupported = false;\newline    tbb::task_group_context ctx;\newline    tbb::empty_task *r = new( tbb::task::allocate_root() ) tbb::empty_task;\newline    ASSERT (!g_CurStat.Existing() &amp&amp !g_CurStat.Existed() &amp&amp !g_CurStat.Executed(), \newline            &quotsomething wrong with the task accounting&quot);\newline    r-&gtset_ref_count(NUM_CHILD_TASKS + 1);\newline    for ( int i = 0; i &lt NUM_CHILD_TASKS; ++i )\newline        r-&gtspawn( *new( r-&gtallocate_child() ) LeafTaskWithMovableExceptions );\newline    TRY()\newline        r-&gtwait_for_all();\newline    } catch ( ... ) {\newline        ASSERT (!ctx.is_group_execution_cancelled(), &quot&quot);\newline        CheckException();\newline        try {\newline            throw;\newline        } catch ( tbb::tbb_exception&amp e ) {\newline            CheckException(e);\newline            g_ExceptionCaught = l_ExceptionCaughtAtCurrentLevel = true;\newline        }\newline        catch ( ... ) {\newline            g_ExceptionCaught = true;\newline            g_UnknownException = unknownException = true;\newline        }\newline        try {\newline            ctx.register_pending_exception();\newline        } catch ( ... ) {\newline            bUnsupported = true;\newline            REPORT( &quotWarning: register_pending_exception() failed. This is expected in case of linking with static msvcrt\\n&quot );\newline        }\newline        ASSERT (ctx.is_group_execution_cancelled() || bUnsupported, &quotAfter exception registration the context must be in the cancelled state&quot);\newline    }\newline","Allocates a root task that spawns a bunch of children, one or several of which throw \newlinea movable exception in a worker or master thread (depending on the global settings).\newlineThe test also checks the correctness of multiple rethrowing of the pending exception. \newline","2643459","object.c","void gts_finalize (void)\newline{\newline  if (class_table) {\newline    g_hash_table_foreach (class_table, (GHFunc) free_class, NULL);\newline    g_hash_table_destroy (class_table);\newline    class_table = NULL;\newline  }\newline}\newline","\newline gts_finalize:\newline \newline Free all the memory allocated by the object system of GTS. No other\newline GTS function can be called after this function has been called.\newline \newline","773080","dmeventd.c","static struct dso_data *_lookup_dso(struct message_data *data)\newline{\newline	struct dso_data *dso_data, *ret = NULL;\newline\newline	dm_list_iterate_items(dso_data, &amp_dso_registry)\newline		if (!strcmp(data-&gtdso_name, dso_data-&gtdso_name)) {\newline			ret = dso_data;\newline			break;\newline		}\newline\newline	return ret;\newline}\newline","Find DSO data. \newline","1255171","ocfs2_controld.h","static inline void sleep_ms(unsigned int ms)\newline{\newline	struct timespec ts = {\newline		.tv_sec = ms / 1000,\newline		.tv_nsec = (ms % 1000) * 1000,\newline	};\newline\newline	nanosleep(&ampts, NULL);\newline}\newline","\newline We need to do some retries in more than one file.\newline Here&#039s some code that prints an error as we take a long time to do it.\newline There is a power-of-two backoff on printing the error.\newline \newline","5107732","crc.c","unsigned short crc_macb(register const unsigned char *ptr, register int count,\newline			register unsigned short crc)\newline{\newline  while (count--)\newline    {\newline      crc ^= *ptr++ &lt&lt 8;\newline      crc  = (crc &lt&lt 8) ^ magic[crc &gt&gt 8];\newline    }\newline\newline  return crc;\newline}\newline","\newline NAME: crc-&gtmacb()\newline DESCRIPTION: compute MacBinary II-style CRC value for a block of data\newline \newline","2009337","error.c","int i_failed(int code, char const *msg) {\newline  if (msg)\newline    i_push_error(code, msg);\newline  if (failed_cb)\newline    failed_cb(error_stack + error_sp);\newline  if (failures_fatal) {\newline    int sp;\newline    size_t total; /* total length of error messages */\newline    char *full; /* full message for logging */\newline    if (argv0)\newline      fprintf(stderr, &quot%s: &quot, argv0);\newline    fputs(&quoterror:\\n&quot, stderr);\newline    sp = error_sp;\newline    while (error_stack[sp].msg) {\newline      fprintf(stderr, &quot %s\\n&quot, error_stack[sp].msg);\newline      ++sp;\newline    }\newline    /* we want to log the error too, build an error message to hand to\newline       i_fatal() */\newline    total = 1; /* remember the NUL */\newline    for (sp = error_sp; error_stack[sp].msg; ++sp) {\newline      size_t new_total += strlen(error_stack[sp].msg) + 2;\newline      if (new_total &lt total) {\newline	/* overflow, somehow */\newline	break;\newline      }\newline    }\newline    full = mymalloc(total);\newline    if (!full) {\newline      /* just quit, at least it&#039s on stderr */\newline      exit(EXIT_FAILURE);\newline    }\newline    *full = 0;\newline    for (sp = error_sp; error_stack[sp].msg; ++sp) {\newline      strcat(full, error_stack[sp].msg);\newline      strcat(full, &quot: &quot);\newline    }\newline    /* lose the extra &quot: &quot */\newline    full[strlen(full)-2] = &#039\\0&#039;\newline    i_fatal(EXIT_FAILURE, &quot%s&quot, full);\newline  }\newline\newline  return 0;\newline}\newline","\newline=item i_failed(char const msg)\newlineCalled by Imager code to indicate that a top-level has failed.\newlinemsg can be NULL, in which case no error is pushed.\newlineCalls the current failed callback, if any.\newlineAborts the program with an error, if failures have been set to be fatal.\newlineReturns zero if it does not abort.\newline=cut\newline \newline","2164709","server.c","int try_server(int index, int conn)\newline{\newline	int upfd;\newline	int client = conns[conn].client;\newline	int n = 0, err;\newline	int optval = 1;\newline	struct sockaddr_storage *addr = &ampservers[index].addr;\newline	/* The idea is that a client should be able to connect again to the same server\newline	   even if the server is close to its configured connection limit */\newline	int sticky = ((client != -1) &amp&amp (index == clients[client].server));\newline\newline	if (index == NO_SERVER) {\newline		DEBUG(2, &quotWon&#039t try to connect to NO_SERVER&quot);\newline		return 0;	/* out of bounds */\newline	}\newline	DEBUG(2, &quotTrying server %d for connection %d at time %d&quot, index, conn, now);\newline	if (pen_getport(addr) == 0) {\newline		DEBUG(1, &quotNo port for you!&quot);\newline		return 0;\newline	}\newline	if (now-servers[index].status &lt blacklist_time) {\newline		DEBUG(1, &quotServer %d is blacklisted&quot, index);\newline		return 0;\newline	}\newline	if (servers[index].maxc != 0 &amp&amp\newline	    (servers[index].c &gt= servers[index].maxc) &amp&amp\newline	    (sticky == 0 || servers[index].c &gt= servers[index].hard)) {\newline		DEBUG(1, &quotServer %d is overloaded: sticky=%d, maxc=%d, hard=%d&quot, \\\newline				index, sticky, servers[index].maxc, servers[index].hard);\newline		return 0;\newline	}\newline	if ((client != -1) &amp&amp !match_acl(servers[index].acl, &amp(clients[client].addr))) {\newline		DEBUG(1, &quottry_server: denied by acl&quot);\newline		return 0;\newline	}\newline	upfd = socket_nb(addr-&gtss_family, udp ? SOCK_DGRAM : SOCK_STREAM, 0);\newline\newline	if (keepalive) {\newline		setsockopt(upfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&ampoptval, sizeof optval);\newline	}\newline\newline	if (debuglevel &gt 1) {\newline		debug(&quotConnecting to %s&quot, pen_ntoa(addr));\newline		pen_dumpaddr(addr);\newline	}\newline	conns[conn].t = now;\newline\newline	if (source) {\newline		/* specify local address for upstream connection */\newline		int n = bind(upfd, (struct sockaddr *)source, pen_ss_size(source));\newline		if (n == -1) {\newline			debug(&quotbind: %s&quot, strerror(errno));\newline		}\newline	} else if (transparent) {\newline		/* use originating client&#039s address for upstream connection */\newline		spoof_bind(index, conn, upfd);\newline	}\newline\newline	n = connect(upfd, (struct sockaddr *)addr, pen_ss_size(addr));\newline	err = socket_errno;\newline	DEBUG(2, &quotconnect (upfd = %d) returns %d, errno = %d, socket_errno = %d&quot,\newline		upfd, n, errno, err);\newline	/* A new complication is that we don&#039t know yet if the connect will succeed. */\newline	if (n == 0) {		/* connection completed */\newline		conns[conn].state = CS_CONNECTED;\newline		if (conns[conn].downfd == -1) {\newline			/* idler */\newline			conns[conn].state |= CS_CLOSED_DOWN;\newline		}\newline		event_add(upfd, EVENT_READ);\newline		event_add(conns[conn].downfd, EVENT_READ);\newline		servers[index].c++;\newline		if (servers[index].status) {\newline			servers[index].status = 0;\newline			DEBUG(1, &quotServer %d ok&quot, index);\newline		}\newline		DEBUG(2, &quotSuccessful connect to server %d\\n&quot \\\newline			&quotconns[%d].client = %d\\n&quot \\\newline			&quotconns[%d].server = %d&quot, \\\newline			index, conn, conns[conn].client, conn, conns[conn].server);\newline	} else if (err == CONNECT_IN_PROGRESS) {	/* may potentially succeed */\newline		conns[conn].state = CS_IN_PROGRESS;\newline		pending_list = dlist_insert(pending_list, conn);\newline		conns[conn].pend = pending_list;\newline		pending_queue++;\newline		event_add(upfd, EVENT_WRITE);\newline		DEBUG(2, &quotPending connect to server %d\\n&quot \\\newline			&quotconns[%d].client = %d\\n&quot \\\newline			&quotconns[%d].server = %d&quot, \\\newline			index, conn, conns[conn].client, conn, conns[conn].server);\newline	} else {		/* failed definitely */\newline		if (servers[index].status == 0) {\newline			debug(&quotServer %d failed, retry in %d sec: %d&quot,\newline				index, blacklist_time, socket_errno);\newline		}\newline		debug(&quotblacklisting server %d because connect error %d&quot, index, err);\newline		blacklist_server(index);\newline		close(upfd);\newline		return 0;\newline	}\newline	conns[conn].server = index;\newline	DEBUG(2, &quotSetting server %d for client %d&quot, index, client);\newline	clients[client].server = index;\newline	current = index;\newline	conns[conn].upfd = upfd;\newline	fd2conn_set(upfd, conn);\newline	return 1;\newline}\newline","return 1 for (potential) success, 0 for failure \newline","6659108","cdw_file_manager.c","bool cdw_file_manager_file_properties_is_appendable(cdw_file_t const * file)\newline{\newline	if (file-&gtinvalid) {\newline		cdw_vdm (&quotINFO: invalid file is not appendable\\n&quot);\newline		return false;\newline\newline	} else if (file-&gtis_ref_to_parent_dir) {\newline		/* Never allow selecting parent dir. */\newline		cdw_vdm (&quotINFO: parent dir is not appendable\\n&quot);\newline		return false;\newline\newline	} else if (!(file-&gttype &amp CDW_FS_FILE) &amp&amp !(file-&gttype &amp CDW_FS_DIR)) {\newline		/* Only directories and regular files (or links to them - notice the &#039&amp&#039 operator) allowed. */\newline		cdw_vdm (&quotINFO: file of strange type \\&quot0x%x\\&quot is not appendable\\n&quot, file-&gttype);\newline		return false;\newline\newline	} else {\newline		return true;\newline	}\newline}\newline","\newline\\brief Decide if given file can be appended to list of selected files based on file&#039s properties\newline\\date Function&#039s top-level comment reviewed on 2016-02-20\newline\\date Function&#039s body reviewed on 2016-02-20\newlineThe function only check properties of the file itself. The file may\newlinebe OK, but caller still may want to not to append the file because\newlineit already exists on list of selected files. It is up to caller to\newlinedo any additional checks.\newline\\param file - file to be checked\newline\\return true if file can be appended to list of selected files\newline\\return false otherwise\newline \newline","161172","main.c","static void parse_dimensions(char *s, char **endptr, dim_t *dxp, dim_t *dyp) {\newline  char *p, *q;\newline  dim_t dx, dy;\newline\newline  dx = parse_dimension(s, &ampp);\newline  if (p==s) {\newline    goto fail;\newline  }\newline  if (*p != &#039x&#039) {\newline    goto fail;\newline  }\newline  p++;\newline  dy = parse_dimension(p, &ampq);\newline  if (q==p) {\newline    goto fail;\newline  }\newline  if (dx.d &amp&amp !dy.d) {\newline    dy.d = dx.d;\newline  } else if (!dx.d &amp&amp dy.d) {\newline    dx.d = dy.d;\newline  }\newline  *dxp = dx;\newline  *dyp = dy;\newline  if (endptr != NULL) {\newline    *endptr = q;\newline  }\newline  return;\newline\newline fail:\newline  dx.x = dx.d = dy.x = dy.d = 0;\newline  *dxp = dx;\newline  *dyp = dy;\newline  if (endptr != NULL) {\newline    *endptr = s;\newline  }\newline  return;\newline}\newline","parse a pair of dimensions, such as &quot8.5x11in&quot, &quot30mmx4cm&quot \newline","on","","on","","","","","","","","on","on","","","on","","","on","","on","","","","","","on","","","","","on","","","","","","","","","","","on","{}","Append the User Data Header","{}","Build a sequence of 'n' nodes,","Allocates a root task","Free all the memory allocated by the object system of GTS.","Find DSO data.","prints an error","compute MacBinary II-style CRC value for a block of data","Calls the current failed callback, if any.","{}","{}","Decide if given file can be appended to list","parse a pair of dimensions,","{}","Checks the patterns in the modfile for UST / 15-inst indications.","unlink an object from its parent and siblings.","{}","adds a contact to an object","{}","read a stream into the editor buffer;"
"3BFF0DJK8XC868LPV2XLKGZ91R1TSK","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3WLEIWSYHOHRJKAPRV6R4YF68S9H23","AMD1LYNQAH3R8","Approved","Wed Apr 17 16:38:19 PDT 2019","Wed Apr 17 16:45:12 PDT 2019","Fri Apr 19 16:45:12 PDT 2019","2019-04-19 23:45:21 UTC","","","413","100% (27/27)","100% (27/27)","100% (27/27)","2029903","bmc.c","void p1(PtpClock *ptpClock, const RunTimeOpts *rtOpts)\newline{\newline	/* make sure we revert to ARB timescale in Passive mode*/\newline	if(ptpClock-&gtportState == PTP_PASSIVE){\newline		ptpClock-&gttimePropertiesDS.currentUtcOffsetValid = rtOpts-&gttimeProperties.currentUtcOffsetValid;\newline		ptpClock-&gttimePropertiesDS.currentUtcOffset = rtOpts-&gttimeProperties.currentUtcOffset;\newline	}\newline	\newline}\newline","first cut on a passive mode specific BMC actions \newline","2936668","pthread_support.c","void GC_fork_prepare_proc(void)\newline{\newline    /* Acquire all relevant locks, so that after releasing the locks	*/\newline    /* the child will see a consistent state in which monitor 		*/\newline    /* invariants hold.	 Unfortunately, we can&#039t acquire libc locks	*/\newline    /* we might need, and there seems to be no guarantee that libc	*/\newline    /* must install a suitable fork handler.				*/\newline    /* Wait for an ongoing GC to finish, since we can&#039t finish it in	*/\newline    /* the (one remaining thread in) the child.				*/\newline      LOCK();\newline#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\newline        GC_wait_for_reclaim();\newline#     endif\newline      GC_wait_for_gc_completion(TRUE);\newline#     if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\newline        GC_acquire_mark_lock();\newline#     endif\newline}\newline","Called before a fork() \newline","85399","abo.c","LOCAL void output_about_udo_eng ( FILE *f )\newline{\newline	fprintf(f, &quot%s\\n&quot, CMD_BEGIN_CENTER);\newline	fprintf(f, &quotThis text was made with\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot(!B)UDO(!b)\\t(!nl)\\n&quot);\newline	fprintf(f, &quotVersion %s.%s.%s\\t(!nl)\\n&quot, UDO_REL, UDO_SUBVER, UDO_PL);\newline	fprintf(f, &quot%s\\n&quot, UDO_OS);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, UDO_COPYRIGHT_TEXT);\newline	fprintf(f, &quotUDO is Open Source\\t(!nl)\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot!udolink\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quotUDO is a program that converts files that are written\\n&quot);\newline	fprintf(f, &quotin the Universal Document Format into ASCII, ST-Guide, LaTeX,\\n&quot);\newline	fprintf(f, &quotRich Text Format, Pure C Help, Manualpage, HTML, WinHelp\\n,&quot);\newline	fprintf(f, &quotTexinfo, Linuxdoc-SGML, LyX, Apple QuickView and Turbo-Vision-Help.\\n&quot);\newline	fprintf(f, &quotFurther information and the current versions can be found at\\t(!nl)\\n&quot);\newline	fprintf(f, &quot\\n&quot);\newline	fprintf(f, &quot(!url [%s] [])\\n&quot, UDO_URL);\newline	fprintf(f, &quot%s\\n\\n&quot, CMD_END_CENTER);\newline\newline}	/* output_about_udo_eng */\newline","############################################################\newline # Englischer Text fuer !english, !french\newline ############################################################ \newline","6200517","load_m15.c","static int CheckPatternType(int numpat)\newline{\newline	int t;\newline	UBYTE eff, dat;\newline\newline	for(t=0;t&ltnumpat*(64U*4);t++) {\newline		/* Load the pattern into the temp buffer and scan it */\newline		_mm_skip_BYTE(modreader);_mm_skip_BYTE(modreader);\newline		eff = _mm_read_UBYTE(modreader);\newline		dat = _mm_read_UBYTE(modreader);\newline\newline		switch(eff) {\newline			case 1:\newline				if(dat&gt0x1f) return 1;\newline				if(dat&lt0x3)  return 2;\newline				break;\newline			case 2:\newline				if(dat&gt0x1f) return 1;\newline				return 2;\newline			case 3:\newline				if (dat) return 2;\newline				break;\newline			default:\newline				return 2;\newline		}\newline	}\newline	return 0;\newline}\newline","Checks the patterns in the modfile for UST / 15-inst indications.\newlineFor example, if an effect 3xx is found, it is assumed that the song\newlineis 15-inst. If a 1xx effect has dat greater than 0x20, it is UST.\newlineReturns: 0 indecisive; 1 = UST; 2 = 15-inst \newline","4660114","object.c","void z_remove_obj (void)\newline{\newline    /* If we are monitoring object movements display a short note */\newline\newline    if (f_setup.object_movement) {\newline	stream_mssg_on ();\newline	print_string (&quot@remove_obj &quot);\newline	print_object (zargs[0]);\newline	stream_mssg_off ();\newline    }\newline\newline    /* Call unlink_object to do the job */\newline\newline    unlink_object (zargs[0]);\newline\newline}/* z_remove_obj */\newline","\newline z_remove_obj, unlink an object from its parent and siblings.\newline \newline zargs[0] = object\newline \newline \newline","1784623","g_svcmds.c","void SVCmd_ListIP_f (void)\newline{\newline	int		i;\newline	byte	b[4];\newline\newline	safe_cprintf (NULL, PRINT_HIGH, &quotFilter list:\\n&quot);\newline	for (i=0 ; i&ltnumipfilters ; i++)\newline	{\newline		*(unsigned *)b = ipfilters[i].compare;\newline		safe_cprintf (NULL, PRINT_HIGH, &quot%3i.%3i.%3i.%3i\\n&quot, b[0], b[1], b[2], b[3]);\newline	}\newline}\newline","\newline=================\newlineSV_ListIP_f\newline=================\newline \newline","313312","objects.c","contactsmember *add_contact_to_object(contactsmember **object_ptr, char *contactname) {\newline	contactsmember *new_contactsmember = NULL;\newline\newline	/* make sure we have the data we need */\newline	if (object_ptr == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Contact object is NULL\\n&quot);\newline		return NULL;\newline	}\newline\newline	if (contactname == NULL || !strcmp(contactname, &quot&quot)) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Contact name is NULL\\n&quot);\newline		return NULL;\newline	}\newline\newline	/* allocate memory for a new member */\newline	if ((new_contactsmember = malloc(sizeof(contactsmember))) == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Could not allocate memory for contact\\n&quot);\newline		return NULL;\newline	}\newline	if ((new_contactsmember-&gtcontact_name = (char *)strdup(contactname)) == NULL) {\newline		logit(NSLOG_CONFIG_ERROR, TRUE, &quotError: Could not allocate memory for contact name\\n&quot);\newline		my_free(new_contactsmember);\newline		return NULL;\newline	}\newline\newline	/* set initial values */\newline#ifdef NSCORE\newline	new_contactsmember-&gtcontact_ptr = NULL;\newline#endif\newline\newline	/* add the new contact to the head of the contact list */\newline	new_contactsmember-&gtnext = *object_ptr;\newline	*object_ptr = new_contactsmember;\newline\newline	return new_contactsmember;\newline}\newline","adds a contact to an object \newline","5068911","html2.c","static GList *pointer_arr2glist(gchar **arr) {\newline	gchar **tmp;\newline	GList *retlist = NULL;\newline\newline	if (!arr) {\newline		return NULL;\newline	}\newline	tmp = arr;\newline	while (*tmp) {\newline		retlist = g_list_append(retlist, *tmp);\newline		tmp++;\newline	}\newline	return retlist;\newline}\newline","the list should be freed, the contents of the list should NOT \newline","5097521","io.c","static long read_stream( FILE * const fp, const int addr )\newline  {\newline  line_t * lp = search_line_node( addr );\newline  undo_t * up = 0;\newline  long total_size = 0;\newline  const bool o_isbinary = isbinary();\newline  const bool appended = ( addr == last_addr() );\newline  bool newline_added_now = false;\newline\newline  set_current_addr( addr );\newline  while( true )\newline    {\newline    int size = 0;\newline    const char * const s = read_stream_line( fp, &ampsize, &ampnewline_added_now );\newline    if( !s ) return -1;\newline    if( size &gt 0 ) total_size += size;\newline    else break;\newline    disable_interrupts();\newline    if( !put_sbuf_line( s, size + newline_added_now, current_addr() ) )\newline      { enable_interrupts(); return -1; }\newline    lp = lp-&gtq_forw;\newline    if( up ) up-&gttail = lp;\newline    else\newline      {\newline      up = push_undo_atom( UADD, current_addr(), current_addr() );\newline      if( !up ) { enable_interrupts(); return -1; }\newline      }\newline    enable_interrupts();\newline    }\newline  if( addr &amp&amp appended &amp&amp total_size &amp&amp o_isbinary &amp&amp newline_added() )\newline    fputs( &quotNewline inserted\\n&quot, stderr );\newline  else if( newline_added_now &amp&amp ( !appended || !isbinary() ) )\newline    fputs( &quotNewline appended\\n&quot, stderr );\newline  if( isbinary() &amp&amp !o_isbinary &amp&amp newline_added_now &amp&amp !appended )\newline    ++total_size;\newline  if( !total_size ) newline_added_now = true;\newline  if( appended &amp&amp newline_added_now ) set_newline_added();\newline  return total_size;\newline  }\newline","read a stream into the editor buffer; return total size of data read \newline","4514145","ota_prov.c","static void ota_pack_udh(Msg **msg, Octstr *doc_type)\newline{\newline    (*msg)-&gtsms.udhdata = octstr_create(&quot&quot);\newline    if (octstr_case_compare(doc_type, octstr_imm(&quotoma-settings&quot)) == 0) \newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot0605040B840B84&quot);    \newline    else if (octstr_case_compare(doc_type, octstr_imm(&quotsyncsettings&quot)) == 0) {\newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot060504C34CC002&quot);\newline    } else \newline        octstr_append_from_hex((*msg)-&gtsms.udhdata, &quot060504C34FC002&quot);    \newline }\newline","\newline Append the User Data Header (UDH) including the length (UDHL). Only ports \newline UDH here - SAR UDH is added when (or if) we split the message. This is our\newline specific WDP layer.\newline \newline","6073938","ucftp.c","static int ucftp_open_check(struct ucftpnode *nod, int flags)\newline{\newline    if(nod == NULL) {\newline        if(!(flags &amp AVO_CREAT))\newline            return -ENOENT;\newline        return 0;\newline    }\newline\newline    if((flags &amp AVO_EXCL) != 0)\newline        return -EEXIST;\newline\newline    return ucftp_open_check_type(nod-&gtst.mode, flags);\newline}\newline","called by ucftp_open \newline","6583589","lptree.c","static void fillseq (TTree *tree, int tag, int n, const char *s) {\newline  int i;\newline  for (i = 0; i &lt n - 1; i++) {  /* initial n-1 copies of Seq tag; Seq ... */\newline    tree-&gttag = TSeq; tree-&gtu.ps = 2;\newline    sib1(tree)-&gttag = tag;\newline    sib1(tree)-&gtu.n = s ? (byte)s[i] : 0;\newline    tree = sib2(tree);\newline  }\newline  tree-&gttag = tag;  /* last one does not need TSeq */\newline  tree-&gtu.n = s ? (byte)s[i] : 0;\newline}\newline","\newline Build a sequence of &#039n&#039 nodes, each with tag &#039tag&#039 and &#039u.n&#039 got\newline from the array &#039s&#039 (or 0 if array is NULL). (TSeq is binary, so it\newline must build a sequence of sequence of sequence...)\newline \newline","522578","test_eh_tasks.cpp","void TestMovableException () {\newline    REMARK( &quotTestMovableException\\n&quot );\newline    ResetGlobals();\newline    bool bUnsupported = false;\newline    tbb::task_group_context ctx;\newline    tbb::empty_task *r = new( tbb::task::allocate_root() ) tbb::empty_task;\newline    ASSERT (!g_CurStat.Existing() &amp&amp !g_CurStat.Existed() &amp&amp !g_CurStat.Executed(), \newline            &quotsomething wrong with the task accounting&quot);\newline    r-&gtset_ref_count(NUM_CHILD_TASKS + 1);\newline    for ( int i = 0; i &lt NUM_CHILD_TASKS; ++i )\newline        r-&gtspawn( *new( r-&gtallocate_child() ) LeafTaskWithMovableExceptions );\newline    TRY()\newline        r-&gtwait_for_all();\newline    } catch ( ... ) {\newline        ASSERT (!ctx.is_group_execution_cancelled(), &quot&quot);\newline        CheckException();\newline        try {\newline            throw;\newline        } catch ( tbb::tbb_exception&amp e ) {\newline            CheckException(e);\newline            g_ExceptionCaught = l_ExceptionCaughtAtCurrentLevel = true;\newline        }\newline        catch ( ... ) {\newline            g_ExceptionCaught = true;\newline            g_UnknownException = unknownException = true;\newline        }\newline        try {\newline            ctx.register_pending_exception();\newline        } catch ( ... ) {\newline            bUnsupported = true;\newline            REPORT( &quotWarning: register_pending_exception() failed. This is expected in case of linking with static msvcrt\\n&quot );\newline        }\newline        ASSERT (ctx.is_group_execution_cancelled() || bUnsupported, &quotAfter exception registration the context must be in the cancelled state&quot);\newline    }\newline","Allocates a root task that spawns a bunch of children, one or several of which throw \newlinea movable exception in a worker or master thread (depending on the global settings).\newlineThe test also checks the correctness of multiple rethrowing of the pending exception. \newline","2643459","object.c","void gts_finalize (void)\newline{\newline  if (class_table) {\newline    g_hash_table_foreach (class_table, (GHFunc) free_class, NULL);\newline    g_hash_table_destroy (class_table);\newline    class_table = NULL;\newline  }\newline}\newline","\newline gts_finalize:\newline \newline Free all the memory allocated by the object system of GTS. No other\newline GTS function can be called after this function has been called.\newline \newline","773080","dmeventd.c","static struct dso_data *_lookup_dso(struct message_data *data)\newline{\newline	struct dso_data *dso_data, *ret = NULL;\newline\newline	dm_list_iterate_items(dso_data, &amp_dso_registry)\newline		if (!strcmp(data-&gtdso_name, dso_data-&gtdso_name)) {\newline			ret = dso_data;\newline			break;\newline		}\newline\newline	return ret;\newline}\newline","Find DSO data. \newline","1255171","ocfs2_controld.h","static inline void sleep_ms(unsigned int ms)\newline{\newline	struct timespec ts = {\newline		.tv_sec = ms / 1000,\newline		.tv_nsec = (ms % 1000) * 1000,\newline	};\newline\newline	nanosleep(&ampts, NULL);\newline}\newline","\newline We need to do some retries in more than one file.\newline Here&#039s some code that prints an error as we take a long time to do it.\newline There is a power-of-two backoff on printing the error.\newline \newline","5107732","crc.c","unsigned short crc_macb(register const unsigned char *ptr, register int count,\newline			register unsigned short crc)\newline{\newline  while (count--)\newline    {\newline      crc ^= *ptr++ &lt&lt 8;\newline      crc  = (crc &lt&lt 8) ^ magic[crc &gt&gt 8];\newline    }\newline\newline  return crc;\newline}\newline","\newline NAME: crc-&gtmacb()\newline DESCRIPTION: compute MacBinary II-style CRC value for a block of data\newline \newline","2009337","error.c","int i_failed(int code, char const *msg) {\newline  if (msg)\newline    i_push_error(code, msg);\newline  if (failed_cb)\newline    failed_cb(error_stack + error_sp);\newline  if (failures_fatal) {\newline    int sp;\newline    size_t total; /* total length of error messages */\newline    char *full; /* full message for logging */\newline    if (argv0)\newline      fprintf(stderr, &quot%s: &quot, argv0);\newline    fputs(&quoterror:\\n&quot, stderr);\newline    sp = error_sp;\newline    while (error_stack[sp].msg) {\newline      fprintf(stderr, &quot %s\\n&quot, error_stack[sp].msg);\newline      ++sp;\newline    }\newline    /* we want to log the error too, build an error message to hand to\newline       i_fatal() */\newline    total = 1; /* remember the NUL */\newline    for (sp = error_sp; error_stack[sp].msg; ++sp) {\newline      size_t new_total += strlen(error_stack[sp].msg) + 2;\newline      if (new_total &lt total) {\newline	/* overflow, somehow */\newline	break;\newline      }\newline    }\newline    full = mymalloc(total);\newline    if (!full) {\newline      /* just quit, at least it&#039s on stderr */\newline      exit(EXIT_FAILURE);\newline    }\newline    *full = 0;\newline    for (sp = error_sp; error_stack[sp].msg; ++sp) {\newline      strcat(full, error_stack[sp].msg);\newline      strcat(full, &quot: &quot);\newline    }\newline    /* lose the extra &quot: &quot */\newline    full[strlen(full)-2] = &#039\\0&#039;\newline    i_fatal(EXIT_FAILURE, &quot%s&quot, full);\newline  }\newline\newline  return 0;\newline}\newline","\newline=item i_failed(char const msg)\newlineCalled by Imager code to indicate that a top-level has failed.\newlinemsg can be NULL, in which case no error is pushed.\newlineCalls the current failed callback, if any.\newlineAborts the program with an error, if failures have been set to be fatal.\newlineReturns zero if it does not abort.\newline=cut\newline \newline","2164709","server.c","int try_server(int index, int conn)\newline{\newline	int upfd;\newline	int client = conns[conn].client;\newline	int n = 0, err;\newline	int optval = 1;\newline	struct sockaddr_storage *addr = &ampservers[index].addr;\newline	/* The idea is that a client should be able to connect again to the same server\newline	   even if the server is close to its configured connection limit */\newline	int sticky = ((client != -1) &amp&amp (index == clients[client].server));\newline\newline	if (index == NO_SERVER) {\newline		DEBUG(2, &quotWon&#039t try to connect to NO_SERVER&quot);\newline		return 0;	/* out of bounds */\newline	}\newline	DEBUG(2, &quotTrying server %d for connection %d at time %d&quot, index, conn, now);\newline	if (pen_getport(addr) == 0) {\newline		DEBUG(1, &quotNo port for you!&quot);\newline		return 0;\newline	}\newline	if (now-servers[index].status &lt blacklist_time) {\newline		DEBUG(1, &quotServer %d is blacklisted&quot, index);\newline		return 0;\newline	}\newline	if (servers[index].maxc != 0 &amp&amp\newline	    (servers[index].c &gt= servers[index].maxc) &amp&amp\newline	    (sticky == 0 || servers[index].c &gt= servers[index].hard)) {\newline		DEBUG(1, &quotServer %d is overloaded: sticky=%d, maxc=%d, hard=%d&quot, \\\newline				index, sticky, servers[index].maxc, servers[index].hard);\newline		return 0;\newline	}\newline	if ((client != -1) &amp&amp !match_acl(servers[index].acl, &amp(clients[client].addr))) {\newline		DEBUG(1, &quottry_server: denied by acl&quot);\newline		return 0;\newline	}\newline	upfd = socket_nb(addr-&gtss_family, udp ? SOCK_DGRAM : SOCK_STREAM, 0);\newline\newline	if (keepalive) {\newline		setsockopt(upfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&ampoptval, sizeof optval);\newline	}\newline\newline	if (debuglevel &gt 1) {\newline		debug(&quotConnecting to %s&quot, pen_ntoa(addr));\newline		pen_dumpaddr(addr);\newline	}\newline	conns[conn].t = now;\newline\newline	if (source) {\newline		/* specify local address for upstream connection */\newline		int n = bind(upfd, (struct sockaddr *)source, pen_ss_size(source));\newline		if (n == -1) {\newline			debug(&quotbind: %s&quot, strerror(errno));\newline		}\newline	} else if (transparent) {\newline		/* use originating client&#039s address for upstream connection */\newline		spoof_bind(index, conn, upfd);\newline	}\newline\newline	n = connect(upfd, (struct sockaddr *)addr, pen_ss_size(addr));\newline	err = socket_errno;\newline	DEBUG(2, &quotconnect (upfd = %d) returns %d, errno = %d, socket_errno = %d&quot,\newline		upfd, n, errno, err);\newline	/* A new complication is that we don&#039t know yet if the connect will succeed. */\newline	if (n == 0) {		/* connection completed */\newline		conns[conn].state = CS_CONNECTED;\newline		if (conns[conn].downfd == -1) {\newline			/* idler */\newline			conns[conn].state |= CS_CLOSED_DOWN;\newline		}\newline		event_add(upfd, EVENT_READ);\newline		event_add(conns[conn].downfd, EVENT_READ);\newline		servers[index].c++;\newline		if (servers[index].status) {\newline			servers[index].status = 0;\newline			DEBUG(1, &quotServer %d ok&quot, index);\newline		}\newline		DEBUG(2, &quotSuccessful connect to server %d\\n&quot \\\newline			&quotconns[%d].client = %d\\n&quot \\\newline			&quotconns[%d].server = %d&quot, \\\newline			index, conn, conns[conn].client, conn, conns[conn].server);\newline	} else if (err == CONNECT_IN_PROGRESS) {	/* may potentially succeed */\newline		conns[conn].state = CS_IN_PROGRESS;\newline		pending_list = dlist_insert(pending_list, conn);\newline		conns[conn].pend = pending_list;\newline		pending_queue++;\newline		event_add(upfd, EVENT_WRITE);\newline		DEBUG(2, &quotPending connect to server %d\\n&quot \\\newline			&quotconns[%d].client = %d\\n&quot \\\newline			&quotconns[%d].server = %d&quot, \\\newline			index, conn, conns[conn].client, conn, conns[conn].server);\newline	} else {		/* failed definitely */\newline		if (servers[index].status == 0) {\newline			debug(&quotServer %d failed, retry in %d sec: %d&quot,\newline				index, blacklist_time, socket_errno);\newline		}\newline		debug(&quotblacklisting server %d because connect error %d&quot, index, err);\newline		blacklist_server(index);\newline		close(upfd);\newline		return 0;\newline	}\newline	conns[conn].server = index;\newline	DEBUG(2, &quotSetting server %d for client %d&quot, index, client);\newline	clients[client].server = index;\newline	current = index;\newline	conns[conn].upfd = upfd;\newline	fd2conn_set(upfd, conn);\newline	return 1;\newline}\newline","return 1 for (potential) success, 0 for failure \newline","6659108","cdw_file_manager.c","bool cdw_file_manager_file_properties_is_appendable(cdw_file_t const * file)\newline{\newline	if (file-&gtinvalid) {\newline		cdw_vdm (&quotINFO: invalid file is not appendable\\n&quot);\newline		return false;\newline\newline	} else if (file-&gtis_ref_to_parent_dir) {\newline		/* Never allow selecting parent dir. */\newline		cdw_vdm (&quotINFO: parent dir is not appendable\\n&quot);\newline		return false;\newline\newline	} else if (!(file-&gttype &amp CDW_FS_FILE) &amp&amp !(file-&gttype &amp CDW_FS_DIR)) {\newline		/* Only directories and regular files (or links to them - notice the &#039&amp&#039 operator) allowed. */\newline		cdw_vdm (&quotINFO: file of strange type \\&quot0x%x\\&quot is not appendable\\n&quot, file-&gttype);\newline		return false;\newline\newline	} else {\newline		return true;\newline	}\newline}\newline","\newline\\brief Decide if given file can be appended to list of selected files based on file&#039s properties\newline\\date Function&#039s top-level comment reviewed on 2016-02-20\newline\\date Function&#039s body reviewed on 2016-02-20\newlineThe function only check properties of the file itself. The file may\newlinebe OK, but caller still may want to not to append the file because\newlineit already exists on list of selected files. It is up to caller to\newlinedo any additional checks.\newline\\param file - file to be checked\newline\\return true if file can be appended to list of selected files\newline\\return false otherwise\newline \newline","161172","main.c","static void parse_dimensions(char *s, char **endptr, dim_t *dxp, dim_t *dyp) {\newline  char *p, *q;\newline  dim_t dx, dy;\newline\newline  dx = parse_dimension(s, &ampp);\newline  if (p==s) {\newline    goto fail;\newline  }\newline  if (*p != &#039x&#039) {\newline    goto fail;\newline  }\newline  p++;\newline  dy = parse_dimension(p, &ampq);\newline  if (q==p) {\newline    goto fail;\newline  }\newline  if (dx.d &amp&amp !dy.d) {\newline    dy.d = dx.d;\newline  } else if (!dx.d &amp&amp dy.d) {\newline    dx.d = dy.d;\newline  }\newline  *dxp = dx;\newline  *dyp = dy;\newline  if (endptr != NULL) {\newline    *endptr = q;\newline  }\newline  return;\newline\newline fail:\newline  dx.x = dx.d = dy.x = dy.d = 0;\newline  *dxp = dx;\newline  *dyp = dy;\newline  if (endptr != NULL) {\newline    *endptr = s;\newline  }\newline  return;\newline}\newline","parse a pair of dimensions, such as &quot8.5x11in&quot, &quot30mmx4cm&quot \newline","","","on","","","","","on","","","on","on","","","on","","","on","","on","","","","","","","","","","","","","","","","","","","","","","","cut on a passive mode specific BMC actions","Append the User Data Header","{}","Build a sequence of 'n' nodes,","Allocates a root task that spawns a bunch of children,","Free all the memory allocated by the object system of GTS.","Find DSO data.","{}","compute MacBinary II-style CRC value for a block of data","to indicate that a top-level has failed.","{}","{}","Decide if given file can be appended to list of selected files","parse a pair of dimensions,","{}","Checks the patterns in the modfile for UST","unlink an object from its parent and siblings.","{}","adds a contact to an object","{}","return total size of data read"
"3CVBMEMMXBGWI1A275ILB60P3JTH7B","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3IJXV6UZ1XJ8JZ2UC33D5IOTKW7IRD","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:25:01 PDT 2019","Wed Apr 17 14:30:50 PDT 2019","Fri Apr 19 14:30:50 PDT 2019","2019-04-19 21:31:21 UTC","","","349","100% (27/27)","100% (27/27)","100% (27/27)","5045593","doc_compile.cpp","string DocCompiler::generateDocConstantTbl (Tree /*tbl*/, Tree size, Tree isig)\newline{	\newline	string 	vname, ctype;\newline    string 	init = CS(isig,0);\newline\newline    int     n;\newline    if (!isSigInt(size, &ampn)) {\newline        cerr &lt&lt &quoterror in DocCompiler::generateDocConstantTbl() : &quot\newline             &lt&lt *size\newline             &lt&lt &quot is not an integer expression and can&#039t be used as a table size&#039 &quot\newline             &lt&lt endl;\newline    }\newline\newline    // allocate a name v_i for the table\newline    getTypedNames(getCertifiedSigType(isig), &quotv&quot, ctype, vname);\newline	\newline    // add a comment on tables in the notice\newline		gDocNoticeFlagMap[&quottablesigs&quot] = true;\newline	\newline    // add equation v[t] = isig(t)\newline        fLateq-&gtaddRDTblSigFormula(subst(&quot$0[t] = $1 \\\\condition{when $$t \\\\in [0,$2]$$} &quot, vname, init, T(n-1)));\newline	\newline    // note that the name of the table can never be used outside an sigDocTableAccess\newline    return vname;\newline}\newline","\newline Generate the equation of a constant table (its content is time constant).\newline Returns the name of the table\newline \newline","4475598","http_emergency.c","int get_esgwri_ert_in_contact(char *contact_esgwri, ESCT *call_cell){\newline\newline	char *contact_routing_aux;\newline	str pattern_contact_routing, replacement_contact_routing;\newline	str pt_contact_routing;\newline	int len_contact_routing;\newline	char *contact_routing;\newline	char *pt_aux;\newline	char *p_aux;\newline	char *srid_aux, *resn_aux, *npa_aux;\newline	char *pt_a, *pt_b;\newline	str pattern_contact_ert, replacement_contact_ert;\newline\newline	char *p = strstr(contact_esgwri, &quotP-Asserted-Identity&quot);\newline	len_contact_routing = p - contact_esgwri -1;\newline\newline	contact_routing = pkg_malloc(sizeof (char)*len_contact_routing);\newline	if (contact_routing == NULL) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(contact_routing, 0, len_contact_routing);\newline	p_aux = contact_esgwri;\newline	p_aux++;\newline	memcpy(contact_routing, p_aux, len_contact_routing-1 );\newline	pkg_free(contact_esgwri);\newline\newline	contact_routing_aux = pkg_malloc(sizeof (char)*len_contact_routing);\newline	if (contact_routing_aux == NULL) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(contact_routing_aux, 0,len_contact_routing);\newline	pt_contact_routing.s = contact_routing_aux;\newline	pt_contact_routing.len = len_contact_routing - 1;\newline\newline	pattern_contact_routing.s = &quot^(sips?):[+]*([-0-9]+)@&quot;\newline	pattern_contact_routing.len = strlen(pattern_contact_routing.s);\newline	replacement_contact_routing.s = &quot\\\\2&quot;\newline	replacement_contact_routing.len = strlen(replacement_contact_routing.s);\newline\newline	if (reg_replace(pattern_contact_routing.s, replacement_contact_routing.s, contact_routing, &amppt_contact_routing) == 1) {\newline		LM_DBG (&quotTRANS REPLY ESGWRI %s \\n&quot,contact_routing);\newline		call_cell-&gtesgwri = contact_routing;\newline		call_cell-&gtdisposition = &quotprocesses&quot;\newline\newline		pkg_free(contact_routing_aux);\newline\newline	}else{\newline		pattern_contact_ert.s = &quot^(sips?):([A-Z0-9.]*)@&quot;\newline		pattern_contact_ert.len = strlen(pattern_contact_ert.s);\newline		replacement_contact_ert.s = &quot\\\\2&quot;\newline		replacement_contact_ert.len = strlen(replacement_contact_ert.s);\newline\newline		if (reg_replace(pattern_contact_ert.s, replacement_contact_ert.s, contact_routing, &amppt_contact_routing) != 1) {\newline			LM_ERR(&quot****** PATTERN ERT NAO OK \\n&quot);\newline			pkg_free(contact_routing_aux);\newline			pkg_free(contact_routing);\newline			return 0;\newline		}\newline\newline		LM_DBG (&quotCONTEUDO TRANS REPLY ERT %.*s \\n&quot, pt_contact_routing.len, pt_contact_routing.s);\newline		pt_aux = pt_contact_routing.s;\newline		pt_a = strchr(pt_aux,&#039.&#039);\newline		int len_srid = pt_a - pt_contact_routing.s;\newline		srid_aux = pkg_malloc(sizeof (char)*len_srid + 1);\newline		if (srid_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		memcpy(srid_aux, pt_aux, len_srid);\newline		srid_aux[len_srid] = 0;\newline		pt_aux += len_srid + 1;\newline\newline		pt_b = strchr(pt_aux,&#039.&#039);\newline		int len_resn = pt_b - pt_aux ;\newline		resn_aux = pkg_malloc(sizeof (char)*len_resn + 1);\newline		if (resn_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		memcpy(resn_aux, pt_aux, len_resn);\newline		resn_aux[len_resn] = 0;\newline		pt_aux += len_resn + 1;\newline\newline		int len_npa = pt_contact_routing.len - len_srid - len_resn;\newline		npa_aux = pkg_malloc(sizeof (char)*len_npa + 1);\newline		if (npa_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		npa_aux[len_npa] = 0;\newline		memcpy(npa_aux, pt_aux, len_npa);\newline\newline		LM_DBG (&quotCONTEUDO TRANS REPLY SRID %s \\n&quot,srid_aux);\newline		LM_DBG (&quotCONTEUDO TRANS REPLY RESN %s \\n&quot,resn_aux);\newline		LM_DBG (&quotCONTEUDO TRANS REPLY NPA %s \\n&quot,npa_aux);\newline		int npa = atoi(npa_aux);\newline		int resn = atoi(resn_aux);\newline		int srid_len = strlen(srid_aux);\newline\newline		call_cell-&gtert_npa = npa;\newline		call_cell-&gtert_resn = resn;\newline		call_cell-&gtert_srid = pkg_malloc(sizeof (char)* srid_len + 1);\newline		if (call_cell-&gtert_srid == NULL) {\newline			LM_ERR(&quot--------------------------------------------------no more shm memory\\n&quot);\newline			return -1;\newline		}\newline\newline		strcpy(call_cell-&gtert_srid, srid_aux);\newline		call_cell-&gtert_srid[srid_len] = 0;\newline\newline		call_cell-&gtdisposition = &quotprocesses&quot;\newline\newline		pkg_free(contact_routing_aux);\newline		pkg_free(contact_routing);\newline		pkg_free(srid_aux);\newline		pkg_free(resn_aux);\newline		pkg_free(npa_aux);\newline	}\newline	return 1;\newline}\newline","get esgwri or ert information from contact header and save this in call cell\newline \newline","5282736","lj_parse.c","static void bcemit_nil(FuncState *fs, BCReg from, BCReg n)\newline{\newline  if (fs-&gtpc &gt fs-&gtlasttarget) {  /* No jumps to current position? */\newline    BCIns *ip = &ampfs-&gtbcbase[fs-&gtpc-1].ins;\newline    BCReg pto, pfrom = bc_a(*ip);\newline    switch (bc_op(*ip)) {  /* Try to merge with the previous instruction. */\newline    case BC_KPRI:\newline      if (bc_d(*ip) != ~LJ_TNIL) break;\newline      if (from == pfrom) {\newline	if (n == 1) return;\newline      } else if (from == pfrom+1) {\newline	from = pfrom;\newline	n++;\newline      } else {\newline	break;\newline      }\newline      *ip = BCINS_AD(BC_KNIL, from, from+n-1);  /* Replace KPRI. */\newline      return;\newline    case BC_KNIL:\newline      pto = bc_d(*ip);\newline      if (pfrom &lt= from &amp&amp from &lt= pto+1) {  /* Can we connect both ranges? */\newline	if (from+n-1 &gt pto)\newline	  setbc_d(ip, from+n-1);  /* Patch previous instruction range. */\newline	return;\newline      }\newline      break;\newline    default:\newline      break;\newline    }\newline  }\newline  /* Emit new instruction or replace old instruction. */\newline  bcemit_INS(fs, n == 1 ? BCINS_AD(BC_KPRI, from, VKNIL) :\newline			  BCINS_AD(BC_KNIL, from, from+n-1));\newline}\newline","Emit bytecode to set a range of registers to nil. \newline","2531622","pins.c","char *build_wps_pin()\newline{\newline        char *key = NULL, *pin = NULL;\newline        int pin_len = PIN_SIZE + 1;\newline\newline        pin = malloc(pin_len);\newline        key = malloc(pin_len);\newline        if(pin &amp&amp key)\newline        {\newline                memset(key, 0, pin_len);\newline                memset(pin, 0, pin_len);\newline\newline                /* Generate a 7-digit pin from the given key index values */\newline                snprintf(key, pin_len, &quot%s%s&quot, get_p1(get_p1_index()), get_p2(get_p2_index()));\newline\newline                /* Generate and append the pin checksum digit */\newline                snprintf(pin, pin_len, &quot%s%d&quot, key, wps_pin_checksum(atoi(key)));\newline\newline                free(key);\newline        }\newline\newline        return pin;\newline}\newline","Builds a WPS PIN from the key tables \newline","1309526","wgdbmodule.c","static wg_int encode_pyobject_xmlliteral(wg_database *db, PyObject *data,\newline  char *ext_str, int param) {\newline  char *s;\newline#ifndef PYTHON3\newline  s = PyString_AsString(data);\newline#elif defined(HAVE_LOCALEENC)\newline  s = PyBytes_AsString(PyUnicode_EncodeLocale(data, ENCODEERR));\newline#else\newline  s = PyBytes_AsString(PyUnicode_AsEncodedString(data, NULL, ENCODEERR));\newline#endif\newline  /* wg_encode_str is not guaranteed to check for NULL pointer */\newline  if(s) {\newline    if(!param) {\newline      return wg_encode_xmlliteral(db-&gtdb, s, ext_str);\newline    } else {\newline      return wg_encode_query_param_xmlliteral(db-&gtdb, s, ext_str);\newline    }\newline  } else {\newline    return WG_ILLEGAL;\newline  }\newline}\newline","Encode an atomic value of type WG_XMLLITERALTYPE\newline returns WG_ILLEGAL on failure\newline if param is 1, the storage will be allocated in local memory (intended\newline for encoding query parameters without write locking)\newline \newline","4318803","opts_p_z.c","int Xorriso_option_pvd_info(struct XorrisO *xorriso, int flag)\newline{\newline  return(Xorriso_pvd_info(xorriso, 0));\newline}\newline","Option -pvd_info \newline","2772252","c_microstrip.c","gfloat filling_factor_odd(gfloat u, gfloat g, gfloat e_r)\newline{\newline  gfloat b_o, c_o, d_o, q_inf;\newline\newline  b_o = 0.747 * e_r / (0.15 + e_r);\newline  c_o = b_o - (b_o - 0.207) * exp(-0.414 * u);\newline  d_o = 0.593 + 0.694 * exp(-0.562 * u);\newline\newline  /* filling factor, with width corrected for thickness */\newline  q_inf = exp(-c_o * pow(g, d_o));\newline\newline  return q_inf;\newline}\newline","\newline filling_factor_odd() - compute the filling factor for the coupled microstrips odd-mode without cover and zero conductor thickness \newline @u: normalized width\newline @g: normalized strips spacing\newline @e_r: relative dielectric constant\newline \newline","3964276","vmfs_inode.c","static int vmfs_inode_write(const vmfs_inode_t *inode,u_char *buf)\newline{\newline   vmfs_metadata_hdr_write(&ampinode-&gtmdh,buf);\newline   write_le32(buf,VMFS_INODE_OFS_ID,inode-&gtid);\newline   write_le32(buf,VMFS_INODE_OFS_ID2,inode-&gtid2);\newline   write_le32(buf,VMFS_INODE_OFS_NLINK,inode-&gtnlink);\newline   write_le32(buf,VMFS_INODE_OFS_TYPE,inode-&gttype);\newline   write_le32(buf,VMFS_INODE_OFS_FLAGS,inode-&gtflags);\newline   write_le64(buf,VMFS_INODE_OFS_SIZE,inode-&gtsize);\newline   write_le64(buf,VMFS_INODE_OFS_BLK_SIZE,inode-&gtblk_size);\newline   write_le64(buf,VMFS_INODE_OFS_BLK_COUNT,inode-&gtblk_count);\newline   write_le32(buf,VMFS_INODE_OFS_MTIME,inode-&gtmtime);\newline   write_le32(buf,VMFS_INODE_OFS_CTIME,inode-&gtctime);\newline   write_le32(buf,VMFS_INODE_OFS_ATIME,inode-&gtatime);\newline   write_le32(buf,VMFS_INODE_OFS_UID,inode-&gtuid);\newline   write_le32(buf,VMFS_INODE_OFS_GID,inode-&gtgid);\newline   write_le32(buf,VMFS_INODE_OFS_MODE,inode-&gtmode);\newline   write_le32(buf,VMFS_INODE_OFS_ZLA,inode-&gtzla);\newline   write_le32(buf,VMFS_INODE_OFS_TBZ,inode-&gttbz);\newline   write_le32(buf,VMFS_INODE_OFS_COW,inode-&gtcow);\newline   return(0);\newline}\newline","Write an inode \newline","811393","ewk_contextmenu.cpp","void ewk_context_menu_show(Ewk_Context_Menu* menu)\newline{\newline    EINA_SAFETY_ON_NULL_RETURN(menu);\newline\newline    evas_object_smart_callback_call(menu-&gtview, &quotcontextmenu,show&quot, menu);\newline}\newline","\newline @internal\newline \newline Emits a signal &quotcontextmenu,show&quot\newline \newline @param menu the context menu object\newline \newline","383603","qbatteryinfo.cpp","QBatteryInfo::QBatteryInfo(QObject *parent)\newline    : QObject(parent)\newline#if !defined(QT_SIMULATOR)\newline    , d_ptr(new QBatteryInfoPrivate(this))\newline#else\newline    , d_ptr(new QBatteryInfoSimulator(this))\newline#endif // QT_SIMULATOR\newline\newline{\newline}\newline","!\newlineConstructs a \\l QBatteryInfo object with the given \\a parent. The \\l batteryIndex()\newlinewill default to \\c 0.\newline \newline","3659541","weaver.cpp","Weaver::~Weaver()\newline{\newline    Q_ASSERT_X(state()-&gtstateId() == Destructed, Q_FUNC_INFO, &quotshutDown() method was not called before Weaver destructor!&quot);\newline}\newline","@brief Destructs a Weaver object. \newline","391953","xz_dec_lzma2.c","static __always_inline uint32_t rc_bittree(\newline		struct rc_dec *rc, uint16_t *probs, uint32_t limit)\newline{\newline	uint32_t symbol = 1;\newline\newline	do {\newline		if (rc_bit(rc, &ampprobs[symbol]))\newline			symbol = (symbol &lt&lt 1) + 1;\newline		else\newline			symbol &lt&lt= 1;\newline	} while (symbol &lt limit);\newline\newline	return symbol;\newline}\newline","Decode a bittree starting from the most significant bit. \newline","384795","ib_cm.c","void ib_destroy_conn ( struct ib_device *ibdev,\newline		       struct ib_queue_pair *qp __unused,\newline		       struct ib_connection *conn ) {\newline\newline	list_del ( &ampconn-&gtlist );\newline	if ( conn-&gtmadx )\newline		ib_destroy_madx ( ibdev, ibdev-&gtgsi, conn-&gtmadx );\newline	if ( conn-&gtpath )\newline		ib_destroy_path ( ibdev, conn-&gtpath );\newline	free ( conn );\newline}\newline","\newline Destroy connection to remote QP\newline \newline @v ibdev Infiniband device\newline @v qp Queue pair\newline @v conn Connection\newline \newline","1271412","lsqlite3.c","static int db_urows(lua_State *L) {\newline  return db_do_rows(L, db_next_row);\newline}\newline","unpacked version of db:rows \newline","1305695","ceph.c","static int cconn_main_loop(uint32_t request_type) {\newline  int ret, some_unreachable = 0;\newline  struct timeval end_tv;\newline  struct cconn io_array[g_num_daemons];\newline\newline  DEBUG(&quotceph plugin: entering cconn_main_loop(request_type = %&quot PRIu32 &quot)&quot,\newline        request_type);\newline\newline  if (g_num_daemons &lt 1) {\newline    ERROR(&quotceph plugin: No daemons configured. See the \\&quotDaemon\\&quot config &quot\newline          &quotoption.&quot);\newline    return ENOENT;\newline  }\newline\newline  /* create cconn array */\newline  for (size_t i = 0; i &lt g_num_daemons; i++) {\newline    io_array[i] = (struct cconn){\newline        .d = g_daemons[i],\newline        .request_type = request_type,\newline        .state = CSTATE_UNCONNECTED,\newline    };\newline  }\newline\newline  /** Calculate the time at which we should give up */\newline  gettimeofday(&ampend_tv, NULL);\newline  end_tv.tv_sec += CEPH_TIMEOUT_INTERVAL;\newline\newline  while (1) {\newline    int nfds, diff;\newline    struct timeval tv;\newline    struct cconn *polled_io_array[g_num_daemons];\newline    struct pollfd fds[g_num_daemons];\newline    memset(fds, 0, sizeof(fds));\newline    nfds = 0;\newline    for (size_t i = 0; i &lt g_num_daemons; ++i) {\newline      struct cconn *io = io_array + i;\newline      ret = cconn_prepare(io, fds + nfds);\newline      if (ret &lt 0) {\newline        WARNING(&quotceph plugin: cconn_prepare(name=%s,i=%zu,st=%d)=%d&quot,\newline                io-&gtd-&gtname, i, io-&gtstate, ret);\newline        cconn_close(io);\newline        io-&gtrequest_type = ASOK_REQ_NONE;\newline        some_unreachable = 1;\newline      } else if (ret == 1) {\newline        polled_io_array[nfds++] = io_array + i;\newline      }\newline    }\newline    if (nfds == 0) {\newline      /* finished */\newline      ret = 0;\newline      goto done;\newline    }\newline    gettimeofday(&amptv, NULL);\newline    diff = milli_diff(&ampend_tv, &amptv);\newline    if (diff &lt= 0) {\newline      /* Timed out */\newline      ret = -ETIMEDOUT;\newline      WARNING(&quotceph plugin: cconn_main_loop: timed out.&quot);\newline      goto done;\newline    }\newline    RETRY_ON_EINTR(ret, poll(fds, nfds, diff));\newline    if (ret &lt 0) {\newline      ERROR(&quotceph plugin: poll(2) error: %d&quot, ret);\newline      goto done;\newline    }\newline    for (int i = 0; i &lt nfds; ++i) {\newline      struct cconn *io = polled_io_array[i];\newline      int revents = fds[i].revents;\newline      if (revents == 0) {\newline        /* do nothing */\newline        continue;\newline      } else if (cconn_validate_revents(io, revents)) {\newline        WARNING(&quotceph plugin: cconn(name=%s,i=%d,st=%d): &quot\newline                &quotrevents validation error: &quot\newline                &quotrevents=0x%08x&quot,\newline                io-&gtd-&gtname, i, io-&gtstate, revents);\newline        cconn_close(io);\newline        io-&gtrequest_type = ASOK_REQ_NONE;\newline        some_unreachable = 1;\newline      } else {\newline        ret = cconn_handle_event(io);\newline        if (ret) {\newline          WARNING(&quotceph plugin: cconn_handle_event(name=%s,&quot\newline                  &quoti=%d,st=%d): error %d&quot,\newline                  io-&gtd-&gtname, i, io-&gtstate, ret);\newline          cconn_close(io);\newline          io-&gtrequest_type = ASOK_REQ_NONE;\newline          some_unreachable = 1;\newline        }\newline      }\newline    }\newline  }\newlinedone:\newline  for (size_t i = 0; i &lt g_num_daemons; ++i) {\newline    cconn_close(io_array + i);\newline  }\newline  if (some_unreachable) {\newline    DEBUG(&quotceph plugin: cconn_main_loop: some Ceph daemons were unreachable.&quot);\newline  } else {\newline    DEBUG(&quotceph plugin: cconn_main_loop: reached all Ceph daemons :)&quot);\newline  }\newline  return ret;\newline}\newline","This handles the actual network I/O to talk to the Ceph daemons.\newline \newline","5365831","resource.c","static IMAGE_SECTION_HEADER *get_resource_section( void *base, DWORD mapping_size )\newline{\newline    IMAGE_SECTION_HEADER *sec;\newline    IMAGE_NT_HEADERS *nt;\newline    DWORD i, num_sections = 0;\newline\newline    nt = get_nt_header( base, mapping_size );\newline    if (!nt)\newline        return NULL;\newline\newline    sec = get_section_header( base, mapping_size, &ampnum_sections );\newline    if (!sec)\newline        return NULL;\newline\newline    /* find the resources section */\newline    for (i=0; i&ltnum_sections; i++)\newline        if (!memcmp(sec[i].Name, &quot.rsrc&quot, 6))\newline            break;\newline\newline    if (i == num_sections)\newline        return NULL;\newline\newline    return &ampsec[i];\newline}\newline","\newline FIXME:\newline Assumes that the resources are in .rsrc\newline and .rsrc is the last section in the file.\newline Not sure whether updating resources will other cases on Windows.\newline If the resources lie in a section containing other data,\newline resizing that section could possibly cause trouble.\newline If the section with the resources isn&#039t last, the remaining\newline sections need to be moved down in the file, and the section header\newline would need to be adjusted.\newline If we needed to add a section, what would we name it?\newline If we needed to add a section and there wasn&#039t space in the file\newline header, how would that work?\newline Seems that at least some of these cases can&#039t be handled properly.\newline \newline","5898923","kmo_priv_functions-test.c","int main()\newline{\newline    cpl_test_init(&quot&ltusd-help@eso.org&gt&quot, CPL_MSG_WARNING);\newline\newline    test_kmo_create_lambda_vec();\newline    test_kmo_is_in_range();\newline    test_kmo_identify_slices();\newline    test_kmo_identify_ranges();\newline    test_kmo_identify_values();\newline    test_kmo_image_get_stdev_median();\newline    test_kmos_combine_pars_create();\newline    test_kmos_band_pars_create();\newline    /* test_kmos_combine_pars_load(); */\newline    test_kmos_band_pars_load();\newline    /* test_kmo_check_frameset_setup(); */\newline    /* test_kmo_check_frame_setup(); */\newline    /* test_kmo_priv_compare_frameset_setup(); */\newline\newline    return cpl_test_end(0);\newline}\newline","\newline@brief Test of helper functions needed in several recipes\newline \newline","2163373","index.c","static void index_thread_orderedsubj(struct index_state *state, \newline				     unsigned *msgno_list, int nmsg,\newline				     int usinguid)\newline{\newline    MsgData *msgdata, *freeme;\newline    static const struct sortcrit sortcrit[] =\newline				 {{ SORT_SUBJECT,  0, {{NULL, NULL}} },\newline				  { SORT_DATE,     0, {{NULL, NULL}} },\newline				  { SORT_SEQUENCE, 0, {{NULL, NULL}} }};\newline    unsigned psubj_hash = 0;\newline    char *psubj;\newline    Thread *head, *newnode, *cur, *parent, *last;\newline\newline    /* Create/load the msgdata array */\newline    freeme = msgdata = index_msgdata_load(state, msgno_list, nmsg, sortcrit);\newline\newline    /* Sort messages by subject and date */\newline    msgdata = lsort(msgdata,\newline		    (void * (*)(void*)) index_sort_getnext,\newline		    (void (*)(void*,void*)) index_sort_setnext,\newline		    (int (*)(void*,void*,void*)) index_sort_compare,\newline		    (void *)sortcrit);\newline\newline    /* create an array of Thread to use as nodes of thread tree\newline     *\newline     * we will be building threads under a dummy head,\newline     * so we need (nmsg + 1) nodes\newline     */\newline    head = (Thread *) xzmalloc((nmsg + 1) * sizeof(Thread));\newline\newline    newnode = head + 1;	/* set next newnode to the second\newline			   one in the array (skip the head) */\newline    parent = head;	/* parent is the head node */\newline    psubj = NULL;	/* no previous subject */\newline    cur = NULL;		/* no current thread */\newline    last = NULL;	/* no last child */\newline\newline    while (msgdata) {\newline	newnode-&gtmsgdata = msgdata;\newline\newline	/* if no previous subj, or\newline	   current subj = prev subj (subjs have same hash, and\newline	   the strings are equal), then add message to current thread */\newline	if (!psubj ||\newline	    (msgdata-&gtxsubj_hash == psubj_hash &amp&amp\newline	     !strcmp(msgdata-&gtxsubj, psubj))) {\newline	    /* if no children, create first child */\newline	    if (!parent-&gtchild) {\newline		last = parent-&gtchild = newnode;\newline		if (!cur)		/* first thread */\newline		    parent = cur = parent-&gtchild;\newline	    }\newline	    /* otherwise, add to siblings */\newline	    else {\newline		last-&gtnext = newnode;\newline		last = last-&gtnext;\newline	    }\newline	}\newline	/* otherwise, create a new thread */\newline	else {\newline	    cur-&gtnext = newnode;	/* create and start a new thread */\newline	    parent = cur = cur-&gtnext;	/* now work with the new thread */\newline	}\newline\newline	psubj_hash = msgdata-&gtxsubj_hash;\newline	psubj = msgdata-&gtxsubj;\newline	msgdata = msgdata-&gtnext;\newline	newnode++;\newline    }\newline\newline    /* Sort threads by date */\newline    index_thread_sort(head, sortcrit+1);\newline\newline    /* Output the threaded messages */ \newline    index_thread_print(state, head, usinguid);\newline\newline    /* free the thread array */\newline    free(head);\newline\newline    /* free the msgdata array */\newline    free(freeme);\newline}\newline","\newline Thread a list of messages using the ORDEREDSUBJECT algorithm.\newline \newline","5750880","gfal_srm.c","char *gfal_srm_construct_key(const char *url, const char *prefix, char *buff,\newline    const size_t s_buff)\newline{\newline    g_strlcpy(buff, prefix, s_buff);\newline    g_strlcat(buff, url, s_buff);\newline    char *p2 = buff + strlen(prefix) + strlen(GFAL_PREFIX_SRM) + 2;\newline    while (*p2 != &#039\\0&#039) { //remove the duplicate //\newline        if (*p2 == &#039/&#039 &amp&amp *(p2 + 1) == &#039/&#039) {\newline            memmove(p2, p2 + 1, strlen(p2 + 1) + 1);\newline        }\newline        else\newline            p2++;\newline    }\newline    return buff;\newline}\newline","\newline Construct a key for the cache system from a url and a prefix\newline \newline","5109154","getdata.c","static size_t _GD_DoMultiply(DIRFILE *restrict D, gd_entry_t *restrict E,\newline    off64_t first_samp, size_t num_samp, gd_type_t return_type,\newline    void *restrict data_out)\newline{\newline  void *tmpbuf = NULL;\newline  unsigned int spf1, spf2;\newline  size_t n_read, n_read2, num_samp2;\newline  off64_t first_samp2;\newline  gd_type_t type2;\newline\newline  dtrace(&quot%p, %p, %&quot PRId64 &quot, %&quot PRIuSIZE &quot, 0x%X, %p&quot, D, E,\newline      (int64_t)first_samp, num_samp, return_type, data_out);\newline\newline  /* find the samples per frame of the first field */\newline  spf1 = _GD_GetSPF(D, E-&gte-&gtentry[0]);\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* read the first field and record the number of samples returned */\newline  n_read = _GD_DoField(D, E-&gte-&gtentry[0], E-&gte-&gtrepr[0], first_samp, num_samp,\newline      return_type, data_out);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* Nothing to multiply */\newline  if (n_read == 0) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* find the samples per frame of the second field */\newline  spf2 = _GD_GetSPF(D, E-&gte-&gtentry[1]);\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* calculate the first sample and number of samples to read of the\newline   * second field */\newline  num_samp2 = (int)ceil((double)n_read * spf2 / spf1);\newline  first_samp2 = first_samp * spf2 / spf1;\newline\newline  /* find the native type of the second field */\newline  type2 = (_GD_NativeType(D, E-&gte-&gtentry[1], E-&gte-&gtrepr[1]) &amp GD_COMPLEX) ?\newline    GD_COMPLEX128 : GD_FLOAT64;\newline\newline  /* Allocate a temporary buffer for the second field */\newline  tmpbuf = _GD_Alloc(D, type2, num_samp2);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    free(tmpbuf);\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* read the second field */\newline  n_read2 = _GD_DoField(D, E-&gte-&gtentry[1], E-&gte-&gtrepr[1], first_samp2,\newline      num_samp2, type2, tmpbuf);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    free(tmpbuf);\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  if (n_read2 &gt 0 &amp&amp n_read2 * spf1 &lt n_read * spf2)\newline    n_read = n_read2 * spf1 / spf2;\newline\newline  if (type2 &amp GD_COMPLEX)\newline    _GD_CMultiplyData(D, data_out, spf1, tmpbuf, spf2, return_type, n_read);\newline  else\newline    _GD_MultiplyData(D, data_out, spf1, tmpbuf, spf2, return_type, n_read);\newline\newline  free(tmpbuf);\newline\newline  dreturn(&quot%&quot PRIuSIZE, n_read);\newline  return n_read;\newline}\newline","_GD_DoMultiply: Read from a multiply. Returns number of samples read.\newline \newline","2188896","cb88o.c","void CB_MATA(GtkWidget *widget,GdkEvent *event,gpointer data)\newline{\newlineextern FR_DOUBLE  xx,yy;\newlineextern int        ifmaus;\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON1_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_ZOOM;\newline  InvalidateRect88();\newline  }\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON2_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_PAN;\newline  InvalidateRect88();\newline  }\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON3_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_ROTATE;\newline  InvalidateRect88();\newline  }\newline\newlinereturn;\newline}\newline","\newline CB_MATA\newline \newline","","","","","","","","on","on","","","","","on","","","","on","","","on","on","","","","","","","","","","","","","","","","","","","","","Generate the equation of a constant table","Constructs a \l QBatteryInfo object with the given \a parent.","Destructs a Weaver object.","Decode a bittree starting from the most significant bit.","Destroy connection to remote QP","unpacked version of db:rows","handles the actual network I/O to talk to the Ceph daemons.","{}","{}","Thread a list of messages","Construct a key for the cache system","get esgwri or ert information from contact header","Read from a multiply.","{}","Emit bytecode to set a range of registers to nil.","Builds a WPS PIN from the key tables","Encode an atomic value","{}","compute the filling factor for the coupled microstrips","Write an inode","{}"
"3CVBMEMMXBGWI1A275ILB60P3JTH7B","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3VAR3R6G1P1CXGY1BPAIYYPA6DGO80","AVC62JNYAXA45","Approved","Wed Apr 17 14:19:43 PDT 2019","Wed Apr 17 14:53:18 PDT 2019","Fri Apr 19 14:53:18 PDT 2019","2019-04-19 21:53:21 UTC","","","2015","100% (24/24)","100% (24/24)","100% (24/24)","5045593","doc_compile.cpp","string DocCompiler::generateDocConstantTbl (Tree /*tbl*/, Tree size, Tree isig)\newline{	\newline	string 	vname, ctype;\newline    string 	init = CS(isig,0);\newline\newline    int     n;\newline    if (!isSigInt(size, &ampn)) {\newline        cerr &lt&lt &quoterror in DocCompiler::generateDocConstantTbl() : &quot\newline             &lt&lt *size\newline             &lt&lt &quot is not an integer expression and can&#039t be used as a table size&#039 &quot\newline             &lt&lt endl;\newline    }\newline\newline    // allocate a name v_i for the table\newline    getTypedNames(getCertifiedSigType(isig), &quotv&quot, ctype, vname);\newline	\newline    // add a comment on tables in the notice\newline		gDocNoticeFlagMap[&quottablesigs&quot] = true;\newline	\newline    // add equation v[t] = isig(t)\newline        fLateq-&gtaddRDTblSigFormula(subst(&quot$0[t] = $1 \\\\condition{when $$t \\\\in [0,$2]$$} &quot, vname, init, T(n-1)));\newline	\newline    // note that the name of the table can never be used outside an sigDocTableAccess\newline    return vname;\newline}\newline","\newline Generate the equation of a constant table (its content is time constant).\newline Returns the name of the table\newline \newline","4475598","http_emergency.c","int get_esgwri_ert_in_contact(char *contact_esgwri, ESCT *call_cell){\newline\newline	char *contact_routing_aux;\newline	str pattern_contact_routing, replacement_contact_routing;\newline	str pt_contact_routing;\newline	int len_contact_routing;\newline	char *contact_routing;\newline	char *pt_aux;\newline	char *p_aux;\newline	char *srid_aux, *resn_aux, *npa_aux;\newline	char *pt_a, *pt_b;\newline	str pattern_contact_ert, replacement_contact_ert;\newline\newline	char *p = strstr(contact_esgwri, &quotP-Asserted-Identity&quot);\newline	len_contact_routing = p - contact_esgwri -1;\newline\newline	contact_routing = pkg_malloc(sizeof (char)*len_contact_routing);\newline	if (contact_routing == NULL) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(contact_routing, 0, len_contact_routing);\newline	p_aux = contact_esgwri;\newline	p_aux++;\newline	memcpy(contact_routing, p_aux, len_contact_routing-1 );\newline	pkg_free(contact_esgwri);\newline\newline	contact_routing_aux = pkg_malloc(sizeof (char)*len_contact_routing);\newline	if (contact_routing_aux == NULL) {\newline		LM_ERR(&quotno more pkg memory\\n&quot);\newline		return -1;\newline	}\newline	memset(contact_routing_aux, 0,len_contact_routing);\newline	pt_contact_routing.s = contact_routing_aux;\newline	pt_contact_routing.len = len_contact_routing - 1;\newline\newline	pattern_contact_routing.s = &quot^(sips?):[+]*([-0-9]+)@&quot;\newline	pattern_contact_routing.len = strlen(pattern_contact_routing.s);\newline	replacement_contact_routing.s = &quot\\\\2&quot;\newline	replacement_contact_routing.len = strlen(replacement_contact_routing.s);\newline\newline	if (reg_replace(pattern_contact_routing.s, replacement_contact_routing.s, contact_routing, &amppt_contact_routing) == 1) {\newline		LM_DBG (&quotTRANS REPLY ESGWRI %s \\n&quot,contact_routing);\newline		call_cell-&gtesgwri = contact_routing;\newline		call_cell-&gtdisposition = &quotprocesses&quot;\newline\newline		pkg_free(contact_routing_aux);\newline\newline	}else{\newline		pattern_contact_ert.s = &quot^(sips?):([A-Z0-9.]*)@&quot;\newline		pattern_contact_ert.len = strlen(pattern_contact_ert.s);\newline		replacement_contact_ert.s = &quot\\\\2&quot;\newline		replacement_contact_ert.len = strlen(replacement_contact_ert.s);\newline\newline		if (reg_replace(pattern_contact_ert.s, replacement_contact_ert.s, contact_routing, &amppt_contact_routing) != 1) {\newline			LM_ERR(&quot****** PATTERN ERT NAO OK \\n&quot);\newline			pkg_free(contact_routing_aux);\newline			pkg_free(contact_routing);\newline			return 0;\newline		}\newline\newline		LM_DBG (&quotCONTEUDO TRANS REPLY ERT %.*s \\n&quot, pt_contact_routing.len, pt_contact_routing.s);\newline		pt_aux = pt_contact_routing.s;\newline		pt_a = strchr(pt_aux,&#039.&#039);\newline		int len_srid = pt_a - pt_contact_routing.s;\newline		srid_aux = pkg_malloc(sizeof (char)*len_srid + 1);\newline		if (srid_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		memcpy(srid_aux, pt_aux, len_srid);\newline		srid_aux[len_srid] = 0;\newline		pt_aux += len_srid + 1;\newline\newline		pt_b = strchr(pt_aux,&#039.&#039);\newline		int len_resn = pt_b - pt_aux ;\newline		resn_aux = pkg_malloc(sizeof (char)*len_resn + 1);\newline		if (resn_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		memcpy(resn_aux, pt_aux, len_resn);\newline		resn_aux[len_resn] = 0;\newline		pt_aux += len_resn + 1;\newline\newline		int len_npa = pt_contact_routing.len - len_srid - len_resn;\newline		npa_aux = pkg_malloc(sizeof (char)*len_npa + 1);\newline		if (npa_aux == NULL) {\newline			LM_ERR(&quotno more pkg memory\\n&quot);\newline			return -1;\newline		}\newline		npa_aux[len_npa] = 0;\newline		memcpy(npa_aux, pt_aux, len_npa);\newline\newline		LM_DBG (&quotCONTEUDO TRANS REPLY SRID %s \\n&quot,srid_aux);\newline		LM_DBG (&quotCONTEUDO TRANS REPLY RESN %s \\n&quot,resn_aux);\newline		LM_DBG (&quotCONTEUDO TRANS REPLY NPA %s \\n&quot,npa_aux);\newline		int npa = atoi(npa_aux);\newline		int resn = atoi(resn_aux);\newline		int srid_len = strlen(srid_aux);\newline\newline		call_cell-&gtert_npa = npa;\newline		call_cell-&gtert_resn = resn;\newline		call_cell-&gtert_srid = pkg_malloc(sizeof (char)* srid_len + 1);\newline		if (call_cell-&gtert_srid == NULL) {\newline			LM_ERR(&quot--------------------------------------------------no more shm memory\\n&quot);\newline			return -1;\newline		}\newline\newline		strcpy(call_cell-&gtert_srid, srid_aux);\newline		call_cell-&gtert_srid[srid_len] = 0;\newline\newline		call_cell-&gtdisposition = &quotprocesses&quot;\newline\newline		pkg_free(contact_routing_aux);\newline		pkg_free(contact_routing);\newline		pkg_free(srid_aux);\newline		pkg_free(resn_aux);\newline		pkg_free(npa_aux);\newline	}\newline	return 1;\newline}\newline","get esgwri or ert information from contact header and save this in call cell\newline \newline","5282736","lj_parse.c","static void bcemit_nil(FuncState *fs, BCReg from, BCReg n)\newline{\newline  if (fs-&gtpc &gt fs-&gtlasttarget) {  /* No jumps to current position? */\newline    BCIns *ip = &ampfs-&gtbcbase[fs-&gtpc-1].ins;\newline    BCReg pto, pfrom = bc_a(*ip);\newline    switch (bc_op(*ip)) {  /* Try to merge with the previous instruction. */\newline    case BC_KPRI:\newline      if (bc_d(*ip) != ~LJ_TNIL) break;\newline      if (from == pfrom) {\newline	if (n == 1) return;\newline      } else if (from == pfrom+1) {\newline	from = pfrom;\newline	n++;\newline      } else {\newline	break;\newline      }\newline      *ip = BCINS_AD(BC_KNIL, from, from+n-1);  /* Replace KPRI. */\newline      return;\newline    case BC_KNIL:\newline      pto = bc_d(*ip);\newline      if (pfrom &lt= from &amp&amp from &lt= pto+1) {  /* Can we connect both ranges? */\newline	if (from+n-1 &gt pto)\newline	  setbc_d(ip, from+n-1);  /* Patch previous instruction range. */\newline	return;\newline      }\newline      break;\newline    default:\newline      break;\newline    }\newline  }\newline  /* Emit new instruction or replace old instruction. */\newline  bcemit_INS(fs, n == 1 ? BCINS_AD(BC_KPRI, from, VKNIL) :\newline			  BCINS_AD(BC_KNIL, from, from+n-1));\newline}\newline","Emit bytecode to set a range of registers to nil. \newline","2531622","pins.c","char *build_wps_pin()\newline{\newline        char *key = NULL, *pin = NULL;\newline        int pin_len = PIN_SIZE + 1;\newline\newline        pin = malloc(pin_len);\newline        key = malloc(pin_len);\newline        if(pin &amp&amp key)\newline        {\newline                memset(key, 0, pin_len);\newline                memset(pin, 0, pin_len);\newline\newline                /* Generate a 7-digit pin from the given key index values */\newline                snprintf(key, pin_len, &quot%s%s&quot, get_p1(get_p1_index()), get_p2(get_p2_index()));\newline\newline                /* Generate and append the pin checksum digit */\newline                snprintf(pin, pin_len, &quot%s%d&quot, key, wps_pin_checksum(atoi(key)));\newline\newline                free(key);\newline        }\newline\newline        return pin;\newline}\newline","Builds a WPS PIN from the key tables \newline","1309526","wgdbmodule.c","static wg_int encode_pyobject_xmlliteral(wg_database *db, PyObject *data,\newline  char *ext_str, int param) {\newline  char *s;\newline#ifndef PYTHON3\newline  s = PyString_AsString(data);\newline#elif defined(HAVE_LOCALEENC)\newline  s = PyBytes_AsString(PyUnicode_EncodeLocale(data, ENCODEERR));\newline#else\newline  s = PyBytes_AsString(PyUnicode_AsEncodedString(data, NULL, ENCODEERR));\newline#endif\newline  /* wg_encode_str is not guaranteed to check for NULL pointer */\newline  if(s) {\newline    if(!param) {\newline      return wg_encode_xmlliteral(db-&gtdb, s, ext_str);\newline    } else {\newline      return wg_encode_query_param_xmlliteral(db-&gtdb, s, ext_str);\newline    }\newline  } else {\newline    return WG_ILLEGAL;\newline  }\newline}\newline","Encode an atomic value of type WG_XMLLITERALTYPE\newline returns WG_ILLEGAL on failure\newline if param is 1, the storage will be allocated in local memory (intended\newline for encoding query parameters without write locking)\newline \newline","4318803","opts_p_z.c","int Xorriso_option_pvd_info(struct XorrisO *xorriso, int flag)\newline{\newline  return(Xorriso_pvd_info(xorriso, 0));\newline}\newline","Option -pvd_info \newline","2772252","c_microstrip.c","gfloat filling_factor_odd(gfloat u, gfloat g, gfloat e_r)\newline{\newline  gfloat b_o, c_o, d_o, q_inf;\newline\newline  b_o = 0.747 * e_r / (0.15 + e_r);\newline  c_o = b_o - (b_o - 0.207) * exp(-0.414 * u);\newline  d_o = 0.593 + 0.694 * exp(-0.562 * u);\newline\newline  /* filling factor, with width corrected for thickness */\newline  q_inf = exp(-c_o * pow(g, d_o));\newline\newline  return q_inf;\newline}\newline","\newline filling_factor_odd() - compute the filling factor for the coupled microstrips odd-mode without cover and zero conductor thickness \newline @u: normalized width\newline @g: normalized strips spacing\newline @e_r: relative dielectric constant\newline \newline","3964276","vmfs_inode.c","static int vmfs_inode_write(const vmfs_inode_t *inode,u_char *buf)\newline{\newline   vmfs_metadata_hdr_write(&ampinode-&gtmdh,buf);\newline   write_le32(buf,VMFS_INODE_OFS_ID,inode-&gtid);\newline   write_le32(buf,VMFS_INODE_OFS_ID2,inode-&gtid2);\newline   write_le32(buf,VMFS_INODE_OFS_NLINK,inode-&gtnlink);\newline   write_le32(buf,VMFS_INODE_OFS_TYPE,inode-&gttype);\newline   write_le32(buf,VMFS_INODE_OFS_FLAGS,inode-&gtflags);\newline   write_le64(buf,VMFS_INODE_OFS_SIZE,inode-&gtsize);\newline   write_le64(buf,VMFS_INODE_OFS_BLK_SIZE,inode-&gtblk_size);\newline   write_le64(buf,VMFS_INODE_OFS_BLK_COUNT,inode-&gtblk_count);\newline   write_le32(buf,VMFS_INODE_OFS_MTIME,inode-&gtmtime);\newline   write_le32(buf,VMFS_INODE_OFS_CTIME,inode-&gtctime);\newline   write_le32(buf,VMFS_INODE_OFS_ATIME,inode-&gtatime);\newline   write_le32(buf,VMFS_INODE_OFS_UID,inode-&gtuid);\newline   write_le32(buf,VMFS_INODE_OFS_GID,inode-&gtgid);\newline   write_le32(buf,VMFS_INODE_OFS_MODE,inode-&gtmode);\newline   write_le32(buf,VMFS_INODE_OFS_ZLA,inode-&gtzla);\newline   write_le32(buf,VMFS_INODE_OFS_TBZ,inode-&gttbz);\newline   write_le32(buf,VMFS_INODE_OFS_COW,inode-&gtcow);\newline   return(0);\newline}\newline","Write an inode \newline","811393","ewk_contextmenu.cpp","void ewk_context_menu_show(Ewk_Context_Menu* menu)\newline{\newline    EINA_SAFETY_ON_NULL_RETURN(menu);\newline\newline    evas_object_smart_callback_call(menu-&gtview, &quotcontextmenu,show&quot, menu);\newline}\newline","\newline @internal\newline \newline Emits a signal &quotcontextmenu,show&quot\newline \newline @param menu the context menu object\newline \newline","383603","qbatteryinfo.cpp","QBatteryInfo::QBatteryInfo(QObject *parent)\newline    : QObject(parent)\newline#if !defined(QT_SIMULATOR)\newline    , d_ptr(new QBatteryInfoPrivate(this))\newline#else\newline    , d_ptr(new QBatteryInfoSimulator(this))\newline#endif // QT_SIMULATOR\newline\newline{\newline}\newline","!\newlineConstructs a \\l QBatteryInfo object with the given \\a parent. The \\l batteryIndex()\newlinewill default to \\c 0.\newline \newline","3659541","weaver.cpp","Weaver::~Weaver()\newline{\newline    Q_ASSERT_X(state()-&gtstateId() == Destructed, Q_FUNC_INFO, &quotshutDown() method was not called before Weaver destructor!&quot);\newline}\newline","@brief Destructs a Weaver object. \newline","391953","xz_dec_lzma2.c","static __always_inline uint32_t rc_bittree(\newline		struct rc_dec *rc, uint16_t *probs, uint32_t limit)\newline{\newline	uint32_t symbol = 1;\newline\newline	do {\newline		if (rc_bit(rc, &ampprobs[symbol]))\newline			symbol = (symbol &lt&lt 1) + 1;\newline		else\newline			symbol &lt&lt= 1;\newline	} while (symbol &lt limit);\newline\newline	return symbol;\newline}\newline","Decode a bittree starting from the most significant bit. \newline","384795","ib_cm.c","void ib_destroy_conn ( struct ib_device *ibdev,\newline		       struct ib_queue_pair *qp __unused,\newline		       struct ib_connection *conn ) {\newline\newline	list_del ( &ampconn-&gtlist );\newline	if ( conn-&gtmadx )\newline		ib_destroy_madx ( ibdev, ibdev-&gtgsi, conn-&gtmadx );\newline	if ( conn-&gtpath )\newline		ib_destroy_path ( ibdev, conn-&gtpath );\newline	free ( conn );\newline}\newline","\newline Destroy connection to remote QP\newline \newline @v ibdev Infiniband device\newline @v qp Queue pair\newline @v conn Connection\newline \newline","1271412","lsqlite3.c","static int db_urows(lua_State *L) {\newline  return db_do_rows(L, db_next_row);\newline}\newline","unpacked version of db:rows \newline","1305695","ceph.c","static int cconn_main_loop(uint32_t request_type) {\newline  int ret, some_unreachable = 0;\newline  struct timeval end_tv;\newline  struct cconn io_array[g_num_daemons];\newline\newline  DEBUG(&quotceph plugin: entering cconn_main_loop(request_type = %&quot PRIu32 &quot)&quot,\newline        request_type);\newline\newline  if (g_num_daemons &lt 1) {\newline    ERROR(&quotceph plugin: No daemons configured. See the \\&quotDaemon\\&quot config &quot\newline          &quotoption.&quot);\newline    return ENOENT;\newline  }\newline\newline  /* create cconn array */\newline  for (size_t i = 0; i &lt g_num_daemons; i++) {\newline    io_array[i] = (struct cconn){\newline        .d = g_daemons[i],\newline        .request_type = request_type,\newline        .state = CSTATE_UNCONNECTED,\newline    };\newline  }\newline\newline  /** Calculate the time at which we should give up */\newline  gettimeofday(&ampend_tv, NULL);\newline  end_tv.tv_sec += CEPH_TIMEOUT_INTERVAL;\newline\newline  while (1) {\newline    int nfds, diff;\newline    struct timeval tv;\newline    struct cconn *polled_io_array[g_num_daemons];\newline    struct pollfd fds[g_num_daemons];\newline    memset(fds, 0, sizeof(fds));\newline    nfds = 0;\newline    for (size_t i = 0; i &lt g_num_daemons; ++i) {\newline      struct cconn *io = io_array + i;\newline      ret = cconn_prepare(io, fds + nfds);\newline      if (ret &lt 0) {\newline        WARNING(&quotceph plugin: cconn_prepare(name=%s,i=%zu,st=%d)=%d&quot,\newline                io-&gtd-&gtname, i, io-&gtstate, ret);\newline        cconn_close(io);\newline        io-&gtrequest_type = ASOK_REQ_NONE;\newline        some_unreachable = 1;\newline      } else if (ret == 1) {\newline        polled_io_array[nfds++] = io_array + i;\newline      }\newline    }\newline    if (nfds == 0) {\newline      /* finished */\newline      ret = 0;\newline      goto done;\newline    }\newline    gettimeofday(&amptv, NULL);\newline    diff = milli_diff(&ampend_tv, &amptv);\newline    if (diff &lt= 0) {\newline      /* Timed out */\newline      ret = -ETIMEDOUT;\newline      WARNING(&quotceph plugin: cconn_main_loop: timed out.&quot);\newline      goto done;\newline    }\newline    RETRY_ON_EINTR(ret, poll(fds, nfds, diff));\newline    if (ret &lt 0) {\newline      ERROR(&quotceph plugin: poll(2) error: %d&quot, ret);\newline      goto done;\newline    }\newline    for (int i = 0; i &lt nfds; ++i) {\newline      struct cconn *io = polled_io_array[i];\newline      int revents = fds[i].revents;\newline      if (revents == 0) {\newline        /* do nothing */\newline        continue;\newline      } else if (cconn_validate_revents(io, revents)) {\newline        WARNING(&quotceph plugin: cconn(name=%s,i=%d,st=%d): &quot\newline                &quotrevents validation error: &quot\newline                &quotrevents=0x%08x&quot,\newline                io-&gtd-&gtname, i, io-&gtstate, revents);\newline        cconn_close(io);\newline        io-&gtrequest_type = ASOK_REQ_NONE;\newline        some_unreachable = 1;\newline      } else {\newline        ret = cconn_handle_event(io);\newline        if (ret) {\newline          WARNING(&quotceph plugin: cconn_handle_event(name=%s,&quot\newline                  &quoti=%d,st=%d): error %d&quot,\newline                  io-&gtd-&gtname, i, io-&gtstate, ret);\newline          cconn_close(io);\newline          io-&gtrequest_type = ASOK_REQ_NONE;\newline          some_unreachable = 1;\newline        }\newline      }\newline    }\newline  }\newlinedone:\newline  for (size_t i = 0; i &lt g_num_daemons; ++i) {\newline    cconn_close(io_array + i);\newline  }\newline  if (some_unreachable) {\newline    DEBUG(&quotceph plugin: cconn_main_loop: some Ceph daemons were unreachable.&quot);\newline  } else {\newline    DEBUG(&quotceph plugin: cconn_main_loop: reached all Ceph daemons :)&quot);\newline  }\newline  return ret;\newline}\newline","This handles the actual network I/O to talk to the Ceph daemons.\newline \newline","5365831","resource.c","static IMAGE_SECTION_HEADER *get_resource_section( void *base, DWORD mapping_size )\newline{\newline    IMAGE_SECTION_HEADER *sec;\newline    IMAGE_NT_HEADERS *nt;\newline    DWORD i, num_sections = 0;\newline\newline    nt = get_nt_header( base, mapping_size );\newline    if (!nt)\newline        return NULL;\newline\newline    sec = get_section_header( base, mapping_size, &ampnum_sections );\newline    if (!sec)\newline        return NULL;\newline\newline    /* find the resources section */\newline    for (i=0; i&ltnum_sections; i++)\newline        if (!memcmp(sec[i].Name, &quot.rsrc&quot, 6))\newline            break;\newline\newline    if (i == num_sections)\newline        return NULL;\newline\newline    return &ampsec[i];\newline}\newline","\newline FIXME:\newline Assumes that the resources are in .rsrc\newline and .rsrc is the last section in the file.\newline Not sure whether updating resources will other cases on Windows.\newline If the resources lie in a section containing other data,\newline resizing that section could possibly cause trouble.\newline If the section with the resources isn&#039t last, the remaining\newline sections need to be moved down in the file, and the section header\newline would need to be adjusted.\newline If we needed to add a section, what would we name it?\newline If we needed to add a section and there wasn&#039t space in the file\newline header, how would that work?\newline Seems that at least some of these cases can&#039t be handled properly.\newline \newline","5898923","kmo_priv_functions-test.c","int main()\newline{\newline    cpl_test_init(&quot&ltusd-help@eso.org&gt&quot, CPL_MSG_WARNING);\newline\newline    test_kmo_create_lambda_vec();\newline    test_kmo_is_in_range();\newline    test_kmo_identify_slices();\newline    test_kmo_identify_ranges();\newline    test_kmo_identify_values();\newline    test_kmo_image_get_stdev_median();\newline    test_kmos_combine_pars_create();\newline    test_kmos_band_pars_create();\newline    /* test_kmos_combine_pars_load(); */\newline    test_kmos_band_pars_load();\newline    /* test_kmo_check_frameset_setup(); */\newline    /* test_kmo_check_frame_setup(); */\newline    /* test_kmo_priv_compare_frameset_setup(); */\newline\newline    return cpl_test_end(0);\newline}\newline","\newline@brief Test of helper functions needed in several recipes\newline \newline","2163373","index.c","static void index_thread_orderedsubj(struct index_state *state, \newline				     unsigned *msgno_list, int nmsg,\newline				     int usinguid)\newline{\newline    MsgData *msgdata, *freeme;\newline    static const struct sortcrit sortcrit[] =\newline				 {{ SORT_SUBJECT,  0, {{NULL, NULL}} },\newline				  { SORT_DATE,     0, {{NULL, NULL}} },\newline				  { SORT_SEQUENCE, 0, {{NULL, NULL}} }};\newline    unsigned psubj_hash = 0;\newline    char *psubj;\newline    Thread *head, *newnode, *cur, *parent, *last;\newline\newline    /* Create/load the msgdata array */\newline    freeme = msgdata = index_msgdata_load(state, msgno_list, nmsg, sortcrit);\newline\newline    /* Sort messages by subject and date */\newline    msgdata = lsort(msgdata,\newline		    (void * (*)(void*)) index_sort_getnext,\newline		    (void (*)(void*,void*)) index_sort_setnext,\newline		    (int (*)(void*,void*,void*)) index_sort_compare,\newline		    (void *)sortcrit);\newline\newline    /* create an array of Thread to use as nodes of thread tree\newline     *\newline     * we will be building threads under a dummy head,\newline     * so we need (nmsg + 1) nodes\newline     */\newline    head = (Thread *) xzmalloc((nmsg + 1) * sizeof(Thread));\newline\newline    newnode = head + 1;	/* set next newnode to the second\newline			   one in the array (skip the head) */\newline    parent = head;	/* parent is the head node */\newline    psubj = NULL;	/* no previous subject */\newline    cur = NULL;		/* no current thread */\newline    last = NULL;	/* no last child */\newline\newline    while (msgdata) {\newline	newnode-&gtmsgdata = msgdata;\newline\newline	/* if no previous subj, or\newline	   current subj = prev subj (subjs have same hash, and\newline	   the strings are equal), then add message to current thread */\newline	if (!psubj ||\newline	    (msgdata-&gtxsubj_hash == psubj_hash &amp&amp\newline	     !strcmp(msgdata-&gtxsubj, psubj))) {\newline	    /* if no children, create first child */\newline	    if (!parent-&gtchild) {\newline		last = parent-&gtchild = newnode;\newline		if (!cur)		/* first thread */\newline		    parent = cur = parent-&gtchild;\newline	    }\newline	    /* otherwise, add to siblings */\newline	    else {\newline		last-&gtnext = newnode;\newline		last = last-&gtnext;\newline	    }\newline	}\newline	/* otherwise, create a new thread */\newline	else {\newline	    cur-&gtnext = newnode;	/* create and start a new thread */\newline	    parent = cur = cur-&gtnext;	/* now work with the new thread */\newline	}\newline\newline	psubj_hash = msgdata-&gtxsubj_hash;\newline	psubj = msgdata-&gtxsubj;\newline	msgdata = msgdata-&gtnext;\newline	newnode++;\newline    }\newline\newline    /* Sort threads by date */\newline    index_thread_sort(head, sortcrit+1);\newline\newline    /* Output the threaded messages */ \newline    index_thread_print(state, head, usinguid);\newline\newline    /* free the thread array */\newline    free(head);\newline\newline    /* free the msgdata array */\newline    free(freeme);\newline}\newline","\newline Thread a list of messages using the ORDEREDSUBJECT algorithm.\newline \newline","5750880","gfal_srm.c","char *gfal_srm_construct_key(const char *url, const char *prefix, char *buff,\newline    const size_t s_buff)\newline{\newline    g_strlcpy(buff, prefix, s_buff);\newline    g_strlcat(buff, url, s_buff);\newline    char *p2 = buff + strlen(prefix) + strlen(GFAL_PREFIX_SRM) + 2;\newline    while (*p2 != &#039\\0&#039) { //remove the duplicate //\newline        if (*p2 == &#039/&#039 &amp&amp *(p2 + 1) == &#039/&#039) {\newline            memmove(p2, p2 + 1, strlen(p2 + 1) + 1);\newline        }\newline        else\newline            p2++;\newline    }\newline    return buff;\newline}\newline","\newline Construct a key for the cache system from a url and a prefix\newline \newline","5109154","getdata.c","static size_t _GD_DoMultiply(DIRFILE *restrict D, gd_entry_t *restrict E,\newline    off64_t first_samp, size_t num_samp, gd_type_t return_type,\newline    void *restrict data_out)\newline{\newline  void *tmpbuf = NULL;\newline  unsigned int spf1, spf2;\newline  size_t n_read, n_read2, num_samp2;\newline  off64_t first_samp2;\newline  gd_type_t type2;\newline\newline  dtrace(&quot%p, %p, %&quot PRId64 &quot, %&quot PRIuSIZE &quot, 0x%X, %p&quot, D, E,\newline      (int64_t)first_samp, num_samp, return_type, data_out);\newline\newline  /* find the samples per frame of the first field */\newline  spf1 = _GD_GetSPF(D, E-&gte-&gtentry[0]);\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* read the first field and record the number of samples returned */\newline  n_read = _GD_DoField(D, E-&gte-&gtentry[0], E-&gte-&gtrepr[0], first_samp, num_samp,\newline      return_type, data_out);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* Nothing to multiply */\newline  if (n_read == 0) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* find the samples per frame of the second field */\newline  spf2 = _GD_GetSPF(D, E-&gte-&gtentry[1]);\newline  if (D-&gterror != GD_E_OK) {\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* calculate the first sample and number of samples to read of the\newline   * second field */\newline  num_samp2 = (int)ceil((double)n_read * spf2 / spf1);\newline  first_samp2 = first_samp * spf2 / spf1;\newline\newline  /* find the native type of the second field */\newline  type2 = (_GD_NativeType(D, E-&gte-&gtentry[1], E-&gte-&gtrepr[1]) &amp GD_COMPLEX) ?\newline    GD_COMPLEX128 : GD_FLOAT64;\newline\newline  /* Allocate a temporary buffer for the second field */\newline  tmpbuf = _GD_Alloc(D, type2, num_samp2);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    free(tmpbuf);\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  /* read the second field */\newline  n_read2 = _GD_DoField(D, E-&gte-&gtentry[1], E-&gte-&gtrepr[1], first_samp2,\newline      num_samp2, type2, tmpbuf);\newline\newline  if (D-&gterror != GD_E_OK) {\newline    free(tmpbuf);\newline    dreturn(&quot%i&quot, 0);\newline    return 0;\newline  }\newline\newline  if (n_read2 &gt 0 &amp&amp n_read2 * spf1 &lt n_read * spf2)\newline    n_read = n_read2 * spf1 / spf2;\newline\newline  if (type2 &amp GD_COMPLEX)\newline    _GD_CMultiplyData(D, data_out, spf1, tmpbuf, spf2, return_type, n_read);\newline  else\newline    _GD_MultiplyData(D, data_out, spf1, tmpbuf, spf2, return_type, n_read);\newline\newline  free(tmpbuf);\newline\newline  dreturn(&quot%&quot PRIuSIZE, n_read);\newline  return n_read;\newline}\newline","_GD_DoMultiply: Read from a multiply. Returns number of samples read.\newline \newline","2188896","cb88o.c","void CB_MATA(GtkWidget *widget,GdkEvent *event,gpointer data)\newline{\newlineextern FR_DOUBLE  xx,yy;\newlineextern int        ifmaus;\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON1_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_ZOOM;\newline  InvalidateRect88();\newline  }\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON2_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_PAN;\newline  InvalidateRect88();\newline  }\newline\newlineif( event-&gtmotion.state &amp GDK_BUTTON3_MASK)\newline  {\newline  xx= event-&gtmotion.x;\newline  yy= event-&gtmotion.y;\newline  ifmaus= IDM_ROTATE;\newline  InvalidateRect88();\newline  }\newline\newlinereturn;\newline}\newline","\newline CB_MATA\newline \newline","","","","","","on","","on","","","","","","on","","","","on","","","","on","","","","","","","","","","","","","","","","","","","","","Generate the equation of a constant table","Constructs a \l QBatteryInfo object","Destructs a Weaver object.","Decode a bittree","Destroy connection to remote QP","{}","handles the actual network I/O to talk to the Ceph daemons.","{}","Test of helper functions","Thread a list of messages","Construct a key for the cache system","get esgwri or ert information from contact header and save","Returns number of samples read.","{}","set a range of registers to nil.","Builds a WPS PIN","Encode an atomic value of type WG_XMLLITERALTYPE","{}","compute the filling factor for the coupled microstrips","Write an inode","Emits a signal ""contextmenu,show"""
"3D5G8J4N5A4OY02TPX2QV3JG0VVTVP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","37C0GNLMHF3YP5OOS1Z43QHKW7WD6P","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 21:56:59 PDT 2019","Wed Apr 17 22:02:55 PDT 2019","Fri Apr 19 22:02:55 PDT 2019","2019-04-20 05:03:22 UTC","","","356","100% (10/10)","100% (10/10)","100% (10/10)","5992121","touchscreen.c","static void irq_touchscreen(struct urb *urb)\newline{\newline  /*\newline   * data raports...\newline   */\newline  struct tscrn_usb_data *tscrn = urb-&gtcontext;\newline  struct tscrn_usb_data_report *data = (struct tscrn_usb_data_report *)tscrn-&gtdata;\newline\newline  if (urb-&gtstatus) return;\newline\newline  //return when driver was clesed \newline  if(!tscrn-&gtisopen) return;\newline\newline  // increase loop counter\newline  // !!! Unfortunately the data was lost to seldom !!!\newline  //if((int)GET_LOOP(data) != tscrn-&gtnLoopCounter)\newline  //  warn(&quotwarn:Lost data new loop %d previous loop %d&quot,(int)GET_LOOP(data),(int)tscrn-&gtnLoopCounter);\newline\newline  input_report_key(&amptscrn-&gtinput_dev, BTN_LEFT, IS_TOUCHED(data));\newline  input_report_abs(&amptscrn-&gtinput_dev, ABS_X, GET_XC(data));\newline  input_report_abs(&amptscrn-&gtinput_dev, ABS_Y, GET_YC(data));\newline\newline  tscrn-&gtnLoopCounter = (GET_LOOP(data))+1; \newline\newline  // store data to buffer\newline  memcpy(tscrn-&gtpToWrite,data,TSCRN_USB_RAPORT_SIZE_DATA);\newline  // next data to next cell\newline  if(tscrn-&gtpToRead == NULL)\newline    tscrn-&gtpToRead = tscrn-&gtpToWrite;\newline\newline  tscrn-&gtpToWrite += TSCRN_USB_RAPORT_SIZE_DATA;\newline  if(tscrn-&gtpToWrite &gt= tscrn-&gtobuf+OBUF_SIZE)\newline    tscrn-&gtpToWrite = tscrn-&gtobuf;\newline\newline  if (waitqueue_active(&amptscrn-&gtwait))\newline    wake_up_interruptible(&amptscrn-&gtwait);\newline\newline  //dbg(&quotirq_touchscreen(): GET_Data 0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x status=%d&quot, (int)data[0],(int)data[1],(int)data[2],(int)data[3],(int)data[4],(int)data[5],(int)data[6],(int)data[7],(int)data[8],(int)data[9],(int)data[10], tscrn-&gtctrlout.status);\newline\newline  return;\newline}\newline","\newline Runs on new data received from device\newline The buffer should keep the last state of device, thus the buffer overflow\newline can occurre\newline The client can&#039t read data when pToRead == pToWrite\newline \newline","5983511","wrapper.c","int wrapperBuildUnixDaemonInfo() {\newline    if (!wrapperData-&gtconfigured) {\newline        /** Get the daemonize flag. */\newline        wrapperData-&gtdaemonize = getBooleanProperty(properties, TEXT(&quotwrapper.daemonize&quot), FALSE);\newline        /** Configure the HUP signal handler. */\newline        wrapperData-&gtsignalHUPMode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.hup&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline\newline        /** Configure the USR1 signal handler. */\newline        wrapperData-&gtsignalUSR1Mode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.usr1&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline\newline        /** Configure the USR2 signal handler. */\newline        wrapperData-&gtsignalUSR2Mode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.usr2&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline    }\newline\newline    return FALSE;\newline}\newline","\newline Return FALSE if successful, TRUE if there were problems.\newline \newline","3923303","kernel_ops.c","VIO_Volume  convolve_kernel(Kernel * K, VIO_Volume vol)\newline{\newline   int      x, y, z, c;\newline   double   value;\newline   int      sizes[MAX_VAR_DIMS];\newline   VIO_progress_struct progress;\newline   VIO_Volume   tmp_vol;\newline\newline   if(verbose){\newline      fprintf(stdout, &quotConvolve kernel\\n&quot);\newline      }\newline   get_volume_sizes(vol, sizes);\newline   initialize_progress_report(&ampprogress, FALSE, sizes[2], &quotConvolve&quot);\newline\newline   /* copy the volume */\newline   tmp_vol = copy_volume(vol);\newline\newline   for(z = -K-&gtpre_pad[2]; z &lt sizes[0] - K-&gtpost_pad[2]; z++){\newline      for(y = -K-&gtpre_pad[1]; y &lt sizes[1] - K-&gtpost_pad[1]; y++){\newline         for(x = -K-&gtpre_pad[0]; x &lt sizes[2] - K-&gtpost_pad[0]; x++){\newline\newline            value = 0;\newline            for(c = 0; c &lt K-&gtnelems; c++){\newline               value += get_volume_real_value(tmp_vol,\newline                                              z + K-&gtK[c][2],\newline                                              y + K-&gtK[c][1],\newline                                              x + K-&gtK[c][0], 0 + K-&gtK[c][3],\newline                                              0 + K-&gtK[c][4]) * K-&gtK[c][5];\newline               }\newline            set_volume_real_value(vol, z, y, x, 0, 0, value);\newline            }\newline         }\newline\newline      update_progress_report(&ampprogress, z + 1);\newline      }\newline\newline   delete_volume(tmp_vol);\newline   terminate_progress_report(&ampprogress);\newline   return (vol);\newline   }\newline","convolve a volume with a input kernel \newline","4516843","basop32.c","Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)\newline{\newline    Word32 L_var_out;\newline    Word32 L_product;\newline\newline    L_product = L_mult (var1, var2);\newline#if (WMOPS)\newline    multiCounter[currCounter].L_mult--;\newline#endif\newline    L_var_out = L_add (L_var3, L_product);\newline#if (WMOPS)\newline    multiCounter[currCounter].L_add--;\newline    multiCounter[currCounter].L_mac++;\newline#endif\newline    return (L_var_out);\newline}\newline","___________________________________________________________________________\newline| |\newline| Function Name : L_mac |\newline| |\newline| Purpose : |\newline| |\newline| Multiply var1 by var2 and shift the result left by 1. Add the 32 bit |\newline| result to L_var3 with saturation, return a 32 bit result: |\newline| L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)). |\newline| |\newline| Complexity weight : 1 |\newline| |\newline| Inputs : |\newline| |\newline| L_var3 32 bit long signed integer (Word32) whose value falls in the |\newline| range : 0x8000 0000 &lt= L_var3 &lt= 0x7fff ffff. |\newline| |\newline| var1 |\newline| 16 bit short signed integer (Word16) whose value falls in the |\newline| range : 0xffff 8000 &lt= var1 &lt= 0x0000 7fff. |\newline| |\newline| var2 |\newline| 16 bit short signed integer (Word16) whose value falls in the |\newline| range : 0xffff 8000 &lt= var1 &lt= 0x0000 7fff. |\newline| |\newline| Outputs : |\newline| |\newline| none |\newline| |\newline| Return Value : |\newline| |\newline| L_var_out |\newline| 32 bit long signed integer (Word32) whose value falls in the |\newline| range : 0x8000 0000 &lt= L_var_out &lt= 0x7fff ffff. |\newline|___________________________________________________________________________|\newline \newline","2646691","datastore_sqlite.c","static void free_dbh(dbh_t *dbh) {\newline    if (!dbh)\newline	return;\newline    xfree(dbh-&gtname);\newline    xfree(dbh-&gtpath);\newline    xfree(dbh);\newline}\newline","Free internal database handle \\a dbh. \newline","6444633","gtkhelp.c","void initialize_buttons (GtkWidget *main_vbox, GtkWidget *content_hpane) {\newline        GtkWidget *buttons_hbuttonbox;\newline        GtkWidget *back_button;\newline        GtkWidget *forward_button;\newline        GtkWidget *home_button;\newline        GtkWidget *contents_button;\newline\newline        // define and attach signals to buttons\newline        back_button = gtk_button_new_with_label(_(&quotBack&quot));\newline        g_signal_connect(back_button, &quotclicked&quot, G_CALLBACK(back_button_clicked), G_OBJECT(main_view));\newline\newline        forward_button = gtk_button_new_with_label(_(&quotForward&quot));\newline        g_signal_connect(forward_button, &quotclicked&quot, G_CALLBACK(forward_button_clicked), G_OBJECT(main_view));\newline\newline        home_button = gtk_button_new_with_label(_(&quotHome&quot));\newline        g_signal_connect(home_button, &quotclicked&quot, G_CALLBACK(home_button_clicked), G_OBJECT(main_view));\newline\newline        contents_button = gtk_button_new_with_label(_(&quotContents&quot));\newline        g_signal_connect(contents_button, &quotclicked&quot, G_CALLBACK(contents_button_clicked), G_OBJECT(content_hpane));\newline\newline        // button layout\newline        buttons_hbuttonbox = gtk_hbutton_box_new();\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), back_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), forward_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), home_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), contents_button);\newline        gtk_box_pack_start(GTK_BOX(main_vbox), buttons_hbuttonbox, FALSE, TRUE, 0);\newline        gtk_box_set_spacing(GTK_BOX(buttons_hbuttonbox), 6);\newline        gtk_button_box_set_layout(GTK_BUTTON_BOX(buttons_hbuttonbox), GTK_BUTTONBOX_START);\newline\newline	/* Store pointers to all widgets, for use by lookup_widget().  */\newline	GLADE_HOOKUP_OBJECT (main_view, back_button, BACKBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, forward_button, FORWARDBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, home_button, HOMEBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, contents_button, CONTENTBUTTON);\newline}\newline","\newline Initialize the buttons for the help window\newline \newline","1321510","ppc_vec.c","void ppc_opc_vcmpbfpx()\newline{\newline	VECTOR_DEBUG;\newline	int vrD, vrA, vrB;\newline	int le, ge;\newline	int ib=CR_CR6_NE;\newline	PPC_OPC_TEMPL_X(gCPU.current_opc, vrD, vrA, vrB);\newline	int i;\newline	for (i=0; i&lt4; i++) { //FIXME: This might not comply with Java FP\newline		le = (gCPU.vr[vrA].f[i] &lt= gCPU.vr[vrB].f[i]) ? 0 : 0x80000000;\newline		ge = (gCPU.vr[vrA].f[i] &gt= -gCPU.vr[vrB].f[i]) ? 0 : 0x40000000;\newline\newline		gCPU.vr[vrD].w[i] = le | ge;\newline		if (le | ge) {\newline			ib = 0;\newline 		}\newline	}\newline\newline	if (PPC_OPC_VRc &amp gCPU.current_opc) {\newline		gCPU.cr &amp= ~CR_CR6;\newline		gCPU.cr |= ib;\newline	}\newline}\newline","vcmpbfpx Vector Compare Bounds Floating Point\newline v.157\newline \newline","206757","brlapi_keyranges.c","static void freeKeyrange(KeyrangeList **p, KeyrangeList *c)\newline{\newline  if (c==NULL) return;\newline  *p = c-&gtnext;\newline  free(c);\newline}\newline","Function : freeKeyrange \newline","5249493","sdlgui.c","static SDL_Surface *SDLGui_LoadXBM(int w, int h, const void *pXbmBits)\newline{\newline	SDL_Surface *bitmap;\newline	Uint8 *dstbits;\newline	const Uint8 *srcbits;\newline	int x, y, srcpitch;\newline	int mask;\newline\newline	srcbits = pXbmBits;\newline\newline	/* Allocate the bitmap */\newline	bitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 8, 0, 0, 0, 0);\newline	if (bitmap == NULL)\newline	{\newline		fprintf(stderr, &quotFailed to allocate bitmap: %s&quot, SDL_GetError());\newline		return NULL;\newline	}\newline\newline	srcpitch = ((w + 7) / 8);\newline	dstbits = (Uint8 *)bitmap-&gtpixels;\newline	mask = 1;\newline\newline	/* Copy the pixels */\newline	for (y = 0 ; y &lt h ; y++)\newline	{\newline		for (x = 0 ; x &lt w ; x++)\newline		{\newline			dstbits[x] = (srcbits[x / 8] &amp mask) ? 1 : 0;\newline			mask &lt&lt= 1;\newline			mask |= (mask &gt&gt 8);\newline			mask &amp= 0xFF;\newline		}\newline		dstbits += bitmap-&gtpitch;\newline		srcbits += srcpitch;\newline	}\newline\newline	return bitmap;\newline}\newline","\newline Load an 1 plane XBM into a 8 planes SDL_Surface.\newline \newline","1999811","modp_b85_gen.c","static void printStart(void)\newline{\newline    printf(&quot/* do not edit -- autogenerated from b85gen */\\n&quot);\newline}\newline","\newline beginning headers\newline \newline","5964543","im.c","faim_export int aim_im_sendch1(aim_session_t *sess, const char *sn, fu16_t flags, const char *msg)\newline{\newline	struct aim_sendimext_args args;\newline\newline	args.destsn = sn;\newline	args.flags = flags;\newline	args.msg = msg;\newline	args.msglen = strlen(msg);\newline	args.charset = 0x0000;\newline	args.charsubset = 0x0000;\newline\newline	/* Make these don&#039t get set by accident -- they need aim_im_sendch1_ext */\newline	args.flags &amp= ~(AIM_IMFLAGS_CUSTOMFEATURES | AIM_IMFLAGS_HASICON | AIM_IMFLAGS_MULTIPART);\newline\newline	return aim_im_sendch1_ext(sess, &ampargs);\newline}\newline","\newline Simple wrapper for aim_im_sendch1_ext() \newline \newline You cannot use aim_send_im if you need the HASICON flag. You must\newline use aim_im_sendch1_ext directly for that.\newline \newline aim_send_im also cannot be used if you require UNICODE messages, because\newline that requires an explicit message length. Use aim_im_sendch1_ext().\newline \newline \newline","1395666","theory_bitvector.cpp","Theorem TheoryBitvector::bitBlastTerm(const Expr&amp t, int bitPosition)\newline{\newline  TRACE(&quotbitvector&quot, &quotbitBlastTerm(&quot, t, &quot, &quot + int2string(bitPosition) + &quot) {&quot);\newline\newline  IF_DEBUG(Type type = t.getType();)\newline  DebugAssert(BITVECTOR == type.getExpr().getOpKind(), &quotTheoryBitvector::bitBlastTerm: The type of input to bitBlastTerm must be BITVECTOR.\\n t = &quot +t.toString());\newline  DebugAssert(bitPosition &gt= 0, &quotTheoryBitvector::bitBlastTerm: illegal bitExtraction attempted.\\n bitPosition = &quot + int2string(bitPosition));\newline\newline  Theorem result;\newline\newline  // Check the cache\newline  Expr t_i = newBoolExtractExpr(t, bitPosition);\newline  CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(t_i);\newline  if (it != d_bitvecCache.end()) {\newline	  result = (*it).second;\newline	  TRACE(&quotbitvector&quot, &quotbitBlastTerm[cached] =&gt &quot, result, &quot }&quot);\newline	  DebugAssert(t_i == result.getLHS(),	&quotTheoryBitvector::bitBlastTerm: created wrong theorem&quot + result.toString() + t_i.toString());\newline	  return result;\newline  }\newline\newline  // Construct the theorem t[bitPosition] &lt=&gt \\theta_i and put it into\newline  // d_bitvecCache\newline  switch(t.getOpKind()) {\newline    case BVCONST:\newline    	result = d_rules-&gtbitExtractConstant(t, bitPosition);\newline    	break;\newline    case CONCAT:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractConcatenation(t, bitPosition);\newline    	const Expr&amp boolExtractTerm = thm.getRHS();\newline    	DebugAssert(BOOLEXTRACT == boolExtractTerm.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be bool_extract&quot);\newline    	const Expr&amp term = boolExtractTerm[0];\newline    	int bitPos = getBoolExtractIndex(boolExtractTerm);\newline    	TRACE(&quotbitvector&quot, &quotterm for bitblastTerm recursion:(&quot, term.toString(), &quot)&quot);\newline    	result = transitivityRule(thm, bitBlastTerm(term, bitPos));\newline    	break;\newline    }\newline    case EXTRACT:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractExtraction(t, bitPosition);\newline    	const Expr&amp boolExtractTerm = thm.getRHS();\newline    	DebugAssert(BOOLEXTRACT == boolExtractTerm.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be bool_extract&quot);\newline    	const Expr&amp term = boolExtractTerm[0];\newline    	int bitPos = getBoolExtractIndex(boolExtractTerm);\newline    	TRACE(&quotbitvector&quot, &quotterm for bitblastTerm recursion:(&quot, term, &quot)&quot);\newline    	result = transitivityRule(thm, bitBlastTerm(term, bitPos));\newline    	break;\newline    }\newline    case CONST_WIDTH_LEFTSHIFT:\newline    {\newline    	result = d_rules-&gtbitExtractFixedLeftShift(t, bitPosition);\newline    	const Expr&amp extractTerm = result.getRHS();\newline    	if(BOOLEXTRACT == extractTerm.getOpKind())\newline    		result = transitivityRule(result, bitBlastTerm(extractTerm[0], getBoolExtractIndex(extractTerm)));\newline    	break;\newline    }\newline    case BVSHL:\newline    {\newline    	// BOOLEXTRACT(bvshl(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                               ((x = 1) AND BOOLEXTRACT(t,i-1)) OR ...\newline    	//                               ((x = i) AND BOOLEXTRACT(t,0))\newline    	Theorem thm = d_rules-&gtbitExtractBVSHL(t, bitPosition);\newline    	// bitblast the equations and extractions\newline      	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline      	for (int i = 0; i &lt= bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition-i));\newline        	thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVLSHR:\newline    {\newline    	// BOOLEXTRACT(bvlshr(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                                ((x = 1) AND BOOLEXTRACT(t,i+1)) OR ...\newline    	//                                ((x = n-1-i) AND BOOLEXTRACT(t,n-1))\newline    	Theorem thm = d_rules-&gtbitExtractBVLSHR(t, bitPosition);\newline    	// bitblast the equations and extractions\newline    	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline    	for (int i = 0; i &lt= bvsize-1-bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition+i));\newline    		thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVASHR:\newline    {\newline    	// BOOLEXTRACT(bvlshr(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                                ((x = 1) AND BOOLEXTRACT(t,i+1)) OR ...\newline    	//                                ((x &gt= n-1-i) AND BOOLEXTRACT(t,n-1))\newline    	Theorem thm = d_rules-&gtbitExtractBVASHR(t, bitPosition);\newline    	// bitblast the equations and extractions\newline    	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline    	int i = 0;\newline    	for (; i &lt bvsize-1-bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition+i));\newline    		thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	Expr leExpr = newBVLEExpr(newBVConstExpr(i, bvsize), t[1]);\newline    	thms0.push_back(bitBlastIneqn(leExpr));\newline    	thms0.push_back(bitBlastTerm(t[0], bvsize-1));\newline    	thms.push_back(substitutivityRule(AND, thms0));\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVOR:\newline    case BVAND:\newline    case BVXOR:\newline    {\newline    	int kind = t.getOpKind();\newline    	int resKind = (kind == BVOR) ? OR :\newline        kind == BVAND ? AND : XOR;\newline    	Theorem thm = d_rules-&gtbitExtractBitwise(t, bitPosition, kind);\newline    	const Expr&amp phi = thm.getRHS();\newline    	DebugAssert(phi.getOpKind() == resKind &amp&amp phi.arity() == t.arity(), &quotTheoryBitvector::bitBlastTerm: recursion:\\n phi = &quot + phi.toString() + &quot\\n t = &quot + t.toString());\newline    	vector&ltTheorem&gt substThms;\newline    	for(Expr::iterator i=phi.begin(), iend=phi.end(); i!=iend; ++i) {\newline    		DebugAssert(i-&gtgetOpKind() == BOOLEXTRACT, &quotExpected BOOLEXTRACT&quot);\newline    		substThms.push_back(bitBlastTerm((*i)[0], getBoolExtractIndex(*i)));\newline    	}\newline    	result = transitivityRule(thm, substitutivityRule(resKind, substThms));\newline    	break;\newline    }\newline    case BVNEG:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractNot(t, bitPosition);\newline    	const Expr&amp extractTerm = thm.getRHS();\newline    	DebugAssert(NOT == extractTerm.getKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be NOT&quot);\newline    	const Expr&amp term0 = extractTerm[0];\newline    	DebugAssert(BOOLEXTRACT == term0.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion:(terms must be BOOL-EXTRACT&quot);\newline    	int bitPos0 = getBoolExtractIndex(term0);\newline    	std::vector&ltTheorem&gt res;\newline    	res.push_back(bitBlastTerm(term0[0], bitPos0));\newline    	result = transitivityRule(thm, substitutivityRule(NOT, res));\newline    	break;\newline    }\newline    case BVPLUS:\newline    {\newline		Theorem thm_binary;\newline		if(t.arity() &gt 2) thm_binary = d_rules-&gtbvPlusAssociativityRule(t);\newline		else thm_binary = reflexivityRule(t);\newline\newline		Expr bvPlusTerm = thm_binary.getRHS();\newline\newline    	// Get the bits of the right multiplicand\newline    	Expr b = bvPlusTerm[1];\newline    	vector&ltTheorem&gt b_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    	    b_bits[bit] = bitBlastTerm(b, bit);\newline\newline    	// The output of the bit-blasting\newline    	vector&ltTheorem&gt output_bits;\newline\newline  		// Get the bits of the left multiplicand\newline   		Expr a = bvPlusTerm[0];\newline   		vector&ltTheorem&gt a_bits(bitPosition + 1);\newline   		for (int bit = bitPosition; bit &gt= 0; -- bit)\newline   			a_bits[bit] = bitBlastTerm(a, bit);\newline\newline   		// Bit-blast them and get all the output bits (of this size)\newline   		d_rules-&gtbitblastBVPlus(a_bits, b_bits, bvPlusTerm, output_bits);\newline\newline    	// Simplify all the resulting bit expressions and add them to the bit-blasting cache\newline    	Theorem thm;\newline    	for (int bit = 0; bit &lt= bitPosition; bit ++)\newline    	{\newline    		thm = output_bits[bit];\newline\newline    		Expr original_boolextract = newBoolExtractExpr(t, bit);\newline    		Expr boolextract = thm.getLHS();\newline    		Expr bitblasted  = thm.getRHS();\newline\newline    		CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(boolextract);\newline    		if (it != d_bitvecCache.end())\newline    			continue;\newline\newline    		thm = d_bitvecCache[boolextract] = transitivityRule(thm, rewriteBoolean(thm.getRHS()));\newline    		if (boolextract != original_boolextract)\newline    			thm = d_bitvecCache[original_boolextract] = transitivityRule(substitutivityRule(original_boolextract, thm_binary), thm);\newline       	}\newline\newline    	// We are returning the last theorem\newline    	return thm;\newline\newline    	break;\newline    }\newline    case BVMULT: {\newline\newline    	Theorem thm;\newline\newline    	bool a_is_const = (BVCONST == t[0].getKind());\newline\newline    			// If a constant, rewrite using addition\newline    	if (a_is_const) {\newline    		thm = d_rules-&gtbitExtractConstBVMult(t, bitPosition);\newline    		const Expr&amp boolExtractTerm = thm.getRHS();\newline		    const Expr&amp term = boolExtractTerm[0];\newline    		result = transitivityRule(thm, bitBlastTerm(term, bitPosition));\newline    		break;\newline    	}\newline\newline    	// Get the bits ot the right multiplicant\newline    	Expr b = t[1];\newline    	vector&ltTheorem&gt b_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    	    b_bits[bit] = bitBlastTerm(b, bit);\newline\newline    	// The output of the bitblasting\newline    	vector&ltTheorem&gt output_bits;\newline\newline		// Get the bits of the left multiplicant\newline    	Expr a = t[0];\newline    	vector&ltTheorem&gt a_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    		a_bits[bit] = bitBlastTerm(a, bit);\newline\newline    	// Bitblast them and get all the output bits (of this size)\newline    	d_rules-&gtbitblastBVMult(a_bits, b_bits, t, output_bits);\newline\newline    	// Simplify all the resulting bit expressions and add them to the bitblasting cache\newline    	for (int bit = 0; bit &lt= bitPosition; bit ++)\newline    	{\newline    		thm = output_bits[bit];\newline\newline    		Expr boolextract = thm.getLHS();\newline    		Expr bitblasted  = thm.getRHS();\newline\newline    		CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(boolextract);\newline    		if (it != d_bitvecCache.end())\newline    			continue;\newline\newline    		thm = d_bitvecCache[boolextract] = transitivityRule(thm, rewriteBoolean(thm.getRHS()));\newline                // not allowed to use simplify in bitblasting\newline                //theoryCore()-&gtsimplify(thm.getRHS()));\newline    	}\newline\newline    	// We are returning the last theorem\newline    	return thm;\newline\newline    	break;\newline    }\newline//    case BVMULT: {\newline//\newline//    	Theorem thm;\newline//      if(BVCONST == t[0].getKind())\newline//    		thm = d_rules-&gtbitExtractConstBVMult(t, bitPosition);\newline//      else\newline//	thm = d_rules-&gtbitExtractBVMult(t, bitPosition);\newline//    		const Expr&amp boolExtractTerm = thm.getRHS();\newline//      const Expr&amp term = boolExtractTerm[0];\newline//      result = transitivityRule(thm, bitBlastTerm(term, bitPosition));\newline//    	break;\newline//    }\newline    default:\newline    {\newline    	FatalAssert(theoryOf(t.getOpKind()) != this, &quotUnexpected operator in bitBlastTerm:&quot + t.toString());\newline    	//we have bitvector variable. check if the expr is indeed a BITVECTOR.\newline    	IF_DEBUG(Type type = t.getType();)\newline    	DebugAssert(BITVECTOR == (type.getExpr()).getOpKind(), &quotBitvectorTheoremProducer::bitBlastTerm: the type must be BITVECTOR&quot);\newline    	//check if 0&lt= i &lt length of BITVECTOR\newline    	IF_DEBUG(int bvLength=BVSize(t);)\newline    	DebugAssert(0 &lt= bitPosition &amp&amp bitPosition &lt bvLength, &quotBitvectorTheoremProducer::bitBlastTerm: the bitextract position must be legal&quot);\newline    	TRACE(&quotbitvector&quot, &quotbitBlastTerm: blasting variables(&quot, t, &quot)&quot);\newline    	const Expr bitExtract = newBoolExtractExpr(t, bitPosition);\newline    	result = reflexivityRule(bitExtract);\newline    	TRACE(&quotbitvector&quot, &quotbitBlastTerm: blasting variables(&quot, t, &quot)&quot);\newline    	break;\newline    }\newline  }\newline  DebugAssert(!result.isNull(), &quotTheoryBitvector::bitBlastTerm()&quot);\newline  Theorem simpThm = rewriteBoolean(result.getRHS());\newline  // not allowed to use simplify in bitblasting\newline  // theoryCore()-&gtsimplify(result.getRHS());\newline  result = transitivityRule(result, simpThm);\newline  d_bitvecCache[t_i] = result;\newline  DebugAssert(t_i == result.getLHS(),\newline              &quotTheoryBitvector::bitBlastTerm: &quot\newline              &quotcreated wrong theorem.\\n result = &quot\newline              +result.toString()\newline              +&quot\\n t_i = &quot+t_i.toString());\newline  TRACE(&quotbitvector&quot, &quotbitBlastTerm =&gt &quot, result, &quot }&quot);\newline","! The invariant maintained by this function is: accepts a bitvector\newline term, t,and a bitPosition, i. returns a formula over the set of\newline propositional variables defined using BOOLEXTRACT of bitvector\newline variables in t at the position i.\newline \newline \\return Theorem(BOOLEXTRACT(t, bitPosition) &lt=&gt phi), where phi is\newline a Boolean formula over the individual bits of bit-vector variables.\newline \newline","2130884","api.c","GSM_Error GSM_ConferenceCall(GSM_StateMachine *s, int ID)\newline{\newline	GSM_Error err;\newline\newline	CHECK_PHONE_CONNECTION();\newline\newline	err = s-&gtPhone.Functions-&gtConferenceCall(s, ID);\newline	PRINT_LOG_ERROR(err);\newline	return err;\newline}\newline","\newline Initiates a conference call.\newline \newline","5020376","hardware.c","static int output_buffer_empty(struct hw_state *s)\newline{\newline	return s-&gtobuf_avail == s-&gtobuf_total;\newline}\newline","\newline @return True if output buffer is empty, else False.\newline \newline","5026298","v4l2_driver.c","int v4l2_setget_std (struct v4l2_driver *drv, enum v4l2_direction dir, v4l2_std_id *id)\newline{\newline	v4l2_std_id		s_id=*id;\newline	int			ret=0;\newline	char			s[256];\newline\newline	if (dir &amp V4L2_SET) {\newline		ret=xioctl(drv-&gtfd,VIDIOC_S_STD,&amps_id);\newline		if (ret&lt0) {\newline			ret=errno;\newline\newline			sprintf (s,&quotwhile trying to set STD to %08x&quot,\newline								(unsigned int) *id);\newline			perror(s);\newline		}\newline	}\newline\newline	if (dir &amp V4L2_GET) {\newline		ret=xioctl(drv-&gtfd,VIDIOC_G_STD,&amps_id);\newline		if (ret&lt0) {\newline			ret=errno;\newline			perror (&quotwhile trying to get STD id&quot);\newline		}\newline	}\newline\newline	if (dir == V4L2_SET_GET) {\newline		if (*id &amp s_id) {\newline			if (*id != s_id) {\newline				printf (&quotWarning: Received a std subset (%08x&quot\newline					&quot std) while trying to adjust to %08x\\n&quot,\newline					(unsigned int) s_id,(unsigned int) *id);\newline			}\newline		} else {\newline			fprintf (stderr,&quotError: Received %08x std while trying&quot\newline				&quot to adjust to %08x\\n&quot,\newline				(unsigned int) s_id,(unsigned int) *id);\newline		}\newline	}\newline	return ret;\newline}\newline","\newline Set routines - currently, it also checks results with Get\newline \newline","4068211","utility.c","char* stristr(const char* haystack, const char* needle)\newline{\newline	const char* needlepoint = needle;\newline	const char* matchpoint = NULL;\newline\newline	if (!haystack || !needle)	/* check for bad input */\newline		return NULL;\newline	else if (*needle == &#039\\0&#039)	/* strstr compliance */\newline		return (char*)haystack;\newline\newline	while (*haystack != &#039\\0&#039)\newline	{\newline		if (tolower(*needlepoint) == tolower(*haystack))\newline		{\newline			if (!matchpoint)\newline				matchpoint = haystack;\newline			needlepoint++;\newline			if (*needlepoint == &#039\\0&#039)\newline				return (char*)matchpoint;\newline		}\newline		else if (matchpoint)\newline		{	/* reset the search */\newline			needlepoint = needle;\newline			haystack = matchpoint; /* cure overlap problem */\newline			matchpoint = NULL;\newline		}\newline		haystack++;\newline	}\newline	return NULL;\newline}\newline","\newline Case-insensitive version of strstr\newline Searches for needle within haystack, returning pointer\newline to start of the matching characters in haystack.\newline \newline","1208467","img.c","static unsigned short *buffer_to_16(unsigned short *tmp, struct cached_image *cimg\newline	,unsigned char *buffer, int height)\newline{\newline	unsigned short red, green,blue;\newline\newline#ifdef DEBUG\newline	if (cimg-&gtstate!=12&amp&ampcimg-&gtstate!=14){\newline		fprintf(stderr,&quotcimg-&gtstate=%d\\n&quot,cimg-&gtstate);\newline		internal(&quotinvalid state in buffer_to_16&quot);\newline	}\newline#endif /* #ifdef DEBUG */\newline	switch (cimg-&gtbuffer_bytes_per_pixel){\newline		case 3:\newline			if (cimg-&gtgamma_table){\newline				agx_24_to_48_table(tmp, buffer,\newline					cimg-&gtwidth*height\newline					,cimg-&gtgamma_table);\newline			}\newline			else{\newline				agx_24_to_48(tmp,buffer,cimg-&gtwidth\newline					*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma));\newline			}\newline		break;\newline\newline		case 3*sizeof(unsigned short):\newline			if (cimg-&gtgamma_table){\newline				agx_48_to_48_table(tmp\newline					,(unsigned short *)buffer\newline					,cimg-&gtwidth*height, cimg-&gtgamma_table);\newline			}else{\newline				agx_48_to_48(tmp,(unsigned short *)buffer\newline					,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma));\newline			}\newline		break;\newline\newline		/* Alpha&#039s: */\newline		case 4:\newline		{\newline\newline			round_color_sRGB_to_48(&ampred,&ampgreen,&ampblue,cimg-&gtbackground_color);\newline			if (cimg-&gtgamma_table){\newline				agx_and_uc_32_to_48_table(\newline						tmp, buffer, cimg-&gtwidth *height,\newline						cimg-&gtgamma_table, red, green, blue);\newline			}else{\newline				agx_and_uc_32_to_48(tmp,buffer\newline					,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma)\newline					,red, green, blue);\newline			}\newline		}\newline		break;\newline\newline		case 4*sizeof(unsigned short):\newline		{\newline			round_color_sRGB_to_48(&ampred, &ampgreen, &ampblue,\newline				cimg-&gtbackground_color);\newline			if (cimg-&gtgamma_table){\newline				agx_and_uc_64_to_48_table\newline					(tmp, (unsigned short *)buffer, cimg-&gtwidth*height\newline					,cimg-&gtgamma_table, red, green, blue);\newline			}else{\newline				agx_and_uc_64_to_48(tmp\newline					,(unsigned short*)buffer,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma)\newline					,red,green,blue);\newline			}\newline		}\newline		break;\newline\newline#ifdef DEBUG\newline		default:\newline		internal(&quotbuffer_to_16: unknown mem organization&quot);\newline#endif /* #ifdef DEBUG */\newline\newline	}\newline	return tmp;\newline}\newline","Fills &quottmp&quot buffer with the resulting data and does not free the input\newline buffer. May be called only in states 12 and 14 of cimg\newline \newline","3371217","cdecl.c","void usage()\newline{\newline    (void) fprintf (stderr, &quotUsage: %s [-r|-p|-a|-+] [-ciq%s%s] [files...]\\n&quot,\newline	progname,\newline#ifdef dodebug\newline	&quotd&quot,\newline#else\newline	&quot&quot,\newline#endif /* dodebug */\newline#ifdef doyydebug\newline	&quotD&quot\newline#else\newline	&quot&quot\newline#endif /* doyydebug */\newline	);\newline    (void) fprintf (stderr, &quot\\t-r Check against Ritchie PDP C Compiler\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-p Check against Pre-ANSI C Compiler\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-a Check against ANSI C Compiler%s\\n&quot,\newline	CplusplusFlag ? &quot&quot : &quot (the default)&quot);\newline    (void) fprintf (stderr, &quot\\t-+ Check against C++ Compiler%s\\n&quot,\newline	CplusplusFlag ? &quot (the default)&quot : &quot&quot);\newline    (void) fprintf (stderr, &quot\\t-c Create compilable output (include ; and {})\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-i Force interactive mode\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-q Quiet prompt\\n&quot);\newline#ifdef dodebug\newline    (void) fprintf (stderr, &quot\\t-d Turn on debugging mode\\n&quot);\newline#endif /* dodebug */\newline#ifdef doyydebug\newline    (void) fprintf (stderr, &quot\\t-D Turn on YACC debugging mode\\n&quot);\newline#endif /* doyydebug */\newline    exit(1);\newline    /* NOTREACHED */\newline}\newline","Tell how to invoke cdecl. \newline","380102","mime.cpp","static int mime_global_wrp(lua_State *L)\newline{\newline    size_t size = 0;\newline    int left = (int) luaL_checknumber(L, 1);\newline    const UC *input = (UC *) luaL_optlstring(L, 2, NULL, &ampsize);\newline    const UC *last = input + size;\newline    int length = (int) luaL_optnumber(L, 3, 76);\newline    luaL_Buffer buffer;\newline    /* end of input black-hole */\newline    if (!input) {\newline        /* if last line has not been terminated, add a line break */\newline        if (left &lt length) lua_pushstring(L, CRLF);\newline        /* otherwise, we are done */\newline        else lua_pushnil(L);\newline        lua_pushnumber(L, length);\newline        return 2;\newline    } \newline    luaL_buffinit(L, &ampbuffer);\newline    while (input &lt last) {\newline        switch (*input) {\newline            case &#039\\r&#039:\newline                break;\newline            case &#039\\n&#039:\newline                luaL_addstring(&ampbuffer, CRLF);\newline                left = length;\newline                break;\newline            default:\newline                if (left &lt= 0) {\newline                    left = length;\newline                    luaL_addstring(&ampbuffer, CRLF);\newline                }\newline                luaL_putchar(&ampbuffer, *input);\newline                left--;\newline                break;\newline        }\newline        input++;\newline    }\newline    luaL_pushresult(&ampbuffer);\newline    lua_pushnumber(L, left);\newline    return 2;\newline}\newline","------------------------------------------------------------------------- \\\newline Incrementaly breaks a string into lines. The string can have CRLF breaks.\newline A, n = wrp(l, B, length)\newline A is a copy of B, broken into lines of at most &#039length&#039 bytes. \newline &#039l&#039 is how many bytes are left for the first line of B. \newline &#039n&#039 is the number of bytes left in the last line of A. \newline\\ ------------------------------------------------------------------------- \newline","2211892","xvtable.c","static void _xwin_draw_sprite_v_flip(BITMAP *dst, BITMAP *src, int dx, int dy)\newline{\newline   int dxbeg, dybeg, w, h;\newline\newline   if (_xwin_in_gfx_call) {\newline      _xwin_vtable.draw_sprite_v_flip(dst, src, dx, dy);\newline      return;\newline   }\newline\newline   CLIP_BOX(dst, dxbeg, dybeg, w, h, dx, dy, src-&gtw, src-&gth)\newline\newline   _xwin_in_gfx_call = 1;\newline   _xwin_vtable.draw_sprite_v_flip(dst, src, dx, dy);\newline   _xwin_in_gfx_call = 0;\newline   _xwin_update_video_bitmap(dst, dxbeg, dybeg, w, h);\newline}\newline","_xwin_draw_sprite_v_flip:\newline Wrapper for draw_sprite_v_flip.\newline \newline","3839031","tripplite_usb.c","static int control_outlet(int outlet_id, int state)\newline{\newline	char k_cmd[10], buf[10];\newline	int ret;\newline\newline	switch(tl_model) {\newline		case TRIPP_LITE_SMARTPRO:   /* tested */\newline		case TRIPP_LITE_SMART_0004: /* untested */\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotN%02X&quot, 5);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotK%d%d&quot, outlet_id, state &amp 1);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline\newline			if(ret != 8) {\newline				upslogx(LOG_ERR, &quotCould not set outlet %d to state %d, ret = %d&quot, outlet_id, state, ret);\newline				return 0;\newline			} else {\newline				return 1;\newline			}\newline			break;\newline		case TRIPP_LITE_SMART_3005:\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotN%c&quot, 5);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotK%c%c&quot, outlet_id, state &amp 1);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline\newline			if(ret != 8) {\newline				upslogx(LOG_ERR, &quotCould not set outlet %d to state %d, ret = %d&quot, outlet_id, state, ret);\newline				return 0;\newline			} else {\newline				return 1;\newline			}\newline			break;\newline		default:\newline			upslogx(LOG_ERR, &quotcontrol_outlet unimplemented for protocol %04x&quot, tl_model);\newline	}\newline	return 0;\newline}\newline","!@brief Turn an outlet on or off.\newline \newline @return 1 if the command worked, 0 if not.\newline \newline","","","","","","on","","","","","","on","on","","","on","on","","on","on","","","","","on","","","","","","","","","","","","","","","","","","Runs on new data received from device","beginning headers","Simple wrapper","a Boolean formula over the individual bits of bit-vector variables.","Initiates a conference call.","{}","Set routines","start of the matching characters in haystack.","called only in states 12 and 14 of cimg","Tell how to invoke cdecl.","breaks a string into lines.","{}","{}","Turn an outlet on or off.","convolve a volume with a input kernel","{}","{}","Initialize the buttons for the help window","{}","{}","Load an 1 plane XBM into"
"3D5G8J4N5A4OY02TPX2QV3JG0VVTVP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3WMINLGALB3P7FUDIIL5ZP1O7OLCAL","A3SYA8EDAEOOF7","Approved","Wed Apr 17 15:58:41 PDT 2019","Wed Apr 17 16:03:47 PDT 2019","Fri Apr 19 16:03:47 PDT 2019","2019-04-19 23:04:21 UTC","","","306","100% (17/17)","100% (17/17)","100% (17/17)","5992121","touchscreen.c","static void irq_touchscreen(struct urb *urb)\newline{\newline  /*\newline   * data raports...\newline   */\newline  struct tscrn_usb_data *tscrn = urb-&gtcontext;\newline  struct tscrn_usb_data_report *data = (struct tscrn_usb_data_report *)tscrn-&gtdata;\newline\newline  if (urb-&gtstatus) return;\newline\newline  //return when driver was clesed \newline  if(!tscrn-&gtisopen) return;\newline\newline  // increase loop counter\newline  // !!! Unfortunately the data was lost to seldom !!!\newline  //if((int)GET_LOOP(data) != tscrn-&gtnLoopCounter)\newline  //  warn(&quotwarn:Lost data new loop %d previous loop %d&quot,(int)GET_LOOP(data),(int)tscrn-&gtnLoopCounter);\newline\newline  input_report_key(&amptscrn-&gtinput_dev, BTN_LEFT, IS_TOUCHED(data));\newline  input_report_abs(&amptscrn-&gtinput_dev, ABS_X, GET_XC(data));\newline  input_report_abs(&amptscrn-&gtinput_dev, ABS_Y, GET_YC(data));\newline\newline  tscrn-&gtnLoopCounter = (GET_LOOP(data))+1; \newline\newline  // store data to buffer\newline  memcpy(tscrn-&gtpToWrite,data,TSCRN_USB_RAPORT_SIZE_DATA);\newline  // next data to next cell\newline  if(tscrn-&gtpToRead == NULL)\newline    tscrn-&gtpToRead = tscrn-&gtpToWrite;\newline\newline  tscrn-&gtpToWrite += TSCRN_USB_RAPORT_SIZE_DATA;\newline  if(tscrn-&gtpToWrite &gt= tscrn-&gtobuf+OBUF_SIZE)\newline    tscrn-&gtpToWrite = tscrn-&gtobuf;\newline\newline  if (waitqueue_active(&amptscrn-&gtwait))\newline    wake_up_interruptible(&amptscrn-&gtwait);\newline\newline  //dbg(&quotirq_touchscreen(): GET_Data 0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x status=%d&quot, (int)data[0],(int)data[1],(int)data[2],(int)data[3],(int)data[4],(int)data[5],(int)data[6],(int)data[7],(int)data[8],(int)data[9],(int)data[10], tscrn-&gtctrlout.status);\newline\newline  return;\newline}\newline","\newline Runs on new data received from device\newline The buffer should keep the last state of device, thus the buffer overflow\newline can occurre\newline The client can&#039t read data when pToRead == pToWrite\newline \newline","5983511","wrapper.c","int wrapperBuildUnixDaemonInfo() {\newline    if (!wrapperData-&gtconfigured) {\newline        /** Get the daemonize flag. */\newline        wrapperData-&gtdaemonize = getBooleanProperty(properties, TEXT(&quotwrapper.daemonize&quot), FALSE);\newline        /** Configure the HUP signal handler. */\newline        wrapperData-&gtsignalHUPMode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.hup&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline\newline        /** Configure the USR1 signal handler. */\newline        wrapperData-&gtsignalUSR1Mode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.usr1&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline\newline        /** Configure the USR2 signal handler. */\newline        wrapperData-&gtsignalUSR2Mode = getSignalMode(getStringProperty(properties, TEXT(&quotwrapper.signal.mode.usr2&quot), NULL), WRAPPER_SIGNAL_MODE_FORWARD);\newline    }\newline\newline    return FALSE;\newline}\newline","\newline Return FALSE if successful, TRUE if there were problems.\newline \newline","3923303","kernel_ops.c","VIO_Volume  convolve_kernel(Kernel * K, VIO_Volume vol)\newline{\newline   int      x, y, z, c;\newline   double   value;\newline   int      sizes[MAX_VAR_DIMS];\newline   VIO_progress_struct progress;\newline   VIO_Volume   tmp_vol;\newline\newline   if(verbose){\newline      fprintf(stdout, &quotConvolve kernel\\n&quot);\newline      }\newline   get_volume_sizes(vol, sizes);\newline   initialize_progress_report(&ampprogress, FALSE, sizes[2], &quotConvolve&quot);\newline\newline   /* copy the volume */\newline   tmp_vol = copy_volume(vol);\newline\newline   for(z = -K-&gtpre_pad[2]; z &lt sizes[0] - K-&gtpost_pad[2]; z++){\newline      for(y = -K-&gtpre_pad[1]; y &lt sizes[1] - K-&gtpost_pad[1]; y++){\newline         for(x = -K-&gtpre_pad[0]; x &lt sizes[2] - K-&gtpost_pad[0]; x++){\newline\newline            value = 0;\newline            for(c = 0; c &lt K-&gtnelems; c++){\newline               value += get_volume_real_value(tmp_vol,\newline                                              z + K-&gtK[c][2],\newline                                              y + K-&gtK[c][1],\newline                                              x + K-&gtK[c][0], 0 + K-&gtK[c][3],\newline                                              0 + K-&gtK[c][4]) * K-&gtK[c][5];\newline               }\newline            set_volume_real_value(vol, z, y, x, 0, 0, value);\newline            }\newline         }\newline\newline      update_progress_report(&ampprogress, z + 1);\newline      }\newline\newline   delete_volume(tmp_vol);\newline   terminate_progress_report(&ampprogress);\newline   return (vol);\newline   }\newline","convolve a volume with a input kernel \newline","4516843","basop32.c","Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)\newline{\newline    Word32 L_var_out;\newline    Word32 L_product;\newline\newline    L_product = L_mult (var1, var2);\newline#if (WMOPS)\newline    multiCounter[currCounter].L_mult--;\newline#endif\newline    L_var_out = L_add (L_var3, L_product);\newline#if (WMOPS)\newline    multiCounter[currCounter].L_add--;\newline    multiCounter[currCounter].L_mac++;\newline#endif\newline    return (L_var_out);\newline}\newline","___________________________________________________________________________\newline| |\newline| Function Name : L_mac |\newline| |\newline| Purpose : |\newline| |\newline| Multiply var1 by var2 and shift the result left by 1. Add the 32 bit |\newline| result to L_var3 with saturation, return a 32 bit result: |\newline| L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)). |\newline| |\newline| Complexity weight : 1 |\newline| |\newline| Inputs : |\newline| |\newline| L_var3 32 bit long signed integer (Word32) whose value falls in the |\newline| range : 0x8000 0000 &lt= L_var3 &lt= 0x7fff ffff. |\newline| |\newline| var1 |\newline| 16 bit short signed integer (Word16) whose value falls in the |\newline| range : 0xffff 8000 &lt= var1 &lt= 0x0000 7fff. |\newline| |\newline| var2 |\newline| 16 bit short signed integer (Word16) whose value falls in the |\newline| range : 0xffff 8000 &lt= var1 &lt= 0x0000 7fff. |\newline| |\newline| Outputs : |\newline| |\newline| none |\newline| |\newline| Return Value : |\newline| |\newline| L_var_out |\newline| 32 bit long signed integer (Word32) whose value falls in the |\newline| range : 0x8000 0000 &lt= L_var_out &lt= 0x7fff ffff. |\newline|___________________________________________________________________________|\newline \newline","2646691","datastore_sqlite.c","static void free_dbh(dbh_t *dbh) {\newline    if (!dbh)\newline	return;\newline    xfree(dbh-&gtname);\newline    xfree(dbh-&gtpath);\newline    xfree(dbh);\newline}\newline","Free internal database handle \\a dbh. \newline","6444633","gtkhelp.c","void initialize_buttons (GtkWidget *main_vbox, GtkWidget *content_hpane) {\newline        GtkWidget *buttons_hbuttonbox;\newline        GtkWidget *back_button;\newline        GtkWidget *forward_button;\newline        GtkWidget *home_button;\newline        GtkWidget *contents_button;\newline\newline        // define and attach signals to buttons\newline        back_button = gtk_button_new_with_label(_(&quotBack&quot));\newline        g_signal_connect(back_button, &quotclicked&quot, G_CALLBACK(back_button_clicked), G_OBJECT(main_view));\newline\newline        forward_button = gtk_button_new_with_label(_(&quotForward&quot));\newline        g_signal_connect(forward_button, &quotclicked&quot, G_CALLBACK(forward_button_clicked), G_OBJECT(main_view));\newline\newline        home_button = gtk_button_new_with_label(_(&quotHome&quot));\newline        g_signal_connect(home_button, &quotclicked&quot, G_CALLBACK(home_button_clicked), G_OBJECT(main_view));\newline\newline        contents_button = gtk_button_new_with_label(_(&quotContents&quot));\newline        g_signal_connect(contents_button, &quotclicked&quot, G_CALLBACK(contents_button_clicked), G_OBJECT(content_hpane));\newline\newline        // button layout\newline        buttons_hbuttonbox = gtk_hbutton_box_new();\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), back_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), forward_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), home_button);\newline        gtk_container_add(GTK_CONTAINER(buttons_hbuttonbox), contents_button);\newline        gtk_box_pack_start(GTK_BOX(main_vbox), buttons_hbuttonbox, FALSE, TRUE, 0);\newline        gtk_box_set_spacing(GTK_BOX(buttons_hbuttonbox), 6);\newline        gtk_button_box_set_layout(GTK_BUTTON_BOX(buttons_hbuttonbox), GTK_BUTTONBOX_START);\newline\newline	/* Store pointers to all widgets, for use by lookup_widget().  */\newline	GLADE_HOOKUP_OBJECT (main_view, back_button, BACKBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, forward_button, FORWARDBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, home_button, HOMEBUTTON);\newline	GLADE_HOOKUP_OBJECT (main_view, contents_button, CONTENTBUTTON);\newline}\newline","\newline Initialize the buttons for the help window\newline \newline","1321510","ppc_vec.c","void ppc_opc_vcmpbfpx()\newline{\newline	VECTOR_DEBUG;\newline	int vrD, vrA, vrB;\newline	int le, ge;\newline	int ib=CR_CR6_NE;\newline	PPC_OPC_TEMPL_X(gCPU.current_opc, vrD, vrA, vrB);\newline	int i;\newline	for (i=0; i&lt4; i++) { //FIXME: This might not comply with Java FP\newline		le = (gCPU.vr[vrA].f[i] &lt= gCPU.vr[vrB].f[i]) ? 0 : 0x80000000;\newline		ge = (gCPU.vr[vrA].f[i] &gt= -gCPU.vr[vrB].f[i]) ? 0 : 0x40000000;\newline\newline		gCPU.vr[vrD].w[i] = le | ge;\newline		if (le | ge) {\newline			ib = 0;\newline 		}\newline	}\newline\newline	if (PPC_OPC_VRc &amp gCPU.current_opc) {\newline		gCPU.cr &amp= ~CR_CR6;\newline		gCPU.cr |= ib;\newline	}\newline}\newline","vcmpbfpx Vector Compare Bounds Floating Point\newline v.157\newline \newline","206757","brlapi_keyranges.c","static void freeKeyrange(KeyrangeList **p, KeyrangeList *c)\newline{\newline  if (c==NULL) return;\newline  *p = c-&gtnext;\newline  free(c);\newline}\newline","Function : freeKeyrange \newline","5249493","sdlgui.c","static SDL_Surface *SDLGui_LoadXBM(int w, int h, const void *pXbmBits)\newline{\newline	SDL_Surface *bitmap;\newline	Uint8 *dstbits;\newline	const Uint8 *srcbits;\newline	int x, y, srcpitch;\newline	int mask;\newline\newline	srcbits = pXbmBits;\newline\newline	/* Allocate the bitmap */\newline	bitmap = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 8, 0, 0, 0, 0);\newline	if (bitmap == NULL)\newline	{\newline		fprintf(stderr, &quotFailed to allocate bitmap: %s&quot, SDL_GetError());\newline		return NULL;\newline	}\newline\newline	srcpitch = ((w + 7) / 8);\newline	dstbits = (Uint8 *)bitmap-&gtpixels;\newline	mask = 1;\newline\newline	/* Copy the pixels */\newline	for (y = 0 ; y &lt h ; y++)\newline	{\newline		for (x = 0 ; x &lt w ; x++)\newline		{\newline			dstbits[x] = (srcbits[x / 8] &amp mask) ? 1 : 0;\newline			mask &lt&lt= 1;\newline			mask |= (mask &gt&gt 8);\newline			mask &amp= 0xFF;\newline		}\newline		dstbits += bitmap-&gtpitch;\newline		srcbits += srcpitch;\newline	}\newline\newline	return bitmap;\newline}\newline","\newline Load an 1 plane XBM into a 8 planes SDL_Surface.\newline \newline","1999811","modp_b85_gen.c","static void printStart(void)\newline{\newline    printf(&quot/* do not edit -- autogenerated from b85gen */\\n&quot);\newline}\newline","\newline beginning headers\newline \newline","5964543","im.c","faim_export int aim_im_sendch1(aim_session_t *sess, const char *sn, fu16_t flags, const char *msg)\newline{\newline	struct aim_sendimext_args args;\newline\newline	args.destsn = sn;\newline	args.flags = flags;\newline	args.msg = msg;\newline	args.msglen = strlen(msg);\newline	args.charset = 0x0000;\newline	args.charsubset = 0x0000;\newline\newline	/* Make these don&#039t get set by accident -- they need aim_im_sendch1_ext */\newline	args.flags &amp= ~(AIM_IMFLAGS_CUSTOMFEATURES | AIM_IMFLAGS_HASICON | AIM_IMFLAGS_MULTIPART);\newline\newline	return aim_im_sendch1_ext(sess, &ampargs);\newline}\newline","\newline Simple wrapper for aim_im_sendch1_ext() \newline \newline You cannot use aim_send_im if you need the HASICON flag. You must\newline use aim_im_sendch1_ext directly for that.\newline \newline aim_send_im also cannot be used if you require UNICODE messages, because\newline that requires an explicit message length. Use aim_im_sendch1_ext().\newline \newline \newline","1395666","theory_bitvector.cpp","Theorem TheoryBitvector::bitBlastTerm(const Expr&amp t, int bitPosition)\newline{\newline  TRACE(&quotbitvector&quot, &quotbitBlastTerm(&quot, t, &quot, &quot + int2string(bitPosition) + &quot) {&quot);\newline\newline  IF_DEBUG(Type type = t.getType();)\newline  DebugAssert(BITVECTOR == type.getExpr().getOpKind(), &quotTheoryBitvector::bitBlastTerm: The type of input to bitBlastTerm must be BITVECTOR.\\n t = &quot +t.toString());\newline  DebugAssert(bitPosition &gt= 0, &quotTheoryBitvector::bitBlastTerm: illegal bitExtraction attempted.\\n bitPosition = &quot + int2string(bitPosition));\newline\newline  Theorem result;\newline\newline  // Check the cache\newline  Expr t_i = newBoolExtractExpr(t, bitPosition);\newline  CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(t_i);\newline  if (it != d_bitvecCache.end()) {\newline	  result = (*it).second;\newline	  TRACE(&quotbitvector&quot, &quotbitBlastTerm[cached] =&gt &quot, result, &quot }&quot);\newline	  DebugAssert(t_i == result.getLHS(),	&quotTheoryBitvector::bitBlastTerm: created wrong theorem&quot + result.toString() + t_i.toString());\newline	  return result;\newline  }\newline\newline  // Construct the theorem t[bitPosition] &lt=&gt \\theta_i and put it into\newline  // d_bitvecCache\newline  switch(t.getOpKind()) {\newline    case BVCONST:\newline    	result = d_rules-&gtbitExtractConstant(t, bitPosition);\newline    	break;\newline    case CONCAT:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractConcatenation(t, bitPosition);\newline    	const Expr&amp boolExtractTerm = thm.getRHS();\newline    	DebugAssert(BOOLEXTRACT == boolExtractTerm.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be bool_extract&quot);\newline    	const Expr&amp term = boolExtractTerm[0];\newline    	int bitPos = getBoolExtractIndex(boolExtractTerm);\newline    	TRACE(&quotbitvector&quot, &quotterm for bitblastTerm recursion:(&quot, term.toString(), &quot)&quot);\newline    	result = transitivityRule(thm, bitBlastTerm(term, bitPos));\newline    	break;\newline    }\newline    case EXTRACT:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractExtraction(t, bitPosition);\newline    	const Expr&amp boolExtractTerm = thm.getRHS();\newline    	DebugAssert(BOOLEXTRACT == boolExtractTerm.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be bool_extract&quot);\newline    	const Expr&amp term = boolExtractTerm[0];\newline    	int bitPos = getBoolExtractIndex(boolExtractTerm);\newline    	TRACE(&quotbitvector&quot, &quotterm for bitblastTerm recursion:(&quot, term, &quot)&quot);\newline    	result = transitivityRule(thm, bitBlastTerm(term, bitPos));\newline    	break;\newline    }\newline    case CONST_WIDTH_LEFTSHIFT:\newline    {\newline    	result = d_rules-&gtbitExtractFixedLeftShift(t, bitPosition);\newline    	const Expr&amp extractTerm = result.getRHS();\newline    	if(BOOLEXTRACT == extractTerm.getOpKind())\newline    		result = transitivityRule(result, bitBlastTerm(extractTerm[0], getBoolExtractIndex(extractTerm)));\newline    	break;\newline    }\newline    case BVSHL:\newline    {\newline    	// BOOLEXTRACT(bvshl(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                               ((x = 1) AND BOOLEXTRACT(t,i-1)) OR ...\newline    	//                               ((x = i) AND BOOLEXTRACT(t,0))\newline    	Theorem thm = d_rules-&gtbitExtractBVSHL(t, bitPosition);\newline    	// bitblast the equations and extractions\newline      	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline      	for (int i = 0; i &lt= bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition-i));\newline        	thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVLSHR:\newline    {\newline    	// BOOLEXTRACT(bvlshr(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                                ((x = 1) AND BOOLEXTRACT(t,i+1)) OR ...\newline    	//                                ((x = n-1-i) AND BOOLEXTRACT(t,n-1))\newline    	Theorem thm = d_rules-&gtbitExtractBVLSHR(t, bitPosition);\newline    	// bitblast the equations and extractions\newline    	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline    	for (int i = 0; i &lt= bvsize-1-bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition+i));\newline    		thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVASHR:\newline    {\newline    	// BOOLEXTRACT(bvlshr(t,x),i) &lt=&gt ((x = 0) AND BOOLEXTRACT(t,i)) OR\newline    	//                                ((x = 1) AND BOOLEXTRACT(t,i+1)) OR ...\newline    	//                                ((x &gt= n-1-i) AND BOOLEXTRACT(t,n-1))\newline    	Theorem thm = d_rules-&gtbitExtractBVASHR(t, bitPosition);\newline    	// bitblast the equations and extractions\newline    	vector&ltTheorem&gt thms, thms0;\newline    	int bvsize = BVSize(t);\newline    	int i = 0;\newline    	for (; i &lt bvsize-1-bitPosition; ++i) {\newline    		thms0.push_back(bitBlastEqn(t[1].eqExpr(newBVConstExpr(i, bvsize))));\newline    		thms0.push_back(bitBlastTerm(t[0], bitPosition+i));\newline    		thms.push_back(substitutivityRule(AND, thms0));\newline    		thms0.clear();\newline    	}\newline    	Expr leExpr = newBVLEExpr(newBVConstExpr(i, bvsize), t[1]);\newline    	thms0.push_back(bitBlastIneqn(leExpr));\newline    	thms0.push_back(bitBlastTerm(t[0], bvsize-1));\newline    	thms.push_back(substitutivityRule(AND, thms0));\newline    	// Put it all together\newline    	if (thms.size() == 1) {\newline    		result = transitivityRule(thm, thms[0]);\newline    	}\newline    	else {\newline    		Theorem thm2 = substitutivityRule(OR, thms);\newline    		result = transitivityRule(thm, thm2);\newline    	}\newline    	break;\newline    }\newline    case BVOR:\newline    case BVAND:\newline    case BVXOR:\newline    {\newline    	int kind = t.getOpKind();\newline    	int resKind = (kind == BVOR) ? OR :\newline        kind == BVAND ? AND : XOR;\newline    	Theorem thm = d_rules-&gtbitExtractBitwise(t, bitPosition, kind);\newline    	const Expr&amp phi = thm.getRHS();\newline    	DebugAssert(phi.getOpKind() == resKind &amp&amp phi.arity() == t.arity(), &quotTheoryBitvector::bitBlastTerm: recursion:\\n phi = &quot + phi.toString() + &quot\\n t = &quot + t.toString());\newline    	vector&ltTheorem&gt substThms;\newline    	for(Expr::iterator i=phi.begin(), iend=phi.end(); i!=iend; ++i) {\newline    		DebugAssert(i-&gtgetOpKind() == BOOLEXTRACT, &quotExpected BOOLEXTRACT&quot);\newline    		substThms.push_back(bitBlastTerm((*i)[0], getBoolExtractIndex(*i)));\newline    	}\newline    	result = transitivityRule(thm, substitutivityRule(resKind, substThms));\newline    	break;\newline    }\newline    case BVNEG:\newline    {\newline    	Theorem thm = d_rules-&gtbitExtractNot(t, bitPosition);\newline    	const Expr&amp extractTerm = thm.getRHS();\newline    	DebugAssert(NOT == extractTerm.getKind(), &quotTheoryBitvector::bitBlastTerm: recursion: term must be NOT&quot);\newline    	const Expr&amp term0 = extractTerm[0];\newline    	DebugAssert(BOOLEXTRACT == term0.getOpKind(), &quotTheoryBitvector::bitBlastTerm: recursion:(terms must be BOOL-EXTRACT&quot);\newline    	int bitPos0 = getBoolExtractIndex(term0);\newline    	std::vector&ltTheorem&gt res;\newline    	res.push_back(bitBlastTerm(term0[0], bitPos0));\newline    	result = transitivityRule(thm, substitutivityRule(NOT, res));\newline    	break;\newline    }\newline    case BVPLUS:\newline    {\newline		Theorem thm_binary;\newline		if(t.arity() &gt 2) thm_binary = d_rules-&gtbvPlusAssociativityRule(t);\newline		else thm_binary = reflexivityRule(t);\newline\newline		Expr bvPlusTerm = thm_binary.getRHS();\newline\newline    	// Get the bits of the right multiplicand\newline    	Expr b = bvPlusTerm[1];\newline    	vector&ltTheorem&gt b_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    	    b_bits[bit] = bitBlastTerm(b, bit);\newline\newline    	// The output of the bit-blasting\newline    	vector&ltTheorem&gt output_bits;\newline\newline  		// Get the bits of the left multiplicand\newline   		Expr a = bvPlusTerm[0];\newline   		vector&ltTheorem&gt a_bits(bitPosition + 1);\newline   		for (int bit = bitPosition; bit &gt= 0; -- bit)\newline   			a_bits[bit] = bitBlastTerm(a, bit);\newline\newline   		// Bit-blast them and get all the output bits (of this size)\newline   		d_rules-&gtbitblastBVPlus(a_bits, b_bits, bvPlusTerm, output_bits);\newline\newline    	// Simplify all the resulting bit expressions and add them to the bit-blasting cache\newline    	Theorem thm;\newline    	for (int bit = 0; bit &lt= bitPosition; bit ++)\newline    	{\newline    		thm = output_bits[bit];\newline\newline    		Expr original_boolextract = newBoolExtractExpr(t, bit);\newline    		Expr boolextract = thm.getLHS();\newline    		Expr bitblasted  = thm.getRHS();\newline\newline    		CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(boolextract);\newline    		if (it != d_bitvecCache.end())\newline    			continue;\newline\newline    		thm = d_bitvecCache[boolextract] = transitivityRule(thm, rewriteBoolean(thm.getRHS()));\newline    		if (boolextract != original_boolextract)\newline    			thm = d_bitvecCache[original_boolextract] = transitivityRule(substitutivityRule(original_boolextract, thm_binary), thm);\newline       	}\newline\newline    	// We are returning the last theorem\newline    	return thm;\newline\newline    	break;\newline    }\newline    case BVMULT: {\newline\newline    	Theorem thm;\newline\newline    	bool a_is_const = (BVCONST == t[0].getKind());\newline\newline    			// If a constant, rewrite using addition\newline    	if (a_is_const) {\newline    		thm = d_rules-&gtbitExtractConstBVMult(t, bitPosition);\newline    		const Expr&amp boolExtractTerm = thm.getRHS();\newline		    const Expr&amp term = boolExtractTerm[0];\newline    		result = transitivityRule(thm, bitBlastTerm(term, bitPosition));\newline    		break;\newline    	}\newline\newline    	// Get the bits ot the right multiplicant\newline    	Expr b = t[1];\newline    	vector&ltTheorem&gt b_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    	    b_bits[bit] = bitBlastTerm(b, bit);\newline\newline    	// The output of the bitblasting\newline    	vector&ltTheorem&gt output_bits;\newline\newline		// Get the bits of the left multiplicant\newline    	Expr a = t[0];\newline    	vector&ltTheorem&gt a_bits(bitPosition + 1);\newline    	for (int bit = bitPosition; bit &gt= 0; -- bit)\newline    		a_bits[bit] = bitBlastTerm(a, bit);\newline\newline    	// Bitblast them and get all the output bits (of this size)\newline    	d_rules-&gtbitblastBVMult(a_bits, b_bits, t, output_bits);\newline\newline    	// Simplify all the resulting bit expressions and add them to the bitblasting cache\newline    	for (int bit = 0; bit &lt= bitPosition; bit ++)\newline    	{\newline    		thm = output_bits[bit];\newline\newline    		Expr boolextract = thm.getLHS();\newline    		Expr bitblasted  = thm.getRHS();\newline\newline    		CDMap&ltExpr,Theorem&gt::iterator it = d_bitvecCache.find(boolextract);\newline    		if (it != d_bitvecCache.end())\newline    			continue;\newline\newline    		thm = d_bitvecCache[boolextract] = transitivityRule(thm, rewriteBoolean(thm.getRHS()));\newline                // not allowed to use simplify in bitblasting\newline                //theoryCore()-&gtsimplify(thm.getRHS()));\newline    	}\newline\newline    	// We are returning the last theorem\newline    	return thm;\newline\newline    	break;\newline    }\newline//    case BVMULT: {\newline//\newline//    	Theorem thm;\newline//      if(BVCONST == t[0].getKind())\newline//    		thm = d_rules-&gtbitExtractConstBVMult(t, bitPosition);\newline//      else\newline//	thm = d_rules-&gtbitExtractBVMult(t, bitPosition);\newline//    		const Expr&amp boolExtractTerm = thm.getRHS();\newline//      const Expr&amp term = boolExtractTerm[0];\newline//      result = transitivityRule(thm, bitBlastTerm(term, bitPosition));\newline//    	break;\newline//    }\newline    default:\newline    {\newline    	FatalAssert(theoryOf(t.getOpKind()) != this, &quotUnexpected operator in bitBlastTerm:&quot + t.toString());\newline    	//we have bitvector variable. check if the expr is indeed a BITVECTOR.\newline    	IF_DEBUG(Type type = t.getType();)\newline    	DebugAssert(BITVECTOR == (type.getExpr()).getOpKind(), &quotBitvectorTheoremProducer::bitBlastTerm: the type must be BITVECTOR&quot);\newline    	//check if 0&lt= i &lt length of BITVECTOR\newline    	IF_DEBUG(int bvLength=BVSize(t);)\newline    	DebugAssert(0 &lt= bitPosition &amp&amp bitPosition &lt bvLength, &quotBitvectorTheoremProducer::bitBlastTerm: the bitextract position must be legal&quot);\newline    	TRACE(&quotbitvector&quot, &quotbitBlastTerm: blasting variables(&quot, t, &quot)&quot);\newline    	const Expr bitExtract = newBoolExtractExpr(t, bitPosition);\newline    	result = reflexivityRule(bitExtract);\newline    	TRACE(&quotbitvector&quot, &quotbitBlastTerm: blasting variables(&quot, t, &quot)&quot);\newline    	break;\newline    }\newline  }\newline  DebugAssert(!result.isNull(), &quotTheoryBitvector::bitBlastTerm()&quot);\newline  Theorem simpThm = rewriteBoolean(result.getRHS());\newline  // not allowed to use simplify in bitblasting\newline  // theoryCore()-&gtsimplify(result.getRHS());\newline  result = transitivityRule(result, simpThm);\newline  d_bitvecCache[t_i] = result;\newline  DebugAssert(t_i == result.getLHS(),\newline              &quotTheoryBitvector::bitBlastTerm: &quot\newline              &quotcreated wrong theorem.\\n result = &quot\newline              +result.toString()\newline              +&quot\\n t_i = &quot+t_i.toString());\newline  TRACE(&quotbitvector&quot, &quotbitBlastTerm =&gt &quot, result, &quot }&quot);\newline","! The invariant maintained by this function is: accepts a bitvector\newline term, t,and a bitPosition, i. returns a formula over the set of\newline propositional variables defined using BOOLEXTRACT of bitvector\newline variables in t at the position i.\newline \newline \\return Theorem(BOOLEXTRACT(t, bitPosition) &lt=&gt phi), where phi is\newline a Boolean formula over the individual bits of bit-vector variables.\newline \newline","2130884","api.c","GSM_Error GSM_ConferenceCall(GSM_StateMachine *s, int ID)\newline{\newline	GSM_Error err;\newline\newline	CHECK_PHONE_CONNECTION();\newline\newline	err = s-&gtPhone.Functions-&gtConferenceCall(s, ID);\newline	PRINT_LOG_ERROR(err);\newline	return err;\newline}\newline","\newline Initiates a conference call.\newline \newline","5020376","hardware.c","static int output_buffer_empty(struct hw_state *s)\newline{\newline	return s-&gtobuf_avail == s-&gtobuf_total;\newline}\newline","\newline @return True if output buffer is empty, else False.\newline \newline","5026298","v4l2_driver.c","int v4l2_setget_std (struct v4l2_driver *drv, enum v4l2_direction dir, v4l2_std_id *id)\newline{\newline	v4l2_std_id		s_id=*id;\newline	int			ret=0;\newline	char			s[256];\newline\newline	if (dir &amp V4L2_SET) {\newline		ret=xioctl(drv-&gtfd,VIDIOC_S_STD,&amps_id);\newline		if (ret&lt0) {\newline			ret=errno;\newline\newline			sprintf (s,&quotwhile trying to set STD to %08x&quot,\newline								(unsigned int) *id);\newline			perror(s);\newline		}\newline	}\newline\newline	if (dir &amp V4L2_GET) {\newline		ret=xioctl(drv-&gtfd,VIDIOC_G_STD,&amps_id);\newline		if (ret&lt0) {\newline			ret=errno;\newline			perror (&quotwhile trying to get STD id&quot);\newline		}\newline	}\newline\newline	if (dir == V4L2_SET_GET) {\newline		if (*id &amp s_id) {\newline			if (*id != s_id) {\newline				printf (&quotWarning: Received a std subset (%08x&quot\newline					&quot std) while trying to adjust to %08x\\n&quot,\newline					(unsigned int) s_id,(unsigned int) *id);\newline			}\newline		} else {\newline			fprintf (stderr,&quotError: Received %08x std while trying&quot\newline				&quot to adjust to %08x\\n&quot,\newline				(unsigned int) s_id,(unsigned int) *id);\newline		}\newline	}\newline	return ret;\newline}\newline","\newline Set routines - currently, it also checks results with Get\newline \newline","4068211","utility.c","char* stristr(const char* haystack, const char* needle)\newline{\newline	const char* needlepoint = needle;\newline	const char* matchpoint = NULL;\newline\newline	if (!haystack || !needle)	/* check for bad input */\newline		return NULL;\newline	else if (*needle == &#039\\0&#039)	/* strstr compliance */\newline		return (char*)haystack;\newline\newline	while (*haystack != &#039\\0&#039)\newline	{\newline		if (tolower(*needlepoint) == tolower(*haystack))\newline		{\newline			if (!matchpoint)\newline				matchpoint = haystack;\newline			needlepoint++;\newline			if (*needlepoint == &#039\\0&#039)\newline				return (char*)matchpoint;\newline		}\newline		else if (matchpoint)\newline		{	/* reset the search */\newline			needlepoint = needle;\newline			haystack = matchpoint; /* cure overlap problem */\newline			matchpoint = NULL;\newline		}\newline		haystack++;\newline	}\newline	return NULL;\newline}\newline","\newline Case-insensitive version of strstr\newline Searches for needle within haystack, returning pointer\newline to start of the matching characters in haystack.\newline \newline","1208467","img.c","static unsigned short *buffer_to_16(unsigned short *tmp, struct cached_image *cimg\newline	,unsigned char *buffer, int height)\newline{\newline	unsigned short red, green,blue;\newline\newline#ifdef DEBUG\newline	if (cimg-&gtstate!=12&amp&ampcimg-&gtstate!=14){\newline		fprintf(stderr,&quotcimg-&gtstate=%d\\n&quot,cimg-&gtstate);\newline		internal(&quotinvalid state in buffer_to_16&quot);\newline	}\newline#endif /* #ifdef DEBUG */\newline	switch (cimg-&gtbuffer_bytes_per_pixel){\newline		case 3:\newline			if (cimg-&gtgamma_table){\newline				agx_24_to_48_table(tmp, buffer,\newline					cimg-&gtwidth*height\newline					,cimg-&gtgamma_table);\newline			}\newline			else{\newline				agx_24_to_48(tmp,buffer,cimg-&gtwidth\newline					*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma));\newline			}\newline		break;\newline\newline		case 3*sizeof(unsigned short):\newline			if (cimg-&gtgamma_table){\newline				agx_48_to_48_table(tmp\newline					,(unsigned short *)buffer\newline					,cimg-&gtwidth*height, cimg-&gtgamma_table);\newline			}else{\newline				agx_48_to_48(tmp,(unsigned short *)buffer\newline					,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma));\newline			}\newline		break;\newline\newline		/* Alpha&#039s: */\newline		case 4:\newline		{\newline\newline			round_color_sRGB_to_48(&ampred,&ampgreen,&ampblue,cimg-&gtbackground_color);\newline			if (cimg-&gtgamma_table){\newline				agx_and_uc_32_to_48_table(\newline						tmp, buffer, cimg-&gtwidth *height,\newline						cimg-&gtgamma_table, red, green, blue);\newline			}else{\newline				agx_and_uc_32_to_48(tmp,buffer\newline					,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma)\newline					,red, green, blue);\newline			}\newline		}\newline		break;\newline\newline		case 4*sizeof(unsigned short):\newline		{\newline			round_color_sRGB_to_48(&ampred, &ampgreen, &ampblue,\newline				cimg-&gtbackground_color);\newline			if (cimg-&gtgamma_table){\newline				agx_and_uc_64_to_48_table\newline					(tmp, (unsigned short *)buffer, cimg-&gtwidth*height\newline					,cimg-&gtgamma_table, red, green, blue);\newline			}else{\newline				agx_and_uc_64_to_48(tmp\newline					,(unsigned short*)buffer,cimg-&gtwidth*height\newline					,(float)((float)user_gamma/cimg-&gtred_gamma)\newline					,(float)((float)user_gamma/cimg-&gtgreen_gamma)\newline					,(float)((float)user_gamma/cimg-&gtblue_gamma)\newline					,red,green,blue);\newline			}\newline		}\newline		break;\newline\newline#ifdef DEBUG\newline		default:\newline		internal(&quotbuffer_to_16: unknown mem organization&quot);\newline#endif /* #ifdef DEBUG */\newline\newline	}\newline	return tmp;\newline}\newline","Fills &quottmp&quot buffer with the resulting data and does not free the input\newline buffer. May be called only in states 12 and 14 of cimg\newline \newline","3371217","cdecl.c","void usage()\newline{\newline    (void) fprintf (stderr, &quotUsage: %s [-r|-p|-a|-+] [-ciq%s%s] [files...]\\n&quot,\newline	progname,\newline#ifdef dodebug\newline	&quotd&quot,\newline#else\newline	&quot&quot,\newline#endif /* dodebug */\newline#ifdef doyydebug\newline	&quotD&quot\newline#else\newline	&quot&quot\newline#endif /* doyydebug */\newline	);\newline    (void) fprintf (stderr, &quot\\t-r Check against Ritchie PDP C Compiler\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-p Check against Pre-ANSI C Compiler\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-a Check against ANSI C Compiler%s\\n&quot,\newline	CplusplusFlag ? &quot&quot : &quot (the default)&quot);\newline    (void) fprintf (stderr, &quot\\t-+ Check against C++ Compiler%s\\n&quot,\newline	CplusplusFlag ? &quot (the default)&quot : &quot&quot);\newline    (void) fprintf (stderr, &quot\\t-c Create compilable output (include ; and {})\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-i Force interactive mode\\n&quot);\newline    (void) fprintf (stderr, &quot\\t-q Quiet prompt\\n&quot);\newline#ifdef dodebug\newline    (void) fprintf (stderr, &quot\\t-d Turn on debugging mode\\n&quot);\newline#endif /* dodebug */\newline#ifdef doyydebug\newline    (void) fprintf (stderr, &quot\\t-D Turn on YACC debugging mode\\n&quot);\newline#endif /* doyydebug */\newline    exit(1);\newline    /* NOTREACHED */\newline}\newline","Tell how to invoke cdecl. \newline","380102","mime.cpp","static int mime_global_wrp(lua_State *L)\newline{\newline    size_t size = 0;\newline    int left = (int) luaL_checknumber(L, 1);\newline    const UC *input = (UC *) luaL_optlstring(L, 2, NULL, &ampsize);\newline    const UC *last = input + size;\newline    int length = (int) luaL_optnumber(L, 3, 76);\newline    luaL_Buffer buffer;\newline    /* end of input black-hole */\newline    if (!input) {\newline        /* if last line has not been terminated, add a line break */\newline        if (left &lt length) lua_pushstring(L, CRLF);\newline        /* otherwise, we are done */\newline        else lua_pushnil(L);\newline        lua_pushnumber(L, length);\newline        return 2;\newline    } \newline    luaL_buffinit(L, &ampbuffer);\newline    while (input &lt last) {\newline        switch (*input) {\newline            case &#039\\r&#039:\newline                break;\newline            case &#039\\n&#039:\newline                luaL_addstring(&ampbuffer, CRLF);\newline                left = length;\newline                break;\newline            default:\newline                if (left &lt= 0) {\newline                    left = length;\newline                    luaL_addstring(&ampbuffer, CRLF);\newline                }\newline                luaL_putchar(&ampbuffer, *input);\newline                left--;\newline                break;\newline        }\newline        input++;\newline    }\newline    luaL_pushresult(&ampbuffer);\newline    lua_pushnumber(L, left);\newline    return 2;\newline}\newline","------------------------------------------------------------------------- \\\newline Incrementaly breaks a string into lines. The string can have CRLF breaks.\newline A, n = wrp(l, B, length)\newline A is a copy of B, broken into lines of at most &#039length&#039 bytes. \newline &#039l&#039 is how many bytes are left for the first line of B. \newline &#039n&#039 is the number of bytes left in the last line of A. \newline\\ ------------------------------------------------------------------------- \newline","2211892","xvtable.c","static void _xwin_draw_sprite_v_flip(BITMAP *dst, BITMAP *src, int dx, int dy)\newline{\newline   int dxbeg, dybeg, w, h;\newline\newline   if (_xwin_in_gfx_call) {\newline      _xwin_vtable.draw_sprite_v_flip(dst, src, dx, dy);\newline      return;\newline   }\newline\newline   CLIP_BOX(dst, dxbeg, dybeg, w, h, dx, dy, src-&gtw, src-&gth)\newline\newline   _xwin_in_gfx_call = 1;\newline   _xwin_vtable.draw_sprite_v_flip(dst, src, dx, dy);\newline   _xwin_in_gfx_call = 0;\newline   _xwin_update_video_bitmap(dst, dxbeg, dybeg, w, h);\newline}\newline","_xwin_draw_sprite_v_flip:\newline Wrapper for draw_sprite_v_flip.\newline \newline","3839031","tripplite_usb.c","static int control_outlet(int outlet_id, int state)\newline{\newline	char k_cmd[10], buf[10];\newline	int ret;\newline\newline	switch(tl_model) {\newline		case TRIPP_LITE_SMARTPRO:   /* tested */\newline		case TRIPP_LITE_SMART_0004: /* untested */\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotN%02X&quot, 5);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotK%d%d&quot, outlet_id, state &amp 1);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline\newline			if(ret != 8) {\newline				upslogx(LOG_ERR, &quotCould not set outlet %d to state %d, ret = %d&quot, outlet_id, state, ret);\newline				return 0;\newline			} else {\newline				return 1;\newline			}\newline			break;\newline		case TRIPP_LITE_SMART_3005:\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotN%c&quot, 5);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline			snprintf(k_cmd, sizeof(k_cmd)-1, &quotK%c%c&quot, outlet_id, state &amp 1);\newline			ret = send_cmd((unsigned char *)k_cmd, strlen(k_cmd) + 1, (unsigned char *)buf, sizeof buf);\newline\newline			if(ret != 8) {\newline				upslogx(LOG_ERR, &quotCould not set outlet %d to state %d, ret = %d&quot, outlet_id, state, ret);\newline				return 0;\newline			} else {\newline				return 1;\newline			}\newline			break;\newline		default:\newline			upslogx(LOG_ERR, &quotcontrol_outlet unimplemented for protocol %04x&quot, tl_model);\newline	}\newline	return 0;\newline}\newline","!@brief Turn an outlet on or off.\newline \newline @return 1 if the command worked, 0 if not.\newline \newline","","on","","","","on","","","","","","on","on","","","","on","","","on","","","","","on","","","on","","on","","","","","","","on","","","","","","read data","{}","use aim_send_im","accepts a bitvector term,","Initiates a conference call.","{}","Set routines","Searches for needle within haystack,","Fills ""tmp"" buffer","invoke cdecl.","Incrementaly breaks a string into lines.","{}","{}","Turn an outlet on or off.","convolve a volume","Multiply var1 by var2 and shift the result left by 1.","{}","Initialize the buttons for the help window","Compare Bounds","{}","Load an 1 plane XBM into a 8 planes"
"3DGDV62G7O9H9HBKK69VOOL8EUHP28","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","352YTHGROVD1MYPCV9PFXDC4S7Q4H9","A21C3WNJNCEA58","Approved","Wed Apr 17 17:53:48 PDT 2019","Wed Apr 17 18:34:24 PDT 2019","Fri Apr 19 18:34:24 PDT 2019","2019-04-20 01:35:21 UTC","","","2436","100% (1/1)","100% (1/1)","100% (1/1)","339860","lexyy.c","void reset_inputbuffer()\newline{ inputbufferspot = 0;\newline  inputsave_flag = 1;\newline}\newline","\newline function: reset_inputbuffer()\newline purpose: reset the input buffer to empty.\newline \newline","1911785","request.c","void acceptLeaveMessage(uint32_t src, uint32_t group) {\newline    struct IfDesc   *sourceVif;\newline    \newline    my_log(LOG_DEBUG, 0,\newline	    &quotGot leave message from %s to %s. Starting last member detection.&quot,\newline	    inetFmt(src, s1), inetFmt(group, s2));\newline\newline    // Sanitycheck the group adress...\newline    if(!IN_MULTICAST( ntohl(group) )) {\newline        my_log(LOG_WARNING, 0, &quotThe group address %s is not a valid Multicast group.&quot,\newline            inetFmt(group, s1));\newline        return;\newline    }\newline\newline    // Find the interface on which the report was recieved.\newline    sourceVif = getIfByAddress( src );\newline    if(sourceVif == NULL) {\newline        my_log(LOG_WARNING, 0, &quotNo interfaces found for source %s&quot,\newline            inetFmt(src,s1));\newline        return;\newline    }\newline\newline    // We have a IF so check that it&#039s an downstream IF.\newline    if(sourceVif-&gtstate == IF_STATE_DOWNSTREAM) {\newline\newline        GroupVifDesc   *gvDesc;\newline        gvDesc = (GroupVifDesc*) malloc(sizeof(GroupVifDesc));\newline\newline        // Tell the route table that we are checking for remaining members...\newline        setRouteLastMemberMode(group);\newline\newline        // Call the group spesific membership querier...\newline        gvDesc-&gtgroup = group;\newline        gvDesc-&gtvifAddr = sourceVif-&gtInAdr.s_addr;\newline        gvDesc-&gtstarted = 0;\newline\newline        sendGroupSpecificMemberQuery(gvDesc);\newline\newline    } else {\newline        // just ignore the leave request...\newline        my_log(LOG_DEBUG, 0, &quotThe found if for %s was not downstream. Ignoring leave request.&quot, inetFmt(src, s1));\newline    }\newline}\newline","\newline Recieves and handles a group leave message.\newline \newline","1659628","clist.c","void selection_made( GtkWidget      *clist,\newline                     gint            row,\newline                     gint            column,\newline		     GdkEventButton *event,\newline                     gpointer        data )\newline{\newline    gchar *text;\newline\newline    /* Get the text that is stored in the selected row and column\newline     * which was clicked in. We will receive it as a pointer in the\newline     * argument text.\newline     */\newline    gtk_clist_get_text (GTK_CLIST (clist), row, column, &amptext);\newline\newline    /* Just prints some information about the selected row */\newline    g_print (&quotYou selected row %d. More specifically you clicked in &quot\newline             &quotcolumn %d, and the text in this cell is %s\\n\\n&quot,\newline	     row, column, text);\newline\newline    return;\newline}\newline","If we come here, then the user has selected a row in the list. \newline","5980937","dbcertify_scan_phase.c","uchar_ptr_t dbc_format_key(phase_static_area *psa, uchar_ptr_t trec_p)\newline{\newline	int		dtblk_index, hdr_len, rec_value_len, rec_len, rec_cmpc;\newline	int		tmp_cmpc;\newline	size_t		len;\newline	uchar_ptr_t	blk_p, rec_value_p, subrec_p, key_end_p, rec_p;\newline	block_info	*blk_set_p;\newline	unsigned short	us_rec_len;\newline\newline	dbc_init_key(psa, &amppsa-&gtfirst_rec_key);\newline	/* We have to parse the block down to the supplied key to make sure the compressed portions\newline	 * of the key are available.\newline	 */\newline	rec_p = psa-&gtblock_buff + SIZEOF(v15_blk_hdr);\newline	while (rec_p &lt trec_p)\newline	{\newline		dbc_find_key(psa, psa-&gtfirst_rec_key, rec_p, 0);\newline		GET_USHORT(us_rec_len, &amp((rec_hdr_ptr_t)rec_p)-&gtrsiz);\newline		rec_p += us_rec_len;\newline	}\newline	assert(rec_p == trec_p);\newline	dbc_find_key(psa, psa-&gtfirst_rec_key, trec_p, 0);\newline	psa-&gtfirst_rec_key-&gtgvn_len = USTRLEN((char_ptr_t)psa-&gtfirst_rec_key-&gtbase);	/* The GVN we need to lookup in the DT */\newline	assert(0 &lt psa-&gtfirst_rec_key-&gtgvn_len);\newline	psa-&gtblock_depth = -1;	/* Reset to beginning each pass */\newline	dtblk_index = dbc_find_dtblk(psa, psa-&gtfirst_rec_key, 0);\newline	if (0 &gt dtblk_index)\newline	{	/* Couldn&#039t find the GVN in the DT. Tiz possible but rare (concurrency issues) and of no major consequence. */\newline		assert(FALSE);\newline		return NULL;\newline	}\newline	blk_set_p = &amppsa-&gtblk_set[dtblk_index];\newline	blk_p = blk_set_p-&gtold_buff;\newline	assert(0 == ((v15_blk_hdr_ptr_t)blk_p)-&gtlevl);\newline	rec_cmpc = EVAL_CMPC((rec_hdr *)blk_set_p-&gtcurr_rec);\newline	rec_value_p = (blk_set_p-&gtcurr_rec + SIZEOF(rec_hdr) + blk_set_p-&gtcurr_blk_key-&gtend + 1 - rec_cmpc);\newline	/* Verify that the dt record we found is the exact one we were looking for */\newline	if ((psa-&gtfirst_rec_key-&gtgvn_len + 1) != blk_set_p-&gtcurr_blk_key-&gtend)\newline		/* Some concurrency issues no doubt.. */\newline		return NULL;\newline	if (0 != memcmp(psa-&gtfirst_rec_key-&gtbase, blk_set_p-&gtcurr_blk_key-&gtbase, blk_set_p-&gtcurr_blk_key-&gtend))\newline		return NULL;\newline	/* Create gv_target if necessary */\newline	if (NULL == gv_target)\newline	{\newline		gv_target = malloc(SIZEOF(gv_namehead) + psa-&gtdbc_cs_data-&gtmax_key_size);\newline		/* No need to initialize gv_target-&gtclue.prev as it is not currently used */\newline		gv_target-&gtclue.top = psa-&gtfirst_rec_key-&gttop;\newline	}\newline	/* Copy our key to gv_target-&gtclue since dbc_gv_key is somewhat different */\newline	gv_target-&gtclue.end = psa-&gtfirst_rec_key-&gtend;\newline	memcpy(gv_target-&gtclue.base, psa-&gtfirst_rec_key-&gtbase, psa-&gtfirst_rec_key-&gtend + 1);\newline	/* Figure out collation for this global */\newline	GET_USHORT(us_rec_len, &amp((rec_hdr *)blk_set_p-&gtcurr_rec)-&gtrsiz);\newline	rec_len = us_rec_len;\newline	rec_value_len = (int)(rec_len - (rec_value_p - blk_set_p-&gtcurr_rec));\newline	if (SIZEOF(block_id) &lt rec_value_len)\newline	{	/* This global potentially has collation data in its record (taken from gvcst_root_search()) */\newline		subrec_p = get_spec(rec_value_p + SIZEOF(block_id), (int)(rec_value_len - SIZEOF(block_id)), COLL_SPEC);\newline		if (subrec_p)\newline		{\newline			gv_target-&gtnct = *(subrec_p + COLL_NCT_OFFSET);\newline			gv_target-&gtact = *(subrec_p + COLL_ACT_OFFSET);\newline			gv_target-&gtver = *(subrec_p + COLL_VER_OFFSET);\newline		} else\newline		{\newline			gv_target-&gtnct = 0;\newline			gv_target-&gtact = 0;\newline			gv_target-&gtver = 0;\newline		}\newline	} else\newline	{\newline		gv_target-&gtnct = 0;\newline		gv_target-&gtact = psa-&gtdbc_cs_data-&gtdef_coll;\newline		gv_target-&gtver = psa-&gtdbc_cs_data-&gtdef_coll_ver;\newline	}\newline	/* If there was any collation data involved, make sure the routines are available */\newline	if (gv_target-&gtact)\newline	{	/* Need to setup gv_altkey in case of errors (contains gvn) */\newline		if (NULL == gv_altkey)\newline		{\newline			gv_altkey = malloc(SIZEOF(gv_key) + psa-&gtdbc_cs_data-&gtmax_key_size);\newline			gv_altkey-&gtprev = 0;\newline			gv_altkey-&gttop = psa-&gtfirst_rec_key-&gttop;\newline		}\newline		gv_altkey-&gtend = psa-&gtfirst_rec_key-&gtgvn_len + 1;\newline		memcpy(gv_altkey-&gtbase, psa-&gtfirst_rec_key-&gtbase, psa-&gtfirst_rec_key-&gtgvn_len + 1);\newline		act_in_gvt(gv_target);\newline	}\newline	assert(gv_target-&gtact || NULL == gv_target-&gtcollseq);\newline	/* Format the resulting key into the result buffer which is sized appropriately for this task */\newline	key_end_p = format_targ_key(psa-&gtrslt_buff, SIZEOF(psa-&gtrslt_buff), &ampgv_target-&gtclue, TRUE);\newline	*key_end_p = 0;\newline	return psa-&gtrslt_buff;\newline}\newline","Generate an ascii representation of the given key in the current block buffer.\newline This is accomplished (mainly) by:\newline 1) Locating the key within the record.\newline 2) Calling the dbc_find_dtblk() routine to locate the directory entry for us.\newline 3) Setting up gv_target and friends to point to the entry.\newline 4) Checking the located directory entry for collation information.\newline 5) Calling format_targ_key() to do the formatting into our buffer.\newline Note: usage of &quotfirst_rec_key&quot is somewhat overloaded in this routine. Under most\newline circumstances, it is most likely the second key that is being formatted but\newline this is a defined area that is available for use in this (scan phase) routine\newline so we use it.\newline \newline","5711516","sock.c","void set_sock_qdisc_bypass(int fd, int verbose)\newline{\newline	int ret, val = 1;\newline\newline	ret = setsockopt(fd, SOL_PACKET, PACKET_QDISC_BYPASS, &ampval, sizeof(val));\newline	if (ret &lt 0) {\newline		if (errno == ENOPROTOOPT) {\newline			if (verbose)\newline				printf(&quotNo kernel support for PACKET_QDISC_BYPASS&quot\newline				       &quot (kernel &lt 3.14?)\\n&quot);\newline		} else\newline			perror(&quotCannot set PACKET_QDISC_BYPASS&quot);\newline	} else\newline		if (verbose) printf(&quotEnabled kernel qdisc bypass\\n&quot);\newline}\newline","Avail in kernel &gt= 3.14\newline in commit d346a3fae3 (packet: introduce PACKET_QDISC_BYPASS socket option)\newline \newline","6007516","insmngr.c","globle SYMBOL_HN *GetFullInstanceName(\newline  void *theEnv,\newline  INSTANCE_TYPE *ins)\newline  {\newline   char *moduleName,*buffer;\newline   unsigned bufsz;\newline   SYMBOL_HN *iname;\newline\newline   if (ins == &ampInstanceData(theEnv)-&gtDummyInstance)\newline     return((SYMBOL_HN *) EnvAddSymbol(theEnv,&quotDummy Instance&quot));\newline   if (ins-&gtgarbage)\newline     return(ins-&gtname);\newline   if (ins-&gtcls-&gtheader.whichModule-&gttheModule == ((struct defmodule *) EnvGetCurrentModule(theEnv)))\newline     return(ins-&gtname);\newline   moduleName = EnvGetDefmoduleName(theEnv,(void *) ins-&gtcls-&gtheader.whichModule-&gttheModule);\newline   bufsz = (sizeof(char) * (strlen(moduleName) +\newline                                  strlen(ValueToString(ins-&gtname)) + 3));\newline   buffer = (char *) gm2(theEnv,bufsz);\newline   sprintf(buffer,&quot%s::%s&quot,moduleName,ValueToString(ins-&gtname));\newline   iname = (SYMBOL_HN *) EnvAddSymbol(theEnv,buffer);\newline   rm(theEnv,(void *) buffer,bufsz);\newline   return(iname);\newline  }\newline","\newlineNAME : GetFullInstanceName\newlineDESCRIPTION : If this function is called while\newlinethe current module is other than\newlinethe one in which the instance\newlineresides, then the module name is\newlineprepended to the instance name.\newlineOtherwise - the base name only is\newlinereturned.\newlineINPUTS : The instance\newlineRETURNS : The instance name symbol (with\newlinemodule name and :: prepended)\newlineSIDE EFFECTS : Temporary buffer allocated possibly\newlineand new symbol created\newlineNOTES : Used to differentiate between\newlineinstances of the same name in\newlinedifferent modules\newline \newline","5747675","events.cpp","static void tweakModifiers(signed char mod, bool down)\newline{\newline    bool isShift = data-&gtmodifierState &amp (LEFTSHIFT | RIGHTSHIFT);\newline\newline    if (mod &lt 0) {\newline        return;\newline    }\newline\newline    if (isShift &amp&amp mod != 1) {\newline        if (data-&gtmodifierState &amp LEFTSHIFT) {\newline            XTestFakeKeyEvent(data-&gtdpy, data-&gtleftShiftCode,\newline                              down, CurrentTime);\newline        }\newline\newline        if (data-&gtmodifierState &amp RIGHTSHIFT) {\newline            XTestFakeKeyEvent(data-&gtdpy, data-&gtrightShiftCode,\newline                              down, CurrentTime);\newline        }\newline    }\newline\newline    if (!isShift &amp&amp mod == 1) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtleftShiftCode,\newline                          down, CurrentTime);\newline    }\newline\newline    if ((data-&gtmodifierState &amp ALTGR) &amp&amp mod != 2) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtaltGrCode,\newline                          !down, CurrentTime);\newline    }\newline\newline    if (!(data-&gtmodifierState &amp ALTGR) &amp&amp mod == 2) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtaltGrCode,\newline                          down, CurrentTime);\newline    }\newline}\newline","this function adjusts the modifiers according to mod (as from modifiers) and data-&gtmodifierState \newline","6165589","url.c","static CURLcode set_login(struct connectdata *conn,\newline                          const char *user, const char *passwd,\newline                          const char *options)\newline{\newline  CURLcode result = CURLE_OK;\newline\newline  /* If our protocol needs a password and we have none, use the defaults */\newline  if((conn-&gthandler-&gtflags &amp PROTOPT_NEEDSPWD) &amp&amp !conn-&gtbits.user_passwd) {\newline    /* Store the default user */\newline    conn-&gtuser = strdup(CURL_DEFAULT_USER);\newline\newline    /* Store the default password */\newline    if(conn-&gtuser)\newline      conn-&gtpasswd = strdup(CURL_DEFAULT_PASSWORD);\newline    else\newline      conn-&gtpasswd = NULL;\newline\newline    /* This is the default password, so DON&#039T set conn-&gtbits.user_passwd */\newline  }\newline  else {\newline    /* Store the user, zero-length if not set */\newline    conn-&gtuser = strdup(user);\newline\newline    /* Store the password (only if user is present), zero-length if not set */\newline    if(conn-&gtuser)\newline      conn-&gtpasswd = strdup(passwd);\newline    else\newline      conn-&gtpasswd = NULL;\newline  }\newline\newline  if(!conn-&gtuser || !conn-&gtpasswd)\newline    result = CURLE_OUT_OF_MEMORY;\newline\newline  /* Store the options, null if not set */\newline  if(!result &amp&amp options[0]) {\newline    conn-&gtoptions = strdup(options);\newline\newline    if(!conn-&gtoptions)\newline      result = CURLE_OUT_OF_MEMORY;\newline  }\newline\newline  return result;\newline}\newline","\newline Set the login details so they&#039re available in the connection\newline \newline","1067010","libuna_codepage_windows_949.c","int libuna_codepage_windows_949_copy_from_byte_stream(\newline     libuna_unicode_character_t *unicode_character,\newline     const uint8_t *byte_stream,\newline     size_t byte_stream_size,\newline     size_t *byte_stream_index,\newline     libcerror_error_t **error )\newline{\newline	static char *function         = &quotlibuna_codepage_windows_949_copy_from_byte_stream&quot;\newline	uint8_t additional_character  = 0;\newline	uint8_t byte_stream_character = 0;\newline\newline	if( unicode_character == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid Unicode character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid byte stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid byte stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid byte stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *byte_stream_index &gt= byte_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: byte stream too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	byte_stream_character = byte_stream[ *byte_stream_index ];\newline\newline	if( byte_stream_character &lt 0x80 )\newline	{\newline		*unicode_character = byte_stream_character;\newline	}\newline	else if( ( *byte_stream_index + 1 ) &lt= byte_stream_size )\newline	{\newline		*byte_stream_index += 1;\newline\newline		additional_character = byte_stream[ *byte_stream_index ];\newline\newline		if( ( byte_stream_character &gt= 0x81 )\newline		 &amp&amp ( byte_stream_character &lt= 0xa1 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0x81:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8140[ additional_character ];\newline						break;\newline\newline					case 0x82:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8240[ additional_character ];\newline						break;\newline\newline					case 0x83:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8340[ additional_character ];\newline						break;\newline\newline					case 0x84:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8440[ additional_character ];\newline						break;\newline\newline					case 0x85:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8540[ additional_character ];\newline						break;\newline\newline					case 0x86:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8640[ additional_character ];\newline						break;\newline\newline					case 0x87:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8740[ additional_character ];\newline						break;\newline\newline					case 0x88:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8840[ additional_character ];\newline						break;\newline\newline					case 0x89:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8940[ additional_character ];\newline						break;\newline\newline					case 0x8a:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8a40[ additional_character ];\newline						break;\newline\newline					case 0x8b:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8b40[ additional_character ];\newline						break;\newline\newline					case 0x8c:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8c40[ additional_character ];\newline						break;\newline\newline					case 0x8d:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8d40[ additional_character ];\newline						break;\newline\newline					case 0x8e:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8e40[ additional_character ];\newline						break;\newline\newline					case 0x8f:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8f40[ additional_character ];\newline						break;\newline\newline					case 0x90:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9040[ additional_character ];\newline						break;\newline\newline					case 0x91:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9140[ additional_character ];\newline						break;\newline\newline					case 0x92:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9240[ additional_character ];\newline						break;\newline\newline					case 0x93:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9340[ additional_character ];\newline						break;\newline\newline					case 0x94:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9440[ additional_character ];\newline						break;\newline\newline					case 0x95:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9540[ additional_character ];\newline						break;\newline\newline					case 0x96:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9640[ additional_character ];\newline						break;\newline\newline					case 0x97:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9740[ additional_character ];\newline						break;\newline\newline					case 0x98:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9840[ additional_character ];\newline						break;\newline\newline					case 0x99:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9940[ additional_character ];\newline						break;\newline\newline					case 0x9a:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9a40[ additional_character ];\newline						break;\newline\newline					case 0x9b:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9b40[ additional_character ];\newline						break;\newline\newline					case 0x9c:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9c40[ additional_character ];\newline						break;\newline\newline					case 0x9d:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9d40[ additional_character ];\newline						break;\newline\newline					case 0x9e:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9e40[ additional_character ];\newline						break;\newline\newline					case 0x9f:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9f40[ additional_character ];\newline						break;\newline\newline					case 0xa0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa040[ additional_character ];\newline						break;\newline\newline					case 0xa1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa140[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa2 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xe8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa240[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xa3 )\newline		      &amp&amp ( byte_stream_character &lt= 0xa4 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xa3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa340[ additional_character ];\newline						break;\newline\newline					case 0xa4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa440[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa5 )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa540[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa6 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xe8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa640[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa7 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xf0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa740[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xa8 )\newline		      &amp&amp ( byte_stream_character &lt= 0xa9 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xa8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa840[ additional_character ];\newline						break;\newline\newline					case 0xa9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa940[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xaa )\newline		      &amp&amp ( byte_stream_character &lt= 0xab ) )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xf8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xaa:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xaa40[ additional_character ];\newline						break;\newline\newline					case 0xab:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xab40[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xac )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xc8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xac40[ additional_character ];\newline			}\newline			else if( ( additional_character &gt= 0xd0 )\newline			      &amp&amp ( additional_character &lt 0xf8 ) )\newline			{\newline				additional_character -= 0xd0;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xacd0[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xad )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xad40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xcdc5;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xae )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xae40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xce2b;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xaf )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xaf40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xce99;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xb0 )\newline		      &amp&amp ( byte_stream_character &lt= 0xc5 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xb0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb040[ additional_character ];\newline						break;\newline\newline					case 0xb1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb140[ additional_character ];\newline						break;\newline\newline					case 0xb2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb240[ additional_character ];\newline						break;\newline\newline					case 0xb3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb340[ additional_character ];\newline						break;\newline\newline					case 0xb4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb440[ additional_character ];\newline						break;\newline\newline					case 0xb5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb540[ additional_character ];\newline						break;\newline\newline					case 0xb6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb640[ additional_character ];\newline						break;\newline\newline					case 0xb7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb740[ additional_character ];\newline						break;\newline\newline					case 0xb8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb840[ additional_character ];\newline						break;\newline\newline					case 0xb9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb940[ additional_character ];\newline						break;\newline\newline					case 0xba:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xba40[ additional_character ];\newline						break;\newline\newline					case 0xbb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbb40[ additional_character ];\newline						break;\newline\newline					case 0xbc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbc40[ additional_character ];\newline						break;\newline\newline					case 0xbd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbd40[ additional_character ];\newline						break;\newline\newline					case 0xbe:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbe40[ additional_character ];\newline						break;\newline\newline					case 0xbf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbf40[ additional_character ];\newline						break;\newline\newline					case 0xc0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc040[ additional_character ];\newline						break;\newline\newline					case 0xc1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc140[ additional_character ];\newline						break;\newline\newline					case 0xc2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc240[ additional_character ];\newline						break;\newline\newline					case 0xc3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc340[ additional_character ];\newline						break;\newline\newline					case 0xc4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc440[ additional_character ];\newline						break;\newline\newline					case 0xc5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc540[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xc6 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0x58 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc640[ additional_character ];\newline			}\newline			else if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc6a0[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xc7 )\newline		      &amp&amp ( byte_stream_character &lt= 0xc8 ) )\newline		{\newline			if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xc7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc7a0[ additional_character ];\newline						break;\newline\newline					case 0xc8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc8a0[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xca )\newline		      &amp&amp ( byte_stream_character &lt= 0xfd ) )\newline		{\newline			if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xca:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcaa0[ additional_character ];\newline						break;\newline\newline					case 0xcb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcba0[ additional_character ];\newline						break;\newline\newline					case 0xcc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcca0[ additional_character ];\newline						break;\newline\newline					case 0xcd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcda0[ additional_character ];\newline						break;\newline\newline					case 0xce:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcea0[ additional_character ];\newline						break;\newline\newline					case 0xcf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcfa0[ additional_character ];\newline						break;\newline\newline					case 0xd0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd0a0[ additional_character ];\newline						break;\newline\newline					case 0xd1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd1a0[ additional_character ];\newline						break;\newline\newline					case 0xd2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd2a0[ additional_character ];\newline						break;\newline\newline					case 0xd3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd3a0[ additional_character ];\newline						break;\newline\newline					case 0xd4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd4a0[ additional_character ];\newline						break;\newline\newline					case 0xd5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd5a0[ additional_character ];\newline						break;\newline\newline					case 0xd6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd6a0[ additional_character ];\newline						break;\newline\newline					case 0xd7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd7a0[ additional_character ];\newline						break;\newline\newline					case 0xd8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd8a0[ additional_character ];\newline						break;\newline\newline					case 0xd9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd9a0[ additional_character ];\newline						break;\newline\newline					case 0xda:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdaa0[ additional_character ];\newline						break;\newline\newline					case 0xdb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdba0[ additional_character ];\newline						break;\newline\newline					case 0xdc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdca0[ additional_character ];\newline						break;\newline\newline					case 0xdd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdda0[ additional_character ];\newline						break;\newline\newline					case 0xde:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdea0[ additional_character ];\newline						break;\newline\newline					case 0xdf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdfa0[ additional_character ];\newline						break;\newline\newline					case 0xe0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe0a0[ additional_character ];\newline						break;\newline\newline					case 0xe1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe1a0[ additional_character ];\newline						break;\newline\newline					case 0xe2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe2a0[ additional_character ];\newline						break;\newline\newline					case 0xe3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe3a0[ additional_character ];\newline						break;\newline\newline					case 0xe4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe4a0[ additional_character ];\newline						break;\newline\newline					case 0xe5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe5a0[ additional_character ];\newline						break;\newline\newline					case 0xe6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe6a0[ additional_character ];\newline						break;\newline\newline					case 0xe7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe7a0[ additional_character ];\newline						break;\newline\newline					case 0xe8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe8a0[ additional_character ];\newline						break;\newline\newline					case 0xe9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe9a0[ additional_character ];\newline						break;\newline\newline					case 0xea:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeaa0[ additional_character ];\newline						break;\newline\newline					case 0xeb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeba0[ additional_character ];\newline						break;\newline\newline					case 0xec:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeca0[ additional_character ];\newline						break;\newline\newline					case 0xed:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeda0[ additional_character ];\newline						break;\newline\newline					case 0xee:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeea0[ additional_character ];\newline						break;\newline\newline					case 0xef:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xefa0[ additional_character ];\newline						break;\newline\newline					case 0xf0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf0a0[ additional_character ];\newline						break;\newline\newline					case 0xf1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf1a0[ additional_character ];\newline						break;\newline\newline					case 0xf2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf2a0[ additional_character ];\newline						break;\newline\newline					case 0xf3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf3a0[ additional_character ];\newline						break;\newline\newline					case 0xf4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf4a0[ additional_character ];\newline						break;\newline\newline					case 0xf5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf5a0[ additional_character ];\newline						break;\newline\newline					case 0xf6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf6a0[ additional_character ];\newline						break;\newline\newline					case 0xf7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf7a0[ additional_character ];\newline						break;\newline\newline					case 0xf8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf8a0[ additional_character ];\newline						break;\newline\newline					case 0xf9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf9a0[ additional_character ];\newline						break;\newline\newline					case 0xfa:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfaa0[ additional_character ];\newline						break;\newline\newline					case 0xfb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfba0[ additional_character ];\newline						break;\newline\newline					case 0xfc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfca0[ additional_character ];\newline						break;\newline\newline					case 0xfd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfda0[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else\newline		{\newline			*unicode_character = 0xfffd;\newline		}\newline	}\newline	else\newline	{\newline		*unicode_character = 0xfffd;\newline	}\newline	*byte_stream_index += 1;\newline\newline	return( 1 );\newline}\newline","Copies a Unicode character from a byte stream\newline Returns 1 if successful or -1 on error\newline \newline","3616639","esdlib.c","int esd_close( int esd )\newline{\newline    /* diagnostic info */\newline    /*\newline    if ( getenv( &quotESDBG&quot ) )\newline	printf( &quotesound closing\\n&quot );\newline    */\newline\newline    return close( esd );\newline}\newline","closes fd, previously obtained by esd_open \newline","4284132","shfile.c","static int shfile_copy_insert_and_close(shfdtab *pfdtab, int *pnative, unsigned oflags, unsigned shflags, int fdMin, const char *who)\newline{\newline    int fd          = -1;\newline    int s           = errno;\newline    int native_copy = fcntl(*pnative, F_DUPFD, SHFILE_UNIX_MIN_FD);\newline    close(*pnative);\newline    *pnative = -1;\newline    errno = s;\newline\newline    if (native_copy != -1)\newline        fd = shfile_insert(pfdtab, native_copy, oflags, shflags, fdMin, who);\newline    return fd;\newline}\newline","\newline Makes a copy of the native file, closes the original, and inserts the copy\newline into the descriptor table.\newline \newline If we&#039re out of memory and cannot extend the table, we&#039ll close the\newline file, set errno to EMFILE and return -1.\newline \newline @returns The file descriptor number. -1 and errno on failure.\newline @param pfdtab The file descriptor table.\newline @param pnative The native file handle on input, -1 on output.\newline @param oflags The flags the it was opened/created with.\newline @param shflags The shell file flags.\newline @param fdMin The minimum file descriptor number, pass -1 if any is ok.\newline @param who Who we&#039re doing this for (for logging purposes).\newline \newline","3369240","extrainfo.cpp","void QDesignerExtraInfoExtension::setWorkingDirectory(const QString &ampworkingDirectory)\newline{\newline    m_workingDirectory = workingDirectory;\newline}\newline","!\newlineSets the path to the working directory used by the extension to \\a workingDirectory. \newline","674302","setup.c","static int keyslot_verify_or_find_empty(struct crypt_device *cd, int *keyslot)\newline{\newline	if (*keyslot == CRYPT_ANY_SLOT) {\newline		*keyslot = LUKS_keyslot_find_empty(&ampcd-&gtu.luks1.hdr);\newline		if (*keyslot &lt 0) {\newline			log_err(cd, _(&quotAll key slots full.\\n&quot));\newline			return -EINVAL;\newline		}\newline	}\newline\newline	switch (LUKS_keyslot_info(&ampcd-&gtu.luks1.hdr, *keyslot)) {\newline		case CRYPT_SLOT_INVALID:\newline			log_err(cd, _(&quotKey slot %d is invalid, please select between 0 and %d.\\n&quot),\newline				*keyslot, LUKS_NUMKEYS - 1);\newline			return -EINVAL;\newline		case CRYPT_SLOT_INACTIVE:\newline			break;\newline		default:\newline			log_err(cd, _(&quotKey slot %d is full, please select another one.\\n&quot),\newline				*keyslot);\newline			return -EINVAL;\newline	}\newline\newline	return 0;\newline}\newline","keyslot helpers \newline","2166239","eft.c","static void set_default_address(struct eft * eft)\newline{\newline	char hostname[TDU_PLEN_ADDR+1];\newline	struct hostent *phinfo;\newline	\newline	if (0 == gethostname(hostname, sizeof(hostname))) {\newline		phinfo = gethostbyname(hostname);\newline		if (NULL == phinfo) {\newline			herror(hostname);\newline			}\newline		else {\newline			eft_set_address(eft, phinfo-&gth_name);\newline			/* FIXME: user defineable log mask isn&#039t read until now */			\newline			tdu_printf(TDU_LOG_LOG, &quotaddress set to \\&quot%s\\&quot initially\\n&quot, eft-&gtaddress);\newline			}\newline		}\newline	else\newline		perror(&quotgethostname&quot);\newline}\newline","\newline Set the default address of the eft instance\newline (contributed by Matthias Stolte &ltms@msdatec.de&gt; slightly modified)\newline \newline","489487","device.c","static int pic14_isShared(int low, int high)\newline{\newline	memRange *r;\newline\newline	assert(pic);\newline	r = pic-&gtram;\newline\newline	while (r) {\newline	    //fprintf (stderr, &quot%s: region %x..%x, bank %x, alias %x, pic-&gtbankmask %x\\n&quot, __FUNCTION__, r-&gtstart_address, r-&gtend_address, r-&gtbank, r-&gtalias, pic-&gtbankMask);\newline	    if ((r-&gtalias == pic-&gtbankMask) &amp&amp (r-&gtstart_address &lt= low) &amp&amp (r-&gtend_address &gt= high)) {\newline		return 1;\newline	    } // if\newline	    r = r-&gtnext;\newline	} // while\newline\newline	return 0;\newline}\newline","\newline True iff the memory region [low, high] is aliased in all banks.\newline \newline","4319496","iso_img.c","static int Xorriso_register_eltorito_gpt(struct XorrisO *xorriso,\newline                                         struct elto_img_par *et_img,\newline                                         int ptype,\newline                                         int *efi_boot_part, int *first_efi,\newline                                         int flag)\newline{\newline if(flag &amp 1) {\newline   if(ptype == 1 || ptype == 3)\newline     et_img-&gtdo_gpt_basdat= 1;\newline   else if(ptype == 2)\newline     et_img-&gtdo_gpt_hfsplus= 1;\newline   return(1);\newline } else if(*first_efi &amp&amp et_img-&gtplatform_id == 0xef) {\newline   *efi_boot_part= 1;\newline   return(1);\newline }\newline if(et_img-&gtplatform_id == 0xef)\newline   *first_efi= 0;\newline return(0);\newline}\newline","@param ptype 0= unknown, 1= gpt-basdat, 2=gpt-hfsplus, 3=EFI\newline@param flag bit0= isohybrid\newline \newline","1001888","sb16ctrl.c","void checkemulator()\newline{\newline  int i;\newline\newline  checked = 1;\newline\newline  enableport();\newline\newline  /* Check emulator status */\newline  for (i=0; i&lt9; i++)\newline    writeemul(1);          /* Clear input queue */\newline  writeemul(10);           /* Check Emulator present */\newline  testemul(254, &quotno check ACK: Emulator not present&quot);\newline  testemul(0x55, &quotEmulator not present&quot);    /* should return 0x55 */\newline}\newline","Check if we are running inside the emulator \newline","5974934","gd.c","BGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)\newline{\newline	int i;\newline	long rd, gd, bd, ad;\newline	int ct = (-1);\newline	int first = 1;\newline	long mindist = 0;\newline	if (im-&gttrueColor) {\newline		return gdTrueColorAlpha (r, g, b, a);\newline	}\newline	for (i = 0; (i &lt (im-&gtcolorsTotal)); i++) {\newline		long dist;\newline		if (im-&gtopen[i]) {\newline			continue;\newline		}\newline		rd = (im-&gtred[i] - r);\newline		gd = (im-&gtgreen[i] - g);\newline		bd = (im-&gtblue[i] - b);\newline		/* gd 2.02: whoops, was - b (thanks to David Marwood) */\newline		/* gd 2.16: was blue rather than alpha! Geez! Thanks to\newline		   Artur Jakub Jerzak */\newline		ad = (im-&gtalpha[i] - a);\newline		dist = rd * rd + gd * gd + bd * bd + ad * ad;\newline		if (first || (dist &lt mindist)) {\newline			mindist = dist;\newline			ct = i;\newline			first = 0;\newline		}\newline	}\newline	return ct;\newline}\newline","\newline Function: gdImageColorClosestAlpha\newline \newline Gets the closest color of the image\newline \newline Parameters:\newline im - The image.\newline r - The value of the red component.\newline g - The value of the green component.\newline b - The value of the blue component.\newline a - The value of the alpha component.\newline \newline Returns:\newline The closest color already available in the palette for palette images;\newline the color value of the given components for truecolor images.\newline \newline See also:\newline - &ltgdImageColorExactAlpha&gt\newline \newline","5746884","editstate.c","void editstate_displayPathString(EditState *cur_es)\newline{\newline  EditState *estack[MAX_STACKDEPTH];\newline  EditState *es;\newline  char path[STRMAX],*p;\newline  int esp,i;\newline\newline  es = cur_es;\newline  for (esp = 0;esp &lt MAX_STACKDEPTH &amp&amp es;es = es-&gtparent)\newline    estack[esp++] = es;\newline\newline  p = path;\newline  sprintf(p,&quot/&quot);\newline  p = p + strlen(p);\newline\newline  DoTcl(&quotcatch { unset tkg_pathInstance }&quot);\newline  for (i = esp-1;i &gt= 0;i--) {\newline    if (i != esp-1) *p++ = &#039/&#039;\newline    if (estack[i]-&gtinst) {\newline      DoTcl(&quotset ::tkg_pathInstance(%s) \\&quot (%s)\\&quot&quot,estack[i]-&gtenv-&gtm_name,estack[i]-&gtinst-&gtename);\newline    } else {\newline      DoTcl(&quotset ::tkg_pathInstance(%s) \\&quot\\&quot&quot,estack[i]-&gtenv-&gtm_name);\newline    }\newline    strcpy(p,estack[i]-&gtenv-&gtm_name);\newline    p = p + strlen(p);\newline  }\newline\newline  if (TkGate.tcl) {\newline    Tcl_SetVar(TkGate.tcl,&quottkg_currentPath&quot,path,TCL_GLOBAL_ONLY); \newline    Tcl_SetVar(TkGate.tcl,&quottkg_currentModule&quot,cur_es-&gtenv-&gtm_name,TCL_GLOBAL_ONLY);\newline  }\newline}\newline","\newline Set the tkg_currentPath and tkg_currentModule variables\newline \newline","1253504","pass2.c","static void fix_dirent_lengths(struct ocfs2_dir_entry *dirent,\newline			       int left, struct ocfs2_dir_entry *prev,\newline			       unsigned int *flags)\newline{\newline	/* \newline	 * as described above we can&#039t reconstruct either value if it is\newline	 * complete nonsense.  We can only proceed if we can work off of\newline	 * one that is kind of valid looking.\newline	 * name_len could well be 0 from the dirent being cleared.\newline	 */\newline	if (dirent-&gtrec_len &lt OCFS2_DIR_MEMBER_LEN ||\newline	   (dirent-&gtrec_len &gt left ||\newline	    dirent-&gtname_len &gt left))\newline	    goto wipe;\newline\newline	/* if we see a dirent with no file name then we remove it by\newline	 * shifting the remaining dirents forward */\newline	if ((dirent-&gtrec_len == OCFS2_DIR_MEMBER_LEN)) {\newline		char *cp = (char *)dirent;\newline		left -= dirent-&gtrec_len;\newline		memmove(cp, cp + dirent-&gtrec_len, left);\newline		memset(cp + left, 0, dirent-&gtrec_len);\newline		goto out;\newline	}\newline\newline	/* if rec_len just appears to be mis-rounded in a way that doesn&#039t\newline	 * affect following dirents then we can probably save this dirent */\newline	if (OCFS2_DIR_REC_LEN(dirent-&gtname_len) != dirent-&gtrec_len &amp&amp\newline	    OCFS2_DIR_REC_LEN(dirent-&gtname_len) == \newline					OCFS2_DIR_REC_LEN(dirent-&gtrec_len)) {\newline		dirent-&gtrec_len = OCFS2_DIR_REC_LEN(dirent-&gtname_len);\newline		left -= dirent-&gtrec_len;\newline		goto out;\newline	}\newline\newline	/* if name_len is too far off, however, we&#039re going to lose this\newline	 * dirent.. we might be able to just lose this one dirent if rec_len\newline	 * appears to be intact. */\newline	if ((dirent-&gtrec_len &amp OCFS2_DIR_ROUND) == 0 &amp&amp\newline	    !dirent_leaves_partial(dirent, left)) {\newline		left -= dirent-&gtrec_len;\newline		dirent-&gtname_len = 0;\newline		dirent-&gtinode = 0;\newline		dirent-&gtfile_type = OCFS2_FT_UNKNOWN;\newline		goto out;\newline	}\newline\newline	/* \newline	 * if we can&#039t trust rec_len, however, then we don&#039t know where the\newline	 * next dirent might begin.  We&#039ve lost the trail of dirents created by\newline	 * the file system and run the risk of parsing file names as dirents.\newline	 * So we&#039re forced to wipe the block and leave the rest to lost+found.\newline	 */\newlinewipe:\newline	dirent-&gtrec_len = left;\newline	dirent-&gtname_len = 0;\newline	dirent-&gtinode = 0;\newline	dirent-&gtfile_type = OCFS2_FT_UNKNOWN;\newline	left = 0;\newlineout:\newline\newline	/* \newline	 * rec_len must be valid and left must reflect the space *after* the\newline	 * current dirent by this point.  if there isn&#039t enough room for\newline	 * another dirent after the one we&#039ve just repaired then we tack the\newline	 * remaining space onto the current dirent.\newline	 */\newline	if (dirent_leaves_partial(dirent, left))\newline		dirent-&gtrec_len += left;\newline\newline	*flags |= OCFS2_DIRENT_CHANGED;\newline}\newline","\newline The caller has found that either of rec_len or name_len are garbage. The\newline caller trusts us to fix them up in place and will be checking them again\newline before proceeding. We have to update the lengths to make forward progress.\newline &#039left&#039 is the number of bytes from the start of this dirent struct that\newline remain in the block. \newline \newline We&#039re called for invalid dirents, and having a dirent\newline that leaves a partial dirent at the end of the block is considered invalid,\newline and we pad out partials at the end of this call so we can&#039t be called here\newline with left &lt OCFS2_DIR_MEMBER_LEN.\newline \newline we&#039re pretty limited in the repairs we can make:\newline \newline - We can&#039t just set name_len if rec_len looks valid, we might guess \newline name_len wrong and create a bogus file name.\newline - we can&#039t just set rec_len based on name_len. rec_len could have\newline included an arbitrary part of the name from a previously freed dirent.\newline \newline","4206734","w32log.c","HWND CreateHiddenLogOwnerWindow(HINSTANCE hInstance)\newline{\newline   static const char *szWndName = &quotPrivoxyLogOwner&quot;\newline   WNDCLASS wc;\newline   HWND hwnd;\newline\newline   wc.style          = 0;\newline   wc.lpfnWndProc    = LogOwnerWindowProc;\newline   wc.cbClsExtra     = 0;\newline   wc.cbWndExtra     = 0;\newline   wc.hInstance      = hInstance;\newline   wc.hIcon          = g_hiconApp;\newline   wc.hCursor        = 0;\newline   wc.hbrBackground  = 0;\newline   wc.lpszMenuName   = 0;\newline   wc.lpszClassName  = szWndName;\newline\newline   RegisterClass(&ampwc);\newline\newline   hwnd = CreateWindow(szWndName, szWndName,\newline      WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\newline      CW_USEDEFAULT, NULL, NULL, hInstance, NULL);\newline\newline   return hwnd;\newline\newline}\newline","\newline \newline Function : CreateHiddenLogOwnerWindow\newline \newline Description : Creates a hidden owner window that stops the log\newline window appearing in the task bar.\newline \newline Parameters :\newline 1 : hInstance = application&#039s instance handle\newline \newline Returns : Handle to newly created window.\newline \newline \newline","","","","","on","","","on","on","","","","on","","on","","","","","","","","on","on","","","","","","","","","","","","","on","","on","","","on","reset the input buffer to empty.","closes fd,","Makes a copy of the native file,","Sets the path to the working directory used by the extension","{}","Set the default address of the eft instance","the memory region [low, high] is aliased in all banks.","{}","{}","Gets the closest color of the image","Set the tkg_currentPath and tkg_currentModule variables","Recieves and handles a group leave message.","{}","Creates a hidden owner window","{}","Generate an ascii representation of the given key","introduce PACKET_QDISC_BYPASS socket option)","Temporary buffer allocated possiblyand new symbol created","adjusts the modifiers according to mod","Set the login details","Copies a Unicode character from a byte stream"
"3DGDV62G7O9H9HBKK69VOOL8EUHP28","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3IXQG4FA2TYSSRS2CCBASAKMJKS9BJ","A2MX5YW3DSQ61W","Approved","Wed Apr 17 15:10:25 PDT 2019","Wed Apr 17 15:21:31 PDT 2019","Fri Apr 19 15:21:31 PDT 2019","2019-04-19 22:22:21 UTC","","","666","100% (5/5)","100% (5/5)","100% (5/5)","339860","lexyy.c","void reset_inputbuffer()\newline{ inputbufferspot = 0;\newline  inputsave_flag = 1;\newline}\newline","\newline function: reset_inputbuffer()\newline purpose: reset the input buffer to empty.\newline \newline","1911785","request.c","void acceptLeaveMessage(uint32_t src, uint32_t group) {\newline    struct IfDesc   *sourceVif;\newline    \newline    my_log(LOG_DEBUG, 0,\newline	    &quotGot leave message from %s to %s. Starting last member detection.&quot,\newline	    inetFmt(src, s1), inetFmt(group, s2));\newline\newline    // Sanitycheck the group adress...\newline    if(!IN_MULTICAST( ntohl(group) )) {\newline        my_log(LOG_WARNING, 0, &quotThe group address %s is not a valid Multicast group.&quot,\newline            inetFmt(group, s1));\newline        return;\newline    }\newline\newline    // Find the interface on which the report was recieved.\newline    sourceVif = getIfByAddress( src );\newline    if(sourceVif == NULL) {\newline        my_log(LOG_WARNING, 0, &quotNo interfaces found for source %s&quot,\newline            inetFmt(src,s1));\newline        return;\newline    }\newline\newline    // We have a IF so check that it&#039s an downstream IF.\newline    if(sourceVif-&gtstate == IF_STATE_DOWNSTREAM) {\newline\newline        GroupVifDesc   *gvDesc;\newline        gvDesc = (GroupVifDesc*) malloc(sizeof(GroupVifDesc));\newline\newline        // Tell the route table that we are checking for remaining members...\newline        setRouteLastMemberMode(group);\newline\newline        // Call the group spesific membership querier...\newline        gvDesc-&gtgroup = group;\newline        gvDesc-&gtvifAddr = sourceVif-&gtInAdr.s_addr;\newline        gvDesc-&gtstarted = 0;\newline\newline        sendGroupSpecificMemberQuery(gvDesc);\newline\newline    } else {\newline        // just ignore the leave request...\newline        my_log(LOG_DEBUG, 0, &quotThe found if for %s was not downstream. Ignoring leave request.&quot, inetFmt(src, s1));\newline    }\newline}\newline","\newline Recieves and handles a group leave message.\newline \newline","1659628","clist.c","void selection_made( GtkWidget      *clist,\newline                     gint            row,\newline                     gint            column,\newline		     GdkEventButton *event,\newline                     gpointer        data )\newline{\newline    gchar *text;\newline\newline    /* Get the text that is stored in the selected row and column\newline     * which was clicked in. We will receive it as a pointer in the\newline     * argument text.\newline     */\newline    gtk_clist_get_text (GTK_CLIST (clist), row, column, &amptext);\newline\newline    /* Just prints some information about the selected row */\newline    g_print (&quotYou selected row %d. More specifically you clicked in &quot\newline             &quotcolumn %d, and the text in this cell is %s\\n\\n&quot,\newline	     row, column, text);\newline\newline    return;\newline}\newline","If we come here, then the user has selected a row in the list. \newline","5980937","dbcertify_scan_phase.c","uchar_ptr_t dbc_format_key(phase_static_area *psa, uchar_ptr_t trec_p)\newline{\newline	int		dtblk_index, hdr_len, rec_value_len, rec_len, rec_cmpc;\newline	int		tmp_cmpc;\newline	size_t		len;\newline	uchar_ptr_t	blk_p, rec_value_p, subrec_p, key_end_p, rec_p;\newline	block_info	*blk_set_p;\newline	unsigned short	us_rec_len;\newline\newline	dbc_init_key(psa, &amppsa-&gtfirst_rec_key);\newline	/* We have to parse the block down to the supplied key to make sure the compressed portions\newline	 * of the key are available.\newline	 */\newline	rec_p = psa-&gtblock_buff + SIZEOF(v15_blk_hdr);\newline	while (rec_p &lt trec_p)\newline	{\newline		dbc_find_key(psa, psa-&gtfirst_rec_key, rec_p, 0);\newline		GET_USHORT(us_rec_len, &amp((rec_hdr_ptr_t)rec_p)-&gtrsiz);\newline		rec_p += us_rec_len;\newline	}\newline	assert(rec_p == trec_p);\newline	dbc_find_key(psa, psa-&gtfirst_rec_key, trec_p, 0);\newline	psa-&gtfirst_rec_key-&gtgvn_len = USTRLEN((char_ptr_t)psa-&gtfirst_rec_key-&gtbase);	/* The GVN we need to lookup in the DT */\newline	assert(0 &lt psa-&gtfirst_rec_key-&gtgvn_len);\newline	psa-&gtblock_depth = -1;	/* Reset to beginning each pass */\newline	dtblk_index = dbc_find_dtblk(psa, psa-&gtfirst_rec_key, 0);\newline	if (0 &gt dtblk_index)\newline	{	/* Couldn&#039t find the GVN in the DT. Tiz possible but rare (concurrency issues) and of no major consequence. */\newline		assert(FALSE);\newline		return NULL;\newline	}\newline	blk_set_p = &amppsa-&gtblk_set[dtblk_index];\newline	blk_p = blk_set_p-&gtold_buff;\newline	assert(0 == ((v15_blk_hdr_ptr_t)blk_p)-&gtlevl);\newline	rec_cmpc = EVAL_CMPC((rec_hdr *)blk_set_p-&gtcurr_rec);\newline	rec_value_p = (blk_set_p-&gtcurr_rec + SIZEOF(rec_hdr) + blk_set_p-&gtcurr_blk_key-&gtend + 1 - rec_cmpc);\newline	/* Verify that the dt record we found is the exact one we were looking for */\newline	if ((psa-&gtfirst_rec_key-&gtgvn_len + 1) != blk_set_p-&gtcurr_blk_key-&gtend)\newline		/* Some concurrency issues no doubt.. */\newline		return NULL;\newline	if (0 != memcmp(psa-&gtfirst_rec_key-&gtbase, blk_set_p-&gtcurr_blk_key-&gtbase, blk_set_p-&gtcurr_blk_key-&gtend))\newline		return NULL;\newline	/* Create gv_target if necessary */\newline	if (NULL == gv_target)\newline	{\newline		gv_target = malloc(SIZEOF(gv_namehead) + psa-&gtdbc_cs_data-&gtmax_key_size);\newline		/* No need to initialize gv_target-&gtclue.prev as it is not currently used */\newline		gv_target-&gtclue.top = psa-&gtfirst_rec_key-&gttop;\newline	}\newline	/* Copy our key to gv_target-&gtclue since dbc_gv_key is somewhat different */\newline	gv_target-&gtclue.end = psa-&gtfirst_rec_key-&gtend;\newline	memcpy(gv_target-&gtclue.base, psa-&gtfirst_rec_key-&gtbase, psa-&gtfirst_rec_key-&gtend + 1);\newline	/* Figure out collation for this global */\newline	GET_USHORT(us_rec_len, &amp((rec_hdr *)blk_set_p-&gtcurr_rec)-&gtrsiz);\newline	rec_len = us_rec_len;\newline	rec_value_len = (int)(rec_len - (rec_value_p - blk_set_p-&gtcurr_rec));\newline	if (SIZEOF(block_id) &lt rec_value_len)\newline	{	/* This global potentially has collation data in its record (taken from gvcst_root_search()) */\newline		subrec_p = get_spec(rec_value_p + SIZEOF(block_id), (int)(rec_value_len - SIZEOF(block_id)), COLL_SPEC);\newline		if (subrec_p)\newline		{\newline			gv_target-&gtnct = *(subrec_p + COLL_NCT_OFFSET);\newline			gv_target-&gtact = *(subrec_p + COLL_ACT_OFFSET);\newline			gv_target-&gtver = *(subrec_p + COLL_VER_OFFSET);\newline		} else\newline		{\newline			gv_target-&gtnct = 0;\newline			gv_target-&gtact = 0;\newline			gv_target-&gtver = 0;\newline		}\newline	} else\newline	{\newline		gv_target-&gtnct = 0;\newline		gv_target-&gtact = psa-&gtdbc_cs_data-&gtdef_coll;\newline		gv_target-&gtver = psa-&gtdbc_cs_data-&gtdef_coll_ver;\newline	}\newline	/* If there was any collation data involved, make sure the routines are available */\newline	if (gv_target-&gtact)\newline	{	/* Need to setup gv_altkey in case of errors (contains gvn) */\newline		if (NULL == gv_altkey)\newline		{\newline			gv_altkey = malloc(SIZEOF(gv_key) + psa-&gtdbc_cs_data-&gtmax_key_size);\newline			gv_altkey-&gtprev = 0;\newline			gv_altkey-&gttop = psa-&gtfirst_rec_key-&gttop;\newline		}\newline		gv_altkey-&gtend = psa-&gtfirst_rec_key-&gtgvn_len + 1;\newline		memcpy(gv_altkey-&gtbase, psa-&gtfirst_rec_key-&gtbase, psa-&gtfirst_rec_key-&gtgvn_len + 1);\newline		act_in_gvt(gv_target);\newline	}\newline	assert(gv_target-&gtact || NULL == gv_target-&gtcollseq);\newline	/* Format the resulting key into the result buffer which is sized appropriately for this task */\newline	key_end_p = format_targ_key(psa-&gtrslt_buff, SIZEOF(psa-&gtrslt_buff), &ampgv_target-&gtclue, TRUE);\newline	*key_end_p = 0;\newline	return psa-&gtrslt_buff;\newline}\newline","Generate an ascii representation of the given key in the current block buffer.\newline This is accomplished (mainly) by:\newline 1) Locating the key within the record.\newline 2) Calling the dbc_find_dtblk() routine to locate the directory entry for us.\newline 3) Setting up gv_target and friends to point to the entry.\newline 4) Checking the located directory entry for collation information.\newline 5) Calling format_targ_key() to do the formatting into our buffer.\newline Note: usage of &quotfirst_rec_key&quot is somewhat overloaded in this routine. Under most\newline circumstances, it is most likely the second key that is being formatted but\newline this is a defined area that is available for use in this (scan phase) routine\newline so we use it.\newline \newline","5711516","sock.c","void set_sock_qdisc_bypass(int fd, int verbose)\newline{\newline	int ret, val = 1;\newline\newline	ret = setsockopt(fd, SOL_PACKET, PACKET_QDISC_BYPASS, &ampval, sizeof(val));\newline	if (ret &lt 0) {\newline		if (errno == ENOPROTOOPT) {\newline			if (verbose)\newline				printf(&quotNo kernel support for PACKET_QDISC_BYPASS&quot\newline				       &quot (kernel &lt 3.14?)\\n&quot);\newline		} else\newline			perror(&quotCannot set PACKET_QDISC_BYPASS&quot);\newline	} else\newline		if (verbose) printf(&quotEnabled kernel qdisc bypass\\n&quot);\newline}\newline","Avail in kernel &gt= 3.14\newline in commit d346a3fae3 (packet: introduce PACKET_QDISC_BYPASS socket option)\newline \newline","6007516","insmngr.c","globle SYMBOL_HN *GetFullInstanceName(\newline  void *theEnv,\newline  INSTANCE_TYPE *ins)\newline  {\newline   char *moduleName,*buffer;\newline   unsigned bufsz;\newline   SYMBOL_HN *iname;\newline\newline   if (ins == &ampInstanceData(theEnv)-&gtDummyInstance)\newline     return((SYMBOL_HN *) EnvAddSymbol(theEnv,&quotDummy Instance&quot));\newline   if (ins-&gtgarbage)\newline     return(ins-&gtname);\newline   if (ins-&gtcls-&gtheader.whichModule-&gttheModule == ((struct defmodule *) EnvGetCurrentModule(theEnv)))\newline     return(ins-&gtname);\newline   moduleName = EnvGetDefmoduleName(theEnv,(void *) ins-&gtcls-&gtheader.whichModule-&gttheModule);\newline   bufsz = (sizeof(char) * (strlen(moduleName) +\newline                                  strlen(ValueToString(ins-&gtname)) + 3));\newline   buffer = (char *) gm2(theEnv,bufsz);\newline   sprintf(buffer,&quot%s::%s&quot,moduleName,ValueToString(ins-&gtname));\newline   iname = (SYMBOL_HN *) EnvAddSymbol(theEnv,buffer);\newline   rm(theEnv,(void *) buffer,bufsz);\newline   return(iname);\newline  }\newline","\newlineNAME : GetFullInstanceName\newlineDESCRIPTION : If this function is called while\newlinethe current module is other than\newlinethe one in which the instance\newlineresides, then the module name is\newlineprepended to the instance name.\newlineOtherwise - the base name only is\newlinereturned.\newlineINPUTS : The instance\newlineRETURNS : The instance name symbol (with\newlinemodule name and :: prepended)\newlineSIDE EFFECTS : Temporary buffer allocated possibly\newlineand new symbol created\newlineNOTES : Used to differentiate between\newlineinstances of the same name in\newlinedifferent modules\newline \newline","5747675","events.cpp","static void tweakModifiers(signed char mod, bool down)\newline{\newline    bool isShift = data-&gtmodifierState &amp (LEFTSHIFT | RIGHTSHIFT);\newline\newline    if (mod &lt 0) {\newline        return;\newline    }\newline\newline    if (isShift &amp&amp mod != 1) {\newline        if (data-&gtmodifierState &amp LEFTSHIFT) {\newline            XTestFakeKeyEvent(data-&gtdpy, data-&gtleftShiftCode,\newline                              down, CurrentTime);\newline        }\newline\newline        if (data-&gtmodifierState &amp RIGHTSHIFT) {\newline            XTestFakeKeyEvent(data-&gtdpy, data-&gtrightShiftCode,\newline                              down, CurrentTime);\newline        }\newline    }\newline\newline    if (!isShift &amp&amp mod == 1) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtleftShiftCode,\newline                          down, CurrentTime);\newline    }\newline\newline    if ((data-&gtmodifierState &amp ALTGR) &amp&amp mod != 2) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtaltGrCode,\newline                          !down, CurrentTime);\newline    }\newline\newline    if (!(data-&gtmodifierState &amp ALTGR) &amp&amp mod == 2) {\newline        XTestFakeKeyEvent(data-&gtdpy, data-&gtaltGrCode,\newline                          down, CurrentTime);\newline    }\newline}\newline","this function adjusts the modifiers according to mod (as from modifiers) and data-&gtmodifierState \newline","6165589","url.c","static CURLcode set_login(struct connectdata *conn,\newline                          const char *user, const char *passwd,\newline                          const char *options)\newline{\newline  CURLcode result = CURLE_OK;\newline\newline  /* If our protocol needs a password and we have none, use the defaults */\newline  if((conn-&gthandler-&gtflags &amp PROTOPT_NEEDSPWD) &amp&amp !conn-&gtbits.user_passwd) {\newline    /* Store the default user */\newline    conn-&gtuser = strdup(CURL_DEFAULT_USER);\newline\newline    /* Store the default password */\newline    if(conn-&gtuser)\newline      conn-&gtpasswd = strdup(CURL_DEFAULT_PASSWORD);\newline    else\newline      conn-&gtpasswd = NULL;\newline\newline    /* This is the default password, so DON&#039T set conn-&gtbits.user_passwd */\newline  }\newline  else {\newline    /* Store the user, zero-length if not set */\newline    conn-&gtuser = strdup(user);\newline\newline    /* Store the password (only if user is present), zero-length if not set */\newline    if(conn-&gtuser)\newline      conn-&gtpasswd = strdup(passwd);\newline    else\newline      conn-&gtpasswd = NULL;\newline  }\newline\newline  if(!conn-&gtuser || !conn-&gtpasswd)\newline    result = CURLE_OUT_OF_MEMORY;\newline\newline  /* Store the options, null if not set */\newline  if(!result &amp&amp options[0]) {\newline    conn-&gtoptions = strdup(options);\newline\newline    if(!conn-&gtoptions)\newline      result = CURLE_OUT_OF_MEMORY;\newline  }\newline\newline  return result;\newline}\newline","\newline Set the login details so they&#039re available in the connection\newline \newline","1067010","libuna_codepage_windows_949.c","int libuna_codepage_windows_949_copy_from_byte_stream(\newline     libuna_unicode_character_t *unicode_character,\newline     const uint8_t *byte_stream,\newline     size_t byte_stream_size,\newline     size_t *byte_stream_index,\newline     libcerror_error_t **error )\newline{\newline	static char *function         = &quotlibuna_codepage_windows_949_copy_from_byte_stream&quot;\newline	uint8_t additional_character  = 0;\newline	uint8_t byte_stream_character = 0;\newline\newline	if( unicode_character == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid Unicode character.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid byte stream.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream_size &gt (size_t) SSIZE_MAX )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\newline		 &quot%s: invalid byte stream size value exceeds maximum.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( byte_stream_index == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid byte stream index.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( *byte_stream_index &gt= byte_stream_size )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_VALUE_TOO_SMALL,\newline		 &quot%s: byte stream too small.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	byte_stream_character = byte_stream[ *byte_stream_index ];\newline\newline	if( byte_stream_character &lt 0x80 )\newline	{\newline		*unicode_character = byte_stream_character;\newline	}\newline	else if( ( *byte_stream_index + 1 ) &lt= byte_stream_size )\newline	{\newline		*byte_stream_index += 1;\newline\newline		additional_character = byte_stream[ *byte_stream_index ];\newline\newline		if( ( byte_stream_character &gt= 0x81 )\newline		 &amp&amp ( byte_stream_character &lt= 0xa1 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0x81:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8140[ additional_character ];\newline						break;\newline\newline					case 0x82:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8240[ additional_character ];\newline						break;\newline\newline					case 0x83:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8340[ additional_character ];\newline						break;\newline\newline					case 0x84:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8440[ additional_character ];\newline						break;\newline\newline					case 0x85:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8540[ additional_character ];\newline						break;\newline\newline					case 0x86:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8640[ additional_character ];\newline						break;\newline\newline					case 0x87:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8740[ additional_character ];\newline						break;\newline\newline					case 0x88:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8840[ additional_character ];\newline						break;\newline\newline					case 0x89:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8940[ additional_character ];\newline						break;\newline\newline					case 0x8a:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8a40[ additional_character ];\newline						break;\newline\newline					case 0x8b:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8b40[ additional_character ];\newline						break;\newline\newline					case 0x8c:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8c40[ additional_character ];\newline						break;\newline\newline					case 0x8d:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8d40[ additional_character ];\newline						break;\newline\newline					case 0x8e:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8e40[ additional_character ];\newline						break;\newline\newline					case 0x8f:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x8f40[ additional_character ];\newline						break;\newline\newline					case 0x90:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9040[ additional_character ];\newline						break;\newline\newline					case 0x91:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9140[ additional_character ];\newline						break;\newline\newline					case 0x92:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9240[ additional_character ];\newline						break;\newline\newline					case 0x93:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9340[ additional_character ];\newline						break;\newline\newline					case 0x94:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9440[ additional_character ];\newline						break;\newline\newline					case 0x95:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9540[ additional_character ];\newline						break;\newline\newline					case 0x96:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9640[ additional_character ];\newline						break;\newline\newline					case 0x97:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9740[ additional_character ];\newline						break;\newline\newline					case 0x98:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9840[ additional_character ];\newline						break;\newline\newline					case 0x99:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9940[ additional_character ];\newline						break;\newline\newline					case 0x9a:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9a40[ additional_character ];\newline						break;\newline\newline					case 0x9b:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9b40[ additional_character ];\newline						break;\newline\newline					case 0x9c:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9c40[ additional_character ];\newline						break;\newline\newline					case 0x9d:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9d40[ additional_character ];\newline						break;\newline\newline					case 0x9e:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9e40[ additional_character ];\newline						break;\newline\newline					case 0x9f:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0x9f40[ additional_character ];\newline						break;\newline\newline					case 0xa0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa040[ additional_character ];\newline						break;\newline\newline					case 0xa1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa140[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa2 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xe8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa240[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xa3 )\newline		      &amp&amp ( byte_stream_character &lt= 0xa4 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xa3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa340[ additional_character ];\newline						break;\newline\newline					case 0xa4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa440[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa5 )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa540[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa6 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xe8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa640[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xa7 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xf0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa740[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xa8 )\newline		      &amp&amp ( byte_stream_character &lt= 0xa9 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xa8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa840[ additional_character ];\newline						break;\newline\newline					case 0xa9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xa940[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xaa )\newline		      &amp&amp ( byte_stream_character &lt= 0xab ) )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xf8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xaa:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xaa40[ additional_character ];\newline						break;\newline\newline					case 0xab:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xab40[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xac )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xc8 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xac40[ additional_character ];\newline			}\newline			else if( ( additional_character &gt= 0xd0 )\newline			      &amp&amp ( additional_character &lt 0xf8 ) )\newline			{\newline				additional_character -= 0xd0;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xacd0[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xad )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xad40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xcdc5;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xae )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xae40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xce2b;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xaf )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0xa0 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xaf40[ additional_character ];\newline			}\newline			else if( additional_character == 0xa0 )\newline			{\newline				*unicode_character = 0xce99;\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xb0 )\newline		      &amp&amp ( byte_stream_character &lt= 0xc5 ) )\newline		{\newline			if( additional_character &gt= 0x40 )\newline			{\newline				additional_character -= 0x40;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xb0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb040[ additional_character ];\newline						break;\newline\newline					case 0xb1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb140[ additional_character ];\newline						break;\newline\newline					case 0xb2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb240[ additional_character ];\newline						break;\newline\newline					case 0xb3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb340[ additional_character ];\newline						break;\newline\newline					case 0xb4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb440[ additional_character ];\newline						break;\newline\newline					case 0xb5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb540[ additional_character ];\newline						break;\newline\newline					case 0xb6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb640[ additional_character ];\newline						break;\newline\newline					case 0xb7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb740[ additional_character ];\newline						break;\newline\newline					case 0xb8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb840[ additional_character ];\newline						break;\newline\newline					case 0xb9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xb940[ additional_character ];\newline						break;\newline\newline					case 0xba:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xba40[ additional_character ];\newline						break;\newline\newline					case 0xbb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbb40[ additional_character ];\newline						break;\newline\newline					case 0xbc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbc40[ additional_character ];\newline						break;\newline\newline					case 0xbd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbd40[ additional_character ];\newline						break;\newline\newline					case 0xbe:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbe40[ additional_character ];\newline						break;\newline\newline					case 0xbf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xbf40[ additional_character ];\newline						break;\newline\newline					case 0xc0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc040[ additional_character ];\newline						break;\newline\newline					case 0xc1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc140[ additional_character ];\newline						break;\newline\newline					case 0xc2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc240[ additional_character ];\newline						break;\newline\newline					case 0xc3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc340[ additional_character ];\newline						break;\newline\newline					case 0xc4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc440[ additional_character ];\newline						break;\newline\newline					case 0xc5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc540[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( byte_stream_character == 0xc6 )\newline		{\newline			if( ( additional_character &gt= 0x40 )\newline			 &amp&amp ( additional_character &lt 0x58 ) )\newline			{\newline				additional_character -= 0x40;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc640[ additional_character ];\newline			}\newline			else if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc6a0[ additional_character ];\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xc7 )\newline		      &amp&amp ( byte_stream_character &lt= 0xc8 ) )\newline		{\newline			if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xc7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc7a0[ additional_character ];\newline						break;\newline\newline					case 0xc8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xc8a0[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else if( ( byte_stream_character &gt= 0xca )\newline		      &amp&amp ( byte_stream_character &lt= 0xfd ) )\newline		{\newline			if( additional_character &gt= 0xa0 )\newline			{\newline				additional_character -= 0xa0;\newline\newline				switch( byte_stream_character )\newline				{\newline					case 0xca:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcaa0[ additional_character ];\newline						break;\newline\newline					case 0xcb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcba0[ additional_character ];\newline						break;\newline\newline					case 0xcc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcca0[ additional_character ];\newline						break;\newline\newline					case 0xcd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcda0[ additional_character ];\newline						break;\newline\newline					case 0xce:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcea0[ additional_character ];\newline						break;\newline\newline					case 0xcf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xcfa0[ additional_character ];\newline						break;\newline\newline					case 0xd0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd0a0[ additional_character ];\newline						break;\newline\newline					case 0xd1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd1a0[ additional_character ];\newline						break;\newline\newline					case 0xd2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd2a0[ additional_character ];\newline						break;\newline\newline					case 0xd3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd3a0[ additional_character ];\newline						break;\newline\newline					case 0xd4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd4a0[ additional_character ];\newline						break;\newline\newline					case 0xd5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd5a0[ additional_character ];\newline						break;\newline\newline					case 0xd6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd6a0[ additional_character ];\newline						break;\newline\newline					case 0xd7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd7a0[ additional_character ];\newline						break;\newline\newline					case 0xd8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd8a0[ additional_character ];\newline						break;\newline\newline					case 0xd9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xd9a0[ additional_character ];\newline						break;\newline\newline					case 0xda:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdaa0[ additional_character ];\newline						break;\newline\newline					case 0xdb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdba0[ additional_character ];\newline						break;\newline\newline					case 0xdc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdca0[ additional_character ];\newline						break;\newline\newline					case 0xdd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdda0[ additional_character ];\newline						break;\newline\newline					case 0xde:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdea0[ additional_character ];\newline						break;\newline\newline					case 0xdf:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xdfa0[ additional_character ];\newline						break;\newline\newline					case 0xe0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe0a0[ additional_character ];\newline						break;\newline\newline					case 0xe1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe1a0[ additional_character ];\newline						break;\newline\newline					case 0xe2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe2a0[ additional_character ];\newline						break;\newline\newline					case 0xe3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe3a0[ additional_character ];\newline						break;\newline\newline					case 0xe4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe4a0[ additional_character ];\newline						break;\newline\newline					case 0xe5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe5a0[ additional_character ];\newline						break;\newline\newline					case 0xe6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe6a0[ additional_character ];\newline						break;\newline\newline					case 0xe7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe7a0[ additional_character ];\newline						break;\newline\newline					case 0xe8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe8a0[ additional_character ];\newline						break;\newline\newline					case 0xe9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xe9a0[ additional_character ];\newline						break;\newline\newline					case 0xea:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeaa0[ additional_character ];\newline						break;\newline\newline					case 0xeb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeba0[ additional_character ];\newline						break;\newline\newline					case 0xec:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeca0[ additional_character ];\newline						break;\newline\newline					case 0xed:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeda0[ additional_character ];\newline						break;\newline\newline					case 0xee:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xeea0[ additional_character ];\newline						break;\newline\newline					case 0xef:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xefa0[ additional_character ];\newline						break;\newline\newline					case 0xf0:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf0a0[ additional_character ];\newline						break;\newline\newline					case 0xf1:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf1a0[ additional_character ];\newline						break;\newline\newline					case 0xf2:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf2a0[ additional_character ];\newline						break;\newline\newline					case 0xf3:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf3a0[ additional_character ];\newline						break;\newline\newline					case 0xf4:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf4a0[ additional_character ];\newline						break;\newline\newline					case 0xf5:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf5a0[ additional_character ];\newline						break;\newline\newline					case 0xf6:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf6a0[ additional_character ];\newline						break;\newline\newline					case 0xf7:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf7a0[ additional_character ];\newline						break;\newline\newline					case 0xf8:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf8a0[ additional_character ];\newline						break;\newline\newline					case 0xf9:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xf9a0[ additional_character ];\newline						break;\newline\newline					case 0xfa:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfaa0[ additional_character ];\newline						break;\newline\newline					case 0xfb:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfba0[ additional_character ];\newline						break;\newline\newline					case 0xfc:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfca0[ additional_character ];\newline						break;\newline\newline					case 0xfd:\newline						*unicode_character = libuna_codepage_windows_949_byte_stream_to_unicode_base_0xfda0[ additional_character ];\newline						break;\newline				}\newline			}\newline			else\newline			{\newline				*unicode_character = 0xfffd;\newline			}\newline		}\newline		else\newline		{\newline			*unicode_character = 0xfffd;\newline		}\newline	}\newline	else\newline	{\newline		*unicode_character = 0xfffd;\newline	}\newline	*byte_stream_index += 1;\newline\newline	return( 1 );\newline}\newline","Copies a Unicode character from a byte stream\newline Returns 1 if successful or -1 on error\newline \newline","3616639","esdlib.c","int esd_close( int esd )\newline{\newline    /* diagnostic info */\newline    /*\newline    if ( getenv( &quotESDBG&quot ) )\newline	printf( &quotesound closing\\n&quot );\newline    */\newline\newline    return close( esd );\newline}\newline","closes fd, previously obtained by esd_open \newline","4284132","shfile.c","static int shfile_copy_insert_and_close(shfdtab *pfdtab, int *pnative, unsigned oflags, unsigned shflags, int fdMin, const char *who)\newline{\newline    int fd          = -1;\newline    int s           = errno;\newline    int native_copy = fcntl(*pnative, F_DUPFD, SHFILE_UNIX_MIN_FD);\newline    close(*pnative);\newline    *pnative = -1;\newline    errno = s;\newline\newline    if (native_copy != -1)\newline        fd = shfile_insert(pfdtab, native_copy, oflags, shflags, fdMin, who);\newline    return fd;\newline}\newline","\newline Makes a copy of the native file, closes the original, and inserts the copy\newline into the descriptor table.\newline \newline If we&#039re out of memory and cannot extend the table, we&#039ll close the\newline file, set errno to EMFILE and return -1.\newline \newline @returns The file descriptor number. -1 and errno on failure.\newline @param pfdtab The file descriptor table.\newline @param pnative The native file handle on input, -1 on output.\newline @param oflags The flags the it was opened/created with.\newline @param shflags The shell file flags.\newline @param fdMin The minimum file descriptor number, pass -1 if any is ok.\newline @param who Who we&#039re doing this for (for logging purposes).\newline \newline","3369240","extrainfo.cpp","void QDesignerExtraInfoExtension::setWorkingDirectory(const QString &ampworkingDirectory)\newline{\newline    m_workingDirectory = workingDirectory;\newline}\newline","!\newlineSets the path to the working directory used by the extension to \\a workingDirectory. \newline","674302","setup.c","static int keyslot_verify_or_find_empty(struct crypt_device *cd, int *keyslot)\newline{\newline	if (*keyslot == CRYPT_ANY_SLOT) {\newline		*keyslot = LUKS_keyslot_find_empty(&ampcd-&gtu.luks1.hdr);\newline		if (*keyslot &lt 0) {\newline			log_err(cd, _(&quotAll key slots full.\\n&quot));\newline			return -EINVAL;\newline		}\newline	}\newline\newline	switch (LUKS_keyslot_info(&ampcd-&gtu.luks1.hdr, *keyslot)) {\newline		case CRYPT_SLOT_INVALID:\newline			log_err(cd, _(&quotKey slot %d is invalid, please select between 0 and %d.\\n&quot),\newline				*keyslot, LUKS_NUMKEYS - 1);\newline			return -EINVAL;\newline		case CRYPT_SLOT_INACTIVE:\newline			break;\newline		default:\newline			log_err(cd, _(&quotKey slot %d is full, please select another one.\\n&quot),\newline				*keyslot);\newline			return -EINVAL;\newline	}\newline\newline	return 0;\newline}\newline","keyslot helpers \newline","2166239","eft.c","static void set_default_address(struct eft * eft)\newline{\newline	char hostname[TDU_PLEN_ADDR+1];\newline	struct hostent *phinfo;\newline	\newline	if (0 == gethostname(hostname, sizeof(hostname))) {\newline		phinfo = gethostbyname(hostname);\newline		if (NULL == phinfo) {\newline			herror(hostname);\newline			}\newline		else {\newline			eft_set_address(eft, phinfo-&gth_name);\newline			/* FIXME: user defineable log mask isn&#039t read until now */			\newline			tdu_printf(TDU_LOG_LOG, &quotaddress set to \\&quot%s\\&quot initially\\n&quot, eft-&gtaddress);\newline			}\newline		}\newline	else\newline		perror(&quotgethostname&quot);\newline}\newline","\newline Set the default address of the eft instance\newline (contributed by Matthias Stolte &ltms@msdatec.de&gt; slightly modified)\newline \newline","489487","device.c","static int pic14_isShared(int low, int high)\newline{\newline	memRange *r;\newline\newline	assert(pic);\newline	r = pic-&gtram;\newline\newline	while (r) {\newline	    //fprintf (stderr, &quot%s: region %x..%x, bank %x, alias %x, pic-&gtbankmask %x\\n&quot, __FUNCTION__, r-&gtstart_address, r-&gtend_address, r-&gtbank, r-&gtalias, pic-&gtbankMask);\newline	    if ((r-&gtalias == pic-&gtbankMask) &amp&amp (r-&gtstart_address &lt= low) &amp&amp (r-&gtend_address &gt= high)) {\newline		return 1;\newline	    } // if\newline	    r = r-&gtnext;\newline	} // while\newline\newline	return 0;\newline}\newline","\newline True iff the memory region [low, high] is aliased in all banks.\newline \newline","4319496","iso_img.c","static int Xorriso_register_eltorito_gpt(struct XorrisO *xorriso,\newline                                         struct elto_img_par *et_img,\newline                                         int ptype,\newline                                         int *efi_boot_part, int *first_efi,\newline                                         int flag)\newline{\newline if(flag &amp 1) {\newline   if(ptype == 1 || ptype == 3)\newline     et_img-&gtdo_gpt_basdat= 1;\newline   else if(ptype == 2)\newline     et_img-&gtdo_gpt_hfsplus= 1;\newline   return(1);\newline } else if(*first_efi &amp&amp et_img-&gtplatform_id == 0xef) {\newline   *efi_boot_part= 1;\newline   return(1);\newline }\newline if(et_img-&gtplatform_id == 0xef)\newline   *first_efi= 0;\newline return(0);\newline}\newline","@param ptype 0= unknown, 1= gpt-basdat, 2=gpt-hfsplus, 3=EFI\newline@param flag bit0= isohybrid\newline \newline","1001888","sb16ctrl.c","void checkemulator()\newline{\newline  int i;\newline\newline  checked = 1;\newline\newline  enableport();\newline\newline  /* Check emulator status */\newline  for (i=0; i&lt9; i++)\newline    writeemul(1);          /* Clear input queue */\newline  writeemul(10);           /* Check Emulator present */\newline  testemul(254, &quotno check ACK: Emulator not present&quot);\newline  testemul(0x55, &quotEmulator not present&quot);    /* should return 0x55 */\newline}\newline","Check if we are running inside the emulator \newline","5974934","gd.c","BGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)\newline{\newline	int i;\newline	long rd, gd, bd, ad;\newline	int ct = (-1);\newline	int first = 1;\newline	long mindist = 0;\newline	if (im-&gttrueColor) {\newline		return gdTrueColorAlpha (r, g, b, a);\newline	}\newline	for (i = 0; (i &lt (im-&gtcolorsTotal)); i++) {\newline		long dist;\newline		if (im-&gtopen[i]) {\newline			continue;\newline		}\newline		rd = (im-&gtred[i] - r);\newline		gd = (im-&gtgreen[i] - g);\newline		bd = (im-&gtblue[i] - b);\newline		/* gd 2.02: whoops, was - b (thanks to David Marwood) */\newline		/* gd 2.16: was blue rather than alpha! Geez! Thanks to\newline		   Artur Jakub Jerzak */\newline		ad = (im-&gtalpha[i] - a);\newline		dist = rd * rd + gd * gd + bd * bd + ad * ad;\newline		if (first || (dist &lt mindist)) {\newline			mindist = dist;\newline			ct = i;\newline			first = 0;\newline		}\newline	}\newline	return ct;\newline}\newline","\newline Function: gdImageColorClosestAlpha\newline \newline Gets the closest color of the image\newline \newline Parameters:\newline im - The image.\newline r - The value of the red component.\newline g - The value of the green component.\newline b - The value of the blue component.\newline a - The value of the alpha component.\newline \newline Returns:\newline The closest color already available in the palette for palette images;\newline the color value of the given components for truecolor images.\newline \newline See also:\newline - &ltgdImageColorExactAlpha&gt\newline \newline","5746884","editstate.c","void editstate_displayPathString(EditState *cur_es)\newline{\newline  EditState *estack[MAX_STACKDEPTH];\newline  EditState *es;\newline  char path[STRMAX],*p;\newline  int esp,i;\newline\newline  es = cur_es;\newline  for (esp = 0;esp &lt MAX_STACKDEPTH &amp&amp es;es = es-&gtparent)\newline    estack[esp++] = es;\newline\newline  p = path;\newline  sprintf(p,&quot/&quot);\newline  p = p + strlen(p);\newline\newline  DoTcl(&quotcatch { unset tkg_pathInstance }&quot);\newline  for (i = esp-1;i &gt= 0;i--) {\newline    if (i != esp-1) *p++ = &#039/&#039;\newline    if (estack[i]-&gtinst) {\newline      DoTcl(&quotset ::tkg_pathInstance(%s) \\&quot (%s)\\&quot&quot,estack[i]-&gtenv-&gtm_name,estack[i]-&gtinst-&gtename);\newline    } else {\newline      DoTcl(&quotset ::tkg_pathInstance(%s) \\&quot\\&quot&quot,estack[i]-&gtenv-&gtm_name);\newline    }\newline    strcpy(p,estack[i]-&gtenv-&gtm_name);\newline    p = p + strlen(p);\newline  }\newline\newline  if (TkGate.tcl) {\newline    Tcl_SetVar(TkGate.tcl,&quottkg_currentPath&quot,path,TCL_GLOBAL_ONLY); \newline    Tcl_SetVar(TkGate.tcl,&quottkg_currentModule&quot,cur_es-&gtenv-&gtm_name,TCL_GLOBAL_ONLY);\newline  }\newline}\newline","\newline Set the tkg_currentPath and tkg_currentModule variables\newline \newline","1253504","pass2.c","static void fix_dirent_lengths(struct ocfs2_dir_entry *dirent,\newline			       int left, struct ocfs2_dir_entry *prev,\newline			       unsigned int *flags)\newline{\newline	/* \newline	 * as described above we can&#039t reconstruct either value if it is\newline	 * complete nonsense.  We can only proceed if we can work off of\newline	 * one that is kind of valid looking.\newline	 * name_len could well be 0 from the dirent being cleared.\newline	 */\newline	if (dirent-&gtrec_len &lt OCFS2_DIR_MEMBER_LEN ||\newline	   (dirent-&gtrec_len &gt left ||\newline	    dirent-&gtname_len &gt left))\newline	    goto wipe;\newline\newline	/* if we see a dirent with no file name then we remove it by\newline	 * shifting the remaining dirents forward */\newline	if ((dirent-&gtrec_len == OCFS2_DIR_MEMBER_LEN)) {\newline		char *cp = (char *)dirent;\newline		left -= dirent-&gtrec_len;\newline		memmove(cp, cp + dirent-&gtrec_len, left);\newline		memset(cp + left, 0, dirent-&gtrec_len);\newline		goto out;\newline	}\newline\newline	/* if rec_len just appears to be mis-rounded in a way that doesn&#039t\newline	 * affect following dirents then we can probably save this dirent */\newline	if (OCFS2_DIR_REC_LEN(dirent-&gtname_len) != dirent-&gtrec_len &amp&amp\newline	    OCFS2_DIR_REC_LEN(dirent-&gtname_len) == \newline					OCFS2_DIR_REC_LEN(dirent-&gtrec_len)) {\newline		dirent-&gtrec_len = OCFS2_DIR_REC_LEN(dirent-&gtname_len);\newline		left -= dirent-&gtrec_len;\newline		goto out;\newline	}\newline\newline	/* if name_len is too far off, however, we&#039re going to lose this\newline	 * dirent.. we might be able to just lose this one dirent if rec_len\newline	 * appears to be intact. */\newline	if ((dirent-&gtrec_len &amp OCFS2_DIR_ROUND) == 0 &amp&amp\newline	    !dirent_leaves_partial(dirent, left)) {\newline		left -= dirent-&gtrec_len;\newline		dirent-&gtname_len = 0;\newline		dirent-&gtinode = 0;\newline		dirent-&gtfile_type = OCFS2_FT_UNKNOWN;\newline		goto out;\newline	}\newline\newline	/* \newline	 * if we can&#039t trust rec_len, however, then we don&#039t know where the\newline	 * next dirent might begin.  We&#039ve lost the trail of dirents created by\newline	 * the file system and run the risk of parsing file names as dirents.\newline	 * So we&#039re forced to wipe the block and leave the rest to lost+found.\newline	 */\newlinewipe:\newline	dirent-&gtrec_len = left;\newline	dirent-&gtname_len = 0;\newline	dirent-&gtinode = 0;\newline	dirent-&gtfile_type = OCFS2_FT_UNKNOWN;\newline	left = 0;\newlineout:\newline\newline	/* \newline	 * rec_len must be valid and left must reflect the space *after* the\newline	 * current dirent by this point.  if there isn&#039t enough room for\newline	 * another dirent after the one we&#039ve just repaired then we tack the\newline	 * remaining space onto the current dirent.\newline	 */\newline	if (dirent_leaves_partial(dirent, left))\newline		dirent-&gtrec_len += left;\newline\newline	*flags |= OCFS2_DIRENT_CHANGED;\newline}\newline","\newline The caller has found that either of rec_len or name_len are garbage. The\newline caller trusts us to fix them up in place and will be checking them again\newline before proceeding. We have to update the lengths to make forward progress.\newline &#039left&#039 is the number of bytes from the start of this dirent struct that\newline remain in the block. \newline \newline We&#039re called for invalid dirents, and having a dirent\newline that leaves a partial dirent at the end of the block is considered invalid,\newline and we pad out partials at the end of this call so we can&#039t be called here\newline with left &lt OCFS2_DIR_MEMBER_LEN.\newline \newline we&#039re pretty limited in the repairs we can make:\newline \newline - We can&#039t just set name_len if rec_len looks valid, we might guess \newline name_len wrong and create a bogus file name.\newline - we can&#039t just set rec_len based on name_len. rec_len could have\newline included an arbitrary part of the name from a previously freed dirent.\newline \newline","4206734","w32log.c","HWND CreateHiddenLogOwnerWindow(HINSTANCE hInstance)\newline{\newline   static const char *szWndName = &quotPrivoxyLogOwner&quot;\newline   WNDCLASS wc;\newline   HWND hwnd;\newline\newline   wc.style          = 0;\newline   wc.lpfnWndProc    = LogOwnerWindowProc;\newline   wc.cbClsExtra     = 0;\newline   wc.cbWndExtra     = 0;\newline   wc.hInstance      = hInstance;\newline   wc.hIcon          = g_hiconApp;\newline   wc.hCursor        = 0;\newline   wc.hbrBackground  = 0;\newline   wc.lpszMenuName   = 0;\newline   wc.lpszClassName  = szWndName;\newline\newline   RegisterClass(&ampwc);\newline\newline   hwnd = CreateWindow(szWndName, szWndName,\newline      WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\newline      CW_USEDEFAULT, NULL, NULL, hInstance, NULL);\newline\newline   return hwnd;\newline\newline}\newline","\newline \newline Function : CreateHiddenLogOwnerWindow\newline \newline Description : Creates a hidden owner window that stops the log\newline window appearing in the task bar.\newline \newline Parameters :\newline 1 : hInstance = application&#039s instance handle\newline \newline Returns : Handle to newly created window.\newline \newline \newline","","","","","on","","on","on","","","","","","","on","","on","","","","","","","on","on","","","","","","","","","","on","","on","","","","","","reset the input buffer to empty.","closes fd, previously obtained by esd_open","Makes a copy of the native file, closes the original, and inserts","Sets the path to the working directory used by the extension to","{}","Set the default address of the eft instance","{}","{}","Check if we are running inside the emulator","Gets the closest color of the image","Set the tkg_currentPath and tkg_currentModule variables","Recieves and handles a group leave message.","invalid dirents,","Creates a hidden owner window that stops the logwindow appearing in","{}","Generate an ascii representation of the given key","{}","the module name isprepended to the instance name.","adjusts the modifiers according to mod (as from modifiers) and data->modifierState","Set the login details","Copies a Unicode character from a byte stream"
"3EHIMLB7F7Z0IFFLHAARP6WKE3ZH8Y","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3SB5N7Y3O346NEC0S2KV0AAQWU30GU","A3SYA8EDAEOOF7","Approved","Wed Apr 17 16:03:51 PDT 2019","Wed Apr 17 16:17:06 PDT 2019","Fri Apr 19 16:17:06 PDT 2019","2019-04-19 23:17:24 UTC","","","795","100% (17/17)","100% (17/17)","100% (17/17)","5793885","eng_main.c","void eng_pic_showarg(eng_obj *o)  {\newline\newline	if(!o)  return;\newline\newline	fprintf(stdout, &quot== PIC ==\\n&quot);\newline	fprintf(stdout, &quot  show          -&gt %d\\n&quot, o-&gtshow);\newline	fprintf(stdout, &quot  x             -&gt %d\\n&quot, o-&gtx);\newline	fprintf(stdout, &quot  y             -&gt %d\\n&quot, o-&gty);\newline	fprintf(stdout, &quot  z             -&gt %d\\n&quot, o-&gtz);\newline	fprintf(stdout, &quot  width         -&gt %d\\n&quot, o-&gtwidth);\newline	fprintf(stdout, &quot  height        -&gt %d\\n&quot, o-&gtheight);\newline	fprintf(stdout, &quot  have_alpha    -&gt %d\\n&quot, o-&gthave_alpha);\newline	fprintf(stdout, &quot  have_bgcolor  -&gt %d\\n&quot, o-&gthave_bgcolor);\newline	fprintf(stdout, &quot  alpha         -&gt %d\\n&quot, o-&gtalpha);\newline	fprintf(stdout, &quot  bgcolor[R]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[0]);\newline	fprintf(stdout, &quot  bgcolor[G]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[1]);\newline	fprintf(stdout, &quot  bgcolor[B]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[2]);\newline	fprintf(stdout, &quot  ------\\n&quot);\newline	fprintf(stdout, &quot  change        -&gt %d\\n&quot, o-&gtchange);\newline	fprintf(stdout, &quot  x old         -&gt %d\\n&quot, o-&gtx_old);\newline	fprintf(stdout, &quot  y old         -&gt %d\\n&quot, o-&gty_old);\newline	fprintf(stdout, &quot  width old     -&gt %d\\n&quot, o-&gtwidth_old);\newline	fprintf(stdout, &quot  height old    -&gt %d\\n&quot, o-&gtheight_old);\newline	fprintf(stdout, &quot  ------\\n&quot);\newline	if(eng_pic_test(o) )\newline	fprintf(stdout, &quot  test      -&gt SUCCESS\\n&quot);\newline	else\newline	fprintf(stdout, &quot  test      -&gt ERROR\\n&quot);\newline	fprintf(stdout, &quot====================\\n&quot);\newline}\newline","---- put in terminal all arguments of a pic \newline","502883","qcustomplot.cpp","void QCPLayout::releaseElement(QCPLayoutElement *el)\newline{\newline  if (el)\newline  {\newline    el-&gtmParentLayout = 0;\newline    el-&gtsetParentLayerable(0);\newline    el-&gtsetParent(mParentPlot);\newline    // Note: Don&#039t initializeParentPlot(0) here, because layout element will stay in same parent plot\newline  } else\newline    qDebug() &lt&lt Q_FUNC_INFO &lt&lt &quotNull element passed&quot;\newline}\newline","! \\internal\newline\newlineDisassociates \\a el from this layout. This is done by setting the \\ref QCPLayoutElement::layout\newlineand the \\ref QCPLayerable::parentLayerable to zero. The QObject parent is set to the parent\newlineQCustomPlot.\newline\newlineThis method is used by subclass specific methods that remove elements from the layout (e.g. \\ref\newlinetake or \\ref takeAt). Note that this method only changes properties in \\a el. The removal from\newlinethe old layout must be done additionally.\newline \newline","2924850","graphobject.c","PyObject *igraphmodule_Graph_get_shortest_paths(igraphmodule_GraphObject *\newline                                                self, PyObject * args,\newline                                                PyObject * kwds)\newline{\newline  static char *kwlist[] = { &quotv&quot, &quotto&quot, &quotweights&quot, &quotmode&quot, &quotoutput&quot, NULL };\newline  igraph_vector_t *res, *weights=0;\newline  igraph_neimode_t mode = IGRAPH_OUT;\newline  long int i, j;\newline  igraph_integer_t from, no_of_target_nodes;\newline  igraph_vs_t to;\newline  PyObject *list, *item, *mode_o=Py_None, *weights_o=Py_None,\newline           *output_o=Py_None, *from_o = Py_None, *to_o=Py_None;\newline  igraph_vector_ptr_t *ptrvec=0;\newline  igraph_bool_t use_edges = 0;\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quotO|OOOO!&quot, kwlist, &ampfrom_o,\newline        &ampto_o, &ampweights_o, &ampmode_o, &ampPyString_Type, &ampoutput_o))\newline    return NULL;\newline\newline  if (output_o == 0 || output_o == Py_None ||\newline      PyString_IsEqualToASCIIString(output_o, &quotvpath&quot)) {\newline    use_edges = 0;\newline  } else if (PyString_IsEqualToASCIIString(output_o, &quotepath&quot)) {\newline    use_edges = 1;\newline  } else {\newline    PyErr_SetString(PyExc_ValueError, &quotoutput argument must be \\&quotvpath\\&quot or \\&quotepath\\&quot&quot);\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_PyObject_to_vid(from_o, &ampfrom, &ampself-&gtg))\newline    return NULL;\newline\newline  if (igraphmodule_PyObject_to_neimode_t(mode_o, &ampmode))\newline    return NULL;\newline  \newline  if (igraphmodule_attrib_to_vector_t(weights_o, self, &ampweights,\newline      ATTRIBUTE_TYPE_EDGE)) return NULL;\newline\newline  if (igraphmodule_PyObject_to_vs_t(to_o, &ampto, &ampself-&gtg, 0, 0)) {\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    return NULL;\newline  }\newline\newline  if (igraph_vs_size(&ampself-&gtg, &ampto, &ampno_of_target_nodes)) {\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline\newline  ptrvec = (igraph_vector_ptr_t *) calloc(1, sizeof(igraph_vector_ptr_t));\newline  if (!ptrvec) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  if (igraph_vector_ptr_init(ptrvec, no_of_target_nodes)) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  res = (igraph_vector_t *) calloc(no_of_target_nodes, sizeof(igraph_vector_t));\newline  if (!res) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  for (i = 0; i &lt no_of_target_nodes; i++) {\newline    VECTOR(*ptrvec)[i] = &ampres[i];\newline    igraph_vector_init(&ampres[i], 0);\newline  }\newline\newline  if (igraph_get_shortest_paths_dijkstra(&ampself-&gtg, use_edges ? 0 : ptrvec,\newline        use_edges ? ptrvec : 0, from, to, weights, mode, 0, 0)) {\newline    igraphmodule_handle_igraph_error();\newline    for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline    free(res);\newline    igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline  if (weights) { igraph_vector_destroy(weights); free(weights); }\newline  igraph_vs_destroy(&ampto);\newline\newline  list = PyList_New(no_of_target_nodes);\newline  if (!list) {\newline    for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline    free(res);\newline    return NULL;\newline  }\newline\newline  for (i = 0; i &lt no_of_target_nodes; i++) {\newline    item = igraphmodule_vector_t_to_PyList(&ampres[i], IGRAPHMODULE_TYPE_INT);\newline    if (!item || PyList_SetItem(list, i, item)) {\newline      if (item) {\newline        Py_DECREF(item);\newline      }\newline      Py_DECREF(list);\newline      for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline      free(res);\newline      return NULL;\newline    }\newline  }\newline\newline  for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline  free(res);\newline  return list;\newline}\newline","\\ingroup python_interface_graph\newline \\brief Calculates the shortest paths from/to a given node in the graph\newline \\return a list containing shortest paths from/to the given node\newline \\sa igraph_get_shortest_paths\newline \newline","1285285","context.c","msym_error_t msymGetElements(msym_context ctx, int *length, msym_element_t **elements){\newline    msym_error_t ret = MSYM_SUCCESS;\newline    msym_element_t *relements = NULL;\newline    if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}\newline    if(ctx-&gtelements == NULL) {ret = MSYM_INVALID_ELEMENTS;goto err;}\newline    if(ctx-&gtext.elements == NULL) ctx-&gtext.elements = malloc(sizeof(msym_element_t[ctx-&gtel]));\newline    if(ctx-&gtorbitals != NULL) {\newline        if(ctx-&gtext.orbitals == NULL) ctx-&gtext.orbitals = malloc(sizeof(msym_orbital_t[ctx-&gtol]));\newline        memcpy(ctx-&gtext.orbitals,ctx-&gtorbitals,sizeof(msym_orbital_t[ctx-&gtol]));\newline    }\newline    if(ctx-&gtporbitals != NULL){\newline        if(ctx-&gtext.porbitals == NULL) ctx-&gtext.orbitals = calloc(ctx-&gtol,sizeof(msym_orbital_t*));\newline    }\newline    \newline    memcpy(ctx-&gtext.elements,ctx-&gtelements,sizeof(msym_element_t[ctx-&gtel]));\newline    msym_orbital_t **porb = ctx-&gtext.porbitals;\newline    for(msym_element_t *a = ctx-&gtext.elements; a &lt (ctx-&gtext.elements+ctx-&gtel); a++){\newline        vadd(a-&gtv,ctx-&gtcm,a-&gtv);\newline        for(int i = 0;i &lt a-&gtaol &amp&amp ctx-&gtext.orbitals != NULL &amp&amp porb != NULL;i++){\newline            porb[i] = a-&gtao[i] - ctx-&gtorbitals + ctx-&gtext.orbitals;\newline        }\newline        if(porb != NULL){\newline            a-&gtao = porb;\newline            porb += a-&gtaol;\newline        }\newline    }\newline    \newline    *elements = ctx-&gtext.elements;\newline    *length = ctx-&gtel;\newline    return ret;\newlineerr:\newline    free(relements);\newline    *elements = NULL;\newline    *length = 0;\newline    return ret;\newline}\newline","We don&#039t really need to copy this every time \newline","1886728","tccgen.c","static void parse_attribute(AttributeDef *ad)\newline{\newline    int t;\newline	long long n;\newline\newline    while (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2) {\newline    next();\newline    skip(&#039(&#039);\newline    skip(&#039(&#039);\newline    while (tok != &#039)&#039) {\newline        if (tok &lt TOK_IDENT)\newline            expect(&quotattribute name&quot);\newline        t = tok;\newline        next();\newline        switch(t) {\newline        case TOK_ALIAS1:\newline        case TOK_ALIAS2:\newline            skip(&#039(&#039);\newline            if (tok != TOK_STR)\newline                expect(&quotalias(\\&quottarget\\&quot)&quot);\newline            ad-&gtalias_target = /* save string as token, for later */\newline              tok_alloc((char*)tokc.cstr-&gtdata, tokc.cstr-&gtsize-1)-&gttok;\newline            next();\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_ALIGNED1:\newline        case TOK_ALIGNED2:\newline            if (tok == &#039(&#039) {\newline                next();\newline                n = expr_const();\newline                if (n &lt= 0 || (n &amp (n - 1)) != 0)\newline                    tcc_error(&quotalignment must be a positive power of two&quot);\newline                skip(&#039)&#039);\newline            } else {\newline                n = MAX_ALIGN;\newline            }\newline            ad-&gtaligned = n;\newline            break;\newline        case TOK_PACKED1:\newline        case TOK_PACKED2:\newline            ad-&gtpacked = 1;\newline            break;\newline        case TOK_WEAK1:\newline        case TOK_WEAK2:\newline            ad-&gtweak = 1;\newline            break;\newline        case TOK_UNUSED1:\newline        case TOK_UNUSED2:\newline            /* currently, no need to handle it because tcc does not\newline               track unused objects */\newline            break;\newline        case TOK_NORETURN1:\newline        case TOK_NORETURN2:\newline            /* currently, no need to handle it because tcc does not\newline               track unused objects */\newline            break;\newline        case TOK_CDECL1:\newline        case TOK_CDECL2:\newline        case TOK_CDECL3:\newline            ad-&gtfunc_call = FUNC_CDECL;\newline            break;\newline        case TOK_STDCALL1:\newline        case TOK_STDCALL2:\newline        case TOK_STDCALL3:\newline            ad-&gtfunc_call = FUNC_STDCALL;\newline            break;\newline#ifdef TCC_TARGET_I386\newline        case TOK_REGPARM1:\newline        case TOK_REGPARM2:\newline            skip(&#039(&#039);\newline            n = expr_const();\newline            if (n &gt 3)\newline                n = 3;\newline            else if (n &lt 0)\newline                n = 0;\newline            if (n &gt 0)\newline                ad-&gtfunc_call = FUNC_FASTCALL1 + n - 1;\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_FASTCALL1:\newline        case TOK_FASTCALL2:\newline        case TOK_FASTCALL3:\newline            ad-&gtfunc_call = FUNC_FASTCALLW;\newline            break;\newline#endif\newline        case TOK_MODE:\newline            skip(&#039(&#039);\newline            switch(tok) {\newline                case TOK_MODE_DI:\newline                    ad-&gtmode = VT_LLONG + 1;\newline                    break;\newline                case TOK_MODE_HI:\newline                    ad-&gtmode = VT_SHORT + 1;\newline                    break;\newline                case TOK_MODE_SI:\newline                    ad-&gtmode = VT_INT + 1;\newline                    break;\newline                default:\newline                    tcc_warning(&quot__mode__(%s) not supported\\n&quot, get_tok_str(tok, NULL));\newline                    break;\newline            }\newline            next();\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_DLLEXPORT:\newline            ad-&gtfunc_export = 1;\newline            break;\newline        case TOK_DLLIMPORT:\newline            ad-&gtfunc_import = 1;\newline            break;\newline        default:\newline            if (tcc_state-&gtwarn_unsupported)\newline                tcc_warning(&quot&#039%s&#039 attribute ignored&quot, get_tok_str(t, NULL));\newline            /* skip parameters */\newline            if (tok == &#039(&#039) {\newline                int parenthesis = 0;\newline                do {\newline                    if (tok == &#039(&#039)\newline                        parenthesis++;\newline                    else if (tok == &#039)&#039)\newline                        parenthesis--;\newline                    next();\newline                } while (parenthesis &amp&amp tok != -1);\newline            }\newline            break;\newline        }\newline        if (tok != &#039,&#039)\newline            break;\newline        next();\newline    }\newline    skip(&#039)&#039);\newline    skip(&#039)&#039);\newline    }\newline}\newline","Parse GNUC __attribute__ extension. Currently, the following\newlineextensions are recognized:\newline- aligned(n) : set data/function alignment.\newline- packed : force data alignment to 1\newline- unused : currently ignored, but may be used someday.\newline- regparm(n) : pass function parameters in registers (i386 only)\newline \newline","2759294","memory.c","int mem_dither(unsigned char *old, int ncols, short *dither, int cspace,\newline	int dist, int limit, int selc, int serpent, int rgb8b, double emult)\newline{\newline	int i, j, k, l, kk, j0, j1, dj, rlen, col0, col1, progress;\newline	unsigned char *ddata, *src, *dest;\newline	double *row0, *row1, *row2, *tmp;\newline	double err, intd, extd, *gamma6, *lin6;\newline	double tc0[3], tc1[3], color0[3], color1[3];\newline	double fdiv = 0, gamut[6] = {1, 1, 1, 0, 0, 0};\newline\newline	/* Allocate working space */\newline	rlen = (mem_width + 4) * 3 * sizeof(double);\newline	ddata = multialloc(MA_ALIGN_DOUBLE,\newline		&amprow0, rlen,\newline		&amprow1, rlen,\newline		&amprow2, rlen,\newline		&ampctp, sizeof(ctable),\newline		NULL);\newline	if (!ddata) return (1);\newline\newline	if ((progress = mem_width * mem_height &gt 1000000))\newline		progress_init(_(&quotConverting to Indexed Palette&quot), 0);\newline\newline	/* Preprocess palette to find whether to extend precision and where */\newline	for (i = 0; i &lt ncols; i++)\newline	{\newline		j = ((mem_pal[i].red &amp 0xFC) &lt&lt 10) +\newline			((mem_pal[i].green &amp 0xFC) &lt&lt 4) +\newline			(mem_pal[i].blue &gt&gt 2);\newline		if (!(l = ctp-&gtcmap[j]))\newline		{\newline			ctp-&gtcmap[j] = l = i + 1;\newline			ctp-&gtxcmap[l * 4 + 2] = j;\newline		}\newline		k = ((mem_pal[i].red &amp 3) &lt&lt 4) +\newline			((mem_pal[i].green &amp 3) &lt&lt 2) +\newline			(mem_pal[i].blue &amp 3);\newline		ctp-&gtxcmap[l * 4 + (k &amp 1)] |= 1 &lt&lt (k &gt&gt 1);\newline	}\newline	memset(ctp-&gtcmap, 0, 64 * 64 * 64);\newline	for (k = 0 , i = 4; i &lt 256 * 4; i += 4)\newline	{\newline		guint32 v = ctp-&gtxcmap[i] | ctp-&gtxcmap[i + 1];\newline		/* Are 2+ colors there somewhere? */\newline		if (!((v &amp (v - 1)) | (ctp-&gtxcmap[i] &amp ctp-&gtxcmap[i + 1])))\newline			continue;\newline		rgb8b = TRUE; /* Force 8-bit precision */\newline		j = ctp-&gtxcmap[i + 2];\newline		ctp-&gtlcmap[j &gt&gt 5] |= 1 &lt&lt (j &amp 31);\newline		ctp-&gtcmap[j] = k++;\newline	}\newline	memset(ctp-&gtxcmap, 0, 257 * 4 * sizeof(guint32));\newline\newline	/* Prepare tables */\newline	for (i = 0; i &lt 256; i++)\newline	{\newline		j = (i &amp 0xFC) + (i &gt&gt 6);\newline		ctp-&gtgamma[i] = gamma256[i];\newline		ctp-&gtgamma[i + 256] = gamma256[j];\newline		ctp-&gtlin[i] = i * (1.0 / 255.0);\newline		ctp-&gtlin[i + 256] = j * (1.0 / 255.0);\newline	}\newline	/* Keep all 8 bits of input or posterize to 6 bits? */\newline	i = rgb8b ? 0 : 256;\newline	gamma6 = ctp-&gtgamma + i; lin6 = ctp-&gtlin + i;\newline	tmp = ctp-&gtxyz256;\newline	for (i = 0; i &lt ncols; i++ , tmp += 3)\newline	{\newline		/* Update gamut limits */\newline		tmp[0] = gamma6[mem_pal[i].red];\newline		tmp[1] = gamma6[mem_pal[i].green];\newline		tmp[2] = gamma6[mem_pal[i].blue];\newline		for (j = 0; j &lt 3; j++)\newline		{\newline			if (tmp[j] &lt gamut[j]) gamut[j] = tmp[j];\newline			if (tmp[j] &gt gamut[j + 3]) gamut[j + 3] = tmp[j];\newline		}\newline		/* Store colour coords */\newline		switch (cspace)\newline		{\newline		default:\newline		case CSPACE_RGB:\newline			tmp[0] = lin6[mem_pal[i].red];\newline			tmp[1] = lin6[mem_pal[i].green];\newline			tmp[2] = lin6[mem_pal[i].blue];\newline			break;\newline		case CSPACE_SRGB:\newline			break; /* Done already */\newline		case CSPACE_LXN:\newline			rgb2LXN(tmp, tmp[0], tmp[1], tmp[2]);\newline			break;\newline		}\newline	}\newline	ctp-&gtcspace = cspace; ctp-&gtcdist = dist; ctp-&gtncols = ncols;\newline	serpent = serpent ? 0 : 2;\newline	if (dither) fdiv = 1.0 / *dither++;\newline\newline	/* Process image */\newline	for (i = 0; i &lt mem_height; i++)\newline	{\newline		src = old + i * mem_width * 3;\newline		dest = mem_img[CHN_IMAGE] + i * mem_width;\newline		memset(row2, 0, rlen);\newline		if (serpent ^= 1)\newline		{\newline			j0 = 0; j1 = mem_width * 3; dj = 1;\newline		}\newline		else\newline		{\newline			j0 = (mem_width - 1) * 3; j1 = -3; dj = -1;\newline			dest += mem_width - 1;\newline		}\newline		for (j = j0; j != j1; j += dj * 3)\newline		{\newline			for (k = 0; k &lt 3; k++)\newline			{\newline				/* Posterize to 6 bits as natural for palette */\newline				color0[k] = gamma6[src[j + k]];\newline				/* Add in error, maybe limiting it */\newline				err = row0[j + k + 6];\newline				if (limit == 1) /* To half of SRGB range */\newline				{\newline					err = err &lt -0.5 ? -0.5 :\newline						err &gt 0.5 ? 0.5 : err;\newline				}\newline				else if (limit == 2) /* To 1/4, with damping */\newline				{\newline					err = err &lt -0.1 ? (err &lt -0.4 ?\newline						-0.25 : 0.5 * err - 0.05) :\newline						err &gt 0.1 ? (err &gt 0.4 ?\newline						0.25 : 0.5 * err + 0.05) : err;\newline				}\newline				color1[k] = color0[k] + err;\newline				/* Limit result to palette gamut */\newline				if (color1[k] &lt gamut[k]) color1[k] = gamut[k];\newline				if (color1[k] &gt gamut[k + 3]) color1[k] = gamut[k + 3];\newline			}\newline			/* Output best colour */\newline			col1 = lookup_srgb(color1);\newline			*dest = col1;\newline			dest += dj;\newline			if (!dither) continue;\newline			/* Evaluate new error */\newline			tc1[0] = gamma6[mem_pal[col1].red];\newline			tc1[1] = gamma6[mem_pal[col1].green];\newline			tc1[2] = gamma6[mem_pal[col1].blue];\newline			if (selc) /* Selective error damping */\newline			{\newline				col0 = lookup_srgb(color0);\newline				tc0[0] = gamma6[mem_pal[col0].red];\newline				tc0[1] = gamma6[mem_pal[col0].green];\newline				tc0[2] = gamma6[mem_pal[col0].blue];\newline				/* Split error the obvious way */\newline				if (!(selc &amp 1) &amp&amp (col0 == col1))\newline				{\newline					color1[0] = (color1[0] - color0[0]) * emult +\newline						color0[0] - tc0[0];\newline					color1[1] = (color1[1] - color0[1]) * emult +\newline						color0[1] - tc0[1];\newline					color1[2] = (color1[2] - color0[2]) * emult +\newline						color0[2] - tc0[2];\newline				}\newline				/* Weigh component errors separately */\newline				else if (selc &lt 3)\newline				{\newline					for (k = 0; k &lt 3; k++)\newline					{\newline						intd = fabs(color0[k] - tc0[k]);\newline						extd = fabs(color0[k] - color1[k]);\newline						if (intd + extd == 0.0) err = 1.0;\newline						else err = (intd + emult * extd) / (intd + extd);\newline						color1[k] = err * (color1[k] - tc1[k]);\newline					}\newline				}\newline				/* Weigh errors by vector length */\newline				else\newline				{\newline					intd = sqrt((color0[0] - tc0[0]) * (color0[0] - tc0[0]) +\newline						(color0[1] - tc0[1]) * (color0[1] - tc0[1]) +\newline						(color0[2] - tc0[2]) * (color0[2] - tc0[2]));\newline					extd = sqrt((color0[0] - color1[0]) * (color0[0] - color1[0]) +\newline						(color0[1] - color1[1]) * (color0[1] - color1[1]) +\newline						(color0[2] - color1[2]) * (color0[2] - color1[2]));\newline					if (intd + extd == 0.0) err = 1.0;\newline					else err = (intd + emult * extd) / (intd + extd);\newline					color1[0] = err * (color1[0] - tc1[0]);\newline					color1[1] = err * (color1[1] - tc1[1]);\newline					color1[2] = err * (color1[2] - tc1[2]);\newline				}\newline			}\newline			else /* Indiscriminate error damping */\newline			{\newline				color1[0] = (color1[0] - tc1[0]) * emult;\newline				color1[1] = (color1[1] - tc1[1]) * emult;\newline				color1[2] = (color1[2] - tc1[2]) * emult;\newline			}\newline			/* Distribute the error */\newline			color1[0] *= fdiv;\newline			color1[1] *= fdiv;\newline			color1[2] *= fdiv;\newline			for (k = 0; k &lt 5; k++)\newline			{\newline				kk = j + (k - 2) * dj * 3 + 6;\newline				for (l = 0; l &lt 3; l++ , kk++)\newline				{\newline					row0[kk] += color1[l] * dither[k];\newline					row1[kk] += color1[l] * dither[k + 5];\newline					row2[kk] += color1[l] * dither[k + 10];\newline				}\newline			}\newline		}\newline		tmp = row0; row0 = row1; row1 = row2; row2 = tmp;\newline		if (progress &amp&amp (i * 10) % mem_height &gt= mem_height - 10)\newline			progress_update((float)(i + 1) / mem_height);\newline	}\newline\newline	if (progress) progress_end();\newline	free(ddata);\newline	return (0);\newline}\newline","Damping functions roughly resemble old GIMP&#039s behaviour, but may need some\newline tuning because linear sRGB is just too different from normal RGB \newline","6484447","mem.c","void *mem_calloc(mem_size_t count, mem_size_t size)\newline{\newline  void *p;\newline\newline  /* allocate &#039count&#039 objects of size &#039size&#039 */\newline  p = mem_malloc(count * size);\newline  if (p) {\newline    /* zero the memory */\newline    memset(p, 0, count * size);\newline  }\newline  return p;\newline}\newline","\newline Contiguously allocates enough space for count objects that are size bytes\newline of memory each and returns a pointer to the allocated memory.\newline \newline The allocated memory is filled with bytes of value zero.\newline \newline @param count number of objects to allocate\newline @param size size of the objects to allocate\newline @return pointer to allocated memory / NULL pointer if there is an error\newline \newline","2681457","explorer.cpp","QSensorItem* QSensorExplorer::selectedSensorItem()\newline{\newline    return _selectedSensorItem;\newline}\newline","\newline\\property QSensorExplorer::selectedSensorItem\newlineReturns the current selected sensor item.\newline \newline","1812560","usbd_req.c","static void USBD_SetConfig(USB_OTG_CORE_HANDLE  *pdev,\newline                           USB_SETUP_REQ *req)\newline{\newline\newline  static uint8_t  cfgidx;\newline\newline  cfgidx = (uint8_t)(req-&gtwValue);\newline\newline  if (cfgidx &gt USBD_CFG_MAX_NUM )\newline  {\newline     USBD_CtlError(pdev , req);\newline  }\newline  else\newline  {\newline    switch (pdev-&gtdev.device_status)\newline    {\newline    case USB_OTG_ADDRESSED:\newline      if (cfgidx)\newline      {\newline        pdev-&gtdev.device_config = cfgidx;\newline        pdev-&gtdev.device_status = USB_OTG_CONFIGURED;\newline        USBD_SetCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      else\newline      {\newline         USBD_CtlSendStatus(pdev);\newline      }\newline      break;\newline\newline    case USB_OTG_CONFIGURED:\newline      if (cfgidx == 0)\newline      {\newline        pdev-&gtdev.device_status = USB_OTG_ADDRESSED;\newline        pdev-&gtdev.device_config = cfgidx;\newline        USBD_ClrCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline\newline      }\newline      else  if (cfgidx != pdev-&gtdev.device_config)\newline      {\newline        /* Clear old configuration */\newline        USBD_ClrCfg(pdev , pdev-&gtdev.device_config);\newline\newline        /* set new configuration */\newline        pdev-&gtdev.device_config = cfgidx;\newline        USBD_SetCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      else\newline      {\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      break;\newline\newline    default:\newline       USBD_CtlError(pdev , req);\newline      break;\newline    }\newline  }\newline}\newline","\newline @brief USBD_SetConfig\newline Handle Set device configuration request\newline @param pdev: device instance\newline @param req: usb request\newline @retval status\newline \newline","282761","utils.c","uint32_t nl_cli_parse_u32(const char *arg)\newline{\newline	unsigned long lval;\newline	char *endptr;\newline\newline	lval = strtoul(arg, &ampendptr, 0);\newline	if (endptr == arg || lval == ULONG_MAX)\newline		nl_cli_fatal(EINVAL, &quotUnable to parse \\&quot%s\\&quot, not a number.&quot,\newline			     arg);\newline\newline	return (uint32_t) lval;\newline}\newline","\newline Parse a text based 32 bit unsigned integer argument\newline @arg arg Integer in text form.\newline \newline Tries to convert the number provided in arg to a uint32_t. Will call\newline nl_cli_fatal() if the conversion fails.\newline \newline @return 32bit unsigned integer.\newline \newline","1786230","qal_win.c","qboolean QAL_Loaded( void )\newline{\newline	return ( hinstOpenAL != NULL &amp&amp !dlsym_error );\newline}\newline","\newline==\newlineQAL_Loaded()\newlinecheck for OpenAL DLL load\newline==\newline \newline","2668680","stat_func.c","void A2L(int* A,int* L,int n,int k)\newline{\newline  int i;\newline  for(i=0;i&ltk;i++)\newline    L[i]=0;\newline  for(i=k+1;i&ltn;i++)\newline    L[i]=1;\newline}     \newline","Descriptions:\newlineAssume we have n objects, of which k of them are labeled with 0, the rest of them\newlineare labeling with 1. A is the subset of the objects which have label 0, L is the \newlinelabelling of each object. This function transforms A to Label\newline \newline","1241016","puzzle2.c","unsigned char loglkl2weight(int    a,\newline                            int    b,\newline                            int    c,\newline                            int    i,\newline                            double d1,\newline                            double d2,\newline                            double d3,\newline                            int    usebestq)\newline{\newline	double onethird;\newline	unsigned char treebits[3];\newline	double templog;\newline	unsigned char tmpweight;\newline	double temp;\newline	double temp1, temp2, temp3;\newline	unsigned char discreteweight[3];\newline\newline	double tttqweight[3];\newline	double tttsqdiff[3];\newline	int tttsqorder[3];\newline	int tttqworder[3];\newline\newline	tttqweight[0] = d1;\newline	tttqweight[1] = d2;\newline	tttqweight[2] = d3;\newline\newline	onethird = 1.0/3.0;\newline	treebits[0] = (unsigned char) 1;\newline	treebits[1] = (unsigned char) 2;\newline	treebits[2] = (unsigned char) 4;\newline	\newline	/* sort in descending order */\newline	sort3doubles(tttqweight, tttqworder);\newline\newline	if (usebestq) {\newline		tttsqorder[2] = 2;\newline		discreteweight[tttsqorder[2]] = treebits[tttqworder[0]];\newline		if (tttqweight[tttqworder[0]] == tttqweight[tttqworder[1]]) {\newline			discreteweight[tttsqorder[2]] = discreteweight[tttsqorder[2]] || treebits[tttqworder[1]];\newline			if (tttqweight[tttqworder[1]] == tttqweight[tttqworder[2]]) {\newline				discreteweight[tttsqorder[2]] = discreteweight[tttsqorder[2]] || treebits[tttqworder[2]];\newline				discreteweight[tttsqorder[2]] = 7;\newline			} \newline		}\newline	} else {\newline\newline		/* compute Bayesian weights */\newline		templog = tttqweight[tttqworder[1]]-tttqweight[tttqworder[0]];\newline		if(templog &lt -TP_MAX_EXP_DIFF)	/* possible, since 1.0+exp(&gt36) == 1.0 */\newline			tttqweight[tttqworder[1]] = 0.0;\newline		else\newline			tttqweight[tttqworder[1]] = exp(templog);\newline\newline	 	templog = tttqweight[tttqworder[2]]-tttqweight[tttqworder[0]];\newline		if(templog &lt -TP_MAX_EXP_DIFF)	/* possible, since 1.0+exp(&gt36) == 1.0 */\newline			tttqweight[tttqworder[2]] = 0.0;\newline		else\newline			tttqweight[tttqworder[2]] = exp(templog);\newline\newline		tttqweight[tttqworder[0]] = 1.0;\newline\newline		temp = tttqweight[0] + tttqweight[1] + tttqweight[2];\newline\newline		tttqweight[0] = tttqweight[0]/temp;\newline		tttqweight[1] = tttqweight[1]/temp;\newline		tttqweight[2] = tttqweight[2]/temp;\newline\newline		/* square deviations */\newline		temp1 = 1.0 - tttqweight[tttqworder[0]];\newline		tttsqdiff[0] = temp1 * temp1 +\newline		tttqweight[tttqworder[1]] * tttqweight[tttqworder[1]] +\newline		tttqweight[tttqworder[2]] * tttqweight[tttqworder[2]];\newline		discreteweight[0] = treebits[tttqworder[0]];\newline \newline		temp1 = 0.5 - tttqweight[tttqworder[0]];\newline		temp2 = 0.5 - tttqweight[tttqworder[1]];\newline		tttsqdiff[1] = temp1 * temp1 + temp2 * temp2 +\newline		tttqweight[tttqworder[2]] * tttqweight[tttqworder[2]];\newline		discreteweight[1] = treebits[tttqworder[0]] + treebits[tttqworder[1]];\newline\newline		temp1 = onethird - tttqweight[tttqworder[0]];\newline		temp2 = onethird - tttqweight[tttqworder[1]];\newline		temp3 = onethird - tttqweight[tttqworder[2]];\newline		tttsqdiff[2] = temp1 * temp1 + temp2 * temp2 + temp3 * temp3;\newline		discreteweight[2] = (unsigned char) 7;\newline\newline		/* sort in descending order */\newline		sort3doubles(tttsqdiff, tttsqorder);\newline	}\newline\newline	tmpweight = discreteweight[tttsqorder[2]];\newline	return(tmpweight);\newline} /* loglkl2weight */\newline","compute Bayesian weights from log-lkls d1, d2, d3 \newline","5975251","gd_tiff.c","static int tiff_closeproc(thandle_t clientdata)\newline{\newline	(void)clientdata;\newline	/*tiff_handle *th = (tiff_handle *)clientdata;\newline	gdIOCtx *ctx = th-&gtctx;\newline\newline	(ctx-&gtgd_free)(ctx);*/\newline\newline	return 0;\newline}\newline","TIFFCloseProc tiff_closeproc - used to finally close the TIFF file \newline","5962429","ircconnection.cpp","bool IrcConnection::isSecureSupported()\newline{\newline    return Irc::isSecureSupported();\newline}\newline","!\newline\\deprecated Use Irc::isSecureSupported() instead.\newline \newline","3228254","pnet.c","int tcp_udp_socket(int port,int dgram_f)\newline{\newline    int sockfd;\newline    struct sockaddr_in my_addr;    /* my address information */\newline    const int on=1;\newline\newline    #ifndef WIN32\newline        #ifndef IPTOS_LOWDELAY\newline        #define IPTOS_LOWDELAY          0x10\newline        #endif\newline        int tos = IPTOS_LOWDELAY;\newline    #endif\newline\newline    if(dgram_f)\newline	sockfd = socket(AF_INET, SOCK_DGRAM, 0);\newline    else\newline	sockfd = socket(AF_INET, SOCK_STREAM, 0);\newline    if(sockfd==-1)\newline	return -1;\newline    my_addr.sin_family = AF_INET;         /* host byte order */\newline    my_addr.sin_port = htons(port);       /* short, network byte order */\newline    my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */\newline    memset(&amp(my_addr.sin_zero),0, 8);        /* zero the rest of the struct */\newline    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,(const char *)&ampon,sizeof(on));\newline    if(bind(sockfd, (struct sockaddr *)&ampmy_addr, sizeof(struct sockaddr))== -1)\newline    {\newline	close(sockfd);\newline	return -1;\newline    }\newline    listen(sockfd,BACKLOG);\newline    nonblockingsocket(sockfd);\newline\newline    /* Try to enable low-latency send/receive operations on socket: */\newline    #ifndef WIN32\newline    if (-1 == setsockopt(sockfd, IPPROTO_IP, IP_TOS, &amptos, sizeof(tos))) {\newline        mexPrintf(&quotpnet: Warning: Could not enable low-latency mode on socket! [%s]\\n&quot, strerror(errno));\newline    }\newline    #endif\newline\newline    return sockfd;\newline}\newline","\newlineFunction Creating a TCP server socket \newlineor a connectionless UDP client socket.\newline \newline","2759680","png.c","static int palette_trans(ls_settings *settings, unsigned char ttb[256])\newline{\newline	int i, n, res;\newline\newline	/* Count transparent colors */\newline	for (i = n = 0; i &lt 256; i++) n += ttb[i] &lt 255;\newline	/* None means no transparency */\newline	settings-&gtxpm_trans = -1;\newline	if (!n) return (0);\newline	/* One fully transparent color means color transparency */\newline	if (n == 1)\newline	{\newline		for (i = 0; i &lt 256; i++)\newline		{\newline			if (ttb[i]) continue;\newline			settings-&gtxpm_trans = i;\newline			return (0);\newline		}\newline	}\newline	/* Anything else means alpha transparency */\newline	res = allocate_image(settings, CMASK_FOR(CHN_ALPHA));\newline	if (!res &amp&amp settings-&gtimg[CHN_ALPHA])\newline	{\newline		unsigned char *src, *dest;\newline		size_t i = (size_t)settings-&gtwidth * settings-&gtheight;\newline\newline		src = settings-&gtimg[CHN_IMAGE];\newline		dest = settings-&gtimg[CHN_ALPHA];\newline		while (i-- &gt 0) *dest++ = ttb[*src++];\newline	}\newline	return (res);\newline}\newline","Converts palette-based transparency to color transparency or alpha channel \newline","6397184","qlgc_vnic_dyn_update_daemon.c","static struct ibvexdm_output *search_existing_ibvexdm_op(char *ioc_guid)\newline{\newline	struct ibvexdm_output *conn;\newline\newline	if (ibvexdm_op == NULL)\newline		return NULL;\newline\newline	for (conn = ibvexdm_op; conn != NULL; conn = conn-&gtnext) {\newline		if (!strcmp(conn-&gtioc_guid, ioc_guid)) {\newline			_DBG_PRINT(&quotFound existing ib_qlgc_vnic_query entry : %s. &quot\newline				  	&quotUpdating the same.\\n&quot, ioc_guid);\newline			return conn;		\newline		}\newline	}	\newline\newline	return NULL;\newline}\newline","\newline Function : search_existing_ibvexdm_op.\newline \newline Description : checks if the ibvexdm output with given ioc_guid is already present in the\newline ibvexdm output list or not.\newline \newline","1446375","bddop.c","BDD bdd_appall(BDD l, BDD r, int opr, BDD var)\newline{\newline   BDD res;\newline   firstReorder = 1;\newline   \newline   CHECKa(l, bddfalse);\newline   CHECKa(r, bddfalse);\newline   CHECKa(var, bddfalse);\newline   \newline   if (opr&lt0 || opr&gtbddop_invimp)\newline   {\newline      bdd_error(BDD_OP);\newline      return bddfalse;\newline   }\newline   \newline   if (var &lt 2)  /* Empty set */\newline      return bdd_apply(l,r,opr);\newline\newline again:\newline   if (setjmp(bddexception) == 0)\newline   {\newline      if (varset2vartable(var) &lt 0)\newline	 return bddfalse;\newline\newline      INITREF;\newline      applyop = bddop_and;\newline      appexop = opr;\newline      appexid = (var &lt&lt 5) | (appexop &lt&lt 1) | 1; /* FIXME: range! */\newline      quantid = (appexid &lt&lt 3) | CACHEID_APPAL;\newline      \newline      if (!firstReorder)\newline	 bdd_disable_reorder();\newline      res = appquant_rec(l, r);\newline      if (!firstReorder)\newline	 bdd_enable_reorder();\newline   }\newline   else\newline   {\newline      bdd_checkreorder();\newline\newline      if (firstReorder-- == 1)\newline	 goto again;\newline      res = BDDZERO;  /* avoid warning about res being uninitialized */\newline   }\newline\newline   checkresize();\newline   return res;\newline}\newline","\newlineNAME { bdd\\_appall }\newlineSECTION { operator }\newlineSHORT { apply operation and universal quantification }\newlinePROTO { BDD bdd_appall(BDD left, BDD right, int opr, BDD var) }\newlineDESCR { Applies the binary operator {\\tt opr} to the arguments\newline{\\tt left} and {\\tt right} and then performs an universal\newline quantification of the variables from the variable set\newline {\\tt var}. This is done in a bottom up manner such that both the\newline apply and quantification is done on the lower nodes before\newline stepping up to the higher nodes. This makes the {\\tt bdd\\_appall}\newline function much more efficient than an apply operation followed\newline by a quantification. }\newlineALSO { bdd\\_appex, bdd\\_appuni, bdd\\_apply, bdd\\_exist, bdd\\_forall, bdd\\_unique, bdd\\_makeset }\newlineRETURN { The result of the operation. }\newline \newline","776479","import_vsn1.c","static void _invalid_format(const char *str)\newline{\newline	log_error(&quotCan&#039t process text format file - %s.&quot, str);\newline}\newline","\newline Logs an attempt to read an invalid format file.\newline \newline","1080549","video_out.c","static void vo_frame_driver_proc(vo_frame_t *img)\newline{\newline  if (img-&gtproc_frame) {\newline    img-&gtproc_frame(img);\newline  }\newline  if (img-&gtproc_called) return;\newline\newline  if (img-&gtproc_slice) {\newline    int height = img-&gtheight;\newline    uint8_t* src[3];\newline\newline    switch (img-&gtformat) {\newline    case XINE_IMGFMT_YV12:\newline      src[0] = img-&gtbase[0];\newline      src[1] = img-&gtbase[1];\newline      src[2] = img-&gtbase[2];\newline      while ((height -= 16) &gt -16) {\newline        img-&gtproc_slice(img, src);\newline        src[0] += 16 * img-&gtpitches[0];\newline        src[1] +=  8 * img-&gtpitches[1];\newline        src[2] +=  8 * img-&gtpitches[2];\newline      }\newline      break;\newline    case XINE_IMGFMT_YUY2:\newline      src[0] = img-&gtbase[0];\newline      while ((height -= 16) &gt -16) {\newline        img-&gtproc_slice(img, src);\newline        src[0] += 16 * img-&gtpitches[0];\newline      }\newline      break;\newline    }\newline  }\newline}\newline","call vo_driver-&gtproc methods for the entire frame \newline","","","","","","","on","","","","","","","on","","","","","","","","","on","","","","","","","","","on","on","","","on","","on","","on","","","put in terminal all arguments of a pic","convert the number provided","check for OpenAL DLL load","transforms A to Label","compute Bayesian weights","close the TIFF file","{}","Creating a TCP server socket or a connectionless UDP client socket.","Converts palette-based transparency to color transparency or alpha channel","checks if the ibvexdm output with given ioc_guid is already present","Applies the binary operator {\tt opr} to the arguments","remove elements from the layout","Logs an attempt to read an invalid format file.","{}","Calculates the shortest paths","copy","set data/function alignment.","resemble old GIMP's behaviour,","allocates enough space for count objects","Returns the current selected sensor item.","Set device configuration"
"3EHIMLB7F7Z0IFFLHAARP6WKE3ZH8Y","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3ZV9H2YQQD7Y1S1XQU6WOBULTTL3WX","AVC62JNYAXA45","Approved","Wed Apr 17 14:09:09 PDT 2019","Wed Apr 17 14:26:10 PDT 2019","Fri Apr 19 14:26:10 PDT 2019","2019-04-19 21:26:21 UTC","","","1021","100% (24/24)","100% (24/24)","100% (24/24)","5793885","eng_main.c","void eng_pic_showarg(eng_obj *o)  {\newline\newline	if(!o)  return;\newline\newline	fprintf(stdout, &quot== PIC ==\\n&quot);\newline	fprintf(stdout, &quot  show          -&gt %d\\n&quot, o-&gtshow);\newline	fprintf(stdout, &quot  x             -&gt %d\\n&quot, o-&gtx);\newline	fprintf(stdout, &quot  y             -&gt %d\\n&quot, o-&gty);\newline	fprintf(stdout, &quot  z             -&gt %d\\n&quot, o-&gtz);\newline	fprintf(stdout, &quot  width         -&gt %d\\n&quot, o-&gtwidth);\newline	fprintf(stdout, &quot  height        -&gt %d\\n&quot, o-&gtheight);\newline	fprintf(stdout, &quot  have_alpha    -&gt %d\\n&quot, o-&gthave_alpha);\newline	fprintf(stdout, &quot  have_bgcolor  -&gt %d\\n&quot, o-&gthave_bgcolor);\newline	fprintf(stdout, &quot  alpha         -&gt %d\\n&quot, o-&gtalpha);\newline	fprintf(stdout, &quot  bgcolor[R]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[0]);\newline	fprintf(stdout, &quot  bgcolor[G]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[1]);\newline	fprintf(stdout, &quot  bgcolor[B]    -&gt 0x%.2X\\n&quot, o-&gtbgcolor[2]);\newline	fprintf(stdout, &quot  ------\\n&quot);\newline	fprintf(stdout, &quot  change        -&gt %d\\n&quot, o-&gtchange);\newline	fprintf(stdout, &quot  x old         -&gt %d\\n&quot, o-&gtx_old);\newline	fprintf(stdout, &quot  y old         -&gt %d\\n&quot, o-&gty_old);\newline	fprintf(stdout, &quot  width old     -&gt %d\\n&quot, o-&gtwidth_old);\newline	fprintf(stdout, &quot  height old    -&gt %d\\n&quot, o-&gtheight_old);\newline	fprintf(stdout, &quot  ------\\n&quot);\newline	if(eng_pic_test(o) )\newline	fprintf(stdout, &quot  test      -&gt SUCCESS\\n&quot);\newline	else\newline	fprintf(stdout, &quot  test      -&gt ERROR\\n&quot);\newline	fprintf(stdout, &quot====================\\n&quot);\newline}\newline","---- put in terminal all arguments of a pic \newline","502883","qcustomplot.cpp","void QCPLayout::releaseElement(QCPLayoutElement *el)\newline{\newline  if (el)\newline  {\newline    el-&gtmParentLayout = 0;\newline    el-&gtsetParentLayerable(0);\newline    el-&gtsetParent(mParentPlot);\newline    // Note: Don&#039t initializeParentPlot(0) here, because layout element will stay in same parent plot\newline  } else\newline    qDebug() &lt&lt Q_FUNC_INFO &lt&lt &quotNull element passed&quot;\newline}\newline","! \\internal\newline\newlineDisassociates \\a el from this layout. This is done by setting the \\ref QCPLayoutElement::layout\newlineand the \\ref QCPLayerable::parentLayerable to zero. The QObject parent is set to the parent\newlineQCustomPlot.\newline\newlineThis method is used by subclass specific methods that remove elements from the layout (e.g. \\ref\newlinetake or \\ref takeAt). Note that this method only changes properties in \\a el. The removal from\newlinethe old layout must be done additionally.\newline \newline","2924850","graphobject.c","PyObject *igraphmodule_Graph_get_shortest_paths(igraphmodule_GraphObject *\newline                                                self, PyObject * args,\newline                                                PyObject * kwds)\newline{\newline  static char *kwlist[] = { &quotv&quot, &quotto&quot, &quotweights&quot, &quotmode&quot, &quotoutput&quot, NULL };\newline  igraph_vector_t *res, *weights=0;\newline  igraph_neimode_t mode = IGRAPH_OUT;\newline  long int i, j;\newline  igraph_integer_t from, no_of_target_nodes;\newline  igraph_vs_t to;\newline  PyObject *list, *item, *mode_o=Py_None, *weights_o=Py_None,\newline           *output_o=Py_None, *from_o = Py_None, *to_o=Py_None;\newline  igraph_vector_ptr_t *ptrvec=0;\newline  igraph_bool_t use_edges = 0;\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quotO|OOOO!&quot, kwlist, &ampfrom_o,\newline        &ampto_o, &ampweights_o, &ampmode_o, &ampPyString_Type, &ampoutput_o))\newline    return NULL;\newline\newline  if (output_o == 0 || output_o == Py_None ||\newline      PyString_IsEqualToASCIIString(output_o, &quotvpath&quot)) {\newline    use_edges = 0;\newline  } else if (PyString_IsEqualToASCIIString(output_o, &quotepath&quot)) {\newline    use_edges = 1;\newline  } else {\newline    PyErr_SetString(PyExc_ValueError, &quotoutput argument must be \\&quotvpath\\&quot or \\&quotepath\\&quot&quot);\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_PyObject_to_vid(from_o, &ampfrom, &ampself-&gtg))\newline    return NULL;\newline\newline  if (igraphmodule_PyObject_to_neimode_t(mode_o, &ampmode))\newline    return NULL;\newline  \newline  if (igraphmodule_attrib_to_vector_t(weights_o, self, &ampweights,\newline      ATTRIBUTE_TYPE_EDGE)) return NULL;\newline\newline  if (igraphmodule_PyObject_to_vs_t(to_o, &ampto, &ampself-&gtg, 0, 0)) {\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    return NULL;\newline  }\newline\newline  if (igraph_vs_size(&ampself-&gtg, &ampto, &ampno_of_target_nodes)) {\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline\newline  ptrvec = (igraph_vector_ptr_t *) calloc(1, sizeof(igraph_vector_ptr_t));\newline  if (!ptrvec) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  if (igraph_vector_ptr_init(ptrvec, no_of_target_nodes)) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  res = (igraph_vector_t *) calloc(no_of_target_nodes, sizeof(igraph_vector_t));\newline  if (!res) {\newline    PyErr_SetString(PyExc_MemoryError, &quot&quot);\newline    igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  for (i = 0; i &lt no_of_target_nodes; i++) {\newline    VECTOR(*ptrvec)[i] = &ampres[i];\newline    igraph_vector_init(&ampres[i], 0);\newline  }\newline\newline  if (igraph_get_shortest_paths_dijkstra(&ampself-&gtg, use_edges ? 0 : ptrvec,\newline        use_edges ? ptrvec : 0, from, to, weights, mode, 0, 0)) {\newline    igraphmodule_handle_igraph_error();\newline    for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline    free(res);\newline    igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline    if (weights) { igraph_vector_destroy(weights); free(weights); }\newline    igraph_vs_destroy(&ampto);\newline    return NULL;\newline  }\newline\newline  igraph_vector_ptr_destroy(ptrvec); free(ptrvec);\newline  if (weights) { igraph_vector_destroy(weights); free(weights); }\newline  igraph_vs_destroy(&ampto);\newline\newline  list = PyList_New(no_of_target_nodes);\newline  if (!list) {\newline    for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline    free(res);\newline    return NULL;\newline  }\newline\newline  for (i = 0; i &lt no_of_target_nodes; i++) {\newline    item = igraphmodule_vector_t_to_PyList(&ampres[i], IGRAPHMODULE_TYPE_INT);\newline    if (!item || PyList_SetItem(list, i, item)) {\newline      if (item) {\newline        Py_DECREF(item);\newline      }\newline      Py_DECREF(list);\newline      for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline      free(res);\newline      return NULL;\newline    }\newline  }\newline\newline  for (j = 0; j &lt no_of_target_nodes; j++) igraph_vector_destroy(&ampres[j]);\newline  free(res);\newline  return list;\newline}\newline","\\ingroup python_interface_graph\newline \\brief Calculates the shortest paths from/to a given node in the graph\newline \\return a list containing shortest paths from/to the given node\newline \\sa igraph_get_shortest_paths\newline \newline","1285285","context.c","msym_error_t msymGetElements(msym_context ctx, int *length, msym_element_t **elements){\newline    msym_error_t ret = MSYM_SUCCESS;\newline    msym_element_t *relements = NULL;\newline    if(ctx == NULL) {ret = MSYM_INVALID_CONTEXT;goto err;}\newline    if(ctx-&gtelements == NULL) {ret = MSYM_INVALID_ELEMENTS;goto err;}\newline    if(ctx-&gtext.elements == NULL) ctx-&gtext.elements = malloc(sizeof(msym_element_t[ctx-&gtel]));\newline    if(ctx-&gtorbitals != NULL) {\newline        if(ctx-&gtext.orbitals == NULL) ctx-&gtext.orbitals = malloc(sizeof(msym_orbital_t[ctx-&gtol]));\newline        memcpy(ctx-&gtext.orbitals,ctx-&gtorbitals,sizeof(msym_orbital_t[ctx-&gtol]));\newline    }\newline    if(ctx-&gtporbitals != NULL){\newline        if(ctx-&gtext.porbitals == NULL) ctx-&gtext.orbitals = calloc(ctx-&gtol,sizeof(msym_orbital_t*));\newline    }\newline    \newline    memcpy(ctx-&gtext.elements,ctx-&gtelements,sizeof(msym_element_t[ctx-&gtel]));\newline    msym_orbital_t **porb = ctx-&gtext.porbitals;\newline    for(msym_element_t *a = ctx-&gtext.elements; a &lt (ctx-&gtext.elements+ctx-&gtel); a++){\newline        vadd(a-&gtv,ctx-&gtcm,a-&gtv);\newline        for(int i = 0;i &lt a-&gtaol &amp&amp ctx-&gtext.orbitals != NULL &amp&amp porb != NULL;i++){\newline            porb[i] = a-&gtao[i] - ctx-&gtorbitals + ctx-&gtext.orbitals;\newline        }\newline        if(porb != NULL){\newline            a-&gtao = porb;\newline            porb += a-&gtaol;\newline        }\newline    }\newline    \newline    *elements = ctx-&gtext.elements;\newline    *length = ctx-&gtel;\newline    return ret;\newlineerr:\newline    free(relements);\newline    *elements = NULL;\newline    *length = 0;\newline    return ret;\newline}\newline","We don&#039t really need to copy this every time \newline","1886728","tccgen.c","static void parse_attribute(AttributeDef *ad)\newline{\newline    int t;\newline	long long n;\newline\newline    while (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2) {\newline    next();\newline    skip(&#039(&#039);\newline    skip(&#039(&#039);\newline    while (tok != &#039)&#039) {\newline        if (tok &lt TOK_IDENT)\newline            expect(&quotattribute name&quot);\newline        t = tok;\newline        next();\newline        switch(t) {\newline        case TOK_ALIAS1:\newline        case TOK_ALIAS2:\newline            skip(&#039(&#039);\newline            if (tok != TOK_STR)\newline                expect(&quotalias(\\&quottarget\\&quot)&quot);\newline            ad-&gtalias_target = /* save string as token, for later */\newline              tok_alloc((char*)tokc.cstr-&gtdata, tokc.cstr-&gtsize-1)-&gttok;\newline            next();\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_ALIGNED1:\newline        case TOK_ALIGNED2:\newline            if (tok == &#039(&#039) {\newline                next();\newline                n = expr_const();\newline                if (n &lt= 0 || (n &amp (n - 1)) != 0)\newline                    tcc_error(&quotalignment must be a positive power of two&quot);\newline                skip(&#039)&#039);\newline            } else {\newline                n = MAX_ALIGN;\newline            }\newline            ad-&gtaligned = n;\newline            break;\newline        case TOK_PACKED1:\newline        case TOK_PACKED2:\newline            ad-&gtpacked = 1;\newline            break;\newline        case TOK_WEAK1:\newline        case TOK_WEAK2:\newline            ad-&gtweak = 1;\newline            break;\newline        case TOK_UNUSED1:\newline        case TOK_UNUSED2:\newline            /* currently, no need to handle it because tcc does not\newline               track unused objects */\newline            break;\newline        case TOK_NORETURN1:\newline        case TOK_NORETURN2:\newline            /* currently, no need to handle it because tcc does not\newline               track unused objects */\newline            break;\newline        case TOK_CDECL1:\newline        case TOK_CDECL2:\newline        case TOK_CDECL3:\newline            ad-&gtfunc_call = FUNC_CDECL;\newline            break;\newline        case TOK_STDCALL1:\newline        case TOK_STDCALL2:\newline        case TOK_STDCALL3:\newline            ad-&gtfunc_call = FUNC_STDCALL;\newline            break;\newline#ifdef TCC_TARGET_I386\newline        case TOK_REGPARM1:\newline        case TOK_REGPARM2:\newline            skip(&#039(&#039);\newline            n = expr_const();\newline            if (n &gt 3)\newline                n = 3;\newline            else if (n &lt 0)\newline                n = 0;\newline            if (n &gt 0)\newline                ad-&gtfunc_call = FUNC_FASTCALL1 + n - 1;\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_FASTCALL1:\newline        case TOK_FASTCALL2:\newline        case TOK_FASTCALL3:\newline            ad-&gtfunc_call = FUNC_FASTCALLW;\newline            break;\newline#endif\newline        case TOK_MODE:\newline            skip(&#039(&#039);\newline            switch(tok) {\newline                case TOK_MODE_DI:\newline                    ad-&gtmode = VT_LLONG + 1;\newline                    break;\newline                case TOK_MODE_HI:\newline                    ad-&gtmode = VT_SHORT + 1;\newline                    break;\newline                case TOK_MODE_SI:\newline                    ad-&gtmode = VT_INT + 1;\newline                    break;\newline                default:\newline                    tcc_warning(&quot__mode__(%s) not supported\\n&quot, get_tok_str(tok, NULL));\newline                    break;\newline            }\newline            next();\newline            skip(&#039)&#039);\newline            break;\newline        case TOK_DLLEXPORT:\newline            ad-&gtfunc_export = 1;\newline            break;\newline        case TOK_DLLIMPORT:\newline            ad-&gtfunc_import = 1;\newline            break;\newline        default:\newline            if (tcc_state-&gtwarn_unsupported)\newline                tcc_warning(&quot&#039%s&#039 attribute ignored&quot, get_tok_str(t, NULL));\newline            /* skip parameters */\newline            if (tok == &#039(&#039) {\newline                int parenthesis = 0;\newline                do {\newline                    if (tok == &#039(&#039)\newline                        parenthesis++;\newline                    else if (tok == &#039)&#039)\newline                        parenthesis--;\newline                    next();\newline                } while (parenthesis &amp&amp tok != -1);\newline            }\newline            break;\newline        }\newline        if (tok != &#039,&#039)\newline            break;\newline        next();\newline    }\newline    skip(&#039)&#039);\newline    skip(&#039)&#039);\newline    }\newline}\newline","Parse GNUC __attribute__ extension. Currently, the following\newlineextensions are recognized:\newline- aligned(n) : set data/function alignment.\newline- packed : force data alignment to 1\newline- unused : currently ignored, but may be used someday.\newline- regparm(n) : pass function parameters in registers (i386 only)\newline \newline","2759294","memory.c","int mem_dither(unsigned char *old, int ncols, short *dither, int cspace,\newline	int dist, int limit, int selc, int serpent, int rgb8b, double emult)\newline{\newline	int i, j, k, l, kk, j0, j1, dj, rlen, col0, col1, progress;\newline	unsigned char *ddata, *src, *dest;\newline	double *row0, *row1, *row2, *tmp;\newline	double err, intd, extd, *gamma6, *lin6;\newline	double tc0[3], tc1[3], color0[3], color1[3];\newline	double fdiv = 0, gamut[6] = {1, 1, 1, 0, 0, 0};\newline\newline	/* Allocate working space */\newline	rlen = (mem_width + 4) * 3 * sizeof(double);\newline	ddata = multialloc(MA_ALIGN_DOUBLE,\newline		&amprow0, rlen,\newline		&amprow1, rlen,\newline		&amprow2, rlen,\newline		&ampctp, sizeof(ctable),\newline		NULL);\newline	if (!ddata) return (1);\newline\newline	if ((progress = mem_width * mem_height &gt 1000000))\newline		progress_init(_(&quotConverting to Indexed Palette&quot), 0);\newline\newline	/* Preprocess palette to find whether to extend precision and where */\newline	for (i = 0; i &lt ncols; i++)\newline	{\newline		j = ((mem_pal[i].red &amp 0xFC) &lt&lt 10) +\newline			((mem_pal[i].green &amp 0xFC) &lt&lt 4) +\newline			(mem_pal[i].blue &gt&gt 2);\newline		if (!(l = ctp-&gtcmap[j]))\newline		{\newline			ctp-&gtcmap[j] = l = i + 1;\newline			ctp-&gtxcmap[l * 4 + 2] = j;\newline		}\newline		k = ((mem_pal[i].red &amp 3) &lt&lt 4) +\newline			((mem_pal[i].green &amp 3) &lt&lt 2) +\newline			(mem_pal[i].blue &amp 3);\newline		ctp-&gtxcmap[l * 4 + (k &amp 1)] |= 1 &lt&lt (k &gt&gt 1);\newline	}\newline	memset(ctp-&gtcmap, 0, 64 * 64 * 64);\newline	for (k = 0 , i = 4; i &lt 256 * 4; i += 4)\newline	{\newline		guint32 v = ctp-&gtxcmap[i] | ctp-&gtxcmap[i + 1];\newline		/* Are 2+ colors there somewhere? */\newline		if (!((v &amp (v - 1)) | (ctp-&gtxcmap[i] &amp ctp-&gtxcmap[i + 1])))\newline			continue;\newline		rgb8b = TRUE; /* Force 8-bit precision */\newline		j = ctp-&gtxcmap[i + 2];\newline		ctp-&gtlcmap[j &gt&gt 5] |= 1 &lt&lt (j &amp 31);\newline		ctp-&gtcmap[j] = k++;\newline	}\newline	memset(ctp-&gtxcmap, 0, 257 * 4 * sizeof(guint32));\newline\newline	/* Prepare tables */\newline	for (i = 0; i &lt 256; i++)\newline	{\newline		j = (i &amp 0xFC) + (i &gt&gt 6);\newline		ctp-&gtgamma[i] = gamma256[i];\newline		ctp-&gtgamma[i + 256] = gamma256[j];\newline		ctp-&gtlin[i] = i * (1.0 / 255.0);\newline		ctp-&gtlin[i + 256] = j * (1.0 / 255.0);\newline	}\newline	/* Keep all 8 bits of input or posterize to 6 bits? */\newline	i = rgb8b ? 0 : 256;\newline	gamma6 = ctp-&gtgamma + i; lin6 = ctp-&gtlin + i;\newline	tmp = ctp-&gtxyz256;\newline	for (i = 0; i &lt ncols; i++ , tmp += 3)\newline	{\newline		/* Update gamut limits */\newline		tmp[0] = gamma6[mem_pal[i].red];\newline		tmp[1] = gamma6[mem_pal[i].green];\newline		tmp[2] = gamma6[mem_pal[i].blue];\newline		for (j = 0; j &lt 3; j++)\newline		{\newline			if (tmp[j] &lt gamut[j]) gamut[j] = tmp[j];\newline			if (tmp[j] &gt gamut[j + 3]) gamut[j + 3] = tmp[j];\newline		}\newline		/* Store colour coords */\newline		switch (cspace)\newline		{\newline		default:\newline		case CSPACE_RGB:\newline			tmp[0] = lin6[mem_pal[i].red];\newline			tmp[1] = lin6[mem_pal[i].green];\newline			tmp[2] = lin6[mem_pal[i].blue];\newline			break;\newline		case CSPACE_SRGB:\newline			break; /* Done already */\newline		case CSPACE_LXN:\newline			rgb2LXN(tmp, tmp[0], tmp[1], tmp[2]);\newline			break;\newline		}\newline	}\newline	ctp-&gtcspace = cspace; ctp-&gtcdist = dist; ctp-&gtncols = ncols;\newline	serpent = serpent ? 0 : 2;\newline	if (dither) fdiv = 1.0 / *dither++;\newline\newline	/* Process image */\newline	for (i = 0; i &lt mem_height; i++)\newline	{\newline		src = old + i * mem_width * 3;\newline		dest = mem_img[CHN_IMAGE] + i * mem_width;\newline		memset(row2, 0, rlen);\newline		if (serpent ^= 1)\newline		{\newline			j0 = 0; j1 = mem_width * 3; dj = 1;\newline		}\newline		else\newline		{\newline			j0 = (mem_width - 1) * 3; j1 = -3; dj = -1;\newline			dest += mem_width - 1;\newline		}\newline		for (j = j0; j != j1; j += dj * 3)\newline		{\newline			for (k = 0; k &lt 3; k++)\newline			{\newline				/* Posterize to 6 bits as natural for palette */\newline				color0[k] = gamma6[src[j + k]];\newline				/* Add in error, maybe limiting it */\newline				err = row0[j + k + 6];\newline				if (limit == 1) /* To half of SRGB range */\newline				{\newline					err = err &lt -0.5 ? -0.5 :\newline						err &gt 0.5 ? 0.5 : err;\newline				}\newline				else if (limit == 2) /* To 1/4, with damping */\newline				{\newline					err = err &lt -0.1 ? (err &lt -0.4 ?\newline						-0.25 : 0.5 * err - 0.05) :\newline						err &gt 0.1 ? (err &gt 0.4 ?\newline						0.25 : 0.5 * err + 0.05) : err;\newline				}\newline				color1[k] = color0[k] + err;\newline				/* Limit result to palette gamut */\newline				if (color1[k] &lt gamut[k]) color1[k] = gamut[k];\newline				if (color1[k] &gt gamut[k + 3]) color1[k] = gamut[k + 3];\newline			}\newline			/* Output best colour */\newline			col1 = lookup_srgb(color1);\newline			*dest = col1;\newline			dest += dj;\newline			if (!dither) continue;\newline			/* Evaluate new error */\newline			tc1[0] = gamma6[mem_pal[col1].red];\newline			tc1[1] = gamma6[mem_pal[col1].green];\newline			tc1[2] = gamma6[mem_pal[col1].blue];\newline			if (selc) /* Selective error damping */\newline			{\newline				col0 = lookup_srgb(color0);\newline				tc0[0] = gamma6[mem_pal[col0].red];\newline				tc0[1] = gamma6[mem_pal[col0].green];\newline				tc0[2] = gamma6[mem_pal[col0].blue];\newline				/* Split error the obvious way */\newline				if (!(selc &amp 1) &amp&amp (col0 == col1))\newline				{\newline					color1[0] = (color1[0] - color0[0]) * emult +\newline						color0[0] - tc0[0];\newline					color1[1] = (color1[1] - color0[1]) * emult +\newline						color0[1] - tc0[1];\newline					color1[2] = (color1[2] - color0[2]) * emult +\newline						color0[2] - tc0[2];\newline				}\newline				/* Weigh component errors separately */\newline				else if (selc &lt 3)\newline				{\newline					for (k = 0; k &lt 3; k++)\newline					{\newline						intd = fabs(color0[k] - tc0[k]);\newline						extd = fabs(color0[k] - color1[k]);\newline						if (intd + extd == 0.0) err = 1.0;\newline						else err = (intd + emult * extd) / (intd + extd);\newline						color1[k] = err * (color1[k] - tc1[k]);\newline					}\newline				}\newline				/* Weigh errors by vector length */\newline				else\newline				{\newline					intd = sqrt((color0[0] - tc0[0]) * (color0[0] - tc0[0]) +\newline						(color0[1] - tc0[1]) * (color0[1] - tc0[1]) +\newline						(color0[2] - tc0[2]) * (color0[2] - tc0[2]));\newline					extd = sqrt((color0[0] - color1[0]) * (color0[0] - color1[0]) +\newline						(color0[1] - color1[1]) * (color0[1] - color1[1]) +\newline						(color0[2] - color1[2]) * (color0[2] - color1[2]));\newline					if (intd + extd == 0.0) err = 1.0;\newline					else err = (intd + emult * extd) / (intd + extd);\newline					color1[0] = err * (color1[0] - tc1[0]);\newline					color1[1] = err * (color1[1] - tc1[1]);\newline					color1[2] = err * (color1[2] - tc1[2]);\newline				}\newline			}\newline			else /* Indiscriminate error damping */\newline			{\newline				color1[0] = (color1[0] - tc1[0]) * emult;\newline				color1[1] = (color1[1] - tc1[1]) * emult;\newline				color1[2] = (color1[2] - tc1[2]) * emult;\newline			}\newline			/* Distribute the error */\newline			color1[0] *= fdiv;\newline			color1[1] *= fdiv;\newline			color1[2] *= fdiv;\newline			for (k = 0; k &lt 5; k++)\newline			{\newline				kk = j + (k - 2) * dj * 3 + 6;\newline				for (l = 0; l &lt 3; l++ , kk++)\newline				{\newline					row0[kk] += color1[l] * dither[k];\newline					row1[kk] += color1[l] * dither[k + 5];\newline					row2[kk] += color1[l] * dither[k + 10];\newline				}\newline			}\newline		}\newline		tmp = row0; row0 = row1; row1 = row2; row2 = tmp;\newline		if (progress &amp&amp (i * 10) % mem_height &gt= mem_height - 10)\newline			progress_update((float)(i + 1) / mem_height);\newline	}\newline\newline	if (progress) progress_end();\newline	free(ddata);\newline	return (0);\newline}\newline","Damping functions roughly resemble old GIMP&#039s behaviour, but may need some\newline tuning because linear sRGB is just too different from normal RGB \newline","6484447","mem.c","void *mem_calloc(mem_size_t count, mem_size_t size)\newline{\newline  void *p;\newline\newline  /* allocate &#039count&#039 objects of size &#039size&#039 */\newline  p = mem_malloc(count * size);\newline  if (p) {\newline    /* zero the memory */\newline    memset(p, 0, count * size);\newline  }\newline  return p;\newline}\newline","\newline Contiguously allocates enough space for count objects that are size bytes\newline of memory each and returns a pointer to the allocated memory.\newline \newline The allocated memory is filled with bytes of value zero.\newline \newline @param count number of objects to allocate\newline @param size size of the objects to allocate\newline @return pointer to allocated memory / NULL pointer if there is an error\newline \newline","2681457","explorer.cpp","QSensorItem* QSensorExplorer::selectedSensorItem()\newline{\newline    return _selectedSensorItem;\newline}\newline","\newline\\property QSensorExplorer::selectedSensorItem\newlineReturns the current selected sensor item.\newline \newline","1812560","usbd_req.c","static void USBD_SetConfig(USB_OTG_CORE_HANDLE  *pdev,\newline                           USB_SETUP_REQ *req)\newline{\newline\newline  static uint8_t  cfgidx;\newline\newline  cfgidx = (uint8_t)(req-&gtwValue);\newline\newline  if (cfgidx &gt USBD_CFG_MAX_NUM )\newline  {\newline     USBD_CtlError(pdev , req);\newline  }\newline  else\newline  {\newline    switch (pdev-&gtdev.device_status)\newline    {\newline    case USB_OTG_ADDRESSED:\newline      if (cfgidx)\newline      {\newline        pdev-&gtdev.device_config = cfgidx;\newline        pdev-&gtdev.device_status = USB_OTG_CONFIGURED;\newline        USBD_SetCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      else\newline      {\newline         USBD_CtlSendStatus(pdev);\newline      }\newline      break;\newline\newline    case USB_OTG_CONFIGURED:\newline      if (cfgidx == 0)\newline      {\newline        pdev-&gtdev.device_status = USB_OTG_ADDRESSED;\newline        pdev-&gtdev.device_config = cfgidx;\newline        USBD_ClrCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline\newline      }\newline      else  if (cfgidx != pdev-&gtdev.device_config)\newline      {\newline        /* Clear old configuration */\newline        USBD_ClrCfg(pdev , pdev-&gtdev.device_config);\newline\newline        /* set new configuration */\newline        pdev-&gtdev.device_config = cfgidx;\newline        USBD_SetCfg(pdev , cfgidx);\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      else\newline      {\newline        USBD_CtlSendStatus(pdev);\newline      }\newline      break;\newline\newline    default:\newline       USBD_CtlError(pdev , req);\newline      break;\newline    }\newline  }\newline}\newline","\newline @brief USBD_SetConfig\newline Handle Set device configuration request\newline @param pdev: device instance\newline @param req: usb request\newline @retval status\newline \newline","282761","utils.c","uint32_t nl_cli_parse_u32(const char *arg)\newline{\newline	unsigned long lval;\newline	char *endptr;\newline\newline	lval = strtoul(arg, &ampendptr, 0);\newline	if (endptr == arg || lval == ULONG_MAX)\newline		nl_cli_fatal(EINVAL, &quotUnable to parse \\&quot%s\\&quot, not a number.&quot,\newline			     arg);\newline\newline	return (uint32_t) lval;\newline}\newline","\newline Parse a text based 32 bit unsigned integer argument\newline @arg arg Integer in text form.\newline \newline Tries to convert the number provided in arg to a uint32_t. Will call\newline nl_cli_fatal() if the conversion fails.\newline \newline @return 32bit unsigned integer.\newline \newline","1786230","qal_win.c","qboolean QAL_Loaded( void )\newline{\newline	return ( hinstOpenAL != NULL &amp&amp !dlsym_error );\newline}\newline","\newline==\newlineQAL_Loaded()\newlinecheck for OpenAL DLL load\newline==\newline \newline","2668680","stat_func.c","void A2L(int* A,int* L,int n,int k)\newline{\newline  int i;\newline  for(i=0;i&ltk;i++)\newline    L[i]=0;\newline  for(i=k+1;i&ltn;i++)\newline    L[i]=1;\newline}     \newline","Descriptions:\newlineAssume we have n objects, of which k of them are labeled with 0, the rest of them\newlineare labeling with 1. A is the subset of the objects which have label 0, L is the \newlinelabelling of each object. This function transforms A to Label\newline \newline","1241016","puzzle2.c","unsigned char loglkl2weight(int    a,\newline                            int    b,\newline                            int    c,\newline                            int    i,\newline                            double d1,\newline                            double d2,\newline                            double d3,\newline                            int    usebestq)\newline{\newline	double onethird;\newline	unsigned char treebits[3];\newline	double templog;\newline	unsigned char tmpweight;\newline	double temp;\newline	double temp1, temp2, temp3;\newline	unsigned char discreteweight[3];\newline\newline	double tttqweight[3];\newline	double tttsqdiff[3];\newline	int tttsqorder[3];\newline	int tttqworder[3];\newline\newline	tttqweight[0] = d1;\newline	tttqweight[1] = d2;\newline	tttqweight[2] = d3;\newline\newline	onethird = 1.0/3.0;\newline	treebits[0] = (unsigned char) 1;\newline	treebits[1] = (unsigned char) 2;\newline	treebits[2] = (unsigned char) 4;\newline	\newline	/* sort in descending order */\newline	sort3doubles(tttqweight, tttqworder);\newline\newline	if (usebestq) {\newline		tttsqorder[2] = 2;\newline		discreteweight[tttsqorder[2]] = treebits[tttqworder[0]];\newline		if (tttqweight[tttqworder[0]] == tttqweight[tttqworder[1]]) {\newline			discreteweight[tttsqorder[2]] = discreteweight[tttsqorder[2]] || treebits[tttqworder[1]];\newline			if (tttqweight[tttqworder[1]] == tttqweight[tttqworder[2]]) {\newline				discreteweight[tttsqorder[2]] = discreteweight[tttsqorder[2]] || treebits[tttqworder[2]];\newline				discreteweight[tttsqorder[2]] = 7;\newline			} \newline		}\newline	} else {\newline\newline		/* compute Bayesian weights */\newline		templog = tttqweight[tttqworder[1]]-tttqweight[tttqworder[0]];\newline		if(templog &lt -TP_MAX_EXP_DIFF)	/* possible, since 1.0+exp(&gt36) == 1.0 */\newline			tttqweight[tttqworder[1]] = 0.0;\newline		else\newline			tttqweight[tttqworder[1]] = exp(templog);\newline\newline	 	templog = tttqweight[tttqworder[2]]-tttqweight[tttqworder[0]];\newline		if(templog &lt -TP_MAX_EXP_DIFF)	/* possible, since 1.0+exp(&gt36) == 1.0 */\newline			tttqweight[tttqworder[2]] = 0.0;\newline		else\newline			tttqweight[tttqworder[2]] = exp(templog);\newline\newline		tttqweight[tttqworder[0]] = 1.0;\newline\newline		temp = tttqweight[0] + tttqweight[1] + tttqweight[2];\newline\newline		tttqweight[0] = tttqweight[0]/temp;\newline		tttqweight[1] = tttqweight[1]/temp;\newline		tttqweight[2] = tttqweight[2]/temp;\newline\newline		/* square deviations */\newline		temp1 = 1.0 - tttqweight[tttqworder[0]];\newline		tttsqdiff[0] = temp1 * temp1 +\newline		tttqweight[tttqworder[1]] * tttqweight[tttqworder[1]] +\newline		tttqweight[tttqworder[2]] * tttqweight[tttqworder[2]];\newline		discreteweight[0] = treebits[tttqworder[0]];\newline \newline		temp1 = 0.5 - tttqweight[tttqworder[0]];\newline		temp2 = 0.5 - tttqweight[tttqworder[1]];\newline		tttsqdiff[1] = temp1 * temp1 + temp2 * temp2 +\newline		tttqweight[tttqworder[2]] * tttqweight[tttqworder[2]];\newline		discreteweight[1] = treebits[tttqworder[0]] + treebits[tttqworder[1]];\newline\newline		temp1 = onethird - tttqweight[tttqworder[0]];\newline		temp2 = onethird - tttqweight[tttqworder[1]];\newline		temp3 = onethird - tttqweight[tttqworder[2]];\newline		tttsqdiff[2] = temp1 * temp1 + temp2 * temp2 + temp3 * temp3;\newline		discreteweight[2] = (unsigned char) 7;\newline\newline		/* sort in descending order */\newline		sort3doubles(tttsqdiff, tttsqorder);\newline	}\newline\newline	tmpweight = discreteweight[tttsqorder[2]];\newline	return(tmpweight);\newline} /* loglkl2weight */\newline","compute Bayesian weights from log-lkls d1, d2, d3 \newline","5975251","gd_tiff.c","static int tiff_closeproc(thandle_t clientdata)\newline{\newline	(void)clientdata;\newline	/*tiff_handle *th = (tiff_handle *)clientdata;\newline	gdIOCtx *ctx = th-&gtctx;\newline\newline	(ctx-&gtgd_free)(ctx);*/\newline\newline	return 0;\newline}\newline","TIFFCloseProc tiff_closeproc - used to finally close the TIFF file \newline","5962429","ircconnection.cpp","bool IrcConnection::isSecureSupported()\newline{\newline    return Irc::isSecureSupported();\newline}\newline","!\newline\\deprecated Use Irc::isSecureSupported() instead.\newline \newline","3228254","pnet.c","int tcp_udp_socket(int port,int dgram_f)\newline{\newline    int sockfd;\newline    struct sockaddr_in my_addr;    /* my address information */\newline    const int on=1;\newline\newline    #ifndef WIN32\newline        #ifndef IPTOS_LOWDELAY\newline        #define IPTOS_LOWDELAY          0x10\newline        #endif\newline        int tos = IPTOS_LOWDELAY;\newline    #endif\newline\newline    if(dgram_f)\newline	sockfd = socket(AF_INET, SOCK_DGRAM, 0);\newline    else\newline	sockfd = socket(AF_INET, SOCK_STREAM, 0);\newline    if(sockfd==-1)\newline	return -1;\newline    my_addr.sin_family = AF_INET;         /* host byte order */\newline    my_addr.sin_port = htons(port);       /* short, network byte order */\newline    my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */\newline    memset(&amp(my_addr.sin_zero),0, 8);        /* zero the rest of the struct */\newline    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,(const char *)&ampon,sizeof(on));\newline    if(bind(sockfd, (struct sockaddr *)&ampmy_addr, sizeof(struct sockaddr))== -1)\newline    {\newline	close(sockfd);\newline	return -1;\newline    }\newline    listen(sockfd,BACKLOG);\newline    nonblockingsocket(sockfd);\newline\newline    /* Try to enable low-latency send/receive operations on socket: */\newline    #ifndef WIN32\newline    if (-1 == setsockopt(sockfd, IPPROTO_IP, IP_TOS, &amptos, sizeof(tos))) {\newline        mexPrintf(&quotpnet: Warning: Could not enable low-latency mode on socket! [%s]\\n&quot, strerror(errno));\newline    }\newline    #endif\newline\newline    return sockfd;\newline}\newline","\newlineFunction Creating a TCP server socket \newlineor a connectionless UDP client socket.\newline \newline","2759680","png.c","static int palette_trans(ls_settings *settings, unsigned char ttb[256])\newline{\newline	int i, n, res;\newline\newline	/* Count transparent colors */\newline	for (i = n = 0; i &lt 256; i++) n += ttb[i] &lt 255;\newline	/* None means no transparency */\newline	settings-&gtxpm_trans = -1;\newline	if (!n) return (0);\newline	/* One fully transparent color means color transparency */\newline	if (n == 1)\newline	{\newline		for (i = 0; i &lt 256; i++)\newline		{\newline			if (ttb[i]) continue;\newline			settings-&gtxpm_trans = i;\newline			return (0);\newline		}\newline	}\newline	/* Anything else means alpha transparency */\newline	res = allocate_image(settings, CMASK_FOR(CHN_ALPHA));\newline	if (!res &amp&amp settings-&gtimg[CHN_ALPHA])\newline	{\newline		unsigned char *src, *dest;\newline		size_t i = (size_t)settings-&gtwidth * settings-&gtheight;\newline\newline		src = settings-&gtimg[CHN_IMAGE];\newline		dest = settings-&gtimg[CHN_ALPHA];\newline		while (i-- &gt 0) *dest++ = ttb[*src++];\newline	}\newline	return (res);\newline}\newline","Converts palette-based transparency to color transparency or alpha channel \newline","6397184","qlgc_vnic_dyn_update_daemon.c","static struct ibvexdm_output *search_existing_ibvexdm_op(char *ioc_guid)\newline{\newline	struct ibvexdm_output *conn;\newline\newline	if (ibvexdm_op == NULL)\newline		return NULL;\newline\newline	for (conn = ibvexdm_op; conn != NULL; conn = conn-&gtnext) {\newline		if (!strcmp(conn-&gtioc_guid, ioc_guid)) {\newline			_DBG_PRINT(&quotFound existing ib_qlgc_vnic_query entry : %s. &quot\newline				  	&quotUpdating the same.\\n&quot, ioc_guid);\newline			return conn;		\newline		}\newline	}	\newline\newline	return NULL;\newline}\newline","\newline Function : search_existing_ibvexdm_op.\newline \newline Description : checks if the ibvexdm output with given ioc_guid is already present in the\newline ibvexdm output list or not.\newline \newline","1446375","bddop.c","BDD bdd_appall(BDD l, BDD r, int opr, BDD var)\newline{\newline   BDD res;\newline   firstReorder = 1;\newline   \newline   CHECKa(l, bddfalse);\newline   CHECKa(r, bddfalse);\newline   CHECKa(var, bddfalse);\newline   \newline   if (opr&lt0 || opr&gtbddop_invimp)\newline   {\newline      bdd_error(BDD_OP);\newline      return bddfalse;\newline   }\newline   \newline   if (var &lt 2)  /* Empty set */\newline      return bdd_apply(l,r,opr);\newline\newline again:\newline   if (setjmp(bddexception) == 0)\newline   {\newline      if (varset2vartable(var) &lt 0)\newline	 return bddfalse;\newline\newline      INITREF;\newline      applyop = bddop_and;\newline      appexop = opr;\newline      appexid = (var &lt&lt 5) | (appexop &lt&lt 1) | 1; /* FIXME: range! */\newline      quantid = (appexid &lt&lt 3) | CACHEID_APPAL;\newline      \newline      if (!firstReorder)\newline	 bdd_disable_reorder();\newline      res = appquant_rec(l, r);\newline      if (!firstReorder)\newline	 bdd_enable_reorder();\newline   }\newline   else\newline   {\newline      bdd_checkreorder();\newline\newline      if (firstReorder-- == 1)\newline	 goto again;\newline      res = BDDZERO;  /* avoid warning about res being uninitialized */\newline   }\newline\newline   checkresize();\newline   return res;\newline}\newline","\newlineNAME { bdd\\_appall }\newlineSECTION { operator }\newlineSHORT { apply operation and universal quantification }\newlinePROTO { BDD bdd_appall(BDD left, BDD right, int opr, BDD var) }\newlineDESCR { Applies the binary operator {\\tt opr} to the arguments\newline{\\tt left} and {\\tt right} and then performs an universal\newline quantification of the variables from the variable set\newline {\\tt var}. This is done in a bottom up manner such that both the\newline apply and quantification is done on the lower nodes before\newline stepping up to the higher nodes. This makes the {\\tt bdd\\_appall}\newline function much more efficient than an apply operation followed\newline by a quantification. }\newlineALSO { bdd\\_appex, bdd\\_appuni, bdd\\_apply, bdd\\_exist, bdd\\_forall, bdd\\_unique, bdd\\_makeset }\newlineRETURN { The result of the operation. }\newline \newline","776479","import_vsn1.c","static void _invalid_format(const char *str)\newline{\newline	log_error(&quotCan&#039t process text format file - %s.&quot, str);\newline}\newline","\newline Logs an attempt to read an invalid format file.\newline \newline","1080549","video_out.c","static void vo_frame_driver_proc(vo_frame_t *img)\newline{\newline  if (img-&gtproc_frame) {\newline    img-&gtproc_frame(img);\newline  }\newline  if (img-&gtproc_called) return;\newline\newline  if (img-&gtproc_slice) {\newline    int height = img-&gtheight;\newline    uint8_t* src[3];\newline\newline    switch (img-&gtformat) {\newline    case XINE_IMGFMT_YV12:\newline      src[0] = img-&gtbase[0];\newline      src[1] = img-&gtbase[1];\newline      src[2] = img-&gtbase[2];\newline      while ((height -= 16) &gt -16) {\newline        img-&gtproc_slice(img, src);\newline        src[0] += 16 * img-&gtpitches[0];\newline        src[1] +=  8 * img-&gtpitches[1];\newline        src[2] +=  8 * img-&gtpitches[2];\newline      }\newline      break;\newline    case XINE_IMGFMT_YUY2:\newline      src[0] = img-&gtbase[0];\newline      while ((height -= 16) &gt -16) {\newline        img-&gtproc_slice(img, src);\newline        src[0] += 16 * img-&gtpitches[0];\newline      }\newline      break;\newline    }\newline  }\newline}\newline","call vo_driver-&gtproc methods for the entire frame \newline","","","","","","","on","","","","","","","on","","on","","on","","","","","","","","","","","","","","","","","","","","","","on","","","put in terminal all arguments of a pic","convert the number provided in arg to a uint32_t.","check for OpenAL DLL load","transforms A to Label","compute Bayesian weights","close the TIFF file","{}","Creating a TCP server socket or a connectionless UDP client socket.","Converts palette-based transparency to color transparency or alpha channel","checks if the ibvexdm output with given ioc_guid is already present","apply operation and universal quantification","Disassociates \a el from this layout.","Logs an attempt to read an invalid format file.","{}","Calculates the shortest paths from/to a given node in the graph","{}","Parse GNUC __attribute__ extension.","{}","Contiguously allocates enough space for count objects","Returns the current selected sensor item.","Handle Set device configuration request"
"3EPG8DX9LKQ98EU72PBTMVOKY48P59","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","38YMOXR4MUZXYBOF9W4UVE653LCW6N","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:54:13 PDT 2019","Wed Apr 17 16:00:06 PDT 2019","Fri Apr 19 16:00:06 PDT 2019","2019-04-19 23:00:21 UTC","","","353","100% (27/27)","100% (27/27)","100% (27/27)","90866","nbase_misc.c","long parse_long(const char *s, char **tail)\newline{\newline    if (!isdigit((int) (unsigned char) *s)) {\newline        *tail = (char *) s;\newline        return 0;\newline    }\newline\newline    return strtol(s, (char **) tail, 10);\newline}\newline","This is like strtol or atoi, but it allows digits only. No whitespace, sign,\newlineor radix prefix. \newline","4714359","interrupt.c","void reset_control_stack_guard_page(void)\newline{\newline    struct thread *th=arch_os_get_current_thread();\newline    if (th-&gtcontrol_stack_guard_page_protected == NIL) {\newline        reset_thread_control_stack_guard_page(th);\newline    }\newline}\newline","Called from the REPL, too. \newline","4350933","normconf.cpp","void NormalizerConformanceTest::TestConformance() {\newline    TestConformance(openNormalizationTestFile(&quotNormalizationTest.txt&quot), 0);\newline}\newline","\newline Test the conformance of Normalizer to\newline http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt\newline \newline","59479","fbo-formats.h","static void next_test_set(int inc_dec)\newline{\newline	do {\newline		test_index += inc_dec;\newline		if (test_index &gt= (int) ARRAY_SIZE(test_sets)) {\newline			test_index = 0;\newline		}\newline		else if (test_index &lt 0) {\newline			test_index = ARRAY_SIZE(test_sets) - 1;\newline		}\newline	} while (!supported(&amptest_sets[test_index]));\newline	format_index = 0;\newline	printf(&quotUsing test set: %s\\n&quot, test_sets[test_index].param);\newline}\newline","\newline If inc_dec == +1, go to the next test set.\newline If inc_dec == -1, go to the previous test set.\newline \newline","3466833","colors.c","static void rgb2hsv(double r, double g, double b,\newline		    double *h, double *s, double *v)\newline    /* all (r,g,b, h,s,v) values in [0,1] */\newline{\newline    double min, max, delta;\newline    Rboolean r_max = TRUE, b_max = FALSE;\newline    /* Compute  min(r,g,b) and max(r,g,b) and remember where max is: */\newline    min = max = r;\newline    if(min &gt g) { /* g &lt r */\newline	if(b &lt g)\newline	    min = b;/* &amp  max = r */\newline	else { /* g &lt= b, g &lt r */\newline	    min = g;\newline	    if(b &gt r) { max = b; b_max = TRUE; r_max = FALSE; }\newline	    /* else : g &lt= b &lt=r */\newline	}\newline    } else { /* r &lt= g */\newline	if(b &gt g) {\newline	    max = b; b_max = TRUE; r_max = FALSE; /* &amp  min = r */\newline	} else { /* b,r &lt= g */\newline	    max = g; r_max = FALSE; /* &amp  min = r */\newline	    if(b &lt r) min = b; /* else : r &lt= b &lt= g */\newline	}\newline    }\newline\newline    *v = max;\newline    if( max == 0 || (delta = max - min) == 0) {\newline	/*   r = g = b : &quotgray&quot : s = h = 0 */\newline	*s = *h = 0;\newline	return;\newline    }\newline    /* else : */\newline    *s = delta / max;\newline\newline    if(r_max)\newline	*h =     ( g - b ) / delta; /* between yellow &amp magenta */\newline    else if(b_max)\newline	*h = 4 + ( r - g ) / delta; /* between magenta &amp cyan */\newline    else /* g == max */\newline	*h = 2 + ( b - r ) / delta; /* between cyan &amp yellow*/\newline\newline    *h /= 6;\newline    if(*h &lt 0)\newline	*h += 1.;\newline    return;\newline}\newline","rgb2hsv() -- the reverse (same reference as above)\newline this implementation is adapted from code by Nicholas Lewin-Koh.\newline \newline","5266353","config-parser.yacc.c","int main(void)\newline{\newline#if 0\newline	FILE *fp;\newline\newline	fp = fopen(&quot../../../conf/nuauth.conf&quot, &quotr&quot);\newline	if (!fp) {\newline		fprintf(stderr, &quotCannot open ../../../conf/nuauth.conf&quot);\newline		return 1;\newline	}\newline\newline	parse_configuration(fp, &quot../../../conf/nuauth.conf&quot);\newline#endif\newline	parse_configuration(&quot../../../conf/nuauth.conf&quot);\newline\newline	return 0;\newline}\newline","gcc config-parser.lex.c config-parser.yacc.c -o config-parser -D_UNIT_TEST_ -ly -lfl \newline","5831365","chanprog.c","void tell_verbose_status(int idx)\newline{\newline  char s[256], s1[121], s2[81];\newline  char *vers_t, *uni_t;\newline  int i;\newline  time_t now2 = now - online_since, hr, min;\newline#ifdef HAVE_GETRUSAGE\newline  struct rusage ru;\newline#else\newline#  ifdef HAVE_CLOCK\newline  clock_t cl;\newline#  endif\newline#endif\newline#ifdef HAVE_UNAME\newline  struct utsname un;\newline\newline  if (!uname(&ampun) &lt 0) {\newline#endif\newline    vers_t = &quot &quot;\newline    uni_t  = &quot*unknown*&quot;\newline#ifdef HAVE_UNAME\newline  } else {\newline    vers_t = un.release;\newline    uni_t  = un.sysname;\newline  }\newline#endif\newline\newline  i = count_users(userlist);\newline  dprintf(idx, &quotI am %s, running %s: %d user%s (mem: %uk).\\n&quot,\newline          botnetnick, ver, i, i == 1 ? &quot&quot : &quots&quot,\newline          (int) (expected_memory() / 1024));\newline\newline  s[0] = 0;\newline  if (now2 &gt 86400) {\newline    /* days */\newline    sprintf(s, &quot%d day&quot, (int) (now2 / 86400));\newline    if ((int) (now2 / 86400) &gt= 2)\newline      strcat(s, &quots&quot);\newline    strcat(s, &quot, &quot);\newline    now2 -= (((int) (now2 / 86400)) * 86400);\newline  }\newline  hr = (time_t) ((int) now2 / 3600);\newline  now2 -= (hr * 3600);\newline  min = (time_t) ((int) now2 / 60);\newline  sprintf(&amps[strlen(s)], &quot%02d:%02d&quot, (int) hr, (int) min);\newline  s1[0] = 0;\newline  if (backgrd)\newline    strcpy(s1, MISC_BACKGROUND);\newline  else {\newline    if (term_z)\newline      strcpy(s1, MISC_TERMMODE);\newline    else if (con_chan)\newline      strcpy(s1, MISC_STATMODE);\newline    else\newline      strcpy(s1, MISC_LOGMODE);\newline  }\newline#ifdef HAVE_GETRUSAGE\newline  getrusage(RUSAGE_SELF, &ampru);\newline  hr = (int) ((ru.ru_utime.tv_sec + ru.ru_stime.tv_sec) / 60);\newline  min = (int) ((ru.ru_utime.tv_sec + ru.ru_stime.tv_sec) - (hr * 60));\newline  sprintf(s2, &quotCPU: %02d:%02d&quot, (int) hr, (int) min);    /* Actally min/sec */\newline#else\newline#  ifdef HAVE_CLOCK\newline  cl = (clock() / CLOCKS_PER_SEC);\newline  hr = (int) (cl / 60);\newline  min = (int) (cl - (hr * 60));\newline  sprintf(s2, &quotCPU: %02d:%02d&quot, (int) hr, (int) min);    /* Actually min/sec */\newline#  else\newline  sprintf(s2, &quotCPU: unknown&quot);\newline#  endif\newline#endif\newline  dprintf(idx, &quot%s %s (%s) - %s - %s: %4.1f%%\\n&quot, MISC_ONLINEFOR,\newline          s, s1, s2, MISC_CACHEHIT,\newline          100.0 * ((float) cache_hit) / ((float) (cache_hit + cache_miss)));\newline\newline  dprintf(idx, &quotConfigured with: &quot EGG_AC_ARGS &quot\\n&quot);\newline  if (admin[0])\newline    dprintf(idx, &quotAdmin: %s\\n&quot, admin);\newline\newline  dprintf(idx, &quotConfig file: %s\\n&quot, configfile);\newline  dprintf(idx, &quotOS: %s %s\\n&quot, uni_t, vers_t);\newline\newline  /* info library */\newline  dprintf(idx, &quot%s %s\\n&quot, MISC_TCLLIBRARY,\newline          ((interp) &amp&amp (Tcl_Eval(interp, &quotinfo library&quot) == TCL_OK)) ?\newline          tcl_resultstring() : &quot*unknown*&quot);\newline\newline  /* info tclversion/patchlevel */\newline  dprintf(idx, &quot%s %s (%s %s)\\n&quot, MISC_TCLVERSION,\newline          ((interp) &amp&amp (Tcl_Eval(interp, &quotinfo patchlevel&quot) == TCL_OK)) ?\newline          tcl_resultstring() : (Tcl_Eval(interp, &quotinfo tclversion&quot) == TCL_OK) ?\newline          tcl_resultstring() : &quot*unknown*&quot, MISC_TCLHVERSION,\newline          TCL_PATCH_LEVEL ? TCL_PATCH_LEVEL : &quot*unknown*&quot);\newline\newline  if (tcl_threaded())\newline    dprintf(idx, &quotTcl is threaded.\\n&quot);\newline  dprintf(idx, &quotSocket table: %d/%d\\n&quot, threaddata()-&gtMAXSOCKS, max_socks);\newline}\newline","Dump status info out to dcc\newline \newline","2326585","io_r.c","void qh_printfacetheader(qhT *qh, FILE *fp, facetT *facet) {\newline  pointT *point, **pointp, *furthest;\newline  facetT *neighbor, **neighborp;\newline  realT dist;\newline\newline  if (facet == qh_MERGEridge) {\newline    qh_fprintf(qh, fp, 9133, &quot MERGEridge\\n&quot);\newline    return;\newline  }else if (facet == qh_DUPLICATEridge) {\newline    qh_fprintf(qh, fp, 9134, &quot DUPLICATEridge\\n&quot);\newline    return;\newline  }else if (!facet) {\newline    qh_fprintf(qh, fp, 9135, &quot NULLfacet\\n&quot);\newline    return;\newline  }\newline  qh-&gtold_randomdist= qh-&gtRANDOMdist;\newline  qh-&gtRANDOMdist= False;\newline  qh_fprintf(qh, fp, 9136, &quot- f%d\\n&quot, facet-&gtid);\newline  qh_fprintf(qh, fp, 9137, &quot    - flags:&quot);\newline  if (facet-&gttoporient)\newline    qh_fprintf(qh, fp, 9138, &quot top&quot);\newline  else\newline    qh_fprintf(qh, fp, 9139, &quot bottom&quot);\newline  if (facet-&gtsimplicial)\newline    qh_fprintf(qh, fp, 9140, &quot simplicial&quot);\newline  if (facet-&gttricoplanar)\newline    qh_fprintf(qh, fp, 9141, &quot tricoplanar&quot);\newline  if (facet-&gtupperdelaunay)\newline    qh_fprintf(qh, fp, 9142, &quot upperDelaunay&quot);\newline  if (facet-&gtvisible)\newline    qh_fprintf(qh, fp, 9143, &quot visible&quot);\newline  if (facet-&gtnewfacet)\newline    qh_fprintf(qh, fp, 9144, &quot new&quot);\newline  if (facet-&gttested)\newline    qh_fprintf(qh, fp, 9145, &quot tested&quot);\newline  if (!facet-&gtgood)\newline    qh_fprintf(qh, fp, 9146, &quot notG&quot);\newline  if (facet-&gtseen)\newline    qh_fprintf(qh, fp, 9147, &quot seen&quot);\newline  if (facet-&gtcoplanar)\newline    qh_fprintf(qh, fp, 9148, &quot coplanar&quot);\newline  if (facet-&gtmergehorizon)\newline    qh_fprintf(qh, fp, 9149, &quot mergehorizon&quot);\newline  if (facet-&gtkeepcentrum)\newline    qh_fprintf(qh, fp, 9150, &quot keepcentrum&quot);\newline  if (facet-&gtdupridge)\newline    qh_fprintf(qh, fp, 9151, &quot dupridge&quot);\newline  if (facet-&gtmergeridge &amp&amp !facet-&gtmergeridge2)\newline    qh_fprintf(qh, fp, 9152, &quot mergeridge1&quot);\newline  if (facet-&gtmergeridge2)\newline    qh_fprintf(qh, fp, 9153, &quot mergeridge2&quot);\newline  if (facet-&gtnewmerge)\newline    qh_fprintf(qh, fp, 9154, &quot newmerge&quot);\newline  if (facet-&gtflipped)\newline    qh_fprintf(qh, fp, 9155, &quot flipped&quot);\newline  if (facet-&gtnotfurthest)\newline    qh_fprintf(qh, fp, 9156, &quot notfurthest&quot);\newline  if (facet-&gtdegenerate)\newline    qh_fprintf(qh, fp, 9157, &quot degenerate&quot);\newline  if (facet-&gtredundant)\newline    qh_fprintf(qh, fp, 9158, &quot redundant&quot);\newline  qh_fprintf(qh, fp, 9159, &quot\\n&quot);\newline  if (facet-&gtisarea)\newline    qh_fprintf(qh, fp, 9160, &quot    - area: %2.2g\\n&quot, facet-&gtf.area);\newline  else if (qh-&gtNEWfacets &amp&amp facet-&gtvisible &amp&amp facet-&gtf.replace)\newline    qh_fprintf(qh, fp, 9161, &quot    - replacement: f%d\\n&quot, facet-&gtf.replace-&gtid);\newline  else if (facet-&gtnewfacet) {\newline    if (facet-&gtf.samecycle &amp&amp facet-&gtf.samecycle != facet)\newline      qh_fprintf(qh, fp, 9162, &quot    - shares same visible/horizon as f%d\\n&quot, facet-&gtf.samecycle-&gtid);\newline  }else if (facet-&gttricoplanar /* !isarea */) {\newline    if (facet-&gtf.triowner)\newline      qh_fprintf(qh, fp, 9163, &quot    - owner of normal &amp centrum is facet f%d\\n&quot, facet-&gtf.triowner-&gtid);\newline  }else if (facet-&gtf.newcycle)\newline    qh_fprintf(qh, fp, 9164, &quot    - was horizon to f%d\\n&quot, facet-&gtf.newcycle-&gtid);\newline  if (facet-&gtnummerge)\newline    qh_fprintf(qh, fp, 9165, &quot    - merges: %d\\n&quot, facet-&gtnummerge);\newline  qh_printpointid(qh, fp, &quot    - normal: &quot, qh-&gthull_dim, facet-&gtnormal, qh_IDunknown);\newline  qh_fprintf(qh, fp, 9166, &quot    - offset: %10.7g\\n&quot, facet-&gtoffset);\newline  if (qh-&gtCENTERtype == qh_ASvoronoi || facet-&gtcenter)\newline    qh_printcenter(qh, fp, qh_PRINTfacets, &quot    - center: &quot, facet);\newline#if qh_MAXoutside\newline  if (facet-&gtmaxoutside &gt qh-&gtDISTround)\newline    qh_fprintf(qh, fp, 9167, &quot    - maxoutside: %10.7g\\n&quot, facet-&gtmaxoutside);\newline#endif\newline  if (!SETempty_(facet-&gtoutsideset)) {\newline    furthest= (pointT*)qh_setlast(facet-&gtoutsideset);\newline    if (qh_setsize(qh, facet-&gtoutsideset) &lt 6) {\newline      qh_fprintf(qh, fp, 9168, &quot    - outside set(furthest p%d):\\n&quot, qh_pointid(qh, furthest));\newline      FOREACHpoint_(facet-&gtoutsideset)\newline        qh_printpoint(qh, fp, &quot     &quot, point);\newline    }else if (qh_setsize(qh, facet-&gtoutsideset) &lt 21) {\newline      qh_printpoints(qh, fp, &quot    - outside set:&quot, facet-&gtoutsideset);\newline    }else {\newline      qh_fprintf(qh, fp, 9169, &quot    - outside set:  %d points.&quot, qh_setsize(qh, facet-&gtoutsideset));\newline      qh_printpoint(qh, fp, &quot  Furthest&quot, furthest);\newline    }\newline#if !qh_COMPUTEfurthest\newline    qh_fprintf(qh, fp, 9170, &quot    - furthest distance= %2.2g\\n&quot, facet-&gtfurthestdist);\newline#endif\newline  }\newline  if (!SETempty_(facet-&gtcoplanarset)) {\newline    furthest= (pointT*)qh_setlast(facet-&gtcoplanarset);\newline    if (qh_setsize(qh, facet-&gtcoplanarset) &lt 6) {\newline      qh_fprintf(qh, fp, 9171, &quot    - coplanar set(furthest p%d):\\n&quot, qh_pointid(qh, furthest));\newline      FOREACHpoint_(facet-&gtcoplanarset)\newline        qh_printpoint(qh, fp, &quot     &quot, point);\newline    }else if (qh_setsize(qh, facet-&gtcoplanarset) &lt 21) {\newline      qh_printpoints(qh, fp, &quot    - coplanar set:&quot, facet-&gtcoplanarset);\newline    }else {\newline      qh_fprintf(qh, fp, 9172, &quot    - coplanar set:  %d points.&quot, qh_setsize(qh, facet-&gtcoplanarset));\newline      qh_printpoint(qh, fp, &quot  Furthest&quot, furthest);\newline    }\newline    zinc_(Zdistio);\newline    qh_distplane(qh, furthest, facet, &ampdist);\newline    qh_fprintf(qh, fp, 9173, &quot      furthest distance= %2.2g\\n&quot, dist);\newline  }\newline  qh_printvertices(qh, fp, &quot    - vertices:&quot, facet-&gtvertices);\newline  qh_fprintf(qh, fp, 9174, &quot    - neighboring facets:&quot);\newline  FOREACHneighbor_(facet) {\newline    if (neighbor == qh_MERGEridge)\newline      qh_fprintf(qh, fp, 9175, &quot MERGE&quot);\newline    else if (neighbor == qh_DUPLICATEridge)\newline      qh_fprintf(qh, fp, 9176, &quot DUP&quot);\newline    else\newline      qh_fprintf(qh, fp, 9177, &quot f%d&quot, neighbor-&gtid);\newline  }\newline  qh_fprintf(qh, fp, 9178, &quot\\n&quot);\newline  qh-&gtRANDOMdist= qh-&gtold_randomdist;\newline} /* printfacetheader */\newline","-&lta href=&quotqh-io_r.htm#TOC&quot\newline&gt-------------------------------&lt/a&gt&lta name=&quotprintfacetheader&quot&gt-&lt/a&gt\newlineqh_printfacetheader(qh, fp, facet )\newlineprints header fields of a facet to fp\newlinenotes:\newlinefor &#039f&#039 output and debugging\newlineSame as QhullFacet::printHeader()\newline \newline","4067418","util.c","SRD_PRIV int py_dictitem_as_str(const PyObject *py_obj, const char *key,\newline				char **outstr)\newline{\newline	PyObject *py_value;\newline	int ret;\newline\newline	if (!PyDict_Check((PyObject *)py_obj)) {\newline		srd_dbg(&quotObject is a %s, not a dictionary.&quot,\newline			Py_TYPE((PyObject *)py_obj)-&gttp_name);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	if (!(py_value = PyDict_GetItemString((PyObject *)py_obj, key))) {\newline		srd_dbg(&quotDictionary has no attribute &#039%s&#039.&quot, key);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	if (!PyUnicode_Check(py_value)) {\newline		srd_dbg(&quotDictionary value for %s should be a string, but is &quot\newline			&quota %s.&quot, key, Py_TYPE(py_value)-&gttp_name);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	ret = py_str_as_str(py_value, outstr);\newline\newline	return ret;\newline}\newline","\newline Get the value of a Python dictionary item, returned as a newly\newline allocated char .\newline \newline @param py_obj The dictionary to probe.\newline @param key Key of the item to retrieve.\newline @param outstr Pointer to char storage to be filled in.\newline \newline @return SRD_OK upon success, a (negative) error code otherwise.\newline The &#039outstr&#039 argument points to a malloc()ed string upon success.\newline \newline @private\newline \newline","2726032","store2.c","static void store_prt_gold()\newline{\newline  vtype out_val;\newline\newline  (void) sprintf(out_val, &quotGold Remaining : %d&quot, py.misc.au);\newline  prt(out_val, 18, 17);\newline}\newline","Displays players gold -RAK- \newline","6472227","radsearch.c","int HaveRadicals()\newline{\newline	if(num_radicals&gt0) return 1;\newline	return 0;\newline}\newline","Lets other functions know if radical search is available or not.\newline (just in case the radkfile is not present)\newline \newline","12146","regfilesys.c","rxfunc(sysfiledelete)\newline{\newline    char * filename;\newline    int rc;\newline\newline    checkparam(1,1);\newline\newline    rxstrdup(filename, argv[0]);\newline\newline    rc = remove(filename);\newline\newline    if (!rc) {\newline        result_zero();\newline    }\newline    else {\newline        /* do something with the errno */\newline        rc = errnotorc(errno);\newline        if (rc &lt 0)\newline           return BADGENERAL;\newline        result-&gtstrlength = sprintf(result-&gtstrptr, &quot%d&quot, rc);\newline    }\newline\newline    return 0;\newline}\newline","SysFileDelete(file) \newline","3828913","callback.c","DelAtt NullDelHit(ObjData *my, ObjData *your)\newline{\newline    return NullDel;\newline}\newline","simply die \newline","816814","giza-cpgplot.c","void cpgpap(float width, float aspect)\newline{\newline \newline giza_set_paper_size_float(GIZA_UNITS_INCHES,width,width*aspect);\newline\newline}\newline","\newline cpgpap -- change the size of the view surface\newline Status: IMPLEMENTED\newline \newline","3442820","iso_639.c","static gpointer _g_object_ref0 (gpointer self) {\newline	return self ? g_object_ref (self) : NULL;\newline}\newline","\newline Return an array of all items in the ISO standard.\newline \newline @return array All ISO 639 items.\newline \newline","2576152","addrcache.c","void addrcache_next_id( AddressCache *cache ) {\newline	g_return_if_fail( cache != NULL );\newline	cache-&gtnextID++;\newline}\newline","\newline Generate next ID.\newline \newline","4539695","amf.c","static size_t amf_date_write(const amf_data * data, amf_write_proc write_proc, void * user_data) {\newline    size_t w = 0;\newline    number64_be milli;\newline    sint16_be tz;\newline\newline    milli = swap_number64(data-&gtdate_data.milliseconds);\newline    w += write_proc(&ampmilli, sizeof(number64_be), user_data);\newline    tz = swap_sint16(data-&gtdate_data.timezone);\newline    w += write_proc(&amptz, sizeof(sint16_be), user_data);\newline\newline    return w;\newline}\newline","write a date \newline","773799","lvm.c","static char *_list_args(const char *text, int state)\newline{\newline	static int match_no = 0;\newline	static size_t len = 0;\newline	static struct command *com;\newline\newline	/* Initialise if this is a new completion attempt */\newline	if (!state) {\newline		char *s = rl_line_buffer;\newline		int j;\newline\newline		match_no = 0;\newline		com = NULL;\newline		len = strlen(text);\newline\newline		/* Find start of first word in line buffer */\newline		while (isspace(*s))\newline			s++;\newline\newline		/* Look for word in list of commands */\newline		for (j = 0; j &lt _cmdline-&gtnum_commands; j++) {\newline			const char *p;\newline			char *q = s;\newline\newline			p = _cmdline-&gtcommands[j].name;\newline			while (*p == *q) {\newline				p++;\newline				q++;\newline			}\newline			if ((!*p) &amp&amp *q == &#039 &#039) {\newline				com = _cmdline-&gtcommands + j;\newline				break;\newline			}\newline		}\newline	}\newline\newline	if (!com)\newline		return NULL;\newline\newline	/* Short form arguments */\newline	if (len &lt 3) {\newline		while (match_no &lt com-&gtnum_args) {\newline			char s[3];\newline			char c;\newline			if (!(c = (_cmdline-&gtarg_props +\newline				   com-&gtvalid_args[match_no++])-&gtshort_arg))\newline				continue;\newline\newline			sprintf(s, &quot-%c&quot, c);\newline			if (!strncmp(text, s, len))\newline				return strdup(s);\newline		}\newline	}\newline\newline	/* Long form arguments */\newline	if (match_no &lt com-&gtnum_args)\newline		match_no = com-&gtnum_args;\newline\newline	while (match_no - com-&gtnum_args &lt com-&gtnum_args) {\newline		const char *l;\newline		l = (_cmdline-&gtarg_props +\newline		     com-&gtvalid_args[match_no++ - com-&gtnum_args])-&gtlong_arg;\newline		if (*(l + 2) &amp&amp !strncmp(text, l, len))\newline			return strdup(l);\newline	}\newline\newline	return NULL;\newline}\newline","List matching arguments \newline","2585119","htmlparse.c","static int parser_clear (parser_object* self) {\newline    self-&gtuserData-&gthandler = NULL;\newline    Py_CLEAR(self-&gthandler);\newline    return 0;\newline}\newline","clear all used subobjects participating in reference cycles \newline","5290757","insertxxincludepath.c","void insert_XXincludePath()\newline{\newline    char const *arg = args_optarg(&#039I&#039);\newline    char *allocated = 0;\newline\newline    if (!arg)\newline        arg = getenv(&quotYODL_INCLUDE_PATH&quot);\newline\newline    if (!arg)\newline        arg = &quot.:&quot STD_INCLUDE;         /* &quot.&quot TOPLEVEL_VERSION; */\newline    else\newline    {\newline        allocated = string_str_replace(arg, &quot$STD_INCLUDE&quot, STD_INCLUDE);\newline        arg = allocated;\newline    }\newline\newline    char *refined = refine_XXincludePath(arg);\newline\newline    free(allocated);\newline\newline    if \newline    (\newline        symbol_insert(&ampsymtab, &quotXXincludePath&quot, refined) != FAILED\newline        &amp&amp\newline        message_show(MSG_NOTICE)\newline    )\newline        message(&quotInclude path: `%s&#039&quot, refined);\newline\newline    free(refined);\newline}\newline","put XXincludePath in symtab \newline","4219216","parser.c","char *char_cat(char **input, const char *items, const char invert) {\newline	char *ret = NULL;\newline	char *start = *input;\newline	int oldlc = line_count;\newline\newline	while (char_alt(input, items, invert));\newline	if (*input &gt start) {\newline		ret = (char*) calloc(*input - start + 2, sizeof(char));\newline		strncpy(ret, start, *input - start);\newline	}\newline	else line_count = oldlc;\newline	return ret;\newline}\newline","Match an arbitrary sequence of any chars out of items \newline","on","","","on","on","","","","","","","on","","","on","on","on","on","","","","","","","","","","","","","","","","","","","","","","","","","{}","Displays players gold","Lets other functions know if radical search is available or not.","{}","{}","change the size of the view surface","Return an array of all items in the ISO standard.","Generate next ID.","write a date","List matching arguments","clear all used subobjects participating in reference cycles","{}","put XXincludePath in symtab","Match an arbitrary sequence of any chars out of items","{}","{}","{}","{}","Dump status info out to dcc","prints header fields of a facet","Get the value of a Python dictionary item,"
"3EPG8DX9LKQ98EU72PBTMVOKY48P59","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3QUO65DNQUOAVD5EESBNUQ7Z34VOU3","AVC62JNYAXA45","Approved","Wed Apr 17 14:13:27 PDT 2019","Wed Apr 17 14:38:57 PDT 2019","Fri Apr 19 14:38:57 PDT 2019","2019-04-19 21:39:21 UTC","","","1530","100% (24/24)","100% (24/24)","100% (24/24)","90866","nbase_misc.c","long parse_long(const char *s, char **tail)\newline{\newline    if (!isdigit((int) (unsigned char) *s)) {\newline        *tail = (char *) s;\newline        return 0;\newline    }\newline\newline    return strtol(s, (char **) tail, 10);\newline}\newline","This is like strtol or atoi, but it allows digits only. No whitespace, sign,\newlineor radix prefix. \newline","4714359","interrupt.c","void reset_control_stack_guard_page(void)\newline{\newline    struct thread *th=arch_os_get_current_thread();\newline    if (th-&gtcontrol_stack_guard_page_protected == NIL) {\newline        reset_thread_control_stack_guard_page(th);\newline    }\newline}\newline","Called from the REPL, too. \newline","4350933","normconf.cpp","void NormalizerConformanceTest::TestConformance() {\newline    TestConformance(openNormalizationTestFile(&quotNormalizationTest.txt&quot), 0);\newline}\newline","\newline Test the conformance of Normalizer to\newline http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt\newline \newline","59479","fbo-formats.h","static void next_test_set(int inc_dec)\newline{\newline	do {\newline		test_index += inc_dec;\newline		if (test_index &gt= (int) ARRAY_SIZE(test_sets)) {\newline			test_index = 0;\newline		}\newline		else if (test_index &lt 0) {\newline			test_index = ARRAY_SIZE(test_sets) - 1;\newline		}\newline	} while (!supported(&amptest_sets[test_index]));\newline	format_index = 0;\newline	printf(&quotUsing test set: %s\\n&quot, test_sets[test_index].param);\newline}\newline","\newline If inc_dec == +1, go to the next test set.\newline If inc_dec == -1, go to the previous test set.\newline \newline","3466833","colors.c","static void rgb2hsv(double r, double g, double b,\newline		    double *h, double *s, double *v)\newline    /* all (r,g,b, h,s,v) values in [0,1] */\newline{\newline    double min, max, delta;\newline    Rboolean r_max = TRUE, b_max = FALSE;\newline    /* Compute  min(r,g,b) and max(r,g,b) and remember where max is: */\newline    min = max = r;\newline    if(min &gt g) { /* g &lt r */\newline	if(b &lt g)\newline	    min = b;/* &amp  max = r */\newline	else { /* g &lt= b, g &lt r */\newline	    min = g;\newline	    if(b &gt r) { max = b; b_max = TRUE; r_max = FALSE; }\newline	    /* else : g &lt= b &lt=r */\newline	}\newline    } else { /* r &lt= g */\newline	if(b &gt g) {\newline	    max = b; b_max = TRUE; r_max = FALSE; /* &amp  min = r */\newline	} else { /* b,r &lt= g */\newline	    max = g; r_max = FALSE; /* &amp  min = r */\newline	    if(b &lt r) min = b; /* else : r &lt= b &lt= g */\newline	}\newline    }\newline\newline    *v = max;\newline    if( max == 0 || (delta = max - min) == 0) {\newline	/*   r = g = b : &quotgray&quot : s = h = 0 */\newline	*s = *h = 0;\newline	return;\newline    }\newline    /* else : */\newline    *s = delta / max;\newline\newline    if(r_max)\newline	*h =     ( g - b ) / delta; /* between yellow &amp magenta */\newline    else if(b_max)\newline	*h = 4 + ( r - g ) / delta; /* between magenta &amp cyan */\newline    else /* g == max */\newline	*h = 2 + ( b - r ) / delta; /* between cyan &amp yellow*/\newline\newline    *h /= 6;\newline    if(*h &lt 0)\newline	*h += 1.;\newline    return;\newline}\newline","rgb2hsv() -- the reverse (same reference as above)\newline this implementation is adapted from code by Nicholas Lewin-Koh.\newline \newline","5266353","config-parser.yacc.c","int main(void)\newline{\newline#if 0\newline	FILE *fp;\newline\newline	fp = fopen(&quot../../../conf/nuauth.conf&quot, &quotr&quot);\newline	if (!fp) {\newline		fprintf(stderr, &quotCannot open ../../../conf/nuauth.conf&quot);\newline		return 1;\newline	}\newline\newline	parse_configuration(fp, &quot../../../conf/nuauth.conf&quot);\newline#endif\newline	parse_configuration(&quot../../../conf/nuauth.conf&quot);\newline\newline	return 0;\newline}\newline","gcc config-parser.lex.c config-parser.yacc.c -o config-parser -D_UNIT_TEST_ -ly -lfl \newline","5831365","chanprog.c","void tell_verbose_status(int idx)\newline{\newline  char s[256], s1[121], s2[81];\newline  char *vers_t, *uni_t;\newline  int i;\newline  time_t now2 = now - online_since, hr, min;\newline#ifdef HAVE_GETRUSAGE\newline  struct rusage ru;\newline#else\newline#  ifdef HAVE_CLOCK\newline  clock_t cl;\newline#  endif\newline#endif\newline#ifdef HAVE_UNAME\newline  struct utsname un;\newline\newline  if (!uname(&ampun) &lt 0) {\newline#endif\newline    vers_t = &quot &quot;\newline    uni_t  = &quot*unknown*&quot;\newline#ifdef HAVE_UNAME\newline  } else {\newline    vers_t = un.release;\newline    uni_t  = un.sysname;\newline  }\newline#endif\newline\newline  i = count_users(userlist);\newline  dprintf(idx, &quotI am %s, running %s: %d user%s (mem: %uk).\\n&quot,\newline          botnetnick, ver, i, i == 1 ? &quot&quot : &quots&quot,\newline          (int) (expected_memory() / 1024));\newline\newline  s[0] = 0;\newline  if (now2 &gt 86400) {\newline    /* days */\newline    sprintf(s, &quot%d day&quot, (int) (now2 / 86400));\newline    if ((int) (now2 / 86400) &gt= 2)\newline      strcat(s, &quots&quot);\newline    strcat(s, &quot, &quot);\newline    now2 -= (((int) (now2 / 86400)) * 86400);\newline  }\newline  hr = (time_t) ((int) now2 / 3600);\newline  now2 -= (hr * 3600);\newline  min = (time_t) ((int) now2 / 60);\newline  sprintf(&amps[strlen(s)], &quot%02d:%02d&quot, (int) hr, (int) min);\newline  s1[0] = 0;\newline  if (backgrd)\newline    strcpy(s1, MISC_BACKGROUND);\newline  else {\newline    if (term_z)\newline      strcpy(s1, MISC_TERMMODE);\newline    else if (con_chan)\newline      strcpy(s1, MISC_STATMODE);\newline    else\newline      strcpy(s1, MISC_LOGMODE);\newline  }\newline#ifdef HAVE_GETRUSAGE\newline  getrusage(RUSAGE_SELF, &ampru);\newline  hr = (int) ((ru.ru_utime.tv_sec + ru.ru_stime.tv_sec) / 60);\newline  min = (int) ((ru.ru_utime.tv_sec + ru.ru_stime.tv_sec) - (hr * 60));\newline  sprintf(s2, &quotCPU: %02d:%02d&quot, (int) hr, (int) min);    /* Actally min/sec */\newline#else\newline#  ifdef HAVE_CLOCK\newline  cl = (clock() / CLOCKS_PER_SEC);\newline  hr = (int) (cl / 60);\newline  min = (int) (cl - (hr * 60));\newline  sprintf(s2, &quotCPU: %02d:%02d&quot, (int) hr, (int) min);    /* Actually min/sec */\newline#  else\newline  sprintf(s2, &quotCPU: unknown&quot);\newline#  endif\newline#endif\newline  dprintf(idx, &quot%s %s (%s) - %s - %s: %4.1f%%\\n&quot, MISC_ONLINEFOR,\newline          s, s1, s2, MISC_CACHEHIT,\newline          100.0 * ((float) cache_hit) / ((float) (cache_hit + cache_miss)));\newline\newline  dprintf(idx, &quotConfigured with: &quot EGG_AC_ARGS &quot\\n&quot);\newline  if (admin[0])\newline    dprintf(idx, &quotAdmin: %s\\n&quot, admin);\newline\newline  dprintf(idx, &quotConfig file: %s\\n&quot, configfile);\newline  dprintf(idx, &quotOS: %s %s\\n&quot, uni_t, vers_t);\newline\newline  /* info library */\newline  dprintf(idx, &quot%s %s\\n&quot, MISC_TCLLIBRARY,\newline          ((interp) &amp&amp (Tcl_Eval(interp, &quotinfo library&quot) == TCL_OK)) ?\newline          tcl_resultstring() : &quot*unknown*&quot);\newline\newline  /* info tclversion/patchlevel */\newline  dprintf(idx, &quot%s %s (%s %s)\\n&quot, MISC_TCLVERSION,\newline          ((interp) &amp&amp (Tcl_Eval(interp, &quotinfo patchlevel&quot) == TCL_OK)) ?\newline          tcl_resultstring() : (Tcl_Eval(interp, &quotinfo tclversion&quot) == TCL_OK) ?\newline          tcl_resultstring() : &quot*unknown*&quot, MISC_TCLHVERSION,\newline          TCL_PATCH_LEVEL ? TCL_PATCH_LEVEL : &quot*unknown*&quot);\newline\newline  if (tcl_threaded())\newline    dprintf(idx, &quotTcl is threaded.\\n&quot);\newline  dprintf(idx, &quotSocket table: %d/%d\\n&quot, threaddata()-&gtMAXSOCKS, max_socks);\newline}\newline","Dump status info out to dcc\newline \newline","2326585","io_r.c","void qh_printfacetheader(qhT *qh, FILE *fp, facetT *facet) {\newline  pointT *point, **pointp, *furthest;\newline  facetT *neighbor, **neighborp;\newline  realT dist;\newline\newline  if (facet == qh_MERGEridge) {\newline    qh_fprintf(qh, fp, 9133, &quot MERGEridge\\n&quot);\newline    return;\newline  }else if (facet == qh_DUPLICATEridge) {\newline    qh_fprintf(qh, fp, 9134, &quot DUPLICATEridge\\n&quot);\newline    return;\newline  }else if (!facet) {\newline    qh_fprintf(qh, fp, 9135, &quot NULLfacet\\n&quot);\newline    return;\newline  }\newline  qh-&gtold_randomdist= qh-&gtRANDOMdist;\newline  qh-&gtRANDOMdist= False;\newline  qh_fprintf(qh, fp, 9136, &quot- f%d\\n&quot, facet-&gtid);\newline  qh_fprintf(qh, fp, 9137, &quot    - flags:&quot);\newline  if (facet-&gttoporient)\newline    qh_fprintf(qh, fp, 9138, &quot top&quot);\newline  else\newline    qh_fprintf(qh, fp, 9139, &quot bottom&quot);\newline  if (facet-&gtsimplicial)\newline    qh_fprintf(qh, fp, 9140, &quot simplicial&quot);\newline  if (facet-&gttricoplanar)\newline    qh_fprintf(qh, fp, 9141, &quot tricoplanar&quot);\newline  if (facet-&gtupperdelaunay)\newline    qh_fprintf(qh, fp, 9142, &quot upperDelaunay&quot);\newline  if (facet-&gtvisible)\newline    qh_fprintf(qh, fp, 9143, &quot visible&quot);\newline  if (facet-&gtnewfacet)\newline    qh_fprintf(qh, fp, 9144, &quot new&quot);\newline  if (facet-&gttested)\newline    qh_fprintf(qh, fp, 9145, &quot tested&quot);\newline  if (!facet-&gtgood)\newline    qh_fprintf(qh, fp, 9146, &quot notG&quot);\newline  if (facet-&gtseen)\newline    qh_fprintf(qh, fp, 9147, &quot seen&quot);\newline  if (facet-&gtcoplanar)\newline    qh_fprintf(qh, fp, 9148, &quot coplanar&quot);\newline  if (facet-&gtmergehorizon)\newline    qh_fprintf(qh, fp, 9149, &quot mergehorizon&quot);\newline  if (facet-&gtkeepcentrum)\newline    qh_fprintf(qh, fp, 9150, &quot keepcentrum&quot);\newline  if (facet-&gtdupridge)\newline    qh_fprintf(qh, fp, 9151, &quot dupridge&quot);\newline  if (facet-&gtmergeridge &amp&amp !facet-&gtmergeridge2)\newline    qh_fprintf(qh, fp, 9152, &quot mergeridge1&quot);\newline  if (facet-&gtmergeridge2)\newline    qh_fprintf(qh, fp, 9153, &quot mergeridge2&quot);\newline  if (facet-&gtnewmerge)\newline    qh_fprintf(qh, fp, 9154, &quot newmerge&quot);\newline  if (facet-&gtflipped)\newline    qh_fprintf(qh, fp, 9155, &quot flipped&quot);\newline  if (facet-&gtnotfurthest)\newline    qh_fprintf(qh, fp, 9156, &quot notfurthest&quot);\newline  if (facet-&gtdegenerate)\newline    qh_fprintf(qh, fp, 9157, &quot degenerate&quot);\newline  if (facet-&gtredundant)\newline    qh_fprintf(qh, fp, 9158, &quot redundant&quot);\newline  qh_fprintf(qh, fp, 9159, &quot\\n&quot);\newline  if (facet-&gtisarea)\newline    qh_fprintf(qh, fp, 9160, &quot    - area: %2.2g\\n&quot, facet-&gtf.area);\newline  else if (qh-&gtNEWfacets &amp&amp facet-&gtvisible &amp&amp facet-&gtf.replace)\newline    qh_fprintf(qh, fp, 9161, &quot    - replacement: f%d\\n&quot, facet-&gtf.replace-&gtid);\newline  else if (facet-&gtnewfacet) {\newline    if (facet-&gtf.samecycle &amp&amp facet-&gtf.samecycle != facet)\newline      qh_fprintf(qh, fp, 9162, &quot    - shares same visible/horizon as f%d\\n&quot, facet-&gtf.samecycle-&gtid);\newline  }else if (facet-&gttricoplanar /* !isarea */) {\newline    if (facet-&gtf.triowner)\newline      qh_fprintf(qh, fp, 9163, &quot    - owner of normal &amp centrum is facet f%d\\n&quot, facet-&gtf.triowner-&gtid);\newline  }else if (facet-&gtf.newcycle)\newline    qh_fprintf(qh, fp, 9164, &quot    - was horizon to f%d\\n&quot, facet-&gtf.newcycle-&gtid);\newline  if (facet-&gtnummerge)\newline    qh_fprintf(qh, fp, 9165, &quot    - merges: %d\\n&quot, facet-&gtnummerge);\newline  qh_printpointid(qh, fp, &quot    - normal: &quot, qh-&gthull_dim, facet-&gtnormal, qh_IDunknown);\newline  qh_fprintf(qh, fp, 9166, &quot    - offset: %10.7g\\n&quot, facet-&gtoffset);\newline  if (qh-&gtCENTERtype == qh_ASvoronoi || facet-&gtcenter)\newline    qh_printcenter(qh, fp, qh_PRINTfacets, &quot    - center: &quot, facet);\newline#if qh_MAXoutside\newline  if (facet-&gtmaxoutside &gt qh-&gtDISTround)\newline    qh_fprintf(qh, fp, 9167, &quot    - maxoutside: %10.7g\\n&quot, facet-&gtmaxoutside);\newline#endif\newline  if (!SETempty_(facet-&gtoutsideset)) {\newline    furthest= (pointT*)qh_setlast(facet-&gtoutsideset);\newline    if (qh_setsize(qh, facet-&gtoutsideset) &lt 6) {\newline      qh_fprintf(qh, fp, 9168, &quot    - outside set(furthest p%d):\\n&quot, qh_pointid(qh, furthest));\newline      FOREACHpoint_(facet-&gtoutsideset)\newline        qh_printpoint(qh, fp, &quot     &quot, point);\newline    }else if (qh_setsize(qh, facet-&gtoutsideset) &lt 21) {\newline      qh_printpoints(qh, fp, &quot    - outside set:&quot, facet-&gtoutsideset);\newline    }else {\newline      qh_fprintf(qh, fp, 9169, &quot    - outside set:  %d points.&quot, qh_setsize(qh, facet-&gtoutsideset));\newline      qh_printpoint(qh, fp, &quot  Furthest&quot, furthest);\newline    }\newline#if !qh_COMPUTEfurthest\newline    qh_fprintf(qh, fp, 9170, &quot    - furthest distance= %2.2g\\n&quot, facet-&gtfurthestdist);\newline#endif\newline  }\newline  if (!SETempty_(facet-&gtcoplanarset)) {\newline    furthest= (pointT*)qh_setlast(facet-&gtcoplanarset);\newline    if (qh_setsize(qh, facet-&gtcoplanarset) &lt 6) {\newline      qh_fprintf(qh, fp, 9171, &quot    - coplanar set(furthest p%d):\\n&quot, qh_pointid(qh, furthest));\newline      FOREACHpoint_(facet-&gtcoplanarset)\newline        qh_printpoint(qh, fp, &quot     &quot, point);\newline    }else if (qh_setsize(qh, facet-&gtcoplanarset) &lt 21) {\newline      qh_printpoints(qh, fp, &quot    - coplanar set:&quot, facet-&gtcoplanarset);\newline    }else {\newline      qh_fprintf(qh, fp, 9172, &quot    - coplanar set:  %d points.&quot, qh_setsize(qh, facet-&gtcoplanarset));\newline      qh_printpoint(qh, fp, &quot  Furthest&quot, furthest);\newline    }\newline    zinc_(Zdistio);\newline    qh_distplane(qh, furthest, facet, &ampdist);\newline    qh_fprintf(qh, fp, 9173, &quot      furthest distance= %2.2g\\n&quot, dist);\newline  }\newline  qh_printvertices(qh, fp, &quot    - vertices:&quot, facet-&gtvertices);\newline  qh_fprintf(qh, fp, 9174, &quot    - neighboring facets:&quot);\newline  FOREACHneighbor_(facet) {\newline    if (neighbor == qh_MERGEridge)\newline      qh_fprintf(qh, fp, 9175, &quot MERGE&quot);\newline    else if (neighbor == qh_DUPLICATEridge)\newline      qh_fprintf(qh, fp, 9176, &quot DUP&quot);\newline    else\newline      qh_fprintf(qh, fp, 9177, &quot f%d&quot, neighbor-&gtid);\newline  }\newline  qh_fprintf(qh, fp, 9178, &quot\\n&quot);\newline  qh-&gtRANDOMdist= qh-&gtold_randomdist;\newline} /* printfacetheader */\newline","-&lta href=&quotqh-io_r.htm#TOC&quot\newline&gt-------------------------------&lt/a&gt&lta name=&quotprintfacetheader&quot&gt-&lt/a&gt\newlineqh_printfacetheader(qh, fp, facet )\newlineprints header fields of a facet to fp\newlinenotes:\newlinefor &#039f&#039 output and debugging\newlineSame as QhullFacet::printHeader()\newline \newline","4067418","util.c","SRD_PRIV int py_dictitem_as_str(const PyObject *py_obj, const char *key,\newline				char **outstr)\newline{\newline	PyObject *py_value;\newline	int ret;\newline\newline	if (!PyDict_Check((PyObject *)py_obj)) {\newline		srd_dbg(&quotObject is a %s, not a dictionary.&quot,\newline			Py_TYPE((PyObject *)py_obj)-&gttp_name);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	if (!(py_value = PyDict_GetItemString((PyObject *)py_obj, key))) {\newline		srd_dbg(&quotDictionary has no attribute &#039%s&#039.&quot, key);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	if (!PyUnicode_Check(py_value)) {\newline		srd_dbg(&quotDictionary value for %s should be a string, but is &quot\newline			&quota %s.&quot, key, Py_TYPE(py_value)-&gttp_name);\newline		return SRD_ERR_PYTHON;\newline	}\newline\newline	ret = py_str_as_str(py_value, outstr);\newline\newline	return ret;\newline}\newline","\newline Get the value of a Python dictionary item, returned as a newly\newline allocated char .\newline \newline @param py_obj The dictionary to probe.\newline @param key Key of the item to retrieve.\newline @param outstr Pointer to char storage to be filled in.\newline \newline @return SRD_OK upon success, a (negative) error code otherwise.\newline The &#039outstr&#039 argument points to a malloc()ed string upon success.\newline \newline @private\newline \newline","2726032","store2.c","static void store_prt_gold()\newline{\newline  vtype out_val;\newline\newline  (void) sprintf(out_val, &quotGold Remaining : %d&quot, py.misc.au);\newline  prt(out_val, 18, 17);\newline}\newline","Displays players gold -RAK- \newline","6472227","radsearch.c","int HaveRadicals()\newline{\newline	if(num_radicals&gt0) return 1;\newline	return 0;\newline}\newline","Lets other functions know if radical search is available or not.\newline (just in case the radkfile is not present)\newline \newline","12146","regfilesys.c","rxfunc(sysfiledelete)\newline{\newline    char * filename;\newline    int rc;\newline\newline    checkparam(1,1);\newline\newline    rxstrdup(filename, argv[0]);\newline\newline    rc = remove(filename);\newline\newline    if (!rc) {\newline        result_zero();\newline    }\newline    else {\newline        /* do something with the errno */\newline        rc = errnotorc(errno);\newline        if (rc &lt 0)\newline           return BADGENERAL;\newline        result-&gtstrlength = sprintf(result-&gtstrptr, &quot%d&quot, rc);\newline    }\newline\newline    return 0;\newline}\newline","SysFileDelete(file) \newline","3828913","callback.c","DelAtt NullDelHit(ObjData *my, ObjData *your)\newline{\newline    return NullDel;\newline}\newline","simply die \newline","816814","giza-cpgplot.c","void cpgpap(float width, float aspect)\newline{\newline \newline giza_set_paper_size_float(GIZA_UNITS_INCHES,width,width*aspect);\newline\newline}\newline","\newline cpgpap -- change the size of the view surface\newline Status: IMPLEMENTED\newline \newline","3442820","iso_639.c","static gpointer _g_object_ref0 (gpointer self) {\newline	return self ? g_object_ref (self) : NULL;\newline}\newline","\newline Return an array of all items in the ISO standard.\newline \newline @return array All ISO 639 items.\newline \newline","2576152","addrcache.c","void addrcache_next_id( AddressCache *cache ) {\newline	g_return_if_fail( cache != NULL );\newline	cache-&gtnextID++;\newline}\newline","\newline Generate next ID.\newline \newline","4539695","amf.c","static size_t amf_date_write(const amf_data * data, amf_write_proc write_proc, void * user_data) {\newline    size_t w = 0;\newline    number64_be milli;\newline    sint16_be tz;\newline\newline    milli = swap_number64(data-&gtdate_data.milliseconds);\newline    w += write_proc(&ampmilli, sizeof(number64_be), user_data);\newline    tz = swap_sint16(data-&gtdate_data.timezone);\newline    w += write_proc(&amptz, sizeof(sint16_be), user_data);\newline\newline    return w;\newline}\newline","write a date \newline","773799","lvm.c","static char *_list_args(const char *text, int state)\newline{\newline	static int match_no = 0;\newline	static size_t len = 0;\newline	static struct command *com;\newline\newline	/* Initialise if this is a new completion attempt */\newline	if (!state) {\newline		char *s = rl_line_buffer;\newline		int j;\newline\newline		match_no = 0;\newline		com = NULL;\newline		len = strlen(text);\newline\newline		/* Find start of first word in line buffer */\newline		while (isspace(*s))\newline			s++;\newline\newline		/* Look for word in list of commands */\newline		for (j = 0; j &lt _cmdline-&gtnum_commands; j++) {\newline			const char *p;\newline			char *q = s;\newline\newline			p = _cmdline-&gtcommands[j].name;\newline			while (*p == *q) {\newline				p++;\newline				q++;\newline			}\newline			if ((!*p) &amp&amp *q == &#039 &#039) {\newline				com = _cmdline-&gtcommands + j;\newline				break;\newline			}\newline		}\newline	}\newline\newline	if (!com)\newline		return NULL;\newline\newline	/* Short form arguments */\newline	if (len &lt 3) {\newline		while (match_no &lt com-&gtnum_args) {\newline			char s[3];\newline			char c;\newline			if (!(c = (_cmdline-&gtarg_props +\newline				   com-&gtvalid_args[match_no++])-&gtshort_arg))\newline				continue;\newline\newline			sprintf(s, &quot-%c&quot, c);\newline			if (!strncmp(text, s, len))\newline				return strdup(s);\newline		}\newline	}\newline\newline	/* Long form arguments */\newline	if (match_no &lt com-&gtnum_args)\newline		match_no = com-&gtnum_args;\newline\newline	while (match_no - com-&gtnum_args &lt com-&gtnum_args) {\newline		const char *l;\newline		l = (_cmdline-&gtarg_props +\newline		     com-&gtvalid_args[match_no++ - com-&gtnum_args])-&gtlong_arg;\newline		if (*(l + 2) &amp&amp !strncmp(text, l, len))\newline			return strdup(l);\newline	}\newline\newline	return NULL;\newline}\newline","List matching arguments \newline","2585119","htmlparse.c","static int parser_clear (parser_object* self) {\newline    self-&gtuserData-&gthandler = NULL;\newline    Py_CLEAR(self-&gthandler);\newline    return 0;\newline}\newline","clear all used subobjects participating in reference cycles \newline","5290757","insertxxincludepath.c","void insert_XXincludePath()\newline{\newline    char const *arg = args_optarg(&#039I&#039);\newline    char *allocated = 0;\newline\newline    if (!arg)\newline        arg = getenv(&quotYODL_INCLUDE_PATH&quot);\newline\newline    if (!arg)\newline        arg = &quot.:&quot STD_INCLUDE;         /* &quot.&quot TOPLEVEL_VERSION; */\newline    else\newline    {\newline        allocated = string_str_replace(arg, &quot$STD_INCLUDE&quot, STD_INCLUDE);\newline        arg = allocated;\newline    }\newline\newline    char *refined = refine_XXincludePath(arg);\newline\newline    free(allocated);\newline\newline    if \newline    (\newline        symbol_insert(&ampsymtab, &quotXXincludePath&quot, refined) != FAILED\newline        &amp&amp\newline        message_show(MSG_NOTICE)\newline    )\newline        message(&quotInclude path: `%s&#039&quot, refined);\newline\newline    free(refined);\newline}\newline","put XXincludePath in symtab \newline","4219216","parser.c","char *char_cat(char **input, const char *items, const char invert) {\newline	char *ret = NULL;\newline	char *start = *input;\newline	int oldlc = line_count;\newline\newline	while (char_alt(input, items, invert));\newline	if (*input &gt start) {\newline		ret = (char*) calloc(*input - start + 2, sizeof(char));\newline		strncpy(ret, start, *input - start);\newline	}\newline	else line_count = oldlc;\newline	return ret;\newline}\newline","Match an arbitrary sequence of any chars out of items \newline","on","","","on","","","","","","","","on","","","","on","on","on","","","","","","","","","","","","","","","","","","","","","","","","","{}","Displays players gold","Lets other functions know if radical search is available","{}","simply die","change the size of the view surface","Return an array of all items in the ISO standard.","Generate next ID.","write a date","List matching arguments","clear all used subobjects participating in reference cycles","{}","put XXincludePath in symtab","Match an arbitrary sequence of any chars out of items","Test the conformance of Normalizer tohttp://www.unicode.org/Public/UNIDATA/NormalizationTest.txt","{}","{}","{}","Dump status info out to dcc","prints header fields of a facet to fp","Get the value of a Python dictionary item,"
"3FO95NVK5C0VQT8XRDSQK1YRD64RS5","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3I33IC7ZWF2C9X2BLPWZNCS2VXFA2H","A2M2K3PO5ALBE2","Approved","Wed Apr 17 16:16:49 PDT 2019","Wed Apr 17 16:19:09 PDT 2019","Fri Apr 19 16:19:09 PDT 2019","2019-04-19 23:19:26 UTC","","","140","100% (13/13)","100% (13/13)","100% (13/13)","429597","nutation.cpp","void ge2000a_nutation(struct julian_date *tdb, double *d_psi, double *d_epsilon)\newline{\newline	int i ;\newline	double t,s_phi,cs,sn,phi[15],psi_lun,psi_pla,eps_lun,eps_pla;\newline\newline	t = JULIAN_CENTURIES(tdb-&gtdate1, tdb-&gtdate2);\newline\newline	/*\newline	 * Get fundamental arguments (planetary longitudes, precession,\newline	 * luni-solar values). We use 1-based indices for phi to make them\newline	 * consistent with the reference document.\newline	 */\newline	for (i = ARG_LONGITUDE_MERCURY; i &lt= ARG_LONGITUDE_NODE; i++)\newline		phi[i + 1] = fundamental_argument((fund_argument)i, t);\newline\newline	psi_lun = 0;\newline	eps_lun = 0;\newline	/* To maximize precision,sum lunisolar terms with smallest terms first */\newline	for (i = ge2000a_lunisolar_count - 1; i &gt= 0 ; i--) {\newline\newline		s_phi = ge2000a_lunisolar[i].l * phi[10] +\newline			ge2000a_lunisolar[i].lp * phi[11] +\newline			ge2000a_lunisolar[i].f * phi[12] +\newline			ge2000a_lunisolar[i].d * phi[13] +\newline			ge2000a_lunisolar[i].om * phi[14];\newline\newline		sincos(s_phi, &ampsn, &ampcs);\newline\newline		psi_lun += (ge2000a_lunisolar[i].ps +\newline			ge2000a_lunisolar[i].psd * t) * sn +\newline			ge2000a_lunisolar[i].pcp * cs;\newline\newline		eps_lun += (ge2000a_lunisolar[i].ec +\newline			ge2000a_lunisolar[i].ecd * t) * cs +\newline			ge2000a_lunisolar[i].esp * sn;\newline	}\newline\newline	psi_pla = 0;\newline	eps_pla = 0;\newline	/* Sum up planetary terms with the smallest terms first */\newline	for (i = 0; i &lt ge2000a_planetary_count; i++) {\newline\newline		s_phi = ge2000a_planetary[i].mer * phi[1] +\newline			ge2000a_planetary[i].ven * phi[2] +\newline			ge2000a_planetary[i].ear * phi[3] +\newline			ge2000a_planetary[i].mar * phi[4] +\newline			ge2000a_planetary[i].jup * phi[5] +\newline			ge2000a_planetary[i].sat * phi[6] +\newline			ge2000a_planetary[i].ura * phi[7] +\newline			ge2000a_planetary[i].nep * phi[8] +\newline			ge2000a_planetary[i].gp * phi[9] +\newline			ge2000a_planetary[i].l * phi[10] +\newline			ge2000a_planetary[i].lp * phi[11] +\newline			ge2000a_planetary[i].f * phi[12] +\newline			ge2000a_planetary[i].d * phi[13] +\newline			ge2000a_planetary[i].om * phi[14];\newline\newline		sincos(s_phi, &ampsn, &ampcs);\newline\newline		psi_pla += ge2000a_planetary[i].ps * sn +\newline			ge2000a_planetary[i].pcp * cs;\newline\newline		eps_pla += ge2000a_planetary[i].ec * cs +\newline			ge2000a_planetary[i].esp * sn;\newline	}\newline\newline	/* Sum up the individual contributions */\newline	*d_psi = (psi_lun + psi_pla) * MAS_TO_RAD;\newline	*d_epsilon = (eps_lun + eps_pla) * MAS_TO_RAD;\newline}\newline","\newline Calculates the nutation in longitude and obliquity using the ge 2000A\newline nutation model in its entirety.\newline \newline tdb -- TDB to be used for calculations. TT may be used for all but the most\newline exacting applications.\newline d_psi -- The nutation in longitude expressed in radians.\newline d_epsilon -- The nutation in obliquity expressed in radians.\newline \newline","4546119","yarn.c","local void *my_malloc(size_t size)\newline{\newline    void *block;\newline\newline    if ((block = my_malloc_f(size)) == NULL)\newline        fail(ENOMEM);\newline    return block;\newline}\newline","memory allocation that cannot fail (from the point of view of the caller) \newline","2107475","pprof.cpp","static char *strsave (const char *s){\newline  char *r;\newline  if ( (r = (char *) malloc (strlen(s)+1)) == NULL ) {\newline    fprintf (stderr, &quoterror: no more memory\\n&quot);\newline    exit (1);\newline  }//if\newline  strcpy (r, s);\newline  return r;\newline}//strsave()\newline","pC++ /HPC++ profiling code \newline","5210262","sd_task.cpp","void SD_task_dependency_add(const char *name, void *data, SD_task_t src, SD_task_t dst)\newline{\newline  if (src == dst)\newline    THROWF(arg_error, 0, &quotCannot add a dependency between task &#039%s&#039 and itself&quot, SD_task_get_name(src));\newline\newline  if (src-&gtstate == SD_DONE || src-&gtstate == SD_FAILED)\newline    THROWF(arg_error, 0, &quotTask &#039%s&#039 must be SD_NOT_SCHEDULED, SD_SCHEDULABLE, SD_SCHEDULED, SD_RUNNABLE, or SD_RUNNING&quot,\newline           src-&gtname);\newline\newline  if (dst-&gtstate == SD_DONE || dst-&gtstate == SD_FAILED || dst-&gtstate == SD_RUNNING)\newline    THROWF(arg_error, 0, &quotTask &#039%s&#039 must be SD_NOT_SCHEDULED, SD_SCHEDULABLE, SD_SCHEDULED, or SD_RUNNABLE&quot,\newline           dst-&gtname);\newline\newline  if (dst-&gtinputs-&gtfind(src) != dst-&gtinputs-&gtend() || src-&gtoutputs-&gtfind(dst) != src-&gtoutputs-&gtend() ||\newline      src-&gtsuccessors-&gtfind(dst) != src-&gtsuccessors-&gtend() || dst-&gtpredecessors-&gtfind(src) != dst-&gtpredecessors-&gtend())\newline    THROWF(arg_error, 0, &quotA dependency already exists between task &#039%s&#039 and task &#039%s&#039&quot, src-&gtname, dst-&gtname);\newline\newline  XBT_DEBUG(&quotSD_task_dependency_add: src = %s, dst = %s&quot, src-&gtname, dst-&gtname);\newline\newline  if (src-&gtkind == SD_TASK_COMM_E2E || src-&gtkind == SD_TASK_COMM_PAR_MXN_1D_BLOCK){\newline    if (dst-&gtkind == SD_TASK_COMP_SEQ || dst-&gtkind == SD_TASK_COMP_PAR_AMDAHL)\newline        dst-&gtinputs-&gtinsert(src);\newline    else\newline      dst-&gtpredecessors-&gtinsert(src);\newline    src-&gtsuccessors-&gtinsert(dst);\newline  } else {\newline    if (dst-&gtkind == SD_TASK_COMM_E2E|| dst-&gtkind == SD_TASK_COMM_PAR_MXN_1D_BLOCK)\newline      src-&gtoutputs-&gtinsert(dst);\newline    else\newline      src-&gtsuccessors-&gtinsert(dst);\newline    dst-&gtpredecessors-&gtinsert(src);\newline  }\newline\newline  /* if the task was runnable, the task goes back to SD_SCHEDULED because of the new dependency*/\newline  if (dst-&gtstate == SD_RUNNABLE) {\newline    XBT_DEBUG(&quotSD_task_dependency_add: %s was runnable and becomes scheduled!&quot, dst-&gtname);\newline    SD_task_set_state(dst, SD_SCHEDULED);\newline  }\newline}\newline","\newline \\brief Adds a dependency between two tasks\newline \newline \\a dst will depend on \\a src, ie \\a dst will not start before \\a src is finished.\newline Their \\ref e_SD_task_state_t &quotstate&quot must be #SD_NOT_SCHEDULED, #SD_SCHEDULED or #SD_RUNNABLE.\newline \newline \\param name the name of the new dependency (can be \\c nullptr)\newline \\param data the user data you want to associate with this dependency (can be \\c nullptr)\newline \\param src the task which must be executed first\newline \\param dst the task you want to make depend on \\a src\newline \\see SD_task_dependency_remove()\newline \newline","3623756","main.c","void version(void) {\newline	fprintf(stdout, &quot%s %s\\n&quot, PACKAGE, VERSION);\newline	fprintf(stdout, &quot\\n&quot);\newline	fprintf(stdout, &quotby Toshihiro Hiraoka (hiraoka@azukimap.jp)\\n&quot);\newline	fprintf(stdout, &quot   Petter Reinholdtsen\\n&quot);\newline}\newline","\newline Shows a version\newline \newline","3213142","colormaps.c","void UninstallRootColormap()\newline{\newline  if (Scr.root_pushes)\newline    Scr.root_pushes--;\newline  \newline  if (!Scr.root_pushes) \newline    {\newline      InstallWindowColormaps(Scr.pushed_window);\newline    }\newline  \newline  return;\newline}\newline","\newline \newline Unstacks one layer of root colormap pushing \newline If we peel off the last layer, re-install th e application colormap\newline \newline \newline","4562989","escape.c","void curl_free(void *p)\newline{\newline  if(p)\newline    free(p);\newline}\newline","For operating systems/environments that use different malloc/free\newlinessystems for the app and for this library, we provide a free that uses\newlinethe library&#039s memory system \newline","2814703","agt_util.c","status_t agt_validate_filter ( ses_cb_t *scb,\newline                               rpc_msg_t *msg )\newline{\newline    assert( scb &amp&amp &quotscb is NULL&quot );\newline    assert( msg &amp&amp &quotmsg is NULL&quot );\newline\newline    /* filter parm is optional */\newline    val_value_t *filter = val_find_child( msg-&gtrpc_input, NC_MODULE, \newline                                          NCX_EL_FILTER );\newline    if (!filter) {\newline        msg-&gtrpc_filter.op_filtyp = OP_FILTER_NONE;\newline        msg-&gtrpc_filter.op_filter = NULL;\newline        return NO_ERR;   /* not an error */\newline    } \newline\newline    return agt_validate_filter_ex( scb, msg, filter );\newline} /* agt_validate_filter */\newline","\newline Validate the &ltfilter&gt parameter if present.\newline If the filter is valid msg-&gtrpc_filter is filled in;\newline \newline \\param scb session control block\newline \\param msg rpc_msg_t in progress\newline \\return status\newline \newline","2570322","admin.c","static bool admin_show_sockets(PgSocket *admin, const char *arg)\newline{\newline	struct List *item;\newline	PgPool *pool;\newline	PktBuf *buf;\newline\newline	buf = pktbuf_dynamic(256);\newline	if (!buf) {\newline		admin_error(admin, &quotno mem&quot);\newline		return true;\newline	}\newline\newline	socket_header(buf, true);\newline	statlist_for_each(item, &amppool_list) {\newline		pool = container_of(item, PgPool, head);\newline		show_socket_list(buf, &amppool-&gtactive_client_list, &quotcl_active&quot, true);\newline		show_socket_list(buf, &amppool-&gtwaiting_client_list, &quotcl_waiting&quot, true);\newline\newline		show_socket_list(buf, &amppool-&gtactive_server_list, &quotsv_active&quot, true);\newline		show_socket_list(buf, &amppool-&gtidle_server_list, &quotsv_idle&quot, true);\newline		show_socket_list(buf, &amppool-&gtused_server_list, &quotsv_used&quot, true);\newline		show_socket_list(buf, &amppool-&gttested_server_list, &quotsv_tested&quot, true);\newline		show_socket_list(buf, &amppool-&gtnew_server_list, &quotsv_login&quot, true);\newline	}\newline	show_socket_list(buf, &amplogin_client_list, &quotcl_login&quot, true);\newline	admin_flush(admin, buf, &quotSHOW&quot);\newline	return true;\newline}\newline","Command: SHOW SOCKETS \newline","17392","stri_uloc.cpp","SEXP stri_locale_info(SEXP loc)\newline{\newline   const char* qloc = stri__prepare_arg_locale(loc, &quotlocale&quot, true); /* this is R_alloc&#039ed */\newline   const R_len_t infosize = 4;\newline   SEXP vals;\newline\newline   PROTECT(vals = Rf_allocVector(VECSXP, infosize));\newline   for (int i=0; i&ltinfosize; ++i)\newline      SET_VECTOR_ELT(vals, i, Rf_ScalarString(NA_STRING));\newline\newline   UErrorCode err = U_ZERO_ERROR;\newline   char buf[ULOC_FULLNAME_CAPACITY]; // this is sufficient\newline\newline   uloc_getLanguage(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 0, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_getCountry(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 1, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_getVariant(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 2, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_canonicalize(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 3, stri__make_character_vector_char_ptr(1, buf));\newline\newline   stri__set_names(vals, 4, &quotLanguage&quot, &quotCountry&quot, &quotVariant&quot, &quotName&quot);\newline   UNPROTECT(1);\newline   return vals;\newline}\newline","Get info on default (current) ICU locale or on given locale\newline \newline @param loc either \\code{NULL} or \\code{&quot&quot} for default locale,\newline or one string with locale name\newline @return a named R list object: each item (\\code{Language},\newline \\code{Country}, \\code{Variant}, \\code{Name}) consists of\newline a single string\newline \newline @version 0.1-?? (Marek Gagolewski)\newline \newline","5291922","connect.c","static VALUE kgio_connect(VALUE klass, VALUE addr)\newline{\newline	return stream_connect(klass, addr, 1);\newline}\newline","call-seq:\newline \newline addr = Socket.pack_sockaddr_in(80, &#039example.com&#039)\newline Kgio::Socket.connect(addr) -&gt socket\newline \newline addr = Socket.pack_sockaddr_un(&quot/path/to/unix/socket&quot)\newline Kgio::Socket.connect(addr) -&gt socket\newline \newline Creates a generic Kgio::Socket object and initiates a\newline non-blocking connection.\newline \newline This may block and call any method defined to +kgio_wait_writable+\newline for the class.\newline \newline","385206","eisa.h","static inline void eisa_set_drvdata ( struct eisa_device *eisa, void *priv ) {\newline	eisa-&gtpriv = priv;\newline}\newline","\newline Set EISA driver-private data\newline \newline @v eisa EISA device\newline @v priv Private data\newline \newline","2164719","dlist.c","static int alloc_node(void)\newline{\newline        static int last_node = 0;\newline        int start = last_node;\newline        do {\newline                if (nodes[last_node].value == -1) return last_node;\newline                last_node = (last_node+1)%nodes_max;\newline        } while (last_node != start);\newline        return -1;      /* all nodes used */\newline}\newline","This finishes in almost-constant time if there are plenty of free nodes \newline","2090131","compat.cpp","void  cvProject3D( CvPoint3D32f* points3D, int count,\newline                   CvPoint2D32f* points2D, int xIndx, int yIndx)\newline{\newline    CvMat src = cvMat( 1, count, CV_32FC3, points3D );\newline    CvMat dst = cvMat( 1, count, CV_32FC2, points2D );\newline    float m[6] = {0,0,0,0,0,0};\newline    CvMat M = cvMat( 2, 3, CV_32F, m );\newline\newline    assert( (unsigned)xIndx &lt 3 &amp&amp (unsigned)yIndx &lt 3 );\newline    m[xIndx] = m[yIndx+3] = 1.f;\newline\newline    cvTransform( &ampsrc, &ampdst, &ampM, NULL );\newline}\newline","Projects 2d points to one of standard coordinate planes\newline(i.e. removes one of coordinates) \newline","6170268","psqlscan.c","void\newlinepsql_scan_finish(PsqlScanState state)\newline{\newline	/* Drop any incomplete variable expansions. */\newline	while (state-&gtbuffer_stack != NULL)\newline		psqlscan_pop_buffer_stack(state);\newline\newline	/* Done with the outer scan buffer, too */\newline	if (state-&gtscanbufhandle)\newline		psql_yy_delete_buffer(state-&gtscanbufhandle,state-&gtscanner);\newline	state-&gtscanbufhandle = NULL;\newline	if (state-&gtscanbuf)\newline		free(state-&gtscanbuf);\newline	state-&gtscanbuf = NULL;\newline}\newline","\newline Clean up after scanning a string. This flushes any unread input and\newline releases resources (but not the PsqlScanState itself). Note however\newline that this does not reset the lexer scan state; that can be done by\newline psql_scan_reset(), which is an orthogonal operation.\newline \newline It is legal to call this when not scanning anything (makes it easier\newline to deal with error recovery).\newline \newline","876548","form_wrap.c","void init_opts_constants() {\newline  FORM_DEF_CONST(O_VISIBLE);\newline  FORM_DEF_CONST(O_ACTIVE);\newline  FORM_DEF_CONST(O_PUBLIC);\newline  FORM_DEF_CONST(O_EDIT);\newline  FORM_DEF_CONST(O_WRAP);\newline  FORM_DEF_CONST(O_BLANK);\newline  FORM_DEF_CONST(O_AUTOSKIP);\newline  FORM_DEF_CONST(O_NULLOK);\newline  FORM_DEF_CONST(O_STATIC);\newline  FORM_DEF_CONST(O_PASSOK);\newline}\newline","\newline field options constants\newline \newline","2790438","freeglut_gamemode.c","static void fghRestoreState( void )\newline{\newline#if TARGET_HOST_POSIX_X11\newline    /* Restore the remembered pointer position: */\newline    XWarpPointer(\newline        fgDisplay.Display, None, fgDisplay.RootWindow, 0, 0, 0, 0,\newline        fgDisplay.DisplayPointerX, fgDisplay.DisplayPointerY\newline    );\newline\newline\newline#   ifdef HAVE_X11_EXTENSIONS_XRANDR_H\newline    if(fgDisplay.prev_size_valid) {\newline        if(xrandr_resize(fgDisplay.prev_xsz, fgDisplay.prev_ysz, fgDisplay.prev_refresh, 0) != -1) {\newline            fgDisplay.prev_size_valid = 0;\newline#       ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H\newline            fgDisplay.DisplayModeValid = 0;\newline#       endif\newline            return;\newline        }\newline    }\newline#   endif\newline\newline\newline\newline#   ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H\newline    /*\newline     * This highly depends on the XFree86 extensions,\newline     * not approved as X Consortium standards\newline     */\newline\newline    if( fgDisplay.DisplayModeValid )\newline    {\newline        XF86VidModeModeInfo** displayModes;\newline        int i, displayModesCount;\newline\newline        if( !XF86VidModeGetAllModeLines(\newline                 fgDisplay.Display,\newline                 fgDisplay.Screen,\newline                 &ampdisplayModesCount,\newline                 &ampdisplayModes ) )\newline        {\newline            fgWarning( &quotXF86VidModeGetAllModeLines failed&quot );\newline            return;\newline        }\newline\newline\newline        /*\newline         * Check every of the modes looking for one that matches our demands.\newline         * If we find one, switch to it and restore the remembered viewport.\newline         */\newline        for( i = 0; i &lt displayModesCount; i++ )\newline        {\newline            if(displayModes[ i ]-&gthdisplay == fgDisplay.DisplayMode.hdisplay &amp&amp\newline               displayModes[ i ]-&gtvdisplay == fgDisplay.DisplayMode.vdisplay &amp&amp\newline               displayModes[ i ]-&gtdotclock == fgDisplay.DisplayModeClock )\newline            {\newline                if( !XF86VidModeSwitchToMode(\newline                         fgDisplay.Display,\newline                         fgDisplay.Screen,\newline                         displayModes[ i ] ) )\newline                {\newline                    fgWarning( &quotXF86VidModeSwitchToMode failed&quot );\newline                    break;\newline                }\newline\newline                if( !XF86VidModeSetViewPort(\newline                         fgDisplay.Display,\newline                         fgDisplay.Screen,\newline                         fgDisplay.DisplayViewPortX,\newline                         fgDisplay.DisplayViewPortY ) )\newline                    fgWarning( &quotXF86VidModeSetViewPort failed&quot );\newline\newline\newline                /*\newline                 * For the case this would be the last X11 call the application\newline                 * calls exit() we&#039ve to flush the X11 output queue to have the\newline                 * commands sent to the X server before the application exits.\newline                 */\newline                XFlush( fgDisplay.Display );\newline\newline                fgDisplay.DisplayModeValid = 0;\newline#       ifdef HAVE_X11_EXTENSIONS_XRANDR_H\newline                fgDisplay.prev_size_valid = 0;\newline#       endif\newline\newline                break;\newline            }\newline        }\newline        XFree( displayModes );\newline    }\newline\newline#   endif\newline\newline#elif TARGET_HOST_MS_WINDOWS\newline\newline    /* Restore the previously remembered desktop display settings */\newline    fghPlatformChangeDisplayMode(GL_FALSE,&ampfgDisplay.DisplayMode);\newline\newline#endif\newline}\newline","\newline Restores the previously remembered visual settings\newline \newline","2643572","delaunay.c","static gboolean edge_slope_swap (GtsEdge * e, GtsSurface * s)\newline{\newline  if (!GTS_IS_CONSTRAINT (e)) {\newline    GtsTriangle * t1 = NULL, * t2 = NULL;\newline    GSList * i = e-&gttriangles;\newline    while (i) {\newline      if (GTS_IS_FACE (i-&gtdata) &amp&amp gts_face_has_parent_surface (i-&gtdata, s)) {\newline	if (!t1)\newline	  t1 = i-&gtdata;\newline	else if (!t2)\newline	  t2 = i-&gtdata;\newline	else\newline	  g_return_val_if_fail (gts_edge_face_number (e, s) == 2, FALSE);\newline      }\newline      i = i-&gtnext;\newline    }\newline    if (!t1 || !t2)\newline      return FALSE;\newline    GtsVertex * v1, * v2, * v3, * v4, * v5, * v6;\newline    GtsEdge * e1, * e2, * e3, * e4;\newline    gts_triangle_vertices_edges (t1, e, &ampv1, &ampv2, &ampv3, &ampe, &ampe1, &ampe2);\newline    gts_triangle_vertices_edges (t2, e, &ampv4, &ampv5, &ampv6, &ampe, &ampe3, &ampe4);\newline    g_assert (v2 == v4 &amp&amp v1 == v5);\newline    if (gts_point_orientation (GTS_POINT (v3), GTS_POINT (v6), GTS_POINT (v2)) &gt 0. &amp&amp\newline	gts_point_orientation (GTS_POINT (v6), GTS_POINT (v3), GTS_POINT (v1)) &gt 0.) {\newline      /* edge swap is possible */\newline      double slope1 = slope (v1, v2, v3), slope2 = slope (v4, v5, v6);\newline      double slopemin1 = MIN (slope1, slope2);\newline      slope1 = slope (v3, v6, v2); slope2 = slope (v6, v3, v1);\newline      double slopemin2 = MIN (slope1, slope2);\newline      if (slopemin2 &gt slopemin1) {\newline	/* edge swap */\newline	GtsSegment * v3v6 = gts_vertices_are_connected (v3, v6);\newline	if (!GTS_IS_EDGE (v3v6))\newline	  v3v6 = GTS_SEGMENT (gts_edge_new (s-&gtedge_class, v3, v6));\newline	GtsFace * f = gts_face_new (s-&gtface_class, e1, GTS_EDGE (v3v6), e4);\newline	GtsTriangle * t;\newline	if ((t = gts_triangle_is_duplicate (GTS_TRIANGLE (f))) &amp&amp\newline	    GTS_IS_FACE (t)) {\newline	  gts_object_destroy (GTS_OBJECT (f));\newline	  f = GTS_FACE (t);\newline	}\newline	gts_surface_add_face (s, f);\newline	\newline	f = gts_face_new (s-&gtface_class, GTS_EDGE (v3v6), e2, e3);\newline	if ((t = gts_triangle_is_duplicate (GTS_TRIANGLE (f))) &amp&amp\newline	    GTS_IS_FACE (t)) {\newline	  gts_object_destroy (GTS_OBJECT (f));\newline	  f = GTS_FACE (t);\newline	}\newline	gts_surface_add_face (s, f);\newline\newline	gts_surface_remove_face (s, GTS_FACE (t1));\newline	gts_surface_remove_face (s, GTS_FACE (t2));\newline	return TRUE;\newline      }\newline    }\newline  }\newline  return FALSE;\newline}\newline","swap edge if it maximises the minimum slope \newline","6620640","sample.c","pa_sample_format_t pa_parse_sample_format(const char *format) {\newline int i;\newline\newline for (i = 0; _roar_pa_format[i].name != NULL; i++)\newline  if ( !strcasecmp(_roar_pa_format[i].name, format) )\newline   return _roar_pa_format[i].format;\newline\newline return PA_SAMPLE_INVALID;\newline}\newline","Parse a sample format text. Inverse of pa_sample_format_to_string() \newline","2973651","dvb_gen_si.c","static void build_desc2b(uint8_t *desc) {\newline    desc2b_init(desc);\newline    desc2b_set_aac_profile(desc, 0x12);\newline    desc2b_set_aac_channel_config(desc, 0x05);\newline    desc2b_set_aac_additional_info(desc, 0x00);\newline}\newline","MPEG Descriptor 0x2b: MPEG-2 AAC audio descriptor \newline","537619","natpmp.c","void SendNATPMPPublicAddressChangeNotification(int * sockets, int n_sockets)\newline{\newline	struct sockaddr_in sockname;\newline	unsigned char notif[12];\newline	int j, n;\newline\newline	notif[0] = 0;	/* vers */\newline	notif[1] = 128;	/* OP code */\newline	notif[2] = 0;	/* result code */\newline	notif[3] = 0;	/* result code */\newline	/* seconds since &quotstart of epoch&quot :\newline	 * time elapsed since the port mapping table was initialized on\newline	 * startup or reset for any other reason */\newline	WRITENU32(notif+4, time(NULL) - startup_time);\newline#ifndef MULTIPLE_EXTERNAL_IP\newline	FillPublicAddressResponse(notif, 0);\newline	if(notif[3])\newline	{\newline		syslog(LOG_WARNING, &quot%s: cannot get public IP address, stopping&quot,\newline		       &quotSendNATPMPPublicAddressChangeNotification&quot);\newline		return;\newline	}\newline#endif\newline	memset(&ampsockname, 0, sizeof(struct sockaddr_in));\newline    sockname.sin_family = AF_INET;\newline    sockname.sin_addr.s_addr = inet_addr(NATPMP_NOTIF_ADDR);\newline\newline	for(j=0; j&ltn_sockets; j++)\newline	{\newline		if(sockets[j] &lt 0)\newline			continue;\newline#ifdef MULTIPLE_EXTERNAL_IP\newline		{\newline			struct lan_addr_s * lan_addr = lan_addrs.lh_first;\newline			int i;\newline			for(i=0; i&ltj; i++)\newline				lan_addr = lan_addr-&gtlist.le_next;\newline			FillPublicAddressResponse(notif, lan_addr-&gtaddr.s_addr);\newline		}\newline#endif\newline		/* Port to use in 2006 version of the NAT-PMP specification */\newline    	sockname.sin_port = htons(NATPMP_PORT);\newline		n = sendto_or_schedule(sockets[j], notif, 12, 0,\newline		           (struct sockaddr *)&ampsockname, sizeof(struct sockaddr_in));\newline		if(n &lt 0)\newline		{\newline			syslog(LOG_ERR, &quot%s: sendto(s_udp=%d): %m&quot,\newline			       &quotSendNATPMPPublicAddressChangeNotification&quot, sockets[j]);\newline			return;\newline		}\newline		/* Port to use in 2008 version of the NAT-PMP specification */\newline    	sockname.sin_port = htons(NATPMP_NOTIF_PORT);\newline		n = sendto_or_schedule(sockets[j], notif, 12, 0,\newline		           (struct sockaddr *)&ampsockname, sizeof(struct sockaddr_in));\newline		if(n &lt 0)\newline		{\newline			syslog(LOG_ERR, &quot%s: sendto(s_udp=%d): %m&quot,\newline			       &quotSendNATPMPPublicAddressChangeNotification&quot, sockets[j]);\newline			return;\newline		}\newline	}\newline}\newline","SendNATPMPPublicAddressChangeNotification()\newline should be called when the public IP address changed \newline","","","","","on","","","","","","","","","on","on","","","","","","","","","","","","","on","","","","","","","","","","","on","","","","Calculates the nutation in longitude and obliquity","Get info on default (current) ICU locale or on given locale","Creates a generic Kgio::Socket object and initiates anon-blocking connection.","Set EISA driver-private data","{}","removes one of coordinates)","Clean up after scanning a string.","field options constants","Restores the previously remembered visual settings","swap edge if it maximises the minimum slope","Parse a sample format text.","memory allocation that cannot fail","audio descriptor","{}","{}","Adds a dependency between two tasks","Shows a version","Unstacks one layer of root colormap pushing","provide a free that usesthe library's memory system","Validate the <filter> parameter if present.","SHOW SOCKETS"
"3FO95NVK5C0VQT8XRDSQK1YRD64RS5","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3U0SRXB7CD50X0DL9JG5AQKA6VYNRV","AVC62JNYAXA45","Approved","Wed Apr 17 14:13:11 PDT 2019","Wed Apr 17 14:37:38 PDT 2019","Fri Apr 19 14:37:38 PDT 2019","2019-04-19 21:38:21 UTC","","","1467","100% (24/24)","100% (24/24)","100% (24/24)","429597","nutation.cpp","void ge2000a_nutation(struct julian_date *tdb, double *d_psi, double *d_epsilon)\newline{\newline	int i ;\newline	double t,s_phi,cs,sn,phi[15],psi_lun,psi_pla,eps_lun,eps_pla;\newline\newline	t = JULIAN_CENTURIES(tdb-&gtdate1, tdb-&gtdate2);\newline\newline	/*\newline	 * Get fundamental arguments (planetary longitudes, precession,\newline	 * luni-solar values). We use 1-based indices for phi to make them\newline	 * consistent with the reference document.\newline	 */\newline	for (i = ARG_LONGITUDE_MERCURY; i &lt= ARG_LONGITUDE_NODE; i++)\newline		phi[i + 1] = fundamental_argument((fund_argument)i, t);\newline\newline	psi_lun = 0;\newline	eps_lun = 0;\newline	/* To maximize precision,sum lunisolar terms with smallest terms first */\newline	for (i = ge2000a_lunisolar_count - 1; i &gt= 0 ; i--) {\newline\newline		s_phi = ge2000a_lunisolar[i].l * phi[10] +\newline			ge2000a_lunisolar[i].lp * phi[11] +\newline			ge2000a_lunisolar[i].f * phi[12] +\newline			ge2000a_lunisolar[i].d * phi[13] +\newline			ge2000a_lunisolar[i].om * phi[14];\newline\newline		sincos(s_phi, &ampsn, &ampcs);\newline\newline		psi_lun += (ge2000a_lunisolar[i].ps +\newline			ge2000a_lunisolar[i].psd * t) * sn +\newline			ge2000a_lunisolar[i].pcp * cs;\newline\newline		eps_lun += (ge2000a_lunisolar[i].ec +\newline			ge2000a_lunisolar[i].ecd * t) * cs +\newline			ge2000a_lunisolar[i].esp * sn;\newline	}\newline\newline	psi_pla = 0;\newline	eps_pla = 0;\newline	/* Sum up planetary terms with the smallest terms first */\newline	for (i = 0; i &lt ge2000a_planetary_count; i++) {\newline\newline		s_phi = ge2000a_planetary[i].mer * phi[1] +\newline			ge2000a_planetary[i].ven * phi[2] +\newline			ge2000a_planetary[i].ear * phi[3] +\newline			ge2000a_planetary[i].mar * phi[4] +\newline			ge2000a_planetary[i].jup * phi[5] +\newline			ge2000a_planetary[i].sat * phi[6] +\newline			ge2000a_planetary[i].ura * phi[7] +\newline			ge2000a_planetary[i].nep * phi[8] +\newline			ge2000a_planetary[i].gp * phi[9] +\newline			ge2000a_planetary[i].l * phi[10] +\newline			ge2000a_planetary[i].lp * phi[11] +\newline			ge2000a_planetary[i].f * phi[12] +\newline			ge2000a_planetary[i].d * phi[13] +\newline			ge2000a_planetary[i].om * phi[14];\newline\newline		sincos(s_phi, &ampsn, &ampcs);\newline\newline		psi_pla += ge2000a_planetary[i].ps * sn +\newline			ge2000a_planetary[i].pcp * cs;\newline\newline		eps_pla += ge2000a_planetary[i].ec * cs +\newline			ge2000a_planetary[i].esp * sn;\newline	}\newline\newline	/* Sum up the individual contributions */\newline	*d_psi = (psi_lun + psi_pla) * MAS_TO_RAD;\newline	*d_epsilon = (eps_lun + eps_pla) * MAS_TO_RAD;\newline}\newline","\newline Calculates the nutation in longitude and obliquity using the ge 2000A\newline nutation model in its entirety.\newline \newline tdb -- TDB to be used for calculations. TT may be used for all but the most\newline exacting applications.\newline d_psi -- The nutation in longitude expressed in radians.\newline d_epsilon -- The nutation in obliquity expressed in radians.\newline \newline","4546119","yarn.c","local void *my_malloc(size_t size)\newline{\newline    void *block;\newline\newline    if ((block = my_malloc_f(size)) == NULL)\newline        fail(ENOMEM);\newline    return block;\newline}\newline","memory allocation that cannot fail (from the point of view of the caller) \newline","2107475","pprof.cpp","static char *strsave (const char *s){\newline  char *r;\newline  if ( (r = (char *) malloc (strlen(s)+1)) == NULL ) {\newline    fprintf (stderr, &quoterror: no more memory\\n&quot);\newline    exit (1);\newline  }//if\newline  strcpy (r, s);\newline  return r;\newline}//strsave()\newline","pC++ /HPC++ profiling code \newline","5210262","sd_task.cpp","void SD_task_dependency_add(const char *name, void *data, SD_task_t src, SD_task_t dst)\newline{\newline  if (src == dst)\newline    THROWF(arg_error, 0, &quotCannot add a dependency between task &#039%s&#039 and itself&quot, SD_task_get_name(src));\newline\newline  if (src-&gtstate == SD_DONE || src-&gtstate == SD_FAILED)\newline    THROWF(arg_error, 0, &quotTask &#039%s&#039 must be SD_NOT_SCHEDULED, SD_SCHEDULABLE, SD_SCHEDULED, SD_RUNNABLE, or SD_RUNNING&quot,\newline           src-&gtname);\newline\newline  if (dst-&gtstate == SD_DONE || dst-&gtstate == SD_FAILED || dst-&gtstate == SD_RUNNING)\newline    THROWF(arg_error, 0, &quotTask &#039%s&#039 must be SD_NOT_SCHEDULED, SD_SCHEDULABLE, SD_SCHEDULED, or SD_RUNNABLE&quot,\newline           dst-&gtname);\newline\newline  if (dst-&gtinputs-&gtfind(src) != dst-&gtinputs-&gtend() || src-&gtoutputs-&gtfind(dst) != src-&gtoutputs-&gtend() ||\newline      src-&gtsuccessors-&gtfind(dst) != src-&gtsuccessors-&gtend() || dst-&gtpredecessors-&gtfind(src) != dst-&gtpredecessors-&gtend())\newline    THROWF(arg_error, 0, &quotA dependency already exists between task &#039%s&#039 and task &#039%s&#039&quot, src-&gtname, dst-&gtname);\newline\newline  XBT_DEBUG(&quotSD_task_dependency_add: src = %s, dst = %s&quot, src-&gtname, dst-&gtname);\newline\newline  if (src-&gtkind == SD_TASK_COMM_E2E || src-&gtkind == SD_TASK_COMM_PAR_MXN_1D_BLOCK){\newline    if (dst-&gtkind == SD_TASK_COMP_SEQ || dst-&gtkind == SD_TASK_COMP_PAR_AMDAHL)\newline        dst-&gtinputs-&gtinsert(src);\newline    else\newline      dst-&gtpredecessors-&gtinsert(src);\newline    src-&gtsuccessors-&gtinsert(dst);\newline  } else {\newline    if (dst-&gtkind == SD_TASK_COMM_E2E|| dst-&gtkind == SD_TASK_COMM_PAR_MXN_1D_BLOCK)\newline      src-&gtoutputs-&gtinsert(dst);\newline    else\newline      src-&gtsuccessors-&gtinsert(dst);\newline    dst-&gtpredecessors-&gtinsert(src);\newline  }\newline\newline  /* if the task was runnable, the task goes back to SD_SCHEDULED because of the new dependency*/\newline  if (dst-&gtstate == SD_RUNNABLE) {\newline    XBT_DEBUG(&quotSD_task_dependency_add: %s was runnable and becomes scheduled!&quot, dst-&gtname);\newline    SD_task_set_state(dst, SD_SCHEDULED);\newline  }\newline}\newline","\newline \\brief Adds a dependency between two tasks\newline \newline \\a dst will depend on \\a src, ie \\a dst will not start before \\a src is finished.\newline Their \\ref e_SD_task_state_t &quotstate&quot must be #SD_NOT_SCHEDULED, #SD_SCHEDULED or #SD_RUNNABLE.\newline \newline \\param name the name of the new dependency (can be \\c nullptr)\newline \\param data the user data you want to associate with this dependency (can be \\c nullptr)\newline \\param src the task which must be executed first\newline \\param dst the task you want to make depend on \\a src\newline \\see SD_task_dependency_remove()\newline \newline","3623756","main.c","void version(void) {\newline	fprintf(stdout, &quot%s %s\\n&quot, PACKAGE, VERSION);\newline	fprintf(stdout, &quot\\n&quot);\newline	fprintf(stdout, &quotby Toshihiro Hiraoka (hiraoka@azukimap.jp)\\n&quot);\newline	fprintf(stdout, &quot   Petter Reinholdtsen\\n&quot);\newline}\newline","\newline Shows a version\newline \newline","3213142","colormaps.c","void UninstallRootColormap()\newline{\newline  if (Scr.root_pushes)\newline    Scr.root_pushes--;\newline  \newline  if (!Scr.root_pushes) \newline    {\newline      InstallWindowColormaps(Scr.pushed_window);\newline    }\newline  \newline  return;\newline}\newline","\newline \newline Unstacks one layer of root colormap pushing \newline If we peel off the last layer, re-install th e application colormap\newline \newline \newline","4562989","escape.c","void curl_free(void *p)\newline{\newline  if(p)\newline    free(p);\newline}\newline","For operating systems/environments that use different malloc/free\newlinessystems for the app and for this library, we provide a free that uses\newlinethe library&#039s memory system \newline","2814703","agt_util.c","status_t agt_validate_filter ( ses_cb_t *scb,\newline                               rpc_msg_t *msg )\newline{\newline    assert( scb &amp&amp &quotscb is NULL&quot );\newline    assert( msg &amp&amp &quotmsg is NULL&quot );\newline\newline    /* filter parm is optional */\newline    val_value_t *filter = val_find_child( msg-&gtrpc_input, NC_MODULE, \newline                                          NCX_EL_FILTER );\newline    if (!filter) {\newline        msg-&gtrpc_filter.op_filtyp = OP_FILTER_NONE;\newline        msg-&gtrpc_filter.op_filter = NULL;\newline        return NO_ERR;   /* not an error */\newline    } \newline\newline    return agt_validate_filter_ex( scb, msg, filter );\newline} /* agt_validate_filter */\newline","\newline Validate the &ltfilter&gt parameter if present.\newline If the filter is valid msg-&gtrpc_filter is filled in;\newline \newline \\param scb session control block\newline \\param msg rpc_msg_t in progress\newline \\return status\newline \newline","2570322","admin.c","static bool admin_show_sockets(PgSocket *admin, const char *arg)\newline{\newline	struct List *item;\newline	PgPool *pool;\newline	PktBuf *buf;\newline\newline	buf = pktbuf_dynamic(256);\newline	if (!buf) {\newline		admin_error(admin, &quotno mem&quot);\newline		return true;\newline	}\newline\newline	socket_header(buf, true);\newline	statlist_for_each(item, &amppool_list) {\newline		pool = container_of(item, PgPool, head);\newline		show_socket_list(buf, &amppool-&gtactive_client_list, &quotcl_active&quot, true);\newline		show_socket_list(buf, &amppool-&gtwaiting_client_list, &quotcl_waiting&quot, true);\newline\newline		show_socket_list(buf, &amppool-&gtactive_server_list, &quotsv_active&quot, true);\newline		show_socket_list(buf, &amppool-&gtidle_server_list, &quotsv_idle&quot, true);\newline		show_socket_list(buf, &amppool-&gtused_server_list, &quotsv_used&quot, true);\newline		show_socket_list(buf, &amppool-&gttested_server_list, &quotsv_tested&quot, true);\newline		show_socket_list(buf, &amppool-&gtnew_server_list, &quotsv_login&quot, true);\newline	}\newline	show_socket_list(buf, &amplogin_client_list, &quotcl_login&quot, true);\newline	admin_flush(admin, buf, &quotSHOW&quot);\newline	return true;\newline}\newline","Command: SHOW SOCKETS \newline","17392","stri_uloc.cpp","SEXP stri_locale_info(SEXP loc)\newline{\newline   const char* qloc = stri__prepare_arg_locale(loc, &quotlocale&quot, true); /* this is R_alloc&#039ed */\newline   const R_len_t infosize = 4;\newline   SEXP vals;\newline\newline   PROTECT(vals = Rf_allocVector(VECSXP, infosize));\newline   for (int i=0; i&ltinfosize; ++i)\newline      SET_VECTOR_ELT(vals, i, Rf_ScalarString(NA_STRING));\newline\newline   UErrorCode err = U_ZERO_ERROR;\newline   char buf[ULOC_FULLNAME_CAPACITY]; // this is sufficient\newline\newline   uloc_getLanguage(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 0, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_getCountry(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 1, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_getVariant(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 2, stri__make_character_vector_char_ptr(1, buf));\newline\newline   uloc_canonicalize(qloc, buf, ULOC_FULLNAME_CAPACITY, &amperr);\newline   if (U_FAILURE(err)) err = U_ZERO_ERROR;\newline   else SET_VECTOR_ELT(vals, 3, stri__make_character_vector_char_ptr(1, buf));\newline\newline   stri__set_names(vals, 4, &quotLanguage&quot, &quotCountry&quot, &quotVariant&quot, &quotName&quot);\newline   UNPROTECT(1);\newline   return vals;\newline}\newline","Get info on default (current) ICU locale or on given locale\newline \newline @param loc either \\code{NULL} or \\code{&quot&quot} for default locale,\newline or one string with locale name\newline @return a named R list object: each item (\\code{Language},\newline \\code{Country}, \\code{Variant}, \\code{Name}) consists of\newline a single string\newline \newline @version 0.1-?? (Marek Gagolewski)\newline \newline","5291922","connect.c","static VALUE kgio_connect(VALUE klass, VALUE addr)\newline{\newline	return stream_connect(klass, addr, 1);\newline}\newline","call-seq:\newline \newline addr = Socket.pack_sockaddr_in(80, &#039example.com&#039)\newline Kgio::Socket.connect(addr) -&gt socket\newline \newline addr = Socket.pack_sockaddr_un(&quot/path/to/unix/socket&quot)\newline Kgio::Socket.connect(addr) -&gt socket\newline \newline Creates a generic Kgio::Socket object and initiates a\newline non-blocking connection.\newline \newline This may block and call any method defined to +kgio_wait_writable+\newline for the class.\newline \newline","385206","eisa.h","static inline void eisa_set_drvdata ( struct eisa_device *eisa, void *priv ) {\newline	eisa-&gtpriv = priv;\newline}\newline","\newline Set EISA driver-private data\newline \newline @v eisa EISA device\newline @v priv Private data\newline \newline","2164719","dlist.c","static int alloc_node(void)\newline{\newline        static int last_node = 0;\newline        int start = last_node;\newline        do {\newline                if (nodes[last_node].value == -1) return last_node;\newline                last_node = (last_node+1)%nodes_max;\newline        } while (last_node != start);\newline        return -1;      /* all nodes used */\newline}\newline","This finishes in almost-constant time if there are plenty of free nodes \newline","2090131","compat.cpp","void  cvProject3D( CvPoint3D32f* points3D, int count,\newline                   CvPoint2D32f* points2D, int xIndx, int yIndx)\newline{\newline    CvMat src = cvMat( 1, count, CV_32FC3, points3D );\newline    CvMat dst = cvMat( 1, count, CV_32FC2, points2D );\newline    float m[6] = {0,0,0,0,0,0};\newline    CvMat M = cvMat( 2, 3, CV_32F, m );\newline\newline    assert( (unsigned)xIndx &lt 3 &amp&amp (unsigned)yIndx &lt 3 );\newline    m[xIndx] = m[yIndx+3] = 1.f;\newline\newline    cvTransform( &ampsrc, &ampdst, &ampM, NULL );\newline}\newline","Projects 2d points to one of standard coordinate planes\newline(i.e. removes one of coordinates) \newline","6170268","psqlscan.c","void\newlinepsql_scan_finish(PsqlScanState state)\newline{\newline	/* Drop any incomplete variable expansions. */\newline	while (state-&gtbuffer_stack != NULL)\newline		psqlscan_pop_buffer_stack(state);\newline\newline	/* Done with the outer scan buffer, too */\newline	if (state-&gtscanbufhandle)\newline		psql_yy_delete_buffer(state-&gtscanbufhandle,state-&gtscanner);\newline	state-&gtscanbufhandle = NULL;\newline	if (state-&gtscanbuf)\newline		free(state-&gtscanbuf);\newline	state-&gtscanbuf = NULL;\newline}\newline","\newline Clean up after scanning a string. This flushes any unread input and\newline releases resources (but not the PsqlScanState itself). Note however\newline that this does not reset the lexer scan state; that can be done by\newline psql_scan_reset(), which is an orthogonal operation.\newline \newline It is legal to call this when not scanning anything (makes it easier\newline to deal with error recovery).\newline \newline","876548","form_wrap.c","void init_opts_constants() {\newline  FORM_DEF_CONST(O_VISIBLE);\newline  FORM_DEF_CONST(O_ACTIVE);\newline  FORM_DEF_CONST(O_PUBLIC);\newline  FORM_DEF_CONST(O_EDIT);\newline  FORM_DEF_CONST(O_WRAP);\newline  FORM_DEF_CONST(O_BLANK);\newline  FORM_DEF_CONST(O_AUTOSKIP);\newline  FORM_DEF_CONST(O_NULLOK);\newline  FORM_DEF_CONST(O_STATIC);\newline  FORM_DEF_CONST(O_PASSOK);\newline}\newline","\newline field options constants\newline \newline","2790438","freeglut_gamemode.c","static void fghRestoreState( void )\newline{\newline#if TARGET_HOST_POSIX_X11\newline    /* Restore the remembered pointer position: */\newline    XWarpPointer(\newline        fgDisplay.Display, None, fgDisplay.RootWindow, 0, 0, 0, 0,\newline        fgDisplay.DisplayPointerX, fgDisplay.DisplayPointerY\newline    );\newline\newline\newline#   ifdef HAVE_X11_EXTENSIONS_XRANDR_H\newline    if(fgDisplay.prev_size_valid) {\newline        if(xrandr_resize(fgDisplay.prev_xsz, fgDisplay.prev_ysz, fgDisplay.prev_refresh, 0) != -1) {\newline            fgDisplay.prev_size_valid = 0;\newline#       ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H\newline            fgDisplay.DisplayModeValid = 0;\newline#       endif\newline            return;\newline        }\newline    }\newline#   endif\newline\newline\newline\newline#   ifdef HAVE_X11_EXTENSIONS_XF86VMODE_H\newline    /*\newline     * This highly depends on the XFree86 extensions,\newline     * not approved as X Consortium standards\newline     */\newline\newline    if( fgDisplay.DisplayModeValid )\newline    {\newline        XF86VidModeModeInfo** displayModes;\newline        int i, displayModesCount;\newline\newline        if( !XF86VidModeGetAllModeLines(\newline                 fgDisplay.Display,\newline                 fgDisplay.Screen,\newline                 &ampdisplayModesCount,\newline                 &ampdisplayModes ) )\newline        {\newline            fgWarning( &quotXF86VidModeGetAllModeLines failed&quot );\newline            return;\newline        }\newline\newline\newline        /*\newline         * Check every of the modes looking for one that matches our demands.\newline         * If we find one, switch to it and restore the remembered viewport.\newline         */\newline        for( i = 0; i &lt displayModesCount; i++ )\newline        {\newline            if(displayModes[ i ]-&gthdisplay == fgDisplay.DisplayMode.hdisplay &amp&amp\newline               displayModes[ i ]-&gtvdisplay == fgDisplay.DisplayMode.vdisplay &amp&amp\newline               displayModes[ i ]-&gtdotclock == fgDisplay.DisplayModeClock )\newline            {\newline                if( !XF86VidModeSwitchToMode(\newline                         fgDisplay.Display,\newline                         fgDisplay.Screen,\newline                         displayModes[ i ] ) )\newline                {\newline                    fgWarning( &quotXF86VidModeSwitchToMode failed&quot );\newline                    break;\newline                }\newline\newline                if( !XF86VidModeSetViewPort(\newline                         fgDisplay.Display,\newline                         fgDisplay.Screen,\newline                         fgDisplay.DisplayViewPortX,\newline                         fgDisplay.DisplayViewPortY ) )\newline                    fgWarning( &quotXF86VidModeSetViewPort failed&quot );\newline\newline\newline                /*\newline                 * For the case this would be the last X11 call the application\newline                 * calls exit() we&#039ve to flush the X11 output queue to have the\newline                 * commands sent to the X server before the application exits.\newline                 */\newline                XFlush( fgDisplay.Display );\newline\newline                fgDisplay.DisplayModeValid = 0;\newline#       ifdef HAVE_X11_EXTENSIONS_XRANDR_H\newline                fgDisplay.prev_size_valid = 0;\newline#       endif\newline\newline                break;\newline            }\newline        }\newline        XFree( displayModes );\newline    }\newline\newline#   endif\newline\newline#elif TARGET_HOST_MS_WINDOWS\newline\newline    /* Restore the previously remembered desktop display settings */\newline    fghPlatformChangeDisplayMode(GL_FALSE,&ampfgDisplay.DisplayMode);\newline\newline#endif\newline}\newline","\newline Restores the previously remembered visual settings\newline \newline","2643572","delaunay.c","static gboolean edge_slope_swap (GtsEdge * e, GtsSurface * s)\newline{\newline  if (!GTS_IS_CONSTRAINT (e)) {\newline    GtsTriangle * t1 = NULL, * t2 = NULL;\newline    GSList * i = e-&gttriangles;\newline    while (i) {\newline      if (GTS_IS_FACE (i-&gtdata) &amp&amp gts_face_has_parent_surface (i-&gtdata, s)) {\newline	if (!t1)\newline	  t1 = i-&gtdata;\newline	else if (!t2)\newline	  t2 = i-&gtdata;\newline	else\newline	  g_return_val_if_fail (gts_edge_face_number (e, s) == 2, FALSE);\newline      }\newline      i = i-&gtnext;\newline    }\newline    if (!t1 || !t2)\newline      return FALSE;\newline    GtsVertex * v1, * v2, * v3, * v4, * v5, * v6;\newline    GtsEdge * e1, * e2, * e3, * e4;\newline    gts_triangle_vertices_edges (t1, e, &ampv1, &ampv2, &ampv3, &ampe, &ampe1, &ampe2);\newline    gts_triangle_vertices_edges (t2, e, &ampv4, &ampv5, &ampv6, &ampe, &ampe3, &ampe4);\newline    g_assert (v2 == v4 &amp&amp v1 == v5);\newline    if (gts_point_orientation (GTS_POINT (v3), GTS_POINT (v6), GTS_POINT (v2)) &gt 0. &amp&amp\newline	gts_point_orientation (GTS_POINT (v6), GTS_POINT (v3), GTS_POINT (v1)) &gt 0.) {\newline      /* edge swap is possible */\newline      double slope1 = slope (v1, v2, v3), slope2 = slope (v4, v5, v6);\newline      double slopemin1 = MIN (slope1, slope2);\newline      slope1 = slope (v3, v6, v2); slope2 = slope (v6, v3, v1);\newline      double slopemin2 = MIN (slope1, slope2);\newline      if (slopemin2 &gt slopemin1) {\newline	/* edge swap */\newline	GtsSegment * v3v6 = gts_vertices_are_connected (v3, v6);\newline	if (!GTS_IS_EDGE (v3v6))\newline	  v3v6 = GTS_SEGMENT (gts_edge_new (s-&gtedge_class, v3, v6));\newline	GtsFace * f = gts_face_new (s-&gtface_class, e1, GTS_EDGE (v3v6), e4);\newline	GtsTriangle * t;\newline	if ((t = gts_triangle_is_duplicate (GTS_TRIANGLE (f))) &amp&amp\newline	    GTS_IS_FACE (t)) {\newline	  gts_object_destroy (GTS_OBJECT (f));\newline	  f = GTS_FACE (t);\newline	}\newline	gts_surface_add_face (s, f);\newline	\newline	f = gts_face_new (s-&gtface_class, GTS_EDGE (v3v6), e2, e3);\newline	if ((t = gts_triangle_is_duplicate (GTS_TRIANGLE (f))) &amp&amp\newline	    GTS_IS_FACE (t)) {\newline	  gts_object_destroy (GTS_OBJECT (f));\newline	  f = GTS_FACE (t);\newline	}\newline	gts_surface_add_face (s, f);\newline\newline	gts_surface_remove_face (s, GTS_FACE (t1));\newline	gts_surface_remove_face (s, GTS_FACE (t2));\newline	return TRUE;\newline      }\newline    }\newline  }\newline  return FALSE;\newline}\newline","swap edge if it maximises the minimum slope \newline","6620640","sample.c","pa_sample_format_t pa_parse_sample_format(const char *format) {\newline int i;\newline\newline for (i = 0; _roar_pa_format[i].name != NULL; i++)\newline  if ( !strcasecmp(_roar_pa_format[i].name, format) )\newline   return _roar_pa_format[i].format;\newline\newline return PA_SAMPLE_INVALID;\newline}\newline","Parse a sample format text. Inverse of pa_sample_format_to_string() \newline","2973651","dvb_gen_si.c","static void build_desc2b(uint8_t *desc) {\newline    desc2b_init(desc);\newline    desc2b_set_aac_profile(desc, 0x12);\newline    desc2b_set_aac_channel_config(desc, 0x05);\newline    desc2b_set_aac_additional_info(desc, 0x00);\newline}\newline","MPEG Descriptor 0x2b: MPEG-2 AAC audio descriptor \newline","537619","natpmp.c","void SendNATPMPPublicAddressChangeNotification(int * sockets, int n_sockets)\newline{\newline	struct sockaddr_in sockname;\newline	unsigned char notif[12];\newline	int j, n;\newline\newline	notif[0] = 0;	/* vers */\newline	notif[1] = 128;	/* OP code */\newline	notif[2] = 0;	/* result code */\newline	notif[3] = 0;	/* result code */\newline	/* seconds since &quotstart of epoch&quot :\newline	 * time elapsed since the port mapping table was initialized on\newline	 * startup or reset for any other reason */\newline	WRITENU32(notif+4, time(NULL) - startup_time);\newline#ifndef MULTIPLE_EXTERNAL_IP\newline	FillPublicAddressResponse(notif, 0);\newline	if(notif[3])\newline	{\newline		syslog(LOG_WARNING, &quot%s: cannot get public IP address, stopping&quot,\newline		       &quotSendNATPMPPublicAddressChangeNotification&quot);\newline		return;\newline	}\newline#endif\newline	memset(&ampsockname, 0, sizeof(struct sockaddr_in));\newline    sockname.sin_family = AF_INET;\newline    sockname.sin_addr.s_addr = inet_addr(NATPMP_NOTIF_ADDR);\newline\newline	for(j=0; j&ltn_sockets; j++)\newline	{\newline		if(sockets[j] &lt 0)\newline			continue;\newline#ifdef MULTIPLE_EXTERNAL_IP\newline		{\newline			struct lan_addr_s * lan_addr = lan_addrs.lh_first;\newline			int i;\newline			for(i=0; i&ltj; i++)\newline				lan_addr = lan_addr-&gtlist.le_next;\newline			FillPublicAddressResponse(notif, lan_addr-&gtaddr.s_addr);\newline		}\newline#endif\newline		/* Port to use in 2006 version of the NAT-PMP specification */\newline    	sockname.sin_port = htons(NATPMP_PORT);\newline		n = sendto_or_schedule(sockets[j], notif, 12, 0,\newline		           (struct sockaddr *)&ampsockname, sizeof(struct sockaddr_in));\newline		if(n &lt 0)\newline		{\newline			syslog(LOG_ERR, &quot%s: sendto(s_udp=%d): %m&quot,\newline			       &quotSendNATPMPPublicAddressChangeNotification&quot, sockets[j]);\newline			return;\newline		}\newline		/* Port to use in 2008 version of the NAT-PMP specification */\newline    	sockname.sin_port = htons(NATPMP_NOTIF_PORT);\newline		n = sendto_or_schedule(sockets[j], notif, 12, 0,\newline		           (struct sockaddr *)&ampsockname, sizeof(struct sockaddr_in));\newline		if(n &lt 0)\newline		{\newline			syslog(LOG_ERR, &quot%s: sendto(s_udp=%d): %m&quot,\newline			       &quotSendNATPMPPublicAddressChangeNotification&quot, sockets[j]);\newline			return;\newline		}\newline	}\newline}\newline","SendNATPMPPublicAddressChangeNotification()\newline should be called when the public IP address changed \newline","","","","","on","","","on","","","","on","on","on","on","","","","on","","","","","","","","","","","","","","","","","","","","","","","","Calculates the nutation in longitude and obliquity","Get info on default (current) ICU locale","Creates a generic Kgio::Socket object","Set EISA driver-private data","{}","Projects 2d points to one of standard coordinate planes","Clean up after scanning a string.","{}","Restores the previously remembered visual settings","swap edge if it maximises the minimum slope","Parse a sample format text.","{}","{}","{}","{}","Adds a dependency between two tasks","Shows a version","Unstacks one layer of root colormap pushing","{}","Validate the <filter> parameter","SHOW SOCKETS"
"3LB1BGHFL2W52UXYU8PA22NAICXTYY","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3C5W7UE9CFQECEEX6H7XMTHY2O0XMW","A66CEWA5DO2W4","Approved","Wed Apr 17 18:14:43 PDT 2019","Wed Apr 17 18:24:58 PDT 2019","Fri Apr 19 18:24:58 PDT 2019","2019-04-20 01:25:27 UTC","","","615","100% (1/1)","100% (1/1)","100% (1/1)","3100911","sym53c8xx.c","static void ncr_nego_rejected(ncb_p np, tcb_p tp, ccb_p cp)\newline{\newline	ncr_nego_default(np, tp, cp);\newline	OUTB (HS_PRT, HS_BUSY);\newline}\newline","==========================================================\newline \newline ncr chip handler for MESSAGE REJECT received for \newline a WIDE or SYNCHRONOUS negotiation.\newline \newline clear the PPR negotiation flag, all future nego.\newline will be SDTR and WDTR\newline \newline ==========================================================\newline \newline Read comments above.\newline \newline ----------------------------------------------------------\newline \newline","4155484","libwebcam.c","CHandle c_open_device (const char *device_name)\newline{\newline	CHandle handle;\newline	const char *v4l2_name;\newline\newline	if(device_name == NULL || !initialized) {\newline		print_libwebcam_error(&quotUnable to open device. No name given or library not initialized.&quot);\newline		return 0;\newline	}\newline\newline	// Try to find the device with the given name.\newline	// Note: If the given name is a device path (e.g. /dev/video0), the V4L2 name\newline	// is simply generated by cutting off the &#039/dev/&#039 part. If the given name\newline	// starts with &#039video&#039, it is taken as is.\newline	if(strstr(device_name, &quot/dev/video&quot) == device_name)\newline		v4l2_name = &ampdevice_name[5];\newline	else if(strstr(device_name, &quotvideo&quot) == device_name)\newline		v4l2_name = device_name;\newline	else {\newline		print_libwebcam_error(&quotUnable to open device &#039%s&#039. Unrecognized device name.&quot, device_name);\newline		return 0;\newline	}\newline	Device *device = find_device_by_name(v4l2_name);\newline	if(device == NULL) {\newline		print_libwebcam_error(&quotUnable to open device &#039%s&#039. Device not found.&quot, device_name);\newline		return 0;\newline	}\newline\newline	// Open device when needed\newline	if (device-&gtfd== 0) {\newline		device-&gtfd= open_v4l2_device(device-&gtv4l2_name);\newline		if (device-&gtfd&lt= 0) {\newline			print_libwebcam_error(&quotopen sys call failed for %s&#039.&quot, device_name);\newline			// Open error\newline			device-&gtfd= 0;\newline			return 0;\newline		}\newline	}\newline\newline	// Create a handle for the given device\newline	// TODO Race condition if delete_device is called here (via c_cleanup)\newline	handle = create_handle(device);\newline	if (handle== 0) {\newline		close(device-&gtfd);\newline		device-&gtfd= 0;\newline	}\newline	return handle;\newline}\newline","\newline Opens a camera device.\newline \newline The function returns a handle that can be used for all functions that require\newline a device handle.\newline \newline @param device_name Name of the device to open.\newline Two different naming schemes are accepted: Full device names\newline (e.g. &#039/dev/video0&#039) and short names (e.g. &#039video0&#039) as\newline returned by c_enum_devices().\newline @return\newline - a device handle greater than zero on success\newline - 0 if an error has occurred\newline \newline","6058327","netmate.c","void show_warning(GtkWidget *widget, gpointer message) {\newline  GtkWidget *toplevel;	/* the toplevel window */\newline  GtkWidget *dialog;	/* the dialog object */\newline\newline  /* get toplevel from widget */\newline  toplevel = gtk_widget_get_toplevel(widget);\newline\newline  /* show window only if toplevel */\newline  if (gtk_widget_is_toplevel(toplevel)) {\newline\newline    /* create new dialog */\newline    dialog = gtk_message_dialog_new(GTK_WINDOW(toplevel), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK, &quot%s&quot, (char*)message);\newline\newline    /* set title */\newline    gtk_window_set_title(GTK_WINDOW(dialog), &quotWarning&quot);\newline\newline    /* run dialog */\newline    gtk_dialog_run(GTK_DIALOG(dialog));\newline\newline    /* destroy dialog */\newline    gtk_widget_destroy(dialog);\newline  }\newline}\newline","shows a warning popup with given (char ) as message \newline","2531900","parse_cmdline.c","static void apply_option(options_t *opts, parsed_option_t* option)\newline{\newline	cmdline_opt_t* o = option-&gto;\newline	unsigned short option_type = o-&gttype;\newline	char* value = NULL;\newline\newline	/* check if option requires a parameter */\newline	if (is_param_required(option_type)) {\newline		if (!option-&gtparameter) {\newline			log_error(_(&quotargument is required for option %s\\n&quot), option-&gtname);\newline			rsh_exit(2);\newline		}\newline\newline#ifdef _WIN32\newline		if (option_type == F_TOUT) {\newline			/* leave the value in UTF-16 */\newline			value = (char*)rsh_wcsdup((wchar_t*)option-&gtparameter);\newline		}\newline		else if (option_type == F_UFNC) {\newline			/* convert from UTF-16 to UTF-8 */\newline			value = wchar_to_cstr((wchar_t*)option-&gtparameter, CP_UTF8, NULL);\newline		} else {\newline			/* convert from UTF-16 */\newline			value = w2c((wchar_t*)option-&gtparameter);\newline		}\newline		rsh_vector_add_ptr(opt.mem, value);\newline#else\newline		value = (char*)option-&gtparameter;\newline#endif\newline	}\newline\newline	/* process option, choosing the method by type */\newline	switch (option_type) {\newline	case F_UFLG:\newline	case F_UENC:\newline		*(unsigned*)((char*)opts + ((char*)o-&gtptr - (char*)&ampopt)) |= o-&gtparam;\newline		break;\newline	case F_CSTR:\newline	case F_TOUT:\newline		/* save the option parameter */\newline		*(char**)((char*)opts + ((char*)o-&gtptr - (char*)&ampopt)) = value;\newline		break;\newline	case F_PFNC:\newline	case F_UFNC:\newline		/* call option parameter handler */\newline		( ( void(*)(options_t *, char*, unsigned) )o-&gtptr )(opts, value, o-&gtparam);\newline		break;\newline	case F_VFNC:\newline		( ( void(*)(options_t *) )o-&gtptr )(opts); /* call option handler */\newline		break;\newline	case F_PRNT:\newline		log_msg(&quot%s&quot, (char*)o-&gtptr);\newline		rsh_exit(0);\newline		break;\newline	default:\newline		assert(0); /* impossible option type */\newline	}\newline}\newline","\newline Process given command line option\newline \newline @param opts the structure to store results of option processing\newline @param option option to process\newline \newline","2626909","msgcookie.c","aim_msgcookie_t *aim_mkcookie(guint8 *c, int type, void *data)\newline{\newline	aim_msgcookie_t *cookie;\newline\newline	if (!c) {\newline		return NULL;\newline	}\newline\newline	if (!(cookie = g_new0(aim_msgcookie_t, 1))) {\newline		return NULL;\newline	}\newline\newline	cookie-&gtdata = data;\newline	cookie-&gttype = type;\newline	memcpy(cookie-&gtcookie, c, 8);\newline\newline	return cookie;\newline}\newline","\newline aim_mkcookie - generate an aim_msgcookie_t struct from a cookie string, a type, and a data pointer.\newline @c: pointer to the cookie string array\newline @type: cookie type to use\newline @data: data to be cached with the cookie\newline \newline returns NULL on error, a pointer to the newly-allocated cookie on\newline success.\newline \newline \newline","5084437","auth.c","void serf__encode_auth_header(const char **header,\newline                              const char *scheme,\newline                              const char *data, apr_size_t data_len,\newline                              apr_pool_t *pool)\newline{\newline    apr_size_t encoded_len, scheme_len;\newline    char *ptr;\newline\newline    encoded_len = apr_base64_encode_len(data_len);\newline    scheme_len = strlen(scheme);\newline\newline    ptr = apr_palloc(pool, encoded_len + scheme_len + 1);\newline    *header = ptr;\newline\newline    apr_cpystrn(ptr, scheme, scheme_len + 1);\newline    ptr += scheme_len;\newline    *ptr++ = &#039 &#039;\newline\newline    apr_base64_encode(ptr, data, data_len);\newline}\newline","\newline base64 encode the authentication data and build an authentication\newline header in this format:\newline [SCHEME] [BASE64 of auth DATA]\newline \newline","2747194","gtp.c","int gtp_echo_ind(struct gsn_t *gsn, int version, struct sockaddr_in *peer,\newline		 int fd, void *pack, unsigned len)\newline{\newline\newline	/* Check if it was a dublicate request */\newline	if (!gtp_dublicate(gsn, 0, peer, get_seq(pack)))\newline		return 0;\newline\newline	/* Send off reply to request */\newline	return gtp_echo_resp(gsn, version, peer, fd, pack, len);\newline}\newline","Handle a received echo request \newline","4500487","command.c","static int show_setting_help( World *wld, char *key )\newline{\newline	char *shortdesc, *longdesc;\newline\newline	if( world_desc_key( wld, key, &ampshortdesc, &amplongdesc ) != GET_KEY_OK )\newline		return 0;\newline\newline	world_msg_client( wld, &quot&quot );\newline	world_msg_client( wld, &quot%s&quot, key );\newline	world_msg_client( wld, &quot&quot );\newline\newline	if( longdesc )\newline		show_longdesc( wld, longdesc );\newline	else\newline		show_longdesc( wld, shortdesc );\newline\newline	return 1;\newline}\newline","Displays the help for one setting.\newline Returns 1 if it was able to show the help for key, 0 otherwise. \newline","2234403","curve_tools.c","float *catmull_rom_set(int n, float x[], float y[])\newline{\newline  float *m;\newline  int i;\newline  if(n &lt= 1)\newline  {\newline    // nc_message(NC_SET_ERROR, &quotspline_cubic_set() error: &quot\newline    //   &quotThe number of data points must be at least 2.\\n&quot);\newline    return NULL;\newline  }\newline\newline  for(i = 0; i &lt n - 1; i++)\newline  {\newline    if(x[i + 1] &lt= x[i])\newline    {\newline      // nc_message(NC_SET_ERROR, &quotspline_cubic_set() error: &quot\newline      //   &quotThe knots must be strictly increasing, but &quot\newline      //  &quotT(%u) = %e, T(%u) = %e\\n&quot,i,x[i],i+1,x[i+1]);\newline      return NULL;\newline    }\newline  }\newline  // nc_merror(delta, &quotspline_cubic_set&quot);\newline  m = (float *)calloc(n, sizeof(float));\newline  // nc_merror(m, &quotspline_cubic_set&quot);\newline\newline  // calculate the slopes\newline  m[0] = (y[1] - y[0]) / (x[1] - x[0]);\newline  for(i = 1; i &lt n - 1; i++)\newline  {\newline    m[i] = (y[i + 1] - y[i - 1]) / (x[i + 1] - x[i - 1]);\newline  }\newline  m[n - 1] = (y[n - 1] - y[n - 2]) / (x[n - 1] - x[n - 2]);\newline\newline  return m;\newline}\newline","\newline catmull_rom_set:\newline calculates the tangents for a catmull_rom spline\newline see http://en.wikipedia.org/wiki/Cubic_Hermite_spline\newline \newline \newline input:\newline n = number of control points\newline x = input x array\newline y = input y array\newline output:\newline pointer to array containing the tangents\newline \newline","4854656","db.c","void db_end_module(\newline  int end_line  /*!&lt Ending line number of specified module in file */\newline) { PROFILE(DB_END_MODULE);\newline\newline#ifdef DEBUG_MODE\newline  if( debug_mode ) {\newline    unsigned int rv = snprintf( user_msg, USER_MSG_LENGTH, &quotIn db_end_module, end_line: %d&quot, end_line );\newline    assert( rv &lt USER_MSG_LENGTH );\newline    print_output( user_msg, DEBUG, __FILE__, __LINE__ );\newline  }\newline#endif\newline\newline  curr_funit-&gtend_line = end_line;\newline\newline  str_link_remove( curr_funit-&gtname, &ampmodlist_head, &ampmodlist_tail );\newline\newline  /* Return the current functional unit to the global functional unit, if it exists */\newline  curr_funit = global_funit;\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineUpdates the modlist for parsing purposes.\newline \newline","5796841","midi-server.cpp","void MIDI_SERVER::add_mmc_send_id(int id)\newline{\newline  mmc_send_ids_rep.push_back(id);\newline}\newline","\newline Adds a new client to which MMC-messages are sent\newline during processing. \newline \newline Note! Id &#039127&#039 is specified as the all-device \newline id-number in the MMC-spec.\newline \newline","6079086","key_handling.c","int install_remote_key(gchar *user, gchar *host, gchar *port, gchar *password, struct w *widgets)\newline{\newline    FILE *fp;\newline    char **new_argv;\newline    gchar *key_name_priv, *key_name_pub, *key_path_pub, *key_path_priv;\newline    gchar *script, *script_name, *script_path, *info;\newline    int retval = 0;\newline\newline    key_name_priv = mk_key_name(user, host, &quotpriv&quot);\newline    key_name_pub  = mk_key_name(user, host, &quotpub&quot);\newline    \newline    key_path_priv = g_strdup_printf(&quot%s/%s&quot, global_key_path, key_name_priv);\newline    key_path_pub  = g_strdup_printf(&quot%s/%s&quot, global_key_path, key_name_pub);\newline\newline    if( ! file_exists(key_path_priv) )\newline    {\newline	info = g_strdup_printf(_(&quotError: The local private key does not exist.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline	printf(&quotError: The local private key doesnt exist: %s\\n&quot, key_path_priv);\newline\newline	g_free(key_name_priv);\newline	g_free(key_name_pub);\newline	g_free(key_path_priv);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline\newline    g_free(key_name_priv);\newline    g_free(key_path_priv);\newline\newline\newline    if( ! file_exists(key_path_pub) )\newline    {\newline	info = g_strdup_printf(_(&quotError: The local public key does not exist.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline	printf(&quotError: The local public key doesnt exist: %s\\n&quot, key_path_pub);\newline\newline	g_free(key_name_pub);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline\newline\newline    /* Make the key install script */\newline    script_name = g_strdup_printf(&quotgadmin-rsync-ssh.sh&quot);\newline\newline    script = g_strconcat(&quot#!/bin/bash\\n&quot,\newline    &quot### Gadmin-rsync ssh key installer ###\\n\\n&quot,\newline    &quotif [ ! -e .ssh ]; then\\n&quot,\newline    &quot   mkdir .ssh &amp&amp chmod 700 .ssh\\n&quot\newline    &quotfi\\n\\n&quot,\newline\newline    &quotcd .ssh || exit 1\\n\\n&quot,\newline	\newline    &quotif [ ! -f authorized_keys ]; then\\n&quot,\newline    &quot   touch authorized_keys &amp&amp chmod 600 authorized_keys\\n&quot\newline    &quotfi\\n\\n&quot\newline		\newline    &quotcat ../&quot, key_name_pub, &quot &gt&gt authorized_keys\\n&quot,\newline    \newline    &quotrm -f ../&quot, key_name_pub, &quot\\n&quot,\newline    &quotrm -f ../&quot, script_name, &quot\\n&quot,\newline    NULL);\newline\newline    g_free(key_name_pub);\newline\newline\newline    /* Write the pub key install script */\newline    script_path = g_strdup_printf(&quot%s/%s&quot, global_home_dir, script_name);\newline\newline    if((fp=fopen(script_path, &quotw+&quot))==NULL)\newline    {\newline	printf(&quotError writing install script file here: %s\\n&quot, script_path);\newline\newline	g_free(script);\newline	g_free(script_name);\newline	g_free(script_path);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline    fputs(script, fp);\newline    fclose(fp);    \newline\newline    g_free(script);\newline\newline\newline    /* Upload public key and key install script to the remote server */\newline    gchar *user_host_dir = g_strdup_printf(&quot%s@%s:~&quot, user, host);\newline\newline    new_argv = create_scp_upload_cmd(user, port, key_path_pub, script_path, user_host_dir);\newline\newline    if( ! run_ssh_cmd(new_argv, password) )\newline    {\newline	printf(&quotError uploading key.\\n&quot);\newline	g_free(script_path);\newline	g_free(key_path_pub);\newline	g_free(user_host_dir);\newline	g_free(script_name);\newline	free(new_argv);\newline\newline	return retval;\newline    }\newline\newline    free(new_argv);\newline    g_free(user_host_dir);\newline\newline\newline    /* Create the key install command */\newline    gchar *ssh_cmd = g_strdup_printf(&quotchmod 755 ~/%s &amp&amp sh ~/%s &amp&amp rm -f ~/%s&quot, script_name, script_name, script_name);\newline    \newline    new_argv = create_ssh_cmd(user, host, port, ssh_cmd);\newline\newline    if( ! run_ssh_cmd(new_argv, password) )\newline    {\newline	info = g_strdup_printf(_(&quotError: Could not install the public key on the remote host.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline        printf(&quotError installing key on the remote host.\\n&quot);\newline        \newline	g_free(script_path);\newline	g_free(key_path_pub);\newline	g_free(script_name);\newline	g_free(ssh_cmd);\newline	free(new_argv);\newline\newline	return retval;\newline    }\newline    else\newline    {\newline	/* This info is good. Will be shown in the progress bar later */\newline	info = g_strdup_printf(_(&quotPublic key installation on remote host successful.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline        printf(&quotKey installation successful.\\n&quot);\newline\newline	retval = 1;\newline    }\newline\newline    free(new_argv);\newline\newline    g_free(ssh_cmd);\newline    g_free(script_name);\newline\newline    /* Remove the local script */\newline    unlink(script_path);\newline    g_free(script_path);\newline\newline    g_free(key_path_pub);\newline\newline\newline    return retval;\newline}\newline","Upload public key to remote host and append it to file: ~/.ssh/authorized_keys \newline","2178210","psi.c","static uint32_t psi_ccrc(struct psisec_s *section) {\newline	return crc32_be(0xffffffff, section-&gtdata, psi_len(section)-4);\newline}\newline","Calculate the CRC of the section \newline","2296341","fuser.c","void fill_unix_cache(struct unixsocket_list **unixsocket_head)\newline{\newline	FILE *fp;\newline	char line[BUFSIZ];\newline	int scanned_inode;\newline	struct stat st;\newline	struct unixsocket_list *newsocket;\newline\newline	if ((fp = fopen(&quot/proc/net/unix&quot, &quotr&quot)) == NULL) {\newline		fprintf(stderr, _(&quotCannot open /proc/net/unix: %s\\n&quot),\newline			strerror(errno));\newline		return;\newline	}\newline	while (fgets(line, BUFSIZ, fp) != NULL) {\newline		char *path;\newline		char *scanned_path = NULL;\newline		if (sscanf(line, &quot%*x: %*x %*x %*x %*x %*d %d %ms&quot,\newline			   &ampscanned_inode, &ampscanned_path) != 2) {\newline			if (scanned_path)\newline				free(scanned_path);\newline			continue;\newline		}\newline		if (scanned_path == NULL)\newline			continue;\newline		path = scanned_path;\newline		if (*scanned_path == &#039@&#039)\newline			scanned_path++;\newline		if (timeout(thestat, scanned_path, &ampst, 5) &lt 0) {\newline			free(path);\newline			continue;\newline		}\newline		if ((newsocket = (struct unixsocket_list *)\newline		     malloc(sizeof(struct unixsocket_list))) == NULL) {\newline			free(path);\newline			continue;\newline		}\newline		newsocket-&gtsun_name = strdup(scanned_path);\newline		newsocket-&gtinode = st.st_ino;\newline		newsocket-&gtdev = st.st_dev;\newline		newsocket-&gtnet_inode = scanned_inode;\newline		newsocket-&gtnext = *unixsocket_head;\newline		*unixsocket_head = newsocket;\newline		free(path);\newline	}			/* while */\newline\newline	fclose(fp);\newline}\newline","\newline fill_unix_cache : Create a list of Unix sockets\newline This list is used later for matching purposes\newline \newline","1259483","tidy.c","int main( int argc, char** argv )\newline{\newline    ctmbstr prog = argv[0];\newline    ctmbstr cfgfil = NULL, errfil = NULL, htmlfil = NULL;\newline    TidyDoc tdoc = tidyCreate();\newline    int status = 0;\newline    tmbstr locale = NULL;\newline\newline    uint contentErrors = 0;\newline    uint contentWarnings = 0;\newline    uint accessWarnings = 0;\newline\newline    errout = stderr;  /* initialize to stderr */\newline\newline    /* Set an atexit handler. */\newline    atexit( tidy_cleanup );\newline    \newline    /* Set the locale for tidy&#039s output. */\newline    locale = tidySystemLocale(locale);\newline    tidySetLanguage(locale);\newline    if ( locale )\newline        free( locale );\newline\newline#if defined(_WIN32)\newline    /* Force Windows console to use UTF, otherwise many characters will\newline     * be garbage. Note that East Asian languages *are* supported, but\newline     * only when Windows OS locale (not console only!) is set to an\newline     * East Asian language.\newline     */\newline    win_cp = GetConsoleOutputCP();\newline    SetConsoleOutputCP(CP_UTF8);\newline#endif\newline\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline    set_log_file((char *)&quottemptidy.txt&quot, 0);\newline    // add_append_log(1);\newline#endif\newline\newline    /*\newline     * Look for default configuration files using any of\newline     * the following possibilities:\newline     *  - TIDY_CONFIG_FILE - from tidyplatform.h, typically /etc/tidy.conf\newline     *  - HTML_TIDY        - environment variable\newline     *  - TIDY_USER_CONFIG_FILE - from tidyplatform.h, typically ~/tidy.conf\newline     */\newline\newline#ifdef TIDY_CONFIG_FILE\newline    if ( tidyFileExists( tdoc, TIDY_CONFIG_FILE) )\newline    {\newline        status = tidyLoadConfig( tdoc, TIDY_CONFIG_FILE );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), TIDY_CONFIG_FILE, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#endif /* TIDY_CONFIG_FILE */\newline\newline    if ( (cfgfil = getenv(&quotHTML_TIDY&quot)) != NULL )\newline    {\newline        status = tidyLoadConfig( tdoc, cfgfil );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), cfgfil, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#ifdef TIDY_USER_CONFIG_FILE\newline    else if ( tidyFileExists( tdoc, TIDY_USER_CONFIG_FILE) )\newline    {\newline        status = tidyLoadConfig( tdoc, TIDY_USER_CONFIG_FILE );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), TIDY_USER_CONFIG_FILE, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#endif /* TIDY_USER_CONFIG_FILE */\newline\newline\newline    /*\newline     * Read command line\newline     */\newline\newline    while ( argc &gt 0 )\newline    {\newline        if (argc &gt 1 &amp&amp argv[1][0] == &#039-&#039)\newline        {\newline            /* support -foo and --foo */\newline            ctmbstr arg = argv[1] + 1;\newline\newline            if ( strcasecmp(arg, &quotxml&quot) == 0)\newline                tidyOptSetBool( tdoc, TidyXmlTags, yes );\newline\newline            else if ( strcasecmp(arg,   &quotasxml&quot) == 0 ||\newline                     strcasecmp(arg, &quotasxhtml&quot) == 0 )\newline            {\newline                tidyOptSetBool( tdoc, TidyXhtmlOut, yes );\newline            }\newline            else if ( strcasecmp(arg,   &quotashtml&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyHtmlOut, yes );\newline\newline            else if ( strcasecmp(arg, &quotindent&quot) == 0 )\newline            {\newline                tidyOptSetInt( tdoc, TidyIndentContent, TidyAutoState );\newline                if ( tidyOptGetInt(tdoc, TidyIndentSpaces) == 0 )\newline                    tidyOptResetToDefault( tdoc, TidyIndentSpaces );\newline            }\newline            else if ( strcasecmp(arg, &quotomit&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyOmitOptionalTags, yes );\newline\newline            else if ( strcasecmp(arg, &quotupper&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyUpperCaseTags, yes );\newline\newline            else if ( strcasecmp(arg, &quotclean&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyMakeClean, yes );\newline\newline            else if ( strcasecmp(arg, &quotgdoc&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyGDocClean, yes );\newline\newline            else if ( strcasecmp(arg, &quotbare&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyMakeBare, yes );\newline\newline            else if ( strcasecmp(arg, &quotraw&quot) == 0     ||\newline                     strcasecmp(arg, &quotascii&quot) == 0    ||\newline                     strcasecmp(arg, &quotlatin0&quot) == 0   ||\newline                     strcasecmp(arg, &quotlatin1&quot) == 0   ||\newline                     strcasecmp(arg, &quotutf8&quot) == 0     ||\newline#ifndef NO_NATIVE_ISO2022_SUPPORT\newline                     strcasecmp(arg, &quotiso2022&quot) == 0  ||\newline#endif\newline#if SUPPORT_UTF16_ENCODINGS\newline                     strcasecmp(arg, &quotutf16le&quot) == 0  ||\newline                     strcasecmp(arg, &quotutf16be&quot) == 0  ||\newline                     strcasecmp(arg, &quotutf16&quot) == 0    ||\newline#endif\newline#if SUPPORT_ASIAN_ENCODINGS\newline                     strcasecmp(arg, &quotshiftjis&quot) == 0 ||\newline                     strcasecmp(arg, &quotbig5&quot) == 0     ||\newline#endif\newline                     strcasecmp(arg, &quotmac&quot) == 0      ||\newline                     strcasecmp(arg, &quotwin1252&quot) == 0  ||\newline                     strcasecmp(arg, &quotibm858&quot) == 0 )\newline            {\newline                tidySetCharEncoding( tdoc, arg );\newline            }\newline            else if ( strcasecmp(arg, &quotnumeric&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyNumEntities, yes );\newline\newline            else if ( strcasecmp(arg, &quotmodify&quot) == 0 ||\newline                     strcasecmp(arg, &quotchange&quot) == 0 ||  /* obsolete */\newline                     strcasecmp(arg, &quotupdate&quot) == 0 )   /* obsolete */\newline            {\newline                tidyOptSetBool( tdoc, TidyWriteBack, yes );\newline            }\newline            else if ( strcasecmp(arg, &quoterrors&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyShowMarkup, no );\newline\newline            else if ( strcasecmp(arg, &quotquiet&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyQuiet, yes );\newline\newline            /* Currenly user must specify a language\newline             prior to anything that causes output */\newline            else if ( strcasecmp(arg, &quotlanguage&quot) == 0 ||\newline                     strcasecmp(arg,     &quotlang&quot) == 0 )\newline                if ( argc &gt= 3)\newline                {\newline                    if ( strcasecmp(argv[2], &quothelp&quot) == 0 )\newline                    {\newline                        lang_help();\newline                        exit(0);\newline                    }\newline                    if ( !tidySetLanguage( argv[2] ) )\newline                    {\newline                        printf(tidyLocalizedString(TC_STRING_LANG_NOT_FOUND),\newline                               argv[2], tidyGetLanguage());\newline                        printf(&quot\\n&quot);\newline                    }\newline                    --argc;\newline                    ++argv;\newline                }\newline                else\newline                {\newline                    printf( &quot%s\\n&quot, tidyLocalizedString(TC_STRING_LANG_MUST_SPECIFY));\newline                }\newline\newline                else if ( strcasecmp(arg, &quothelp&quot) == 0 ||\newline                         strcasecmp(arg, &quot-help&quot) == 0 ||\newline                         strcasecmp(arg,    &quoth&quot) == 0 || *arg == &#039?&#039 )\newline                {\newline                    help( prog );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-help&quot) == 0)\newline                {\newline                    xml_help( );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-error-strings&quot) == 0)\newline                {\newline                    xml_error_strings( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-options-strings&quot) == 0)\newline                {\newline                    xml_options_strings( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-strings&quot) == 0)\newline                {\newline                    xml_strings( );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quothelp-config&quot) == 0 )\newline                {\newline                    optionhelp( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quothelp-option&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3)\newline                    {\newline                        optionDescribe( tdoc, argv[2] );\newline                    }\newline                    else\newline                    {\newline                        printf( &quot%s\\n&quot, tidyLocalizedString(TC_STRING_MUST_SPECIFY));\newline                    }\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-config&quot) == 0 )\newline                {\newline                    XMLoptionhelp( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotshow-config&quot) == 0 )\newline                {\newline                    optionvalues( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotconfig&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        ctmbstr post;\newline\newline                        tidyLoadConfig( tdoc, argv[2] );\newline\newline                        /* Set new error output stream if setting changed */\newline                        post = tidyOptGetValue( tdoc, TidyErrFile );\newline                        if ( post &amp&amp (!errfil || !samefile(errfil, post)) )\newline                        {\newline                            errfil = post;\newline                            errout = tidySetErrorFile( tdoc, post );\newline                        }\newline\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline\newline                else if ( strcasecmp(arg, &quotoutput&quot) == 0 ||\newline                         strcasecmp(arg, &quot-output-file&quot) == 0 ||\newline                         strcasecmp(arg, &quoto&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        tidyOptSetValue( tdoc, TidyOutFile, argv[2] );\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotfile&quot) == 0 ||\newline                         strcasecmp(arg, &quot-file&quot) == 0 ||\newline                         strcasecmp(arg,     &quotf&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        errfil = argv[2];\newline                        errout = tidySetErrorFile( tdoc, errfil );\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotwrap&quot) == 0 ||\newline                         strcasecmp(arg, &quot-wrap&quot) == 0 ||\newline                         strcasecmp(arg,     &quotw&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        uint wraplen = 0;\newline                        int nfields = sscanf( argv[2], &quot%u&quot, &ampwraplen );\newline                        tidyOptSetInt( tdoc, TidyWrapLen, wraplen );\newline                        if (nfields &gt 0)\newline                        {\newline                            --argc;\newline                            ++argv;\newline                        }\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotversion&quot) == 0 ||\newline                         strcasecmp(arg, &quot-version&quot) == 0 ||\newline                         strcasecmp(arg,        &quotv&quot) == 0 )\newline                {\newline                    version();\newline                    tidyRelease( tdoc );\newline                    return 0;  /* success */\newline\newline                }\newline                else if ( strncmp(argv[1], &quot--&quot, 2 ) == 0)\newline                {\newline                    if ( tidyOptParseValue(tdoc, argv[1]+2, argv[2]) )\newline                    {\newline                        /* Set new error output stream if setting changed */\newline                        ctmbstr post = tidyOptGetValue( tdoc, TidyErrFile );\newline                        if ( post &amp&amp (!errfil || !samefile(errfil, post)) )\newline                        {\newline                            errfil = post;\newline                            errout = tidySetErrorFile( tdoc, post );\newline                        }\newline\newline                        ++argv;\newline                        --argc;\newline                    }\newline                }\newline\newline#if SUPPORT_ACCESSIBILITY_CHECKS\newline                else if ( strcasecmp(arg, &quotaccess&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        uint acclvl = 0;\newline                        int nfields = sscanf( argv[2], &quot%u&quot, &ampacclvl );\newline                        tidyOptSetInt( tdoc, TidyAccessibilityCheckLevel, acclvl );\newline                        if (nfields &gt 0)\newline                        {\newline                            --argc;\newline                            ++argv;\newline                        }\newline                    }\newline                }\newline#endif\newline\newline                else\newline                {\newline                    uint c;\newline                    ctmbstr s = argv[1];\newline\newline                    while ( (c = *++s) != &#039\\0&#039 )\newline                    {\newline                        switch ( c )\newline                        {\newline                            case &#039i&#039:\newline                                tidyOptSetInt( tdoc, TidyIndentContent, TidyAutoState );\newline                                if ( tidyOptGetInt(tdoc, TidyIndentSpaces) == 0 )\newline                                    tidyOptResetToDefault( tdoc, TidyIndentSpaces );\newline                                break;\newline\newline                                /* Usurp -o for output file.  Anyone hiding end tags?\newline                                 case &#039o&#039:\newline                                 tidyOptSetBool( tdoc, TidyHideEndTags, yes );\newline                                 break;\newline                                 */\newline\newline                            case &#039u&#039:\newline                                tidyOptSetBool( tdoc, TidyUpperCaseTags, yes );\newline                                break;\newline\newline                            case &#039c&#039:\newline                                tidyOptSetBool( tdoc, TidyMakeClean, yes );\newline                                break;\newline\newline                            case &#039g&#039:\newline                                tidyOptSetBool( tdoc, TidyGDocClean, yes );\newline                                break;\newline\newline                            case &#039b&#039:\newline                                tidyOptSetBool( tdoc, TidyMakeBare, yes );\newline                                break;\newline\newline                            case &#039n&#039:\newline                                tidyOptSetBool( tdoc, TidyNumEntities, yes );\newline                                break;\newline\newline                            case &#039m&#039:\newline                                tidyOptSetBool( tdoc, TidyWriteBack, yes );\newline                                break;\newline\newline                            case &#039e&#039:\newline                                tidyOptSetBool( tdoc, TidyShowMarkup, no );\newline                                break;\newline\newline                            case &#039q&#039:\newline                                tidyOptSetBool( tdoc, TidyQuiet, yes );\newline                                break;\newline\newline                            default:\newline                                unknownOption( c );\newline                                break;\newline                        }\newline                    }\newline                }\newline\newline            --argc;\newline            ++argv;\newline            continue;\newline        }\newline\newline        if ( argc &gt 1 )\newline        {\newline            htmlfil = argv[1];\newline#if (!defined(NDEBUG) &amp&amp defined(_MSC_VER))\newline            SPRTF(&quotTidying &#039%s&#039\\n&quot, htmlfil);\newline#endif // DEBUG outout\newline            if ( tidyOptGetBool(tdoc, TidyEmacs) )\newline                tidyOptSetValue( tdoc, TidyEmacsFile, htmlfil );\newline            status = tidyParseFile( tdoc, htmlfil );\newline        }\newline        else\newline        {\newline            htmlfil = &quotstdin&quot;\newline            status = tidyParseStdin( tdoc );\newline        }\newline\newline        if ( status &gt= 0 )\newline            status = tidyCleanAndRepair( tdoc );\newline\newline        if ( status &gt= 0 ) {\newline            status = tidyRunDiagnostics( tdoc );\newline            if ( !tidyOptGetBool(tdoc, TidyQuiet) ) {\newline                /* NOT quiet, show DOCTYPE, if not already shown */\newline                if (!tidyOptGetBool(tdoc, TidyShowInfo)) {\newline                    tidyOptSetBool( tdoc, TidyShowInfo, yes );\newline                    tidyReportDoctype( tdoc );  /* FIX20140913: like warnings, errors, ALWAYS report DOCTYPE */\newline                    tidyOptSetBool( tdoc, TidyShowInfo, no );\newline                }\newline            }\newline\newline        }\newline        if ( status &gt 1 ) /* If errors, do we want to force output? */\newline            status = ( tidyOptGetBool(tdoc, TidyForceOutput) ? status : -1 );\newline\newline        if ( status &gt= 0 &amp&amp tidyOptGetBool(tdoc, TidyShowMarkup) )\newline        {\newline            if ( tidyOptGetBool(tdoc, TidyWriteBack) &amp&amp argc &gt 1 )\newline                status = tidySaveFile( tdoc, htmlfil );\newline            else\newline            {\newline                ctmbstr outfil = tidyOptGetValue( tdoc, TidyOutFile );\newline                if ( outfil ) {\newline                    status = tidySaveFile( tdoc, outfil );\newline                } else {\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    static char tmp_buf[264];\newline                    sprintf(tmp_buf,&quot%s.html&quot,get_log_file());\newline                    status = tidySaveFile( tdoc, tmp_buf );\newline                    SPRTF(&quotSaved tidied content to &#039%s&#039\\n&quot,tmp_buf);\newline#else\newline                    status = tidySaveStdout( tdoc );\newline#endif\newline                }\newline            }\newline        }\newline        \newline        contentErrors   += tidyErrorCount( tdoc );\newline        contentWarnings += tidyWarningCount( tdoc );\newline        accessWarnings  += tidyAccessWarningCount( tdoc );\newline        \newline        --argc;\newline        ++argv;\newline        \newline        if ( argc &lt= 1 )\newline            break;\newline    } /* read command line loop */\newline    \newline    \newline    if (!tidyOptGetBool(tdoc, TidyQuiet) &amp&amp\newline        errout == stderr &amp&amp !contentErrors)\newline        fprintf(errout, &quot\\n&quot);\newline    \newline    if (contentErrors + contentWarnings &gt 0 &amp&amp\newline        !tidyOptGetBool(tdoc, TidyQuiet))\newline        tidyErrorSummary(tdoc);\newline    \newline    if (!tidyOptGetBool(tdoc, TidyQuiet))\newline        tidyGeneralInfo(tdoc);\newline    \newline    /* called to free hash tables etc. */\newline    tidyRelease( tdoc );\newline    \newline    /* return status can be used by scripts */\newline    if ( contentErrors &gt 0 )\newline        return 2;\newline    \newline    if ( contentWarnings &gt 0 )\newline        return 1;\newline    \newline    /* 0 signifies all is ok */\newline    return 0;\newline}\newline","\newline MAIN -- let&#039s do something here.\newline \newline","1057554","tlslib.h","inline static void packet_deinit(void *p)\newline{\newline#ifdef ZERO_COPY\newline	gnutls_packet_t packet = p;\newline 	if (packet)\newline	 	gnutls_packet_deinit(packet);\newline#endif\newline}\newline","packet API \newline","5144069","conversions.c","void nmea_GPGSV2info(const nmeaGPGSV *pack, nmeaINFO *info) {\newline	int pack_index;\newline\newline	assert(pack);\newline	assert(info);\newline\newline	pack_index = pack-&gtpack_index;\newline	if (pack_index &lt 1)\newline		pack_index = 1;\newline\newline	if (pack_index &gt pack-&gtpack_count)\newline		pack_index = pack-&gtpack_count;\newline\newline	if ((pack_index * NMEA_SATINPACK) &gt NMEA_MAXSAT)\newline		pack_index = NMEA_NSATPACKS;\newline\newline	info-&gtpresent |= pack-&gtpresent;\newline	nmea_INFO_set_present(&ampinfo-&gtpresent, SMASK);\newline	info-&gtsmask |= GPGSV;\newline	if (nmea_INFO_is_present(pack-&gtpresent, SATINVIEW)) {\newline		int sat_index;\newline\newline		/* index of 1st sat in pack */\newline		int sat_offset = (pack_index - 1) * NMEA_SATINPACK;\newline		/* the number of sats in this sentence */\newline		int sat_count = ((sat_offset + NMEA_SATINPACK) &gt pack-&gtsat_count) ? (pack-&gtsat_count - sat_offset) : NMEA_SATINPACK;\newline\newline		for (sat_index = 0; sat_index &lt sat_count; sat_index++) {\newline			info-&gtsatinfo.sat[sat_offset + sat_index].id = pack-&gtsat_data[sat_index].id;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].elv = pack-&gtsat_data[sat_index].elv;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].azimuth = pack-&gtsat_data[sat_index].azimuth;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].sig = pack-&gtsat_data[sat_index].sig;\newline		}\newline\newline		info-&gtsatinfo.inview = pack-&gtsat_count;\newline	}\newline}\newline","\newline Fill nmeaINFO structure from GSV packet structure\newline \newline @param pack a pointer to the packet structure\newline @param info a pointer to the nmeaINFO structure\newline \newline","4312547","inet6.c","static const char *INET6_print(const char *ptr)\newline{\newline    static char name[INET6_ADDRSTRLEN + 1];\newline    socklen_t len = sizeof(name) - 1;\newline    name[len] = &#039\\0&#039;\newline    inet_ntop(AF_INET6, ptr, name, len);\newline    return fix_v4_address(name, (struct in6_addr *)ptr);\newline}\newline","Display an Internet socket address. \newline","3503546","inotifytools.c","char * inotifytools_filename_from_wd( int wd ) {\newline	niceassert( init, &quotinotifytools_initialize not called yet&quot );\newline	watch *w = watch_from_wd(wd);\newline	if (!w)\newline        return NULL;\newline\newline	return w-&gtfilename;\newline}\newline","\newline Get the filename used to establish a watch.\newline \newline inotifytools_initialize() must be called before this function can\newline be used.\newline \newline @param wd watch descriptor.\newline \newline @return filename associated with watch descriptor @a wd, or NULL if @a wd\newline is not associated with any filename.\newline \newline @note This always returns the filename which was used to establish a watch.\newline This means the filename may be a relative path. If this isn&#039t desired,\newline then always use absolute paths when watching files.\newline Also, this is not necessarily the filename which might have been used\newline to cause an event on the file, since inotify is inode based and there\newline can be many filenames mapping to a single inode.\newline Finally, if a file is moved or renamed while being watched, the\newline filename returned will still be the original name.\newline \newline","2152530","scroll.c","int getCDKScrollCurrentTop (CDKSCROLL *widget)\newline{\newline   return widget-&gtcurrentTop;\newline}\newline","\newline Get/Set the top line of the scroller.\newline \newline","5789822","ap_abstract0.c","bool ap_abstract0_check_linexpr_array(ap_funid_t funid, ap_manager_t* man,\newline				      ap_dimension_t dimension,\newline				      ap_linexpr0_t** texpr, size_t size)\newline{\newline  size_t i;\newline\newline  for (i=0;i&ltsize; i++){\newline    if (texpr[i]==NULL){\newline      char str[80];\newline      sprintf(str,&quotnull pointer in the %luth expression of the array&quot,(unsigned long)i);\newline      ap_manager_raise_exception(man,\newline				 AP_EXC_INVALID_ARGUMENT,\newline				 funid,str);\newline      return false;\newline    }\newline    ap_dim_t dim = ap_abstract0_check_linexpr_check(dimension,texpr[i]);\newline    if (dim!=AP_DIM_MAX){\newline      char str[80];\newline      sprintf(str,&quotincompatible dimension in the %luth expression of the array&quot,(unsigned long)i);\newline      ap_abstract0_check_expr_raise(funid,man,dimension,dim,str);\newline      return false;\newline    }\newline  }\newline  return true;\newline}\newline","Check that array of linear expressions makes sense in the given dimensionality \newline","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","on","","","","","clear the PPR negotiation flag,","Updates the modlist","Adds a new client","Upload public key","Calculate the CRC","Create a list of Unix sockets","do something","packet","Fill nmeaINFO structure","Display an Internet socket address.","Get the filename","The function returns a handle","Get/Set the top line of the scroller.","Check that array of linear expressions makes sense","shows a warning popup with given (char )","opts the structure to store results","generate an aim_msgcookie_t struct","encode the authentication data and build an authenticationheader","Handle a received echo request","Displays the help for one setting.","calculates the tangents for a catmull_rom spline"
"3LB1BGHFL2W52UXYU8PA22NAICXTYY","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3QHK8ZVMIMINTTTB19E0XJBHJEVBL4","AVC62JNYAXA45","Approved","Wed Apr 17 14:13:56 PDT 2019","Wed Apr 17 14:40:29 PDT 2019","Fri Apr 19 14:40:29 PDT 2019","2019-04-19 21:41:21 UTC","","","1593","100% (24/24)","100% (24/24)","100% (24/24)","3100911","sym53c8xx.c","static void ncr_nego_rejected(ncb_p np, tcb_p tp, ccb_p cp)\newline{\newline	ncr_nego_default(np, tp, cp);\newline	OUTB (HS_PRT, HS_BUSY);\newline}\newline","==========================================================\newline \newline ncr chip handler for MESSAGE REJECT received for \newline a WIDE or SYNCHRONOUS negotiation.\newline \newline clear the PPR negotiation flag, all future nego.\newline will be SDTR and WDTR\newline \newline ==========================================================\newline \newline Read comments above.\newline \newline ----------------------------------------------------------\newline \newline","4155484","libwebcam.c","CHandle c_open_device (const char *device_name)\newline{\newline	CHandle handle;\newline	const char *v4l2_name;\newline\newline	if(device_name == NULL || !initialized) {\newline		print_libwebcam_error(&quotUnable to open device. No name given or library not initialized.&quot);\newline		return 0;\newline	}\newline\newline	// Try to find the device with the given name.\newline	// Note: If the given name is a device path (e.g. /dev/video0), the V4L2 name\newline	// is simply generated by cutting off the &#039/dev/&#039 part. If the given name\newline	// starts with &#039video&#039, it is taken as is.\newline	if(strstr(device_name, &quot/dev/video&quot) == device_name)\newline		v4l2_name = &ampdevice_name[5];\newline	else if(strstr(device_name, &quotvideo&quot) == device_name)\newline		v4l2_name = device_name;\newline	else {\newline		print_libwebcam_error(&quotUnable to open device &#039%s&#039. Unrecognized device name.&quot, device_name);\newline		return 0;\newline	}\newline	Device *device = find_device_by_name(v4l2_name);\newline	if(device == NULL) {\newline		print_libwebcam_error(&quotUnable to open device &#039%s&#039. Device not found.&quot, device_name);\newline		return 0;\newline	}\newline\newline	// Open device when needed\newline	if (device-&gtfd== 0) {\newline		device-&gtfd= open_v4l2_device(device-&gtv4l2_name);\newline		if (device-&gtfd&lt= 0) {\newline			print_libwebcam_error(&quotopen sys call failed for %s&#039.&quot, device_name);\newline			// Open error\newline			device-&gtfd= 0;\newline			return 0;\newline		}\newline	}\newline\newline	// Create a handle for the given device\newline	// TODO Race condition if delete_device is called here (via c_cleanup)\newline	handle = create_handle(device);\newline	if (handle== 0) {\newline		close(device-&gtfd);\newline		device-&gtfd= 0;\newline	}\newline	return handle;\newline}\newline","\newline Opens a camera device.\newline \newline The function returns a handle that can be used for all functions that require\newline a device handle.\newline \newline @param device_name Name of the device to open.\newline Two different naming schemes are accepted: Full device names\newline (e.g. &#039/dev/video0&#039) and short names (e.g. &#039video0&#039) as\newline returned by c_enum_devices().\newline @return\newline - a device handle greater than zero on success\newline - 0 if an error has occurred\newline \newline","6058327","netmate.c","void show_warning(GtkWidget *widget, gpointer message) {\newline  GtkWidget *toplevel;	/* the toplevel window */\newline  GtkWidget *dialog;	/* the dialog object */\newline\newline  /* get toplevel from widget */\newline  toplevel = gtk_widget_get_toplevel(widget);\newline\newline  /* show window only if toplevel */\newline  if (gtk_widget_is_toplevel(toplevel)) {\newline\newline    /* create new dialog */\newline    dialog = gtk_message_dialog_new(GTK_WINDOW(toplevel), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK, &quot%s&quot, (char*)message);\newline\newline    /* set title */\newline    gtk_window_set_title(GTK_WINDOW(dialog), &quotWarning&quot);\newline\newline    /* run dialog */\newline    gtk_dialog_run(GTK_DIALOG(dialog));\newline\newline    /* destroy dialog */\newline    gtk_widget_destroy(dialog);\newline  }\newline}\newline","shows a warning popup with given (char ) as message \newline","2531900","parse_cmdline.c","static void apply_option(options_t *opts, parsed_option_t* option)\newline{\newline	cmdline_opt_t* o = option-&gto;\newline	unsigned short option_type = o-&gttype;\newline	char* value = NULL;\newline\newline	/* check if option requires a parameter */\newline	if (is_param_required(option_type)) {\newline		if (!option-&gtparameter) {\newline			log_error(_(&quotargument is required for option %s\\n&quot), option-&gtname);\newline			rsh_exit(2);\newline		}\newline\newline#ifdef _WIN32\newline		if (option_type == F_TOUT) {\newline			/* leave the value in UTF-16 */\newline			value = (char*)rsh_wcsdup((wchar_t*)option-&gtparameter);\newline		}\newline		else if (option_type == F_UFNC) {\newline			/* convert from UTF-16 to UTF-8 */\newline			value = wchar_to_cstr((wchar_t*)option-&gtparameter, CP_UTF8, NULL);\newline		} else {\newline			/* convert from UTF-16 */\newline			value = w2c((wchar_t*)option-&gtparameter);\newline		}\newline		rsh_vector_add_ptr(opt.mem, value);\newline#else\newline		value = (char*)option-&gtparameter;\newline#endif\newline	}\newline\newline	/* process option, choosing the method by type */\newline	switch (option_type) {\newline	case F_UFLG:\newline	case F_UENC:\newline		*(unsigned*)((char*)opts + ((char*)o-&gtptr - (char*)&ampopt)) |= o-&gtparam;\newline		break;\newline	case F_CSTR:\newline	case F_TOUT:\newline		/* save the option parameter */\newline		*(char**)((char*)opts + ((char*)o-&gtptr - (char*)&ampopt)) = value;\newline		break;\newline	case F_PFNC:\newline	case F_UFNC:\newline		/* call option parameter handler */\newline		( ( void(*)(options_t *, char*, unsigned) )o-&gtptr )(opts, value, o-&gtparam);\newline		break;\newline	case F_VFNC:\newline		( ( void(*)(options_t *) )o-&gtptr )(opts); /* call option handler */\newline		break;\newline	case F_PRNT:\newline		log_msg(&quot%s&quot, (char*)o-&gtptr);\newline		rsh_exit(0);\newline		break;\newline	default:\newline		assert(0); /* impossible option type */\newline	}\newline}\newline","\newline Process given command line option\newline \newline @param opts the structure to store results of option processing\newline @param option option to process\newline \newline","2626909","msgcookie.c","aim_msgcookie_t *aim_mkcookie(guint8 *c, int type, void *data)\newline{\newline	aim_msgcookie_t *cookie;\newline\newline	if (!c) {\newline		return NULL;\newline	}\newline\newline	if (!(cookie = g_new0(aim_msgcookie_t, 1))) {\newline		return NULL;\newline	}\newline\newline	cookie-&gtdata = data;\newline	cookie-&gttype = type;\newline	memcpy(cookie-&gtcookie, c, 8);\newline\newline	return cookie;\newline}\newline","\newline aim_mkcookie - generate an aim_msgcookie_t struct from a cookie string, a type, and a data pointer.\newline @c: pointer to the cookie string array\newline @type: cookie type to use\newline @data: data to be cached with the cookie\newline \newline returns NULL on error, a pointer to the newly-allocated cookie on\newline success.\newline \newline \newline","5084437","auth.c","void serf__encode_auth_header(const char **header,\newline                              const char *scheme,\newline                              const char *data, apr_size_t data_len,\newline                              apr_pool_t *pool)\newline{\newline    apr_size_t encoded_len, scheme_len;\newline    char *ptr;\newline\newline    encoded_len = apr_base64_encode_len(data_len);\newline    scheme_len = strlen(scheme);\newline\newline    ptr = apr_palloc(pool, encoded_len + scheme_len + 1);\newline    *header = ptr;\newline\newline    apr_cpystrn(ptr, scheme, scheme_len + 1);\newline    ptr += scheme_len;\newline    *ptr++ = &#039 &#039;\newline\newline    apr_base64_encode(ptr, data, data_len);\newline}\newline","\newline base64 encode the authentication data and build an authentication\newline header in this format:\newline [SCHEME] [BASE64 of auth DATA]\newline \newline","2747194","gtp.c","int gtp_echo_ind(struct gsn_t *gsn, int version, struct sockaddr_in *peer,\newline		 int fd, void *pack, unsigned len)\newline{\newline\newline	/* Check if it was a dublicate request */\newline	if (!gtp_dublicate(gsn, 0, peer, get_seq(pack)))\newline		return 0;\newline\newline	/* Send off reply to request */\newline	return gtp_echo_resp(gsn, version, peer, fd, pack, len);\newline}\newline","Handle a received echo request \newline","4500487","command.c","static int show_setting_help( World *wld, char *key )\newline{\newline	char *shortdesc, *longdesc;\newline\newline	if( world_desc_key( wld, key, &ampshortdesc, &amplongdesc ) != GET_KEY_OK )\newline		return 0;\newline\newline	world_msg_client( wld, &quot&quot );\newline	world_msg_client( wld, &quot%s&quot, key );\newline	world_msg_client( wld, &quot&quot );\newline\newline	if( longdesc )\newline		show_longdesc( wld, longdesc );\newline	else\newline		show_longdesc( wld, shortdesc );\newline\newline	return 1;\newline}\newline","Displays the help for one setting.\newline Returns 1 if it was able to show the help for key, 0 otherwise. \newline","2234403","curve_tools.c","float *catmull_rom_set(int n, float x[], float y[])\newline{\newline  float *m;\newline  int i;\newline  if(n &lt= 1)\newline  {\newline    // nc_message(NC_SET_ERROR, &quotspline_cubic_set() error: &quot\newline    //   &quotThe number of data points must be at least 2.\\n&quot);\newline    return NULL;\newline  }\newline\newline  for(i = 0; i &lt n - 1; i++)\newline  {\newline    if(x[i + 1] &lt= x[i])\newline    {\newline      // nc_message(NC_SET_ERROR, &quotspline_cubic_set() error: &quot\newline      //   &quotThe knots must be strictly increasing, but &quot\newline      //  &quotT(%u) = %e, T(%u) = %e\\n&quot,i,x[i],i+1,x[i+1]);\newline      return NULL;\newline    }\newline  }\newline  // nc_merror(delta, &quotspline_cubic_set&quot);\newline  m = (float *)calloc(n, sizeof(float));\newline  // nc_merror(m, &quotspline_cubic_set&quot);\newline\newline  // calculate the slopes\newline  m[0] = (y[1] - y[0]) / (x[1] - x[0]);\newline  for(i = 1; i &lt n - 1; i++)\newline  {\newline    m[i] = (y[i + 1] - y[i - 1]) / (x[i + 1] - x[i - 1]);\newline  }\newline  m[n - 1] = (y[n - 1] - y[n - 2]) / (x[n - 1] - x[n - 2]);\newline\newline  return m;\newline}\newline","\newline catmull_rom_set:\newline calculates the tangents for a catmull_rom spline\newline see http://en.wikipedia.org/wiki/Cubic_Hermite_spline\newline \newline \newline input:\newline n = number of control points\newline x = input x array\newline y = input y array\newline output:\newline pointer to array containing the tangents\newline \newline","4854656","db.c","void db_end_module(\newline  int end_line  /*!&lt Ending line number of specified module in file */\newline) { PROFILE(DB_END_MODULE);\newline\newline#ifdef DEBUG_MODE\newline  if( debug_mode ) {\newline    unsigned int rv = snprintf( user_msg, USER_MSG_LENGTH, &quotIn db_end_module, end_line: %d&quot, end_line );\newline    assert( rv &lt USER_MSG_LENGTH );\newline    print_output( user_msg, DEBUG, __FILE__, __LINE__ );\newline  }\newline#endif\newline\newline  curr_funit-&gtend_line = end_line;\newline\newline  str_link_remove( curr_funit-&gtname, &ampmodlist_head, &ampmodlist_tail );\newline\newline  /* Return the current functional unit to the global functional unit, if it exists */\newline  curr_funit = global_funit;\newline\newline  PROFILE_END;\newline\newline}\newline","!\newlineUpdates the modlist for parsing purposes.\newline \newline","5796841","midi-server.cpp","void MIDI_SERVER::add_mmc_send_id(int id)\newline{\newline  mmc_send_ids_rep.push_back(id);\newline}\newline","\newline Adds a new client to which MMC-messages are sent\newline during processing. \newline \newline Note! Id &#039127&#039 is specified as the all-device \newline id-number in the MMC-spec.\newline \newline","6079086","key_handling.c","int install_remote_key(gchar *user, gchar *host, gchar *port, gchar *password, struct w *widgets)\newline{\newline    FILE *fp;\newline    char **new_argv;\newline    gchar *key_name_priv, *key_name_pub, *key_path_pub, *key_path_priv;\newline    gchar *script, *script_name, *script_path, *info;\newline    int retval = 0;\newline\newline    key_name_priv = mk_key_name(user, host, &quotpriv&quot);\newline    key_name_pub  = mk_key_name(user, host, &quotpub&quot);\newline    \newline    key_path_priv = g_strdup_printf(&quot%s/%s&quot, global_key_path, key_name_priv);\newline    key_path_pub  = g_strdup_printf(&quot%s/%s&quot, global_key_path, key_name_pub);\newline\newline    if( ! file_exists(key_path_priv) )\newline    {\newline	info = g_strdup_printf(_(&quotError: The local private key does not exist.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline	printf(&quotError: The local private key doesnt exist: %s\\n&quot, key_path_priv);\newline\newline	g_free(key_name_priv);\newline	g_free(key_name_pub);\newline	g_free(key_path_priv);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline\newline    g_free(key_name_priv);\newline    g_free(key_path_priv);\newline\newline\newline    if( ! file_exists(key_path_pub) )\newline    {\newline	info = g_strdup_printf(_(&quotError: The local public key does not exist.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline	printf(&quotError: The local public key doesnt exist: %s\\n&quot, key_path_pub);\newline\newline	g_free(key_name_pub);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline\newline\newline    /* Make the key install script */\newline    script_name = g_strdup_printf(&quotgadmin-rsync-ssh.sh&quot);\newline\newline    script = g_strconcat(&quot#!/bin/bash\\n&quot,\newline    &quot### Gadmin-rsync ssh key installer ###\\n\\n&quot,\newline    &quotif [ ! -e .ssh ]; then\\n&quot,\newline    &quot   mkdir .ssh &amp&amp chmod 700 .ssh\\n&quot\newline    &quotfi\\n\\n&quot,\newline\newline    &quotcd .ssh || exit 1\\n\\n&quot,\newline	\newline    &quotif [ ! -f authorized_keys ]; then\\n&quot,\newline    &quot   touch authorized_keys &amp&amp chmod 600 authorized_keys\\n&quot\newline    &quotfi\\n\\n&quot\newline		\newline    &quotcat ../&quot, key_name_pub, &quot &gt&gt authorized_keys\\n&quot,\newline    \newline    &quotrm -f ../&quot, key_name_pub, &quot\\n&quot,\newline    &quotrm -f ../&quot, script_name, &quot\\n&quot,\newline    NULL);\newline\newline    g_free(key_name_pub);\newline\newline\newline    /* Write the pub key install script */\newline    script_path = g_strdup_printf(&quot%s/%s&quot, global_home_dir, script_name);\newline\newline    if((fp=fopen(script_path, &quotw+&quot))==NULL)\newline    {\newline	printf(&quotError writing install script file here: %s\\n&quot, script_path);\newline\newline	g_free(script);\newline	g_free(script_name);\newline	g_free(script_path);\newline	g_free(key_path_pub);\newline\newline	return retval;\newline    }\newline    fputs(script, fp);\newline    fclose(fp);    \newline\newline    g_free(script);\newline\newline\newline    /* Upload public key and key install script to the remote server */\newline    gchar *user_host_dir = g_strdup_printf(&quot%s@%s:~&quot, user, host);\newline\newline    new_argv = create_scp_upload_cmd(user, port, key_path_pub, script_path, user_host_dir);\newline\newline    if( ! run_ssh_cmd(new_argv, password) )\newline    {\newline	printf(&quotError uploading key.\\n&quot);\newline	g_free(script_path);\newline	g_free(key_path_pub);\newline	g_free(user_host_dir);\newline	g_free(script_name);\newline	free(new_argv);\newline\newline	return retval;\newline    }\newline\newline    free(new_argv);\newline    g_free(user_host_dir);\newline\newline\newline    /* Create the key install command */\newline    gchar *ssh_cmd = g_strdup_printf(&quotchmod 755 ~/%s &amp&amp sh ~/%s &amp&amp rm -f ~/%s&quot, script_name, script_name, script_name);\newline    \newline    new_argv = create_ssh_cmd(user, host, port, ssh_cmd);\newline\newline    if( ! run_ssh_cmd(new_argv, password) )\newline    {\newline	info = g_strdup_printf(_(&quotError: Could not install the public key on the remote host.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline        printf(&quotError installing key on the remote host.\\n&quot);\newline        \newline	g_free(script_path);\newline	g_free(key_path_pub);\newline	g_free(script_name);\newline	g_free(ssh_cmd);\newline	free(new_argv);\newline\newline	return retval;\newline    }\newline    else\newline    {\newline	/* This info is good. Will be shown in the progress bar later */\newline	info = g_strdup_printf(_(&quotPublic key installation on remote host successful.\\n&quot));	\newline	show_info(info);\newline	if( info!=NULL )\newline	  g_free(info);\newline\newline        printf(&quotKey installation successful.\\n&quot);\newline\newline	retval = 1;\newline    }\newline\newline    free(new_argv);\newline\newline    g_free(ssh_cmd);\newline    g_free(script_name);\newline\newline    /* Remove the local script */\newline    unlink(script_path);\newline    g_free(script_path);\newline\newline    g_free(key_path_pub);\newline\newline\newline    return retval;\newline}\newline","Upload public key to remote host and append it to file: ~/.ssh/authorized_keys \newline","2178210","psi.c","static uint32_t psi_ccrc(struct psisec_s *section) {\newline	return crc32_be(0xffffffff, section-&gtdata, psi_len(section)-4);\newline}\newline","Calculate the CRC of the section \newline","2296341","fuser.c","void fill_unix_cache(struct unixsocket_list **unixsocket_head)\newline{\newline	FILE *fp;\newline	char line[BUFSIZ];\newline	int scanned_inode;\newline	struct stat st;\newline	struct unixsocket_list *newsocket;\newline\newline	if ((fp = fopen(&quot/proc/net/unix&quot, &quotr&quot)) == NULL) {\newline		fprintf(stderr, _(&quotCannot open /proc/net/unix: %s\\n&quot),\newline			strerror(errno));\newline		return;\newline	}\newline	while (fgets(line, BUFSIZ, fp) != NULL) {\newline		char *path;\newline		char *scanned_path = NULL;\newline		if (sscanf(line, &quot%*x: %*x %*x %*x %*x %*d %d %ms&quot,\newline			   &ampscanned_inode, &ampscanned_path) != 2) {\newline			if (scanned_path)\newline				free(scanned_path);\newline			continue;\newline		}\newline		if (scanned_path == NULL)\newline			continue;\newline		path = scanned_path;\newline		if (*scanned_path == &#039@&#039)\newline			scanned_path++;\newline		if (timeout(thestat, scanned_path, &ampst, 5) &lt 0) {\newline			free(path);\newline			continue;\newline		}\newline		if ((newsocket = (struct unixsocket_list *)\newline		     malloc(sizeof(struct unixsocket_list))) == NULL) {\newline			free(path);\newline			continue;\newline		}\newline		newsocket-&gtsun_name = strdup(scanned_path);\newline		newsocket-&gtinode = st.st_ino;\newline		newsocket-&gtdev = st.st_dev;\newline		newsocket-&gtnet_inode = scanned_inode;\newline		newsocket-&gtnext = *unixsocket_head;\newline		*unixsocket_head = newsocket;\newline		free(path);\newline	}			/* while */\newline\newline	fclose(fp);\newline}\newline","\newline fill_unix_cache : Create a list of Unix sockets\newline This list is used later for matching purposes\newline \newline","1259483","tidy.c","int main( int argc, char** argv )\newline{\newline    ctmbstr prog = argv[0];\newline    ctmbstr cfgfil = NULL, errfil = NULL, htmlfil = NULL;\newline    TidyDoc tdoc = tidyCreate();\newline    int status = 0;\newline    tmbstr locale = NULL;\newline\newline    uint contentErrors = 0;\newline    uint contentWarnings = 0;\newline    uint accessWarnings = 0;\newline\newline    errout = stderr;  /* initialize to stderr */\newline\newline    /* Set an atexit handler. */\newline    atexit( tidy_cleanup );\newline    \newline    /* Set the locale for tidy&#039s output. */\newline    locale = tidySystemLocale(locale);\newline    tidySetLanguage(locale);\newline    if ( locale )\newline        free( locale );\newline\newline#if defined(_WIN32)\newline    /* Force Windows console to use UTF, otherwise many characters will\newline     * be garbage. Note that East Asian languages *are* supported, but\newline     * only when Windows OS locale (not console only!) is set to an\newline     * East Asian language.\newline     */\newline    win_cp = GetConsoleOutputCP();\newline    SetConsoleOutputCP(CP_UTF8);\newline#endif\newline\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline    set_log_file((char *)&quottemptidy.txt&quot, 0);\newline    // add_append_log(1);\newline#endif\newline\newline    /*\newline     * Look for default configuration files using any of\newline     * the following possibilities:\newline     *  - TIDY_CONFIG_FILE - from tidyplatform.h, typically /etc/tidy.conf\newline     *  - HTML_TIDY        - environment variable\newline     *  - TIDY_USER_CONFIG_FILE - from tidyplatform.h, typically ~/tidy.conf\newline     */\newline\newline#ifdef TIDY_CONFIG_FILE\newline    if ( tidyFileExists( tdoc, TIDY_CONFIG_FILE) )\newline    {\newline        status = tidyLoadConfig( tdoc, TIDY_CONFIG_FILE );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), TIDY_CONFIG_FILE, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#endif /* TIDY_CONFIG_FILE */\newline\newline    if ( (cfgfil = getenv(&quotHTML_TIDY&quot)) != NULL )\newline    {\newline        status = tidyLoadConfig( tdoc, cfgfil );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), cfgfil, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#ifdef TIDY_USER_CONFIG_FILE\newline    else if ( tidyFileExists( tdoc, TIDY_USER_CONFIG_FILE) )\newline    {\newline        status = tidyLoadConfig( tdoc, TIDY_USER_CONFIG_FILE );\newline        if ( status != 0 ) {\newline            fprintf(errout, tidyLocalizedString( TC_MAIN_ERROR_LOAD_CONFIG ), TIDY_USER_CONFIG_FILE, status);\newline            fprintf(errout, &quot\\n&quot);\newline        }\newline    }\newline#endif /* TIDY_USER_CONFIG_FILE */\newline\newline\newline    /*\newline     * Read command line\newline     */\newline\newline    while ( argc &gt 0 )\newline    {\newline        if (argc &gt 1 &amp&amp argv[1][0] == &#039-&#039)\newline        {\newline            /* support -foo and --foo */\newline            ctmbstr arg = argv[1] + 1;\newline\newline            if ( strcasecmp(arg, &quotxml&quot) == 0)\newline                tidyOptSetBool( tdoc, TidyXmlTags, yes );\newline\newline            else if ( strcasecmp(arg,   &quotasxml&quot) == 0 ||\newline                     strcasecmp(arg, &quotasxhtml&quot) == 0 )\newline            {\newline                tidyOptSetBool( tdoc, TidyXhtmlOut, yes );\newline            }\newline            else if ( strcasecmp(arg,   &quotashtml&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyHtmlOut, yes );\newline\newline            else if ( strcasecmp(arg, &quotindent&quot) == 0 )\newline            {\newline                tidyOptSetInt( tdoc, TidyIndentContent, TidyAutoState );\newline                if ( tidyOptGetInt(tdoc, TidyIndentSpaces) == 0 )\newline                    tidyOptResetToDefault( tdoc, TidyIndentSpaces );\newline            }\newline            else if ( strcasecmp(arg, &quotomit&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyOmitOptionalTags, yes );\newline\newline            else if ( strcasecmp(arg, &quotupper&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyUpperCaseTags, yes );\newline\newline            else if ( strcasecmp(arg, &quotclean&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyMakeClean, yes );\newline\newline            else if ( strcasecmp(arg, &quotgdoc&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyGDocClean, yes );\newline\newline            else if ( strcasecmp(arg, &quotbare&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyMakeBare, yes );\newline\newline            else if ( strcasecmp(arg, &quotraw&quot) == 0     ||\newline                     strcasecmp(arg, &quotascii&quot) == 0    ||\newline                     strcasecmp(arg, &quotlatin0&quot) == 0   ||\newline                     strcasecmp(arg, &quotlatin1&quot) == 0   ||\newline                     strcasecmp(arg, &quotutf8&quot) == 0     ||\newline#ifndef NO_NATIVE_ISO2022_SUPPORT\newline                     strcasecmp(arg, &quotiso2022&quot) == 0  ||\newline#endif\newline#if SUPPORT_UTF16_ENCODINGS\newline                     strcasecmp(arg, &quotutf16le&quot) == 0  ||\newline                     strcasecmp(arg, &quotutf16be&quot) == 0  ||\newline                     strcasecmp(arg, &quotutf16&quot) == 0    ||\newline#endif\newline#if SUPPORT_ASIAN_ENCODINGS\newline                     strcasecmp(arg, &quotshiftjis&quot) == 0 ||\newline                     strcasecmp(arg, &quotbig5&quot) == 0     ||\newline#endif\newline                     strcasecmp(arg, &quotmac&quot) == 0      ||\newline                     strcasecmp(arg, &quotwin1252&quot) == 0  ||\newline                     strcasecmp(arg, &quotibm858&quot) == 0 )\newline            {\newline                tidySetCharEncoding( tdoc, arg );\newline            }\newline            else if ( strcasecmp(arg, &quotnumeric&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyNumEntities, yes );\newline\newline            else if ( strcasecmp(arg, &quotmodify&quot) == 0 ||\newline                     strcasecmp(arg, &quotchange&quot) == 0 ||  /* obsolete */\newline                     strcasecmp(arg, &quotupdate&quot) == 0 )   /* obsolete */\newline            {\newline                tidyOptSetBool( tdoc, TidyWriteBack, yes );\newline            }\newline            else if ( strcasecmp(arg, &quoterrors&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyShowMarkup, no );\newline\newline            else if ( strcasecmp(arg, &quotquiet&quot) == 0 )\newline                tidyOptSetBool( tdoc, TidyQuiet, yes );\newline\newline            /* Currenly user must specify a language\newline             prior to anything that causes output */\newline            else if ( strcasecmp(arg, &quotlanguage&quot) == 0 ||\newline                     strcasecmp(arg,     &quotlang&quot) == 0 )\newline                if ( argc &gt= 3)\newline                {\newline                    if ( strcasecmp(argv[2], &quothelp&quot) == 0 )\newline                    {\newline                        lang_help();\newline                        exit(0);\newline                    }\newline                    if ( !tidySetLanguage( argv[2] ) )\newline                    {\newline                        printf(tidyLocalizedString(TC_STRING_LANG_NOT_FOUND),\newline                               argv[2], tidyGetLanguage());\newline                        printf(&quot\\n&quot);\newline                    }\newline                    --argc;\newline                    ++argv;\newline                }\newline                else\newline                {\newline                    printf( &quot%s\\n&quot, tidyLocalizedString(TC_STRING_LANG_MUST_SPECIFY));\newline                }\newline\newline                else if ( strcasecmp(arg, &quothelp&quot) == 0 ||\newline                         strcasecmp(arg, &quot-help&quot) == 0 ||\newline                         strcasecmp(arg,    &quoth&quot) == 0 || *arg == &#039?&#039 )\newline                {\newline                    help( prog );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-help&quot) == 0)\newline                {\newline                    xml_help( );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-error-strings&quot) == 0)\newline                {\newline                    xml_error_strings( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-options-strings&quot) == 0)\newline                {\newline                    xml_options_strings( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-strings&quot) == 0)\newline                {\newline                    xml_strings( );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quothelp-config&quot) == 0 )\newline                {\newline                    optionhelp( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quothelp-option&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3)\newline                    {\newline                        optionDescribe( tdoc, argv[2] );\newline                    }\newline                    else\newline                    {\newline                        printf( &quot%s\\n&quot, tidyLocalizedString(TC_STRING_MUST_SPECIFY));\newline                    }\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotxml-config&quot) == 0 )\newline                {\newline                    XMLoptionhelp( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotshow-config&quot) == 0 )\newline                {\newline                    optionvalues( tdoc );\newline                    tidyRelease( tdoc );\newline                    return 0; /* success */\newline                }\newline                else if ( strcasecmp(arg, &quotconfig&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        ctmbstr post;\newline\newline                        tidyLoadConfig( tdoc, argv[2] );\newline\newline                        /* Set new error output stream if setting changed */\newline                        post = tidyOptGetValue( tdoc, TidyErrFile );\newline                        if ( post &amp&amp (!errfil || !samefile(errfil, post)) )\newline                        {\newline                            errfil = post;\newline                            errout = tidySetErrorFile( tdoc, post );\newline                        }\newline\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline\newline                else if ( strcasecmp(arg, &quotoutput&quot) == 0 ||\newline                         strcasecmp(arg, &quot-output-file&quot) == 0 ||\newline                         strcasecmp(arg, &quoto&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        tidyOptSetValue( tdoc, TidyOutFile, argv[2] );\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotfile&quot) == 0 ||\newline                         strcasecmp(arg, &quot-file&quot) == 0 ||\newline                         strcasecmp(arg,     &quotf&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        errfil = argv[2];\newline                        errout = tidySetErrorFile( tdoc, errfil );\newline                        --argc;\newline                        ++argv;\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotwrap&quot) == 0 ||\newline                         strcasecmp(arg, &quot-wrap&quot) == 0 ||\newline                         strcasecmp(arg,     &quotw&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        uint wraplen = 0;\newline                        int nfields = sscanf( argv[2], &quot%u&quot, &ampwraplen );\newline                        tidyOptSetInt( tdoc, TidyWrapLen, wraplen );\newline                        if (nfields &gt 0)\newline                        {\newline                            --argc;\newline                            ++argv;\newline                        }\newline                    }\newline                }\newline                else if ( strcasecmp(arg,  &quotversion&quot) == 0 ||\newline                         strcasecmp(arg, &quot-version&quot) == 0 ||\newline                         strcasecmp(arg,        &quotv&quot) == 0 )\newline                {\newline                    version();\newline                    tidyRelease( tdoc );\newline                    return 0;  /* success */\newline\newline                }\newline                else if ( strncmp(argv[1], &quot--&quot, 2 ) == 0)\newline                {\newline                    if ( tidyOptParseValue(tdoc, argv[1]+2, argv[2]) )\newline                    {\newline                        /* Set new error output stream if setting changed */\newline                        ctmbstr post = tidyOptGetValue( tdoc, TidyErrFile );\newline                        if ( post &amp&amp (!errfil || !samefile(errfil, post)) )\newline                        {\newline                            errfil = post;\newline                            errout = tidySetErrorFile( tdoc, post );\newline                        }\newline\newline                        ++argv;\newline                        --argc;\newline                    }\newline                }\newline\newline#if SUPPORT_ACCESSIBILITY_CHECKS\newline                else if ( strcasecmp(arg, &quotaccess&quot) == 0 )\newline                {\newline                    if ( argc &gt= 3 )\newline                    {\newline                        uint acclvl = 0;\newline                        int nfields = sscanf( argv[2], &quot%u&quot, &ampacclvl );\newline                        tidyOptSetInt( tdoc, TidyAccessibilityCheckLevel, acclvl );\newline                        if (nfields &gt 0)\newline                        {\newline                            --argc;\newline                            ++argv;\newline                        }\newline                    }\newline                }\newline#endif\newline\newline                else\newline                {\newline                    uint c;\newline                    ctmbstr s = argv[1];\newline\newline                    while ( (c = *++s) != &#039\\0&#039 )\newline                    {\newline                        switch ( c )\newline                        {\newline                            case &#039i&#039:\newline                                tidyOptSetInt( tdoc, TidyIndentContent, TidyAutoState );\newline                                if ( tidyOptGetInt(tdoc, TidyIndentSpaces) == 0 )\newline                                    tidyOptResetToDefault( tdoc, TidyIndentSpaces );\newline                                break;\newline\newline                                /* Usurp -o for output file.  Anyone hiding end tags?\newline                                 case &#039o&#039:\newline                                 tidyOptSetBool( tdoc, TidyHideEndTags, yes );\newline                                 break;\newline                                 */\newline\newline                            case &#039u&#039:\newline                                tidyOptSetBool( tdoc, TidyUpperCaseTags, yes );\newline                                break;\newline\newline                            case &#039c&#039:\newline                                tidyOptSetBool( tdoc, TidyMakeClean, yes );\newline                                break;\newline\newline                            case &#039g&#039:\newline                                tidyOptSetBool( tdoc, TidyGDocClean, yes );\newline                                break;\newline\newline                            case &#039b&#039:\newline                                tidyOptSetBool( tdoc, TidyMakeBare, yes );\newline                                break;\newline\newline                            case &#039n&#039:\newline                                tidyOptSetBool( tdoc, TidyNumEntities, yes );\newline                                break;\newline\newline                            case &#039m&#039:\newline                                tidyOptSetBool( tdoc, TidyWriteBack, yes );\newline                                break;\newline\newline                            case &#039e&#039:\newline                                tidyOptSetBool( tdoc, TidyShowMarkup, no );\newline                                break;\newline\newline                            case &#039q&#039:\newline                                tidyOptSetBool( tdoc, TidyQuiet, yes );\newline                                break;\newline\newline                            default:\newline                                unknownOption( c );\newline                                break;\newline                        }\newline                    }\newline                }\newline\newline            --argc;\newline            ++argv;\newline            continue;\newline        }\newline\newline        if ( argc &gt 1 )\newline        {\newline            htmlfil = argv[1];\newline#if (!defined(NDEBUG) &amp&amp defined(_MSC_VER))\newline            SPRTF(&quotTidying &#039%s&#039\\n&quot, htmlfil);\newline#endif // DEBUG outout\newline            if ( tidyOptGetBool(tdoc, TidyEmacs) )\newline                tidyOptSetValue( tdoc, TidyEmacsFile, htmlfil );\newline            status = tidyParseFile( tdoc, htmlfil );\newline        }\newline        else\newline        {\newline            htmlfil = &quotstdin&quot;\newline            status = tidyParseStdin( tdoc );\newline        }\newline\newline        if ( status &gt= 0 )\newline            status = tidyCleanAndRepair( tdoc );\newline\newline        if ( status &gt= 0 ) {\newline            status = tidyRunDiagnostics( tdoc );\newline            if ( !tidyOptGetBool(tdoc, TidyQuiet) ) {\newline                /* NOT quiet, show DOCTYPE, if not already shown */\newline                if (!tidyOptGetBool(tdoc, TidyShowInfo)) {\newline                    tidyOptSetBool( tdoc, TidyShowInfo, yes );\newline                    tidyReportDoctype( tdoc );  /* FIX20140913: like warnings, errors, ALWAYS report DOCTYPE */\newline                    tidyOptSetBool( tdoc, TidyShowInfo, no );\newline                }\newline            }\newline\newline        }\newline        if ( status &gt 1 ) /* If errors, do we want to force output? */\newline            status = ( tidyOptGetBool(tdoc, TidyForceOutput) ? status : -1 );\newline\newline        if ( status &gt= 0 &amp&amp tidyOptGetBool(tdoc, TidyShowMarkup) )\newline        {\newline            if ( tidyOptGetBool(tdoc, TidyWriteBack) &amp&amp argc &gt 1 )\newline                status = tidySaveFile( tdoc, htmlfil );\newline            else\newline            {\newline                ctmbstr outfil = tidyOptGetValue( tdoc, TidyOutFile );\newline                if ( outfil ) {\newline                    status = tidySaveFile( tdoc, outfil );\newline                } else {\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER)\newline                    static char tmp_buf[264];\newline                    sprintf(tmp_buf,&quot%s.html&quot,get_log_file());\newline                    status = tidySaveFile( tdoc, tmp_buf );\newline                    SPRTF(&quotSaved tidied content to &#039%s&#039\\n&quot,tmp_buf);\newline#else\newline                    status = tidySaveStdout( tdoc );\newline#endif\newline                }\newline            }\newline        }\newline        \newline        contentErrors   += tidyErrorCount( tdoc );\newline        contentWarnings += tidyWarningCount( tdoc );\newline        accessWarnings  += tidyAccessWarningCount( tdoc );\newline        \newline        --argc;\newline        ++argv;\newline        \newline        if ( argc &lt= 1 )\newline            break;\newline    } /* read command line loop */\newline    \newline    \newline    if (!tidyOptGetBool(tdoc, TidyQuiet) &amp&amp\newline        errout == stderr &amp&amp !contentErrors)\newline        fprintf(errout, &quot\\n&quot);\newline    \newline    if (contentErrors + contentWarnings &gt 0 &amp&amp\newline        !tidyOptGetBool(tdoc, TidyQuiet))\newline        tidyErrorSummary(tdoc);\newline    \newline    if (!tidyOptGetBool(tdoc, TidyQuiet))\newline        tidyGeneralInfo(tdoc);\newline    \newline    /* called to free hash tables etc. */\newline    tidyRelease( tdoc );\newline    \newline    /* return status can be used by scripts */\newline    if ( contentErrors &gt 0 )\newline        return 2;\newline    \newline    if ( contentWarnings &gt 0 )\newline        return 1;\newline    \newline    /* 0 signifies all is ok */\newline    return 0;\newline}\newline","\newline MAIN -- let&#039s do something here.\newline \newline","1057554","tlslib.h","inline static void packet_deinit(void *p)\newline{\newline#ifdef ZERO_COPY\newline	gnutls_packet_t packet = p;\newline 	if (packet)\newline	 	gnutls_packet_deinit(packet);\newline#endif\newline}\newline","packet API \newline","5144069","conversions.c","void nmea_GPGSV2info(const nmeaGPGSV *pack, nmeaINFO *info) {\newline	int pack_index;\newline\newline	assert(pack);\newline	assert(info);\newline\newline	pack_index = pack-&gtpack_index;\newline	if (pack_index &lt 1)\newline		pack_index = 1;\newline\newline	if (pack_index &gt pack-&gtpack_count)\newline		pack_index = pack-&gtpack_count;\newline\newline	if ((pack_index * NMEA_SATINPACK) &gt NMEA_MAXSAT)\newline		pack_index = NMEA_NSATPACKS;\newline\newline	info-&gtpresent |= pack-&gtpresent;\newline	nmea_INFO_set_present(&ampinfo-&gtpresent, SMASK);\newline	info-&gtsmask |= GPGSV;\newline	if (nmea_INFO_is_present(pack-&gtpresent, SATINVIEW)) {\newline		int sat_index;\newline\newline		/* index of 1st sat in pack */\newline		int sat_offset = (pack_index - 1) * NMEA_SATINPACK;\newline		/* the number of sats in this sentence */\newline		int sat_count = ((sat_offset + NMEA_SATINPACK) &gt pack-&gtsat_count) ? (pack-&gtsat_count - sat_offset) : NMEA_SATINPACK;\newline\newline		for (sat_index = 0; sat_index &lt sat_count; sat_index++) {\newline			info-&gtsatinfo.sat[sat_offset + sat_index].id = pack-&gtsat_data[sat_index].id;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].elv = pack-&gtsat_data[sat_index].elv;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].azimuth = pack-&gtsat_data[sat_index].azimuth;\newline			info-&gtsatinfo.sat[sat_offset + sat_index].sig = pack-&gtsat_data[sat_index].sig;\newline		}\newline\newline		info-&gtsatinfo.inview = pack-&gtsat_count;\newline	}\newline}\newline","\newline Fill nmeaINFO structure from GSV packet structure\newline \newline @param pack a pointer to the packet structure\newline @param info a pointer to the nmeaINFO structure\newline \newline","4312547","inet6.c","static const char *INET6_print(const char *ptr)\newline{\newline    static char name[INET6_ADDRSTRLEN + 1];\newline    socklen_t len = sizeof(name) - 1;\newline    name[len] = &#039\\0&#039;\newline    inet_ntop(AF_INET6, ptr, name, len);\newline    return fix_v4_address(name, (struct in6_addr *)ptr);\newline}\newline","Display an Internet socket address. \newline","3503546","inotifytools.c","char * inotifytools_filename_from_wd( int wd ) {\newline	niceassert( init, &quotinotifytools_initialize not called yet&quot );\newline	watch *w = watch_from_wd(wd);\newline	if (!w)\newline        return NULL;\newline\newline	return w-&gtfilename;\newline}\newline","\newline Get the filename used to establish a watch.\newline \newline inotifytools_initialize() must be called before this function can\newline be used.\newline \newline @param wd watch descriptor.\newline \newline @return filename associated with watch descriptor @a wd, or NULL if @a wd\newline is not associated with any filename.\newline \newline @note This always returns the filename which was used to establish a watch.\newline This means the filename may be a relative path. If this isn&#039t desired,\newline then always use absolute paths when watching files.\newline Also, this is not necessarily the filename which might have been used\newline to cause an event on the file, since inotify is inode based and there\newline can be many filenames mapping to a single inode.\newline Finally, if a file is moved or renamed while being watched, the\newline filename returned will still be the original name.\newline \newline","2152530","scroll.c","int getCDKScrollCurrentTop (CDKSCROLL *widget)\newline{\newline   return widget-&gtcurrentTop;\newline}\newline","\newline Get/Set the top line of the scroller.\newline \newline","5789822","ap_abstract0.c","bool ap_abstract0_check_linexpr_array(ap_funid_t funid, ap_manager_t* man,\newline				      ap_dimension_t dimension,\newline				      ap_linexpr0_t** texpr, size_t size)\newline{\newline  size_t i;\newline\newline  for (i=0;i&ltsize; i++){\newline    if (texpr[i]==NULL){\newline      char str[80];\newline      sprintf(str,&quotnull pointer in the %luth expression of the array&quot,(unsigned long)i);\newline      ap_manager_raise_exception(man,\newline				 AP_EXC_INVALID_ARGUMENT,\newline				 funid,str);\newline      return false;\newline    }\newline    ap_dim_t dim = ap_abstract0_check_linexpr_check(dimension,texpr[i]);\newline    if (dim!=AP_DIM_MAX){\newline      char str[80];\newline      sprintf(str,&quotincompatible dimension in the %luth expression of the array&quot,(unsigned long)i);\newline      ap_abstract0_check_expr_raise(funid,man,dimension,dim,str);\newline      return false;\newline    }\newline  }\newline  return true;\newline}\newline","Check that array of linear expressions makes sense in the given dimensionality \newline","","","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","clear the PPR negotiation flag,","Updates the modlist for parsing purposes.","Adds a new client","Upload public key to remote host and append it to file:","Calculate the CRC of the section","Create a list of Unix sockets","{}","{}","Fill nmeaINFO structure from GSV packet structure","Display an Internet socket address.","Get the filename used to establish a watch.","Opens a camera device.","Get/Set the top line of the scroller.","Check that array of linear expressions makes sense","shows a warning popup with given (char ) as message","Process given command line option","generate an aim_msgcookie_t struct","encode the authentication data and build an authenticationheader","Handle a received echo request","Displays the help for one setting.","calculates the tangents for a catmull_rom spline"
"3MD8CKRQZZN2RQP74JJCS074HNRJRH","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3NLZY2D53PPAXZV0KRBQS86G5EWQLV","AVC62JNYAXA45","Approved","Wed Apr 17 14:13:59 PDT 2019","Wed Apr 17 14:41:35 PDT 2019","Fri Apr 19 14:41:35 PDT 2019","2019-04-19 21:42:21 UTC","","","1656","100% (24/24)","100% (24/24)","100% (24/24)","5891763","memory.c","static DOF *transfer_dofs(MESH *mesh, DOF_ADMIN *new_admin,\newline			  DOF *old_dof, int position,\newline			  int is_coarse_dof, const DOF *periodic_twin)\newline{\newline  /* FUNCNAME(&quottransfer_dofs&quot); */\newline  DOF_ADMIN *admin;\newline  DOF       *new_dof = NULL;\newline  int       i, j, n, n0, ndof = mesh-&gtn_dof[position];\newline\newline  if (ndof &lt= 0) return NULL;\newline\newline  new_dof = AI_get_dof_memory(mesh, position);\newline\newline  for (i = 0; i &lt mesh-&gtn_dof_admin; i++) {\newline    admin = mesh-&gtdof_admin[i];\newline\newline    n  = admin-&gtn_dof[position];\newline    n0 = admin-&gtn0_dof[position];\newline\newline    for (j = 0; j &lt n; j++) {\newline      if (admin == new_admin) {\newline	if ((admin-&gtflags &amp ADM_PERIODIC) &amp&amp periodic_twin) {\newline	  new_dof[n0+j] = periodic_twin[n0+j];\newline	} else if (!is_coarse_dof ||\newline		   (admin-&gtflags &amp ADM_PRESERVE_COARSE_DOFS)) {\newline	  new_dof[n0+j] = get_dof_index(admin);\newline	} else {\newline	  new_dof[n0+j] = -1;\newline	}\newline      } else {\newline	if(old_dof) {\newline	  new_dof[n0+j] = old_dof[n0 + j];\newline	} else {\newline	  new_dof[n0+j] = -1;\newline	}\newline      }\newline    }\newline  }\newline\newline  return new_dof;\newline}\newline","transfer_dofs(mesh, new_admin, old_dof, position,\newline is_coarse_dof, periodic_twin):\newline \newline We allocate and return memory for a new dof pointer in an el-&gtdof[]\newline entry. The field is filled either with new DOF indices for each\newline admin or with -1 to mark it as unused. If &quotperiodic_twin&quot != NULL\newline and (new_admin-&gtflags &amp ADM_PERIODIC), then dof indices will not be\newline allocated but copied over from periodic_twin.\newline \newline","3060164","lex.c","static void dqEscape(char* buf, int len, int index, struct Parser* p,\newline                     char* cOut, int* eatenOut)\newline{\newline    if(len &lt 2) error(p, &quotunterminated string&quot, index);\newline    *eatenOut = 2;\newline    switch(buf[1]) {\newline    case &#039&quot&#039: *cOut = &#039&quot&#039; break;\newline    case &#039r&#039: *cOut = &#039\\r&#039; break;\newline    case &#039n&#039: *cOut = &#039\\n&#039; break;\newline    case &#039t&#039: *cOut = &#039\\t&#039; break;\newline    case &#039\\\\&#039: *cOut = &#039\\\\&#039; break;\newline    case &#039`&#039: *cOut = &#039`&#039; break;\newline    case &#039x&#039:\newline        if(len &lt 4) error(p, &quotunterminated string&quot, index);\newline        *cOut = (char)((hexc(buf[2], p, index)&lt&lt4) | hexc(buf[3], p, index));\newline        *eatenOut = 4;\newline        break;\newline    default:\newline        // Unhandled, put the backslash back\newline        *cOut = &#039\\\\&#039;\newline        *eatenOut = 1;\newline    }\newline}\newline","FIXME: need to handle \\b (8), \\f (12), and \\uXXXX for JSON compliance \newline","2102804","ctkdisplaydevice.c","static void update_device_info(CtkDisplayDevice *ctk_object)\newline{\newline    int i;\newline    int max_width;\newline    GtkRequisition req;\newline\newline\newline    max_width = 0;\newline    for (i = 0; i &lt ctk_object-&gtnum_info_entries; i++) {\newline        InfoEntryData *entryData = __info_entry_data+i;\newline        InfoEntry *entry = ctk_object-&gtinfo_entries+i;\newline\newline        entry-&gtpresent = entryData-&gtupdate_func(entry);\newline\newline        if (entry-&gtpresent) {\newline            gtk_widget_show(entry-&gthbox);\newline            gtk_widget_size_request(entry-&gtlabel, &ampreq);\newline            if (max_width &lt req.width) {\newline                max_width = req.width;\newline            }\newline        } else {\newline            gtk_widget_hide(entry-&gthbox);\newline        }\newline    }\newline\newline    for (i = 0; i &lt ctk_object-&gtnum_info_entries; i++) {\newline        InfoEntry *entry = ctk_object-&gtinfo_entries+i;\newline        if (entry-&gtpresent) {\newline            gtk_widget_set_size_request(entry-&gtlabel, max_width, -1);\newline        }\newline    }\newline\newline} /* update_device_info() */\newline","\newline update_device_info() - (Re)Queries the static display device information.\newline \newline","2808214","icalmemory.c","void icalmemory_free_ring_byval(buffer_ring *br) {\newline   int i;\newline   for(i=0; i&ltBUFFER_RING_SIZE; i++){\newline    if ( br-&gtring[i] != 0){\newline       free( br-&gtring[i]);\newline    }\newline    }\newline   free(br);\newline}\newline","get rid of this buffer ring \newline","4347793","cucdtst.c","static void TestIdentifier()\newline{\newline    const UChar32 sampleJavaIDStart[] = {0x0071, 0x00e4, 0x005f};\newline    const UChar32 sampleNonJavaIDStart[] = {0x0020, 0x2030, 0x0082};\newline    const UChar32 sampleJavaIDPart[] = {0x005f, 0x0032, 0x0045};\newline    const UChar32 sampleNonJavaIDPart[] = {0x2030, 0x2020, 0x0020};\newline    const UChar32 sampleUnicodeIDStart[] = {0x0250, 0x00e2, 0x0061};\newline    const UChar32 sampleNonUnicodeIDStart[] = {0x2000, 0x000a, 0x2019};\newline    const UChar32 sampleUnicodeIDPart[] = {0x005f, 0x0032, 0x0045};\newline    const UChar32 sampleNonUnicodeIDPart[] = {0x2030, 0x00a3, 0x0020};\newline    const UChar32 sampleIDIgnore[] = {0x0006, 0x0010, 0x206b, 0x85};\newline    const UChar32 sampleNonIDIgnore[] = {0x0075, 0x00a3, 0x0061};\newline\newline    testSampleCharProps(u_isJavaIDStart, &quotu_isJavaIDStart&quot,\newline                        sampleJavaIDStart, UPRV_LENGTHOF(sampleJavaIDStart), TRUE);\newline    testSampleCharProps(u_isJavaIDStart, &quotu_isJavaIDStart&quot,\newline                        sampleNonJavaIDStart, UPRV_LENGTHOF(sampleNonJavaIDStart), FALSE);\newline\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleJavaIDPart, UPRV_LENGTHOF(sampleJavaIDPart), TRUE);\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleNonJavaIDPart, UPRV_LENGTHOF(sampleNonJavaIDPart), FALSE);\newline\newline    /* IDPart should imply IDStart */\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleJavaIDStart, UPRV_LENGTHOF(sampleJavaIDStart), TRUE);\newline\newline    testSampleCharProps(u_isIDStart, &quotu_isIDStart&quot,\newline                        sampleUnicodeIDStart, UPRV_LENGTHOF(sampleUnicodeIDStart), TRUE);\newline    testSampleCharProps(u_isIDStart, &quotu_isIDStart&quot,\newline                        sampleNonUnicodeIDStart, UPRV_LENGTHOF(sampleNonUnicodeIDStart), FALSE);\newline\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleUnicodeIDPart, UPRV_LENGTHOF(sampleUnicodeIDPart), TRUE);\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleNonUnicodeIDPart, UPRV_LENGTHOF(sampleNonUnicodeIDPart), FALSE);\newline\newline    /* IDPart should imply IDStart */\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleUnicodeIDStart, UPRV_LENGTHOF(sampleUnicodeIDStart), TRUE);\newline\newline    testSampleCharProps(u_isIDIgnorable, &quotu_isIDIgnorable&quot,\newline                        sampleIDIgnore, UPRV_LENGTHOF(sampleIDIgnore), TRUE);\newline    testSampleCharProps(u_isIDIgnorable, &quotu_isIDIgnorable&quot,\newline                        sampleNonIDIgnore, UPRV_LENGTHOF(sampleNonIDIgnore), FALSE);\newline}\newline","u_isJavaIDStart, u_isJavaIDPart, u_isIDStart(), u_isIDPart(), u_isIDIgnorable() \newline","6652916","nm_mgr_db.c","uint32_t db_add_agent(eid_t agent_eid)\newline{\newline	char query[1024];\newline\newline	/* Step 1: Create Query */\newline	sprintf(query, &quotINSERT INTO dbtRegisteredAgents(AgentId) &quot\newline			&quotVALUES(&#039%s&#039)&quot, agent_eid.name);\newline\newline	if (mysql_query(gConn, query)) {\newline		DTNMP_DEBUG_ERR(&quotdb_add_agent&quot, &quotDatabase error: %s&quot,\newline				mysql_error(gConn));\newline		DTNMP_DEBUG_EXIT(&quotdb_add_agent&quot, &quot--&gt0&quot, NULL);\newline		return 0;\newline	}\newline\newline	DTNMP_DEBUG_EXIT(&quotdb_add_agent&quot, &quot--&gt1&quot, NULL);\newline	return 1;\newline}\newline","\newline \newline \\par Function Name: db_add_agent()\newline \newline \\par Adds a Registered Agent to the database\newline \newline \\return 0 Failure\newline !0 Success\newline \newline \\param[in] agent_eid - The Agent EID being added to the DB.\newline \newline \\par Notes:\newline - Only the agent EID is kept in the database, and used as a recipient\newline ID. No other agent information is persisted at this time.\newline \newline Modification History:\newline MM/DD/YY AUTHOR DESCRIPTION\newline -------- ------------ ---------------------------------------------\newline 07/12/13 S. Jacobs Initial implementation,\newline \newline","2924981","graphobject.c","PyObject *igraphmodule_Graph_community_spinglass(igraphmodule_GraphObject *self,\newline        PyObject *args, PyObject *kwds) {\newline  static char *kwlist[] = {&quotweights&quot, &quotspins&quot, &quotparupdate&quot,\newline      &quotstart_temp&quot, &quotstop_temp&quot, &quotcool_fact&quot, &quotupdate_rule&quot,\newline      &quotgamma&quot, &quotimplementation&quot, &quotlambda_&quot, NULL};\newline  PyObject *weights_o = Py_None;\newline  PyObject *parupdate_o = Py_False;\newline  PyObject *update_rule_o = Py_None;\newline  PyObject *impl_o = Py_None;\newline  PyObject *res;\newline\newline  long int spins = 25;\newline  double start_temp = 1.0;\newline  double stop_temp = 0.01;\newline  double cool_fact = 0.99;\newline  igraph_spinglass_implementation_t impl = IGRAPH_SPINCOMM_IMP_ORIG;\newline  igraph_spincomm_update_t update_rule = IGRAPH_SPINCOMM_UPDATE_CONFIG;\newline  double gamma = 1;\newline  double lambda = 1;\newline  igraph_vector_t *weights = 0, membership;\newline\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quot|OlOdddOdOd&quot, kwlist,\newline        &ampweights_o, &ampspins, &ampparupdate_o, &ampstart_temp, &ampstop_temp,\newline        &ampcool_fact, &ampupdate_rule_o, &ampgamma, &ampimpl_o, &amplambda))\newline    return NULL;\newline\newline  if (igraphmodule_PyObject_to_spincomm_update_t(update_rule_o, &ampupdate_rule)) {\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_PyObject_to_spinglass_implementation_t(impl_o, &ampimpl)) {\newline    return NULL;\newline  }\newline\newline  if (igraph_vector_init(&ampmembership, igraph_vcount(&ampself-&gtg))) {\newline	igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_attrib_to_vector_t(weights_o, self, &ampweights,\newline	  ATTRIBUTE_TYPE_EDGE)) {\newline    igraph_vector_destroy(&ampmembership);\newline    return NULL;\newline  }\newline\newline  if (igraph_community_spinglass(&ampself-&gtg, weights,\newline              0, 0, &ampmembership, 0, (igraph_integer_t) spins,\newline              PyObject_IsTrue(parupdate_o),\newline              start_temp, stop_temp, cool_fact,\newline              update_rule, gamma, impl, lambda)) {\newline    igraphmodule_handle_igraph_error();\newline    igraph_vector_destroy(&ampmembership);\newline    if (weights != 0) {\newline      igraph_vector_destroy(weights);\newline      free(weights);\newline    }\newline    return NULL;\newline  }\newline\newline  if (weights != 0) {\newline    igraph_vector_destroy(weights);\newline    free(weights);\newline  }\newline\newline  res = igraphmodule_vector_t_to_PyList(&ampmembership, IGRAPHMODULE_TYPE_INT);\newline  igraph_vector_destroy(&ampmembership);\newline\newline  return res;\newline}\newline","\newline Spinglass community detection method of Reichardt &amp Bornholdt\newline \newline","3284345","pilot-read-notepad.c","void write_png_v2( FILE *f, struct NotePad *n )\newline{\newline   if( n-&gtbody.dataType != NOTEPAD_DATA_PNG )\newline     {\newline	fprintf( stderr, &quotBad data Type&quot );\newline	return;\newline     }\newline\newline   fwrite( n-&gtdata, n-&gtbody.dataLen, 1, f );\newline   fflush( f );\newline}\newline","\newline \newline Function: write_png_v2\newline \newline Summary:\newline \newline Parameters: None\newline \newline Return: Nothing\newline \newline \newline","2905593","generator_random.cpp","float random_generator::generator_gauss_1(void)\newline{\newline  return(1.0f - fabs(generator_gauss_0()));\newline}\newline","\newlineGauss random number generator\newline\newlinecenter (and maximum) is 1.0\newlinerange is 1.0 - 0.0\newline \newline","4704915","event_tag_map.c","static int sortTags(EventTagMap* map)\newline{\newline    int i;\newline\newline    qsort(map-&gttagArray, map-&gtnumTags, sizeof(EventTag), compareEventTags);\newline\newline    for (i = 1; i &lt map-&gtnumTags; i++) {\newline        if (map-&gttagArray[i].tagIndex == map-&gttagArray[i-1].tagIndex) {\newline            fprintf(stderr, &quot%s: duplicate tag entries (%d:%s and %d:%s)\\n&quot,\newline                OUT_TAG,\newline                map-&gttagArray[i].tagIndex, map-&gttagArray[i].tagStr,\newline                map-&gttagArray[i-1].tagIndex, map-&gttagArray[i-1].tagStr);\newline            return -1;\newline        }\newline    }\newline\newline    return 0;\newline}\newline","\newline Sort the EventTag array so we can do fast lookups by tag index. After\newline the sort we do a quick check for duplicate tag indices.\newline \newline Returns 0 on success.\newline \newline","4962151","mainwindow.cpp","void MainWindow::slotReportProblem()\newline{\newline  QDesktopServices::openUrl(QUrl(&quothttps://github.com/QuiteRSS/quiterss/issues&quot));\newline}\newline","@brief Call default e-mail application to report the problem\newline --------------------------------------------------------------------------- \newline","3808424","tl_bmp.c","bitmap_t *thin_bmp_createhw(uint8 *addr, int width, int height, int bpp, int pitch)\newline{\newline   return _make_bitmap(addr, true, width, height, bpp, pitch, 0); /* zero overdraw */\newline}\newline","allocate and initialize a hardware bitmap \newline","5108104","mainstate.c","void exec_def(void) {\newline  byte *tp, *base;\newline  basicvars.current++;		/* Skip the DEF token */\newline  if (*basicvars.current != TOKEN_XFNPROCALL) {		/* Not followed by PROC or FN so ignore rest of line */\newline    while (!ateol[*basicvars.current]) basicvars.current = skip_token(basicvars.current);\newline    return;\newline  }\newline  tp = get_srcaddr(basicvars.current);		/* Find name of PROC or FN */\newline  if (*tp == TOKEN_PROC) error(ERR_CRASH);	/* Have run into a procedure */\newline/* This leaves just functions. Check for single line function */\newline  tp = basicvars.current+1+LOFFSIZE;\newline  if (*tp == &#039(&#039) {	/* Function name is followed by a parameter list */\newline    tp++;\newline    while (!ateol[*tp]) {	/* Find end of parameter list */\newline      if (*tp == TOKEN_RETURN) tp++;	/* Return parameter */\newline      if (*tp == TOKEN_XVAR) {		/* Found a parameter */\newline        base = tp;\newline        tp+=1+LOFFSIZE;\newline        if (*tp == &#039)&#039) {		/* Could mark an array or the end of the parameters */\newline          base = get_srcaddr(base);\newline          if (*(skip_name(base)-1) == &#039(&#039) tp++;	/* Got &#039name()&#039 - Found an array */\newline        }\newline      }\newline      else if (*tp == TOKEN_STATICVAR)	/* Found a static variable */\newline        tp+=2;\newline      else {\newline        error(ERR_SYNTAX);\newline      }\newline      if (*tp == &#039)&#039) break;	/* Found end of parameter list */\newline      if (*tp != &#039,&#039) error(ERR_SYNTAX);\newline      tp++;	/* Skip the &#039,&#039 */\newline    }\newline    if (*tp == &#039)&#039) tp++;	/* Skip the &#039)&#039 */\newline/* Check if token after the function name (and optional parameter list) is a &#039=&#039 */\newline  }\newline  if (*tp != &#039=&#039) error(ERR_CRASH);	/* Not an &#039=&#039 - Flag error */\newline  do	/* Single line function - Skip to end of statement */\newline    tp = skip_token(tp);\newline  while (!ateol[*tp]);\newline  basicvars.current = tp;\newline}\newline","\newline &#039exec_def&#039 processes &#039DEF&#039-type statements. It is an error in\newline this interpreter to run into a procedure or multi-line function\newline \newline","4461340","speed.c","speed_t cfgetospeed (const struct termios *termios_p)\newline{\newline  return termios_p-&gtc_cflag &amp (CBAUD | CBAUDEX);\newline}\newline","Return the output baud rate stored in TERMIOS_P. \newline","5721786","rspl1.c","static int *get_res(rspl *s) {\newline	return &amps-&gtnig;\newline}\newline","Return a pointer to the resolution array \newline","6372852","libmtd.c","static int read_pos_int(const char *file, int *value)\newline{\newline	long long res;\newline\newline	if (read_pos_ll(file, &ampres))\newline		return -1;\newline\newline	/* Make sure the value is not too big */\newline	if (res &gt INT_MAX) {\newline		errmsg(&quotvalue %lld read from file \\&quot%s\\&quot is out of range&quot,\newline		       res, file);\newline		errno = EINVAL;\newline		return -1;\newline	}\newline\newline	*value = res;\newline	return 0;\newline}\newline","\newline read_pos_int - read a positive &#039int&#039 value from a file.\newline @file: the file to read from\newline @value: the result is stored here\newline \newline This function is the same as &#039read_pos_ll()&#039, but it reads an &#039int&#039\newline value, not &#039long long&#039.\newline \newline","5137932","linux_logo.c","static void list_logos() {\newline\newline    int i;\newline    struct logo_info *temp_logo;\newline\newline    printf(&quot\\nAvailable Built-in Logos:\\n&quot);\newline    printf(&quot\\tNum\\tType\\tAscii\\tName\\t\\tDescription\\n&quot);\newline\newline    temp_logo=logo_info_head;\newline    i=1;\newline    while (temp_logo!=NULL) {\newline       printf(&quot\\t%d&quot,i);\newline       if (temp_logo-&gtsysinfo_position) printf(&quot\\tBanner&quot);\newline       else printf(&quot\\tClassic&quot);\newline       if (temp_logo-&gtascii_logo!=NULL) printf(&quot\\tYes&quot);\newline       else printf(&quot\\tNo&quot);\newline       printf(&quot\\t%s&quot,temp_logo-&gtname);\newline       if (strlen(temp_logo-&gtname)&lt8) printf(&quot\\t&quot);\newline       printf(&quot\\t%s\\n&quot,temp_logo-&gtdescription);\newline       temp_logo=temp_logo-&gtnext_logo;\newline       i++;\newline    }\newline    printf(&quot\\nDo \\&quotlinux_logo -L num\\&quot where num is from &quot\newline	      &quotabove to get the appropriate logo.\\n&quot);\newline    printf(&quotRemember to also use -a to get ascii version.\\n\\n&quot);\newline    exit(0);\newline}\newline","list the logos \newline","4332421","linenoise.c","static int fd_read(struct current *current)\newline{\newline#ifdef USE_UTF8\newline    char buf[4];\newline    int n;\newline    int i;\newline    int c;\newline\newline    if (read(current-&gtfd, &ampbuf[0], 1) != 1) {\newline        return -1;\newline    }\newline    n = utf8_charlen(buf[0]);\newline    if (n &lt 1 || n &gt 3) {\newline        return -1;\newline    }\newline    for (i = 1; i &lt n; i++) {\newline        if (read(current-&gtfd, &ampbuf[i], 1) != 1) {\newline            return -1;\newline        }\newline    }\newline    buf[n] = 0;\newline    /* decode and return the character */\newline    utf8_tounicode(buf, &ampc);\newline    return c;\newline#else\newline    return fd_read_char(current-&gtfd, -1);\newline#endif\newline}\newline","\newline Reads a complete utf-8 character\newline and returns the unicode value, or -1 on error.\newline \newline","1082535","input_http.c","static input_plugin_t *http_class_get_instance (input_class_t *cls_gen, xine_stream_t *stream,\newline				    const char *mrl) {\newline  /* http_input_class_t  *cls = (http_input_class_t *) cls_gen;*/\newline  http_input_plugin_t *this;\newline\newline  if (strncasecmp (mrl, &quothttp://&quot, 7) &amp&amp\newline      strncasecmp (mrl, &quotunsv://&quot, 7) &amp&amp\newline      strncasecmp (mrl, &quotpeercast://pls/&quot, 15) &amp&amp\newline      !_x_url_user_agent (mrl) /* user agent hacks */) {\newline    return NULL;\newline  }\newline  this = calloc(1, sizeof(http_input_plugin_t));\newline\newline  if (!strncasecmp (mrl, &quotpeercast://pls/&quot, 15)) {\newline    this-&gtmrl = _x_asprintf (&quothttp://127.0.0.1:7144/stream/%s&quot, mrl+15);\newline  } else {\newline    this-&gtmrl = strdup (mrl);\newline  }\newline\newline  this-&gtstream = stream;\newline  this-&gtfh     = -1;\newline  this-&gtnbc    = nbc_init (this-&gtstream);\newline\newline  this-&gtinput_plugin.open              = http_plugin_open;\newline  this-&gtinput_plugin.get_capabilities  = http_plugin_get_capabilities;\newline  this-&gtinput_plugin.read              = http_plugin_read;\newline  this-&gtinput_plugin.read_block        = http_plugin_read_block;\newline  this-&gtinput_plugin.seek              = http_plugin_seek;\newline  this-&gtinput_plugin.get_current_pos   = http_plugin_get_current_pos;\newline  this-&gtinput_plugin.get_length        = http_plugin_get_length;\newline  this-&gtinput_plugin.get_blocksize     = http_plugin_get_blocksize;\newline  this-&gtinput_plugin.get_mrl           = http_plugin_get_mrl;\newline  this-&gtinput_plugin.get_optional_data = http_plugin_get_optional_data;\newline  this-&gtinput_plugin.dispose           = http_plugin_dispose;\newline  this-&gtinput_plugin.input_class       = cls_gen;\newline\newline  return &ampthis-&gtinput_plugin;\newline}\newline","\newline http input plugin class\newline \newline","385411","ipoib.c","void ipoib_link_state_changed ( struct ib_device *ibdev ) {\newline	struct net_device *netdev = ib_get_ownerdata ( ibdev );\newline	struct ipoib_device *ipoib = netdev-&gtpriv;\newline	struct ipoib_mac *mac = ( ( struct ipoib_mac * ) netdev-&gtll_addr );\newline	int rc;\newline\newline	/* Leave existing broadcast group */\newline	ipoib_leave_broadcast_group ( ipoib );\newline\newline	/* Update MAC address based on potentially-new GID prefix */\newline	memcpy ( &ampmac-&gtgid.u.half[0], &ampibdev-&gtgid.u.half[0],\newline		 sizeof ( mac-&gtgid.u.half[0] ) );\newline\newline	/* Update broadcast GID based on potentially-new partition key */\newline	ipoib-&gtbroadcast.gid.u.words[2] = htons ( ibdev-&gtpkey );\newline\newline	/* Set net device link state to reflect Infiniband link state */\newline	if ( ib_link_ok ( ibdev ) ) {\newline		netdev_link_up ( netdev );\newline	} else {\newline		netdev_link_down ( netdev );\newline	}\newline\newline	/* Join new broadcast group */\newline	if ( ib_link_ok ( ibdev ) &amp&amp\newline	     ( ( rc = ipoib_join_broadcast_group ( ipoib ) ) != 0 ) ) {\newline		DBGC ( ipoib, &quotIPoIB %p could not rejoin broadcast group: &quot\newline		       &quot%s\\n&quot, ipoib, strerror ( rc ) );\newline		return;\newline	}\newline}\newline","\newline Handle link status change\newline \newline @v ibdev Infiniband device\newline \newline","6133261","brw_eu.h","static inline struct brw_reg brw_ip_reg(void)\newline{\newline	return brw_reg(BRW_ARCHITECTURE_REGISTER_FILE,\newline		       BRW_ARF_IP,\newline		       0,\newline		       BRW_REGISTER_TYPE_UD,\newline		       BRW_VERTICAL_STRIDE_4, /* ? */\newline		       BRW_WIDTH_1,\newline		       BRW_HORIZONTAL_STRIDE_0,\newline		       BRW_SWIZZLE_XYZW, /* NOTE! */\newline		       WRITEMASK_XYZW); /* NOTE! */\newline}\newline","If/else instructions break in align16 mode if writemask &amp swizzle\newline aren&#039t xyzw. This goes against the convention for other scalar\newline regs:\newline \newline","","","","","on","","","","","","on","on","","on","","","on","","on","on","","","","","","","","","","","","","","","","","","","","","","","allocate and return memory for a new dof pointer","Sort the EventTag array","Call default e-mail application to report the problem","allocate and initialize a hardware bitmap","{}","Return the output baud rate stored in TERMIOS_P.","Return a pointer to the resolution array","read a positive 'int' value from a file.","list the logos","Reads a complete utf-8 characterand returns the unicode value,","{}","{}","Handle link status change","{}","(Re)Queries the static display device information.","get rid of this buffer ring","{}","Adds a Registered Agent to the database","{}","{}","Gauss random number generator"
"3MD8CKRQZZN2RQP74JJCS074HNRJRH","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3WLEIWSYHOHRJKAPRV6R4YF68R9H21","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:14:36 PDT 2019","Wed Apr 17 14:20:09 PDT 2019","Fri Apr 19 14:20:09 PDT 2019","2019-04-19 21:20:21 UTC","","","333","100% (27/27)","100% (27/27)","100% (27/27)","5891763","memory.c","static DOF *transfer_dofs(MESH *mesh, DOF_ADMIN *new_admin,\newline			  DOF *old_dof, int position,\newline			  int is_coarse_dof, const DOF *periodic_twin)\newline{\newline  /* FUNCNAME(&quottransfer_dofs&quot); */\newline  DOF_ADMIN *admin;\newline  DOF       *new_dof = NULL;\newline  int       i, j, n, n0, ndof = mesh-&gtn_dof[position];\newline\newline  if (ndof &lt= 0) return NULL;\newline\newline  new_dof = AI_get_dof_memory(mesh, position);\newline\newline  for (i = 0; i &lt mesh-&gtn_dof_admin; i++) {\newline    admin = mesh-&gtdof_admin[i];\newline\newline    n  = admin-&gtn_dof[position];\newline    n0 = admin-&gtn0_dof[position];\newline\newline    for (j = 0; j &lt n; j++) {\newline      if (admin == new_admin) {\newline	if ((admin-&gtflags &amp ADM_PERIODIC) &amp&amp periodic_twin) {\newline	  new_dof[n0+j] = periodic_twin[n0+j];\newline	} else if (!is_coarse_dof ||\newline		   (admin-&gtflags &amp ADM_PRESERVE_COARSE_DOFS)) {\newline	  new_dof[n0+j] = get_dof_index(admin);\newline	} else {\newline	  new_dof[n0+j] = -1;\newline	}\newline      } else {\newline	if(old_dof) {\newline	  new_dof[n0+j] = old_dof[n0 + j];\newline	} else {\newline	  new_dof[n0+j] = -1;\newline	}\newline      }\newline    }\newline  }\newline\newline  return new_dof;\newline}\newline","transfer_dofs(mesh, new_admin, old_dof, position,\newline is_coarse_dof, periodic_twin):\newline \newline We allocate and return memory for a new dof pointer in an el-&gtdof[]\newline entry. The field is filled either with new DOF indices for each\newline admin or with -1 to mark it as unused. If &quotperiodic_twin&quot != NULL\newline and (new_admin-&gtflags &amp ADM_PERIODIC), then dof indices will not be\newline allocated but copied over from periodic_twin.\newline \newline","3060164","lex.c","static void dqEscape(char* buf, int len, int index, struct Parser* p,\newline                     char* cOut, int* eatenOut)\newline{\newline    if(len &lt 2) error(p, &quotunterminated string&quot, index);\newline    *eatenOut = 2;\newline    switch(buf[1]) {\newline    case &#039&quot&#039: *cOut = &#039&quot&#039; break;\newline    case &#039r&#039: *cOut = &#039\\r&#039; break;\newline    case &#039n&#039: *cOut = &#039\\n&#039; break;\newline    case &#039t&#039: *cOut = &#039\\t&#039; break;\newline    case &#039\\\\&#039: *cOut = &#039\\\\&#039; break;\newline    case &#039`&#039: *cOut = &#039`&#039; break;\newline    case &#039x&#039:\newline        if(len &lt 4) error(p, &quotunterminated string&quot, index);\newline        *cOut = (char)((hexc(buf[2], p, index)&lt&lt4) | hexc(buf[3], p, index));\newline        *eatenOut = 4;\newline        break;\newline    default:\newline        // Unhandled, put the backslash back\newline        *cOut = &#039\\\\&#039;\newline        *eatenOut = 1;\newline    }\newline}\newline","FIXME: need to handle \\b (8), \\f (12), and \\uXXXX for JSON compliance \newline","2102804","ctkdisplaydevice.c","static void update_device_info(CtkDisplayDevice *ctk_object)\newline{\newline    int i;\newline    int max_width;\newline    GtkRequisition req;\newline\newline\newline    max_width = 0;\newline    for (i = 0; i &lt ctk_object-&gtnum_info_entries; i++) {\newline        InfoEntryData *entryData = __info_entry_data+i;\newline        InfoEntry *entry = ctk_object-&gtinfo_entries+i;\newline\newline        entry-&gtpresent = entryData-&gtupdate_func(entry);\newline\newline        if (entry-&gtpresent) {\newline            gtk_widget_show(entry-&gthbox);\newline            gtk_widget_size_request(entry-&gtlabel, &ampreq);\newline            if (max_width &lt req.width) {\newline                max_width = req.width;\newline            }\newline        } else {\newline            gtk_widget_hide(entry-&gthbox);\newline        }\newline    }\newline\newline    for (i = 0; i &lt ctk_object-&gtnum_info_entries; i++) {\newline        InfoEntry *entry = ctk_object-&gtinfo_entries+i;\newline        if (entry-&gtpresent) {\newline            gtk_widget_set_size_request(entry-&gtlabel, max_width, -1);\newline        }\newline    }\newline\newline} /* update_device_info() */\newline","\newline update_device_info() - (Re)Queries the static display device information.\newline \newline","2808214","icalmemory.c","void icalmemory_free_ring_byval(buffer_ring *br) {\newline   int i;\newline   for(i=0; i&ltBUFFER_RING_SIZE; i++){\newline    if ( br-&gtring[i] != 0){\newline       free( br-&gtring[i]);\newline    }\newline    }\newline   free(br);\newline}\newline","get rid of this buffer ring \newline","4347793","cucdtst.c","static void TestIdentifier()\newline{\newline    const UChar32 sampleJavaIDStart[] = {0x0071, 0x00e4, 0x005f};\newline    const UChar32 sampleNonJavaIDStart[] = {0x0020, 0x2030, 0x0082};\newline    const UChar32 sampleJavaIDPart[] = {0x005f, 0x0032, 0x0045};\newline    const UChar32 sampleNonJavaIDPart[] = {0x2030, 0x2020, 0x0020};\newline    const UChar32 sampleUnicodeIDStart[] = {0x0250, 0x00e2, 0x0061};\newline    const UChar32 sampleNonUnicodeIDStart[] = {0x2000, 0x000a, 0x2019};\newline    const UChar32 sampleUnicodeIDPart[] = {0x005f, 0x0032, 0x0045};\newline    const UChar32 sampleNonUnicodeIDPart[] = {0x2030, 0x00a3, 0x0020};\newline    const UChar32 sampleIDIgnore[] = {0x0006, 0x0010, 0x206b, 0x85};\newline    const UChar32 sampleNonIDIgnore[] = {0x0075, 0x00a3, 0x0061};\newline\newline    testSampleCharProps(u_isJavaIDStart, &quotu_isJavaIDStart&quot,\newline                        sampleJavaIDStart, UPRV_LENGTHOF(sampleJavaIDStart), TRUE);\newline    testSampleCharProps(u_isJavaIDStart, &quotu_isJavaIDStart&quot,\newline                        sampleNonJavaIDStart, UPRV_LENGTHOF(sampleNonJavaIDStart), FALSE);\newline\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleJavaIDPart, UPRV_LENGTHOF(sampleJavaIDPart), TRUE);\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleNonJavaIDPart, UPRV_LENGTHOF(sampleNonJavaIDPart), FALSE);\newline\newline    /* IDPart should imply IDStart */\newline    testSampleCharProps(u_isJavaIDPart, &quotu_isJavaIDPart&quot,\newline                        sampleJavaIDStart, UPRV_LENGTHOF(sampleJavaIDStart), TRUE);\newline\newline    testSampleCharProps(u_isIDStart, &quotu_isIDStart&quot,\newline                        sampleUnicodeIDStart, UPRV_LENGTHOF(sampleUnicodeIDStart), TRUE);\newline    testSampleCharProps(u_isIDStart, &quotu_isIDStart&quot,\newline                        sampleNonUnicodeIDStart, UPRV_LENGTHOF(sampleNonUnicodeIDStart), FALSE);\newline\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleUnicodeIDPart, UPRV_LENGTHOF(sampleUnicodeIDPart), TRUE);\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleNonUnicodeIDPart, UPRV_LENGTHOF(sampleNonUnicodeIDPart), FALSE);\newline\newline    /* IDPart should imply IDStart */\newline    testSampleCharProps(u_isIDPart, &quotu_isIDPart&quot,\newline                        sampleUnicodeIDStart, UPRV_LENGTHOF(sampleUnicodeIDStart), TRUE);\newline\newline    testSampleCharProps(u_isIDIgnorable, &quotu_isIDIgnorable&quot,\newline                        sampleIDIgnore, UPRV_LENGTHOF(sampleIDIgnore), TRUE);\newline    testSampleCharProps(u_isIDIgnorable, &quotu_isIDIgnorable&quot,\newline                        sampleNonIDIgnore, UPRV_LENGTHOF(sampleNonIDIgnore), FALSE);\newline}\newline","u_isJavaIDStart, u_isJavaIDPart, u_isIDStart(), u_isIDPart(), u_isIDIgnorable() \newline","6652916","nm_mgr_db.c","uint32_t db_add_agent(eid_t agent_eid)\newline{\newline	char query[1024];\newline\newline	/* Step 1: Create Query */\newline	sprintf(query, &quotINSERT INTO dbtRegisteredAgents(AgentId) &quot\newline			&quotVALUES(&#039%s&#039)&quot, agent_eid.name);\newline\newline	if (mysql_query(gConn, query)) {\newline		DTNMP_DEBUG_ERR(&quotdb_add_agent&quot, &quotDatabase error: %s&quot,\newline				mysql_error(gConn));\newline		DTNMP_DEBUG_EXIT(&quotdb_add_agent&quot, &quot--&gt0&quot, NULL);\newline		return 0;\newline	}\newline\newline	DTNMP_DEBUG_EXIT(&quotdb_add_agent&quot, &quot--&gt1&quot, NULL);\newline	return 1;\newline}\newline","\newline \newline \\par Function Name: db_add_agent()\newline \newline \\par Adds a Registered Agent to the database\newline \newline \\return 0 Failure\newline !0 Success\newline \newline \\param[in] agent_eid - The Agent EID being added to the DB.\newline \newline \\par Notes:\newline - Only the agent EID is kept in the database, and used as a recipient\newline ID. No other agent information is persisted at this time.\newline \newline Modification History:\newline MM/DD/YY AUTHOR DESCRIPTION\newline -------- ------------ ---------------------------------------------\newline 07/12/13 S. Jacobs Initial implementation,\newline \newline","2924981","graphobject.c","PyObject *igraphmodule_Graph_community_spinglass(igraphmodule_GraphObject *self,\newline        PyObject *args, PyObject *kwds) {\newline  static char *kwlist[] = {&quotweights&quot, &quotspins&quot, &quotparupdate&quot,\newline      &quotstart_temp&quot, &quotstop_temp&quot, &quotcool_fact&quot, &quotupdate_rule&quot,\newline      &quotgamma&quot, &quotimplementation&quot, &quotlambda_&quot, NULL};\newline  PyObject *weights_o = Py_None;\newline  PyObject *parupdate_o = Py_False;\newline  PyObject *update_rule_o = Py_None;\newline  PyObject *impl_o = Py_None;\newline  PyObject *res;\newline\newline  long int spins = 25;\newline  double start_temp = 1.0;\newline  double stop_temp = 0.01;\newline  double cool_fact = 0.99;\newline  igraph_spinglass_implementation_t impl = IGRAPH_SPINCOMM_IMP_ORIG;\newline  igraph_spincomm_update_t update_rule = IGRAPH_SPINCOMM_UPDATE_CONFIG;\newline  double gamma = 1;\newline  double lambda = 1;\newline  igraph_vector_t *weights = 0, membership;\newline\newline  if (!PyArg_ParseTupleAndKeywords(args, kwds, &quot|OlOdddOdOd&quot, kwlist,\newline        &ampweights_o, &ampspins, &ampparupdate_o, &ampstart_temp, &ampstop_temp,\newline        &ampcool_fact, &ampupdate_rule_o, &ampgamma, &ampimpl_o, &amplambda))\newline    return NULL;\newline\newline  if (igraphmodule_PyObject_to_spincomm_update_t(update_rule_o, &ampupdate_rule)) {\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_PyObject_to_spinglass_implementation_t(impl_o, &ampimpl)) {\newline    return NULL;\newline  }\newline\newline  if (igraph_vector_init(&ampmembership, igraph_vcount(&ampself-&gtg))) {\newline	igraphmodule_handle_igraph_error();\newline    return NULL;\newline  }\newline\newline  if (igraphmodule_attrib_to_vector_t(weights_o, self, &ampweights,\newline	  ATTRIBUTE_TYPE_EDGE)) {\newline    igraph_vector_destroy(&ampmembership);\newline    return NULL;\newline  }\newline\newline  if (igraph_community_spinglass(&ampself-&gtg, weights,\newline              0, 0, &ampmembership, 0, (igraph_integer_t) spins,\newline              PyObject_IsTrue(parupdate_o),\newline              start_temp, stop_temp, cool_fact,\newline              update_rule, gamma, impl, lambda)) {\newline    igraphmodule_handle_igraph_error();\newline    igraph_vector_destroy(&ampmembership);\newline    if (weights != 0) {\newline      igraph_vector_destroy(weights);\newline      free(weights);\newline    }\newline    return NULL;\newline  }\newline\newline  if (weights != 0) {\newline    igraph_vector_destroy(weights);\newline    free(weights);\newline  }\newline\newline  res = igraphmodule_vector_t_to_PyList(&ampmembership, IGRAPHMODULE_TYPE_INT);\newline  igraph_vector_destroy(&ampmembership);\newline\newline  return res;\newline}\newline","\newline Spinglass community detection method of Reichardt &amp Bornholdt\newline \newline","3284345","pilot-read-notepad.c","void write_png_v2( FILE *f, struct NotePad *n )\newline{\newline   if( n-&gtbody.dataType != NOTEPAD_DATA_PNG )\newline     {\newline	fprintf( stderr, &quotBad data Type&quot );\newline	return;\newline     }\newline\newline   fwrite( n-&gtdata, n-&gtbody.dataLen, 1, f );\newline   fflush( f );\newline}\newline","\newline \newline Function: write_png_v2\newline \newline Summary:\newline \newline Parameters: None\newline \newline Return: Nothing\newline \newline \newline","2905593","generator_random.cpp","float random_generator::generator_gauss_1(void)\newline{\newline  return(1.0f - fabs(generator_gauss_0()));\newline}\newline","\newlineGauss random number generator\newline\newlinecenter (and maximum) is 1.0\newlinerange is 1.0 - 0.0\newline \newline","4704915","event_tag_map.c","static int sortTags(EventTagMap* map)\newline{\newline    int i;\newline\newline    qsort(map-&gttagArray, map-&gtnumTags, sizeof(EventTag), compareEventTags);\newline\newline    for (i = 1; i &lt map-&gtnumTags; i++) {\newline        if (map-&gttagArray[i].tagIndex == map-&gttagArray[i-1].tagIndex) {\newline            fprintf(stderr, &quot%s: duplicate tag entries (%d:%s and %d:%s)\\n&quot,\newline                OUT_TAG,\newline                map-&gttagArray[i].tagIndex, map-&gttagArray[i].tagStr,\newline                map-&gttagArray[i-1].tagIndex, map-&gttagArray[i-1].tagStr);\newline            return -1;\newline        }\newline    }\newline\newline    return 0;\newline}\newline","\newline Sort the EventTag array so we can do fast lookups by tag index. After\newline the sort we do a quick check for duplicate tag indices.\newline \newline Returns 0 on success.\newline \newline","4962151","mainwindow.cpp","void MainWindow::slotReportProblem()\newline{\newline  QDesktopServices::openUrl(QUrl(&quothttps://github.com/QuiteRSS/quiterss/issues&quot));\newline}\newline","@brief Call default e-mail application to report the problem\newline --------------------------------------------------------------------------- \newline","3808424","tl_bmp.c","bitmap_t *thin_bmp_createhw(uint8 *addr, int width, int height, int bpp, int pitch)\newline{\newline   return _make_bitmap(addr, true, width, height, bpp, pitch, 0); /* zero overdraw */\newline}\newline","allocate and initialize a hardware bitmap \newline","5108104","mainstate.c","void exec_def(void) {\newline  byte *tp, *base;\newline  basicvars.current++;		/* Skip the DEF token */\newline  if (*basicvars.current != TOKEN_XFNPROCALL) {		/* Not followed by PROC or FN so ignore rest of line */\newline    while (!ateol[*basicvars.current]) basicvars.current = skip_token(basicvars.current);\newline    return;\newline  }\newline  tp = get_srcaddr(basicvars.current);		/* Find name of PROC or FN */\newline  if (*tp == TOKEN_PROC) error(ERR_CRASH);	/* Have run into a procedure */\newline/* This leaves just functions. Check for single line function */\newline  tp = basicvars.current+1+LOFFSIZE;\newline  if (*tp == &#039(&#039) {	/* Function name is followed by a parameter list */\newline    tp++;\newline    while (!ateol[*tp]) {	/* Find end of parameter list */\newline      if (*tp == TOKEN_RETURN) tp++;	/* Return parameter */\newline      if (*tp == TOKEN_XVAR) {		/* Found a parameter */\newline        base = tp;\newline        tp+=1+LOFFSIZE;\newline        if (*tp == &#039)&#039) {		/* Could mark an array or the end of the parameters */\newline          base = get_srcaddr(base);\newline          if (*(skip_name(base)-1) == &#039(&#039) tp++;	/* Got &#039name()&#039 - Found an array */\newline        }\newline      }\newline      else if (*tp == TOKEN_STATICVAR)	/* Found a static variable */\newline        tp+=2;\newline      else {\newline        error(ERR_SYNTAX);\newline      }\newline      if (*tp == &#039)&#039) break;	/* Found end of parameter list */\newline      if (*tp != &#039,&#039) error(ERR_SYNTAX);\newline      tp++;	/* Skip the &#039,&#039 */\newline    }\newline    if (*tp == &#039)&#039) tp++;	/* Skip the &#039)&#039 */\newline/* Check if token after the function name (and optional parameter list) is a &#039=&#039 */\newline  }\newline  if (*tp != &#039=&#039) error(ERR_CRASH);	/* Not an &#039=&#039 - Flag error */\newline  do	/* Single line function - Skip to end of statement */\newline    tp = skip_token(tp);\newline  while (!ateol[*tp]);\newline  basicvars.current = tp;\newline}\newline","\newline &#039exec_def&#039 processes &#039DEF&#039-type statements. It is an error in\newline this interpreter to run into a procedure or multi-line function\newline \newline","4461340","speed.c","speed_t cfgetospeed (const struct termios *termios_p)\newline{\newline  return termios_p-&gtc_cflag &amp (CBAUD | CBAUDEX);\newline}\newline","Return the output baud rate stored in TERMIOS_P. \newline","5721786","rspl1.c","static int *get_res(rspl *s) {\newline	return &amps-&gtnig;\newline}\newline","Return a pointer to the resolution array \newline","6372852","libmtd.c","static int read_pos_int(const char *file, int *value)\newline{\newline	long long res;\newline\newline	if (read_pos_ll(file, &ampres))\newline		return -1;\newline\newline	/* Make sure the value is not too big */\newline	if (res &gt INT_MAX) {\newline		errmsg(&quotvalue %lld read from file \\&quot%s\\&quot is out of range&quot,\newline		       res, file);\newline		errno = EINVAL;\newline		return -1;\newline	}\newline\newline	*value = res;\newline	return 0;\newline}\newline","\newline read_pos_int - read a positive &#039int&#039 value from a file.\newline @file: the file to read from\newline @value: the result is stored here\newline \newline This function is the same as &#039read_pos_ll()&#039, but it reads an &#039int&#039\newline value, not &#039long long&#039.\newline \newline","5137932","linux_logo.c","static void list_logos() {\newline\newline    int i;\newline    struct logo_info *temp_logo;\newline\newline    printf(&quot\\nAvailable Built-in Logos:\\n&quot);\newline    printf(&quot\\tNum\\tType\\tAscii\\tName\\t\\tDescription\\n&quot);\newline\newline    temp_logo=logo_info_head;\newline    i=1;\newline    while (temp_logo!=NULL) {\newline       printf(&quot\\t%d&quot,i);\newline       if (temp_logo-&gtsysinfo_position) printf(&quot\\tBanner&quot);\newline       else printf(&quot\\tClassic&quot);\newline       if (temp_logo-&gtascii_logo!=NULL) printf(&quot\\tYes&quot);\newline       else printf(&quot\\tNo&quot);\newline       printf(&quot\\t%s&quot,temp_logo-&gtname);\newline       if (strlen(temp_logo-&gtname)&lt8) printf(&quot\\t&quot);\newline       printf(&quot\\t%s\\n&quot,temp_logo-&gtdescription);\newline       temp_logo=temp_logo-&gtnext_logo;\newline       i++;\newline    }\newline    printf(&quot\\nDo \\&quotlinux_logo -L num\\&quot where num is from &quot\newline	      &quotabove to get the appropriate logo.\\n&quot);\newline    printf(&quotRemember to also use -a to get ascii version.\\n\\n&quot);\newline    exit(0);\newline}\newline","list the logos \newline","4332421","linenoise.c","static int fd_read(struct current *current)\newline{\newline#ifdef USE_UTF8\newline    char buf[4];\newline    int n;\newline    int i;\newline    int c;\newline\newline    if (read(current-&gtfd, &ampbuf[0], 1) != 1) {\newline        return -1;\newline    }\newline    n = utf8_charlen(buf[0]);\newline    if (n &lt 1 || n &gt 3) {\newline        return -1;\newline    }\newline    for (i = 1; i &lt n; i++) {\newline        if (read(current-&gtfd, &ampbuf[i], 1) != 1) {\newline            return -1;\newline        }\newline    }\newline    buf[n] = 0;\newline    /* decode and return the character */\newline    utf8_tounicode(buf, &ampc);\newline    return c;\newline#else\newline    return fd_read_char(current-&gtfd, -1);\newline#endif\newline}\newline","\newline Reads a complete utf-8 character\newline and returns the unicode value, or -1 on error.\newline \newline","1082535","input_http.c","static input_plugin_t *http_class_get_instance (input_class_t *cls_gen, xine_stream_t *stream,\newline				    const char *mrl) {\newline  /* http_input_class_t  *cls = (http_input_class_t *) cls_gen;*/\newline  http_input_plugin_t *this;\newline\newline  if (strncasecmp (mrl, &quothttp://&quot, 7) &amp&amp\newline      strncasecmp (mrl, &quotunsv://&quot, 7) &amp&amp\newline      strncasecmp (mrl, &quotpeercast://pls/&quot, 15) &amp&amp\newline      !_x_url_user_agent (mrl) /* user agent hacks */) {\newline    return NULL;\newline  }\newline  this = calloc(1, sizeof(http_input_plugin_t));\newline\newline  if (!strncasecmp (mrl, &quotpeercast://pls/&quot, 15)) {\newline    this-&gtmrl = _x_asprintf (&quothttp://127.0.0.1:7144/stream/%s&quot, mrl+15);\newline  } else {\newline    this-&gtmrl = strdup (mrl);\newline  }\newline\newline  this-&gtstream = stream;\newline  this-&gtfh     = -1;\newline  this-&gtnbc    = nbc_init (this-&gtstream);\newline\newline  this-&gtinput_plugin.open              = http_plugin_open;\newline  this-&gtinput_plugin.get_capabilities  = http_plugin_get_capabilities;\newline  this-&gtinput_plugin.read              = http_plugin_read;\newline  this-&gtinput_plugin.read_block        = http_plugin_read_block;\newline  this-&gtinput_plugin.seek              = http_plugin_seek;\newline  this-&gtinput_plugin.get_current_pos   = http_plugin_get_current_pos;\newline  this-&gtinput_plugin.get_length        = http_plugin_get_length;\newline  this-&gtinput_plugin.get_blocksize     = http_plugin_get_blocksize;\newline  this-&gtinput_plugin.get_mrl           = http_plugin_get_mrl;\newline  this-&gtinput_plugin.get_optional_data = http_plugin_get_optional_data;\newline  this-&gtinput_plugin.dispose           = http_plugin_dispose;\newline  this-&gtinput_plugin.input_class       = cls_gen;\newline\newline  return &ampthis-&gtinput_plugin;\newline}\newline","\newline http input plugin class\newline \newline","385411","ipoib.c","void ipoib_link_state_changed ( struct ib_device *ibdev ) {\newline	struct net_device *netdev = ib_get_ownerdata ( ibdev );\newline	struct ipoib_device *ipoib = netdev-&gtpriv;\newline	struct ipoib_mac *mac = ( ( struct ipoib_mac * ) netdev-&gtll_addr );\newline	int rc;\newline\newline	/* Leave existing broadcast group */\newline	ipoib_leave_broadcast_group ( ipoib );\newline\newline	/* Update MAC address based on potentially-new GID prefix */\newline	memcpy ( &ampmac-&gtgid.u.half[0], &ampibdev-&gtgid.u.half[0],\newline		 sizeof ( mac-&gtgid.u.half[0] ) );\newline\newline	/* Update broadcast GID based on potentially-new partition key */\newline	ipoib-&gtbroadcast.gid.u.words[2] = htons ( ibdev-&gtpkey );\newline\newline	/* Set net device link state to reflect Infiniband link state */\newline	if ( ib_link_ok ( ibdev ) ) {\newline		netdev_link_up ( netdev );\newline	} else {\newline		netdev_link_down ( netdev );\newline	}\newline\newline	/* Join new broadcast group */\newline	if ( ib_link_ok ( ibdev ) &amp&amp\newline	     ( ( rc = ipoib_join_broadcast_group ( ipoib ) ) != 0 ) ) {\newline		DBGC ( ipoib, &quotIPoIB %p could not rejoin broadcast group: &quot\newline		       &quot%s\\n&quot, ipoib, strerror ( rc ) );\newline		return;\newline	}\newline}\newline","\newline Handle link status change\newline \newline @v ibdev Infiniband device\newline \newline","6133261","brw_eu.h","static inline struct brw_reg brw_ip_reg(void)\newline{\newline	return brw_reg(BRW_ARCHITECTURE_REGISTER_FILE,\newline		       BRW_ARF_IP,\newline		       0,\newline		       BRW_REGISTER_TYPE_UD,\newline		       BRW_VERTICAL_STRIDE_4, /* ? */\newline		       BRW_WIDTH_1,\newline		       BRW_HORIZONTAL_STRIDE_0,\newline		       BRW_SWIZZLE_XYZW, /* NOTE! */\newline		       WRITEMASK_XYZW); /* NOTE! */\newline}\newline","If/else instructions break in align16 mode if writemask &amp swizzle\newline aren&#039t xyzw. This goes against the convention for other scalar\newline regs:\newline \newline","on","","","","on","","","","","","","on","","on","","","on","","","on","","","","","","","","","","","","","","","","","","","","","","","{}","Sort the EventTag array","Call default e-mail application to report the problem","allocate and initialize a hardware bitmap","{}","Return the output baud rate stored in TERMIOS_P.","Return a pointer to the resolution array","read a positive 'int' value from a file.","list the logos","Reads a complete utf-8 characterand returns the unicode value,","http input plugin class","{}","Handle link status change","{}","(Re)Queries the static display device information.","get rid of this buffer ring","{}","Adds a Registered Agent to the database","Spinglass community detection method","{}","Gauss random number generator"
"3MXX6RQ9EV5RCVQ7OKSJH3I6Y8DP44","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3IJXV6UZ1XJ8JZ2UC33D5IOTKWFRIU","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:03:33 PDT 2019","Wed Apr 17 15:10:53 PDT 2019","Fri Apr 19 15:10:53 PDT 2019","2019-04-19 22:11:21 UTC","","","440","100% (27/27)","100% (27/27)","100% (27/27)","295849","shutdown.cpp","void KSMServer::protectionTimeout()\newline{\newline    if ( ( state != Shutdown &amp&amp state != Checkpoint &amp&amp state != ClosingSubSession ) || clientInteracting )\newline        return;\newline\newline    foreach( KSMClient* c, clients ) {\newline        if ( !c-&gtsaveYourselfDone &amp&amp !c-&gtwaitForPhase2 ) {\newline            qCDebug(KSMSERVER) &lt&lt &quotprotectionTimeout: client &quot &lt&lt c-&gtprogram() &lt&lt &quot(&quot &lt&lt c-&gtclientId() &lt&lt &quot)&quot;\newline            c-&gtsaveYourselfDone = true;\newline        }\newline    }\newline    completeShutdownOrCheckpoint();\newline    startProtection();\newline}\newline","\newlineInternal protection slot, invoked when clients do not react during\newlineshutdown.\newline \newline","102931","blake2b-ref.c","int blake2b_init_param( blake2b_state *S, const blake2b_param *P )\newline{\newline  blake2b_init0( S );\newline  uint8_t *p = ( uint8_t * )( P );\newline\newline  /* IV XOR ParamBlock */\newline  for( size_t i = 0; i &lt 8; ++i )\newline    S-&gth[i] ^= load64( p + sizeof( S-&gth[i] ) * i );\newline\newline  S-&gtoutlen = P-&gtdigest_length;\newline  return 0;\newline}\newline","init xors IV with input parameter block \newline","774968","lvconvert.c","static int _raid4_conversion_supported(struct logical_volume *lv, struct lvconvert_params *lp)\newline{\newline	int ret = 1;\newline	struct lv_segment *seg = first_seg(lv);\newline\newline	if (seg_is_raid4(seg))\newline		ret = raid4_is_supported(lv-&gtvg-&gtcmd, seg-&gtsegtype);\newline	else if (segtype_is_raid4(lp-&gtsegtype))\newline		ret = raid4_is_supported(lv-&gtvg-&gtcmd, lp-&gtsegtype);\newline\newline	if (ret)\newline		return 1;\newline\newline	log_error(&quotCannot convert %s LV %s to %s.&quot,\newline		  lvseg_name(seg), display_lvname(lv), lp-&gtsegtype-&gtname);\newline	return 0;\newline}\newline","Check for dm-raid target supporting raid4 conversion properly. \newline","2072636","wd_keepalive.c","static void close_all(void)\newline{\newline	close_watchdog();\newline}\newline","close the device and check for error \newline","4945851","field.c","double fdisk_field_get_width(const struct fdisk_field *field)\newline{\newline	return field ? field-&gtwidth : -EINVAL;\newline}\newline","\newline fdisk_field_get_width:\newline @field: field instance\newline \newline Returns: libsmartcols compatible width.\newline \newline","4479207","domain.c","int is_domain_local_pvar(struct sip_msg *msg, str* _host, char *pvar)\newline{\newline	pv_spec_t *pv = (pv_spec_t *)pvar;\newline	pv_value_t val;\newline	db_val_t *values;\newline\newline	if (db_mode == 0) {\newline		db_key_t keys[1];\newline		db_val_t vals[1];\newline		db_key_t cols[2];\newline		db_res_t* res = NULL;\newline\newline		keys[0] = &ampdomain_col;\newline		cols[0] = &ampdomain_col;\newline		cols[1] = &ampdomain_attrs_col;\newline\newline		if (domain_dbf.use_table(db_handle, &ampdomain_table) &lt 0) {\newline			LM_ERR(&quotError while trying to use domain table\\n&quot);\newline			return -3;\newline		}\newline\newline		VAL_TYPE(vals) = DB_STR;\newline		VAL_NULL(vals) = 0;\newline\newline		VAL_STR(vals).s = _host-&gts;\newline		VAL_STR(vals).len = _host-&gtlen;\newline\newline		if (domain_dbf.query(db_handle, keys, 0, vals, cols, 1, 2, 0, &ampres) &lt 0\newline				) {\newline			LM_ERR(&quotError while querying database\\n&quot);\newline			return -3;\newline		}\newline\newline		if (RES_ROW_N(res) == 0) {\newline			LM_DBG(&quotRealm &#039%.*s&#039 is not local\\n&quot,\newline			       _host-&gtlen, ZSW(_host-&gts));\newline			domain_dbf.free_result(db_handle, res);\newline			return -1;\newline		} else {\newline			LM_DBG(&quotRealm &#039%.*s&#039 is local\\n&quot,\newline			       _host-&gtlen, ZSW(_host-&gts));\newline			if (pvar) {\newline				/* XXX: what shall we do if there are duplicate entries? */\newline				/* we only check the first row - razvanc */\newline				values = ROW_VALUES(RES_ROWS(res));\newline				if (!VAL_NULL(values +1)) {\newline					if (VAL_TYPE(values + 1) == DB_STR) {\newline						val.rs = VAL_STR(values + 1);\newline					} else {\newline						val.rs.s = (char *)VAL_STRING(values + 1);\newline						val.rs.len = strlen(val.rs.s);\newline					}\newline					val.flags = PV_VAL_STR;\newline					if (pv_set_value(msg, pv, 0, &ampval) != 0)\newline						LM_ERR(&quotCannot set attributes value\\n&quot);\newline				}\newline			}\newline			domain_dbf.free_result(db_handle, res);\newline			return 1;\newline		}\newline	} else {\newline		return hash_table_lookup (msg, _host, pv);\newline	}\newline\newline}\newline","\newline Check if domain is local and store attributes in a pvar\newline \newline","3280051","omake_shell_sys.c","static value omake_shell_sys_wait_aux(value v_pgrp, value v_leader, value v_nohang)\newline{\newline    CAMLparam3(v_pgrp, v_leader, v_nohang);\newline    CAMLlocal3(list, tuple, status);\newline    int processes[MAXIMUM_WAIT_OBJECTS];\newline    HANDLE handles[MAXIMUM_WAIT_OBJECTS];\newline    Process **processpp, *processp;\newline    int ncount, code, pid, pgrp, leader;\newline    DWORD exitcode, timeout, index;\newline\newline#ifdef OSH_DEBUG\newline    fprintf(stderr, &quotomake_shell_sys_wait\\n&quot);\newline    fflush(stderr);\newline#endif\newline\newline    /* Parameters */\newline    pgrp = Int_val(v_pgrp);\newline    leader = Int_val(v_leader);\newline    timeout = Int_val(v_nohang) ? 0 : INFINITE;\newline\newline    /* Collect the processes and their handles */\newline    ncount = 1;\newline    handles[0] = state-&gtchanged;\newline    for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline        if((pgrp &amp&amp processp-&gtpgrp != pgrp)\newline           || (pgrp == 0 &amp&amp processp-&gtpgrp == INIT_PID)\newline           || (leader &amp&amp processp-&gtpid != processp-&gtpgrp)\newline           || (leader == 0 &amp&amp processp-&gtpid == processp-&gtpgrp)) {\newline            continue;\newline        }\newline        else if(processp-&gtchanged)\newline            CAMLreturn(handle_wait(&quotchanged&quot, processpp));\newline        else {\newline            if(ncount == MAXIMUM_WAIT_OBJECTS)\newline                invalid_argument(&quotomake_shell_sys_wait: too many processes&quot);\newline            processes[ncount] = processp-&gtpid;\newline            handles[ncount] = processp-&gthandle;\newline            ncount++;\newline        }\newline    }\newline\newline#ifdef OSH_DEBUG\newline    fprintf(stderr, &quotomake_shell_sys_wait: waiting for %d events\\n&quot, ncount);\newline    fprintf(stderr, &quot\\tpgrp = %d, leader = %d, timeout = %d\\n&quot, pgrp, leader, timeout);\newline    fflush(stderr);\newline#endif\newline\newline    /* Wait for an event */\newline    while(1) {\newline        /* Perform the wait */\newline        enter_blocking_section();\newline        index = WaitForMultipleObjects(ncount, handles, FALSE, timeout);\newline        if(index == WAIT_FAILED)\newline            code = GetLastError();\newline        leave_blocking_section();\newline\newline        /* See if something has changed */\newline        if(index == WAIT_OBJECT_0) {\newline            for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline                if(processp-&gtpgrp == pgrp &amp&amp processp-&gtchanged)\newline                    CAMLreturn(handle_wait(&quotstate changed&quot, processpp));\newline            }\newline        }\newline        else\newline            break;\newline    }\newline\newline    /* Get the index of the event */\newline    if(index &gt= WAIT_OBJECT_0 + 1 &amp&amp index &lt WAIT_OBJECT_0 + ncount)\newline        index -= WAIT_OBJECT_0;\newline    else if(index &gt= WAIT_ABANDONED_0 + 1 &amp&amp index &lt WAIT_ABANDONED_0 + ncount)\newline        index -= WAIT_ABANDONED_0;\newline    else\newline        raise_not_found();\newline\newline    /* Adjust process */\newline    pid = processes[index];\newline    for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline        if(processp-&gtpid == pid)\newline            break;\newline    }\newline\newline    /* If the process is not found, some other thread waited for it */\newline    if(processp == 0)\newline        CAMLreturn((value) 0);\newline\newline    /* Otherwise, handle the wait */\newline    processp-&gtchanged = 1;\newline    processp-&gtstatus = STATUS_EXITED;\newline\newline    /* Get the return code */\newline    if(processp-&gtis_thread == 0) {\newline        if(GetExitCodeProcess(handles[index], &ampexitcode) == FALSE)\newline            exitcode = 111;\newline        processp-&gtcode = exitcode;\newline    }\newline\newline    /* Return the value */\newline    CAMLreturn(handle_wait(&quotdone&quot, processpp));\newline}\newline","\newline Wait for any of the processes in the group to complete.\newline There are several modes:\newline pgrp == 0: wait for any process group leader\newline pgrp &lt&gt 0: wait for a specific process group\newline leader: if true, wait only for the group leader\newline if false, wait only for the children\newline nohang: if true, don&#039t block\newline \newline","3839574","hidparser.c","HIDData_t *FindObject_with_ID(HIDDesc_t *pDesc, uint8_t ReportID, uint8_t Offset, uint8_t Type)\newline{\newline	int	i;\newline\newline	for (i = 0; i &lt pDesc-&gtnitems; i++) {\newline		HIDData_t *pData = &amppDesc-&gtitem[i];\newline		\newline		if (pData-&gtReportID != ReportID) {\newline			continue;\newline		}\newline		\newline		if (pData-&gtType != Type) {\newline			continue;\newline		}\newline \newline		if (pData-&gtOffset != Offset) {\newline			continue;\newline		}\newline		\newline		return pData;\newline	}\newline	\newline	return NULL;\newline}\newline","\newline FindObject_with_ID\newline Get pData item with given ReportID, Offset, and Type. Return NULL\newline if not found.\newline -------------------------------------------------------------------------- \newline","1101031","alstream.c","static int OpenPlayerFile(StreamPlayer *player, const char *filename)\newline{\newline    ClosePlayerFile(player);\newline\newline    /* Open the file and get the first stream from it */\newline    player-&gtfile = openAudioFile(filename, BUFFER_TIME_MS);\newline    if(!player-&gtfile)\newline    {\newline        fprintf(stderr, &quotCould not open audio in %s\\n&quot, filename);\newline        goto error;\newline    }\newline\newline    /* Get the stream format, and figure out the OpenAL format */\newline    if(getAudioInfo(player-&gtfile, &ampplayer-&gtrate, &ampplayer-&gtchannels, &ampplayer-&gttype) != 0)\newline    {\newline        fprintf(stderr, &quotError getting audio info for %s\\n&quot, filename);\newline        goto error;\newline    }\newline\newline    player-&gtformat = GetFormat(player-&gtchannels, player-&gttype, alIsBufferFormatSupportedSOFT);\newline    if(player-&gtformat == 0)\newline    {\newline        fprintf(stderr, &quotUnsupported format (%s, %s) for %s\\n&quot,\newline                ChannelsName(player-&gtchannels), TypeName(player-&gttype),\newline                filename);\newline        goto error;\newline    }\newline\newline    return 1;\newline\newlineerror:\newline    closeAudioFile(player-&gtfile);\newline    player-&gtfile = NULL;\newline\newline    return 0;\newline}\newline","Opens the first audio stream of the named file. If a file is already open,\newline it will be closed first. \newline","3067420","qwt_text.cpp","void QwtText::setColor(const QColor &ampcolor) \newline{ \newline    d_data-&gtcolor = color; \newline    setPaintAttribute(PaintUsingTextColor);\newline}\newline","! \newlineSet the pen color used for painting the text.\newline\\param color Color\newline\\note Setting the color might have no effect, when\newlinethe text contains control sequences for setting colors.\newline \newline","5388337","install.c","BOOL WINAPI SetupInstallFromInfSectionW( HWND owner, HINF hinf, PCWSTR section, UINT flags,\newline                                         HKEY key_root, PCWSTR src_root, UINT copy_flags,\newline                                         PSP_FILE_CALLBACK_W callback, PVOID context,\newline                                         HDEVINFO devinfo, PSP_DEVINFO_DATA devinfo_data )\newline{\newline    BOOL ret;\newline    int i;\newline\newline    if (flags &amp SPINST_REGISTRY)\newline    {\newline        struct registry_callback_info info;\newline\newline        info.default_root = key_root;\newline        info.delete = FALSE;\newline        if (!iterate_section_fields( hinf, section, WinePreInstall, registry_callback, &ampinfo ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_FILES)\newline    {\newline        struct files_callback_info info;\newline        HSPFILEQ queue;\newline\newline        if (!(queue = SetupOpenFileQueue())) return FALSE;\newline        info.queue      = queue;\newline        info.src_root   = src_root;\newline        info.copy_flags = copy_flags;\newline        info.layout     = hinf;\newline        ret = (iterate_section_fields( hinf, section, CopyFiles, copy_files_callback, &ampinfo ) &amp&amp\newline               iterate_section_fields( hinf, section, DelFiles, delete_files_callback, &ampinfo ) &amp&amp\newline               iterate_section_fields( hinf, section, RenFiles, rename_files_callback, &ampinfo ) &amp&amp\newline               SetupCommitFileQueueW( owner, queue, callback, context ));\newline        SetupCloseFileQueue( queue );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_INIFILES)\newline    {\newline        if (!iterate_section_fields( hinf, section, UpdateInis, update_ini_callback, NULL ) ||\newline            !iterate_section_fields( hinf, section, UpdateIniFields,\newline                                     update_ini_fields_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_INI2REG)\newline    {\newline        if (!iterate_section_fields( hinf, section, Ini2Reg, ini2reg_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_LOGCONFIG)\newline    {\newline        if (!iterate_section_fields( hinf, section, LogConf, logconf_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_REGSVR)\newline    {\newline        struct register_dll_info info;\newline\newline        info.unregister    = FALSE;\newline        info.modules_size  = 0;\newline        info.modules_count = 0;\newline        info.modules       = NULL;\newline        if (flags &amp SPINST_REGISTERCALLBACKAWARE)\newline        {\newline            info.callback         = callback;\newline            info.callback_context = context;\newline        }\newline        else info.callback = NULL;\newline\newline        if (iterate_section_fields( hinf, section, WineFakeDlls, fake_dlls_callback, NULL ))\newline            cleanup_fake_dlls();\newline        else\newline            return FALSE;\newline\newline        ret = iterate_section_fields( hinf, section, RegisterDlls, register_dlls_callback, &ampinfo );\newline        for (i = 0; i &lt info.modules_count; i++) FreeLibrary( info.modules[i] );\newline        HeapFree( GetProcessHeap(), 0, info.modules );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_UNREGSVR)\newline    {\newline        struct register_dll_info info;\newline\newline        info.unregister    = TRUE;\newline        info.modules_size  = 0;\newline        info.modules_count = 0;\newline        info.modules       = NULL;\newline        if (flags &amp SPINST_REGISTERCALLBACKAWARE)\newline        {\newline            info.callback         = callback;\newline            info.callback_context = context;\newline        }\newline        else info.callback = NULL;\newline\newline        ret = iterate_section_fields( hinf, section, UnregisterDlls, register_dlls_callback, &ampinfo );\newline        for (i = 0; i &lt info.modules_count; i++) FreeLibrary( info.modules[i] );\newline        HeapFree( GetProcessHeap(), 0, info.modules );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_REGISTRY)\newline    {\newline        struct registry_callback_info info;\newline\newline        info.default_root = key_root;\newline        info.delete = TRUE;\newline        if (!iterate_section_fields( hinf, section, DelReg, registry_callback, &ampinfo ))\newline            return FALSE;\newline        info.delete = FALSE;\newline        if (!iterate_section_fields( hinf, section, AddReg, registry_callback, &ampinfo ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_BITREG)\newline    {\newline        if (!iterate_section_fields( hinf, section, BitReg, bitreg_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_PROFILEITEMS)\newline    {\newline        if (!iterate_section_fields( hinf, section, ProfileItems, profile_items_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_COPYINF)\newline    {\newline        if (!iterate_section_fields( hinf, section, CopyINF, copy_inf_callback, NULL ))\newline            return FALSE;\newline    }\newline\newline    return TRUE;\newline}\newline","\newline SetupInstallFromInfSectionW (SETUPAPI.@)\newline \newline","2840973","mgrutil.c","SML_API SmlPcdataPtr_t smlPcdataDup(SmlPcdataPtr_t pcdata)\newline{\newline  /* Definitions */\newline  SmlPcdataPtr_t newPcdata;\newline\newline  /* Invalid Input */\newline  if (! pcdata)\newline    return NULL;\newline\newline  /* Allocate the new pcdata memory object */\newline  newPcdata = (SmlPcdataPtr_t)smlLibMalloc((MemSize_t)sizeof(SmlPcdata_t));\newline  if (! newPcdata)\newline    return NULL;\newline  smlLibMemset (newPcdata, 0, (MemSize_t)sizeof(SmlPcdata_t));\newline\newline  /* Set the PcData Structure */\newline  newPcdata-&gtcontentType = pcdata-&gtcontentType;\newline  newPcdata-&gtlength = pcdata-&gtlength;\newline  newPcdata-&gtcontent =(VoidPtr_t)smlLibMalloc((MemSize_t)pcdata-&gtlength+1);\newline  if (newPcdata-&gtcontent ==NULL)\newline  {\newline      smlLibFree(newPcdata-&gtcontent);\newline        smlLibFree(newPcdata);\newline        return NULL;\newline  }\newline  smlLibMemset(newPcdata-&gtcontent, 0, (MemSize_t)((pcdata-&gtlength)+1));\newline  smlLibMemcpy(newPcdata-&gtcontent, pcdata-&gtcontent, (MemSize_t)pcdata-&gtlength);\newline\newline  return newPcdata;\newline}\newline","\newline Duplicates a Pcdata memory object\newline \newline @param pcdata (IN)\newline A Pointer to the original PcData structure\newline @return A Pointer to the copy of the PcData structure\newline \newline","733408","io.c","static void sig_int(int signo)\newline{\newline	/** Return I/O streams to a default state before exiting. */\newline	fdEnd(io.in);\newline	fdEnd(io.out);\newline	exit(1);\newline}\newline","A signal handler for control-C.\newline \newline \\param signo The signal number.\newline \newline","2905418","3dinterface.h","inline GLMATRIX *set_matrix_texture(int num, GLMATRIX * p_text)\newline{\newline  glMatrixMode(GL_TEXTURE);\newline  glLoadMatrixf((float *) p_text);\newline  __mat_text[num] = TRUE;\newline  return (p_text);\newline}\newline","Low-level matice\newline \newline","998696","quality.h","static BROTLI_INLINE size_t MaxZopfliCandidates(\newline  const BrotliEncoderParams* params) {\newline  return params-&gtquality &lt= 10 ? 1 : 5;\newline}\newline","Number of best candidates to evaluate to expand Zopfli chain. \newline","4367430","h5diff_array.c","static hsize_t diff_int(unsigned char *mem1,\newline                 unsigned char *mem2,\newline                 hsize_t       nelmts,\newline                 hsize_t       hyper_start,\newline                 int           rank,\newline                 hsize_t       *dims,\newline                 hsize_t       *acc,\newline                 hsize_t       *pos,\newline                 diff_opt_t    *options,\newline                 const char    *obj1,\newline                 const char    *obj2,\newline                 int           *ph)\newline\newline{\newline hsize_t       nfound=0;          /* number of differences found */\newline int           temp1_int;\newline int           temp2_int;\newline hsize_t       i;\newline double        per;\newline hbool_t       both_zero;\newline\newline h5difftrace(&quotdiff_int start\\n&quot);\newline /* -d and !-p */\newline if (options-&gtd &amp&amp !options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         if (ABS(temp1_int-temp2_int) &gt options-&gtdelta)\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,0,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT,temp1_int,temp2_int,ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline         mem1+=sizeof(int);\newline         mem2+=sizeof(int);\newline         if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline             return nfound;\newline     }\newline\newline }\newline\newline /* !-d and -p */\newline else if (!options-&gtd &amp&amp options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         PER(temp1_int,temp2_int);\newline\newline         if (not_comparable &amp&amp !both_zero) /* not comparable */\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT_P_NOTCOMP,temp1_int,temp2_int,\newline                     ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         else\newline\newline             if ( per &gt options-&gtpercent )\newline             {\newline                 if ( print_data(options) )\newline                 {\newline                     print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                     parallel_print(SPACES);\newline                     parallel_print(I_FORMAT_P,temp1_int,temp2_int,\newline                         ABS(temp1_int-temp2_int),\newline                         per);\newline                 }\newline                 nfound++;\newline             }\newline             mem1+=sizeof(int);\newline             mem2+=sizeof(int);\newline             if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline                 return nfound;\newline     }\newline\newline\newline }\newline\newline /* -d and -p */\newline else if ( options-&gtd &amp&amp options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         PER(temp1_int,temp2_int);\newline\newline         if (not_comparable &amp&amp !both_zero) /* not comparable */\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT_P_NOTCOMP,temp1_int,temp2_int,\newline                     ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         else\newline\newline             if ( per &gt options-&gtpercent &amp&amp ABS(temp1_int-temp2_int) &gt options-&gtdelta )\newline             {\newline                 if ( print_data(options) )\newline                 {\newline                     print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                     parallel_print(SPACES);\newline                     parallel_print(I_FORMAT_P,temp1_int,temp2_int,\newline                         ABS(temp1_int-temp2_int),\newline                         per);\newline                 }\newline                 nfound++;\newline             }\newline             mem1+=sizeof(int);\newline             mem2+=sizeof(int);\newline             if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline                 return nfound;\newline     }\newline\newline }\newline else\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         if (temp1_int != temp2_int)\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,0,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT,temp1_int,temp2_int,ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         mem1+=sizeof(int);\newline         mem2+=sizeof(int);\newline         if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline             return nfound;\newline     } /* nelmts */\newline\newline }\newline h5difftrace(&quotdiff_int finish\\n&quot);\newline\newline return nfound;\newline}\newline","-------------------------------------------------------------------------\newline Function: diff_int\newline \newline Purpose: diff a H5T_NATIVE_INT type\newline \newline Return: number of differences found\newline \newline -------------------------------------------------------------------------\newline \newline","2130828","api.c","GSM_Error GSM_GetManufactureMonth(GSM_StateMachine *s, char *value)\newline{\newline	GSM_Error err;\newline\newline	CHECK_PHONE_CONNECTION();\newline\newline	err = s-&gtPhone.Functions-&gtGetManufactureMonth(s, value);\newline	PRINT_LOG_ERROR(err);\newline	return err;\newline}\newline","\newline Gets month when device was manufactured.\newline \newline","1305670","ceph.c","static int compact_ds_name(char *buffer, size_t buffer_size, char const *src) {\newline  char *src_copy;\newline  size_t src_len;\newline  char *ptr = buffer;\newline  size_t ptr_size = buffer_size;\newline  _Bool append_plus = 0;\newline  _Bool append_minus = 0;\newline\newline  if ((buffer == NULL) || (buffer_size &lt= strlen(&quotMinus&quot)) || (src == NULL))\newline    return EINVAL;\newline\newline  src_copy = strdup(src);\newline  src_len = strlen(src);\newline\newline  /* Remove trailing &quot+&quot and &quot-&quot. */\newline  if (src_copy[src_len - 1] == &#039+&#039) {\newline    append_plus = 1;\newline    src_len--;\newline    src_copy[src_len] = 0;\newline  } else if (src_copy[src_len - 1] == &#039-&#039) {\newline    append_minus = 1;\newline    src_len--;\newline    src_copy[src_len] = 0;\newline  }\newline\newline  /* Split at special chars, capitalize first character, append to buffer. */\newline  char *dummy = src_copy;\newline  char *token;\newline  char *save_ptr = NULL;\newline  while ((token = strtok_r(dummy, &quot:_-+&quot, &ampsave_ptr)) != NULL) {\newline    size_t len;\newline\newline    dummy = NULL;\newline\newline    token[0] = toupper((int)token[0]);\newline\newline    assert(ptr_size &gt 1);\newline\newline    len = strlen(token);\newline    if (len &gt= ptr_size)\newline      len = ptr_size - 1;\newline\newline    assert(len &gt 0);\newline    assert(len &lt ptr_size);\newline\newline    sstrncpy(ptr, token, len + 1);\newline    ptr += len;\newline    ptr_size -= len;\newline\newline    assert(*ptr == 0);\newline    if (ptr_size &lt= 1)\newline      break;\newline  }\newline\newline  /* Append &quotPlus&quot or &quotMinus&quot if &quot+&quot or &quot-&quot has been stripped above. */\newline  if (append_plus || append_minus) {\newline    char const *append = &quotPlus&quot;\newline    if (append_minus)\newline      append = &quotMinus&quot;\newline\newline    size_t offset = buffer_size - (strlen(append) + 1);\newline    if (offset &gt strlen(buffer))\newline      offset = strlen(buffer);\newline\newline    sstrncpy(buffer + offset, append, buffer_size - offset);\newline  }\newline\newline  sfree(src_copy);\newline  return 0;\newline}\newline","compact_ds_name removed the special characters &quot:&quot, &quot_&quot, &quot-&quot and &quot+&quot from the\newline intput string. Characters following these special characters are capitalized.\newline Trailing &quot+&quot and &quot-&quot characters are replaces with the strings &quotPlus&quot and\newline &quotMinus&quot. \newline","1083980","demux_matroska.c","static int parse_top_level_head(demux_matroska_t *this, int *next_level) {\newline  ebml_parser_t *ebml = this-&gtebml;\newline  ebml_elem_t elem;\newline  int ret_value = 1;\newline  off_t current_pos;\newline\newline\newline  current_pos = this-&gtinput-&gtget_current_pos(this-&gtinput);\newline  lprintf(&quotcurrent_pos: %&quot PRIdMAX &quot\\n&quot, (intmax_t)current_pos);\newline\newline  if (!ebml_read_elem_head(ebml, &ampelem))\newline    return 0;\newline\newline  if (!find_top_level_entry(this, current_pos)) {\newline\newline    if (!add_top_level_entry(this, current_pos))\newline      return 0;\newline\newline    switch (elem.id) {\newline      case MATROSKA_ID_SEEKHEAD:\newline        lprintf(&quotSeekHead\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_seekhead(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_INFO:\newline        lprintf(&quotInfo\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_info(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_TRACKS:\newline        lprintf(&quotTracks\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_tracks(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_CHAPTERS:\newline        lprintf(&quotChapters\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !matroska_parse_chapters(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_CLUSTER:\newline        lprintf(&quotCluster\\n&quot);\newline        if (!ebml_skip(ebml, &ampelem))\newline          return 0;\newline        ret_value = 2;\newline        break;\newline      case MATROSKA_ID_CUES:\newline        lprintf(&quotCues\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_cues(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_ATTACHMENTS:\newline        lprintf(&quotAttachments\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_attachments(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_TAGS:\newline        lprintf(&quotTags\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_tags(this))\newline          return 0;\newline        break;\newline      default:\newline        lprintf(&quotunknown top_level ID: 0x%x\\n&quot, elem.id);\newline        if (!ebml_skip(ebml, &ampelem))\newline          return 0;\newline    }\newline  } else {\newline    lprintf(&quottop_level entry already parsed, ID: 0x%x\\n&quot, elem.id);\newline    if (!ebml_skip(ebml, &ampelem))\newline      return 0;\newline  }\newline\newline  if (next_level)\newline    *next_level = ebml_get_next_level(ebml, &ampelem);\newline\newline  return ret_value;\newline}\newline","\newline Function used to parse a top level when opening the file.\newline It does&#039nt parse clusters.\newline retuned value:\newline 0: error\newline 1: ok\newline 2: cluster\newline \newline","2643688","type2str.c","TIEXPORT1 CableModel TICALL ticables_string_to_model(const char *str)\newline{\newline	if (str == NULL)\newline	{\newline		ticables_critical(&quot%s(NULL)&quot, __FUNCTION__);\newline		return CABLE_NUL;\newline	}\newline\newline	if(!g_ascii_strcasecmp(str, &quotnull&quot))\newline		return CABLE_NUL;\newline	else if(!g_ascii_strcasecmp(str, &quotGrayLink&quot))\newline		return CABLE_GRY;\newline	else if(!g_ascii_strcasecmp(str, &quotBlackLink&quot))\newline		return CABLE_BLK;\newline	else if(!g_ascii_strcasecmp(str, &quotParallel&quot))\newline		return CABLE_PAR;\newline	else if(!g_ascii_strcasecmp(str, &quotSilverLink&quot))\newline		return CABLE_SLV;\newline	else if(!g_ascii_strcasecmp(str, &quotDirectLink&quot))\newline		return CABLE_USB;\newline	else if(!g_ascii_strcasecmp(str, &quotVTi&quot))\newline		return CABLE_VTI;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTilEm&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu/TilEm&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotlinkport&quot))\newline		return CABLE_ILP;\newline	else if(!g_ascii_strcasecmp(str, &quotUsbKernel&quot))\newline		return CABLE_DEV;\newline\newline	return CABLE_NUL;\newline}\newline","\newline ticables_string_to_model:\newline @str: a cable model as string like &quotBlackLink&quot.\newline \newline Do a string to integer conversion.\newline \newline Return value: a cable model.\newline \newline","5842565","addr.c","void libsieve_addrerror(char *msg)\newline{\newline    libsieve_parse_context-&gtexec_errors++;\newline\newline    libsieve_do_error_address(libsieve_parse_context, msg);\newline}\newline","Run an execution error callback. \newline","","","on","","","on","","","","","","on","","","","","on","","","on","","","","","","","","","","","on","","","","","","","","","","","","invoked when clients do not react duringshutdown.","Set the pen color used for painting the text.","{}","Duplicates a Pcdata memory object","A signal handler for control-C.","{}","Number of best candidates to evaluate to expand Zopfli chain.","diff a H5T_NATIVE_INT type","Gets month when device was manufactured.","removed the special characters","parse a top level when opening the file.","{}","string to integer conversion.","Run an execution error callback.","Check for dm-raid target supporting raid4 conversion properly.","close the device and check for error","{}","Check if domain is local","Wait for any of the processes in the group to complete.","{}","Opens the first audio stream of the named file."
"3MXX6RQ9EV5RCVQ7OKSJH3I6Y8DP44","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3Z2R0DQ0JHEFZAJN1UYLJVITGBTE2U","AW7Q22H68DVQ8","Approved","Wed Apr 17 15:03:42 PDT 2019","Wed Apr 17 15:11:02 PDT 2019","Fri Apr 19 15:11:02 PDT 2019","2019-04-19 22:11:21 UTC","","","440","100% (1/1)","100% (1/1)","100% (1/1)","295849","shutdown.cpp","void KSMServer::protectionTimeout()\newline{\newline    if ( ( state != Shutdown &amp&amp state != Checkpoint &amp&amp state != ClosingSubSession ) || clientInteracting )\newline        return;\newline\newline    foreach( KSMClient* c, clients ) {\newline        if ( !c-&gtsaveYourselfDone &amp&amp !c-&gtwaitForPhase2 ) {\newline            qCDebug(KSMSERVER) &lt&lt &quotprotectionTimeout: client &quot &lt&lt c-&gtprogram() &lt&lt &quot(&quot &lt&lt c-&gtclientId() &lt&lt &quot)&quot;\newline            c-&gtsaveYourselfDone = true;\newline        }\newline    }\newline    completeShutdownOrCheckpoint();\newline    startProtection();\newline}\newline","\newlineInternal protection slot, invoked when clients do not react during\newlineshutdown.\newline \newline","102931","blake2b-ref.c","int blake2b_init_param( blake2b_state *S, const blake2b_param *P )\newline{\newline  blake2b_init0( S );\newline  uint8_t *p = ( uint8_t * )( P );\newline\newline  /* IV XOR ParamBlock */\newline  for( size_t i = 0; i &lt 8; ++i )\newline    S-&gth[i] ^= load64( p + sizeof( S-&gth[i] ) * i );\newline\newline  S-&gtoutlen = P-&gtdigest_length;\newline  return 0;\newline}\newline","init xors IV with input parameter block \newline","774968","lvconvert.c","static int _raid4_conversion_supported(struct logical_volume *lv, struct lvconvert_params *lp)\newline{\newline	int ret = 1;\newline	struct lv_segment *seg = first_seg(lv);\newline\newline	if (seg_is_raid4(seg))\newline		ret = raid4_is_supported(lv-&gtvg-&gtcmd, seg-&gtsegtype);\newline	else if (segtype_is_raid4(lp-&gtsegtype))\newline		ret = raid4_is_supported(lv-&gtvg-&gtcmd, lp-&gtsegtype);\newline\newline	if (ret)\newline		return 1;\newline\newline	log_error(&quotCannot convert %s LV %s to %s.&quot,\newline		  lvseg_name(seg), display_lvname(lv), lp-&gtsegtype-&gtname);\newline	return 0;\newline}\newline","Check for dm-raid target supporting raid4 conversion properly. \newline","2072636","wd_keepalive.c","static void close_all(void)\newline{\newline	close_watchdog();\newline}\newline","close the device and check for error \newline","4945851","field.c","double fdisk_field_get_width(const struct fdisk_field *field)\newline{\newline	return field ? field-&gtwidth : -EINVAL;\newline}\newline","\newline fdisk_field_get_width:\newline @field: field instance\newline \newline Returns: libsmartcols compatible width.\newline \newline","4479207","domain.c","int is_domain_local_pvar(struct sip_msg *msg, str* _host, char *pvar)\newline{\newline	pv_spec_t *pv = (pv_spec_t *)pvar;\newline	pv_value_t val;\newline	db_val_t *values;\newline\newline	if (db_mode == 0) {\newline		db_key_t keys[1];\newline		db_val_t vals[1];\newline		db_key_t cols[2];\newline		db_res_t* res = NULL;\newline\newline		keys[0] = &ampdomain_col;\newline		cols[0] = &ampdomain_col;\newline		cols[1] = &ampdomain_attrs_col;\newline\newline		if (domain_dbf.use_table(db_handle, &ampdomain_table) &lt 0) {\newline			LM_ERR(&quotError while trying to use domain table\\n&quot);\newline			return -3;\newline		}\newline\newline		VAL_TYPE(vals) = DB_STR;\newline		VAL_NULL(vals) = 0;\newline\newline		VAL_STR(vals).s = _host-&gts;\newline		VAL_STR(vals).len = _host-&gtlen;\newline\newline		if (domain_dbf.query(db_handle, keys, 0, vals, cols, 1, 2, 0, &ampres) &lt 0\newline				) {\newline			LM_ERR(&quotError while querying database\\n&quot);\newline			return -3;\newline		}\newline\newline		if (RES_ROW_N(res) == 0) {\newline			LM_DBG(&quotRealm &#039%.*s&#039 is not local\\n&quot,\newline			       _host-&gtlen, ZSW(_host-&gts));\newline			domain_dbf.free_result(db_handle, res);\newline			return -1;\newline		} else {\newline			LM_DBG(&quotRealm &#039%.*s&#039 is local\\n&quot,\newline			       _host-&gtlen, ZSW(_host-&gts));\newline			if (pvar) {\newline				/* XXX: what shall we do if there are duplicate entries? */\newline				/* we only check the first row - razvanc */\newline				values = ROW_VALUES(RES_ROWS(res));\newline				if (!VAL_NULL(values +1)) {\newline					if (VAL_TYPE(values + 1) == DB_STR) {\newline						val.rs = VAL_STR(values + 1);\newline					} else {\newline						val.rs.s = (char *)VAL_STRING(values + 1);\newline						val.rs.len = strlen(val.rs.s);\newline					}\newline					val.flags = PV_VAL_STR;\newline					if (pv_set_value(msg, pv, 0, &ampval) != 0)\newline						LM_ERR(&quotCannot set attributes value\\n&quot);\newline				}\newline			}\newline			domain_dbf.free_result(db_handle, res);\newline			return 1;\newline		}\newline	} else {\newline		return hash_table_lookup (msg, _host, pv);\newline	}\newline\newline}\newline","\newline Check if domain is local and store attributes in a pvar\newline \newline","3280051","omake_shell_sys.c","static value omake_shell_sys_wait_aux(value v_pgrp, value v_leader, value v_nohang)\newline{\newline    CAMLparam3(v_pgrp, v_leader, v_nohang);\newline    CAMLlocal3(list, tuple, status);\newline    int processes[MAXIMUM_WAIT_OBJECTS];\newline    HANDLE handles[MAXIMUM_WAIT_OBJECTS];\newline    Process **processpp, *processp;\newline    int ncount, code, pid, pgrp, leader;\newline    DWORD exitcode, timeout, index;\newline\newline#ifdef OSH_DEBUG\newline    fprintf(stderr, &quotomake_shell_sys_wait\\n&quot);\newline    fflush(stderr);\newline#endif\newline\newline    /* Parameters */\newline    pgrp = Int_val(v_pgrp);\newline    leader = Int_val(v_leader);\newline    timeout = Int_val(v_nohang) ? 0 : INFINITE;\newline\newline    /* Collect the processes and their handles */\newline    ncount = 1;\newline    handles[0] = state-&gtchanged;\newline    for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline        if((pgrp &amp&amp processp-&gtpgrp != pgrp)\newline           || (pgrp == 0 &amp&amp processp-&gtpgrp == INIT_PID)\newline           || (leader &amp&amp processp-&gtpid != processp-&gtpgrp)\newline           || (leader == 0 &amp&amp processp-&gtpid == processp-&gtpgrp)) {\newline            continue;\newline        }\newline        else if(processp-&gtchanged)\newline            CAMLreturn(handle_wait(&quotchanged&quot, processpp));\newline        else {\newline            if(ncount == MAXIMUM_WAIT_OBJECTS)\newline                invalid_argument(&quotomake_shell_sys_wait: too many processes&quot);\newline            processes[ncount] = processp-&gtpid;\newline            handles[ncount] = processp-&gthandle;\newline            ncount++;\newline        }\newline    }\newline\newline#ifdef OSH_DEBUG\newline    fprintf(stderr, &quotomake_shell_sys_wait: waiting for %d events\\n&quot, ncount);\newline    fprintf(stderr, &quot\\tpgrp = %d, leader = %d, timeout = %d\\n&quot, pgrp, leader, timeout);\newline    fflush(stderr);\newline#endif\newline\newline    /* Wait for an event */\newline    while(1) {\newline        /* Perform the wait */\newline        enter_blocking_section();\newline        index = WaitForMultipleObjects(ncount, handles, FALSE, timeout);\newline        if(index == WAIT_FAILED)\newline            code = GetLastError();\newline        leave_blocking_section();\newline\newline        /* See if something has changed */\newline        if(index == WAIT_OBJECT_0) {\newline            for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline                if(processp-&gtpgrp == pgrp &amp&amp processp-&gtchanged)\newline                    CAMLreturn(handle_wait(&quotstate changed&quot, processpp));\newline            }\newline        }\newline        else\newline            break;\newline    }\newline\newline    /* Get the index of the event */\newline    if(index &gt= WAIT_OBJECT_0 + 1 &amp&amp index &lt WAIT_OBJECT_0 + ncount)\newline        index -= WAIT_OBJECT_0;\newline    else if(index &gt= WAIT_ABANDONED_0 + 1 &amp&amp index &lt WAIT_ABANDONED_0 + ncount)\newline        index -= WAIT_ABANDONED_0;\newline    else\newline        raise_not_found();\newline\newline    /* Adjust process */\newline    pid = processes[index];\newline    for(processpp = &ampstate-&gtprocesses; processp = *processpp; processpp = &amp(*processpp)-&gtnext) {\newline        if(processp-&gtpid == pid)\newline            break;\newline    }\newline\newline    /* If the process is not found, some other thread waited for it */\newline    if(processp == 0)\newline        CAMLreturn((value) 0);\newline\newline    /* Otherwise, handle the wait */\newline    processp-&gtchanged = 1;\newline    processp-&gtstatus = STATUS_EXITED;\newline\newline    /* Get the return code */\newline    if(processp-&gtis_thread == 0) {\newline        if(GetExitCodeProcess(handles[index], &ampexitcode) == FALSE)\newline            exitcode = 111;\newline        processp-&gtcode = exitcode;\newline    }\newline\newline    /* Return the value */\newline    CAMLreturn(handle_wait(&quotdone&quot, processpp));\newline}\newline","\newline Wait for any of the processes in the group to complete.\newline There are several modes:\newline pgrp == 0: wait for any process group leader\newline pgrp &lt&gt 0: wait for a specific process group\newline leader: if true, wait only for the group leader\newline if false, wait only for the children\newline nohang: if true, don&#039t block\newline \newline","3839574","hidparser.c","HIDData_t *FindObject_with_ID(HIDDesc_t *pDesc, uint8_t ReportID, uint8_t Offset, uint8_t Type)\newline{\newline	int	i;\newline\newline	for (i = 0; i &lt pDesc-&gtnitems; i++) {\newline		HIDData_t *pData = &amppDesc-&gtitem[i];\newline		\newline		if (pData-&gtReportID != ReportID) {\newline			continue;\newline		}\newline		\newline		if (pData-&gtType != Type) {\newline			continue;\newline		}\newline \newline		if (pData-&gtOffset != Offset) {\newline			continue;\newline		}\newline		\newline		return pData;\newline	}\newline	\newline	return NULL;\newline}\newline","\newline FindObject_with_ID\newline Get pData item with given ReportID, Offset, and Type. Return NULL\newline if not found.\newline -------------------------------------------------------------------------- \newline","1101031","alstream.c","static int OpenPlayerFile(StreamPlayer *player, const char *filename)\newline{\newline    ClosePlayerFile(player);\newline\newline    /* Open the file and get the first stream from it */\newline    player-&gtfile = openAudioFile(filename, BUFFER_TIME_MS);\newline    if(!player-&gtfile)\newline    {\newline        fprintf(stderr, &quotCould not open audio in %s\\n&quot, filename);\newline        goto error;\newline    }\newline\newline    /* Get the stream format, and figure out the OpenAL format */\newline    if(getAudioInfo(player-&gtfile, &ampplayer-&gtrate, &ampplayer-&gtchannels, &ampplayer-&gttype) != 0)\newline    {\newline        fprintf(stderr, &quotError getting audio info for %s\\n&quot, filename);\newline        goto error;\newline    }\newline\newline    player-&gtformat = GetFormat(player-&gtchannels, player-&gttype, alIsBufferFormatSupportedSOFT);\newline    if(player-&gtformat == 0)\newline    {\newline        fprintf(stderr, &quotUnsupported format (%s, %s) for %s\\n&quot,\newline                ChannelsName(player-&gtchannels), TypeName(player-&gttype),\newline                filename);\newline        goto error;\newline    }\newline\newline    return 1;\newline\newlineerror:\newline    closeAudioFile(player-&gtfile);\newline    player-&gtfile = NULL;\newline\newline    return 0;\newline}\newline","Opens the first audio stream of the named file. If a file is already open,\newline it will be closed first. \newline","3067420","qwt_text.cpp","void QwtText::setColor(const QColor &ampcolor) \newline{ \newline    d_data-&gtcolor = color; \newline    setPaintAttribute(PaintUsingTextColor);\newline}\newline","! \newlineSet the pen color used for painting the text.\newline\\param color Color\newline\\note Setting the color might have no effect, when\newlinethe text contains control sequences for setting colors.\newline \newline","5388337","install.c","BOOL WINAPI SetupInstallFromInfSectionW( HWND owner, HINF hinf, PCWSTR section, UINT flags,\newline                                         HKEY key_root, PCWSTR src_root, UINT copy_flags,\newline                                         PSP_FILE_CALLBACK_W callback, PVOID context,\newline                                         HDEVINFO devinfo, PSP_DEVINFO_DATA devinfo_data )\newline{\newline    BOOL ret;\newline    int i;\newline\newline    if (flags &amp SPINST_REGISTRY)\newline    {\newline        struct registry_callback_info info;\newline\newline        info.default_root = key_root;\newline        info.delete = FALSE;\newline        if (!iterate_section_fields( hinf, section, WinePreInstall, registry_callback, &ampinfo ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_FILES)\newline    {\newline        struct files_callback_info info;\newline        HSPFILEQ queue;\newline\newline        if (!(queue = SetupOpenFileQueue())) return FALSE;\newline        info.queue      = queue;\newline        info.src_root   = src_root;\newline        info.copy_flags = copy_flags;\newline        info.layout     = hinf;\newline        ret = (iterate_section_fields( hinf, section, CopyFiles, copy_files_callback, &ampinfo ) &amp&amp\newline               iterate_section_fields( hinf, section, DelFiles, delete_files_callback, &ampinfo ) &amp&amp\newline               iterate_section_fields( hinf, section, RenFiles, rename_files_callback, &ampinfo ) &amp&amp\newline               SetupCommitFileQueueW( owner, queue, callback, context ));\newline        SetupCloseFileQueue( queue );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_INIFILES)\newline    {\newline        if (!iterate_section_fields( hinf, section, UpdateInis, update_ini_callback, NULL ) ||\newline            !iterate_section_fields( hinf, section, UpdateIniFields,\newline                                     update_ini_fields_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_INI2REG)\newline    {\newline        if (!iterate_section_fields( hinf, section, Ini2Reg, ini2reg_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_LOGCONFIG)\newline    {\newline        if (!iterate_section_fields( hinf, section, LogConf, logconf_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_REGSVR)\newline    {\newline        struct register_dll_info info;\newline\newline        info.unregister    = FALSE;\newline        info.modules_size  = 0;\newline        info.modules_count = 0;\newline        info.modules       = NULL;\newline        if (flags &amp SPINST_REGISTERCALLBACKAWARE)\newline        {\newline            info.callback         = callback;\newline            info.callback_context = context;\newline        }\newline        else info.callback = NULL;\newline\newline        if (iterate_section_fields( hinf, section, WineFakeDlls, fake_dlls_callback, NULL ))\newline            cleanup_fake_dlls();\newline        else\newline            return FALSE;\newline\newline        ret = iterate_section_fields( hinf, section, RegisterDlls, register_dlls_callback, &ampinfo );\newline        for (i = 0; i &lt info.modules_count; i++) FreeLibrary( info.modules[i] );\newline        HeapFree( GetProcessHeap(), 0, info.modules );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_UNREGSVR)\newline    {\newline        struct register_dll_info info;\newline\newline        info.unregister    = TRUE;\newline        info.modules_size  = 0;\newline        info.modules_count = 0;\newline        info.modules       = NULL;\newline        if (flags &amp SPINST_REGISTERCALLBACKAWARE)\newline        {\newline            info.callback         = callback;\newline            info.callback_context = context;\newline        }\newline        else info.callback = NULL;\newline\newline        ret = iterate_section_fields( hinf, section, UnregisterDlls, register_dlls_callback, &ampinfo );\newline        for (i = 0; i &lt info.modules_count; i++) FreeLibrary( info.modules[i] );\newline        HeapFree( GetProcessHeap(), 0, info.modules );\newline        if (!ret) return FALSE;\newline    }\newline    if (flags &amp SPINST_REGISTRY)\newline    {\newline        struct registry_callback_info info;\newline\newline        info.default_root = key_root;\newline        info.delete = TRUE;\newline        if (!iterate_section_fields( hinf, section, DelReg, registry_callback, &ampinfo ))\newline            return FALSE;\newline        info.delete = FALSE;\newline        if (!iterate_section_fields( hinf, section, AddReg, registry_callback, &ampinfo ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_BITREG)\newline    {\newline        if (!iterate_section_fields( hinf, section, BitReg, bitreg_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_PROFILEITEMS)\newline    {\newline        if (!iterate_section_fields( hinf, section, ProfileItems, profile_items_callback, NULL ))\newline            return FALSE;\newline    }\newline    if (flags &amp SPINST_COPYINF)\newline    {\newline        if (!iterate_section_fields( hinf, section, CopyINF, copy_inf_callback, NULL ))\newline            return FALSE;\newline    }\newline\newline    return TRUE;\newline}\newline","\newline SetupInstallFromInfSectionW (SETUPAPI.@)\newline \newline","2840973","mgrutil.c","SML_API SmlPcdataPtr_t smlPcdataDup(SmlPcdataPtr_t pcdata)\newline{\newline  /* Definitions */\newline  SmlPcdataPtr_t newPcdata;\newline\newline  /* Invalid Input */\newline  if (! pcdata)\newline    return NULL;\newline\newline  /* Allocate the new pcdata memory object */\newline  newPcdata = (SmlPcdataPtr_t)smlLibMalloc((MemSize_t)sizeof(SmlPcdata_t));\newline  if (! newPcdata)\newline    return NULL;\newline  smlLibMemset (newPcdata, 0, (MemSize_t)sizeof(SmlPcdata_t));\newline\newline  /* Set the PcData Structure */\newline  newPcdata-&gtcontentType = pcdata-&gtcontentType;\newline  newPcdata-&gtlength = pcdata-&gtlength;\newline  newPcdata-&gtcontent =(VoidPtr_t)smlLibMalloc((MemSize_t)pcdata-&gtlength+1);\newline  if (newPcdata-&gtcontent ==NULL)\newline  {\newline      smlLibFree(newPcdata-&gtcontent);\newline        smlLibFree(newPcdata);\newline        return NULL;\newline  }\newline  smlLibMemset(newPcdata-&gtcontent, 0, (MemSize_t)((pcdata-&gtlength)+1));\newline  smlLibMemcpy(newPcdata-&gtcontent, pcdata-&gtcontent, (MemSize_t)pcdata-&gtlength);\newline\newline  return newPcdata;\newline}\newline","\newline Duplicates a Pcdata memory object\newline \newline @param pcdata (IN)\newline A Pointer to the original PcData structure\newline @return A Pointer to the copy of the PcData structure\newline \newline","733408","io.c","static void sig_int(int signo)\newline{\newline	/** Return I/O streams to a default state before exiting. */\newline	fdEnd(io.in);\newline	fdEnd(io.out);\newline	exit(1);\newline}\newline","A signal handler for control-C.\newline \newline \\param signo The signal number.\newline \newline","2905418","3dinterface.h","inline GLMATRIX *set_matrix_texture(int num, GLMATRIX * p_text)\newline{\newline  glMatrixMode(GL_TEXTURE);\newline  glLoadMatrixf((float *) p_text);\newline  __mat_text[num] = TRUE;\newline  return (p_text);\newline}\newline","Low-level matice\newline \newline","998696","quality.h","static BROTLI_INLINE size_t MaxZopfliCandidates(\newline  const BrotliEncoderParams* params) {\newline  return params-&gtquality &lt= 10 ? 1 : 5;\newline}\newline","Number of best candidates to evaluate to expand Zopfli chain. \newline","4367430","h5diff_array.c","static hsize_t diff_int(unsigned char *mem1,\newline                 unsigned char *mem2,\newline                 hsize_t       nelmts,\newline                 hsize_t       hyper_start,\newline                 int           rank,\newline                 hsize_t       *dims,\newline                 hsize_t       *acc,\newline                 hsize_t       *pos,\newline                 diff_opt_t    *options,\newline                 const char    *obj1,\newline                 const char    *obj2,\newline                 int           *ph)\newline\newline{\newline hsize_t       nfound=0;          /* number of differences found */\newline int           temp1_int;\newline int           temp2_int;\newline hsize_t       i;\newline double        per;\newline hbool_t       both_zero;\newline\newline h5difftrace(&quotdiff_int start\\n&quot);\newline /* -d and !-p */\newline if (options-&gtd &amp&amp !options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         if (ABS(temp1_int-temp2_int) &gt options-&gtdelta)\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,0,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT,temp1_int,temp2_int,ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline         mem1+=sizeof(int);\newline         mem2+=sizeof(int);\newline         if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline             return nfound;\newline     }\newline\newline }\newline\newline /* !-d and -p */\newline else if (!options-&gtd &amp&amp options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         PER(temp1_int,temp2_int);\newline\newline         if (not_comparable &amp&amp !both_zero) /* not comparable */\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT_P_NOTCOMP,temp1_int,temp2_int,\newline                     ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         else\newline\newline             if ( per &gt options-&gtpercent )\newline             {\newline                 if ( print_data(options) )\newline                 {\newline                     print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                     parallel_print(SPACES);\newline                     parallel_print(I_FORMAT_P,temp1_int,temp2_int,\newline                         ABS(temp1_int-temp2_int),\newline                         per);\newline                 }\newline                 nfound++;\newline             }\newline             mem1+=sizeof(int);\newline             mem2+=sizeof(int);\newline             if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline                 return nfound;\newline     }\newline\newline\newline }\newline\newline /* -d and -p */\newline else if ( options-&gtd &amp&amp options-&gtp)\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         PER(temp1_int,temp2_int);\newline\newline         if (not_comparable &amp&amp !both_zero) /* not comparable */\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT_P_NOTCOMP,temp1_int,temp2_int,\newline                     ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         else\newline\newline             if ( per &gt options-&gtpercent &amp&amp ABS(temp1_int-temp2_int) &gt options-&gtdelta )\newline             {\newline                 if ( print_data(options) )\newline                 {\newline                     print_pos(ph,1,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                     parallel_print(SPACES);\newline                     parallel_print(I_FORMAT_P,temp1_int,temp2_int,\newline                         ABS(temp1_int-temp2_int),\newline                         per);\newline                 }\newline                 nfound++;\newline             }\newline             mem1+=sizeof(int);\newline             mem2+=sizeof(int);\newline             if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline                 return nfound;\newline     }\newline\newline }\newline else\newline {\newline\newline     for ( i = 0; i &lt nelmts; i++)\newline     {\newline         HDmemcpy(&amptemp1_int, mem1, sizeof(int));\newline         HDmemcpy(&amptemp2_int, mem2, sizeof(int));\newline\newline         if (temp1_int != temp2_int)\newline         {\newline             if ( print_data(options) )\newline             {\newline                 print_pos(ph,0,hyper_start+i,acc,pos,rank,dims,obj1,obj2);\newline                 parallel_print(SPACES);\newline                 parallel_print(I_FORMAT,temp1_int,temp2_int,ABS(temp1_int-temp2_int));\newline             }\newline             nfound++;\newline         }\newline\newline         mem1+=sizeof(int);\newline         mem2+=sizeof(int);\newline         if (options-&gtn &amp&amp nfound&gt=options-&gtcount)\newline             return nfound;\newline     } /* nelmts */\newline\newline }\newline h5difftrace(&quotdiff_int finish\\n&quot);\newline\newline return nfound;\newline}\newline","-------------------------------------------------------------------------\newline Function: diff_int\newline \newline Purpose: diff a H5T_NATIVE_INT type\newline \newline Return: number of differences found\newline \newline -------------------------------------------------------------------------\newline \newline","2130828","api.c","GSM_Error GSM_GetManufactureMonth(GSM_StateMachine *s, char *value)\newline{\newline	GSM_Error err;\newline\newline	CHECK_PHONE_CONNECTION();\newline\newline	err = s-&gtPhone.Functions-&gtGetManufactureMonth(s, value);\newline	PRINT_LOG_ERROR(err);\newline	return err;\newline}\newline","\newline Gets month when device was manufactured.\newline \newline","1305670","ceph.c","static int compact_ds_name(char *buffer, size_t buffer_size, char const *src) {\newline  char *src_copy;\newline  size_t src_len;\newline  char *ptr = buffer;\newline  size_t ptr_size = buffer_size;\newline  _Bool append_plus = 0;\newline  _Bool append_minus = 0;\newline\newline  if ((buffer == NULL) || (buffer_size &lt= strlen(&quotMinus&quot)) || (src == NULL))\newline    return EINVAL;\newline\newline  src_copy = strdup(src);\newline  src_len = strlen(src);\newline\newline  /* Remove trailing &quot+&quot and &quot-&quot. */\newline  if (src_copy[src_len - 1] == &#039+&#039) {\newline    append_plus = 1;\newline    src_len--;\newline    src_copy[src_len] = 0;\newline  } else if (src_copy[src_len - 1] == &#039-&#039) {\newline    append_minus = 1;\newline    src_len--;\newline    src_copy[src_len] = 0;\newline  }\newline\newline  /* Split at special chars, capitalize first character, append to buffer. */\newline  char *dummy = src_copy;\newline  char *token;\newline  char *save_ptr = NULL;\newline  while ((token = strtok_r(dummy, &quot:_-+&quot, &ampsave_ptr)) != NULL) {\newline    size_t len;\newline\newline    dummy = NULL;\newline\newline    token[0] = toupper((int)token[0]);\newline\newline    assert(ptr_size &gt 1);\newline\newline    len = strlen(token);\newline    if (len &gt= ptr_size)\newline      len = ptr_size - 1;\newline\newline    assert(len &gt 0);\newline    assert(len &lt ptr_size);\newline\newline    sstrncpy(ptr, token, len + 1);\newline    ptr += len;\newline    ptr_size -= len;\newline\newline    assert(*ptr == 0);\newline    if (ptr_size &lt= 1)\newline      break;\newline  }\newline\newline  /* Append &quotPlus&quot or &quotMinus&quot if &quot+&quot or &quot-&quot has been stripped above. */\newline  if (append_plus || append_minus) {\newline    char const *append = &quotPlus&quot;\newline    if (append_minus)\newline      append = &quotMinus&quot;\newline\newline    size_t offset = buffer_size - (strlen(append) + 1);\newline    if (offset &gt strlen(buffer))\newline      offset = strlen(buffer);\newline\newline    sstrncpy(buffer + offset, append, buffer_size - offset);\newline  }\newline\newline  sfree(src_copy);\newline  return 0;\newline}\newline","compact_ds_name removed the special characters &quot:&quot, &quot_&quot, &quot-&quot and &quot+&quot from the\newline intput string. Characters following these special characters are capitalized.\newline Trailing &quot+&quot and &quot-&quot characters are replaces with the strings &quotPlus&quot and\newline &quotMinus&quot. \newline","1083980","demux_matroska.c","static int parse_top_level_head(demux_matroska_t *this, int *next_level) {\newline  ebml_parser_t *ebml = this-&gtebml;\newline  ebml_elem_t elem;\newline  int ret_value = 1;\newline  off_t current_pos;\newline\newline\newline  current_pos = this-&gtinput-&gtget_current_pos(this-&gtinput);\newline  lprintf(&quotcurrent_pos: %&quot PRIdMAX &quot\\n&quot, (intmax_t)current_pos);\newline\newline  if (!ebml_read_elem_head(ebml, &ampelem))\newline    return 0;\newline\newline  if (!find_top_level_entry(this, current_pos)) {\newline\newline    if (!add_top_level_entry(this, current_pos))\newline      return 0;\newline\newline    switch (elem.id) {\newline      case MATROSKA_ID_SEEKHEAD:\newline        lprintf(&quotSeekHead\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_seekhead(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_INFO:\newline        lprintf(&quotInfo\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_info(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_TRACKS:\newline        lprintf(&quotTracks\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_tracks(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_CHAPTERS:\newline        lprintf(&quotChapters\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !matroska_parse_chapters(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_CLUSTER:\newline        lprintf(&quotCluster\\n&quot);\newline        if (!ebml_skip(ebml, &ampelem))\newline          return 0;\newline        ret_value = 2;\newline        break;\newline      case MATROSKA_ID_CUES:\newline        lprintf(&quotCues\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_cues(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_ATTACHMENTS:\newline        lprintf(&quotAttachments\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_attachments(this))\newline          return 0;\newline        break;\newline      case MATROSKA_ID_TAGS:\newline        lprintf(&quotTags\\n&quot);\newline        if (!ebml_read_master (ebml, &ampelem))\newline          return 0;\newline        if ((elem.len &gt 0) &amp&amp !parse_tags(this))\newline          return 0;\newline        break;\newline      default:\newline        lprintf(&quotunknown top_level ID: 0x%x\\n&quot, elem.id);\newline        if (!ebml_skip(ebml, &ampelem))\newline          return 0;\newline    }\newline  } else {\newline    lprintf(&quottop_level entry already parsed, ID: 0x%x\\n&quot, elem.id);\newline    if (!ebml_skip(ebml, &ampelem))\newline      return 0;\newline  }\newline\newline  if (next_level)\newline    *next_level = ebml_get_next_level(ebml, &ampelem);\newline\newline  return ret_value;\newline}\newline","\newline Function used to parse a top level when opening the file.\newline It does&#039nt parse clusters.\newline retuned value:\newline 0: error\newline 1: ok\newline 2: cluster\newline \newline","2643688","type2str.c","TIEXPORT1 CableModel TICALL ticables_string_to_model(const char *str)\newline{\newline	if (str == NULL)\newline	{\newline		ticables_critical(&quot%s(NULL)&quot, __FUNCTION__);\newline		return CABLE_NUL;\newline	}\newline\newline	if(!g_ascii_strcasecmp(str, &quotnull&quot))\newline		return CABLE_NUL;\newline	else if(!g_ascii_strcasecmp(str, &quotGrayLink&quot))\newline		return CABLE_GRY;\newline	else if(!g_ascii_strcasecmp(str, &quotBlackLink&quot))\newline		return CABLE_BLK;\newline	else if(!g_ascii_strcasecmp(str, &quotParallel&quot))\newline		return CABLE_PAR;\newline	else if(!g_ascii_strcasecmp(str, &quotSilverLink&quot))\newline		return CABLE_SLV;\newline	else if(!g_ascii_strcasecmp(str, &quotDirectLink&quot))\newline		return CABLE_USB;\newline	else if(!g_ascii_strcasecmp(str, &quotVTi&quot))\newline		return CABLE_VTI;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTilEm&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu/TilEm&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotTiEmu&quot))\newline		return CABLE_TIE;\newline	else if(!g_ascii_strcasecmp(str, &quotlinkport&quot))\newline		return CABLE_ILP;\newline	else if(!g_ascii_strcasecmp(str, &quotUsbKernel&quot))\newline		return CABLE_DEV;\newline\newline	return CABLE_NUL;\newline}\newline","\newline ticables_string_to_model:\newline @str: a cable model as string like &quotBlackLink&quot.\newline \newline Do a string to integer conversion.\newline \newline Return value: a cable model.\newline \newline","5842565","addr.c","void libsieve_addrerror(char *msg)\newline{\newline    libsieve_parse_context-&gtexec_errors++;\newline\newline    libsieve_do_error_address(libsieve_parse_context, msg);\newline}\newline","Run an execution error callback. \newline","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","on","","","Internal protection slot, invoked","text contains control sequences for setting colors.","{}","Duplicates a Pcdata memory object","A signal handler for control-C.","Low-level matice","Number of best candidates to evaluate to expand Zopfli chain.","number of differences found","Gets month when device was manufactured.","removed the special characters "":"", ""_"", ""-"" and ""+""","Function used to parse a top level when opening the file.","input parameter block","Return value: a cable model.","Run an execution error callback.","conversion properly.","close the device and check for error","Returns: libsmartcols compatible width.","Check if domain is local and store attributes in a pvar","Wait for any of the processes in the group to complete.","Get pData item with given ReportID, Offset, and Type.","Opens the first audio stream of the named file."
"3NQUW096N682IGHLDNV3HUK2FQQ9LM","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3H8DHMCCW9B5OK9DU5T5D9M2XZ7DKF","AMD1LYNQAH3R8","Approved","Wed Apr 17 14:30:53 PDT 2019","Wed Apr 17 14:36:26 PDT 2019","Fri Apr 19 14:36:26 PDT 2019","2019-04-19 21:37:21 UTC","","","333","100% (27/27)","100% (27/27)","100% (27/27)","5402840","servers.c","void tld_delete(const char *name)\newline{\newline        tld_t *tld = tld_find(name);\newline        mowgli_node_t *n;\newline\newline        if (!tld)\newline        {\newline                slog(LG_DEBUG, &quottld_delete(): called for nonexistant tld: %s&quot, name);\newline\newline                return;\newline        }\newline\newline        slog(LG_DEBUG, &quottld_delete(): %s&quot, tld-&gtname);\newline\newline        n = mowgli_node_find(tld, &amptldlist);\newline        mowgli_node_delete(n, &amptldlist);\newline        mowgli_node_free(n);\newline\newline        free(tld-&gtname);\newline        mowgli_heap_free(tld_heap, tld);\newline\newline        cnt.tld--;\newline}\newline","\newline tld_delete(const char name)\newline \newline Destroys a TLD object.\newline \newline Inputs:\newline - name of TLD object to destroy\newline \newline Outputs:\newline - nothing\newline \newline Side Effects:\newline - the TLD object is removed and deregistered from the TLD list.\newline \newline","5751034","lfc_ifce_ng.c","int gfal_lfc_getComment(struct lfc_ops *ops, const char* lfn, char* buff, size_t s_buff, GError** err){\newline	g_return_val_err_if_fail(lfn, -1, err, &quotbad path&quot);\newline	const size_t req_size = CA_MAXCOMMENTLEN+1;\newline	char local_buff[CA_MAXCOMMENTLEN+1];\newline	int ret, resu_len;\newline\newline	if(buff == NULL || s_buff == 0)\newline		return req_size;\newline	else{\newline		ret = ops-&gtgetcomment(lfn, local_buff);\newline		if(ret &lt 0){\newline			const int sav_errno = gfal_lfc_get_errno(ops);\newline			if(sav_errno == ENOENT) { // no comments is define or not file exist, can be ambigous\newline				resu_len = 0;\newline				*buff = &#039\\0&#039;\newline				ret = 0;\newline			}\newline			else {\newline                gfal2_set_error(err, gfal2_get_plugin_lfc_quark(), sav_errno, __func__,\newline                        &quotError report from LFC : %s&quot, gfal_lfc_get_strerror(ops) );\newline			}\newline		}else{\newline			resu_len = strnlen(local_buff, MIN(s_buff, req_size));\newline			*((char*)mempcpy(buff, local_buff,resu_len )) = &#039\\0&#039;\newline		}\newline		return (ret==0)?(resu_len):-1;\newline	}\newline}\newline","\newline return the comment associated with this path\newline follow the xattr behavior, if buff==NULL, return only the appropriate buffer size for the call\newline @return the size of the comment or -1 if error\newline \newline","897008","ospauthrsp.c","void OSPPAuthRspSetDelayLimit(\newline    OSPT_AUTH_RSP *ospvAuthRsp, /* authorization response */\newline    unsigned ospvDelayLimit)    /* delay limit to set */\newline{\newline    if (ospvAuthRsp != OSPC_OSNULL) {\newline        ospvAuthRsp-&gtDelayLimit = ospvDelayLimit;\newline    }\newline}\newline","\newline OSPPAuthRspSetDelayLimit() - sets the delay limit for an authorization\newline \newline","5960127","options.c","void print_usage_msgs(option_class class)\newline{\newline  int option_index;\newline\newline  switch (class){\newline  case OPT_MISC:\newline    printf(gettext(&quotMiscellaneous options:\\n&quot));\newline    break;\newline  case OPT_PAGE_FURNITURE:\newline    printf(gettext(&quotPage furniture options:\\n&quot));\newline    break;\newline  case OPT_TEXT_FORMAT:\newline    printf(gettext(&quotText formatting options:\\n&quot));\newline    break;\newline  case OPT_PRINT:\newline    printf(gettext(&quotPrint selection options:\\n&quot));\newline    break;\newline  case OPT_PAGE_FORMAT:\newline    printf(gettext(&quotPage format options:\\n&quot));\newline    break;\newline  case OPT_OUTPUT:\newline    printf(gettext(&quotOutput options:\\n&quot));\newline    break;\newline  }\newline\newline  for (option_index=0; option_index &lt next_option; option_index++)\newline    {\newline      option_type *op = &ampoption_list[option_index];\newline      if (class == op-&gtclass)\newline	{\newline	  switch (op-&gttype)\newline	    {\newline	    case NOPARM:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.onoparm.string)\newline		printf(&quot--%s&quot,op-&gtt.onoparm.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.onoparm.help_string));\newline	      break;\newline\newline	    case OPTIONAL:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.ooptional.string)\newline		printf(&quot--%s[=&ltstring&gt]&quot,op-&gtt.ooptional.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ooptional.help_string));\newline	      break;\newline	    \newline	    case BOOLEAN:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.obool.true_string)\newline		printf(&quot--%s&quot,op-&gtt.obool.true_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.obool.true_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot--%c  &quot,op-&gtletter);\newline	      if (op-&gtt.obool.false_string)\newline		printf(&quot--%s&quot,op-&gtt.obool.false_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.obool.false_help_string));\newline	      break;\newline\newline	    case CHAR:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltchar&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.ochar.string)\newline		printf(&quot--%s &ltchar&gt&quot,op-&gtt.ochar.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochar.help_string));\newline	      break;\newline\newline	    case CHOICE:\newline	      if (op-&gtletter)\newline		printf(&quot-%c %c  &quot,op-&gtletter,op-&gtt.ochoice.choice1);\newline	      if (op-&gtt.ochoice.choice1_string)\newline		printf(&quot--%s&quot,op-&gtt.ochoice.choice1_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochoice.choice1_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot-%c %c  &quot,op-&gtletter,op-&gtt.ochoice.choice2);\newline	      if (op-&gtt.ochoice.choice2_string)\newline		printf(&quot--%s&quot,op-&gtt.ochoice.choice2_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochoice.choice2_help_string));\newline	      break;\newline\newline	    case SHORT:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltnumber&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oshrt.string)\newline		printf(&quot--%s=&ltnumber&gt&quot,op-&gtt.oshrt.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oshrt.help_string));\newline	      if (op-&gtt.oshrt.special_string)\newline		printf(&quot--%s\\n    %s\\n&quot, op-&gtt.oshrt.special_string, gettext(op-&gtt.oshrt.special_help_string));\newline	      break;\newline\newline	    case INT:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltnumber&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oint.string)\newline		printf(&quot--%s=&ltnumber&gt&quot,op-&gtt.oint.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oint.help_string));\newline	      if (op-&gtt.oint.special_string)\newline		printf(&quot--%s\\n    %s\\n&quot, op-&gtt.oint.special_string, gettext(op-&gtt.oint.special_help_string));\newline	      break;\newline\newline	    case STRING:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltstring&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.ostrng.string)\newline		printf(&quot--%s=&ltstring&gt&quot,op-&gtt.ostrng.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ostrng.help_string));\newline	      break;\newline\newline	    case FLAG_STRING:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltstring&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oflg.set_string)\newline		printf(&quot--%s=&ltstring&gt&quot,op-&gtt.oflg.set_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oflg.set_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot--%c  &quot,op-&gtletter);\newline	      if (op-&gtt.oflg.set_string)\newline		printf(&quot--%s&quot,op-&gtt.oflg.not_set_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oflg.not_set_help_string));\newline	    }\newline	}	\newline    }\newline}\newline","\newline Function:\newline print_usage_msgs\newline \newline","893245","jpg.c","SDL_Surface *loadJPG(Uint8 * data, Uint32 * memcounter)\newline{\newline  struct jpeg_error_mgr errmgr;\newline  struct jpeg_decompress_struct cinfo;\newline  JSAMPROW rowptr[1];\newline  SDL_Surface *surface;\newline  SDL_RWops *src = NULL;\newline  Uint32 size;\newline\newline  memcpy(&ampsize, data, sizeof(Uint32));\newline  if (memcounter)\newline    *memcounter += size + sizeof(Uint32);\newline  data += sizeof(Uint32);\newline  src = SDL_RWFromMem(data, size);\newline\newline  /* Create a decompression structure and load the JPEG header */\newline  cinfo.err = jpeg_std_error(&amperrmgr);\newline  jpeg_create_decompress(&ampcinfo);\newline  jpeg_SDL_RW_src(&ampcinfo, src);\newline  jpeg_read_header(&ampcinfo, TRUE);\newline\newline  /* Set 24-bit RGB output */\newline  cinfo.out_color_space = JCS_RGB;\newline  cinfo.quantize_colors = FALSE;\newline  jpeg_calc_output_dimensions(&ampcinfo);\newline\newline  /* Allocate an output surface to hold the image */\newline  surface = SDL_AllocSurface(SDL_SWSURFACE,\newline			     cinfo.output_width, cinfo.output_height, 24,\newline#if SDL_BYTEORDER == SDL_LIL_ENDIAN\newline			     0x0000FF, 0x00FF00, 0xFF0000,\newline#else\newline			     0xFF0000, 0x00FF00, 0x0000FF,\newline#endif\newline			     0);\newline  if (surface == NULL) {\newline    SDL_SetError(&quotOut of memory&quot);\newline    goto done;\newline  }\newline\newline  /* Decompress the image */\newline  jpeg_start_decompress(&ampcinfo);\newline  while (cinfo.output_scanline &lt cinfo.output_height) {\newline    rowptr[0] = (JSAMPROW) (Uint8 *) surface-&gtpixels +\newline      cinfo.output_scanline * surface-&gtpitch;\newline    jpeg_read_scanlines(&ampcinfo, rowptr, (JDIMENSION) 1);\newline  }\newline  jpeg_finish_decompress(&ampcinfo);\newline\newline  /* Clean up and return */\newlinedone:\newline  if (src)\newline    SDL_FreeRW(src);\newline  jpeg_destroy_decompress(&ampcinfo);\newline  return (surface);\newline}\newline","Load a JPEG type image \newline","4517307","sp_enc.c","static Word16 check_gp_clipping( Float32 *gp, Float32 g_pitch )\newline{\newline   Float32 sum;\newline   Word32 i;\newline\newline\newline   sum = g_pitch;\newline\newline   for ( i = 0; i &lt N_FRAME; i++ ) {\newline      sum += gp[i];\newline   }\newline\newline   if ( sum &gt 7.6F /*FGP_CLIP*/ ) {\newline      return 1;\newline   }\newline   else {\newline      return 0;\newline   }\newline}\newline","\newline check_gp_clipping\newline \newline \newline Parameters:\newline gp I: old pitch gains\newline g_pitch I: pitch gain\newline \newline Function:\newline Verify that the sum of the last (N_FRAME+1) pitch gains is under\newline a certain threshold.\newline \newline Returns:\newline True or false\newline \newline","4910923","repl5_replica.c","int replica_check_for_data_reload (Replica *r, void *arg)\newline{\newline    int rc = 0;\newline    RUV *upper_bound_ruv = NULL;\newline    RUV *r_ruv = NULL;\newline    Object *r_obj, *ruv_obj;\newline\newline    PR_ASSERT (r);\newline\newline    /* check that we have a changelog and if this replica logs changes */\newline    if (cl5GetState () == CL5_STATE_OPEN &amp&amp (r-&gtrepl_flags &amp REPLICA_LOG_CHANGES))\newline    {\newline        /* Compare new ruv to the purge ruv. If the new contains csns which\newline           are smaller than those in purge ruv, we need to remove old and\newline           create new changelog file for this replica. This is because we\newline           will not have sufficient changes to incrementally update a consumer\newline           to the current state of the supplier. */    \newline\newline        rc = cl5GetUpperBoundRUV (r, &ampupper_bound_ruv);\newline        if (rc != CL5_SUCCESS &amp&amp rc != CL5_NOTFOUND)\newline        {\newline            return -1;\newline        }\newline\newline        if (upper_bound_ruv)\newline        {\newline            ruv_obj = replica_get_ruv (r);\newline            r_ruv = object_get_data (ruv_obj);\newline            PR_ASSERT (r_ruv);\newline\newline            /* Compare new ruv to the changelog&#039s upper bound ruv. We could only keep\newline               the existing changelog if its upper bound is the same as replica&#039s RUV.\newline               This is because if changelog has changes not in RUV, they will be\newline               eventually sent to the consumer&#039s which will cause a state mismatch \newline               (because the supplier does not actually contain the changes in its data store.\newline               If, on the other hand, the changelog is not as up to date as the supplier,\newline               it is not really useful since out of sync consumer&#039s can&#039t be brought\newline               up to date using this changelog and hence will need to be reinitialized */\newline\newline			/*\newline			 * Actually we can ignore the scenario that the changelog&#039s upper\newline			 * bound ruv covers data store&#039s ruv for two reasons: (1) a change\newline			 * is always written to the changelog after it is committed to the\newline			 * data store;  (2) a change will be ignored if the server has seen\newline			 * it before - this happens frequently at the beginning of replication\newline			 * sessions.\newline			 */\newline\newline            if (slapi_disordely_shutdown(PR_FALSE)) {\newline                slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                    &quotWarning: disordely shutdown for replica %s. Check if DB RUV needs to be updated\\n&quot,\newline                    slapi_sdn_get_dn(r-&gtrepl_root));\newline                \newline                if (ruv_covers_ruv(upper_bound_ruv, r_ruv) &amp&amp !ruv_covers_ruv(r_ruv, upper_bound_ruv)) {\newline                    /*\newline                     * The Changelog RUV is ahead of the RUV in the DB.\newline                     * RUV DB was likely not flushed on disk.\newline                     */\newline\newline                    ruv_force_csn_update_from_ruv(upper_bound_ruv, r_ruv, \newline                            &quotForce update of database RUV (from CL RUV) -&gt &quot, SLAPI_LOG_FATAL);\newline                    replica_set_ruv_dirty(r);\newline                }\newline                \newline            } else {\newline\newline                rc = ruv_compare_ruv(upper_bound_ruv, &quotchangelog max RUV&quot, r_ruv, &quotdatabase RUV&quot, 0, SLAPI_LOG_FATAL);\newline                if (RUV_COMP_IS_FATAL(rc)) {\newline                    /* create a temporary replica object to conform to the interface */\newline                    r_obj = object_new(r, NULL);\newline\newline                    /* We can&#039t use existing changelog - remove existing file */\newline                    slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                            &quotWarning: data for replica %s does not match the data in the changelog. &quot\newline                            &quotRecreating the changelog file. &quot\newline                            &quotThis could affect replication with replica&#039s consumers in which case the &quot\newline                            &quotconsumers should be reinitialized.\\n&quot,\newline                            slapi_sdn_get_dn(r-&gtrepl_root));\newline\newline                    rc = cl5DeleteDBSync(r_obj);\newline\newline                    object_release(r_obj);\newline\newline                    if (rc == CL5_SUCCESS) {\newline                        /* log changes to mark starting point for replication */\newline                        rc = replica_log_ruv_elements(r);\newline                    }\newline                } else if (rc) {\newline                    slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                            &quotWarning: for replica %s there were some differences between the changelog max RUV and the &quot\newline                            &quotdatabase RUV.  If there are obsolete elements in the database RUV, you &quot\newline                            &quotshould remove them using the CLEANALLRUV task.  If they are not obsolete, &quot\newline                            &quotyou should check their status to see why there are no changes from those &quot\newline                            &quotservers in the changelog.\\n&quot,\newline                            slapi_sdn_get_dn(r-&gtrepl_root));\newline                    rc = 0;\newline                }\newline            } // slapi_disordely_shutdown\newline\newline            object_release (ruv_obj);\newline        }\newline        else    /* we have no changes currently logged for this replica */\newline        {\newline            /* log changes to mark starting point for replication */\newline            rc = replica_log_ruv_elements (r);\newline        }\newline    }\newline\newline    if (rc == 0)\newline    {\newline         /* reset mapping tree referrals based on new local RUV */\newline        consumer5_set_mapping_tree_state_for_replica(r, NULL);\newline    }\newline\newline    if (upper_bound_ruv)\newline        ruv_destroy (&ampupper_bound_ruv);\newline        \newline    return rc;\newline}\newline","the function does not use replica lock but all functions it calls are\newlinethread safe. Locking replica lock while calling changelog functions\newlinecauses a deadlock because changelog calls replica functions that\newlinethat lock the same lock \newline","4152771","btreplay.c","static char *map_dev(char *from_dev)\newline{\newline	struct list_head *p;\newline\newline	__list_for_each(p, &ampmap_devs) {\newline		struct map_dev *mdp = list_entry(p, struct map_dev, head);\newline\newline		if (strcmp(from_dev, mdp-&gtfrom_dev) == 0)\newline			return mdp-&gtto_dev;\newline	}\newline\newline	return from_dev;\newline}\newline","\newline map_dev - Return the mapped device for that specified\newline @from_dev: Device name as seen on recorded system\newline \newline Note: If there is no such mapping, we return the same name.\newline \newline","5604159","gnutls_config.c","static apr_status_t mgs_pool_free_credentials(void *arg)\newline{\newline    mgs_srvconf_rec *sc = (mgs_srvconf_rec *) arg;\newline\newline    if (sc-&gtcerts)\newline    {\newline        gnutls_certificate_free_credentials(sc-&gtcerts);\newline        sc-&gtcerts = NULL;\newline    }\newline\newline    if (sc-&gtanon_creds)\newline    {\newline        gnutls_anon_free_server_credentials(sc-&gtanon_creds);\newline        sc-&gtanon_creds = NULL;\newline    }\newline\newline#ifdef ENABLE_SRP\newline    if (sc-&gtsrp_creds)\newline    {\newline        gnutls_srp_free_server_credentials(sc-&gtsrp_creds);\newline        sc-&gtsrp_creds = NULL;\newline    }\newline#endif\newline\newline    if (sc-&gtdh_params)\newline    {\newline        gnutls_dh_params_deinit(sc-&gtdh_params);\newline        sc-&gtdh_params = NULL;\newline    }\newline\newline    for (unsigned int i = 0; i &lt sc-&gtcerts_x509_chain_num; i++)\newline    {\newline        gnutls_pcert_deinit(&ampsc-&gtcerts_x509_chain[i]);\newline        gnutls_x509_crt_deinit(sc-&gtcerts_x509_crt_chain[i]);\newline    }\newline\newline    if (sc-&gtprivkey_x509)\newline    {\newline        gnutls_privkey_deinit(sc-&gtprivkey_x509);\newline        sc-&gtprivkey_x509 = NULL;\newline    }\newline\newline    if (sc-&gtca_list)\newline    {\newline        for (unsigned int i = 0; i &lt sc-&gtca_list_size; i++)\newline        {\newline            gnutls_x509_crt_deinit(sc-&gtca_list[i]);\newline        }\newline        gnutls_free(sc-&gtca_list);\newline        sc-&gtca_list = NULL;\newline    }\newline\newline    if (sc-&gtcert_pgp)\newline    {\newline        gnutls_pcert_deinit(&ampsc-&gtcert_pgp[0]);\newline        sc-&gtcert_pgp = NULL;\newline        gnutls_openpgp_crt_deinit(sc-&gtcert_crt_pgp[0]);\newline        sc-&gtcert_crt_pgp = NULL;\newline    }\newline\newline    if (sc-&gtprivkey_pgp)\newline    {\newline        gnutls_privkey_deinit(sc-&gtprivkey_pgp);\newline        sc-&gtprivkey_pgp = NULL;\newline#if GNUTLS_VERSION_NUMBER &lt 0x030312\newline        gnutls_openpgp_privkey_deinit(sc-&gtprivkey_pgp_internal);\newline        sc-&gtprivkey_pgp_internal = NULL;\newline#endif\newline    }\newline\newline    if (sc-&gtpgp_list)\newline    {\newline        gnutls_openpgp_keyring_deinit(sc-&gtpgp_list);\newline        sc-&gtpgp_list = NULL;\newline    }\newline\newline    if (sc-&gtpriorities)\newline    {\newline        gnutls_priority_deinit(sc-&gtpriorities);\newline        sc-&gtpriorities = NULL;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","\newline Clean up the various GnuTLS data structures allocated from\newline mgs_load_files()\newline \newline","810088","parser.c","int\newlineln_combineData_Literal(void *const porg, void *const padd)\newline{\newline	struct data_Literal *const __restrict__ org = porg;\newline	struct data_Literal *const __restrict__ add = padd;\newline	int r = 0;\newline	const size_t len = strlen(org-&gtlit);\newline	const size_t add_len = strlen(add-&gtlit);\newline	char *const newlit = (char*)realloc((void*)org-&gtlit, len+add_len+1);\newline	CHKN(newlit);\newline	org-&gtlit = newlit;\newline	memcpy((char*)org-&gtlit+len, add-&gtlit, add_len+1);\newlinedone:	return r;\newline}\newline","for path compaction, we need a special handler to combine two\newline literal data elements.\newline \newline","2986071","kircclienthandler.cpp","KIrc::Handler::Handled ClientEventHandler::numericReply_324(KIrc::Context *context, const KIrc::Message &ampmessage, KIrc::Socket *socket)\newline{\newline//	emit incomingChannelMode(message.arg(1), message.arg(2), message.arg(3));\newline	return KIrc::Handler::NotHandled;\newline}\newline","324: &quot&ltchannel&gt &ltmode&gt &ltmode params&gt&quot\newline \newline","507002","zstd_v05.c","static size_t HUFv05_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,\newline                            U32* nbSymbolsPtr, U32* tableLogPtr,\newline                            const void* src, size_t srcSize)\newline{\newline    U32 weightTotal;\newline    U32 tableLog;\newline    const BYTE* ip = (const BYTE*) src;\newline    size_t iSize = ip[0];\newline    size_t oSize;\newline    U32 n;\newline\newline    //memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */\newline\newline    if (iSize &gt= 128)  { /* special header */\newline        if (iSize &gt= (242)) {  /* RLE */\newline            static int l[14] = { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };\newline            oSize = l[iSize-242];\newline            memset(huffWeight, 1, hwSize);\newline            iSize = 0;\newline        }\newline        else {   /* Incompressible */\newline            oSize = iSize - 127;\newline            iSize = ((oSize+1)/2);\newline            if (iSize+1 &gt srcSize) return ERROR(srcSize_wrong);\newline            if (oSize &gt= hwSize) return ERROR(corruption_detected);\newline            ip += 1;\newline            for (n=0; n&ltoSize; n+=2) {\newline                huffWeight[n]   = ip[n/2] &gt&gt 4;\newline                huffWeight[n+1] = ip[n/2] &amp 15;\newline    }   }   }\newline    else  {   /* header compressed with FSEv05 (normal case) */\newline        if (iSize+1 &gt srcSize) return ERROR(srcSize_wrong);\newline        oSize = FSEv05_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */\newline        if (FSEv05_isError(oSize)) return oSize;\newline    }\newline\newline    /* collect weight stats */\newline    memset(rankStats, 0, (HUFv05_ABSOLUTEMAX_TABLELOG + 1) * sizeof(U32));\newline    weightTotal = 0;\newline    for (n=0; n&ltoSize; n++) {\newline        if (huffWeight[n] &gt= HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);\newline        rankStats[huffWeight[n]]++;\newline        weightTotal += (1 &lt&lt huffWeight[n]) &gt&gt 1;\newline    }\newline\newline    /* get last non-null symbol weight (implied, total must be 2^n) */\newline    tableLog = BITv05_highbit32(weightTotal) + 1;\newline    if (tableLog &gt HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);\newline    {   /* determine last weight */\newline        U32 total = 1 &lt&lt tableLog;\newline        U32 rest = total - weightTotal;\newline        U32 verif = 1 &lt&lt BITv05_highbit32(rest);\newline        U32 lastWeight = BITv05_highbit32(rest) + 1;\newline        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */\newline        huffWeight[oSize] = (BYTE)lastWeight;\newline        rankStats[lastWeight]++;\newline    }\newline\newline    /* check tree construction validity */\newline    if ((rankStats[1] &lt 2) || (rankStats[1] &amp 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */\newline\newline    /* results */\newline    *nbSymbolsPtr = (U32)(oSize+1);\newline    *tableLogPtr = tableLog;\newline    return iSize+1;\newline}\newline","! HUFv05_readStats\newlineRead compact Huffman tree, saved by HUFv05_writeCTable\newline@huffWeight : destination buffer\newline@return : size read from `src`\newline \newline","3491739","tableau.cpp","int Tableau::autoMoveRight(int p)\newline{\newline  int i = -1;\newline  if (!piles[p]-&gtempty())\newline  {\newline    if (selected != piles[p])\newline      select(p);\newline    for (i = p + 1; i &lt (int)piles.size(); ++i)\newline      if (piles[i]-&gtempty() || selected-&gtselectionMatchesTo(piles[i]))\newline        break;\newline    if (i &lt (int)piles.size())\newline      move(i);\newline    else\newline      i = -1;\newline    changed = true;\newline  }\newline  return i;\newline}\newline","Search move from p-th pile to the next right pile, return destination \newline","263920","keybindings.c","static int calc_key_from_name(const TilemCalc *calc, const char *name)\newline{\newline	int i;\newline\newline	for (i = 0; i &lt 64; i++)\newline		if (calc-&gthw.keynames[i]\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], name))\newline			return i + 1;\newline\newline	/* kludge: accept aliases for a few keys */\newline	for (i = 0; i &lt 64; i++) {\newline		if (!calc-&gthw.keynames[i])\newline			continue;\newline\newline		if (!strcmp(name, &quotMatrix&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotApps&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotApps&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotAppsMenu&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotList&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotStatEd&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotPower&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotExpon&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotStat&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotTable&quot))\newline			return i + 1;\newline	}\newline\newline	return 0;\newline}\newline","Get the associated calculator key name \newline","5923809","redis_cluster.c","static HashTable *method_args_to_ht(zval *z_args, int argc) {\newline    HashTable *ht_ret;\newline    int i;\newline\newline    /* Allocate our hash table */\newline    ALLOC_HASHTABLE(ht_ret);\newline    zend_hash_init(ht_ret, argc, NULL, NULL, 0);\newline\newline    /* Populate our return hash table with our arguments */\newline    for (i = 0; i &lt argc; i++) {\newline        zend_hash_next_index_insert(ht_ret, &ampz_args[i]);\newline    }\newline\newline    /* Return our hash table */\newline    return ht_ret;\newline}\newline","Turn variable arguments into a HashTable for processing \newline","2638356","test_c.cpp","static ae_bool testlinlsqrunit_bidiagonaltest(ae_bool silent,\newline     ae_state *_state)\newline{\newline    ae_frame _frame_block;\newline    linlsqrstate s;\newline    linlsqrreport rep;\newline    ae_matrix a;\newline    ae_vector b;\newline    double bnorm;\newline    ae_vector x0;\newline    ae_int_t sz;\newline    ae_int_t n;\newline    ae_int_t m;\newline    ae_int_t minmn;\newline    ae_int_t ns0;\newline    ae_int_t ns1;\newline    double s0;\newline    double s1;\newline    ae_int_t i;\newline    ae_int_t j;\newline    ae_int_t p;\newline    ae_int_t diag;\newline    double pz;\newline    ae_bool result;\newline\newline    ae_frame_make(_state, &amp_frame_block);\newline    _linlsqrstate_init(&amps, _state);\newline    _linlsqrreport_init(&amprep, _state);\newline    ae_matrix_init(&ampa, 0, 0, DT_REAL, _state);\newline    ae_vector_init(&ampb, 0, DT_REAL, _state);\newline    ae_vector_init(&ampx0, 0, DT_REAL, _state);\newline\newline    sz = 5;\newline    for(m=1; m&lt=sz; m++)\newline    {\newline        for(n=1; n&lt=sz; n++)\newline        {\newline            minmn = ae_minint(m, n, _state);\newline            for(p=0; p&lt=2; p++)\newline            {\newline                for(ns0=-1; ns0&lt=1; ns0++)\newline                {\newline                    for(ns1=-1; ns1&lt=1; ns1++)\newline                    {\newline                        for(diag=0; diag&lt=1; diag++)\newline                        {\newline                            \newline                            /*\newline                             * Generate problem:\newline                             * * scaling coefficients s0, s1\newline                             * * bidiagonal A, with probability of having zero element at diagonal equal to PZ\newline                             */\newline                            s0 = ae_pow((double)(10), (double)(10*ns0), _state);\newline                            s1 = ae_pow((double)(10), (double)(10*ns1), _state);\newline                            pz = 0.0;\newline                            if( p==0 )\newline                            {\newline                                pz = 0.25;\newline                            }\newline                            if( p==1 )\newline                            {\newline                                pz = 0.5;\newline                            }\newline                            if( p==2 )\newline                            {\newline                                pz = 0.75;\newline                            }\newline                            ae_matrix_set_length(&ampa, m, n, _state);\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                for(j=0; j&lt=n-1; j++)\newline                                {\newline                                    a.ptr.pp_double[i][j] = (double)(0);\newline                                }\newline                            }\newline                            for(i=0; i&lt=minmn-1; i++)\newline                            {\newline                                if( ae_fp_greater_eq(ae_randomreal(_state),pz) )\newline                                {\newline                                    a.ptr.pp_double[i][i] = 2*ae_randomreal(_state)-1;\newline                                }\newline                            }\newline                            for(i=1; i&lt=minmn-1; i++)\newline                            {\newline                                if( ae_fp_greater_eq(ae_randomreal(_state),pz) )\newline                                {\newline                                    if( diag==0 )\newline                                    {\newline                                        a.ptr.pp_double[i-1][i] = 2*ae_randomreal(_state)-1;\newline                                    }\newline                                    if( diag==1 )\newline                                    {\newline                                        a.ptr.pp_double[i][i-1] = 2*ae_randomreal(_state)-1;\newline                                    }\newline                                }\newline                            }\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                for(j=0; j&lt=n-1; j++)\newline                                {\newline                                    a.ptr.pp_double[i][j] = s0*a.ptr.pp_double[i][j];\newline                                }\newline                            }\newline                            ae_vector_set_length(&ampb, m, _state);\newline                            do\newline                            {\newline                                bnorm = (double)(0);\newline                                for(i=0; i&lt=m-1; i++)\newline                                {\newline                                    b.ptr.p_double[i] = 2*ae_randomreal(_state)-1;\newline                                    bnorm = bnorm+b.ptr.p_double[i]*b.ptr.p_double[i];\newline                                }\newline                                bnorm = ae_sqrt(bnorm, _state);\newline                            }\newline                            while(ae_fp_less_eq(bnorm,testlinlsqrunit_e0));\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                b.ptr.p_double[i] = b.ptr.p_double[i]*s1/bnorm;\newline                            }\newline                            \newline                            /*\newline                             * LSQR solution\newline                             */\newline                            linlsqrcreate(m, n, &amps, _state);\newline                            linlsqrsetb(&amps, &ampb, _state);\newline                            linlsqrsetcond(&amps, testlinlsqrunit_e0, testlinlsqrunit_e0, 0, _state);\newline                            while(linlsqriteration(&amps, _state))\newline                            {\newline                                if( s.needmv )\newline                                {\newline                                    for(i=0; i&lt=m-1; i++)\newline                                    {\newline                                        s.mv.ptr.p_double[i] = (double)(0);\newline                                        for(j=0; j&lt=n-1; j++)\newline                                        {\newline                                            s.mv.ptr.p_double[i] = s.mv.ptr.p_double[i]+a.ptr.pp_double[i][j]*s.x.ptr.p_double[j];\newline                                        }\newline                                    }\newline                                }\newline                                if( s.needmtv )\newline                                {\newline                                    for(i=0; i&lt=n-1; i++)\newline                                    {\newline                                        s.mtv.ptr.p_double[i] = (double)(0);\newline                                        for(j=0; j&lt=m-1; j++)\newline                                        {\newline                                            s.mtv.ptr.p_double[i] = s.mtv.ptr.p_double[i]+a.ptr.pp_double[j][i]*s.x.ptr.p_double[j];\newline                                        }\newline                                    }\newline                                }\newline                            }\newline                            linlsqrresults(&amps, &ampx0, &amprep, _state);\newline                            \newline                            /*\newline                             * Check\newline                             */\newline                            if( !testlinlsqrunit_isitgoodsolution(&ampa, &ampb, m, n, 0.0, &ampx0, testlinlsqrunit_e0, testlinlsqrunit_tolort, _state) )\newline                            {\newline                                result = ae_true;\newline                                ae_frame_leave(_state);\newline                                return result;\newline                            }\newline                        }\newline                    }\newline                }\newline            }\newline        }\newline    }\newline    result = ae_false;\newline    ae_frame_leave(_state);\newline    return result;\newline}\newline","\newlineThe test does check, that algorithm can find a solution with minimum norm,\newlineif a problem has bidiagonal matrix on diagonals of a lot of zeros. This\newlineproblem has to lead to case when State.Alpha and State.Beta are zero, and we\newlinewe can be sure that the algorithm correctly handles it.\newlineWe do not use iteration count as stopping condition, because problem can\newlinebe degenerate and we may need more than N iterations to converge.\newlineINPUT: \newlineSilent - if true then function output report\newline-- ALGLIB --\newlineCopyright 30.11.2011 by Bochkanov Sergey\newline \newline","4742353","radar.c","void _site_update_loading(gchar *file, goffset cur,\newline		goffset total, gpointer _site)\newline{\newline	RadarSite *site = _site;\newline	GtkWidget *progress_bar = gtk_bin_get_child(GTK_BIN(site-&gtconfig));\newline	double percent = (double)cur/total;\newline	gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(progress_bar), MIN(percent, 1.0));\newline	gchar *msg = g_strdup_printf(&quotLoading... %5.1f%% (%.2f/%.2f MB)&quot,\newline			percent*100, (double)cur/1000000, (double)total/1000000);\newline	gtk_progress_bar_set_text(GTK_PROGRESS_BAR(progress_bar), msg);\newline	g_free(msg);\newline}\newline","format: http://mesonet.agron.iastate.edu/data/nexrd2/raw/KABR/KABR_20090510_0323 \newline","839725","qsidebar.cpp","QUrlModel::QUrlModel(QObject *parent) : QStandardItemModel(parent), showFullPath(false), fileSystemModel(0)\newline{\newline}\newline","!\newlineQUrlModel lets you have indexes from a QFileSystemModel to a list. When QFileSystemModel\newlinechanges them QUrlModel will automatically update.\newlineExample usage: File dialog sidebar and combo box\newline \newline","5943321","parsesf.c","static void set_init_info(SFInfo *sf, awe_voice_info *vp, LayerTable *tbl)\newline{\newline	/* key range */\newline	vp-&gtlow = LOWNUM(tbl-&gtval[SF_keyRange]);\newline	vp-&gthigh = HIGHNUM(tbl-&gtval[SF_keyRange]);\newline\newline	/* velocity range */\newline	vp-&gtvellow = LOWNUM(tbl-&gtval[SF_velRange]);\newline	vp-&gtvelhigh = HIGHNUM(tbl-&gtval[SF_velRange]);\newline\newline	/* fixed key &amp velocity */\newline	vp-&gtfixkey = tbl-&gtval[SF_keynum];\newline	vp-&gtfixvel = tbl-&gtval[SF_velocity];\newline	\newline	/* panning position */\newline	vp-&gtpan = awe_calc_pan(tbl-&gtval[SF_panEffectsSend]);\newline	vp-&gtfixpan = -1;\newline\newline	/* initial volume */\newline\newline	vp-&gtamplitude = awe_option.default_volume * 127 / 100;\newline	vp-&gtattenuation = awe_calc_attenuation(tbl-&gtval[SF_initAtten]);\newline#if 0\newline	if (vp-&gtmode &amp AWE_MODE_ROMSOUND &amp&amp !awe_option.compatible) {\newline		if (vp-&gtattenuation &lt 0xf0)\newline			vp-&gtattenuation += 0x10;\newline		else\newline			vp-&gtattenuation = 0xff;\newline	}\newline#endif\newline	\newline	/* chorus &amp reverb effects */\newline	if (tbl-&gtset[SF_chorusEffectsSend])\newline		vp-&gtparm.chorus = awe_calc_chorus(tbl-&gtval[SF_chorusEffectsSend]);\newline	else\newline		vp-&gtparm.chorus = awe_calc_chorus(awe_option.default_chorus * 10);\newline	if (tbl-&gtset[SF_reverbEffectsSend])\newline		vp-&gtparm.reverb = awe_calc_reverb(tbl-&gtval[SF_reverbEffectsSend]);\newline	else\newline		vp-&gtparm.reverb = awe_calc_reverb(awe_option.default_reverb * 10);\newline\newline	/* initial cutoff &amp resonance */\newline	vp-&gtparm.cutoff = awe_calc_cutoff(tbl-&gtval[SF_initialFilterFc]);\newline	vp-&gtparm.filterQ = awe_calc_filterQ(tbl-&gtval[SF_initialFilterQ]);\newline\newline	/* exclusive class key */\newline	vp-&gtexclusiveClass = tbl-&gtval[SF_keyExclusiveClass];\newline}\newline","set global information \newline","4962072","mainwindow.cpp","void MainWindow::slotRefreshNewsView(int nextUnread)\newline{\newline  if (nextUnread == 1) {\newline    feedsView_-&gtclearSelection();\newline    QModelIndex indexNextUnread =\newline        feedsView_-&gtindexNextUnread(feedsView_-&gtcurrentIndex());\newline    feedsView_-&gtsetCurrentIndex(indexNextUnread);\newline    slotFeedClicked(indexNextUnread);\newline  } else if ((tabBar_-&gtcurrentIndex() == TAB_WIDGET_PERMANENT) &amp&amp (nextUnread == -1)) {\newline    QModelIndex index = feedsProxyModel_-&gtindex(-1, &quottext&quot);\newline    feedsView_-&gtsetCurrentIndex(index);\newline    slotFeedClicked(index);\newline  } else {\newline    int currentRow = newsView_-&gtcurrentIndex().row();\newline\newline    newsModel_-&gtselect();\newline\newline    while (newsModel_-&gtcanFetchMore())\newline      newsModel_-&gtfetchMore();\newline\newline    currentNewsTab-&gtloadNewspaper(NewsTabWidget::RefreshWithPos);\newline\newline    newsView_-&gtsetCurrentIndex(newsModel_-&gtindex(currentRow, newsModel_-&gtfieldIndex(&quottitle&quot)));\newline  }\newline}\newline","@brief Refresh news view (After mark all feeds or one feed read)\newline --------------------------------------------------------------------------- \newline","1081909","video_out_xv.c","static void x11_InstallXErrorHandler (xv_driver_t *this) {\newline  this-&gtx11_old_error_handler = XSetErrorHandler (HandleXError);\newline  XSync(this-&gtdisplay, False);\newline}\newline","called xlocked \newline","","on","on","","","","","","on","","","","","on","","on","","","on","","","","","","","","","","","","","","","","","","","","","","","","Destroys a TLD object.","{}","{}","Read compact Huffman tree,","Search move from p-th pile to the next right pile,","Get the associated calculator key name","Turn variable arguments into a HashTable for processing","find a solution with minimum norm,","{}","have indexes from a QFileSystemModel to a list.","set global information","return the comment associated with this path","Refresh news view","{}","sets the delay limit for an authorization","{}","Load a JPEG type image","Verify that the sum of the last (N_FRAME+1) pitch gains","{}","Return the mapped device","Clean up the various GnuTLS data structures"
"3NQUW096N682IGHLDNV3HUK2FQQ9LM","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3Z4XG4ZF48RZRPCTCGXEHBG3IIOX8J","A2C9MHLJVOREJU","Approved","Wed Apr 17 17:06:18 PDT 2019","Wed Apr 17 17:20:00 PDT 2019","Fri Apr 19 17:20:00 PDT 2019","2019-04-20 00:20:22 UTC","","","822","100% (2/2)","100% (2/2)","100% (2/2)","5402840","servers.c","void tld_delete(const char *name)\newline{\newline        tld_t *tld = tld_find(name);\newline        mowgli_node_t *n;\newline\newline        if (!tld)\newline        {\newline                slog(LG_DEBUG, &quottld_delete(): called for nonexistant tld: %s&quot, name);\newline\newline                return;\newline        }\newline\newline        slog(LG_DEBUG, &quottld_delete(): %s&quot, tld-&gtname);\newline\newline        n = mowgli_node_find(tld, &amptldlist);\newline        mowgli_node_delete(n, &amptldlist);\newline        mowgli_node_free(n);\newline\newline        free(tld-&gtname);\newline        mowgli_heap_free(tld_heap, tld);\newline\newline        cnt.tld--;\newline}\newline","\newline tld_delete(const char name)\newline \newline Destroys a TLD object.\newline \newline Inputs:\newline - name of TLD object to destroy\newline \newline Outputs:\newline - nothing\newline \newline Side Effects:\newline - the TLD object is removed and deregistered from the TLD list.\newline \newline","5751034","lfc_ifce_ng.c","int gfal_lfc_getComment(struct lfc_ops *ops, const char* lfn, char* buff, size_t s_buff, GError** err){\newline	g_return_val_err_if_fail(lfn, -1, err, &quotbad path&quot);\newline	const size_t req_size = CA_MAXCOMMENTLEN+1;\newline	char local_buff[CA_MAXCOMMENTLEN+1];\newline	int ret, resu_len;\newline\newline	if(buff == NULL || s_buff == 0)\newline		return req_size;\newline	else{\newline		ret = ops-&gtgetcomment(lfn, local_buff);\newline		if(ret &lt 0){\newline			const int sav_errno = gfal_lfc_get_errno(ops);\newline			if(sav_errno == ENOENT) { // no comments is define or not file exist, can be ambigous\newline				resu_len = 0;\newline				*buff = &#039\\0&#039;\newline				ret = 0;\newline			}\newline			else {\newline                gfal2_set_error(err, gfal2_get_plugin_lfc_quark(), sav_errno, __func__,\newline                        &quotError report from LFC : %s&quot, gfal_lfc_get_strerror(ops) );\newline			}\newline		}else{\newline			resu_len = strnlen(local_buff, MIN(s_buff, req_size));\newline			*((char*)mempcpy(buff, local_buff,resu_len )) = &#039\\0&#039;\newline		}\newline		return (ret==0)?(resu_len):-1;\newline	}\newline}\newline","\newline return the comment associated with this path\newline follow the xattr behavior, if buff==NULL, return only the appropriate buffer size for the call\newline @return the size of the comment or -1 if error\newline \newline","897008","ospauthrsp.c","void OSPPAuthRspSetDelayLimit(\newline    OSPT_AUTH_RSP *ospvAuthRsp, /* authorization response */\newline    unsigned ospvDelayLimit)    /* delay limit to set */\newline{\newline    if (ospvAuthRsp != OSPC_OSNULL) {\newline        ospvAuthRsp-&gtDelayLimit = ospvDelayLimit;\newline    }\newline}\newline","\newline OSPPAuthRspSetDelayLimit() - sets the delay limit for an authorization\newline \newline","5960127","options.c","void print_usage_msgs(option_class class)\newline{\newline  int option_index;\newline\newline  switch (class){\newline  case OPT_MISC:\newline    printf(gettext(&quotMiscellaneous options:\\n&quot));\newline    break;\newline  case OPT_PAGE_FURNITURE:\newline    printf(gettext(&quotPage furniture options:\\n&quot));\newline    break;\newline  case OPT_TEXT_FORMAT:\newline    printf(gettext(&quotText formatting options:\\n&quot));\newline    break;\newline  case OPT_PRINT:\newline    printf(gettext(&quotPrint selection options:\\n&quot));\newline    break;\newline  case OPT_PAGE_FORMAT:\newline    printf(gettext(&quotPage format options:\\n&quot));\newline    break;\newline  case OPT_OUTPUT:\newline    printf(gettext(&quotOutput options:\\n&quot));\newline    break;\newline  }\newline\newline  for (option_index=0; option_index &lt next_option; option_index++)\newline    {\newline      option_type *op = &ampoption_list[option_index];\newline      if (class == op-&gtclass)\newline	{\newline	  switch (op-&gttype)\newline	    {\newline	    case NOPARM:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.onoparm.string)\newline		printf(&quot--%s&quot,op-&gtt.onoparm.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.onoparm.help_string));\newline	      break;\newline\newline	    case OPTIONAL:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.ooptional.string)\newline		printf(&quot--%s[=&ltstring&gt]&quot,op-&gtt.ooptional.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ooptional.help_string));\newline	      break;\newline	    \newline	    case BOOLEAN:\newline	      if (op-&gtletter)\newline		printf(&quot-%c  &quot,op-&gtletter);\newline	      if (op-&gtt.obool.true_string)\newline		printf(&quot--%s&quot,op-&gtt.obool.true_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.obool.true_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot--%c  &quot,op-&gtletter);\newline	      if (op-&gtt.obool.false_string)\newline		printf(&quot--%s&quot,op-&gtt.obool.false_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.obool.false_help_string));\newline	      break;\newline\newline	    case CHAR:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltchar&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.ochar.string)\newline		printf(&quot--%s &ltchar&gt&quot,op-&gtt.ochar.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochar.help_string));\newline	      break;\newline\newline	    case CHOICE:\newline	      if (op-&gtletter)\newline		printf(&quot-%c %c  &quot,op-&gtletter,op-&gtt.ochoice.choice1);\newline	      if (op-&gtt.ochoice.choice1_string)\newline		printf(&quot--%s&quot,op-&gtt.ochoice.choice1_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochoice.choice1_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot-%c %c  &quot,op-&gtletter,op-&gtt.ochoice.choice2);\newline	      if (op-&gtt.ochoice.choice2_string)\newline		printf(&quot--%s&quot,op-&gtt.ochoice.choice2_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ochoice.choice2_help_string));\newline	      break;\newline\newline	    case SHORT:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltnumber&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oshrt.string)\newline		printf(&quot--%s=&ltnumber&gt&quot,op-&gtt.oshrt.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oshrt.help_string));\newline	      if (op-&gtt.oshrt.special_string)\newline		printf(&quot--%s\\n    %s\\n&quot, op-&gtt.oshrt.special_string, gettext(op-&gtt.oshrt.special_help_string));\newline	      break;\newline\newline	    case INT:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltnumber&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oint.string)\newline		printf(&quot--%s=&ltnumber&gt&quot,op-&gtt.oint.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oint.help_string));\newline	      if (op-&gtt.oint.special_string)\newline		printf(&quot--%s\\n    %s\\n&quot, op-&gtt.oint.special_string, gettext(op-&gtt.oint.special_help_string));\newline	      break;\newline\newline	    case STRING:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltstring&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.ostrng.string)\newline		printf(&quot--%s=&ltstring&gt&quot,op-&gtt.ostrng.string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.ostrng.help_string));\newline	      break;\newline\newline	    case FLAG_STRING:\newline	      if (op-&gtletter)\newline		printf(&quot-%c &ltstring&gt  &quot,op-&gtletter);\newline	      if (op-&gtt.oflg.set_string)\newline		printf(&quot--%s=&ltstring&gt&quot,op-&gtt.oflg.set_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oflg.set_help_string));\newline	      if (op-&gtletter)\newline		printf(&quot--%c  &quot,op-&gtletter);\newline	      if (op-&gtt.oflg.set_string)\newline		printf(&quot--%s&quot,op-&gtt.oflg.not_set_string);\newline	      printf(&quot\\n    %s\\n&quot,gettext(op-&gtt.oflg.not_set_help_string));\newline	    }\newline	}	\newline    }\newline}\newline","\newline Function:\newline print_usage_msgs\newline \newline","893245","jpg.c","SDL_Surface *loadJPG(Uint8 * data, Uint32 * memcounter)\newline{\newline  struct jpeg_error_mgr errmgr;\newline  struct jpeg_decompress_struct cinfo;\newline  JSAMPROW rowptr[1];\newline  SDL_Surface *surface;\newline  SDL_RWops *src = NULL;\newline  Uint32 size;\newline\newline  memcpy(&ampsize, data, sizeof(Uint32));\newline  if (memcounter)\newline    *memcounter += size + sizeof(Uint32);\newline  data += sizeof(Uint32);\newline  src = SDL_RWFromMem(data, size);\newline\newline  /* Create a decompression structure and load the JPEG header */\newline  cinfo.err = jpeg_std_error(&amperrmgr);\newline  jpeg_create_decompress(&ampcinfo);\newline  jpeg_SDL_RW_src(&ampcinfo, src);\newline  jpeg_read_header(&ampcinfo, TRUE);\newline\newline  /* Set 24-bit RGB output */\newline  cinfo.out_color_space = JCS_RGB;\newline  cinfo.quantize_colors = FALSE;\newline  jpeg_calc_output_dimensions(&ampcinfo);\newline\newline  /* Allocate an output surface to hold the image */\newline  surface = SDL_AllocSurface(SDL_SWSURFACE,\newline			     cinfo.output_width, cinfo.output_height, 24,\newline#if SDL_BYTEORDER == SDL_LIL_ENDIAN\newline			     0x0000FF, 0x00FF00, 0xFF0000,\newline#else\newline			     0xFF0000, 0x00FF00, 0x0000FF,\newline#endif\newline			     0);\newline  if (surface == NULL) {\newline    SDL_SetError(&quotOut of memory&quot);\newline    goto done;\newline  }\newline\newline  /* Decompress the image */\newline  jpeg_start_decompress(&ampcinfo);\newline  while (cinfo.output_scanline &lt cinfo.output_height) {\newline    rowptr[0] = (JSAMPROW) (Uint8 *) surface-&gtpixels +\newline      cinfo.output_scanline * surface-&gtpitch;\newline    jpeg_read_scanlines(&ampcinfo, rowptr, (JDIMENSION) 1);\newline  }\newline  jpeg_finish_decompress(&ampcinfo);\newline\newline  /* Clean up and return */\newlinedone:\newline  if (src)\newline    SDL_FreeRW(src);\newline  jpeg_destroy_decompress(&ampcinfo);\newline  return (surface);\newline}\newline","Load a JPEG type image \newline","4517307","sp_enc.c","static Word16 check_gp_clipping( Float32 *gp, Float32 g_pitch )\newline{\newline   Float32 sum;\newline   Word32 i;\newline\newline\newline   sum = g_pitch;\newline\newline   for ( i = 0; i &lt N_FRAME; i++ ) {\newline      sum += gp[i];\newline   }\newline\newline   if ( sum &gt 7.6F /*FGP_CLIP*/ ) {\newline      return 1;\newline   }\newline   else {\newline      return 0;\newline   }\newline}\newline","\newline check_gp_clipping\newline \newline \newline Parameters:\newline gp I: old pitch gains\newline g_pitch I: pitch gain\newline \newline Function:\newline Verify that the sum of the last (N_FRAME+1) pitch gains is under\newline a certain threshold.\newline \newline Returns:\newline True or false\newline \newline","4910923","repl5_replica.c","int replica_check_for_data_reload (Replica *r, void *arg)\newline{\newline    int rc = 0;\newline    RUV *upper_bound_ruv = NULL;\newline    RUV *r_ruv = NULL;\newline    Object *r_obj, *ruv_obj;\newline\newline    PR_ASSERT (r);\newline\newline    /* check that we have a changelog and if this replica logs changes */\newline    if (cl5GetState () == CL5_STATE_OPEN &amp&amp (r-&gtrepl_flags &amp REPLICA_LOG_CHANGES))\newline    {\newline        /* Compare new ruv to the purge ruv. If the new contains csns which\newline           are smaller than those in purge ruv, we need to remove old and\newline           create new changelog file for this replica. This is because we\newline           will not have sufficient changes to incrementally update a consumer\newline           to the current state of the supplier. */    \newline\newline        rc = cl5GetUpperBoundRUV (r, &ampupper_bound_ruv);\newline        if (rc != CL5_SUCCESS &amp&amp rc != CL5_NOTFOUND)\newline        {\newline            return -1;\newline        }\newline\newline        if (upper_bound_ruv)\newline        {\newline            ruv_obj = replica_get_ruv (r);\newline            r_ruv = object_get_data (ruv_obj);\newline            PR_ASSERT (r_ruv);\newline\newline            /* Compare new ruv to the changelog&#039s upper bound ruv. We could only keep\newline               the existing changelog if its upper bound is the same as replica&#039s RUV.\newline               This is because if changelog has changes not in RUV, they will be\newline               eventually sent to the consumer&#039s which will cause a state mismatch \newline               (because the supplier does not actually contain the changes in its data store.\newline               If, on the other hand, the changelog is not as up to date as the supplier,\newline               it is not really useful since out of sync consumer&#039s can&#039t be brought\newline               up to date using this changelog and hence will need to be reinitialized */\newline\newline			/*\newline			 * Actually we can ignore the scenario that the changelog&#039s upper\newline			 * bound ruv covers data store&#039s ruv for two reasons: (1) a change\newline			 * is always written to the changelog after it is committed to the\newline			 * data store;  (2) a change will be ignored if the server has seen\newline			 * it before - this happens frequently at the beginning of replication\newline			 * sessions.\newline			 */\newline\newline            if (slapi_disordely_shutdown(PR_FALSE)) {\newline                slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                    &quotWarning: disordely shutdown for replica %s. Check if DB RUV needs to be updated\\n&quot,\newline                    slapi_sdn_get_dn(r-&gtrepl_root));\newline                \newline                if (ruv_covers_ruv(upper_bound_ruv, r_ruv) &amp&amp !ruv_covers_ruv(r_ruv, upper_bound_ruv)) {\newline                    /*\newline                     * The Changelog RUV is ahead of the RUV in the DB.\newline                     * RUV DB was likely not flushed on disk.\newline                     */\newline\newline                    ruv_force_csn_update_from_ruv(upper_bound_ruv, r_ruv, \newline                            &quotForce update of database RUV (from CL RUV) -&gt &quot, SLAPI_LOG_FATAL);\newline                    replica_set_ruv_dirty(r);\newline                }\newline                \newline            } else {\newline\newline                rc = ruv_compare_ruv(upper_bound_ruv, &quotchangelog max RUV&quot, r_ruv, &quotdatabase RUV&quot, 0, SLAPI_LOG_FATAL);\newline                if (RUV_COMP_IS_FATAL(rc)) {\newline                    /* create a temporary replica object to conform to the interface */\newline                    r_obj = object_new(r, NULL);\newline\newline                    /* We can&#039t use existing changelog - remove existing file */\newline                    slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                            &quotWarning: data for replica %s does not match the data in the changelog. &quot\newline                            &quotRecreating the changelog file. &quot\newline                            &quotThis could affect replication with replica&#039s consumers in which case the &quot\newline                            &quotconsumers should be reinitialized.\\n&quot,\newline                            slapi_sdn_get_dn(r-&gtrepl_root));\newline\newline                    rc = cl5DeleteDBSync(r_obj);\newline\newline                    object_release(r_obj);\newline\newline                    if (rc == CL5_SUCCESS) {\newline                        /* log changes to mark starting point for replication */\newline                        rc = replica_log_ruv_elements(r);\newline                    }\newline                } else if (rc) {\newline                    slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, &quotreplica_check_for_data_reload: &quot\newline                            &quotWarning: for replica %s there were some differences between the changelog max RUV and the &quot\newline                            &quotdatabase RUV.  If there are obsolete elements in the database RUV, you &quot\newline                            &quotshould remove them using the CLEANALLRUV task.  If they are not obsolete, &quot\newline                            &quotyou should check their status to see why there are no changes from those &quot\newline                            &quotservers in the changelog.\\n&quot,\newline                            slapi_sdn_get_dn(r-&gtrepl_root));\newline                    rc = 0;\newline                }\newline            } // slapi_disordely_shutdown\newline\newline            object_release (ruv_obj);\newline        }\newline        else    /* we have no changes currently logged for this replica */\newline        {\newline            /* log changes to mark starting point for replication */\newline            rc = replica_log_ruv_elements (r);\newline        }\newline    }\newline\newline    if (rc == 0)\newline    {\newline         /* reset mapping tree referrals based on new local RUV */\newline        consumer5_set_mapping_tree_state_for_replica(r, NULL);\newline    }\newline\newline    if (upper_bound_ruv)\newline        ruv_destroy (&ampupper_bound_ruv);\newline        \newline    return rc;\newline}\newline","the function does not use replica lock but all functions it calls are\newlinethread safe. Locking replica lock while calling changelog functions\newlinecauses a deadlock because changelog calls replica functions that\newlinethat lock the same lock \newline","4152771","btreplay.c","static char *map_dev(char *from_dev)\newline{\newline	struct list_head *p;\newline\newline	__list_for_each(p, &ampmap_devs) {\newline		struct map_dev *mdp = list_entry(p, struct map_dev, head);\newline\newline		if (strcmp(from_dev, mdp-&gtfrom_dev) == 0)\newline			return mdp-&gtto_dev;\newline	}\newline\newline	return from_dev;\newline}\newline","\newline map_dev - Return the mapped device for that specified\newline @from_dev: Device name as seen on recorded system\newline \newline Note: If there is no such mapping, we return the same name.\newline \newline","5604159","gnutls_config.c","static apr_status_t mgs_pool_free_credentials(void *arg)\newline{\newline    mgs_srvconf_rec *sc = (mgs_srvconf_rec *) arg;\newline\newline    if (sc-&gtcerts)\newline    {\newline        gnutls_certificate_free_credentials(sc-&gtcerts);\newline        sc-&gtcerts = NULL;\newline    }\newline\newline    if (sc-&gtanon_creds)\newline    {\newline        gnutls_anon_free_server_credentials(sc-&gtanon_creds);\newline        sc-&gtanon_creds = NULL;\newline    }\newline\newline#ifdef ENABLE_SRP\newline    if (sc-&gtsrp_creds)\newline    {\newline        gnutls_srp_free_server_credentials(sc-&gtsrp_creds);\newline        sc-&gtsrp_creds = NULL;\newline    }\newline#endif\newline\newline    if (sc-&gtdh_params)\newline    {\newline        gnutls_dh_params_deinit(sc-&gtdh_params);\newline        sc-&gtdh_params = NULL;\newline    }\newline\newline    for (unsigned int i = 0; i &lt sc-&gtcerts_x509_chain_num; i++)\newline    {\newline        gnutls_pcert_deinit(&ampsc-&gtcerts_x509_chain[i]);\newline        gnutls_x509_crt_deinit(sc-&gtcerts_x509_crt_chain[i]);\newline    }\newline\newline    if (sc-&gtprivkey_x509)\newline    {\newline        gnutls_privkey_deinit(sc-&gtprivkey_x509);\newline        sc-&gtprivkey_x509 = NULL;\newline    }\newline\newline    if (sc-&gtca_list)\newline    {\newline        for (unsigned int i = 0; i &lt sc-&gtca_list_size; i++)\newline        {\newline            gnutls_x509_crt_deinit(sc-&gtca_list[i]);\newline        }\newline        gnutls_free(sc-&gtca_list);\newline        sc-&gtca_list = NULL;\newline    }\newline\newline    if (sc-&gtcert_pgp)\newline    {\newline        gnutls_pcert_deinit(&ampsc-&gtcert_pgp[0]);\newline        sc-&gtcert_pgp = NULL;\newline        gnutls_openpgp_crt_deinit(sc-&gtcert_crt_pgp[0]);\newline        sc-&gtcert_crt_pgp = NULL;\newline    }\newline\newline    if (sc-&gtprivkey_pgp)\newline    {\newline        gnutls_privkey_deinit(sc-&gtprivkey_pgp);\newline        sc-&gtprivkey_pgp = NULL;\newline#if GNUTLS_VERSION_NUMBER &lt 0x030312\newline        gnutls_openpgp_privkey_deinit(sc-&gtprivkey_pgp_internal);\newline        sc-&gtprivkey_pgp_internal = NULL;\newline#endif\newline    }\newline\newline    if (sc-&gtpgp_list)\newline    {\newline        gnutls_openpgp_keyring_deinit(sc-&gtpgp_list);\newline        sc-&gtpgp_list = NULL;\newline    }\newline\newline    if (sc-&gtpriorities)\newline    {\newline        gnutls_priority_deinit(sc-&gtpriorities);\newline        sc-&gtpriorities = NULL;\newline    }\newline\newline    return APR_SUCCESS;\newline}\newline","\newline Clean up the various GnuTLS data structures allocated from\newline mgs_load_files()\newline \newline","810088","parser.c","int\newlineln_combineData_Literal(void *const porg, void *const padd)\newline{\newline	struct data_Literal *const __restrict__ org = porg;\newline	struct data_Literal *const __restrict__ add = padd;\newline	int r = 0;\newline	const size_t len = strlen(org-&gtlit);\newline	const size_t add_len = strlen(add-&gtlit);\newline	char *const newlit = (char*)realloc((void*)org-&gtlit, len+add_len+1);\newline	CHKN(newlit);\newline	org-&gtlit = newlit;\newline	memcpy((char*)org-&gtlit+len, add-&gtlit, add_len+1);\newlinedone:	return r;\newline}\newline","for path compaction, we need a special handler to combine two\newline literal data elements.\newline \newline","2986071","kircclienthandler.cpp","KIrc::Handler::Handled ClientEventHandler::numericReply_324(KIrc::Context *context, const KIrc::Message &ampmessage, KIrc::Socket *socket)\newline{\newline//	emit incomingChannelMode(message.arg(1), message.arg(2), message.arg(3));\newline	return KIrc::Handler::NotHandled;\newline}\newline","324: &quot&ltchannel&gt &ltmode&gt &ltmode params&gt&quot\newline \newline","507002","zstd_v05.c","static size_t HUFv05_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,\newline                            U32* nbSymbolsPtr, U32* tableLogPtr,\newline                            const void* src, size_t srcSize)\newline{\newline    U32 weightTotal;\newline    U32 tableLog;\newline    const BYTE* ip = (const BYTE*) src;\newline    size_t iSize = ip[0];\newline    size_t oSize;\newline    U32 n;\newline\newline    //memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */\newline\newline    if (iSize &gt= 128)  { /* special header */\newline        if (iSize &gt= (242)) {  /* RLE */\newline            static int l[14] = { 1, 2, 3, 4, 7, 8, 15, 16, 31, 32, 63, 64, 127, 128 };\newline            oSize = l[iSize-242];\newline            memset(huffWeight, 1, hwSize);\newline            iSize = 0;\newline        }\newline        else {   /* Incompressible */\newline            oSize = iSize - 127;\newline            iSize = ((oSize+1)/2);\newline            if (iSize+1 &gt srcSize) return ERROR(srcSize_wrong);\newline            if (oSize &gt= hwSize) return ERROR(corruption_detected);\newline            ip += 1;\newline            for (n=0; n&ltoSize; n+=2) {\newline                huffWeight[n]   = ip[n/2] &gt&gt 4;\newline                huffWeight[n+1] = ip[n/2] &amp 15;\newline    }   }   }\newline    else  {   /* header compressed with FSEv05 (normal case) */\newline        if (iSize+1 &gt srcSize) return ERROR(srcSize_wrong);\newline        oSize = FSEv05_decompress(huffWeight, hwSize-1, ip+1, iSize);   /* max (hwSize-1) values decoded, as last one is implied */\newline        if (FSEv05_isError(oSize)) return oSize;\newline    }\newline\newline    /* collect weight stats */\newline    memset(rankStats, 0, (HUFv05_ABSOLUTEMAX_TABLELOG + 1) * sizeof(U32));\newline    weightTotal = 0;\newline    for (n=0; n&ltoSize; n++) {\newline        if (huffWeight[n] &gt= HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);\newline        rankStats[huffWeight[n]]++;\newline        weightTotal += (1 &lt&lt huffWeight[n]) &gt&gt 1;\newline    }\newline\newline    /* get last non-null symbol weight (implied, total must be 2^n) */\newline    tableLog = BITv05_highbit32(weightTotal) + 1;\newline    if (tableLog &gt HUFv05_ABSOLUTEMAX_TABLELOG) return ERROR(corruption_detected);\newline    {   /* determine last weight */\newline        U32 total = 1 &lt&lt tableLog;\newline        U32 rest = total - weightTotal;\newline        U32 verif = 1 &lt&lt BITv05_highbit32(rest);\newline        U32 lastWeight = BITv05_highbit32(rest) + 1;\newline        if (verif != rest) return ERROR(corruption_detected);    /* last value must be a clean power of 2 */\newline        huffWeight[oSize] = (BYTE)lastWeight;\newline        rankStats[lastWeight]++;\newline    }\newline\newline    /* check tree construction validity */\newline    if ((rankStats[1] &lt 2) || (rankStats[1] &amp 1)) return ERROR(corruption_detected);   /* by construction : at least 2 elts of rank 1, must be even */\newline\newline    /* results */\newline    *nbSymbolsPtr = (U32)(oSize+1);\newline    *tableLogPtr = tableLog;\newline    return iSize+1;\newline}\newline","! HUFv05_readStats\newlineRead compact Huffman tree, saved by HUFv05_writeCTable\newline@huffWeight : destination buffer\newline@return : size read from `src`\newline \newline","3491739","tableau.cpp","int Tableau::autoMoveRight(int p)\newline{\newline  int i = -1;\newline  if (!piles[p]-&gtempty())\newline  {\newline    if (selected != piles[p])\newline      select(p);\newline    for (i = p + 1; i &lt (int)piles.size(); ++i)\newline      if (piles[i]-&gtempty() || selected-&gtselectionMatchesTo(piles[i]))\newline        break;\newline    if (i &lt (int)piles.size())\newline      move(i);\newline    else\newline      i = -1;\newline    changed = true;\newline  }\newline  return i;\newline}\newline","Search move from p-th pile to the next right pile, return destination \newline","263920","keybindings.c","static int calc_key_from_name(const TilemCalc *calc, const char *name)\newline{\newline	int i;\newline\newline	for (i = 0; i &lt 64; i++)\newline		if (calc-&gthw.keynames[i]\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], name))\newline			return i + 1;\newline\newline	/* kludge: accept aliases for a few keys */\newline	for (i = 0; i &lt 64; i++) {\newline		if (!calc-&gthw.keynames[i])\newline			continue;\newline\newline		if (!strcmp(name, &quotMatrix&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotApps&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotApps&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotAppsMenu&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotList&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotStatEd&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotPower&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotExpon&quot))\newline			return i + 1;\newline		if (!strcmp(name, &quotStat&quot)\newline		    &amp&amp !strcmp(calc-&gthw.keynames[i], &quotTable&quot))\newline			return i + 1;\newline	}\newline\newline	return 0;\newline}\newline","Get the associated calculator key name \newline","5923809","redis_cluster.c","static HashTable *method_args_to_ht(zval *z_args, int argc) {\newline    HashTable *ht_ret;\newline    int i;\newline\newline    /* Allocate our hash table */\newline    ALLOC_HASHTABLE(ht_ret);\newline    zend_hash_init(ht_ret, argc, NULL, NULL, 0);\newline\newline    /* Populate our return hash table with our arguments */\newline    for (i = 0; i &lt argc; i++) {\newline        zend_hash_next_index_insert(ht_ret, &ampz_args[i]);\newline    }\newline\newline    /* Return our hash table */\newline    return ht_ret;\newline}\newline","Turn variable arguments into a HashTable for processing \newline","2638356","test_c.cpp","static ae_bool testlinlsqrunit_bidiagonaltest(ae_bool silent,\newline     ae_state *_state)\newline{\newline    ae_frame _frame_block;\newline    linlsqrstate s;\newline    linlsqrreport rep;\newline    ae_matrix a;\newline    ae_vector b;\newline    double bnorm;\newline    ae_vector x0;\newline    ae_int_t sz;\newline    ae_int_t n;\newline    ae_int_t m;\newline    ae_int_t minmn;\newline    ae_int_t ns0;\newline    ae_int_t ns1;\newline    double s0;\newline    double s1;\newline    ae_int_t i;\newline    ae_int_t j;\newline    ae_int_t p;\newline    ae_int_t diag;\newline    double pz;\newline    ae_bool result;\newline\newline    ae_frame_make(_state, &amp_frame_block);\newline    _linlsqrstate_init(&amps, _state);\newline    _linlsqrreport_init(&amprep, _state);\newline    ae_matrix_init(&ampa, 0, 0, DT_REAL, _state);\newline    ae_vector_init(&ampb, 0, DT_REAL, _state);\newline    ae_vector_init(&ampx0, 0, DT_REAL, _state);\newline\newline    sz = 5;\newline    for(m=1; m&lt=sz; m++)\newline    {\newline        for(n=1; n&lt=sz; n++)\newline        {\newline            minmn = ae_minint(m, n, _state);\newline            for(p=0; p&lt=2; p++)\newline            {\newline                for(ns0=-1; ns0&lt=1; ns0++)\newline                {\newline                    for(ns1=-1; ns1&lt=1; ns1++)\newline                    {\newline                        for(diag=0; diag&lt=1; diag++)\newline                        {\newline                            \newline                            /*\newline                             * Generate problem:\newline                             * * scaling coefficients s0, s1\newline                             * * bidiagonal A, with probability of having zero element at diagonal equal to PZ\newline                             */\newline                            s0 = ae_pow((double)(10), (double)(10*ns0), _state);\newline                            s1 = ae_pow((double)(10), (double)(10*ns1), _state);\newline                            pz = 0.0;\newline                            if( p==0 )\newline                            {\newline                                pz = 0.25;\newline                            }\newline                            if( p==1 )\newline                            {\newline                                pz = 0.5;\newline                            }\newline                            if( p==2 )\newline                            {\newline                                pz = 0.75;\newline                            }\newline                            ae_matrix_set_length(&ampa, m, n, _state);\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                for(j=0; j&lt=n-1; j++)\newline                                {\newline                                    a.ptr.pp_double[i][j] = (double)(0);\newline                                }\newline                            }\newline                            for(i=0; i&lt=minmn-1; i++)\newline                            {\newline                                if( ae_fp_greater_eq(ae_randomreal(_state),pz) )\newline                                {\newline                                    a.ptr.pp_double[i][i] = 2*ae_randomreal(_state)-1;\newline                                }\newline                            }\newline                            for(i=1; i&lt=minmn-1; i++)\newline                            {\newline                                if( ae_fp_greater_eq(ae_randomreal(_state),pz) )\newline                                {\newline                                    if( diag==0 )\newline                                    {\newline                                        a.ptr.pp_double[i-1][i] = 2*ae_randomreal(_state)-1;\newline                                    }\newline                                    if( diag==1 )\newline                                    {\newline                                        a.ptr.pp_double[i][i-1] = 2*ae_randomreal(_state)-1;\newline                                    }\newline                                }\newline                            }\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                for(j=0; j&lt=n-1; j++)\newline                                {\newline                                    a.ptr.pp_double[i][j] = s0*a.ptr.pp_double[i][j];\newline                                }\newline                            }\newline                            ae_vector_set_length(&ampb, m, _state);\newline                            do\newline                            {\newline                                bnorm = (double)(0);\newline                                for(i=0; i&lt=m-1; i++)\newline                                {\newline                                    b.ptr.p_double[i] = 2*ae_randomreal(_state)-1;\newline                                    bnorm = bnorm+b.ptr.p_double[i]*b.ptr.p_double[i];\newline                                }\newline                                bnorm = ae_sqrt(bnorm, _state);\newline                            }\newline                            while(ae_fp_less_eq(bnorm,testlinlsqrunit_e0));\newline                            for(i=0; i&lt=m-1; i++)\newline                            {\newline                                b.ptr.p_double[i] = b.ptr.p_double[i]*s1/bnorm;\newline                            }\newline                            \newline                            /*\newline                             * LSQR solution\newline                             */\newline                            linlsqrcreate(m, n, &amps, _state);\newline                            linlsqrsetb(&amps, &ampb, _state);\newline                            linlsqrsetcond(&amps, testlinlsqrunit_e0, testlinlsqrunit_e0, 0, _state);\newline                            while(linlsqriteration(&amps, _state))\newline                            {\newline                                if( s.needmv )\newline                                {\newline                                    for(i=0; i&lt=m-1; i++)\newline                                    {\newline                                        s.mv.ptr.p_double[i] = (double)(0);\newline                                        for(j=0; j&lt=n-1; j++)\newline                                        {\newline                                            s.mv.ptr.p_double[i] = s.mv.ptr.p_double[i]+a.ptr.pp_double[i][j]*s.x.ptr.p_double[j];\newline                                        }\newline                                    }\newline                                }\newline                                if( s.needmtv )\newline                                {\newline                                    for(i=0; i&lt=n-1; i++)\newline                                    {\newline                                        s.mtv.ptr.p_double[i] = (double)(0);\newline                                        for(j=0; j&lt=m-1; j++)\newline                                        {\newline                                            s.mtv.ptr.p_double[i] = s.mtv.ptr.p_double[i]+a.ptr.pp_double[j][i]*s.x.ptr.p_double[j];\newline                                        }\newline                                    }\newline                                }\newline                            }\newline                            linlsqrresults(&amps, &ampx0, &amprep, _state);\newline                            \newline                            /*\newline                             * Check\newline                             */\newline                            if( !testlinlsqrunit_isitgoodsolution(&ampa, &ampb, m, n, 0.0, &ampx0, testlinlsqrunit_e0, testlinlsqrunit_tolort, _state) )\newline                            {\newline                                result = ae_true;\newline                                ae_frame_leave(_state);\newline                                return result;\newline                            }\newline                        }\newline                    }\newline                }\newline            }\newline        }\newline    }\newline    result = ae_false;\newline    ae_frame_leave(_state);\newline    return result;\newline}\newline","\newlineThe test does check, that algorithm can find a solution with minimum norm,\newlineif a problem has bidiagonal matrix on diagonals of a lot of zeros. This\newlineproblem has to lead to case when State.Alpha and State.Beta are zero, and we\newlinewe can be sure that the algorithm correctly handles it.\newlineWe do not use iteration count as stopping condition, because problem can\newlinebe degenerate and we may need more than N iterations to converge.\newlineINPUT: \newlineSilent - if true then function output report\newline-- ALGLIB --\newlineCopyright 30.11.2011 by Bochkanov Sergey\newline \newline","4742353","radar.c","void _site_update_loading(gchar *file, goffset cur,\newline		goffset total, gpointer _site)\newline{\newline	RadarSite *site = _site;\newline	GtkWidget *progress_bar = gtk_bin_get_child(GTK_BIN(site-&gtconfig));\newline	double percent = (double)cur/total;\newline	gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(progress_bar), MIN(percent, 1.0));\newline	gchar *msg = g_strdup_printf(&quotLoading... %5.1f%% (%.2f/%.2f MB)&quot,\newline			percent*100, (double)cur/1000000, (double)total/1000000);\newline	gtk_progress_bar_set_text(GTK_PROGRESS_BAR(progress_bar), msg);\newline	g_free(msg);\newline}\newline","format: http://mesonet.agron.iastate.edu/data/nexrd2/raw/KABR/KABR_20090510_0323 \newline","839725","qsidebar.cpp","QUrlModel::QUrlModel(QObject *parent) : QStandardItemModel(parent), showFullPath(false), fileSystemModel(0)\newline{\newline}\newline","!\newlineQUrlModel lets you have indexes from a QFileSystemModel to a list. When QFileSystemModel\newlinechanges them QUrlModel will automatically update.\newlineExample usage: File dialog sidebar and combo box\newline \newline","5943321","parsesf.c","static void set_init_info(SFInfo *sf, awe_voice_info *vp, LayerTable *tbl)\newline{\newline	/* key range */\newline	vp-&gtlow = LOWNUM(tbl-&gtval[SF_keyRange]);\newline	vp-&gthigh = HIGHNUM(tbl-&gtval[SF_keyRange]);\newline\newline	/* velocity range */\newline	vp-&gtvellow = LOWNUM(tbl-&gtval[SF_velRange]);\newline	vp-&gtvelhigh = HIGHNUM(tbl-&gtval[SF_velRange]);\newline\newline	/* fixed key &amp velocity */\newline	vp-&gtfixkey = tbl-&gtval[SF_keynum];\newline	vp-&gtfixvel = tbl-&gtval[SF_velocity];\newline	\newline	/* panning position */\newline	vp-&gtpan = awe_calc_pan(tbl-&gtval[SF_panEffectsSend]);\newline	vp-&gtfixpan = -1;\newline\newline	/* initial volume */\newline\newline	vp-&gtamplitude = awe_option.default_volume * 127 / 100;\newline	vp-&gtattenuation = awe_calc_attenuation(tbl-&gtval[SF_initAtten]);\newline#if 0\newline	if (vp-&gtmode &amp AWE_MODE_ROMSOUND &amp&amp !awe_option.compatible) {\newline		if (vp-&gtattenuation &lt 0xf0)\newline			vp-&gtattenuation += 0x10;\newline		else\newline			vp-&gtattenuation = 0xff;\newline	}\newline#endif\newline	\newline	/* chorus &amp reverb effects */\newline	if (tbl-&gtset[SF_chorusEffectsSend])\newline		vp-&gtparm.chorus = awe_calc_chorus(tbl-&gtval[SF_chorusEffectsSend]);\newline	else\newline		vp-&gtparm.chorus = awe_calc_chorus(awe_option.default_chorus * 10);\newline	if (tbl-&gtset[SF_reverbEffectsSend])\newline		vp-&gtparm.reverb = awe_calc_reverb(tbl-&gtval[SF_reverbEffectsSend]);\newline	else\newline		vp-&gtparm.reverb = awe_calc_reverb(awe_option.default_reverb * 10);\newline\newline	/* initial cutoff &amp resonance */\newline	vp-&gtparm.cutoff = awe_calc_cutoff(tbl-&gtval[SF_initialFilterFc]);\newline	vp-&gtparm.filterQ = awe_calc_filterQ(tbl-&gtval[SF_initialFilterQ]);\newline\newline	/* exclusive class key */\newline	vp-&gtexclusiveClass = tbl-&gtval[SF_keyExclusiveClass];\newline}\newline","set global information \newline","4962072","mainwindow.cpp","void MainWindow::slotRefreshNewsView(int nextUnread)\newline{\newline  if (nextUnread == 1) {\newline    feedsView_-&gtclearSelection();\newline    QModelIndex indexNextUnread =\newline        feedsView_-&gtindexNextUnread(feedsView_-&gtcurrentIndex());\newline    feedsView_-&gtsetCurrentIndex(indexNextUnread);\newline    slotFeedClicked(indexNextUnread);\newline  } else if ((tabBar_-&gtcurrentIndex() == TAB_WIDGET_PERMANENT) &amp&amp (nextUnread == -1)) {\newline    QModelIndex index = feedsProxyModel_-&gtindex(-1, &quottext&quot);\newline    feedsView_-&gtsetCurrentIndex(index);\newline    slotFeedClicked(index);\newline  } else {\newline    int currentRow = newsView_-&gtcurrentIndex().row();\newline\newline    newsModel_-&gtselect();\newline\newline    while (newsModel_-&gtcanFetchMore())\newline      newsModel_-&gtfetchMore();\newline\newline    currentNewsTab-&gtloadNewspaper(NewsTabWidget::RefreshWithPos);\newline\newline    newsView_-&gtsetCurrentIndex(newsModel_-&gtindex(currentRow, newsModel_-&gtfieldIndex(&quottitle&quot)));\newline  }\newline}\newline","@brief Refresh news view (After mark all feeds or one feed read)\newline --------------------------------------------------------------------------- \newline","1081909","video_out_xv.c","static void x11_InstallXErrorHandler (xv_driver_t *this) {\newline  this-&gtx11_old_error_handler = XSetErrorHandler (HandleXError);\newline  XSync(this-&gtdisplay, False);\newline}\newline","called xlocked \newline","","","on","","on","","","","on","on","on","","","on","","on","","","on","","","","","","on","","","","","","","","","","","","","","","","","","Destroys a TLD object.","combine twoliteral data elements.","{}","size read","{}","Get the associated calculator key name","Turn variable arguments into a HashTable","find a solution with minimum norm,","{}","{}","{}","return the comment associated with this path","Refresh news view","{}","sets the delay limit for an authorization","{}","Load a JPEG type image","sum of the last (N_FRAME+1) pitch gains is undera certain threshold.","{}","Return the mapped device","Clean up the various GnuTLS data structures"
"3RIHDBQ1NEYF34HPBBKAUOXFY8OMHR","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","31LM9EDVOLSJZCU81E7W8ZYJWHJJNK","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 22:02:56 PDT 2019","Wed Apr 17 22:12:51 PDT 2019","Fri Apr 19 22:12:51 PDT 2019","2019-04-20 05:13:21 UTC","","","595","100% (10/10)","100% (10/10)","100% (10/10)","331837","hashfs.c","rc_ty sx_hashfs_distlock_release(sx_hashfs_t *h) {\newline    sqlite3_reset(h-&gtq_delval);\newline    if(qbind_text(h-&gtq_delval, &quot:k&quot, &quotdistlock&quot) || qstep_noret(h-&gtq_delval)) {\newline        WARN(&quotFailed to unlock distribution&quot);\newline        return FAIL_EINTERNAL;\newline    }\newline\newline    return OK;\newline}\newline","Release distribution lock \newline","6038116","dmmain.c","static int display_presize(void *handle, void *device, int width, int height,\newline    int raster, unsigned int format)\newline{\newline    /* Check for correct format (32-bit RGB), fatal error if not */\newline    if (format != display_format)\newline    {\newline        printf(&quotDisplayFormat has been set to an incompatible value.\\n&quot);\newline        fflush(stdout);\newline        return gs_error_rangecheck;\newline    }\newline\newline    return 0;\newline}\newline","Resize will only occur if this function returns 0. \newline","4216330","sv_user.c","static void Cmd_Spawn_f (void)\newline{\newline	int		i;\newline	client_t	*client;\newline	edict_t	*ent;\newline	eval_t *val;\newline	unsigned n;\newline#ifdef USE_PR2\newline	string_t	savenetname;\newline#endif\newline\newline	if (sv_client-&gtstate != cs_connected)\newline	{\newline		Con_Printf (&quotSpawn not valid -- already spawned\\n&quot);\newline		return;\newline	}\newline\newline	// handle the case of a level changing while a client was connecting\newline	if (Q_atoi(Cmd_Argv(1)) != svs.spawncount)\newline	{\newline		SV_ClearReliable (sv_client);\newline		Con_Printf (&quotSV_Spawn_f from different level\\n&quot);\newline		Cmd_New_f ();\newline		return;\newline	}\newline\newline	n = Q_atoi(Cmd_Argv(2));\newline	if (n &gt= MAX_CLIENTS)\newline	{\newline		SV_ClientPrintf (sv_client, PRINT_HIGH,\newline		                 &quotSV_Spawn_f: Invalid client start\\n&quot);\newline		SV_DropClient (sv_client);\newline		return;\newline	}\newline\newline	// send all current names, colors, and frag counts\newline	// FIXME: is this a good thing?\newline	SZ_Clear (&ampsv_client-&gtnetchan.message);\newline\newline	// send current status of all other players\newline\newline	// normally this could overflow, but no need to check due to backbuf\newline	for (i=n, client = svs.clients + n ; i&ltMAX_CLIENTS &amp&amp sv_client-&gtnetchan.message.cursize &lt (MAX_MSGLEN/2); i++, client++)\newline		SV_FullClientUpdateToClient (client, sv_client);\newline\newline	if (i &lt MAX_CLIENTS)\newline	{\newline		MSG_WriteByte (&ampsv_client-&gtnetchan.message, svc_stufftext);\newline		MSG_WriteString (&ampsv_client-&gtnetchan.message,\newline		                 va(&quotcmd spawn %i %d\\n&quot, svs.spawncount, i) );\newline		return;\newline	}\newline\newline	// send all current light styles\newline	for (i=0 ; i&ltMAX_LIGHTSTYLES ; i++)\newline	{\newline		ClientReliableWrite_Begin (sv_client, svc_lightstyle,\newline		                           3 + (sv.lightstyles[i] ? strlen(sv.lightstyles[i]) : 1));\newline		ClientReliableWrite_Byte (sv_client, (char)i);\newline		ClientReliableWrite_String (sv_client, sv.lightstyles[i]);\newline	}\newline\newline	// set up the edict\newline	ent = sv_client-&gtedict;\newline\newline	if (sv.loadgame)\newline	{\newline		// loaded games are already fully initialized \newline		// if this is the last client to be connected, unpause\newline\newline		if (sv.paused &amp 1)\newline			SV_TogglePause (NULL, 1);\newline	}\newline	else\newline	{\newline#ifdef USE_PR2\newline		if ( sv_vm )\newline		{\newline			savenetname = ent-&gtv.netname;\newline			memset(&ampent-&gtv, 0, pr_edict_size - sizeof(edict_t) + sizeof(entvars_t));\newline			ent-&gtv.netname = savenetname;\newline    \newline			// so spec will have right goalentity - if speccing someone\newline			// qqshka {\newline			if(sv_client-&gtspectator &amp&amp sv_client-&gtspec_track &gt 0)\newline				ent-&gtv.goalentity = EDICT_TO_PROG(svs.clients[sv_client-&gtspec_track-1].edict);\newline    \newline			// }\newline    \newline			//sv_client-&gtname = PR2_GetString(ent-&gtv.netname);\newline			//strlcpy(PR2_GetString(ent-&gtv.netname), sv_client-&gtname, 32);\newline		}\newline		else\newline#endif\newline		{\newline			memset (&ampent-&gtv, 0, progs-&gtentityfields * 4);\newline			ent-&gtv.netname = PR_SetString(sv_client-&gtname);\newline		}\newline		ent-&gtv.colormap = NUM_FOR_EDICT(ent);\newline		ent-&gtv.team = 0;	// FIXME\newline		if (pr_teamfield)\newline			E_INT(ent, pr_teamfield) = PR_SetString(sv_client-&gtteam);\newline	}\newline\newline	sv_client-&gtentgravity = 1.0;\newline	val =\newline#ifdef USE_PR2\newline	    PR2_GetEdictFieldValue(ent, &quotgravity&quot);\newline#else\newline	    GetEdictFieldValue(ent, &quotgravity&quot);\newline#endif\newline	if (val)\newline		val-&gt_float = 1.0;\newline	sv_client-&gtmaxspeed = sv_maxspeed.value;\newline	val =\newline#ifdef USE_PR2\newline	    PR2_GetEdictFieldValue(ent, &quotmaxspeed&quot);\newline#else\newline		GetEdictFieldValue(ent, &quotmaxspeed&quot);\newline#endif\newline	if (val)\newline		val-&gt_float = sv_maxspeed.value;\newline\newline	//\newline	// force stats to be updated\newline	//\newline	memset (sv_client-&gtstats, 0, sizeof(sv_client-&gtstats));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_TOTALSECRETS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(total_secrets));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_TOTALMONSTERS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(total_monsters));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_SECRETS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(found_secrets));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_MONSTERS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(killed_monsters));\newline\newline	// get the client to check and download skins\newline	// when that is completed, a begin command will be issued\newline	ClientReliableWrite_Begin (sv_client, svc_stufftext, 8);\newline	ClientReliableWrite_String (sv_client, &quotskins\\n&quot );\newline\newline}\newline","\newline==================\newlineCmd_Spawn_f\newline==================\newline \newline","4694037","ceph_frag.h","static inline __u32 ceph_frag_make(__u32 b, __u32 v)\newline{\newline	return (b &lt&lt 24) |\newline		(v &amp (0xffffffu &lt&lt (24-b)) &amp 0xffffffu);\newline}\newline","\newline &quotFrags&quot are a way to describe a subset of a 32-bit number space,\newline using a mask and a value to match against that mask. Any given frag\newline (subset of the number space) can be partitioned into 2^n sub-frags.\newline \newline Frags are encoded into a 32-bit word:\newline 8 upper bits = &quotbits&quot\newline 24 lower bits = &quotvalue&quot\newline (We could go to 5+27 bits, but who cares.)\newline \newline We use the _most_ significant bits of the 24 bit value. This makes\newline values logically sort.\newline \newline Unfortunately, because the &quotbits&quot field is still in the high bits, we\newline can&#039t sort encoded frags numerically. However, it does allow you\newline to feed encoded frags as values into frag_contains_value.\newline \newline","2178191","libhttp.c","int http_return_stream(struct http_connection *hc, void *data, size_t datalen) {\newline	/* We are chunked and done sending - end session */\newline	if (!data) {\newline		/* Chunked transfer - send a 0 chunk */\newline		if (hc-&gtproto == HP_HTTP11) {\newline			evbuffer_add_printf(hc-&gtevb,&quot0\\r\\n\\r\\n&quot);\newline			bufferevent_write_buffer(hc-&gtbev, hc-&gtevb);\newline		}\newline		hc-&gtstatus=HC_STATUS_END;\newline		return 1;\newline	}\newline\newline	/* In case of Transfer-Encoding: chunked send a chunk - otherwise just data */\newline	if (hc-&gtproto == HP_HTTP11) {\newline		evbuffer_add_printf(hc-&gtevb,&quot%x\\r\\n&quot, datalen);\newline		evbuffer_add(hc-&gtevb, data, datalen);\newline		evbuffer_add_printf(hc-&gtevb, &quot\\r\\n&quot);\newline	} else {\newline		evbuffer_add(hc-&gtevb, data, datalen);\newline	}\newline\newline	bufferevent_write_buffer(hc-&gtbev, hc-&gtevb);\newline\newline	Dprintf(&quot%s: output buffer len %d\\n&quot, __FUNCTION__,\newline			EVBUFFER_LENGTH(hc-&gtbev-&gtoutput));\newline\newline	return 1;\newline}\newline","\newline Function to return an http chunk with previous unknown size. HTTP/1.1 allows\newline for chunked transfers which HTTP/1.0 doesnt know about. There is no legal way\newline to do this so we hope our best.\newline \newline \newline","5108163","graphsdl.c","void find_cursor(void) {\newline//  if (graphmode!=FULLSCREEN) {\newline//    xtext = wherex()-1;\newline//    ytext = wherey()-1;\newline//  }\newline}\newline","\newline &#039find_cursor&#039 locates the cursor on the text screen and ensures that\newline its position is valid, that is, lies within the text window\newline \newline","1082564","input_dvb.c","static epg_entry_t* current_epg(channel_t* channel) {\newline    epg_entry_t* next = ith_next_epg(channel, 0);\newline#ifdef DEBUG_EPG\newline    if (next != NULL)\newline	printf(&quotinput_dvb: EPG  current: %s (%d)\\n&quot, next-&gtprogname, next-&gtrunning);\newline#endif\newline    return next;\newline}\newline","Finds the EPG of the current program. If not found, returns NULL. \newline","2633555","cmtspeech_msgs.c","int cmtspeech_msg_encode_reset_conn_resp(cmtspeech_cmd_t *cmd)\newline{\newline  cmd-&gtd.buf[BYTE0] = (CMTSPEECH_RESET_CONN_RESP &lt&lt 4) | CMTSPEECH_DOMAIN_CONTROL;\newline  cmd-&gtd.buf[BYTE1] = 0x0;\newline  cmd-&gtd.buf[BYTE2] = 0x0;\newline  cmd-&gtd.buf[BYTE3] = 0x0;\newline\newline  return 4;\newline}\newline","\newline Encodes an RESET_CONN_RESP message to buffer pointed\newline by &#039cmd&#039. Returns size of encoded data (in octets).\newline \newline","3092860","threedwidget.cpp","void ThreeDWidget::resizeGL(int width, int height)\newline{\newline	double w, h;\newline	m_rCltRect = geometry();\newline	int side = qMax(width, height);\newline	w = (double)width;\newline	h = (double)height;\newline\newline#ifdef Q_WS_MAC\newline    glViewport(0,0, width, height);\newline#else\newline	glViewport((width - side) / 2, (height - side) / 2, side, side);\newline#endif\newline//	d = qMax(w,h);\newline//	glViewport(0,0, d, d);\newline\newline	glMatrixMode(GL_PROJECTION);\newline	glLoadIdentity();\newline	double s = 1.0;\newline#ifdef Q_WS_MAC\newline    glOrtho(-s,s,-(h*s)/w,(h*s)/w,-100.0*s,100.0*s);\newline#else\newline    glOrtho(-s,s,-s,s,-100.0*s,100.0*s);\newline#endif\newline//	glFrustum(-1.0, +1.0, -1.0, 1.0, 5.0, 60.0);\newline	glMatrixMode(GL_MODELVIEW);\newline	glLoadIdentity();\newline	if(w&gth)	m_GLViewRect.SetRect(-s, s*h/w, s, -s*h/w);\newline	else    m_GLViewRect.SetRect(-s*w/h, s, s*w/h, -s*h/w);\newline\newline	if(m_iView == GLMIAREXVIEW)\newline	{\newline		QMiarex* pMiarex = (QMiarex*)s_pMiarex;\newline		pMiarex-&gtm_ArcBall.GetMatrix();\newline//		pMiarex-&gtSetScale(m_rCltRect);\newline		pMiarex-&gtm_bIs3DScaleSet = false;\newline		pMiarex-&gtSet3DScale();\newline	}\newline	else if(m_iView == GLWINGVIEW)\newline	{\newline//		GL3dWingDlg *pDlg = (GL3dWingDlg*)m_pParent;\newline//		pDlg-&gtm_3DWingRect = m_rCltRect;\newline	}\newline	else if(m_iView == GLBODYVIEW)\newline	{\newline		GL3dBodyDlg *pDlg = (GL3dBodyDlg*)m_pParent;\newline		pDlg-&gtm_bIs3DScaleSet = false;\newline		pDlg-&gtSetRectangles();\newline		pDlg-&gtSetBodyScale();\newline		pDlg-&gtSetBodyLineScale();\newline		pDlg-&gtSetFrameScale();\newline	}\newline}\newline","\newline Overrides the resizeGL method of the base class.\newline Sets the GL viewport to fit in the client area.\newline Sets the scaling factors for the objects to be drawn in the viewport.\newline @param width the width in pixels of the client area\newline @param height the height in pixels of the client area\newline \newline","4900256","semanage_store.c","int semanage_direct_get_serial(semanage_handle_t * sh)\newline{\newline	char buf[32];\newline	int fd, commit_number;\newline	ssize_t amount_read;\newline	const char *commit_filename;\newline	memset(buf, 0, sizeof(buf));\newline\newline	if (sh-&gtis_in_transaction) {\newline		commit_filename =\newline		    semanage_path(SEMANAGE_TMP, SEMANAGE_COMMIT_NUM_FILE);\newline	} else {\newline		commit_filename =\newline		    semanage_path(SEMANAGE_ACTIVE, SEMANAGE_COMMIT_NUM_FILE);\newline	}\newline\newline	if ((fd = open(commit_filename, O_RDONLY)) == -1) {\newline		if (errno == ENOENT) {\newline			/* the commit number file does not exist yet,\newline			 * so assume that the number is 0 */\newline			errno = 0;\newline			return 0;\newline		} else {\newline			ERR(sh, &quotCould not open commit number file %s.&quot,\newline			    commit_filename);\newline			return -1;\newline		}\newline	}\newline\newline	amount_read = read(fd, buf, sizeof(buf));\newline	if (amount_read == -1) {\newline		ERR(sh, &quotError while reading commit number from %s.&quot,\newline		    commit_filename);\newline		commit_number = -1;\newline	} else if (sscanf(buf, &quot%d&quot, &ampcommit_number) != 1) {\newline		/* if nothing was read, assume that the commit number is 0 */\newline		commit_number = 0;\newline	} else if (commit_number &lt 0) {\newline		/* read file ought never have negative values */\newline		ERR(sh,\newline		    &quotCommit number file %s is corrupted; it should only contain a non-negative integer.&quot,\newline		    commit_filename);\newline		commit_number = -1;\newline	}\newline\newline	close(fd);\newline	return commit_number;\newline}\newline","Read the current commit number from the commit number file which\newline the handle is pointing, resetting the file pointer afterwards.\newline Return it (a non-negative number), or -1 on error. \newline","4482048","seas_action.c","static inline int process_pings(struct ha *the_table)\newline{\newline   int i,k,elapsed;\newline   struct ping *tmp;\newline   struct timeval now;\newline\newline   tmp=NULL;\newline   gettimeofday(&ampnow,NULL);\newline   if(the_table-&gtcount==0)\newline      return 0;\newline   lock_get(the_table-&gtmutex);\newline   {\newline      print_pingtable(the_table,-1,0);\newline      for(i=0;i&ltthe_table-&gtcount;i++){\newline	 k=(the_table-&gtbegin+i)%the_table-&gtsize;\newline	 tmp=the_table-&gtpings+k;\newline	 elapsed=(now.tv_sec-tmp-&gtsent.tv_sec)*1000+(now.tv_usec-tmp-&gtsent.tv_usec)/1000;\newline	 if(elapsed&gtthe_table-&gttimeout){\newline	    LM_DBG(&quotping timed out %d\\n&quot,tmp-&gtid);\newline	    the_table-&gttimed_out_pings++;\newline	 }else{\newline	    the_table-&gtbegin=k;\newline	    the_table-&gtcount-=i;\newline	    break;\newline	 }\newline      }\newline   }\newline   lock_release(the_table-&gtmutex);\newline   return 0;\newline}\newline","\newline The ha structure (high availability) uses a circular (ring) buffer. A linked\newline list could be used, but it would involve a lot of shm_malloc/free, and this\newline would involve a lot of shm-lock_get/release, which would interfere a lot\newline with all the SER processes. With a this ring buffer, the lock_get/release only\newline involve the SEAS processes.\newline This function scans the ping structures in the buffer, computing the elapsed time\newline from when the ping was sent, so if the ping has timed out, it increases the\newline timed_out_pings counter. All the timed-out pings are removed from the buffer (the\newline begin index is incremented). Because the pings are added always at the end\newline of the buffer, they will always be ordered in increasing time, so when we find one ping\newline that has not timed out, the following pings will neither be.\newline \newline \newline","155605","main.c","static void _sig_term(int sig) {\newline  debug(&quotReceived signal %d to stop&quot, sig);\newline  stop();\newline}\newline","Signal to stop polling \newline","4616850","m-fancy.c","Uint32 MdcCheckStrSize(char *str_to_add, Uint32 current_size, Uint32 max)\newline{\newline  Uint32 max_value = MDC_2KB_OFFSET;\newline  Uint32 new_size;\newline\newline  if (max != 0) max_value = max;\newline\newline  new_size = current_size + (Uint32)strlen(str_to_add);\newline\newline  if ( new_size &gt= max_value ) {\newline    MdcPrntWarn(&quotInternal Problem -- Information string too small&quot);\newline    return(0);\newline  }\newline\newline  return(new_size);\newline} \newline","returns the new stringsize value or 0 in case of error to add \newline","2625899","utilstr.cpp","SWBuf wcharToUTF8(const wchar_t *buf) {\newline\newline	SWBuf utf8Buf;\newline	while (*buf) {\newline		utf8Buf.append(getUTF8FromUniChar(*buf++));\newline	}\newline	return utf8Buf;\newline}\newline","\newline This can be called to convert a wchar_t[] to a UTF-8 SWBuf\newline \newline \newline","5951567","linelist.c","static void Remove_duplicates_line_list( struct line_list *l )\newline{\newline	char *s, *t;\newline	int i, j;\newline	for( i = 0; i &lt l-&gtcount; ){\newline		if( (s = l-&gtlist[i]) ){\newline			for( j = i+1; j &lt l-&gtcount; ){\newline				if( !(t = l-&gtlist[j]) || !safestrcmp(s,t) ){\newline					Remove_line_list( l, j );\newline				} else {\newline					++j;\newline				}\newline			}\newline			++i;\newline		} else {\newline			Remove_line_list( l, i );\newline		}\newline	}\newline}\newline","\newline Remove_duplicates_line_list( struct line_list l )\newline Remove duplicate entries in the list\newline \newline","2276472","plugins.c","void plugin_unload_plugins(GList * list)\newline{\newline  g_list_foreach ( list, (GFunc) plugin_foreach_free, NULL );\newline  g_list_free ( list );\newline}\newline","Unloads all the plugins loaded in the GList \newline","2168957","auth.c","static int scan_authfile(FILE *f,char *client,char *server,char *secret,struct wordlist ** addrs,char *filename)\newline{\newline	int newline, xxx;\newline	int got_flag, best_flag;\newline	FILE *sf;\newline	struct wordlist *ap, *addr_list, *addr_last;\newline	char word[MAXWORDLEN];\newline	char atfile[MAXWORDLEN];\newline\newline	if (addrs != NULL)\newline		*addrs = NULL;\newline	addr_list = NULL;\newline	if (!getword(f, word, &ampnewline, filename))\newline		return -1;                /* file is empty??? */\newline	newline = 1;\newline	best_flag = -1;\newline	for (;;) {\newline		/*\newline		 * Skip until we find a word at the start of a line.\newline		 */\newline		while (!newline &amp&amp getword(f, word, &ampnewline, filename))\newline			;\newline		if (!newline)\newline			break;                /* got to end of file */\newline\newline		/*\newline		 * Got a client - check if it&#039s a match or a wildcard.\newline		 */\newline		got_flag = 0;\newline		if (client != NULL &amp&amp strcmp(word, client) != 0 &amp&amp !ISWILD(word)) {\newline			newline = 0;\newline			continue;\newline		}\newline		if (!ISWILD(word))\newline			got_flag = NONWILD_CLIENT;\newline\newline		/*\newline		 * Now get a server and check if it matches.\newline		 */\newline		if (!getword(f, word, &ampnewline, filename))\newline			break;\newline		if (newline)\newline			continue;\newline		if (server != NULL &amp&amp strcmp(word, server) != 0 &amp&amp !ISWILD(word))\newline			continue;\newline		if (!ISWILD(word))\newline			got_flag |= NONWILD_SERVER;\newline\newline		/*\newline		 * Got some sort of a match - see if it&#039s better than what\newline		 * we have already.\newline		 */\newline		if (got_flag &lt= best_flag)\newline			continue;\newline\newline		/*\newline		 * Get the secret.\newline		 */\newline		if (!getword(f, word, &ampnewline, filename))\newline			break;\newline		if (newline)\newline			continue;\newline\newline		/*\newline		 * Special syntax: @filename means read secret from file.\newline		 */\newline		if (word[0] == &#039@&#039) {\newline			strcpy(atfile, word+1);\newline			if ((sf = fopen(atfile, &quotr&quot)) == NULL) {\newline				syslog(LOG_WARNING, &quotcan&#039t open indirect secret file %s&quot,\newline					   atfile);\newline				continue;\newline			}\newline			check_access(sf, atfile);\newline			if (!getword(sf, word, &ampxxx, atfile)) {\newline				syslog(LOG_WARNING, &quotno secret in indirect secret file %s&quot,\newline					   atfile);\newline				fclose(sf);\newline				continue;\newline			}\newline			fclose(sf);\newline		}\newline		if (secret != NULL)\newline			strcpy(secret, word);\newline				\newline		best_flag = got_flag;\newline\newline		/*\newline		 * Now read address authorization info and make a wordlist.\newline		 */\newline		if (addr_list)\newline			free_wordlist(addr_list);\newline		addr_list = addr_last = NULL;\newline		for (;;) {\newline			if (!getword(f, word, &ampnewline, filename) || newline)\newline				break;\newline			ap = (struct wordlist *) malloc(sizeof(struct wordlist) + strlen(word));\newline			if (ap == NULL)\newline				novm(&quotauthorized addresses&quot);\newline			ap-&gtnext = NULL;\newline			strcpy(ap-&gtword, word);\newline			if (addr_list == NULL)\newline				addr_list = ap;\newline			else\newline				addr_last-&gtnext = ap;\newline			addr_last = ap;\newline		}\newline		if (!newline)\newline			break;\newline	}\newline\newline	if (addrs != NULL)\newline		*addrs = addr_list;\newline	else if (addr_list != NULL)\newline		free_wordlist(addr_list);\newline\newline	return best_flag;\newline}\newline","\newline scan_authfile - Scan an authorization file for a secret suitable\newline for authenticating `client&#039 on `server&#039. The return value is -1\newline if no secret is found, otherwise &gt= 0. The return value has\newline NONWILD_CLIENT set if the secret didn&#039t have &quot &quot for the client, and\newline NONWILD_SERVER set if the secret didn&#039t have &quot &quot for the server.\newline Any following words on the line (i.e. address authorization\newline info) are placed in a wordlist and returned in addrs. \newline \newline","4219456","lxplib.c","static void dischargestring (lxp_userdata *xpu) {\newline  assert(xpu-&gtstate == XPSstring);\newline  xpu-&gtstate = XPSok;\newline  luaL_pushresult(xpu-&gtb);\newline  docall(xpu, 1, 0);\newline}\newline","\newline Check whether there is pending Cdata, and call its handle if necessary\newline \newline","705324","dw_parse_cmd.c","int dw_FindArgument_String(int nargs, char **args, const char *opt)\newline{\newline  int i;\newline  for (i=nargs-1; i &gt= 0; i--)\newline    if (((args[i][0] == ARGUMENT_ID_1) || (args[i][0] == ARGUMENT_ID_2)) &amp&amp !strcmp(args[i]+1,opt)) break;\newline  return i;\newline}\newline","\newlineSearches args for a leading ARGUMENT_ID followed by the string opt. Returns\newlinethe index if found and -1 otherwise.\newline \newline","4212707","yubico-piv-tool.c","static bool change_pin(ykpiv_state *state, enum enum_action action, const char *pin,\newline    const char *new_pin) {\newline  char pinbuf[9] = {0};\newline  char new_pinbuf[9] = {0};\newline  const char *name = action == action_arg_changeMINUS_pin ? &quotpin&quot : &quotpuk&quot;\newline  const char *new_name = action == action_arg_changeMINUS_puk ? &quotnew puk&quot : &quotnew pin&quot;\newline  int (*op)(ykpiv_state *state, const char * puk, size_t puk_len,\newline            const char * new_pin, size_t new_pin_len, int *tries) = ykpiv_change_pin;\newline  size_t pin_len;\newline  size_t new_len;\newline  int tries;\newline  ykpiv_rc res;\newline\newline  if(!pin) {\newline    if (!read_pw(name, pinbuf, sizeof(pinbuf), false)) {\newline      return false;\newline    }\newline    pin = pinbuf;\newline  }\newline  if(!new_pin) {\newline    if (!read_pw(new_name, new_pinbuf, sizeof(new_pinbuf), true)) {\newline      return false;\newline    }\newline    new_pin = new_pinbuf;\newline  }\newline  pin_len = strlen(pin);\newline  new_len = strlen(new_pin);\newline\newline  if(pin_len &gt 8 || new_len &gt 8) {\newline    fprintf(stderr, &quotMaximum 8 digits of PIN supported.\\n&quot);\newline    return false;\newline  }\newline\newline  if(new_len &lt 6) {\newline    fprintf(stderr, &quotMinimum 6 digits of PIN supported.\\n&quot);\newline    return false;\newline  }\newline\newline  if(action == action_arg_unblockMINUS_pin) {\newline    op = ykpiv_unblock_pin;\newline  }\newline  else if(action == action_arg_changeMINUS_puk) {\newline    op = ykpiv_change_puk;\newline  }\newline  res = op(state, pin, pin_len, new_pin, new_len, &amptries);\newline  switch (res) {\newline    case YKPIV_OK:\newline      return true;\newline\newline    case YKPIV_WRONG_PIN:\newline      fprintf(stderr, &quotFailed verifying %s code, now %d tries left before blocked.\\n&quot,\newline              name, tries);\newline      return false;\newline\newline    case YKPIV_PIN_LOCKED:\newline      if(action == action_arg_changeMINUS_pin) {\newline        fprintf(stderr, &quotThe pin code is blocked, use the unblock-pin action to unblock it.\\n&quot);\newline      } else {\newline        fprintf(stderr, &quotThe puk code is blocked, you will have to reinitialize the application.\\n&quot);\newline      }\newline      return false;\newline\newline    default:\newline      fprintf(stderr, &quotFailed changing/unblocking code, error: %s\\n&quot, ykpiv_strerror(res));\newline      return false;\newline  }\newline}\newline","this function is called for all three of change-pin, change-puk and unblock pin\newline since they&#039re very similar in what data they use. \newline","2215099","data.c","API_EXPORTED struct fp_print_data *fp_print_data_from_data(unsigned char *buf,\newline	size_t buflen)\newline{\newline	struct fpi_print_data_fp2 *raw = (struct fpi_print_data_fp2 *) buf;\newline\newline	fp_dbg(&quotbuffer size %zd&quot, buflen);\newline	if (buflen &lt sizeof(*raw))\newline		return NULL;\newline\newline	if (strncmp(raw-&gtprefix, &quotFP1&quot, 3) == 0) {\newline		return fpi_print_data_from_fp1_data(buf, buflen);\newline	} else if (strncmp(raw-&gtprefix, &quotFP2&quot, 3) == 0) {\newline		return fpi_print_data_from_fp2_data(buf, buflen);\newline	} else {\newline		fp_dbg(&quotbad header prefix&quot);\newline	}\newline\newline	return NULL;\newline}\newline","\\ingroup print_data\newline Load a stored print from a data buffer. The contents of said buffer must\newline be the untouched contents of a buffer previously supplied to you by the\newline fp_print_data_get_data() function.\newline \\param buf the data buffer\newline \\param buflen the length of the buffer\newline \\returns the stored print represented by the data, or NULL on error. Must\newline be freed with fp_print_data_free() after use.\newline \newline","","","","","","on","","","","","","on","","","on","","","","","","","","","on","","","","","","","","","","","","","on","","","","","on","Release distribution lock","Read the current commit number from the commit number file","All the timed-out pings are removed from the buffer","Signal to stop polling","returns the new stringsize value","{}","Remove duplicate entries in the list","Unloads all the plugins loaded in the GList","Scan an authorization file for a secret suitable for authenticating","Check whether there is pending Cdata,","Searches args for a leading ARGUMENT_ID","{}","called for all three of change-pin, change-puk and unblock pin","Load a stored print from a data buffer.","{}","using a mask and a value to match against that mask.","return an http chunk with previous unknown size.","locates the cursor on the text screen","Finds the EPG of the current program.","message to buffer pointed by 'cmd'.","Sets the scaling factors"
"3RIHDBQ1NEYF34HPBBKAUOXFY8OMHR","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","3GNCZX450IN8143HNN7BJP0V66CAP7","AVC62JNYAXA45","Approved","Wed Apr 17 14:17:43 PDT 2019","Wed Apr 17 14:51:31 PDT 2019","Fri Apr 19 14:51:31 PDT 2019","2019-04-19 21:52:21 UTC","","","2028","100% (24/24)","100% (24/24)","100% (24/24)","331837","hashfs.c","rc_ty sx_hashfs_distlock_release(sx_hashfs_t *h) {\newline    sqlite3_reset(h-&gtq_delval);\newline    if(qbind_text(h-&gtq_delval, &quot:k&quot, &quotdistlock&quot) || qstep_noret(h-&gtq_delval)) {\newline        WARN(&quotFailed to unlock distribution&quot);\newline        return FAIL_EINTERNAL;\newline    }\newline\newline    return OK;\newline}\newline","Release distribution lock \newline","6038116","dmmain.c","static int display_presize(void *handle, void *device, int width, int height,\newline    int raster, unsigned int format)\newline{\newline    /* Check for correct format (32-bit RGB), fatal error if not */\newline    if (format != display_format)\newline    {\newline        printf(&quotDisplayFormat has been set to an incompatible value.\\n&quot);\newline        fflush(stdout);\newline        return gs_error_rangecheck;\newline    }\newline\newline    return 0;\newline}\newline","Resize will only occur if this function returns 0. \newline","4216330","sv_user.c","static void Cmd_Spawn_f (void)\newline{\newline	int		i;\newline	client_t	*client;\newline	edict_t	*ent;\newline	eval_t *val;\newline	unsigned n;\newline#ifdef USE_PR2\newline	string_t	savenetname;\newline#endif\newline\newline	if (sv_client-&gtstate != cs_connected)\newline	{\newline		Con_Printf (&quotSpawn not valid -- already spawned\\n&quot);\newline		return;\newline	}\newline\newline	// handle the case of a level changing while a client was connecting\newline	if (Q_atoi(Cmd_Argv(1)) != svs.spawncount)\newline	{\newline		SV_ClearReliable (sv_client);\newline		Con_Printf (&quotSV_Spawn_f from different level\\n&quot);\newline		Cmd_New_f ();\newline		return;\newline	}\newline\newline	n = Q_atoi(Cmd_Argv(2));\newline	if (n &gt= MAX_CLIENTS)\newline	{\newline		SV_ClientPrintf (sv_client, PRINT_HIGH,\newline		                 &quotSV_Spawn_f: Invalid client start\\n&quot);\newline		SV_DropClient (sv_client);\newline		return;\newline	}\newline\newline	// send all current names, colors, and frag counts\newline	// FIXME: is this a good thing?\newline	SZ_Clear (&ampsv_client-&gtnetchan.message);\newline\newline	// send current status of all other players\newline\newline	// normally this could overflow, but no need to check due to backbuf\newline	for (i=n, client = svs.clients + n ; i&ltMAX_CLIENTS &amp&amp sv_client-&gtnetchan.message.cursize &lt (MAX_MSGLEN/2); i++, client++)\newline		SV_FullClientUpdateToClient (client, sv_client);\newline\newline	if (i &lt MAX_CLIENTS)\newline	{\newline		MSG_WriteByte (&ampsv_client-&gtnetchan.message, svc_stufftext);\newline		MSG_WriteString (&ampsv_client-&gtnetchan.message,\newline		                 va(&quotcmd spawn %i %d\\n&quot, svs.spawncount, i) );\newline		return;\newline	}\newline\newline	// send all current light styles\newline	for (i=0 ; i&ltMAX_LIGHTSTYLES ; i++)\newline	{\newline		ClientReliableWrite_Begin (sv_client, svc_lightstyle,\newline		                           3 + (sv.lightstyles[i] ? strlen(sv.lightstyles[i]) : 1));\newline		ClientReliableWrite_Byte (sv_client, (char)i);\newline		ClientReliableWrite_String (sv_client, sv.lightstyles[i]);\newline	}\newline\newline	// set up the edict\newline	ent = sv_client-&gtedict;\newline\newline	if (sv.loadgame)\newline	{\newline		// loaded games are already fully initialized \newline		// if this is the last client to be connected, unpause\newline\newline		if (sv.paused &amp 1)\newline			SV_TogglePause (NULL, 1);\newline	}\newline	else\newline	{\newline#ifdef USE_PR2\newline		if ( sv_vm )\newline		{\newline			savenetname = ent-&gtv.netname;\newline			memset(&ampent-&gtv, 0, pr_edict_size - sizeof(edict_t) + sizeof(entvars_t));\newline			ent-&gtv.netname = savenetname;\newline    \newline			// so spec will have right goalentity - if speccing someone\newline			// qqshka {\newline			if(sv_client-&gtspectator &amp&amp sv_client-&gtspec_track &gt 0)\newline				ent-&gtv.goalentity = EDICT_TO_PROG(svs.clients[sv_client-&gtspec_track-1].edict);\newline    \newline			// }\newline    \newline			//sv_client-&gtname = PR2_GetString(ent-&gtv.netname);\newline			//strlcpy(PR2_GetString(ent-&gtv.netname), sv_client-&gtname, 32);\newline		}\newline		else\newline#endif\newline		{\newline			memset (&ampent-&gtv, 0, progs-&gtentityfields * 4);\newline			ent-&gtv.netname = PR_SetString(sv_client-&gtname);\newline		}\newline		ent-&gtv.colormap = NUM_FOR_EDICT(ent);\newline		ent-&gtv.team = 0;	// FIXME\newline		if (pr_teamfield)\newline			E_INT(ent, pr_teamfield) = PR_SetString(sv_client-&gtteam);\newline	}\newline\newline	sv_client-&gtentgravity = 1.0;\newline	val =\newline#ifdef USE_PR2\newline	    PR2_GetEdictFieldValue(ent, &quotgravity&quot);\newline#else\newline	    GetEdictFieldValue(ent, &quotgravity&quot);\newline#endif\newline	if (val)\newline		val-&gt_float = 1.0;\newline	sv_client-&gtmaxspeed = sv_maxspeed.value;\newline	val =\newline#ifdef USE_PR2\newline	    PR2_GetEdictFieldValue(ent, &quotmaxspeed&quot);\newline#else\newline		GetEdictFieldValue(ent, &quotmaxspeed&quot);\newline#endif\newline	if (val)\newline		val-&gt_float = sv_maxspeed.value;\newline\newline	//\newline	// force stats to be updated\newline	//\newline	memset (sv_client-&gtstats, 0, sizeof(sv_client-&gtstats));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_TOTALSECRETS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(total_secrets));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_TOTALMONSTERS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(total_monsters));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_SECRETS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(found_secrets));\newline\newline	ClientReliableWrite_Begin (sv_client, svc_updatestatlong, 6);\newline	ClientReliableWrite_Byte (sv_client, STAT_MONSTERS);\newline	ClientReliableWrite_Long (sv_client, PR_GLOBAL(killed_monsters));\newline\newline	// get the client to check and download skins\newline	// when that is completed, a begin command will be issued\newline	ClientReliableWrite_Begin (sv_client, svc_stufftext, 8);\newline	ClientReliableWrite_String (sv_client, &quotskins\\n&quot );\newline\newline}\newline","\newline==================\newlineCmd_Spawn_f\newline==================\newline \newline","4694037","ceph_frag.h","static inline __u32 ceph_frag_make(__u32 b, __u32 v)\newline{\newline	return (b &lt&lt 24) |\newline		(v &amp (0xffffffu &lt&lt (24-b)) &amp 0xffffffu);\newline}\newline","\newline &quotFrags&quot are a way to describe a subset of a 32-bit number space,\newline using a mask and a value to match against that mask. Any given frag\newline (subset of the number space) can be partitioned into 2^n sub-frags.\newline \newline Frags are encoded into a 32-bit word:\newline 8 upper bits = &quotbits&quot\newline 24 lower bits = &quotvalue&quot\newline (We could go to 5+27 bits, but who cares.)\newline \newline We use the _most_ significant bits of the 24 bit value. This makes\newline values logically sort.\newline \newline Unfortunately, because the &quotbits&quot field is still in the high bits, we\newline can&#039t sort encoded frags numerically. However, it does allow you\newline to feed encoded frags as values into frag_contains_value.\newline \newline","2178191","libhttp.c","int http_return_stream(struct http_connection *hc, void *data, size_t datalen) {\newline	/* We are chunked and done sending - end session */\newline	if (!data) {\newline		/* Chunked transfer - send a 0 chunk */\newline		if (hc-&gtproto == HP_HTTP11) {\newline			evbuffer_add_printf(hc-&gtevb,&quot0\\r\\n\\r\\n&quot);\newline			bufferevent_write_buffer(hc-&gtbev, hc-&gtevb);\newline		}\newline		hc-&gtstatus=HC_STATUS_END;\newline		return 1;\newline	}\newline\newline	/* In case of Transfer-Encoding: chunked send a chunk - otherwise just data */\newline	if (hc-&gtproto == HP_HTTP11) {\newline		evbuffer_add_printf(hc-&gtevb,&quot%x\\r\\n&quot, datalen);\newline		evbuffer_add(hc-&gtevb, data, datalen);\newline		evbuffer_add_printf(hc-&gtevb, &quot\\r\\n&quot);\newline	} else {\newline		evbuffer_add(hc-&gtevb, data, datalen);\newline	}\newline\newline	bufferevent_write_buffer(hc-&gtbev, hc-&gtevb);\newline\newline	Dprintf(&quot%s: output buffer len %d\\n&quot, __FUNCTION__,\newline			EVBUFFER_LENGTH(hc-&gtbev-&gtoutput));\newline\newline	return 1;\newline}\newline","\newline Function to return an http chunk with previous unknown size. HTTP/1.1 allows\newline for chunked transfers which HTTP/1.0 doesnt know about. There is no legal way\newline to do this so we hope our best.\newline \newline \newline","5108163","graphsdl.c","void find_cursor(void) {\newline//  if (graphmode!=FULLSCREEN) {\newline//    xtext = wherex()-1;\newline//    ytext = wherey()-1;\newline//  }\newline}\newline","\newline &#039find_cursor&#039 locates the cursor on the text screen and ensures that\newline its position is valid, that is, lies within the text window\newline \newline","1082564","input_dvb.c","static epg_entry_t* current_epg(channel_t* channel) {\newline    epg_entry_t* next = ith_next_epg(channel, 0);\newline#ifdef DEBUG_EPG\newline    if (next != NULL)\newline	printf(&quotinput_dvb: EPG  current: %s (%d)\\n&quot, next-&gtprogname, next-&gtrunning);\newline#endif\newline    return next;\newline}\newline","Finds the EPG of the current program. If not found, returns NULL. \newline","2633555","cmtspeech_msgs.c","int cmtspeech_msg_encode_reset_conn_resp(cmtspeech_cmd_t *cmd)\newline{\newline  cmd-&gtd.buf[BYTE0] = (CMTSPEECH_RESET_CONN_RESP &lt&lt 4) | CMTSPEECH_DOMAIN_CONTROL;\newline  cmd-&gtd.buf[BYTE1] = 0x0;\newline  cmd-&gtd.buf[BYTE2] = 0x0;\newline  cmd-&gtd.buf[BYTE3] = 0x0;\newline\newline  return 4;\newline}\newline","\newline Encodes an RESET_CONN_RESP message to buffer pointed\newline by &#039cmd&#039. Returns size of encoded data (in octets).\newline \newline","3092860","threedwidget.cpp","void ThreeDWidget::resizeGL(int width, int height)\newline{\newline	double w, h;\newline	m_rCltRect = geometry();\newline	int side = qMax(width, height);\newline	w = (double)width;\newline	h = (double)height;\newline\newline#ifdef Q_WS_MAC\newline    glViewport(0,0, width, height);\newline#else\newline	glViewport((width - side) / 2, (height - side) / 2, side, side);\newline#endif\newline//	d = qMax(w,h);\newline//	glViewport(0,0, d, d);\newline\newline	glMatrixMode(GL_PROJECTION);\newline	glLoadIdentity();\newline	double s = 1.0;\newline#ifdef Q_WS_MAC\newline    glOrtho(-s,s,-(h*s)/w,(h*s)/w,-100.0*s,100.0*s);\newline#else\newline    glOrtho(-s,s,-s,s,-100.0*s,100.0*s);\newline#endif\newline//	glFrustum(-1.0, +1.0, -1.0, 1.0, 5.0, 60.0);\newline	glMatrixMode(GL_MODELVIEW);\newline	glLoadIdentity();\newline	if(w&gth)	m_GLViewRect.SetRect(-s, s*h/w, s, -s*h/w);\newline	else    m_GLViewRect.SetRect(-s*w/h, s, s*w/h, -s*h/w);\newline\newline	if(m_iView == GLMIAREXVIEW)\newline	{\newline		QMiarex* pMiarex = (QMiarex*)s_pMiarex;\newline		pMiarex-&gtm_ArcBall.GetMatrix();\newline//		pMiarex-&gtSetScale(m_rCltRect);\newline		pMiarex-&gtm_bIs3DScaleSet = false;\newline		pMiarex-&gtSet3DScale();\newline	}\newline	else if(m_iView == GLWINGVIEW)\newline	{\newline//		GL3dWingDlg *pDlg = (GL3dWingDlg*)m_pParent;\newline//		pDlg-&gtm_3DWingRect = m_rCltRect;\newline	}\newline	else if(m_iView == GLBODYVIEW)\newline	{\newline		GL3dBodyDlg *pDlg = (GL3dBodyDlg*)m_pParent;\newline		pDlg-&gtm_bIs3DScaleSet = false;\newline		pDlg-&gtSetRectangles();\newline		pDlg-&gtSetBodyScale();\newline		pDlg-&gtSetBodyLineScale();\newline		pDlg-&gtSetFrameScale();\newline	}\newline}\newline","\newline Overrides the resizeGL method of the base class.\newline Sets the GL viewport to fit in the client area.\newline Sets the scaling factors for the objects to be drawn in the viewport.\newline @param width the width in pixels of the client area\newline @param height the height in pixels of the client area\newline \newline","4900256","semanage_store.c","int semanage_direct_get_serial(semanage_handle_t * sh)\newline{\newline	char buf[32];\newline	int fd, commit_number;\newline	ssize_t amount_read;\newline	const char *commit_filename;\newline	memset(buf, 0, sizeof(buf));\newline\newline	if (sh-&gtis_in_transaction) {\newline		commit_filename =\newline		    semanage_path(SEMANAGE_TMP, SEMANAGE_COMMIT_NUM_FILE);\newline	} else {\newline		commit_filename =\newline		    semanage_path(SEMANAGE_ACTIVE, SEMANAGE_COMMIT_NUM_FILE);\newline	}\newline\newline	if ((fd = open(commit_filename, O_RDONLY)) == -1) {\newline		if (errno == ENOENT) {\newline			/* the commit number file does not exist yet,\newline			 * so assume that the number is 0 */\newline			errno = 0;\newline			return 0;\newline		} else {\newline			ERR(sh, &quotCould not open commit number file %s.&quot,\newline			    commit_filename);\newline			return -1;\newline		}\newline	}\newline\newline	amount_read = read(fd, buf, sizeof(buf));\newline	if (amount_read == -1) {\newline		ERR(sh, &quotError while reading commit number from %s.&quot,\newline		    commit_filename);\newline		commit_number = -1;\newline	} else if (sscanf(buf, &quot%d&quot, &ampcommit_number) != 1) {\newline		/* if nothing was read, assume that the commit number is 0 */\newline		commit_number = 0;\newline	} else if (commit_number &lt 0) {\newline		/* read file ought never have negative values */\newline		ERR(sh,\newline		    &quotCommit number file %s is corrupted; it should only contain a non-negative integer.&quot,\newline		    commit_filename);\newline		commit_number = -1;\newline	}\newline\newline	close(fd);\newline	return commit_number;\newline}\newline","Read the current commit number from the commit number file which\newline the handle is pointing, resetting the file pointer afterwards.\newline Return it (a non-negative number), or -1 on error. \newline","4482048","seas_action.c","static inline int process_pings(struct ha *the_table)\newline{\newline   int i,k,elapsed;\newline   struct ping *tmp;\newline   struct timeval now;\newline\newline   tmp=NULL;\newline   gettimeofday(&ampnow,NULL);\newline   if(the_table-&gtcount==0)\newline      return 0;\newline   lock_get(the_table-&gtmutex);\newline   {\newline      print_pingtable(the_table,-1,0);\newline      for(i=0;i&ltthe_table-&gtcount;i++){\newline	 k=(the_table-&gtbegin+i)%the_table-&gtsize;\newline	 tmp=the_table-&gtpings+k;\newline	 elapsed=(now.tv_sec-tmp-&gtsent.tv_sec)*1000+(now.tv_usec-tmp-&gtsent.tv_usec)/1000;\newline	 if(elapsed&gtthe_table-&gttimeout){\newline	    LM_DBG(&quotping timed out %d\\n&quot,tmp-&gtid);\newline	    the_table-&gttimed_out_pings++;\newline	 }else{\newline	    the_table-&gtbegin=k;\newline	    the_table-&gtcount-=i;\newline	    break;\newline	 }\newline      }\newline   }\newline   lock_release(the_table-&gtmutex);\newline   return 0;\newline}\newline","\newline The ha structure (high availability) uses a circular (ring) buffer. A linked\newline list could be used, but it would involve a lot of shm_malloc/free, and this\newline would involve a lot of shm-lock_get/release, which would interfere a lot\newline with all the SER processes. With a this ring buffer, the lock_get/release only\newline involve the SEAS processes.\newline This function scans the ping structures in the buffer, computing the elapsed time\newline from when the ping was sent, so if the ping has timed out, it increases the\newline timed_out_pings counter. All the timed-out pings are removed from the buffer (the\newline begin index is incremented). Because the pings are added always at the end\newline of the buffer, they will always be ordered in increasing time, so when we find one ping\newline that has not timed out, the following pings will neither be.\newline \newline \newline","155605","main.c","static void _sig_term(int sig) {\newline  debug(&quotReceived signal %d to stop&quot, sig);\newline  stop();\newline}\newline","Signal to stop polling \newline","4616850","m-fancy.c","Uint32 MdcCheckStrSize(char *str_to_add, Uint32 current_size, Uint32 max)\newline{\newline  Uint32 max_value = MDC_2KB_OFFSET;\newline  Uint32 new_size;\newline\newline  if (max != 0) max_value = max;\newline\newline  new_size = current_size + (Uint32)strlen(str_to_add);\newline\newline  if ( new_size &gt= max_value ) {\newline    MdcPrntWarn(&quotInternal Problem -- Information string too small&quot);\newline    return(0);\newline  }\newline\newline  return(new_size);\newline} \newline","returns the new stringsize value or 0 in case of error to add \newline","2625899","utilstr.cpp","SWBuf wcharToUTF8(const wchar_t *buf) {\newline\newline	SWBuf utf8Buf;\newline	while (*buf) {\newline		utf8Buf.append(getUTF8FromUniChar(*buf++));\newline	}\newline	return utf8Buf;\newline}\newline","\newline This can be called to convert a wchar_t[] to a UTF-8 SWBuf\newline \newline \newline","5951567","linelist.c","static void Remove_duplicates_line_list( struct line_list *l )\newline{\newline	char *s, *t;\newline	int i, j;\newline	for( i = 0; i &lt l-&gtcount; ){\newline		if( (s = l-&gtlist[i]) ){\newline			for( j = i+1; j &lt l-&gtcount; ){\newline				if( !(t = l-&gtlist[j]) || !safestrcmp(s,t) ){\newline					Remove_line_list( l, j );\newline				} else {\newline					++j;\newline				}\newline			}\newline			++i;\newline		} else {\newline			Remove_line_list( l, i );\newline		}\newline	}\newline}\newline","\newline Remove_duplicates_line_list( struct line_list l )\newline Remove duplicate entries in the list\newline \newline","2276472","plugins.c","void plugin_unload_plugins(GList * list)\newline{\newline  g_list_foreach ( list, (GFunc) plugin_foreach_free, NULL );\newline  g_list_free ( list );\newline}\newline","Unloads all the plugins loaded in the GList \newline","2168957","auth.c","static int scan_authfile(FILE *f,char *client,char *server,char *secret,struct wordlist ** addrs,char *filename)\newline{\newline	int newline, xxx;\newline	int got_flag, best_flag;\newline	FILE *sf;\newline	struct wordlist *ap, *addr_list, *addr_last;\newline	char word[MAXWORDLEN];\newline	char atfile[MAXWORDLEN];\newline\newline	if (addrs != NULL)\newline		*addrs = NULL;\newline	addr_list = NULL;\newline	if (!getword(f, word, &ampnewline, filename))\newline		return -1;                /* file is empty??? */\newline	newline = 1;\newline	best_flag = -1;\newline	for (;;) {\newline		/*\newline		 * Skip until we find a word at the start of a line.\newline		 */\newline		while (!newline &amp&amp getword(f, word, &ampnewline, filename))\newline			;\newline		if (!newline)\newline			break;                /* got to end of file */\newline\newline		/*\newline		 * Got a client - check if it&#039s a match or a wildcard.\newline		 */\newline		got_flag = 0;\newline		if (client != NULL &amp&amp strcmp(word, client) != 0 &amp&amp !ISWILD(word)) {\newline			newline = 0;\newline			continue;\newline		}\newline		if (!ISWILD(word))\newline			got_flag = NONWILD_CLIENT;\newline\newline		/*\newline		 * Now get a server and check if it matches.\newline		 */\newline		if (!getword(f, word, &ampnewline, filename))\newline			break;\newline		if (newline)\newline			continue;\newline		if (server != NULL &amp&amp strcmp(word, server) != 0 &amp&amp !ISWILD(word))\newline			continue;\newline		if (!ISWILD(word))\newline			got_flag |= NONWILD_SERVER;\newline\newline		/*\newline		 * Got some sort of a match - see if it&#039s better than what\newline		 * we have already.\newline		 */\newline		if (got_flag &lt= best_flag)\newline			continue;\newline\newline		/*\newline		 * Get the secret.\newline		 */\newline		if (!getword(f, word, &ampnewline, filename))\newline			break;\newline		if (newline)\newline			continue;\newline\newline		/*\newline		 * Special syntax: @filename means read secret from file.\newline		 */\newline		if (word[0] == &#039@&#039) {\newline			strcpy(atfile, word+1);\newline			if ((sf = fopen(atfile, &quotr&quot)) == NULL) {\newline				syslog(LOG_WARNING, &quotcan&#039t open indirect secret file %s&quot,\newline					   atfile);\newline				continue;\newline			}\newline			check_access(sf, atfile);\newline			if (!getword(sf, word, &ampxxx, atfile)) {\newline				syslog(LOG_WARNING, &quotno secret in indirect secret file %s&quot,\newline					   atfile);\newline				fclose(sf);\newline				continue;\newline			}\newline			fclose(sf);\newline		}\newline		if (secret != NULL)\newline			strcpy(secret, word);\newline				\newline		best_flag = got_flag;\newline\newline		/*\newline		 * Now read address authorization info and make a wordlist.\newline		 */\newline		if (addr_list)\newline			free_wordlist(addr_list);\newline		addr_list = addr_last = NULL;\newline		for (;;) {\newline			if (!getword(f, word, &ampnewline, filename) || newline)\newline				break;\newline			ap = (struct wordlist *) malloc(sizeof(struct wordlist) + strlen(word));\newline			if (ap == NULL)\newline				novm(&quotauthorized addresses&quot);\newline			ap-&gtnext = NULL;\newline			strcpy(ap-&gtword, word);\newline			if (addr_list == NULL)\newline				addr_list = ap;\newline			else\newline				addr_last-&gtnext = ap;\newline			addr_last = ap;\newline		}\newline		if (!newline)\newline			break;\newline	}\newline\newline	if (addrs != NULL)\newline		*addrs = addr_list;\newline	else if (addr_list != NULL)\newline		free_wordlist(addr_list);\newline\newline	return best_flag;\newline}\newline","\newline scan_authfile - Scan an authorization file for a secret suitable\newline for authenticating `client&#039 on `server&#039. The return value is -1\newline if no secret is found, otherwise &gt= 0. The return value has\newline NONWILD_CLIENT set if the secret didn&#039t have &quot &quot for the client, and\newline NONWILD_SERVER set if the secret didn&#039t have &quot &quot for the server.\newline Any following words on the line (i.e. address authorization\newline info) are placed in a wordlist and returned in addrs. \newline \newline","4219456","lxplib.c","static void dischargestring (lxp_userdata *xpu) {\newline  assert(xpu-&gtstate == XPSstring);\newline  xpu-&gtstate = XPSok;\newline  luaL_pushresult(xpu-&gtb);\newline  docall(xpu, 1, 0);\newline}\newline","\newline Check whether there is pending Cdata, and call its handle if necessary\newline \newline","705324","dw_parse_cmd.c","int dw_FindArgument_String(int nargs, char **args, const char *opt)\newline{\newline  int i;\newline  for (i=nargs-1; i &gt= 0; i--)\newline    if (((args[i][0] == ARGUMENT_ID_1) || (args[i][0] == ARGUMENT_ID_2)) &amp&amp !strcmp(args[i]+1,opt)) break;\newline  return i;\newline}\newline","\newlineSearches args for a leading ARGUMENT_ID followed by the string opt. Returns\newlinethe index if found and -1 otherwise.\newline \newline","4212707","yubico-piv-tool.c","static bool change_pin(ykpiv_state *state, enum enum_action action, const char *pin,\newline    const char *new_pin) {\newline  char pinbuf[9] = {0};\newline  char new_pinbuf[9] = {0};\newline  const char *name = action == action_arg_changeMINUS_pin ? &quotpin&quot : &quotpuk&quot;\newline  const char *new_name = action == action_arg_changeMINUS_puk ? &quotnew puk&quot : &quotnew pin&quot;\newline  int (*op)(ykpiv_state *state, const char * puk, size_t puk_len,\newline            const char * new_pin, size_t new_pin_len, int *tries) = ykpiv_change_pin;\newline  size_t pin_len;\newline  size_t new_len;\newline  int tries;\newline  ykpiv_rc res;\newline\newline  if(!pin) {\newline    if (!read_pw(name, pinbuf, sizeof(pinbuf), false)) {\newline      return false;\newline    }\newline    pin = pinbuf;\newline  }\newline  if(!new_pin) {\newline    if (!read_pw(new_name, new_pinbuf, sizeof(new_pinbuf), true)) {\newline      return false;\newline    }\newline    new_pin = new_pinbuf;\newline  }\newline  pin_len = strlen(pin);\newline  new_len = strlen(new_pin);\newline\newline  if(pin_len &gt 8 || new_len &gt 8) {\newline    fprintf(stderr, &quotMaximum 8 digits of PIN supported.\\n&quot);\newline    return false;\newline  }\newline\newline  if(new_len &lt 6) {\newline    fprintf(stderr, &quotMinimum 6 digits of PIN supported.\\n&quot);\newline    return false;\newline  }\newline\newline  if(action == action_arg_unblockMINUS_pin) {\newline    op = ykpiv_unblock_pin;\newline  }\newline  else if(action == action_arg_changeMINUS_puk) {\newline    op = ykpiv_change_puk;\newline  }\newline  res = op(state, pin, pin_len, new_pin, new_len, &amptries);\newline  switch (res) {\newline    case YKPIV_OK:\newline      return true;\newline\newline    case YKPIV_WRONG_PIN:\newline      fprintf(stderr, &quotFailed verifying %s code, now %d tries left before blocked.\\n&quot,\newline              name, tries);\newline      return false;\newline\newline    case YKPIV_PIN_LOCKED:\newline      if(action == action_arg_changeMINUS_pin) {\newline        fprintf(stderr, &quotThe pin code is blocked, use the unblock-pin action to unblock it.\\n&quot);\newline      } else {\newline        fprintf(stderr, &quotThe puk code is blocked, you will have to reinitialize the application.\\n&quot);\newline      }\newline      return false;\newline\newline    default:\newline      fprintf(stderr, &quotFailed changing/unblocking code, error: %s\\n&quot, ykpiv_strerror(res));\newline      return false;\newline  }\newline}\newline","this function is called for all three of change-pin, change-puk and unblock pin\newline since they&#039re very similar in what data they use. \newline","2215099","data.c","API_EXPORTED struct fp_print_data *fp_print_data_from_data(unsigned char *buf,\newline	size_t buflen)\newline{\newline	struct fpi_print_data_fp2 *raw = (struct fpi_print_data_fp2 *) buf;\newline\newline	fp_dbg(&quotbuffer size %zd&quot, buflen);\newline	if (buflen &lt sizeof(*raw))\newline		return NULL;\newline\newline	if (strncmp(raw-&gtprefix, &quotFP1&quot, 3) == 0) {\newline		return fpi_print_data_from_fp1_data(buf, buflen);\newline	} else if (strncmp(raw-&gtprefix, &quotFP2&quot, 3) == 0) {\newline		return fpi_print_data_from_fp2_data(buf, buflen);\newline	} else {\newline		fp_dbg(&quotbad header prefix&quot);\newline	}\newline\newline	return NULL;\newline}\newline","\\ingroup print_data\newline Load a stored print from a data buffer. The contents of said buffer must\newline be the untouched contents of a buffer previously supplied to you by the\newline fp_print_data_get_data() function.\newline \\param buf the data buffer\newline \\param buflen the length of the buffer\newline \\returns the stored print represented by the data, or NULL on error. Must\newline be freed with fp_print_data_free() after use.\newline \newline","","","","","","","","","","","","on","on","","on","on","","","","","","","","on","","","","","","","","","","","","","","","","","","on","Release distribution lock","Read the current commit number","computing the elapsed timefrom when the ping was sent,","stop polling","returns the new stringsize value","convert a wchar_t[] to a UTF-8 SWBuf","Remove duplicate entries in the list","Unloads all the plugins loaded in the GList","Scan an authorization file for a secret","Check whether there is pending Cdata,","Searches args for a leading ARGUMENT_ID followed by the string opt.","{}","{}","Load a stored print from a data buffer.","{}","{}","return an http chunk with previous unknown size.","locates the cursor on the text screen","Finds the EPG of the current program.","Encodes an RESET_CONN_RESP message to buffer","Sets the GL viewport to fit in the client area."
"3T2HW4QDUV79FCNF0A24EBUFLHCC99","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3L2IS5HSFAISDS52DDBAF17UDXJNUM","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 22:14:14 PDT 2019","Wed Apr 17 22:18:46 PDT 2019","Fri Apr 19 22:18:46 PDT 2019","2019-04-20 05:19:21 UTC","","","272","100% (10/10)","100% (10/10)","100% (10/10)","5891818","parametric.c","static void param_world_to_coord(const EL_INFO *el_info, int N,\newline				 const REAL_D world[],\newline				 REAL_B lambda[], int k[])\newline{\newline  FUNCNAME(&quotparam_world_to_coord&quot);\newline\newline/* stuff for newton */\newline  static ISP_DATA isp_data;\newline  static NLS_DATA nls_data = {\newline    nl_update,\newline    &ampisp_data,\newline    nl_solve,\newline    &ampisp_data,\newline    NULL,  /* norm */\newline    NULL,  /* norm-data */\newline    NULL,  /* work-space */\newline    1e-15, /* tolerance */\newline    1,     /* restart */\newline    1000,  /* max_iter */\newline    1,     /* info */\newline    -1.0,  /* initial residual */\newline    -1.0   /* residual */\newline  };\newline  REAL_B      lambda0_const, lambda0;\newline  int         iter, max_iter;\newline  REAL        tolerance, lambda_tolerance;\newline  int         dim_of_mesh = MIN(DIM_MAX, el_info-&gtmesh-&gtdim);\newline  int         fail_count  = 0;\newline  int         i, iq/* , dim */;\newline  int         k_dummy[N];\newline  \newline  LAGRANGE_PARAM_DATA *data = \newline    (LAGRANGE_PARAM_DATA *)el_info-&gtmesh-&gtparametric-&gtdata;\newline  REAL_D *local_coords      = data-&gtlocal_coords;\newline  const BAS_FCTS *bas_fcts  = data-&gtcoords-&gtfe_space-&gtbas_fcts;\newline\newline  REAL_D coord_backup[N_VERTICES(dim_of_mesh)];\newline\newline  nls_data.max_iter  = max_iter  = data-&gtmax_iter;\newline  nls_data.tolerance = tolerance = data-&gtnewton_tolerance;\newline  lambda_tolerance               = data-&gtlambda_tolerance;\newline\newline  if (!k) k = k_dummy;\newline\newline  if (DIM_OF_WORLD != dim_of_mesh) {\newline    ERROR_EXIT(&quotDIM_OF_WORLD = %d != %d = dim_of_mesh.&quot,\newline	       DIM_OF_WORLD, dim_of_mesh);\newline  }\newline  DEBUG_TEST_EXIT((el_info-&gtfill_flag &amp FILL_COORDS) ||\newline		  el_info-&gtmesh-&gtparametric-&gtuse_reference_mesh,\newline		  &quotYou must enable the use_reference_mesh entry in the &quot\newline		  &quotPARAMETRIC structure to use this function.\\n&quot);\newline\newline  if (!data-&gti_am_affine) {\newline    for (iq = 0; iq &lt N; iq++) {\newline      /* fill data */\newline      COPY_DOW(world[iq], isp_data.x);\newline      isp_data.el_info  = el_info;\newline      isp_data.bfcts    = (BAS_FCTS*)bas_fcts;\newline      isp_data.coords   = local_coords;\newline\newline      /* For planar and not too heavily deformed meshes the standard\newline       * world_to_coord should provide a reasonable initial value for\newline       * points inside the simplex. If world lies outside the simplex\newline       * we can neither guarantee the convergence of newton&#039s method\newline       * nor be sure that our initial lambda ist near the solution.\newline       */\newline      /* As global_refine does not fill the coords of projected nodes\newline       * into el_info_coord when use_reference_mesh == true (and not\newline       * at all if use_reference_mesh == false), we update el_info\newline       * with the correct information.\newline       */\newline      for (i = 0; i &lt N_VERTICES(dim_of_mesh); i++) {\newline	COPY_DOW(el_info-&gtcoord[i], coord_backup[i]);\newline	COPY_DOW(local_coords[i], (REAL *)el_info-&gtcoord[i]);\newline      }\newline\newline      world_to_coord(el_info, world[iq], lambda0_const);\newline\newline      /* Undo the hack above. */\newline      for (i=0; i &lt N_VERTICES(dim_of_mesh); i++) {\newline	COPY_DOW(coord_backup[i], (REAL *)el_info-&gtcoord[i]);\newline      }\newline      \newline      /* start newton, and retry if not successful */\newline      for (fail_count = 0; fail_count &lt N_LAMBDA(dim_of_mesh)+1;) {\newline	REAL sum = 0.0;\newline	\newline	COPY_BAR(DIM_MAX, lambda0_const, lambda0);\newline\newline	if (fail_count &gt 0) {\newline	  #if 0\newline	  WARNING(&quotNewton failed! current number of fails: %d.\\n&quot,\newline		  fail_count);\newline	  MSG(&quotRetry with different lambda0...\\n&quot);\newline	  #endif\newline	  lambda0[fail_count-1] += 0.1;\newline\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) sum += lambda0[i];\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) lambda0[i] /= sum;\newline	}\newline\newline	iter = nls_newton(&ampnls_data, N_LAMBDA(dim_of_mesh), (REAL *)&amplambda0);\newline	\newline	if (iter &gt max_iter) {\newline	  fail_count++;\newline	} else {\newline	  sum = 0;\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) {\newline	    lambda[iq][i] = lambda0[i];\newline	    sum += lambda0[i];\newline	  }\newline	  if (ABS(sum-1) &gt 10.0*REAL_EPSILON) {\newline#if 0\newline	    MSG(&quotl_r[0]=%e, l_r[1]=%e, l_r[2]=%e\\n&quot,\newline		lambda0[0], lambda0[1], lambda0[2]);\newline#endif\newline	    ERROR_EXIT(&quot%e = sum{lambda[i]} != 1\\n&quot, ABS(sum-1));\newline	  }\newline\newline	  #if 0\newline	  MSG(&quotSuccess! Newton needed %d iterations and failed %d times.\\n&quot,\newline	      iter, fail_count);\newline	  #endif\newline	  break;\newline	}\newline      }\newline      if (fail_count &lt N_LAMBDA(dim_of_mesh)+1) {\newline	REAL lmin = 0.0;\newline	k[iq] = -1;\newline	for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) {\newline	  if (lambda[iq][i] &lt lambda_tolerance) {\newline	    if (lambda[iq][i] &lt lmin) {\newline	      k[iq] = i;\newline	      lmin = lambda[iq][i];\newline	    }\newline	  }\newline	}\newline      } else {\newline	WARNING(&quot\\a Newton failed totally. &quot\newline		&quotMaybe you have to lift the tolerance a little, &quot\newline		&quotor there is no solution.\\n&quot);\newline	k[iq] = -2;\newline      }\newline    }\newline    return;\newline  } else {\newline    for (iq = 0; iq &lt N; iq++) {\newline      k[iq] = world_to_coord(el_info, world[iq], lambda[iq]);\newline    }\newline    return;\newline  }\newline}\newline","return: -2 if newton did not converge,\newline -1 if inside,\newline otherwise index of lambda &lt0\newline \newline","2476957","settingsdialog.cpp","void SettingsDialog::addLookAndFeelPage()\newline{\newline    QWidget* lookPage = new QWidget;\newline    QVBoxLayout *lookPageVBoxLayout = new QVBoxLayout(lookPage);\newline    KPageWidgetItem *page = new KPageWidgetItem( lookPage, i18n(&quotAppearance&quot) );\newline    page-&gtsetIcon( QIcon::fromTheme(&quotpreferences-desktop-theme&quot) );\newline\newline    QGroupBox* fontGroupBox = new QGroupBox(i18n(&quotFonts&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(fontGroupBox);\newline\newline    m_protocolFontBox  = new FontButton(i18n(&quotFont for &ampProtocol Window...&quot),\newline                                        fontGroupBox);\newline    m_annotateFontBox  = new FontButton(i18n(&quotFont for A&ampnnotate View...&quot),\newline                                        fontGroupBox);\newline    m_diffFontBox      = new FontButton(i18n(&quotFont for D&ampiff View...&quot),\newline                                        fontGroupBox);\newline    m_changelogFontBox = new FontButton(i18n(&quotFont for ChangeLog View...&quot),\newline                                        fontGroupBox);\newline\newline    QVBoxLayout* fontLayout( new QVBoxLayout( fontGroupBox ) );\newline    fontLayout-&gtaddWidget( m_protocolFontBox );\newline    fontLayout-&gtaddWidget( m_annotateFontBox );\newline    fontLayout-&gtaddWidget( m_diffFontBox );\newline    fontLayout-&gtaddWidget( m_changelogFontBox );\newline\newline    QGroupBox* colorGroupBox = new QGroupBox(i18n(&quotColors&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(colorGroupBox);\newline\newline    QLabel* conflictLabel = new QLabel(i18n(&quotConflict:&quot), colorGroupBox);\newline    m_conflictButton      = new KColorButton(colorGroupBox);\newline    conflictLabel-&gtsetBuddy(m_conflictButton);\newline\newline    QLabel* diffChangeLabel = new QLabel(i18n(&quotDiff change:&quot), colorGroupBox);\newline    m_diffChangeButton      = new KColorButton(colorGroupBox);\newline    diffChangeLabel-&gtsetBuddy(m_diffChangeButton);\newline\newline    QLabel* localChangeLabel = new QLabel(i18n(&quotLocal change:&quot), colorGroupBox);\newline    m_localChangeButton      = new KColorButton(colorGroupBox);\newline    localChangeLabel-&gtsetBuddy(m_localChangeButton);\newline\newline    QLabel* diffInsertLabel = new QLabel(i18n(&quotDiff insertion:&quot), colorGroupBox);\newline    m_diffInsertButton      = new KColorButton(colorGroupBox);\newline    diffInsertLabel-&gtsetBuddy(m_diffInsertButton);\newline\newline    QLabel* remoteChangeLabel = new QLabel(i18n(&quotRemote change:&quot), colorGroupBox);\newline    m_remoteChangeButton      = new KColorButton(colorGroupBox);\newline    remoteChangeLabel-&gtsetBuddy( m_remoteChangeButton );\newline\newline    QLabel* diffDeleteLabel = new QLabel(i18n(&quotDiff deletion:&quot), colorGroupBox);\newline    m_diffDeleteButton      = new KColorButton(colorGroupBox);\newline    diffDeleteLabel-&gtsetBuddy(m_diffDeleteButton);\newline\newline    QLabel* notInCvsLabel = new QLabel(i18n(&quotNot in cvs:&quot), colorGroupBox);\newline    m_notInCvsButton      = new KColorButton(colorGroupBox);\newline    notInCvsLabel-&gtsetBuddy(m_notInCvsButton);\newline\newline    QGridLayout* colorLayout( new QGridLayout( colorGroupBox ) );\newline    colorLayout-&gtaddWidget( conflictLabel, 0, 0 );\newline    colorLayout-&gtaddWidget( m_conflictButton, 0, 1 );\newline    colorLayout-&gtaddWidget( localChangeLabel, 1, 0 );\newline    colorLayout-&gtaddWidget( m_localChangeButton, 1, 1 );\newline    colorLayout-&gtaddWidget( remoteChangeLabel, 2, 0 );\newline    colorLayout-&gtaddWidget( m_remoteChangeButton, 2, 1 );\newline    colorLayout-&gtaddWidget( notInCvsLabel, 3, 0 );\newline    colorLayout-&gtaddWidget( m_notInCvsButton, 3, 1 );\newline\newline    colorLayout-&gtaddWidget( diffChangeLabel, 0, 3 );\newline    colorLayout-&gtaddWidget( m_diffChangeButton, 0, 4 );\newline    colorLayout-&gtaddWidget( diffInsertLabel, 1, 3 );\newline    colorLayout-&gtaddWidget( m_diffInsertButton, 1, 4 );\newline    colorLayout-&gtaddWidget( diffDeleteLabel, 2, 3 );\newline    colorLayout-&gtaddWidget( m_diffDeleteButton, 2, 4 );\newline\newline    m_splitterBox = new QCheckBox(i18n(&quotSplit main window &amphorizontally&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(m_splitterBox);\newline\newline    addPage(page);\newline}\newline","\newline Create a page for the look &amp feel options\newline \newline","154957","parent.c","Point parent_move_child_delta(Rectangle *p_ext, Rectangle *c_ext, Point *delta)\newline{\newline    Point new_delta = {0, 0};\newline    gboolean free_delta = FALSE;\newline    if (delta == NULL)\newline    {\newline      delta = g_new0(Point, 1);\newline      free_delta = TRUE;\newline    }\newline    /* we check if the child extent would be inside the parent extent after the move\newline      if not, we calculate how far we have to move the extent back to place it back\newline      inside the parent extent */\newline    if (c_ext-&gtleft + delta-&gtx &lt p_ext-&gtleft )\newline      new_delta.x = p_ext-&gtleft - (c_ext-&gtleft + delta-&gtx);\newline    else if (c_ext-&gtleft + delta-&gtx + (c_ext-&gtright - c_ext-&gtleft) &gt p_ext-&gtright)\newline      new_delta.x = p_ext-&gtright - (c_ext-&gtleft + delta-&gtx + (c_ext-&gtright - c_ext-&gtleft));\newline\newline    if (c_ext-&gttop + delta-&gty &lt p_ext-&gttop)\newline      new_delta.y = p_ext-&gttop - (c_ext-&gttop + delta-&gty);\newline    else if (c_ext-&gttop + delta-&gty + (c_ext-&gtbottom - c_ext-&gttop) &gt p_ext-&gtbottom)\newline      new_delta.y = p_ext-&gtbottom  - (c_ext-&gttop + delta-&gty + (c_ext-&gtbottom - c_ext-&gttop));\newline\newline    if (free_delta)\newline      g_free(delta);\newline\newline    return new_delta;\newline}\newline","p_ext are the &quotextents&quot of the parent and c_ext are the &quotextents&quot of the child\newlineThe extent is a rectangle that specifies how far an object goes on the grid (based on its handles)\newlineIf delta is not present, these are the extents before any moves\newlineIf delta is present, delta is considered into the extents&#039s position\newline \newline","6110548","util.c","static void set_rwx(unsigned mode, char *str)\newline{\newline    str[0] = (char) ((mode &amp 4) ? &#039r&#039 : &#039-&#039);\newline    str[1] = (char) ((mode &amp 2) ? &#039w&#039 : &#039-&#039);\newline    str[2] = (char) ((mode &amp 1) ? &#039x&#039 : &#039-&#039);\newline}\newline","Set the read, write, and execute flags. \newline","554484","hostlist.c","static int _zero_padded(unsigned long num, int width)\newline{\newline    int n = 1;\newline    while (num /= 10L)\newline        n++;\newline    return width &gt n ? width - n : 0;\newline}\newline","return the number of zeros needed to pad &quotnum&quot to &quotwidth&quot\newline \newline","4495427","desa68.c","static int read_pc(void)\newline{\newline  unsigned int pc = d.pc;\newline\newline/*\newline  d.w = (s8)d.mem[pc++&ampd.memmsk]&lt&lt8;\newline  d.w  += d.mem[pc++&ampd.memmsk];\newline*/\newline\newline  d.w = d.mem_callb(pc &amp d.memmsk, d.private_data);\newline  pc += 2;\newline\newline  d.pc = pc;\newline  return d.w;\newline}\newline","Read next word , increment pc \newline","6468843","srl_encoder.c","SRL_STATIC_INLINE void\newlinesrl_dump_nv(pTHX_ srl_encoder_t *enc, SV *src)\newline{\newline    NV nv= SvNV(src);\newline    MS_VC6_WORKAROUND_VOLATILE float f= (float)nv;\newline    MS_VC6_WORKAROUND_VOLATILE double d= (double)nv;\newline    /* TODO: this logic could be reworked to not duplicate so much code, which will help on win32 */\newline    if ( f == nv || nv != nv ) {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(f)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_FLOAT);\newline        Copy((char *)&ampf, enc-&gtbuf.pos, sizeof(f), char);\newline        enc-&gtbuf.pos += sizeof(f);\newline    } else if (d == nv) {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(d)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_DOUBLE);\newline        Copy((char *)&ampd, enc-&gtbuf.pos, sizeof(d), char);\newline        enc-&gtbuf.pos += sizeof(d);\newline    } else {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(nv)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_LONG_DOUBLE);\newline        Copy((char *)&ampnv, enc-&gtbuf.pos, sizeof(nv), char);\newline#if SRL_EXTENDED_PRECISION_LONG_DOUBLE\newline        /* x86 uses an 80 bit extended precision. on 64 bit machines\newline         * this is 16 bytes long, and on 32 bits its is 12 bytes long.\newline         * the unused 2/6 bytes are not necessarily zeroed, potentially\newline         * allowing internal memory to be exposed. We therefore zero\newline         * the unused bytes here. */\newline        memset(enc-&gtbuf.pos+10, 0, sizeof(nv) - 10);\newline#endif\newline        enc-&gtbuf.pos += sizeof(nv);\newline    }\newline}\newline","Code for serializing floats \newline","1798220","admind.c","static void handle_cmd_get_kb_info(int client_fd, uint16_t datasize)\newline{\newline    int rv, len, err;\newline    fsa_kb_info *ki;\newline    unsigned char *response;\newline    unsigned char *kb_name;\newline\newline    kb_name = get_string_from_client(client_fd, datasize);\newline    if (kb_name == NULL) {\newline        /* errors already logged/handled */\newline        return;\newline    }\newline\newline    /* should already have been checked by client */\newline    if (!fsa_is_valid_kb_name((const char *)kb_name)) {\newline        fsa_error(LOG_CRIT, &quotInvalid kb name received from client&quot);\newline        send_error_message(client_fd, &quotkb name invalid&quot);\newline        free(kb_name);\newline        return;\newline    }\newline\newline    ki = fsab_get_local_kb_info(kb_name, &amperr);\newline    free(kb_name); /* done with kb_name */\newline    if (ki == NULL || err == ADM_ERR_KB_NOT_EXISTS) {\newline        send_error_message(client_fd, &quotfailed to get local kb info&quot);\newline        return;\newline    }\newline\newline    /* encode message for client */\newline    response = fsap_encode_rsp_get_kb_info(ki, &amplen);\newline    fsa_kb_info_free(ki);\newline    if (response == NULL) {\newline        send_error_message(client_fd, &quotfailed to encode kb info&quot);\newline        return;\newline    }\newline\newline    fsa_error(LOG_DEBUG, &quotresponse size is %d bytes&quot, len);\newline\newline    /* send entire response back to client */\newline    rv = fsa_sendall(client_fd, response, &amplen);\newline    free(response); /* done with response buffer */\newline    if (rv == -1) {\newline        fsa_error(LOG_ERR, &quotfailed to send response to client: %s&quot,\newline                  strerror(errno));\newline        return;\newline    }\newline\newline    fsa_error(LOG_DEBUG, &quot%d bytes sent to client&quot, len);\newline}\newline","get all information about a specific kb on this host, send to client \newline","1446312","reorder.c","int bdd_getreorder_times(void)\newline{\newline   return bddreordertimes;\newline}\newline","\newlineNAME { bdd\\_getreorder\\_times }\newlineSECTION { reorder }\newlineSHORT { Fetch the current number of allowed reorderings }\newlinePROTO { int bdd_getreorder_times(void) }\newlineDESCR { Returns the current number of allowed reorderings left. This\newlinevalue can be defined by {\\tt bdd\\_autoreorder\\_times}. }\newlineALSO { bdd\\_reorder\\_times, bdd\\_getreorder\\_method }\newline \newline","4214883","menu_mp3player.c","static void Center_Playlist(void) {\newline	int current;\newline	int curosor_position;\newline\newline	MP3_GetPlaylistInfo(&ampcurrent, NULL);\newline	M_Menu_MP3_Playlist_MoveBase(current);\newline\newline	/* Calculate the corect cursor position */\newline	/* We can display all songs so its just the current index */\newline	if (current &lt PLAYLIST_MAXLINES)\newline		curosor_position = current;\newline	/* We are at the end of the playlist */\newline	else if (playlist_size - (current) &lt PLAYLIST_MAXLINES)\newline		curosor_position = PLAYLIST_MAXLINES - (playlist_size - (current));\newline	/* We are in the middle of the playlist &amp the bottom is the current song*/\newline	else \newline		curosor_position = 0;\newline	M_Menu_MP3_Playlist_MoveCursor(curosor_position);\newline}\newline","\newline Center the playlist cursor on the current song\newline \newline","2188647","z88ci.c","int z88ci(void)\newline{\newlineextern FILE *fi2,*fi4,*f3y,*fo1,*fo2,*fl2;\newlineextern char ci2[],ci4[],c3y[],co1[],co2[];\newline\newlineextern FR_DOUBLEAY GS;\newlineextern FR_DOUBLEAY rs;\newlineextern FR_DOUBLEAY fak;\newline\newlineextern FR_INT4AY ip;\newlineextern FR_INT4AY iez;\newlineextern FR_INT4AY ioffs; \newlineextern FR_INT4AY ifrei; \newline\newlineextern FR_DOUBLE  eps,rp,rpomega,rpalpha;\newlineextern FR_INT4 kfoun,nkp,nfg,maxit,iqflag;\newlineextern FR_INT4 MAXNFG,LANG,ICFLAG;\newline\newlineFR_DOUBLE wert;\newline\newlineFR_INT4 i,nrb,k,nkn,ifg,iflag1,jndex,j;\newline\newlineint iret;\newline\newlinechar cline[256];\newline\newline/*----------------------------------------------------------------------\newline* Start Function\newline*---------------------------------------------------------------------*/\newlinewrim88i(0,TX_Z88CC);\newlinewlog88i2(0,LOG_Z88CC);\newline\newline/***********************************************************************\newline* Oeffnen der Files Z88I2.TXT,Z88I4.TXT,Z88O3.BNY,Z88O1.TXT &amp Z88O2.TXT\newline***********************************************************************/\newlinefi2= fopen(ci2,&quotr&quot);\newlineif(fi2 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOI2);\newline  fclose(fl2);\newline  return(AL_NOI2);\newline  }\newline\newlinerewind(fi2);\newline\newlinefi4= fopen(ci4,&quotr&quot);\newlineif(fi4 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOI4);\newline  fclose(fl2);\newline  return(AL_NOI4);\newline  }\newline\newlinerewind(fi4);\newline\newlinef3y= fopen(c3y,&quotw+b&quot);\newlineif(f3y == NULL)\newline  {\newline  wlog88i2(0,LOG_NO3Y);\newline  fclose(fl2);\newline  return(AL_NO3Y);\newline  }\newline\newlinerewind(f3y);\newline\newlinefo1= fopen(co1,&quotw+&quot);\newlineif(fo1 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOO1);\newline  fclose(fl2);\newline  return(AL_NOO1);\newline  }\newline\newlinerewind(fo1);\newline\newlinefo2= fopen(co2,&quotw+&quot);\newlineif(fo2 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOO2);\newline  fclose(fl2);\newline  return(AL_NOO2);\newline  }\newline\newlinerewind(fo2);\newline\newline/***********************************************************************\newline* Lesen des Steuerfiles Z88I4.TXT\newline***********************************************************************/\newlinewrim88i(0,TX_REAI4);\newlinewlog88i2(0,LOG_REAI4);\newline\newlinefgets(cline,256,fi4);\newlinesscanf(cline,PDB PF PF PF,&ampmaxit,&ampeps,&amprpalpha,&amprpomega);\newline\newlinewlog88i2(maxit,LOG_MAXIT);\newlinefclose(fi4);\newline\newline/***********************************************************************\newline* Lesen des Randbedingungsfiles und Einarbeiten der RB, Pass 1\newline***********************************************************************/\newlinewrim88i(0,TX_REAI2);\newlinewrim88i(1,TX_ERBPA);\newlinewlog88i2(0,LOG_REAI2);\newlinewlog88i2(1,LOG_ERBPA);\newline\newlinefgets(cline,256,fi2);\newlinesscanf(cline,PD,&ampnrb);\newline\newlinefor(k = 1;k &lt= nrb;k++)\newline  {\newline\newline  fgets(cline,256,fi2);\newline  sscanf(cline,PDB PDB PDB PG,&ampnkn,&ampifg,&ampiflag1,&ampwert);\newline\newline  jndex= ioffs[nkn]-1+ifg;\newline\newline  wran88i(k,iflag1);\newline\newline/*----------------------------------------------------------------------\newline* Verzweigen, ob Kraft oder Verschiebung\newline*---------------------------------------------------------------------*/\newline/*======================================================================\newline* Kraft vorgegeben\newline*=====================================================================*/\newline  if (iflag1 == 1) rs[jndex]+= wert;     \newline\newline/*======================================================================\newline* Verschiebung vorgegeben\newline*=====================================================================*/\newline  if(iflag1 == 2)\newline    {\newline/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\newline* Verschiebung != 0\newline*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/ \newline    if(FR_FABS(wert) &gt=  1e-8)\newline      {\newline      rs[jndex]= wert;\newline      GS[ip[jndex]]= 1.;\newline\newline      if(jndex == 1) goto L30; \newline\newline      for(i= ip[jndex-1]+1; i &lt= ip[jndex]-1; i++)\newline        {\newline        rs[iez[i]]-= wert * GS[i];\newline        GS[i]= 0.;\newline        }  \newline\newline      L30: if(jndex == nfg) break;\newline\newline      for(j= jndex+1; j &lt= nfg; j++)\newline        {\newline        for(i= ip[j-1]+1; i &lt= ip[j]; i++)\newline          {\newline          if(iez[i] &gt jndex) break;\newline          if(iez[i] &lt jndex) continue;\newline          rs[j]-= wert * GS[i];\newline          GS[i]= 0.;\newline          break;\newline          }\newline        } \newline      } /* Ende inhomogene RB */\newline    else\newline/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\newline* Verschiebung == 0 \newline*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/ \newline      {\newline      GS[ip[jndex]]= 1.;\newline\newline      if(jndex == 1) goto L40; \newline\newline      for(i= ip[jndex-1]+1; i &lt= ip[jndex]-1; i++)\newline        GS[i]= 0.;\newline\newline      L40: if(jndex == nfg) break;\newline\newline      for(j= jndex+1; j &lt= nfg; j++)\newline        {\newline        for(i= ip[j-1]+1; i &lt= ip[j]; i++)\newline          {\newline          if(iez[i] &gt jndex) break;\newline          if(iez[i] &lt jndex) continue;\newline          GS[i]= 0.;\newline          break;\newline          }\newline        } \newline      } /* Ende homogene RB */\newline    } /* Ende Weg vorgeben */\newline\newline  } /* Ende Schleife Randbedingungen */\newline\newline/***********************************************************************\newline* Lesen des Randbedingungsfiles und Einarbeiten der RB, Pass 2\newline* Gleichzeitig Kontrollfile Z88O1.TXT beschreiben\newline***********************************************************************/\newlinewrim88i(0,TX_REAI2P2);\newlinewrim88i(2,TX_ERBPA);\newlinewrim88i(0,TX_WRIO1);\newlinewlog88i2(0,LOG_REAI2);\newlinewlog88i2(2,LOG_ERBPA);\newlinewlog88i2(0,LOG_WRIO1);\newline\newlinerewind(fi2);\newline\newlinefgets(cline,256,fi2);\newlinesscanf(cline,PD,&ampnrb);\newline\newlineif(LANG == 1)\newline{\newlinefprintf(fo1,&quotAusgabedatei Z88O1.TXT  Randbedingungen, erzeugt mit Z88I2 V13.0\\n&quot);\newlinefprintf(fo1,&quot                        ***************\\n\\n&quot);\newlinefprintf(fo1,&quotAnzahl gegebene Randbedingungen: &quot PD &quot\\n\\n&quot,nrb);\newline}\newline\newlineif(LANG == 2)\newline{\newlinefprintf(fo1,&quotoutput file Z88O1.TXT : constraints, produced by Z88I2 V13.0\\n&quot);\newlinefprintf(fo1,&quot                        ***********\\n\\n&quot);\newlinefprintf(fo1,&quotnumber of given constraints: &quot PD &quot\\n\\n&quot,nrb);\newline}\newline\newlinefor(k = 1;k &lt= nrb;k++)\newline  {\newline  fgets(cline,256,fi2);\newline  sscanf(cline,PDB PDB PDB PG,&ampnkn,&ampifg,&ampiflag1,&ampwert);\newline\newline  jndex= ioffs[nkn]-1+ifg;\newline  if(iflag1 == 2) rs[jndex]= wert;\newline\newline  if(iflag1 == 1)\newline    {\newline    if(LANG == 1)\newline    fprintf(fo1, &quotKnoten#&quot B5D &quot   FG&quot B1D &quot   Steuerflag&quot B1D &quot   Last         &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline\newline    if(LANG == 2)\newline    fprintf(fo1, &quot  node#&quot B5D &quot   DOF&quot B1D &quot  lo/di flag&quot B1D &quot   load         &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline    }\newline    \newline  if(iflag1 == 2)\newline    {\newline    if(LANG == 1)\newline    fprintf(fo1, &quotKnoten#&quot B5D &quot   FG&quot B1D &quot   Steuerflag&quot B1D &quot   Verschiebung &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline\newline    if(LANG == 2)\newline    fprintf(fo1,&quot  node#&quot B5D &quot   DOF&quot B1D &quot  lo/di flag&quot B1D &quot   displacement &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline    }\newline  }\newline\newline/*----------------------------------------------------------------------\newline* ggf. Flaechenlasten nach Z88O1.TXT ausschreiben\newline*---------------------------------------------------------------------*/\newlineif(iqflag == 1) prfl88();\newline\newline/*----------------------------------------------------------------------\newline* Z88I2.TXT und Z88O1.TXT schliessen\newline*---------------------------------------------------------------------*/\newlinefclose(fi2);\newlinefclose(fo1);\newline\newline/***********************************************************************\newline* Gleichungssystem skalieren mit SCAL88\newline***********************************************************************/\newlinewrim88i(0,TX_SCAL88);\newlinewlog88i2(0,LOG_SCAL88);\newline\newlineiret= scal88();\newlineif(iret != 0) return(iret);\newline\newline/***********************************************************************\newline* Ab die Post: Loesen des Gleichungssystems mit SICCG88 oder SORCG88\newline***********************************************************************/\newlineif(ICFLAG == 1)\newline  {\newline  wrim88i(0,TX_SICCG88);\newline  wlog88i2(0,LOG_SICCG88);\newline\newline  wrim88i(nfg,TX_NFG);\newline  wrim88i(nfg,TX_ALPHA);\newline\newline  siccg88();\newline  }\newline\newlineif(ICFLAG == 2)\newline  {\newline  wrim88i(0,TX_SORCG88);\newline  wlog88i2(0,LOG_SORCG88);\newline\newline  wrim88i(nfg,TX_NFG);\newline  wrim88i(nfg,TX_OMEGA);\newline\newline  sorcg88();\newline  }\newline\newline/***********************************************************************\newline* Scalierung rueckgaengig machen\newline***********************************************************************/\newlinefor(i = 1;i &lt= nfg;i++)\newline  rs[i]*= fak[i];\newline\newline/***********************************************************************\newline* Beschreiben und Schliessen von Z88O3.BNY \newline***********************************************************************/\newlinewrim88i(0,TX_WRI3Y);\newlinewlog88i2(0,LOG_WRI3Y);\newline\newlinefwrite(&ampnfg,sizeof(FR_INT4),1,f3y);\newlinefor(i = 1;i &lt= nfg;i++)\newline  fwrite(&amprs[i],sizeof(FR_DOUBLE),1,f3y);\newline\newlinefclose(f3y);\newline\newline/***********************************************************************\newline* Beschreiben von Z88O2.TXT mit Verschiebungen\newline***********************************************************************/\newlinewrim88i(0,TX_WRIO2);\newlinewlog88i2(0,LOG_WRIO2);\newline\newlineif(LANG == 1)\newline{\newlinefprintf(fo2,&quotAusgabedatei Z88O2.TXT: Verschiebungen, erzeugt mit Z88I2 V13.0\\n&quot);\newlinefprintf(fo2,&quot                        **************\\n&quot);\newline}\newline\newlineif(LANG == 2)\newline{\newlinefprintf(fo2,&quotoutput file Z88O2.TXT: displacements, computed by Z88I2 V13.0\\n&quot);\newlinefprintf(fo2,&quot                       *************\\n&quot);\newline}\newline\newlinefprintf(fo2,\newline&quot\\nKnoten         U(1)              U(2)              U(3)\\\newline              U(4)              U(5)              U(6)\\n&quot);\newline\newline/*----------------------------------------------------------------------\newline* Schleife ueber alle Knoten\newline*---------------------------------------------------------------------*/\newlinek= 1;\newlinefor(i = 1;i &lt= nkp;i++)\newline  {\newline          \newline/*======================================================================\newline* 2 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 2)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E,i,rs[k],rs[k+1]);\newline    k+= 2;\newline    }\newline\newline/*======================================================================\newline* 3 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 3)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E B315E,i,rs[k],rs[k+1],rs[k+2]);\newline    k+= 3;\newline    }\newline\newline/*======================================================================\newline* 6 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 6)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E B315E B315E B315E B315E,\newline    i,rs[k],rs[k+1],rs[k+2],rs[k+3],rs[k+4],rs[k+5]);\newline    k+= 6;\newline    }\newline\newline/*---------------------------------------------------------------------\newline* Ende Schleife ueber alle Knoten\newline*--------------------------------------------------------------------*/\newline   }\newline\newline/***********************************************************************\newline* Schliessen des noch offenen Files, Ende Z88CI\newline***********************************************************************/\newlinefprintf(fo2,&quot\\n&quot);\newlinefclose(fo2);\newline\newlinewlog88i2(0,LOG_EXITZ88CC);\newlinereturn(0);\newline}\newline","\newline hier beginnt Function z88ci\newline \newline","1066581","libfdata_tree_node.c","int libfdata_tree_node_set_data_range(\newline     libfdata_tree_node_t *node,\newline     int node_file_index,\newline     off64_t node_offset,\newline     size64_t node_size,\newline     uint32_t node_flags,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_data_range&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	if( ( internal_tree_node-&gtflags &amp LIBFDATA_TREE_NODE_FLAG_IS_VIRTUAL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\newline		 &quot%s: invalid node - node is virtual.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libfdata_range_set(\newline	     internal_tree_node-&gtnode_data_range,\newline	     node_file_index,\newline	     node_offset,\newline	     node_size,\newline	     node_flags,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,\newline		 &quot%s: unable to set node data range.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libfcache_date_time_get_timestamp(\newline	     &amp( internal_tree_node-&gttimestamp ),\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,\newline		 &quot%s: unable to retrieve cache timestamp.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	return( 1 );\newline}\newline","Sets the data offset and size\newline Returns 1 if successful or -1 on error\newline \newline","4850078","hashmap.c","static int delete_hashbucket (struct hashbucket_s *bucket)\newline{\newline        struct hashentry_s *nextptr;\newline        struct hashentry_s *ptr;\newline\newline        if (bucket == NULL || bucket-&gthead == NULL)\newline                return -EINVAL;\newline\newline        ptr = bucket-&gthead;\newline        while (ptr) {\newline                nextptr = ptr-&gtnext;\newline\newline                safefree (ptr-&gtkey);\newline                safefree (ptr-&gtdata);\newline                safefree (ptr);\newline\newline                ptr = nextptr;\newline        }\newline\newline        return 0;\newline}\newline","\newline Follow the chain of hashentries and delete them (including the data and\newline the key.)\newline \newline Returns: 0 if the function completed successfully\newline negative number is returned if &quotentry&quot was NULL\newline \newline","2925016","convert.c","int igraphmodule_PyObject_to_vector_int_t(PyObject *list, igraph_vector_int_t *v) {\newline  PyObject *item;\newline  int value=0;\newline  Py_ssize_t i, j, k;\newline  int ok, retval;\newline\newline  if (PyBaseString_Check(list)) {\newline    /* It is highly unlikely that a string (although it is a sequence) will\newline     * provide us with integers or integer pairs */\newline    PyErr_SetString(PyExc_TypeError, &quotexpected a sequence or an iterable containing integers&quot);\newline    return 1;\newline  }\newline\newline  if (!PySequence_Check(list)) {\newline    /* try to use an iterator */\newline    PyObject *it = PyObject_GetIter(list);\newline    if (it) {\newline      PyObject *item;\newline      igraph_vector_int_init(v, 0);\newline      while ((item = PyIter_Next(it)) != 0) {\newline        ok = 1;\newline        if (!PyNumber_Check(item)) {\newline          PyErr_SetString(PyExc_TypeError, &quotiterable must return numbers&quot);\newline          ok=0;\newline        } else {\newline          PyObject *item2 = PyNumber_Int(item);\newline          if (item2 == 0) {\newline            PyErr_SetString(PyExc_TypeError, &quotcan&#039t convert a list item to integer&quot);\newline            ok = 0;\newline          } else {\newline            ok = (PyInt_AsInt(item, &ampvalue) == 0);\newline            Py_DECREF(item2);\newline          }\newline        }\newline       \newline        if (ok == 0) {\newline          igraph_vector_int_destroy(v);\newline          Py_DECREF(item);\newline          Py_DECREF(it);\newline          return 1;\newline        }\newline        if (igraph_vector_int_push_back(v, value)) {\newline          igraphmodule_handle_igraph_error();\newline          igraph_vector_int_destroy(v);\newline          Py_DECREF(item);\newline          Py_DECREF(it);\newline          return 1;\newline        }\newline        Py_DECREF(item);\newline      }\newline      Py_DECREF(it);\newline      return 0;\newline    } else {\newline      PyErr_SetString(PyExc_TypeError, &quotsequence or iterable expected&quot);\newline      return 1;\newline    }\newline    return 0;\newline  }\newline\newline  j=PySequence_Size(list);\newline  igraph_vector_int_init(v, j);\newline  for (i=0, k=0; i&ltj; i++) {\newline    item=PySequence_GetItem(list, i);\newline    if (item) {\newline      ok=1;\newline      if (!PyNumber_Check(item)) {\newline        PyErr_SetString(PyExc_TypeError, &quotsequence elements must be integers&quot);\newline        ok=0;\newline      } else {\newline        PyObject *item2 = PyNumber_Int(item);\newline        if (item2 == 0) {\newline          PyErr_SetString(PyExc_TypeError, &quotcan&#039t convert sequence element to int&quot);\newline          ok=0;\newline        } else {\newline          retval = PyInt_AsInt(item2, &ampvalue);\newline          if (retval)\newline            ok = 0;\newline          Py_DECREF(item2);\newline        }\newline      }\newline      Py_XDECREF(item);\newline      if (!ok) {\newline        igraph_vector_int_destroy(v);\newline        return 1;\newline      }\newline      VECTOR(*v)[k]=value;\newline      k++;\newline    } else {\newline      /* this should not happen, but we return anyway.\newline       * an IndexError exception was set by PyList_GetItem\newline       * at this point */\newline      igraph_vector_int_destroy(v);\newline      return 1;\newline    }\newline  }\newline  return 0;\newline}\newline","\newline \\ingroup python_interface_conversion\newline \\brief Converts a Python list of ints to an igraph \\c igraph_vector_int_t\newline The incoming \\c igraph_vector_int_t should be uninitialized.\newline Raises suitable Python exceptions when needed.\newline \newline This function is almost identical to\newline \\ref igraphmodule_PyObject_to_vector_t . Make sure you fix bugs\newline in both cases (if any).\newline \newline \\param list the Python list to be converted\newline \\param v the \\c igraph_vector_int_t containing the result\newline \\return 0 if everything was OK, 1 otherwise\newline \newline","4770327","sslutils.c","static int ssl_verify_OCSP(int ok, X509_STORE_CTX *ctx)\newline{\newline    X509 *cert, *issuer;\newline    int r = OCSP_STATUS_UNKNOWN;\newline\newline    cert = X509_STORE_CTX_get_current_cert(ctx);\newline    /* if we can&#039t get the issuer, we cannot perform OCSP verification */\newline    if (X509_STORE_CTX_get1_issuer(&ampissuer, ctx, cert) == 1 ) {\newline        r = ssl_ocsp_request(cert, issuer);\newline        if (r == OCSP_STATUS_REVOKED) {\newline            /* we set the error if we know that it is revoked */\newline            X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\newline        }\newline        else {\newline            /* else we return unknown, so that we can continue with the crl */\newline            r = OCSP_STATUS_UNKNOWN;\newline        }\newline        X509_free(issuer); /* It appears that we  should free issuer since\newline                            * X509_STORE_CTX_get1_issuer() calls X509_OBJECT_up_ref_count()\newline                            * on the issuer object (unline X509_STORE_CTX_get_current_cert()\newline                            * that just returns the pointer\newline                            */\newline    }\newline    return r;\newline}\newline","Function that is used to do the OCSP verification \newline","5687541","ne_socks.c","static int sofail(ne_socket *sock, ssize_t ret, const char *context)\newline{\newline    char *err = ne_strdup(ne_sock_error(sock));\newline    ne_sock_set_error(sock, &quot%s: %s&quot, context, err);\newline    ne_free(err);\newline    return NE_SOCK_ERROR;\newline}\newline","Fail with given NE_SOCK_ error code and given context. \newline","3372281","service.c","unsigned int corosync_service_defaults_link_and_init (struct corosync_api_v1 *corosync_api)\newline{\newline	unsigned int i;\newline	char *error;\newline\newline	for (i = 0;\newline		i &lt sizeof (default_services) / sizeof (struct default_service); i++) {\newline\newline		default_services[i].loader();\newline		error = corosync_service_link_and_init (\newline			corosync_api,\newline			&ampdefault_services[i]);\newline		if (error) {\newline			log_printf(LOGSYS_LEVEL_ERROR,\newline				&quotService engine &#039%s&#039 failed to load for reason &#039%s&#039&quot,\newline				default_services[i].name,\newline				error);\newline			corosync_exit_error (COROSYNC_DONE_SERVICE_ENGINE_INIT);\newline		}\newline	}\newline\newline	return (0);\newline}\newline","\newline Links default services into the executive\newline \newline","1284927","tetrahedron_method.c","static double _n_0(void)\newline{\newline  return 0.0;\newline}\newline","omega &lt omega1 \newline","5268095","menu-cache.c","MenuCacheDir* menu_cache_get_dir_from_path( MenuCache* cache, const char* path )\newline{\newline    char** names = g_strsplit( path + 1, &quot/&quot, -1 );\newline    int i = 0;\newline    MenuCacheDir* dir = NULL;\newline\newline    if( !names )\newline        return NULL;\newline\newline    if( G_UNLIKELY(!names[0]) )\newline    {\newline        g_strfreev(names);\newline        return NULL;\newline    }\newline    /* the topmost dir of the path should be the root menu dir. */\newline    MENU_CACHE_LOCK;\newline    dir = cache-&gtroot_dir;\newline    if (G_UNLIKELY(dir == NULL) || strcmp(names[0], MENU_CACHE_ITEM(dir)-&gtid))\newline    {\newline        MENU_CACHE_UNLOCK;\newline        return NULL;\newline    }\newline\newline    for( ++i; names[i]; ++i )\newline    {\newline        GSList* l;\newline        for( l = dir-&gtchildren; l; l = l-&gtnext )\newline        {\newline            MenuCacheItem* item = MENU_CACHE_ITEM(l-&gtdata);\newline            if( item-&gttype == MENU_CACHE_TYPE_DIR &amp&amp 0 == strcmp( item-&gtid, names[i] ) )\newline                dir = MENU_CACHE_DIR(item);\newline        }\newline        /* FIXME: we really should ref it on return since other thread may\newline           destroy the parent at this time and returned data become invalid.\newline           Therefore this call isn&#039t thread-safe! */\newline        if( ! dir )\newline        {\newline            MENU_CACHE_UNLOCK;\newline            return NULL;\newline        }\newline    }\newline    MENU_CACHE_UNLOCK;\newline    return dir;\newline}\newline","\newline menu_cache_get_dir_from_path\newline @cache: a menu cache instance\newline @path: item path\newline \newline Since: 0.1.0\newline \newline Deprecated: 0.3.4: Use menu_cache_item_from_path() instead.\newline \newline","1209208","jsint.c","void js_upcall_set_status(void *context, unsigned char *tak_se_ukaz_Kolbene)\newline{\newline	struct f_data_c *fd=(struct f_data_c*)context;\newline	unsigned char *trouba;\newline\newline	if (!fd)internal(&quotTo leda tak -PRd!\\n&quot);\newline\newline	if (!(*tak_se_ukaz_Kolbene)){mem_free(tak_se_ukaz_Kolbene);tak_se_ukaz_Kolbene=NULL;}\newline\newline	if (fd-&gtses-&gtst)mem_free(fd-&gtses-&gtst);\newline	skip_nonprintable(tak_se_ukaz_Kolbene);\newline	if (fd-&gtf_data&amp&amptak_se_ukaz_Kolbene)\newline	{\newline		trouba=convert(fd-&gtf_data-&gtcp, fd-&gtf_data-&gtopt.cp, tak_se_ukaz_Kolbene, NULL);\newline		mem_free(tak_se_ukaz_Kolbene);\newline		/* a je to v troube... */\newline	}\newline	else\newline	{\newline		trouba=tak_se_ukaz_Kolbene;\newline	}\newline\newline	fd-&gtses-&gtst=trouba;\newline	print_screen_status(fd-&gtses);\newline}\newline","set status-line text\newline tak_se_ukaz_Kolbene is allocated string or NULL\newline \newline","1821283","recovery.c","void start_recovery(int recovery_node)\newline{\newline	int node_id;\newline	BackendInfo *backend;\newline	BackendInfo *recovery_backend;\newline	PGconn *conn;\newline	int failback_wait_count;\newline#define FAILBACK_WAIT_MAX_RETRY 5		/* 5 seconds should be enough for failback operation */\newline\newline	ereport(LOG,\newline		(errmsg(&quotstarting recovering node %d&quot, recovery_node)));\newline\newline	if ( (recovery_node &lt 0) || (recovery_node &gt= pool_config-&gtbackend_desc-&gtnum_backends) )\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, node id: %d is not valid&quot, recovery_node)));\newline\newline	if (VALID_BACKEND(recovery_node))\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, node id: %d is alive&quot, recovery_node)));\newline\newline	/* select master/primary node */\newline	node_id = MASTER_SLAVE ? PRIMARY_NODE_ID : REAL_MASTER_NODE_ID;\newline	backend = &amppool_config-&gtbackend_desc-&gtbackend_info[node_id];\newline\newline	/* get node info to be recovered */\newline	recovery_backend = &amppool_config-&gtbackend_desc-&gtbackend_info[recovery_node];\newline\newline	conn = connect_backend_libpq(backend);\newline	if (conn == NULL)\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, unable to connect to master node: %d &quot, node_id)));\newline\newline	PG_TRY();\newline	{\newline		/* 1st stage */\newline		if (REPLICATION)\newline		{\newline			exec_checkpoint(conn);\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, CHECKPOINT in the 1st stage done&quot)));\newline		}\newline\newline		exec_recovery(conn, backend, recovery_backend, FIRST_STAGE);\newline\newline		ereport(LOG,\newline			(errmsg(&quotnode recovery, 1st stage is done&quot)));\newline\newline		if (REPLICATION)\newline		{\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, starting 2nd stage&quot)));\newline\newline			/* 2nd stage */\newline			*InRecovery = RECOVERY_ONLINE;\newline			if (pool_config-&gtuse_watchdog)\newline			{\newline				/* announce start recovery */\newline				if (COMMAND_OK != wd_start_recovery())\newline					ereport(ERROR,\newline							(errmsg(&quotnode recovery failed, failed to send start recovery packet&quot)));\newline			}\newline\newline			if (wait_connection_closed() != 0)\newline				ereport(ERROR,\newline						(errmsg(&quotnode recovery failed, waiting connection closed in the other pgpools timeout&quot)));\newline\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, all connections from clients have been closed&quot)));\newline\newline			exec_checkpoint(conn);\newline\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery&quot),\newline					 errdetail(&quotCHECKPOINT in the 2nd stage done&quot)));\newline\newline			exec_recovery(conn, backend, recovery_backend, SECOND_STAGE);\newline		}\newline\newline		exec_remote_start(conn, recovery_backend);\newline\newline		check_postmaster_started(recovery_backend);\newline\newline		ereport(LOG,\newline			(errmsg(&quotnode recovery, node: %d restarted&quot, recovery_node)));\newline\newline		/*\newline		 * reset failover completion flag.  this is necessary since\newline		 * previous failover/failback will set the flag to 1.\newline		 */\newline		pcp_worker_wakeup_request = 0;\newline\newline		/* send failback request to pgpool parent */\newline		send_failback_request(recovery_node,false, false);\newline\newline		/* wait for failback */\newline		failback_wait_count = 0;\newline		while (!pcp_worker_wakeup_request)\newline		{\newline			struct timeval t = {1, 0};\newline			/* polling SIGUSR2 signal every 1 sec */\newline			select(0, NULL, NULL, NULL, &ampt);\newline			failback_wait_count++;\newline			if (failback_wait_count &gt= FAILBACK_WAIT_MAX_RETRY)\newline			{\newline				ereport(LOG,\newline					(errmsg(&quotnode recovery&quot),\newline						errdetail(&quotwaiting for wake up request is timeout(%d seconds)&quot,\newline							   FAILBACK_WAIT_MAX_RETRY)));\newline\newline				break;\newline			}\newline		}\newline		pcp_worker_wakeup_request = 0;\newline	}\newline	PG_CATCH();\newline	{\newline		PQfinish(conn);\newline		PG_RE_THROW();\newline	}\newline	PG_END_TRY();\newline\newline	PQfinish(conn);\newline\newline	ereport(LOG,\newline			(errmsg(&quotrecovery done&quot)));\newline}\newline","\newline Start online recovery.\newline &quotrecovery_node&quot is the node to be recovered.\newline Master or primary node is chosen in this function.\newline \newline","on","","on","","","","","on","","on","on","","on","","","","on","on","","","on","","","","","","","","","","","","","","","","","","","","","","{}","Center the playlist cursor on the current song","{}","Sets the data offset and size","Follow the chain of hashentries and delete them","Raises suitable Python exceptions when needed.","Function that is used to do the OCSP verification","{}","Links default services into the executive","{}","{}","Create a page for the look & feel options","{}","Start online recovery.","specifies how far an object goes on the grid","Set the read, write, and execute flags.","{}","{}","Code for serializing floats","get all information about a specific kb on this host,","{}"
"3T2HW4QDUV79FCNF0A24EBUFLHCC99","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3WR9XG3T63B4T9J0I03360NAE2Y477","AMD1LYNQAH3R8","Approved","Wed Apr 17 13:22:56 PDT 2019","Wed Apr 17 13:30:15 PDT 2019","Fri Apr 19 13:30:15 PDT 2019","2019-04-19 20:30:21 UTC","","","439","100% (27/27)","100% (27/27)","100% (27/27)","5891818","parametric.c","static void param_world_to_coord(const EL_INFO *el_info, int N,\newline				 const REAL_D world[],\newline				 REAL_B lambda[], int k[])\newline{\newline  FUNCNAME(&quotparam_world_to_coord&quot);\newline\newline/* stuff for newton */\newline  static ISP_DATA isp_data;\newline  static NLS_DATA nls_data = {\newline    nl_update,\newline    &ampisp_data,\newline    nl_solve,\newline    &ampisp_data,\newline    NULL,  /* norm */\newline    NULL,  /* norm-data */\newline    NULL,  /* work-space */\newline    1e-15, /* tolerance */\newline    1,     /* restart */\newline    1000,  /* max_iter */\newline    1,     /* info */\newline    -1.0,  /* initial residual */\newline    -1.0   /* residual */\newline  };\newline  REAL_B      lambda0_const, lambda0;\newline  int         iter, max_iter;\newline  REAL        tolerance, lambda_tolerance;\newline  int         dim_of_mesh = MIN(DIM_MAX, el_info-&gtmesh-&gtdim);\newline  int         fail_count  = 0;\newline  int         i, iq/* , dim */;\newline  int         k_dummy[N];\newline  \newline  LAGRANGE_PARAM_DATA *data = \newline    (LAGRANGE_PARAM_DATA *)el_info-&gtmesh-&gtparametric-&gtdata;\newline  REAL_D *local_coords      = data-&gtlocal_coords;\newline  const BAS_FCTS *bas_fcts  = data-&gtcoords-&gtfe_space-&gtbas_fcts;\newline\newline  REAL_D coord_backup[N_VERTICES(dim_of_mesh)];\newline\newline  nls_data.max_iter  = max_iter  = data-&gtmax_iter;\newline  nls_data.tolerance = tolerance = data-&gtnewton_tolerance;\newline  lambda_tolerance               = data-&gtlambda_tolerance;\newline\newline  if (!k) k = k_dummy;\newline\newline  if (DIM_OF_WORLD != dim_of_mesh) {\newline    ERROR_EXIT(&quotDIM_OF_WORLD = %d != %d = dim_of_mesh.&quot,\newline	       DIM_OF_WORLD, dim_of_mesh);\newline  }\newline  DEBUG_TEST_EXIT((el_info-&gtfill_flag &amp FILL_COORDS) ||\newline		  el_info-&gtmesh-&gtparametric-&gtuse_reference_mesh,\newline		  &quotYou must enable the use_reference_mesh entry in the &quot\newline		  &quotPARAMETRIC structure to use this function.\\n&quot);\newline\newline  if (!data-&gti_am_affine) {\newline    for (iq = 0; iq &lt N; iq++) {\newline      /* fill data */\newline      COPY_DOW(world[iq], isp_data.x);\newline      isp_data.el_info  = el_info;\newline      isp_data.bfcts    = (BAS_FCTS*)bas_fcts;\newline      isp_data.coords   = local_coords;\newline\newline      /* For planar and not too heavily deformed meshes the standard\newline       * world_to_coord should provide a reasonable initial value for\newline       * points inside the simplex. If world lies outside the simplex\newline       * we can neither guarantee the convergence of newton&#039s method\newline       * nor be sure that our initial lambda ist near the solution.\newline       */\newline      /* As global_refine does not fill the coords of projected nodes\newline       * into el_info_coord when use_reference_mesh == true (and not\newline       * at all if use_reference_mesh == false), we update el_info\newline       * with the correct information.\newline       */\newline      for (i = 0; i &lt N_VERTICES(dim_of_mesh); i++) {\newline	COPY_DOW(el_info-&gtcoord[i], coord_backup[i]);\newline	COPY_DOW(local_coords[i], (REAL *)el_info-&gtcoord[i]);\newline      }\newline\newline      world_to_coord(el_info, world[iq], lambda0_const);\newline\newline      /* Undo the hack above. */\newline      for (i=0; i &lt N_VERTICES(dim_of_mesh); i++) {\newline	COPY_DOW(coord_backup[i], (REAL *)el_info-&gtcoord[i]);\newline      }\newline      \newline      /* start newton, and retry if not successful */\newline      for (fail_count = 0; fail_count &lt N_LAMBDA(dim_of_mesh)+1;) {\newline	REAL sum = 0.0;\newline	\newline	COPY_BAR(DIM_MAX, lambda0_const, lambda0);\newline\newline	if (fail_count &gt 0) {\newline	  #if 0\newline	  WARNING(&quotNewton failed! current number of fails: %d.\\n&quot,\newline		  fail_count);\newline	  MSG(&quotRetry with different lambda0...\\n&quot);\newline	  #endif\newline	  lambda0[fail_count-1] += 0.1;\newline\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) sum += lambda0[i];\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) lambda0[i] /= sum;\newline	}\newline\newline	iter = nls_newton(&ampnls_data, N_LAMBDA(dim_of_mesh), (REAL *)&amplambda0);\newline	\newline	if (iter &gt max_iter) {\newline	  fail_count++;\newline	} else {\newline	  sum = 0;\newline	  for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) {\newline	    lambda[iq][i] = lambda0[i];\newline	    sum += lambda0[i];\newline	  }\newline	  if (ABS(sum-1) &gt 10.0*REAL_EPSILON) {\newline#if 0\newline	    MSG(&quotl_r[0]=%e, l_r[1]=%e, l_r[2]=%e\\n&quot,\newline		lambda0[0], lambda0[1], lambda0[2]);\newline#endif\newline	    ERROR_EXIT(&quot%e = sum{lambda[i]} != 1\\n&quot, ABS(sum-1));\newline	  }\newline\newline	  #if 0\newline	  MSG(&quotSuccess! Newton needed %d iterations and failed %d times.\\n&quot,\newline	      iter, fail_count);\newline	  #endif\newline	  break;\newline	}\newline      }\newline      if (fail_count &lt N_LAMBDA(dim_of_mesh)+1) {\newline	REAL lmin = 0.0;\newline	k[iq] = -1;\newline	for (i = 0; i &lt N_LAMBDA(dim_of_mesh); i++) {\newline	  if (lambda[iq][i] &lt lambda_tolerance) {\newline	    if (lambda[iq][i] &lt lmin) {\newline	      k[iq] = i;\newline	      lmin = lambda[iq][i];\newline	    }\newline	  }\newline	}\newline      } else {\newline	WARNING(&quot\\a Newton failed totally. &quot\newline		&quotMaybe you have to lift the tolerance a little, &quot\newline		&quotor there is no solution.\\n&quot);\newline	k[iq] = -2;\newline      }\newline    }\newline    return;\newline  } else {\newline    for (iq = 0; iq &lt N; iq++) {\newline      k[iq] = world_to_coord(el_info, world[iq], lambda[iq]);\newline    }\newline    return;\newline  }\newline}\newline","return: -2 if newton did not converge,\newline -1 if inside,\newline otherwise index of lambda &lt0\newline \newline","2476957","settingsdialog.cpp","void SettingsDialog::addLookAndFeelPage()\newline{\newline    QWidget* lookPage = new QWidget;\newline    QVBoxLayout *lookPageVBoxLayout = new QVBoxLayout(lookPage);\newline    KPageWidgetItem *page = new KPageWidgetItem( lookPage, i18n(&quotAppearance&quot) );\newline    page-&gtsetIcon( QIcon::fromTheme(&quotpreferences-desktop-theme&quot) );\newline\newline    QGroupBox* fontGroupBox = new QGroupBox(i18n(&quotFonts&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(fontGroupBox);\newline\newline    m_protocolFontBox  = new FontButton(i18n(&quotFont for &ampProtocol Window...&quot),\newline                                        fontGroupBox);\newline    m_annotateFontBox  = new FontButton(i18n(&quotFont for A&ampnnotate View...&quot),\newline                                        fontGroupBox);\newline    m_diffFontBox      = new FontButton(i18n(&quotFont for D&ampiff View...&quot),\newline                                        fontGroupBox);\newline    m_changelogFontBox = new FontButton(i18n(&quotFont for ChangeLog View...&quot),\newline                                        fontGroupBox);\newline\newline    QVBoxLayout* fontLayout( new QVBoxLayout( fontGroupBox ) );\newline    fontLayout-&gtaddWidget( m_protocolFontBox );\newline    fontLayout-&gtaddWidget( m_annotateFontBox );\newline    fontLayout-&gtaddWidget( m_diffFontBox );\newline    fontLayout-&gtaddWidget( m_changelogFontBox );\newline\newline    QGroupBox* colorGroupBox = new QGroupBox(i18n(&quotColors&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(colorGroupBox);\newline\newline    QLabel* conflictLabel = new QLabel(i18n(&quotConflict:&quot), colorGroupBox);\newline    m_conflictButton      = new KColorButton(colorGroupBox);\newline    conflictLabel-&gtsetBuddy(m_conflictButton);\newline\newline    QLabel* diffChangeLabel = new QLabel(i18n(&quotDiff change:&quot), colorGroupBox);\newline    m_diffChangeButton      = new KColorButton(colorGroupBox);\newline    diffChangeLabel-&gtsetBuddy(m_diffChangeButton);\newline\newline    QLabel* localChangeLabel = new QLabel(i18n(&quotLocal change:&quot), colorGroupBox);\newline    m_localChangeButton      = new KColorButton(colorGroupBox);\newline    localChangeLabel-&gtsetBuddy(m_localChangeButton);\newline\newline    QLabel* diffInsertLabel = new QLabel(i18n(&quotDiff insertion:&quot), colorGroupBox);\newline    m_diffInsertButton      = new KColorButton(colorGroupBox);\newline    diffInsertLabel-&gtsetBuddy(m_diffInsertButton);\newline\newline    QLabel* remoteChangeLabel = new QLabel(i18n(&quotRemote change:&quot), colorGroupBox);\newline    m_remoteChangeButton      = new KColorButton(colorGroupBox);\newline    remoteChangeLabel-&gtsetBuddy( m_remoteChangeButton );\newline\newline    QLabel* diffDeleteLabel = new QLabel(i18n(&quotDiff deletion:&quot), colorGroupBox);\newline    m_diffDeleteButton      = new KColorButton(colorGroupBox);\newline    diffDeleteLabel-&gtsetBuddy(m_diffDeleteButton);\newline\newline    QLabel* notInCvsLabel = new QLabel(i18n(&quotNot in cvs:&quot), colorGroupBox);\newline    m_notInCvsButton      = new KColorButton(colorGroupBox);\newline    notInCvsLabel-&gtsetBuddy(m_notInCvsButton);\newline\newline    QGridLayout* colorLayout( new QGridLayout( colorGroupBox ) );\newline    colorLayout-&gtaddWidget( conflictLabel, 0, 0 );\newline    colorLayout-&gtaddWidget( m_conflictButton, 0, 1 );\newline    colorLayout-&gtaddWidget( localChangeLabel, 1, 0 );\newline    colorLayout-&gtaddWidget( m_localChangeButton, 1, 1 );\newline    colorLayout-&gtaddWidget( remoteChangeLabel, 2, 0 );\newline    colorLayout-&gtaddWidget( m_remoteChangeButton, 2, 1 );\newline    colorLayout-&gtaddWidget( notInCvsLabel, 3, 0 );\newline    colorLayout-&gtaddWidget( m_notInCvsButton, 3, 1 );\newline\newline    colorLayout-&gtaddWidget( diffChangeLabel, 0, 3 );\newline    colorLayout-&gtaddWidget( m_diffChangeButton, 0, 4 );\newline    colorLayout-&gtaddWidget( diffInsertLabel, 1, 3 );\newline    colorLayout-&gtaddWidget( m_diffInsertButton, 1, 4 );\newline    colorLayout-&gtaddWidget( diffDeleteLabel, 2, 3 );\newline    colorLayout-&gtaddWidget( m_diffDeleteButton, 2, 4 );\newline\newline    m_splitterBox = new QCheckBox(i18n(&quotSplit main window &amphorizontally&quot), lookPage);\newline    lookPageVBoxLayout-&gtaddWidget(m_splitterBox);\newline\newline    addPage(page);\newline}\newline","\newline Create a page for the look &amp feel options\newline \newline","154957","parent.c","Point parent_move_child_delta(Rectangle *p_ext, Rectangle *c_ext, Point *delta)\newline{\newline    Point new_delta = {0, 0};\newline    gboolean free_delta = FALSE;\newline    if (delta == NULL)\newline    {\newline      delta = g_new0(Point, 1);\newline      free_delta = TRUE;\newline    }\newline    /* we check if the child extent would be inside the parent extent after the move\newline      if not, we calculate how far we have to move the extent back to place it back\newline      inside the parent extent */\newline    if (c_ext-&gtleft + delta-&gtx &lt p_ext-&gtleft )\newline      new_delta.x = p_ext-&gtleft - (c_ext-&gtleft + delta-&gtx);\newline    else if (c_ext-&gtleft + delta-&gtx + (c_ext-&gtright - c_ext-&gtleft) &gt p_ext-&gtright)\newline      new_delta.x = p_ext-&gtright - (c_ext-&gtleft + delta-&gtx + (c_ext-&gtright - c_ext-&gtleft));\newline\newline    if (c_ext-&gttop + delta-&gty &lt p_ext-&gttop)\newline      new_delta.y = p_ext-&gttop - (c_ext-&gttop + delta-&gty);\newline    else if (c_ext-&gttop + delta-&gty + (c_ext-&gtbottom - c_ext-&gttop) &gt p_ext-&gtbottom)\newline      new_delta.y = p_ext-&gtbottom  - (c_ext-&gttop + delta-&gty + (c_ext-&gtbottom - c_ext-&gttop));\newline\newline    if (free_delta)\newline      g_free(delta);\newline\newline    return new_delta;\newline}\newline","p_ext are the &quotextents&quot of the parent and c_ext are the &quotextents&quot of the child\newlineThe extent is a rectangle that specifies how far an object goes on the grid (based on its handles)\newlineIf delta is not present, these are the extents before any moves\newlineIf delta is present, delta is considered into the extents&#039s position\newline \newline","6110548","util.c","static void set_rwx(unsigned mode, char *str)\newline{\newline    str[0] = (char) ((mode &amp 4) ? &#039r&#039 : &#039-&#039);\newline    str[1] = (char) ((mode &amp 2) ? &#039w&#039 : &#039-&#039);\newline    str[2] = (char) ((mode &amp 1) ? &#039x&#039 : &#039-&#039);\newline}\newline","Set the read, write, and execute flags. \newline","554484","hostlist.c","static int _zero_padded(unsigned long num, int width)\newline{\newline    int n = 1;\newline    while (num /= 10L)\newline        n++;\newline    return width &gt n ? width - n : 0;\newline}\newline","return the number of zeros needed to pad &quotnum&quot to &quotwidth&quot\newline \newline","4495427","desa68.c","static int read_pc(void)\newline{\newline  unsigned int pc = d.pc;\newline\newline/*\newline  d.w = (s8)d.mem[pc++&ampd.memmsk]&lt&lt8;\newline  d.w  += d.mem[pc++&ampd.memmsk];\newline*/\newline\newline  d.w = d.mem_callb(pc &amp d.memmsk, d.private_data);\newline  pc += 2;\newline\newline  d.pc = pc;\newline  return d.w;\newline}\newline","Read next word , increment pc \newline","6468843","srl_encoder.c","SRL_STATIC_INLINE void\newlinesrl_dump_nv(pTHX_ srl_encoder_t *enc, SV *src)\newline{\newline    NV nv= SvNV(src);\newline    MS_VC6_WORKAROUND_VOLATILE float f= (float)nv;\newline    MS_VC6_WORKAROUND_VOLATILE double d= (double)nv;\newline    /* TODO: this logic could be reworked to not duplicate so much code, which will help on win32 */\newline    if ( f == nv || nv != nv ) {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(f)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_FLOAT);\newline        Copy((char *)&ampf, enc-&gtbuf.pos, sizeof(f), char);\newline        enc-&gtbuf.pos += sizeof(f);\newline    } else if (d == nv) {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(d)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_DOUBLE);\newline        Copy((char *)&ampd, enc-&gtbuf.pos, sizeof(d), char);\newline        enc-&gtbuf.pos += sizeof(d);\newline    } else {\newline        BUF_SIZE_ASSERT(&ampenc-&gtbuf, 1 + sizeof(nv)); /* heuristic: header + string + simple value */\newline        srl_buf_cat_char_nocheck(&ampenc-&gtbuf, SRL_HDR_LONG_DOUBLE);\newline        Copy((char *)&ampnv, enc-&gtbuf.pos, sizeof(nv), char);\newline#if SRL_EXTENDED_PRECISION_LONG_DOUBLE\newline        /* x86 uses an 80 bit extended precision. on 64 bit machines\newline         * this is 16 bytes long, and on 32 bits its is 12 bytes long.\newline         * the unused 2/6 bytes are not necessarily zeroed, potentially\newline         * allowing internal memory to be exposed. We therefore zero\newline         * the unused bytes here. */\newline        memset(enc-&gtbuf.pos+10, 0, sizeof(nv) - 10);\newline#endif\newline        enc-&gtbuf.pos += sizeof(nv);\newline    }\newline}\newline","Code for serializing floats \newline","1798220","admind.c","static void handle_cmd_get_kb_info(int client_fd, uint16_t datasize)\newline{\newline    int rv, len, err;\newline    fsa_kb_info *ki;\newline    unsigned char *response;\newline    unsigned char *kb_name;\newline\newline    kb_name = get_string_from_client(client_fd, datasize);\newline    if (kb_name == NULL) {\newline        /* errors already logged/handled */\newline        return;\newline    }\newline\newline    /* should already have been checked by client */\newline    if (!fsa_is_valid_kb_name((const char *)kb_name)) {\newline        fsa_error(LOG_CRIT, &quotInvalid kb name received from client&quot);\newline        send_error_message(client_fd, &quotkb name invalid&quot);\newline        free(kb_name);\newline        return;\newline    }\newline\newline    ki = fsab_get_local_kb_info(kb_name, &amperr);\newline    free(kb_name); /* done with kb_name */\newline    if (ki == NULL || err == ADM_ERR_KB_NOT_EXISTS) {\newline        send_error_message(client_fd, &quotfailed to get local kb info&quot);\newline        return;\newline    }\newline\newline    /* encode message for client */\newline    response = fsap_encode_rsp_get_kb_info(ki, &amplen);\newline    fsa_kb_info_free(ki);\newline    if (response == NULL) {\newline        send_error_message(client_fd, &quotfailed to encode kb info&quot);\newline        return;\newline    }\newline\newline    fsa_error(LOG_DEBUG, &quotresponse size is %d bytes&quot, len);\newline\newline    /* send entire response back to client */\newline    rv = fsa_sendall(client_fd, response, &amplen);\newline    free(response); /* done with response buffer */\newline    if (rv == -1) {\newline        fsa_error(LOG_ERR, &quotfailed to send response to client: %s&quot,\newline                  strerror(errno));\newline        return;\newline    }\newline\newline    fsa_error(LOG_DEBUG, &quot%d bytes sent to client&quot, len);\newline}\newline","get all information about a specific kb on this host, send to client \newline","1446312","reorder.c","int bdd_getreorder_times(void)\newline{\newline   return bddreordertimes;\newline}\newline","\newlineNAME { bdd\\_getreorder\\_times }\newlineSECTION { reorder }\newlineSHORT { Fetch the current number of allowed reorderings }\newlinePROTO { int bdd_getreorder_times(void) }\newlineDESCR { Returns the current number of allowed reorderings left. This\newlinevalue can be defined by {\\tt bdd\\_autoreorder\\_times}. }\newlineALSO { bdd\\_reorder\\_times, bdd\\_getreorder\\_method }\newline \newline","4214883","menu_mp3player.c","static void Center_Playlist(void) {\newline	int current;\newline	int curosor_position;\newline\newline	MP3_GetPlaylistInfo(&ampcurrent, NULL);\newline	M_Menu_MP3_Playlist_MoveBase(current);\newline\newline	/* Calculate the corect cursor position */\newline	/* We can display all songs so its just the current index */\newline	if (current &lt PLAYLIST_MAXLINES)\newline		curosor_position = current;\newline	/* We are at the end of the playlist */\newline	else if (playlist_size - (current) &lt PLAYLIST_MAXLINES)\newline		curosor_position = PLAYLIST_MAXLINES - (playlist_size - (current));\newline	/* We are in the middle of the playlist &amp the bottom is the current song*/\newline	else \newline		curosor_position = 0;\newline	M_Menu_MP3_Playlist_MoveCursor(curosor_position);\newline}\newline","\newline Center the playlist cursor on the current song\newline \newline","2188647","z88ci.c","int z88ci(void)\newline{\newlineextern FILE *fi2,*fi4,*f3y,*fo1,*fo2,*fl2;\newlineextern char ci2[],ci4[],c3y[],co1[],co2[];\newline\newlineextern FR_DOUBLEAY GS;\newlineextern FR_DOUBLEAY rs;\newlineextern FR_DOUBLEAY fak;\newline\newlineextern FR_INT4AY ip;\newlineextern FR_INT4AY iez;\newlineextern FR_INT4AY ioffs; \newlineextern FR_INT4AY ifrei; \newline\newlineextern FR_DOUBLE  eps,rp,rpomega,rpalpha;\newlineextern FR_INT4 kfoun,nkp,nfg,maxit,iqflag;\newlineextern FR_INT4 MAXNFG,LANG,ICFLAG;\newline\newlineFR_DOUBLE wert;\newline\newlineFR_INT4 i,nrb,k,nkn,ifg,iflag1,jndex,j;\newline\newlineint iret;\newline\newlinechar cline[256];\newline\newline/*----------------------------------------------------------------------\newline* Start Function\newline*---------------------------------------------------------------------*/\newlinewrim88i(0,TX_Z88CC);\newlinewlog88i2(0,LOG_Z88CC);\newline\newline/***********************************************************************\newline* Oeffnen der Files Z88I2.TXT,Z88I4.TXT,Z88O3.BNY,Z88O1.TXT &amp Z88O2.TXT\newline***********************************************************************/\newlinefi2= fopen(ci2,&quotr&quot);\newlineif(fi2 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOI2);\newline  fclose(fl2);\newline  return(AL_NOI2);\newline  }\newline\newlinerewind(fi2);\newline\newlinefi4= fopen(ci4,&quotr&quot);\newlineif(fi4 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOI4);\newline  fclose(fl2);\newline  return(AL_NOI4);\newline  }\newline\newlinerewind(fi4);\newline\newlinef3y= fopen(c3y,&quotw+b&quot);\newlineif(f3y == NULL)\newline  {\newline  wlog88i2(0,LOG_NO3Y);\newline  fclose(fl2);\newline  return(AL_NO3Y);\newline  }\newline\newlinerewind(f3y);\newline\newlinefo1= fopen(co1,&quotw+&quot);\newlineif(fo1 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOO1);\newline  fclose(fl2);\newline  return(AL_NOO1);\newline  }\newline\newlinerewind(fo1);\newline\newlinefo2= fopen(co2,&quotw+&quot);\newlineif(fo2 == NULL)\newline  {\newline  wlog88i2(0,LOG_NOO2);\newline  fclose(fl2);\newline  return(AL_NOO2);\newline  }\newline\newlinerewind(fo2);\newline\newline/***********************************************************************\newline* Lesen des Steuerfiles Z88I4.TXT\newline***********************************************************************/\newlinewrim88i(0,TX_REAI4);\newlinewlog88i2(0,LOG_REAI4);\newline\newlinefgets(cline,256,fi4);\newlinesscanf(cline,PDB PF PF PF,&ampmaxit,&ampeps,&amprpalpha,&amprpomega);\newline\newlinewlog88i2(maxit,LOG_MAXIT);\newlinefclose(fi4);\newline\newline/***********************************************************************\newline* Lesen des Randbedingungsfiles und Einarbeiten der RB, Pass 1\newline***********************************************************************/\newlinewrim88i(0,TX_REAI2);\newlinewrim88i(1,TX_ERBPA);\newlinewlog88i2(0,LOG_REAI2);\newlinewlog88i2(1,LOG_ERBPA);\newline\newlinefgets(cline,256,fi2);\newlinesscanf(cline,PD,&ampnrb);\newline\newlinefor(k = 1;k &lt= nrb;k++)\newline  {\newline\newline  fgets(cline,256,fi2);\newline  sscanf(cline,PDB PDB PDB PG,&ampnkn,&ampifg,&ampiflag1,&ampwert);\newline\newline  jndex= ioffs[nkn]-1+ifg;\newline\newline  wran88i(k,iflag1);\newline\newline/*----------------------------------------------------------------------\newline* Verzweigen, ob Kraft oder Verschiebung\newline*---------------------------------------------------------------------*/\newline/*======================================================================\newline* Kraft vorgegeben\newline*=====================================================================*/\newline  if (iflag1 == 1) rs[jndex]+= wert;     \newline\newline/*======================================================================\newline* Verschiebung vorgegeben\newline*=====================================================================*/\newline  if(iflag1 == 2)\newline    {\newline/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\newline* Verschiebung != 0\newline*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/ \newline    if(FR_FABS(wert) &gt=  1e-8)\newline      {\newline      rs[jndex]= wert;\newline      GS[ip[jndex]]= 1.;\newline\newline      if(jndex == 1) goto L30; \newline\newline      for(i= ip[jndex-1]+1; i &lt= ip[jndex]-1; i++)\newline        {\newline        rs[iez[i]]-= wert * GS[i];\newline        GS[i]= 0.;\newline        }  \newline\newline      L30: if(jndex == nfg) break;\newline\newline      for(j= jndex+1; j &lt= nfg; j++)\newline        {\newline        for(i= ip[j-1]+1; i &lt= ip[j]; i++)\newline          {\newline          if(iez[i] &gt jndex) break;\newline          if(iez[i] &lt jndex) continue;\newline          rs[j]-= wert * GS[i];\newline          GS[i]= 0.;\newline          break;\newline          }\newline        } \newline      } /* Ende inhomogene RB */\newline    else\newline/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\newline* Verschiebung == 0 \newline*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/ \newline      {\newline      GS[ip[jndex]]= 1.;\newline\newline      if(jndex == 1) goto L40; \newline\newline      for(i= ip[jndex-1]+1; i &lt= ip[jndex]-1; i++)\newline        GS[i]= 0.;\newline\newline      L40: if(jndex == nfg) break;\newline\newline      for(j= jndex+1; j &lt= nfg; j++)\newline        {\newline        for(i= ip[j-1]+1; i &lt= ip[j]; i++)\newline          {\newline          if(iez[i] &gt jndex) break;\newline          if(iez[i] &lt jndex) continue;\newline          GS[i]= 0.;\newline          break;\newline          }\newline        } \newline      } /* Ende homogene RB */\newline    } /* Ende Weg vorgeben */\newline\newline  } /* Ende Schleife Randbedingungen */\newline\newline/***********************************************************************\newline* Lesen des Randbedingungsfiles und Einarbeiten der RB, Pass 2\newline* Gleichzeitig Kontrollfile Z88O1.TXT beschreiben\newline***********************************************************************/\newlinewrim88i(0,TX_REAI2P2);\newlinewrim88i(2,TX_ERBPA);\newlinewrim88i(0,TX_WRIO1);\newlinewlog88i2(0,LOG_REAI2);\newlinewlog88i2(2,LOG_ERBPA);\newlinewlog88i2(0,LOG_WRIO1);\newline\newlinerewind(fi2);\newline\newlinefgets(cline,256,fi2);\newlinesscanf(cline,PD,&ampnrb);\newline\newlineif(LANG == 1)\newline{\newlinefprintf(fo1,&quotAusgabedatei Z88O1.TXT  Randbedingungen, erzeugt mit Z88I2 V13.0\\n&quot);\newlinefprintf(fo1,&quot                        ***************\\n\\n&quot);\newlinefprintf(fo1,&quotAnzahl gegebene Randbedingungen: &quot PD &quot\\n\\n&quot,nrb);\newline}\newline\newlineif(LANG == 2)\newline{\newlinefprintf(fo1,&quotoutput file Z88O1.TXT : constraints, produced by Z88I2 V13.0\\n&quot);\newlinefprintf(fo1,&quot                        ***********\\n\\n&quot);\newlinefprintf(fo1,&quotnumber of given constraints: &quot PD &quot\\n\\n&quot,nrb);\newline}\newline\newlinefor(k = 1;k &lt= nrb;k++)\newline  {\newline  fgets(cline,256,fi2);\newline  sscanf(cline,PDB PDB PDB PG,&ampnkn,&ampifg,&ampiflag1,&ampwert);\newline\newline  jndex= ioffs[nkn]-1+ifg;\newline  if(iflag1 == 2) rs[jndex]= wert;\newline\newline  if(iflag1 == 1)\newline    {\newline    if(LANG == 1)\newline    fprintf(fo1, &quotKnoten#&quot B5D &quot   FG&quot B1D &quot   Steuerflag&quot B1D &quot   Last         &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline\newline    if(LANG == 2)\newline    fprintf(fo1, &quot  node#&quot B5D &quot   DOF&quot B1D &quot  lo/di flag&quot B1D &quot   load         &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline    }\newline    \newline  if(iflag1 == 2)\newline    {\newline    if(LANG == 1)\newline    fprintf(fo1, &quotKnoten#&quot B5D &quot   FG&quot B1D &quot   Steuerflag&quot B1D &quot   Verschiebung &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline\newline    if(LANG == 2)\newline    fprintf(fo1,&quot  node#&quot B5D &quot   DOF&quot B1D &quot  lo/di flag&quot B1D &quot   displacement &quot P15E NL,\newline    nkn,ifg,iflag1,wert);\newline    }\newline  }\newline\newline/*----------------------------------------------------------------------\newline* ggf. Flaechenlasten nach Z88O1.TXT ausschreiben\newline*---------------------------------------------------------------------*/\newlineif(iqflag == 1) prfl88();\newline\newline/*----------------------------------------------------------------------\newline* Z88I2.TXT und Z88O1.TXT schliessen\newline*---------------------------------------------------------------------*/\newlinefclose(fi2);\newlinefclose(fo1);\newline\newline/***********************************************************************\newline* Gleichungssystem skalieren mit SCAL88\newline***********************************************************************/\newlinewrim88i(0,TX_SCAL88);\newlinewlog88i2(0,LOG_SCAL88);\newline\newlineiret= scal88();\newlineif(iret != 0) return(iret);\newline\newline/***********************************************************************\newline* Ab die Post: Loesen des Gleichungssystems mit SICCG88 oder SORCG88\newline***********************************************************************/\newlineif(ICFLAG == 1)\newline  {\newline  wrim88i(0,TX_SICCG88);\newline  wlog88i2(0,LOG_SICCG88);\newline\newline  wrim88i(nfg,TX_NFG);\newline  wrim88i(nfg,TX_ALPHA);\newline\newline  siccg88();\newline  }\newline\newlineif(ICFLAG == 2)\newline  {\newline  wrim88i(0,TX_SORCG88);\newline  wlog88i2(0,LOG_SORCG88);\newline\newline  wrim88i(nfg,TX_NFG);\newline  wrim88i(nfg,TX_OMEGA);\newline\newline  sorcg88();\newline  }\newline\newline/***********************************************************************\newline* Scalierung rueckgaengig machen\newline***********************************************************************/\newlinefor(i = 1;i &lt= nfg;i++)\newline  rs[i]*= fak[i];\newline\newline/***********************************************************************\newline* Beschreiben und Schliessen von Z88O3.BNY \newline***********************************************************************/\newlinewrim88i(0,TX_WRI3Y);\newlinewlog88i2(0,LOG_WRI3Y);\newline\newlinefwrite(&ampnfg,sizeof(FR_INT4),1,f3y);\newlinefor(i = 1;i &lt= nfg;i++)\newline  fwrite(&amprs[i],sizeof(FR_DOUBLE),1,f3y);\newline\newlinefclose(f3y);\newline\newline/***********************************************************************\newline* Beschreiben von Z88O2.TXT mit Verschiebungen\newline***********************************************************************/\newlinewrim88i(0,TX_WRIO2);\newlinewlog88i2(0,LOG_WRIO2);\newline\newlineif(LANG == 1)\newline{\newlinefprintf(fo2,&quotAusgabedatei Z88O2.TXT: Verschiebungen, erzeugt mit Z88I2 V13.0\\n&quot);\newlinefprintf(fo2,&quot                        **************\\n&quot);\newline}\newline\newlineif(LANG == 2)\newline{\newlinefprintf(fo2,&quotoutput file Z88O2.TXT: displacements, computed by Z88I2 V13.0\\n&quot);\newlinefprintf(fo2,&quot                       *************\\n&quot);\newline}\newline\newlinefprintf(fo2,\newline&quot\\nKnoten         U(1)              U(2)              U(3)\\\newline              U(4)              U(5)              U(6)\\n&quot);\newline\newline/*----------------------------------------------------------------------\newline* Schleife ueber alle Knoten\newline*---------------------------------------------------------------------*/\newlinek= 1;\newlinefor(i = 1;i &lt= nkp;i++)\newline  {\newline          \newline/*======================================================================\newline* 2 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 2)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E,i,rs[k],rs[k+1]);\newline    k+= 2;\newline    }\newline\newline/*======================================================================\newline* 3 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 3)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E B315E,i,rs[k],rs[k+1],rs[k+2]);\newline    k+= 3;\newline    }\newline\newline/*======================================================================\newline* 6 Freiheitsgrade:\newline*=====================================================================*/\newline  if (ifrei[i] == 6)\newline    {\newline    fprintf(fo2,NL B5D B315E B315E B315E B315E B315E B315E,\newline    i,rs[k],rs[k+1],rs[k+2],rs[k+3],rs[k+4],rs[k+5]);\newline    k+= 6;\newline    }\newline\newline/*---------------------------------------------------------------------\newline* Ende Schleife ueber alle Knoten\newline*--------------------------------------------------------------------*/\newline   }\newline\newline/***********************************************************************\newline* Schliessen des noch offenen Files, Ende Z88CI\newline***********************************************************************/\newlinefprintf(fo2,&quot\\n&quot);\newlinefclose(fo2);\newline\newlinewlog88i2(0,LOG_EXITZ88CC);\newlinereturn(0);\newline}\newline","\newline hier beginnt Function z88ci\newline \newline","1066581","libfdata_tree_node.c","int libfdata_tree_node_set_data_range(\newline     libfdata_tree_node_t *node,\newline     int node_file_index,\newline     off64_t node_offset,\newline     size64_t node_size,\newline     uint32_t node_flags,\newline     libcerror_error_t **error )\newline{\newline	libfdata_internal_tree_node_t *internal_tree_node = NULL;\newline	static char *function                             = &quotlibfdata_tree_node_set_data_range&quot;\newline\newline	if( node == NULL )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\newline		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\newline		 &quot%s: invalid node.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	internal_tree_node = (libfdata_internal_tree_node_t *) node;\newline\newline	if( ( internal_tree_node-&gtflags &amp LIBFDATA_TREE_NODE_FLAG_IS_VIRTUAL ) != 0 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\newline		 &quot%s: invalid node - node is virtual.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libfdata_range_set(\newline	     internal_tree_node-&gtnode_data_range,\newline	     node_file_index,\newline	     node_offset,\newline	     node_size,\newline	     node_flags,\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_SET_FAILED,\newline		 &quot%s: unable to set node data range.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	if( libfcache_date_time_get_timestamp(\newline	     &amp( internal_tree_node-&gttimestamp ),\newline	     error ) != 1 )\newline	{\newline		libcerror_error_set(\newline		 error,\newline		 LIBCERROR_ERROR_DOMAIN_RUNTIME,\newline		 LIBCERROR_RUNTIME_ERROR_GET_FAILED,\newline		 &quot%s: unable to retrieve cache timestamp.&quot,\newline		 function );\newline\newline		return( -1 );\newline	}\newline	return( 1 );\newline}\newline","Sets the data offset and size\newline Returns 1 if successful or -1 on error\newline \newline","4850078","hashmap.c","static int delete_hashbucket (struct hashbucket_s *bucket)\newline{\newline        struct hashentry_s *nextptr;\newline        struct hashentry_s *ptr;\newline\newline        if (bucket == NULL || bucket-&gthead == NULL)\newline                return -EINVAL;\newline\newline        ptr = bucket-&gthead;\newline        while (ptr) {\newline                nextptr = ptr-&gtnext;\newline\newline                safefree (ptr-&gtkey);\newline                safefree (ptr-&gtdata);\newline                safefree (ptr);\newline\newline                ptr = nextptr;\newline        }\newline\newline        return 0;\newline}\newline","\newline Follow the chain of hashentries and delete them (including the data and\newline the key.)\newline \newline Returns: 0 if the function completed successfully\newline negative number is returned if &quotentry&quot was NULL\newline \newline","2925016","convert.c","int igraphmodule_PyObject_to_vector_int_t(PyObject *list, igraph_vector_int_t *v) {\newline  PyObject *item;\newline  int value=0;\newline  Py_ssize_t i, j, k;\newline  int ok, retval;\newline\newline  if (PyBaseString_Check(list)) {\newline    /* It is highly unlikely that a string (although it is a sequence) will\newline     * provide us with integers or integer pairs */\newline    PyErr_SetString(PyExc_TypeError, &quotexpected a sequence or an iterable containing integers&quot);\newline    return 1;\newline  }\newline\newline  if (!PySequence_Check(list)) {\newline    /* try to use an iterator */\newline    PyObject *it = PyObject_GetIter(list);\newline    if (it) {\newline      PyObject *item;\newline      igraph_vector_int_init(v, 0);\newline      while ((item = PyIter_Next(it)) != 0) {\newline        ok = 1;\newline        if (!PyNumber_Check(item)) {\newline          PyErr_SetString(PyExc_TypeError, &quotiterable must return numbers&quot);\newline          ok=0;\newline        } else {\newline          PyObject *item2 = PyNumber_Int(item);\newline          if (item2 == 0) {\newline            PyErr_SetString(PyExc_TypeError, &quotcan&#039t convert a list item to integer&quot);\newline            ok = 0;\newline          } else {\newline            ok = (PyInt_AsInt(item, &ampvalue) == 0);\newline            Py_DECREF(item2);\newline          }\newline        }\newline       \newline        if (ok == 0) {\newline          igraph_vector_int_destroy(v);\newline          Py_DECREF(item);\newline          Py_DECREF(it);\newline          return 1;\newline        }\newline        if (igraph_vector_int_push_back(v, value)) {\newline          igraphmodule_handle_igraph_error();\newline          igraph_vector_int_destroy(v);\newline          Py_DECREF(item);\newline          Py_DECREF(it);\newline          return 1;\newline        }\newline        Py_DECREF(item);\newline      }\newline      Py_DECREF(it);\newline      return 0;\newline    } else {\newline      PyErr_SetString(PyExc_TypeError, &quotsequence or iterable expected&quot);\newline      return 1;\newline    }\newline    return 0;\newline  }\newline\newline  j=PySequence_Size(list);\newline  igraph_vector_int_init(v, j);\newline  for (i=0, k=0; i&ltj; i++) {\newline    item=PySequence_GetItem(list, i);\newline    if (item) {\newline      ok=1;\newline      if (!PyNumber_Check(item)) {\newline        PyErr_SetString(PyExc_TypeError, &quotsequence elements must be integers&quot);\newline        ok=0;\newline      } else {\newline        PyObject *item2 = PyNumber_Int(item);\newline        if (item2 == 0) {\newline          PyErr_SetString(PyExc_TypeError, &quotcan&#039t convert sequence element to int&quot);\newline          ok=0;\newline        } else {\newline          retval = PyInt_AsInt(item2, &ampvalue);\newline          if (retval)\newline            ok = 0;\newline          Py_DECREF(item2);\newline        }\newline      }\newline      Py_XDECREF(item);\newline      if (!ok) {\newline        igraph_vector_int_destroy(v);\newline        return 1;\newline      }\newline      VECTOR(*v)[k]=value;\newline      k++;\newline    } else {\newline      /* this should not happen, but we return anyway.\newline       * an IndexError exception was set by PyList_GetItem\newline       * at this point */\newline      igraph_vector_int_destroy(v);\newline      return 1;\newline    }\newline  }\newline  return 0;\newline}\newline","\newline \\ingroup python_interface_conversion\newline \\brief Converts a Python list of ints to an igraph \\c igraph_vector_int_t\newline The incoming \\c igraph_vector_int_t should be uninitialized.\newline Raises suitable Python exceptions when needed.\newline \newline This function is almost identical to\newline \\ref igraphmodule_PyObject_to_vector_t . Make sure you fix bugs\newline in both cases (if any).\newline \newline \\param list the Python list to be converted\newline \\param v the \\c igraph_vector_int_t containing the result\newline \\return 0 if everything was OK, 1 otherwise\newline \newline","4770327","sslutils.c","static int ssl_verify_OCSP(int ok, X509_STORE_CTX *ctx)\newline{\newline    X509 *cert, *issuer;\newline    int r = OCSP_STATUS_UNKNOWN;\newline\newline    cert = X509_STORE_CTX_get_current_cert(ctx);\newline    /* if we can&#039t get the issuer, we cannot perform OCSP verification */\newline    if (X509_STORE_CTX_get1_issuer(&ampissuer, ctx, cert) == 1 ) {\newline        r = ssl_ocsp_request(cert, issuer);\newline        if (r == OCSP_STATUS_REVOKED) {\newline            /* we set the error if we know that it is revoked */\newline            X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\newline        }\newline        else {\newline            /* else we return unknown, so that we can continue with the crl */\newline            r = OCSP_STATUS_UNKNOWN;\newline        }\newline        X509_free(issuer); /* It appears that we  should free issuer since\newline                            * X509_STORE_CTX_get1_issuer() calls X509_OBJECT_up_ref_count()\newline                            * on the issuer object (unline X509_STORE_CTX_get_current_cert()\newline                            * that just returns the pointer\newline                            */\newline    }\newline    return r;\newline}\newline","Function that is used to do the OCSP verification \newline","5687541","ne_socks.c","static int sofail(ne_socket *sock, ssize_t ret, const char *context)\newline{\newline    char *err = ne_strdup(ne_sock_error(sock));\newline    ne_sock_set_error(sock, &quot%s: %s&quot, context, err);\newline    ne_free(err);\newline    return NE_SOCK_ERROR;\newline}\newline","Fail with given NE_SOCK_ error code and given context. \newline","3372281","service.c","unsigned int corosync_service_defaults_link_and_init (struct corosync_api_v1 *corosync_api)\newline{\newline	unsigned int i;\newline	char *error;\newline\newline	for (i = 0;\newline		i &lt sizeof (default_services) / sizeof (struct default_service); i++) {\newline\newline		default_services[i].loader();\newline		error = corosync_service_link_and_init (\newline			corosync_api,\newline			&ampdefault_services[i]);\newline		if (error) {\newline			log_printf(LOGSYS_LEVEL_ERROR,\newline				&quotService engine &#039%s&#039 failed to load for reason &#039%s&#039&quot,\newline				default_services[i].name,\newline				error);\newline			corosync_exit_error (COROSYNC_DONE_SERVICE_ENGINE_INIT);\newline		}\newline	}\newline\newline	return (0);\newline}\newline","\newline Links default services into the executive\newline \newline","1284927","tetrahedron_method.c","static double _n_0(void)\newline{\newline  return 0.0;\newline}\newline","omega &lt omega1 \newline","5268095","menu-cache.c","MenuCacheDir* menu_cache_get_dir_from_path( MenuCache* cache, const char* path )\newline{\newline    char** names = g_strsplit( path + 1, &quot/&quot, -1 );\newline    int i = 0;\newline    MenuCacheDir* dir = NULL;\newline\newline    if( !names )\newline        return NULL;\newline\newline    if( G_UNLIKELY(!names[0]) )\newline    {\newline        g_strfreev(names);\newline        return NULL;\newline    }\newline    /* the topmost dir of the path should be the root menu dir. */\newline    MENU_CACHE_LOCK;\newline    dir = cache-&gtroot_dir;\newline    if (G_UNLIKELY(dir == NULL) || strcmp(names[0], MENU_CACHE_ITEM(dir)-&gtid))\newline    {\newline        MENU_CACHE_UNLOCK;\newline        return NULL;\newline    }\newline\newline    for( ++i; names[i]; ++i )\newline    {\newline        GSList* l;\newline        for( l = dir-&gtchildren; l; l = l-&gtnext )\newline        {\newline            MenuCacheItem* item = MENU_CACHE_ITEM(l-&gtdata);\newline            if( item-&gttype == MENU_CACHE_TYPE_DIR &amp&amp 0 == strcmp( item-&gtid, names[i] ) )\newline                dir = MENU_CACHE_DIR(item);\newline        }\newline        /* FIXME: we really should ref it on return since other thread may\newline           destroy the parent at this time and returned data become invalid.\newline           Therefore this call isn&#039t thread-safe! */\newline        if( ! dir )\newline        {\newline            MENU_CACHE_UNLOCK;\newline            return NULL;\newline        }\newline    }\newline    MENU_CACHE_UNLOCK;\newline    return dir;\newline}\newline","\newline menu_cache_get_dir_from_path\newline @cache: a menu cache instance\newline @path: item path\newline \newline Since: 0.1.0\newline \newline Deprecated: 0.3.4: Use menu_cache_item_from_path() instead.\newline \newline","1209208","jsint.c","void js_upcall_set_status(void *context, unsigned char *tak_se_ukaz_Kolbene)\newline{\newline	struct f_data_c *fd=(struct f_data_c*)context;\newline	unsigned char *trouba;\newline\newline	if (!fd)internal(&quotTo leda tak -PRd!\\n&quot);\newline\newline	if (!(*tak_se_ukaz_Kolbene)){mem_free(tak_se_ukaz_Kolbene);tak_se_ukaz_Kolbene=NULL;}\newline\newline	if (fd-&gtses-&gtst)mem_free(fd-&gtses-&gtst);\newline	skip_nonprintable(tak_se_ukaz_Kolbene);\newline	if (fd-&gtf_data&amp&amptak_se_ukaz_Kolbene)\newline	{\newline		trouba=convert(fd-&gtf_data-&gtcp, fd-&gtf_data-&gtopt.cp, tak_se_ukaz_Kolbene, NULL);\newline		mem_free(tak_se_ukaz_Kolbene);\newline		/* a je to v troube... */\newline	}\newline	else\newline	{\newline		trouba=tak_se_ukaz_Kolbene;\newline	}\newline\newline	fd-&gtses-&gtst=trouba;\newline	print_screen_status(fd-&gtses);\newline}\newline","set status-line text\newline tak_se_ukaz_Kolbene is allocated string or NULL\newline \newline","1821283","recovery.c","void start_recovery(int recovery_node)\newline{\newline	int node_id;\newline	BackendInfo *backend;\newline	BackendInfo *recovery_backend;\newline	PGconn *conn;\newline	int failback_wait_count;\newline#define FAILBACK_WAIT_MAX_RETRY 5		/* 5 seconds should be enough for failback operation */\newline\newline	ereport(LOG,\newline		(errmsg(&quotstarting recovering node %d&quot, recovery_node)));\newline\newline	if ( (recovery_node &lt 0) || (recovery_node &gt= pool_config-&gtbackend_desc-&gtnum_backends) )\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, node id: %d is not valid&quot, recovery_node)));\newline\newline	if (VALID_BACKEND(recovery_node))\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, node id: %d is alive&quot, recovery_node)));\newline\newline	/* select master/primary node */\newline	node_id = MASTER_SLAVE ? PRIMARY_NODE_ID : REAL_MASTER_NODE_ID;\newline	backend = &amppool_config-&gtbackend_desc-&gtbackend_info[node_id];\newline\newline	/* get node info to be recovered */\newline	recovery_backend = &amppool_config-&gtbackend_desc-&gtbackend_info[recovery_node];\newline\newline	conn = connect_backend_libpq(backend);\newline	if (conn == NULL)\newline		ereport(ERROR,\newline				(errmsg(&quotnode recovery failed, unable to connect to master node: %d &quot, node_id)));\newline\newline	PG_TRY();\newline	{\newline		/* 1st stage */\newline		if (REPLICATION)\newline		{\newline			exec_checkpoint(conn);\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, CHECKPOINT in the 1st stage done&quot)));\newline		}\newline\newline		exec_recovery(conn, backend, recovery_backend, FIRST_STAGE);\newline\newline		ereport(LOG,\newline			(errmsg(&quotnode recovery, 1st stage is done&quot)));\newline\newline		if (REPLICATION)\newline		{\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, starting 2nd stage&quot)));\newline\newline			/* 2nd stage */\newline			*InRecovery = RECOVERY_ONLINE;\newline			if (pool_config-&gtuse_watchdog)\newline			{\newline				/* announce start recovery */\newline				if (COMMAND_OK != wd_start_recovery())\newline					ereport(ERROR,\newline							(errmsg(&quotnode recovery failed, failed to send start recovery packet&quot)));\newline			}\newline\newline			if (wait_connection_closed() != 0)\newline				ereport(ERROR,\newline						(errmsg(&quotnode recovery failed, waiting connection closed in the other pgpools timeout&quot)));\newline\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery, all connections from clients have been closed&quot)));\newline\newline			exec_checkpoint(conn);\newline\newline			ereport(LOG,\newline				(errmsg(&quotnode recovery&quot),\newline					 errdetail(&quotCHECKPOINT in the 2nd stage done&quot)));\newline\newline			exec_recovery(conn, backend, recovery_backend, SECOND_STAGE);\newline		}\newline\newline		exec_remote_start(conn, recovery_backend);\newline\newline		check_postmaster_started(recovery_backend);\newline\newline		ereport(LOG,\newline			(errmsg(&quotnode recovery, node: %d restarted&quot, recovery_node)));\newline\newline		/*\newline		 * reset failover completion flag.  this is necessary since\newline		 * previous failover/failback will set the flag to 1.\newline		 */\newline		pcp_worker_wakeup_request = 0;\newline\newline		/* send failback request to pgpool parent */\newline		send_failback_request(recovery_node,false, false);\newline\newline		/* wait for failback */\newline		failback_wait_count = 0;\newline		while (!pcp_worker_wakeup_request)\newline		{\newline			struct timeval t = {1, 0};\newline			/* polling SIGUSR2 signal every 1 sec */\newline			select(0, NULL, NULL, NULL, &ampt);\newline			failback_wait_count++;\newline			if (failback_wait_count &gt= FAILBACK_WAIT_MAX_RETRY)\newline			{\newline				ereport(LOG,\newline					(errmsg(&quotnode recovery&quot),\newline						errdetail(&quotwaiting for wake up request is timeout(%d seconds)&quot,\newline							   FAILBACK_WAIT_MAX_RETRY)));\newline\newline				break;\newline			}\newline		}\newline		pcp_worker_wakeup_request = 0;\newline	}\newline	PG_CATCH();\newline	{\newline		PQfinish(conn);\newline		PG_RE_THROW();\newline	}\newline	PG_END_TRY();\newline\newline	PQfinish(conn);\newline\newline	ereport(LOG,\newline			(errmsg(&quotrecovery done&quot)));\newline}\newline","\newline Start online recovery.\newline &quotrecovery_node&quot is the node to be recovered.\newline Master or primary node is chosen in this function.\newline \newline","on","","on","","","","","on","","on","on","","","","on","","","","","","","","","","","","","","","","","","","","","","","","on","","","","{}","Center the playlist cursor on the current song","{}","Sets the data offset and size","Follow the chain of hashentries and delete them","Converts a Python list of ints to an igraph","used to do the OCSP verification","{}","Links default services into the executive","{}","{}","Create a page for the look & feel options","set status-line text","Start online recovery.","{}","Set the read, write, and execute flags.","return the number of zeros needed to pad ""num"" to ""width""","Read next word","Code for serializing floats","information about a specific kb on this host, send to client","Returns the current number of allowed reorderings left."
"3TTPFEFXCTKDE1WXOVDT5S0T889H6C","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","30OG32W0SUBBOW8GNDW5BJLRR7TNE5","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:40:36 PDT 2019","Wed Apr 17 15:47:36 PDT 2019","Fri Apr 19 15:47:36 PDT 2019","2019-04-19 22:48:21 UTC","","","420","100% (27/27)","100% (27/27)","100% (27/27)","4129349","cppcheckexecutor.cpp","static bool IsAddressOnStack(const void* ptr)\newline{\newline    if (nullptr==ptr)\newline        return false;\newline    char a;\newline    if (bStackBelowHeap)\newline        return ptr &lt &ampa;\newline    else\newline        return ptr &gt &ampa;\newline}\newline","\newline \\param[in] ptr address to be examined.\newline \\return true if address is supposed to be on stack (contrary to heap). If ptr is 0 false will be returned.\newline If unknown better return false.\newline \newline","5268680","reg.c","word_t peek_reg(const Tracee *tracee, RegVersion version, Reg reg)\newline{\newline	word_t result;\newline\newline	assert(version &lt NB_REG_VERSION);\newline\newline	result = REG(tracee, version, reg);\newline\newline	/* Use only the 32 least significant bits (LSB) when running\newline	 * 32-bit processes on a 64-bit kernel.  */\newline	if (is_32on64_mode(tracee))\newline		result &amp= 0xFFFFFFFF;\newline\newline	return result;\newline}\newline","\newline Return the cached value of the given @tracees&#039 @reg.\newline \newline","4996931","vid21394_base.c","unicap_status_t vid21394_set_brightness( vid21394handle_t vid21394handle, unsigned int brightness )\newline{\newline   unsigned long long fcp_write_i2c = WRITE_I2C_BYTE_MSG &lt&lt 24;	\newline   int bit = WRITE_I2C_BYTE_MSG - 0x10;\newline\newline   fcp_write_i2c |= I2C_SAA7112_ID;\newline   fcp_write_i2c |= I2C_BRIGHTNESS;\newline   fcp_write_i2c |= brightness &amp 0xff;\newline\newline   return( _vid21394_send_fcp_command( vid21394handle, fcp_write_i2c, bit, NULL ) );\newline}\newline","\newlineSet brightness level\newlineInput: vid21394handle\newlinebrightness\newlineReturns: STATUS_SUCCESS\newlineSTATUS_TIMEOUT\newlineSTATUS_NO_DEVICE\newlineSTATUS_FAILURE\newlineSTATUS_INVALID_PARAMETER: brightness level not in valid range\newline \newline","3068616","memwatch.c","static int mwRelink( mwData* mw, const char* file, int line ) {\newline    int fails;\newline    mwData *mw1, *mw2;\newline    long count, size;\newline    mwStat *ms;\newline\newline	if( file == NULL ) file = &quotunknown&quot;\newline\newline    if( mw == NULL ) {\newline        mwWrite(&quotrelink: cannot repair MW at NULL\\n&quot);\newline        FLUSH();\newline        goto emergency;\newline        }\newline\newline    if( !mwIsSafeAddr(mw, mwDataSize) ) {\newline        mwWrite(&quotrelink: MW-%p is a garbage pointer\\n&quot, mw);\newline        FLUSH();\newline        goto emergency;\newline        }\newline\newline    mwWrite(&quotrelink: &lt%ld&gt %s(%d) attempting to repair MW-%p...\\n&quot, mwCounter, file, line, mw );\newline    FLUSH();\newline    fails = 0;\newline\newline    /* Repair from head */\newline    if( mwHead != mw ) {\newline        if( !mwIsSafeAddr( mwHead, mwDataSize ) ) {\newline            mwWrite(&quotrelink: failed for MW-%p; head pointer destroyed\\n&quot, mw );\newline            FLUSH();\newline            goto emergency;\newline            }\newline        for( mw1=mwHead; mw1; mw1=mw1-&gtnext ) {\newline            if( mw1-&gtnext == mw ) {\newline                mw-&gtprev = mw1;\newline                break;\newline                }\newline            if( mw1-&gtnext &amp&amp\newline                ( !mwIsSafeAddr(mw1-&gtnext, mwDataSize ) || mw1-&gtnext-&gtprev != mw1) ) {\newline                mwWrite(&quotrelink: failed for MW-%p; forward chain fragmented at MW-%p: &#039next&#039 is %p\\n&quot, mw, mw1, mw1-&gtnext );\newline                FLUSH();\newline                goto emergency;\newline                }\newline            }\newline        if( mw1 == NULL ) {\newline            mwWrite(&quotrelink: MW-%p not found in forward chain search\\n&quot, mw );\newline            FLUSH();\newline            fails ++;\newline            }\newline        }\newline	else\newline	{\newline		mwWrite( &quotrelink: MW-%p is the head (first) allocation\\n&quot, mw );\newline		if( mw-&gtprev != NULL )\newline		{\newline			mwWrite( &quotrelink: MW-%p prev pointer is non-NULL, you have a wild pointer\\n&quot, mw );\newline			mw-&gtprev = NULL;\newline		}\newline	}\newline\newline    /* Repair from tail */\newline    if( mwTail != mw ) {\newline        if( !mwIsSafeAddr( mwTail, mwDataSize ) ) {\newline            mwWrite(&quotrelink: failed for MW-%p; tail pointer destroyed\\n&quot, mw );\newline            FLUSH();\newline            goto emergency;\newline            }\newline        for( mw1=mwTail; mw1; mw1=mw1-&gtprev ) {\newline            if( mw1-&gtprev == mw ) {\newline                mw-&gtnext = mw1;\newline                break;\newline                }\newline            if( mw1-&gtprev &amp&amp (!mwIsSafeAddr(mw1-&gtprev, mwDataSize ) || mw1-&gtprev-&gtnext != mw1) ) {\newline                mwWrite(&quotrelink: failed for MW-%p; reverse chain fragmented at MW-%p, &#039prev&#039 is %p\\n&quot, mw, mw1, mw1-&gtprev );\newline                FLUSH();\newline                goto emergency;\newline                }\newline            }\newline        if( mw1 == NULL ) {\newline            mwWrite(&quotrelink: MW-%p not found in reverse chain search\\n&quot, mw );\newline            FLUSH();\newline            fails ++;\newline            }\newline        }\newline	else\newline	{\newline		mwWrite( &quotrelink: MW-%p is the tail (last) allocation\\n&quot, mw );\newline		if( mw-&gtnext != NULL )\newline		{\newline			mwWrite( &quotrelink: MW-%p next pointer is non-NULL, you have a wild pointer\\n&quot, mw );\newline			mw-&gtnext = NULL;\newline		}\newline	}\newline\newline    if( fails &gt 1 ) {\newline        mwWrite(&quotrelink: heap appears intact, MW-%p probably garbage pointer\\n&quot, mw );\newline        FLUSH();\newline        goto verifyok;\newline        }\newline\newline    /* restore MW info where possible */\newline    if( mwIsReadAddr( mw-&gtfile, 1 ) ) {\newline        ms = mwStatGet( mw-&gtfile, -1, 0 );\newline        if( ms == NULL ) mw-&gtfile = &quot&ltrelinked&gt&quot;\newline        }\newline    mw-&gtcheck = CHKVAL(mw);\newline    goto verifyok;\newline\newline    /* Emergency repair */\newline    emergency:\newline\newline    if( mwHead == NULL &amp&amp mwTail == NULL )\newline    {\newline        if( mwStatCurAlloc == 0 )\newline            mwWrite(&quotrelink: &lt%ld&gt %s(%d) heap is empty, nothing to repair\\n&quot, mwCounter, file, line );\newline        else\newline            mwWrite(&quotrelink: &lt%ld&gt %s(%d) heap damaged beyond repair\\n&quot, mwCounter, file, line );\newline        FLUSH();\newline        return 0;\newline    }\newline\newline    mwWrite(&quotrelink: &lt%ld&gt %s(%d) attempting emergency repairs...\\n&quot, mwCounter, file, line );\newline    FLUSH();\newline\newline	if( mwHead == NULL || mwTail == NULL )\newline	{\newline		if( mwHead == NULL ) mwWrite(&quotrelink: mwHead is NULL, but mwTail is %p\\n&quot, mwTail );\newline		else mwWrite(&quotrelink: mwTail is NULL, but mwHead is %p\\n&quot, mwHead );\newline	}\newline\newline    mw1=NULL;\newline    if( mwHead != NULL )\newline	{\newline		if( !mwIsReadAddr( mwHead, mwDataSize ) || mwHead-&gtcheck != CHKVAL(mwHead) )\newline		{\newline			mwWrite(&quotrelink: mwHead (MW-%p) is damaged, skipping forward scan\\n&quot, mwHead );\newline			mwHead = NULL;\newline			goto scan_reverse;\newline		}\newline		if( mwHead-&gtprev != NULL )\newline		{\newline			mwWrite(&quotrelink: the mwHead pointer&#039s &#039prev&#039 member is %p, not NULL\\n&quot, mwHead-&gtprev );\newline		}\newline        for( mw1=mwHead; mw1; mw1=mw1-&gtnext )\newline		{\newline			if( mw1-&gtnext )\newline			{\newline				if( !mwIsReadAddr(mw1-&gtnext,mwDataSize) ||\newline					!mw1-&gtnext-&gtcheck != CHKVAL(mw1) ||\newline					mw1-&gtnext-&gtprev != mw1 )\newline				{\newline					mwWrite(&quotrelink: forward chain&#039s last intact MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline						mw1, mw1-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot, mw1-&gtfile, mw1-&gtline );\newline					if( mwIsReadAddr(mw1-&gtnext,mwDataSize ) )\newline					{\newline						mwWrite(&quotrelink: forward chain&#039s first damaged MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline							mw1-&gtnext, mw1-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot,\newline							mwIsReadAddr(mw1-&gtfile,16)?mw1-&gtfile:&quot&ltgarbage-pointer&gt&quot, mw1-&gtline );\newline					}\newline					else\newline					{\newline						mwWrite(&quotrelink: the &#039next&#039 pointer of this MW points to %p, which is out-of-legal-access\\n&quot,\newline							mw1-&gtnext );\newline					}\newline					break;\newline				}\newline			}\newline        }\newline	}\newline\newline\newlinescan_reverse:\newline    mw2=NULL;\newline    if( mwTail != NULL )\newline	{\newline		if( !mwIsReadAddr(mwTail,mwDataSize) || mwTail-&gtcheck != CHKVAL(mwTail) )\newline		{\newline			mwWrite(&quotrelink: mwTail (%p) is damaged, skipping reverse scan\\n&quot, mwTail );\newline			mwTail = NULL;\newline			goto analyze;\newline		}\newline		if( mwTail-&gtnext != NULL )\newline		{\newline			mwWrite(&quotrelink: the mwTail pointer&#039s &#039next&#039 member is %p, not NULL\\n&quot, mwTail-&gtnext );\newline		}\newline        for( mw2=mwTail; mw2; mw2=mw2-&gtprev )\newline		{\newline            if( mw2-&gtprev )\newline			{\newline				if( !mwIsReadAddr(mw2-&gtprev,mwDataSize) ||\newline					!mw2-&gtprev-&gtcheck != CHKVAL(mw2) ||\newline					mw2-&gtprev-&gtnext != mw2 )\newline				{\newline					mwWrite(&quotrelink: reverse chain&#039s last intact MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline						mw2, mw2-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot, mw2-&gtfile, mw2-&gtline );\newline					if( mwIsReadAddr(mw2-&gtprev,mwDataSize ) )\newline					{\newline						mwWrite(&quotrelink: reverse chain&#039s first damaged MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline							mw2-&gtprev, mw2-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot,\newline							mwIsReadAddr(mw2-&gtfile,16)?mw2-&gtfile:&quot&ltgarbage-pointer&gt&quot, mw2-&gtline );\newline					}\newline					else\newline					{\newline						mwWrite(&quotrelink: the &#039prev&#039 pointer of this MW points to %p, which is out-of-legal-access\\n&quot,\newline							mw2-&gtprev );\newline					}\newline					break;\newline				}\newline			}\newline        }\newline	}\newline\newlineanalyze:\newline	if( mwHead == NULL &amp&amp mwTail == NULL )\newline	{\newline        mwWrite(&quotrelink: both head and tail pointers damaged, aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline	}\newline	if( mwHead == NULL )\newline	{\newline		mwHead = mw2;\newline		mwWrite(&quotrelink: heap truncated, MW-%p designated as new mwHead\\n&quot, mw2 );\newline		mw2-&gtprev = NULL;\newline		mw1 = mw2 = NULL;\newline	}\newline	if( mwTail == NULL )\newline	{\newline		mwTail = mw1;\newline		mwWrite(&quotrelink: heap truncated, MW-%p designated as new mwTail\\n&quot, mw1 );\newline		mw1-&gtnext = NULL;\newline		mw1 = mw2 = NULL;\newline	}\newline    if( mw1 == NULL &amp&amp mw2 == NULL &amp&amp\newline        mwHead-&gtprev == NULL &amp&amp mwTail-&gtnext == NULL ) {\newline        mwWrite(&quotrelink: verifying heap integrity...\\n&quot );\newline        FLUSH();\newline        goto verifyok;\newline        }\newline    if( mw1 &amp&amp mw2 &amp&amp mw1 != mw2 ) {\newline        mw1-&gtnext = mw2;\newline        mw2-&gtprev = mw1;\newline        mwWrite(&quotrelink: emergency repairs successful, assessing damage...\\n&quot);\newline        FLUSH();\newline        }\newline    else {\newline        mwWrite(&quotrelink: heap totally destroyed, aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline        }\newline\newline    /* Verify by checking that the number of active allocations */\newline    /* match the number of entries in the chain */\newlineverifyok:\newline    if( !mwIsHeapOK( NULL ) ) {\newline        mwWrite(&quotrelink: heap verification FAILS - aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline        }\newline    for( size=count=0, mw1=mwHead; mw1; mw1=mw1-&gtnext ) {\newline        count ++;\newline        size += (long) mw1-&gtsize;\newline        }\newline    if( count == mwNumCurAlloc ) {\newline        mwWrite(&quotrelink: successful, &quot);\newline        if( size == mwStatCurAlloc ) {\newline            mwWrite(&quotno allocations lost\\n&quot);\newline            }\newline        else {\newline            if( mw != NULL ) {\newline                mwWrite(&quotsize information lost for MW-%p\\n&quot, mw);\newline                mw-&gtsize = 0;\newline                }\newline            }\newline        }\newline    else {\newline        mwWrite(&quotrelink: partial, %ld MW-blocks of %ld bytes lost\\n&quot,\newline			mwNmlNumAlloc+mwNumCurAlloc-count, mwNmlCurAlloc+mwStatCurAlloc-size );\newline        return 0;\newline        }\newline\newline    return 1;\newline    }\newline","\newline Relinking tries to repair a damaged mw block.\newline Returns nonzero if it thinks it successfully\newline repaired the heap chain.\newline \newline","5108307","emulate.c","int32 emulate_time(void) {\newline  return clock()-startime;\newline}\newline","\newline &#039emulate_time&#039 is called to deal with the Basic pseudo-variable\newline &#039TIME&#039 to return its current value. Under RISC OS, the C function\newline &#039clock&#039 returns the current value of the centisecond clock, which\newline is just what we want\newline \newline","5967937","rose_qsig_cc.c","unsigned char *rose_enc_qsig_CcnrRequest_ARG(struct pri *ctrl, unsigned char *pos,\newline	unsigned char *end, const union rose_msg_invoke_args *args)\newline{\newline	return rose_enc_qsig_CcRequestArg(ctrl, pos, end, ASN1_TAG_SEQUENCE,\newline		&ampargs-&gtqsig.CcnrRequest);\newline}\newline","!\newline \\brief Encode the Q.SIG CcnrRequest invoke facility ie arguments.\newline \newline \\param ctrl D channel controller for diagnostic messages or global options.\newline \\param pos Starting position to encode ASN.1 component.\newline \\param end End of ASN.1 encoding data buffer.\newline \\param args Arguments to encode in the buffer.\newline \newline \\retval Start of the next ASN.1 component to encode on success.\newline \\retval NULL on error.\newline \newline","6493740","sched.c","void sched_exec(void)\newline{\newline	struct task_struct *p = current;\newline	unsigned long flags;\newline	struct rq *rq;\newline	int dest_cpu;\newline\newline	rq = task_rq_lock(p, &ampflags);\newline	dest_cpu = p-&gtsched_class-&gtselect_task_rq(rq, p, SD_BALANCE_EXEC, 0);\newline	if (dest_cpu == smp_processor_id())\newline		goto unlock;\newline\newline	/*\newline	 * select_task_rq() can race against -&gtcpus_allowed\newline	 */\newline	if (cpumask_test_cpu(dest_cpu, &ampp-&gtcpus_allowed) &amp&amp\newline	    likely(cpu_active(dest_cpu)) &amp&amp migrate_task(p, dest_cpu)) {\newline		struct migration_arg arg = { p, dest_cpu };\newline\newline		task_rq_unlock(rq, &ampflags);\newline		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &amparg);\newline		return;\newline	}\newlineunlock:\newline	task_rq_unlock(rq, &ampflags);\newline}\newline","\newline sched_exec - execve() is a valuable balancing opportunity, because at\newline this point the task has the smallest effective memory and cache footprint.\newline \newline","2245088","p_polys.h","static inline unsigned pLength(poly a)\newline{\newline  unsigned l = 0;\newline  while (a!=NULL)\newline  {\newline    pIter(a);\newline    l++;\newline  }\newline  return l;\newline}\newline","2\newline returns the length of a polynomial (numbers of monomials)\newline \newline","243049","build.c","void sqliteAddNotNull(Parse *pParse, int onError){\newline  Table *p;\newline  int i;\newline  if( (p = pParse-&gtpNewTable)==0 ) return;\newline  i = p-&gtnCol-1;\newline  if( i&gt=0 ) p-&gtaCol[i].notNull = onError;\newline}\newline","\newline This routine is called by the parser while in the middle of\newline parsing a CREATE TABLE statement. A &quotNOT NULL&quot constraint has\newline been seen on a column. This routine sets the notNull flag on\newline the column currently under construction.\newline \newline","4047622","png.c","int rgba_to_gdkpixmap(GdkWindow *window, uint8 *data,int width, int height,\newline                      GdkPixmap **pix, GdkBitmap **mask, GdkColormap *colormap)\newline{\newline    GdkGC       *gc, *gc_alpha;\newline    int         has_alpha=0, alpha;\newline    GdkColor  scolor;\newline    int x,y;\newline\newline    *pix = gdk_pixmap_new(window, width, height, -1);\newline\newline    gc=gdk_gc_new(*pix);\newline    gdk_gc_set_function(gc, GDK_COPY);\newline\newline    *mask=gdk_pixmap_new(window, width, height,1);\newline    gc_alpha=gdk_gc_new(*mask);\newline\newline    scolor.pixel=1;\newline    gdk_gc_set_foreground(gc_alpha, &ampscolor);\newline    gdk_draw_rectangle(*mask, gc_alpha, 1, 0, 0, width, height);\newline\newline    scolor.pixel=0;\newline    gdk_gc_set_foreground(gc_alpha, &ampscolor);\newline\newline    /* we need to draw the alpha channel.  The image may not in fact\newline     * have alpha, but no way to know at this point other than to try\newline     * and draw it.\newline     */\newline    for (y=0; y&ltheight; y++) {\newline        for (x=0; x&ltwidth; x++) {\newline            alpha = data[(y * width + x) * 4 +3];\newline            /* Transparent bit */\newline            if (alpha==0) {\newline                gdk_draw_point(*mask, gc_alpha, x, y);\newline                has_alpha=1;\newline            }\newline        }\newline    }\newline\newline    gdk_draw_rgb_32_image(*pix, gc,  0, 0, width, height, GDK_RGB_DITHER_NONE, data, width*4);\newline    if (!has_alpha) {\newline        gdk_pixmap_unref(*mask);\newline        *mask = NULL;\newline    }\newline\newline    gdk_gc_destroy(gc_alpha);\newline    gdk_gc_destroy(gc);\newline    return 0;\newline}\newline","\newline Takes data that has already been converted into RGBA format (via png_to_data\newline above perhaps) and creates a GdkPixmap and GdkBitmap out of it.\newline \newline @param window\newline @param data\newline @param width\newline @param height\newline @param pix\newline @param mask\newline @param colormap\newline @return Non-zero on error (currently, no checks for error conditions is done\newline \newline","11768","instore.c","external_parser_type *TinTree(const tsd_t *TSD,\newline                              const internal_parser_type *ipt,\newline                              unsigned long *length)\newline{\newline   external_parser_type *retval;\newline   unsigned long srclines, nodecount, len;\newline\newline   *length = ComputeExternalSize(ipt, &ampsrclines, &ampnodecount);\newline\newline   retval = (external_parser_type *)IfcAllocateMemory(*length);\newline   if (retval == NULL)\newline      return(NULL);\newline   memset(retval, 0, sizeof(external_parser_type));\newline\newline   /* Build the envelope */\newline   len = sizeof(MagicHeader); /* includes a terminating 0 */\newline   if (len &gt sizeof(retval-&gtMagic))\newline      len = sizeof(retval-&gtMagic);\newline   memcpy(retval-&gtMagic, MagicHeader, len);\newline   len = sizeof(PARSE_VERSION_STRING);\newline   if (len &gt sizeof(retval-&gtReginaVersion))\newline      len = sizeof(retval-&gtReginaVersion);\newline   memcpy(retval-&gtReginaVersion, PARSE_VERSION_STRING, len);\newline\newline   retval-&gtarch_detector.s.one = 1;\newline   retval-&gtarch_detector.s.two = 2;\newline   retval-&gtarch_detector.s.ptr3 = (void *)3;\newline   retval-&gtarch_detector.s.ptr4 = (void *)4;\newline   retval-&gtOverallSize = (unsigned long) *length;\newline   retval-&gtNumberOfSourceLines = srclines;\newline   retval-&gtversion = INSTORE_VERSION;\newline   retval-&gtNumberOfTreeElements = nodecount;\newline\newline   retval-&gtsource = sizeof(external_parser_type);\newline   len = FillStrings((char *) retval,\newline                     sizeof(external_parser_type),\newline                     ipt-&gtsrclines);\newline\newline   retval-&gttree = len;\newline   retval-&gtTreeStart = ipt-&gtroot-&gtnodeindex;\newline   len = FillTree((treenode *) ((char *) retval + len),\newline                  (char *) retval,\newline                  len + nodecount*sizeof(treenode),\newline                  ipt-&gtnodes);\newline\newline   memcpy((char *) retval + len, retval-&gtMagic, sizeof(retval-&gtMagic));\newline\newline   assert((unsigned long) len + sizeof(retval-&gtMagic) == *length);\newline\newline   /* DEBUGGING: return NULL if you don&#039t want tinned trees */\newline   TSD = TSD; /* keep compiler happy */\newline   return(retval);\newline}\newline","TinTree &quottins&quot a tree into an external structure. The complete structure\newline is allocated by one call to IfcAllocateMemory. The returned value shall\newline be used as an instore macro for RexxStart.\newline length is set to the allocated size of the memory block on return.\newline ExpandedTinnedTree can expand the returned value and IsValidTin checks it.\newline \newline","4051121","previsat.cpp","void PreviSat::on_effacerHeuresIri_clicked()\newline{\newline    /* Declarations des variables locales */\newline\newline    /* Initialisations */\newline\newline    /* Corps de la methode */\newline    ui-&gtdateInitialeIri-&gtsetTime(QTime(0, 0, 0));\newline    ui-&gtdateFinaleIri-&gtsetTime(QTime(0, 0, 0));\newline\newline    /* Retour */\newline    return;\newline}\newline","\newline Calcul des flashs Iridium\newline \newline","3068951","nxstaxablock.cpp","bool NxsTaxaBlock::NeedsQuotes(\newline  unsigned i)	/* the taxon label number in question */\newline	{\newline	const NxsString x(GetTaxonLabel(i).c_str());\newline	return x.QuotesNeeded();\newline	}\newline","!\newline Returns true if taxonLabels[i] contains embedded spaces and thus should be surrounded by single quotes if output is\newline NEXUS format.\newline \newline","3672140","dsensor.c","void ds_shutdown(void) {\newline\newline  AD_CSR=0x00;\newline  PORT6        &amp=DS_ALL_PASSIVE;\newline  rom_port6_ddr&amp=DS_ALL_PASSIVE;\newline  PORT6_DDR     =rom_port6_ddr;\newline}\newline","! all sensors set to passive mode\newline \newline","4630930","fix_imd.cpp","void FixIMD::ioworker()\newline{\newline  while (1) {\newline    pthread_mutex_lock(&ampwrite_mutex);\newline    if (buf_has_data &lt 0) {\newline      /* master told us to go away */\newline      fprintf(screen,&quotAsynchronous I/O thread is exiting.\\n&quot);\newline      buf_has_data=0;\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline      pthread_exit(NULL);\newline    } else if (buf_has_data &gt 0) {\newline      /* send coordinate data, if client is able to accept */\newline      if (clientsock &amp&amp imdsock_selwrite(clientsock,0)) {\newline        imd_writen(clientsock, msgdata, msglen);\newline      }\newline      delete[] msgdata;\newline      buf_has_data=0;\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline    } else {\newline      /* nothing to write out yet. wait on condition. */\newline      pthread_cond_wait(&ampwrite_cond, &ampwrite_mutex);\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline    }\newline  }\newline}\newline","the real i/o worker thread \newline","340908","lexinit2.c","void raw_fe_reorder(edge_id e_id)\newline{ int fcount = 0;\newline  facetedge_id fe;\newline  struct fsort fe_list[FSORTMAX];\newline  REAL side[MAXCOORD],norm_a[MAXCOORD],side_a[MAXCOORD];\newline  REAL side_b[MAXCOORD],norm_aa[MAXCOORD],a_norm,aa_norm;\newline  REAL c,s,angle;\newline  int i,j,k;\newline  facetedge_id first_fe;\newline\newline  memset(norm_a,0,sizeof(norm_a));\newline  memset(norm_aa,0,sizeof(norm_aa));\newline\newline  /* see if we have 3 or more facets */\newline  fe = first_fe = get_edge_fe(e_id);\newline  if ( valid_id(fe) ) \newline  do { fcount++; \newline       fe = get_next_facet(fe);\newline     } while ( valid_id(fe) &amp&amp !equal_id(fe,first_fe) );\newline  if ( fcount &lt= 2 ) return;\newline\newline  if ( fcount &gt FSORTMAX )\newline  { kb_error(5742,&quotMore than 100 facets on an edge; not sorted.\\n&quot,WARNING); \newline    return;\newline  }\newline\newline  /* use first facet as reference facet */\newline  /* to get basis for calculating angles */\newline  get_edge_side(e_id,side);     \newline  fe = get_edge_fe(e_id);\newline  fe_list[0].fe = fe;\newline  get_fe_side(get_next_edge(fe),side_a);\newline  cross_prod(side,side_a,norm_a);\newline  cross_prod(norm_a,side,norm_aa);\newline  a_norm = sqrt(SDIM_dot(norm_a,norm_a));\newline  aa_norm = sqrt(SDIM_dot(norm_aa,norm_aa));\newline\newline  /* now get angles to rest of facets */\newline  fe_list[0].angle = 0.0;\newline  for ( i = 1 ; i &lt fcount ; i++ )\newline  { fe = get_next_facet(fe);\newline    fe_list[i].fe = fe;\newline    get_fe_side(get_next_edge(fe),side_b);\newline    s = SDIM_dot(side_b,norm_a)*aa_norm;\newline    c = SDIM_dot(side_b,norm_aa)*a_norm;\newline    angle = atan2(s,c);\newline    fe_list[i].angle = angle;\newline  }\newline\newline  /* sort by angle */\newline  for ( j = 0 ; j &lt fcount-1 ; j++ )\newline    for ( k = j+1 ; k &lt fcount ; k++ )\newline       if ( fe_list[k].angle &lt fe_list[j].angle )\newline       { struct fsort ftemp;\newline         ftemp = fe_list[k];\newline         fe_list[k] = fe_list[j];\newline         fe_list[j] = ftemp;\newline       } \newline\newline  /* relink in proper order */\newline  for ( i = 0 ; i &lt fcount ; i++ )\newline  { set_next_facet(fe_list[i].fe,fe_list[(i+1)%fcount].fe);\newline    set_prev_facet(fe_list[i].fe,fe_list[(i+fcount-1)%fcount].fe);\newline  }\newline} // end raw_fe_reorder()\newline","\newline \newline Function: raw_fe_reorder()\newline \newline Purpose: Order facets properly around edge, without regard for bodies.\newline For use by merge_edge().\newline Note: for higher dimension ambient space, just uses \newline first three dimensions.\newline \newline","6007880","defins.c","globle void ListDefinstancesCommand(\newline  void *theEnv)\newline  {\newline   ListConstructCommand(theEnv,&quotlist-definstances&quot,DefinstancesData(theEnv)-&gtDefinstancesConstruct);\newline  }\newline","\newlineNAME : ListDefinstancesCommand\newlineDESCRIPTION : Displays all definstances names\newlineINPUTS : None\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Definstances name sprinted\newlineNOTES : H/L Interface\newline \newline","1576513","format_dpdk.c","static int dpdk_config_input (libtrace_t *libtrace,\newline                                        trace_option_t option,\newline                                        void *data) {\newline    switch (option) {\newline        case TRACE_OPTION_SNAPLEN:\newline            /* Only support changing snaplen before a call to start is \newline             * made */\newline            if (FORMAT(libtrace)-&gtpaused == DPDK_NEVER_STARTED)\newline                FORMAT(libtrace)-&gtsnaplen=*(int*)data;\newline            else\newline                return -1;\newline            return 0;\newline		case TRACE_OPTION_PROMISC:\newline			FORMAT(libtrace)-&gtpromisc=*(int*)data;\newline            return 0;\newline        case TRACE_OPTION_FILTER:\newline            /* TODO filtering */\newline            break;\newline        case TRACE_OPTION_META_FREQ:\newline            break;\newline        case TRACE_OPTION_EVENT_REALTIME:\newline            break;\newline        /* Avoid default: so that future options will cause a warning\newline         * here to remind us to implement it, or flag it as\newline         * unimplementable\newline         */\newline    }\newline\newline	/* Don&#039t set an error - trace_config will try to deal with the\newline	 * option and will set an error if it fails */\newline    return -1;\newline}\newline","\newline Note here snaplen excludes the MAC checksum. Packets over\newline the requested snaplen will be dropped. (Excluding MAC checksum)\newline \newline I.e the maximum size of a standard ethernet packet is 1518 (Including MAC checksum)\newline So to allow packets upto 1518 this would be set to 1514 and if GET_MAC_CRC_CHECKSUM\newline is set the maximum size of the returned packet would be 1518 otherwise\newline 1514 would be the largest size possibly returned.\newline \newline \newline","2662755","scan.c","int scan_inquiry (hcicfg_t *hci)\newline{\newline	int num_rsp, length, flags, dd, i, cc, rv;\newline	inquiry_info *info = NULL;\newline	device_t *dev;\newline	char buf[BUFN_SZ], tmp[32];\newline	uint16_t handle;\newline	struct search_context context;\newline	rangedef_t *range;\newline	uint8_t do_store, uval;\newline	int8_t val;\newline\newline\newline	length = 8; /* ~10 seconds */\newline	flags = IREQ_CACHE_FLUSH; /* flush each time */\newline	num_rsp = 10; /* max devices to scan for, FIXME */\newline	cc = 0;\newline	do_store = 0;\newline\newline	/* scan */\newline	num_rsp = hci_inquiry(hci-&gtid, length, num_rsp, NULL, &ampinfo, flags);\newline	if (num_rsp &lt 0)\newline		return -1;\newline\newline	/* open the bluetooth device to enquiries */\newline	dd = hci_open_dev(hci-&gtid);\newline	if (dd &lt 0)\newline		return -1;\newline\newline	/* now we have a list of devices, get thier info and enum */\newline	for (i = 0; i &lt num_rsp &amp&amp bts_run_scan; i++, cc=0) {\newline		/* get the rangedef for this particular device */\newline		range = cfg_get_range(bd2int(&amp(info+i)-&gtbdaddr));\newline		if (!range) continue;\newline\newline		ba2str(&amp(info+i)-&gtbdaddr, tmp);\newline		screen_log(&quotFound device %s&quot, tmp);\newline\newline		dev = ll_lock_device(&amp(info+i)-&gtbdaddr);\newline		if (!dev) continue; /* malloc failed or locked */\newline\newline		/* the clock offset + class */\newline		ll_lock_list();\newline		dev-&gtclk_off = (info+i)-&gtclock_offset;\newline		if (!dev-&gtgot_class) {\newline			dev-&gtclass = (info+i)-&gtdev_class[2] &lt&lt 16;\newline			dev-&gtclass |= (info+i)-&gtdev_class[1] &lt&lt 8;\newline			dev-&gtclass |= (info+i)-&gtdev_class[0];\newline			dev-&gtgot_class = 1;\newline			do_store = 1;\newline		}\newline\newline		/* state of play */\newline		dev-&gtupdated = 1;\newline		time(&amp(dev-&gtlast_scanned));\newline		bacpy(&amp(dev-&gtbd_scan), &amp(hci-&gtbdaddr));\newline		dev-&gtscan_count++;\newline		ll_unlock_list();\newline\newline\newline		/* the name */\newline		if ((range-&gtsf &amp SF_NAME) &amp&amp !ll_check_got_name(dev)) {\newline			if (hci_read_remote_name(dd, &amp(info+i)-&gtbdaddr,\newline			  BUFN_SZ*sizeof(char), buf, 100000) == 0) {\newline				ll_lock_list();\newline				ll_copy_name(dev, buf);\newline				dev-&gtgot_name = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		/* the oui */\newline		if (!ll_check_got_oui(dev)) {\newline			ll_lock_list();\newline			dev-&gtoui = ouidb_query(&ampdev-&gtbdaddr);\newline			dev-&gtgot_oui = 1;\newline			ll_unlock_list();\newline		}\newline\newline		/* do we need to do any of this */\newline		if (0 == (range-&gtsf &amp ~(SF_HCI|SF_RSSI|SF_LQ|SF_TXPWR|SF_SDP)))\newline			goto scan_inquiry_nextdev;\newline			\newline\newline		/* get a connection */\newline		handle = find_conn(hci-&gtid, &ampdev-&gtbdaddr);\newline		if ((uint16_t)-1 == handle) {\newline			if (0 != errno) break;\newline\newline			cc=1;\newline			if (hci_create_connection(dd, &ampdev-&gtbdaddr, HCI_DM1 | HCI_DH1,\newline			  0, 0, &amphandle, 25000) &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_create_connection(): Cant create: %s&quot,\newline				  __FUNCTION__, strerror(errno));\newline				goto scan_inquiry_nextdev;\newline			}\newline\newline		}\newline\newline		/* the hci info */\newline		if ((range-&gtsf &amp SF_HCI) &amp&amp !ll_check_got_version(dev)) {\newline			if (hci_read_remote_version(dd,handle, &ampdev-&gtversion,20000) == 0) {\newline				ll_lock_list();\newline				dev-&gtgot_version = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		if ((range-&gtsf &amp SF_HCI) &amp&amp !ll_check_got_features(dev)) {\newline			if (hci_read_remote_features(dd,handle,dev-&gtfeatures,20000) == 0) {\newline				ll_lock_list();\newline				dev-&gtgot_features = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		/* read the RSSI/LQ/TXPWR */\newline		/* RSSI */\newline		if (range-&gtsf &amp SF_RSSI) {\newline			rv = hci_read_rssi(dd, handle, &ampval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): rssi read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gtrssi_status = rv;\newline			dev-&gtrssi = val;\newline			ll_unlock_list();\newline		}\newline\newline		/* LQ */\newline		if (range-&gtsf &amp SF_LQ) {\newline			rv = hci_read_link_quality(dd, handle, &ampuval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): lq read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gtlq_status = rv; \newline			dev-&gtlq = uval;\newline			ll_unlock_list();\newline		}\newline\newline		/* TXPWR */\newline		if (range-&gtsf &amp SF_TXPWR) {\newline			rv = hci_read_transmit_power_level(dd, handle, 0, &ampval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): tpl read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gttxpwr_status = rv;\newline			dev-&gttxpwr_type = 0;\newline			dev-&gttxpwr_level = val;\newline			ll_unlock_list();\newline		}\newline\newline\newline		/* read the SDP info */\newline		if ((range-&gtsf &amp SF_SDP) &amp&amp !ll_check_got_sdp(dev)) {\newline			cbuf_t sdpstr;\newline			memset(&ampsdpstr, 0, sizeof(cbuf_t));\newline			memset(&ampcontext, 0, sizeof(struct search_context));\newline			sdp_uuid16_create(&amp(context.group), PUBLIC_BROWSE_GROUP);\newline			scan_sdp(hci, dev, &ampsdpstr, &ampcontext);\newline\newline			ll_lock_list();\newline			if(sdpstr.buf) sdpstr.buf[sdpstr.len] = 0;\newline			dev-&gtsdp = sdpstr.buf;\newline			do_store = 1;\newline			ll_unlock_list();\newline		}\newline\newline		/* all done */\newline		scan_inquiry_nextdev:\newline\newline		/* store a timestamp */\newline		store_timestamp(dev);\newline		/* store the device if needed */\newline		if (do_store) {\newline			store_device(dev);\newline			do_store = 0;\newline		}\newline		/* unlock */\newline		ll_unlock_device(dev);\newline\newline		/* disconnect */\newline		if (cc)\newline			hci_disconnect(dd, handle, HCI_OE_USER_ENDED_CONNECTION, 10000);\newline\newline	}\newline\newline	/* tidy up */\newline	hci_close_dev(dd);\newline	free(info);\newline	info = NULL;\newline\newline	return 0;\newline}\newline","scan_inquiry: run a standard inquiry \newline","2788886","measures3d.c","int lw_dist3d_line_poly(LWLINE *line, LWPOLY *poly, DISTPTS3D *dl)\newline{\newline	PLANE3D plane;	\newline	LWDEBUG(2, &quotlw_dist3d_line_poly is called&quot);	\newline		\newline	if (dl-&gtmode == DIST_MAX)\newline	{\newline		return lw_dist3d_ptarray_ptarray(line-&gtpoints, poly-&gtrings[0], dl);\newline	}\newline	\newline	if(!define_plane(poly-&gtrings[0], &ampplane))\newline		return LW_FALSE;\newline	\newline	return lw_dist3d_ptarray_poly(line-&gtpoints, poly,&ampplane, dl);\newline}\newline","\newlineline to polygon calculation\newline \newline","146911","srf.c","void srf_index_destroy(srf_index_t *idx) {\newline    size_t i;\newline\newline    if (!idx)\newline	return;\newline\newline    if (idx-&gtdb_hash)\newline	HashTableDestroy(idx-&gtdb_hash, 0);\newline    if (idx-&gtch_pos)\newline	ArrayDestroy(idx-&gtch_pos);\newline    if (idx-&gtth_pos)\newline	ArrayDestroy(idx-&gtth_pos);\newline    if (idx-&gtname_blocks) {\newline        for (i = 0; i &lt ArrayMax(idx-&gtname_blocks); i++) {\newline	    if (NULL != arr(srf_name_block_t, idx-&gtname_blocks, i).names)\newline	        free(arr(srf_name_block_t, idx-&gtname_blocks, i).names);\newline        }\newline	ArrayDestroy(idx-&gtname_blocks);\newline    }\newline\newline    free(idx);\newline}\newline","\newline Deallocates memory used by an srf_index_t structure.\newline \newline","","","on","on","","","on","","","on","","","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","\return true if address is supposed to be on stack","creates a GdkPixmap and GdkBitmap","{}","{}","Returns true if taxonLabels[i] contains embedded spaces","all sensors set to passive mode","{}","Order facets properly around edge, without regard for bodies.","Displays all definstances names","{}","run a standard inquiry","Return the cached value","line to polygon calculation","Deallocates memory used by an srf_index_t structure.","Set brightness level","tries to repair a damaged mw block.","returns the current value of the centisecond clock,","Encode the Q.SIG CcnrRequest invoke facility ie arguments.","{}","returns the length of a polynomial","sets the notNull flag onthe column currently under construction."
"3TTPFEFXCTKDE1WXOVDT5S0T889H6C","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","30ZX6P7VF8VNAQ5FFV9CGBVLLK32JJ","A2M2K3PO5ALBE2","Approved","Wed Apr 17 15:59:56 PDT 2019","Wed Apr 17 16:07:15 PDT 2019","Fri Apr 19 16:07:15 PDT 2019","2019-04-19 23:07:21 UTC","","","439","100% (13/13)","100% (13/13)","100% (13/13)","4129349","cppcheckexecutor.cpp","static bool IsAddressOnStack(const void* ptr)\newline{\newline    if (nullptr==ptr)\newline        return false;\newline    char a;\newline    if (bStackBelowHeap)\newline        return ptr &lt &ampa;\newline    else\newline        return ptr &gt &ampa;\newline}\newline","\newline \\param[in] ptr address to be examined.\newline \\return true if address is supposed to be on stack (contrary to heap). If ptr is 0 false will be returned.\newline If unknown better return false.\newline \newline","5268680","reg.c","word_t peek_reg(const Tracee *tracee, RegVersion version, Reg reg)\newline{\newline	word_t result;\newline\newline	assert(version &lt NB_REG_VERSION);\newline\newline	result = REG(tracee, version, reg);\newline\newline	/* Use only the 32 least significant bits (LSB) when running\newline	 * 32-bit processes on a 64-bit kernel.  */\newline	if (is_32on64_mode(tracee))\newline		result &amp= 0xFFFFFFFF;\newline\newline	return result;\newline}\newline","\newline Return the cached value of the given @tracees&#039 @reg.\newline \newline","4996931","vid21394_base.c","unicap_status_t vid21394_set_brightness( vid21394handle_t vid21394handle, unsigned int brightness )\newline{\newline   unsigned long long fcp_write_i2c = WRITE_I2C_BYTE_MSG &lt&lt 24;	\newline   int bit = WRITE_I2C_BYTE_MSG - 0x10;\newline\newline   fcp_write_i2c |= I2C_SAA7112_ID;\newline   fcp_write_i2c |= I2C_BRIGHTNESS;\newline   fcp_write_i2c |= brightness &amp 0xff;\newline\newline   return( _vid21394_send_fcp_command( vid21394handle, fcp_write_i2c, bit, NULL ) );\newline}\newline","\newlineSet brightness level\newlineInput: vid21394handle\newlinebrightness\newlineReturns: STATUS_SUCCESS\newlineSTATUS_TIMEOUT\newlineSTATUS_NO_DEVICE\newlineSTATUS_FAILURE\newlineSTATUS_INVALID_PARAMETER: brightness level not in valid range\newline \newline","3068616","memwatch.c","static int mwRelink( mwData* mw, const char* file, int line ) {\newline    int fails;\newline    mwData *mw1, *mw2;\newline    long count, size;\newline    mwStat *ms;\newline\newline	if( file == NULL ) file = &quotunknown&quot;\newline\newline    if( mw == NULL ) {\newline        mwWrite(&quotrelink: cannot repair MW at NULL\\n&quot);\newline        FLUSH();\newline        goto emergency;\newline        }\newline\newline    if( !mwIsSafeAddr(mw, mwDataSize) ) {\newline        mwWrite(&quotrelink: MW-%p is a garbage pointer\\n&quot, mw);\newline        FLUSH();\newline        goto emergency;\newline        }\newline\newline    mwWrite(&quotrelink: &lt%ld&gt %s(%d) attempting to repair MW-%p...\\n&quot, mwCounter, file, line, mw );\newline    FLUSH();\newline    fails = 0;\newline\newline    /* Repair from head */\newline    if( mwHead != mw ) {\newline        if( !mwIsSafeAddr( mwHead, mwDataSize ) ) {\newline            mwWrite(&quotrelink: failed for MW-%p; head pointer destroyed\\n&quot, mw );\newline            FLUSH();\newline            goto emergency;\newline            }\newline        for( mw1=mwHead; mw1; mw1=mw1-&gtnext ) {\newline            if( mw1-&gtnext == mw ) {\newline                mw-&gtprev = mw1;\newline                break;\newline                }\newline            if( mw1-&gtnext &amp&amp\newline                ( !mwIsSafeAddr(mw1-&gtnext, mwDataSize ) || mw1-&gtnext-&gtprev != mw1) ) {\newline                mwWrite(&quotrelink: failed for MW-%p; forward chain fragmented at MW-%p: &#039next&#039 is %p\\n&quot, mw, mw1, mw1-&gtnext );\newline                FLUSH();\newline                goto emergency;\newline                }\newline            }\newline        if( mw1 == NULL ) {\newline            mwWrite(&quotrelink: MW-%p not found in forward chain search\\n&quot, mw );\newline            FLUSH();\newline            fails ++;\newline            }\newline        }\newline	else\newline	{\newline		mwWrite( &quotrelink: MW-%p is the head (first) allocation\\n&quot, mw );\newline		if( mw-&gtprev != NULL )\newline		{\newline			mwWrite( &quotrelink: MW-%p prev pointer is non-NULL, you have a wild pointer\\n&quot, mw );\newline			mw-&gtprev = NULL;\newline		}\newline	}\newline\newline    /* Repair from tail */\newline    if( mwTail != mw ) {\newline        if( !mwIsSafeAddr( mwTail, mwDataSize ) ) {\newline            mwWrite(&quotrelink: failed for MW-%p; tail pointer destroyed\\n&quot, mw );\newline            FLUSH();\newline            goto emergency;\newline            }\newline        for( mw1=mwTail; mw1; mw1=mw1-&gtprev ) {\newline            if( mw1-&gtprev == mw ) {\newline                mw-&gtnext = mw1;\newline                break;\newline                }\newline            if( mw1-&gtprev &amp&amp (!mwIsSafeAddr(mw1-&gtprev, mwDataSize ) || mw1-&gtprev-&gtnext != mw1) ) {\newline                mwWrite(&quotrelink: failed for MW-%p; reverse chain fragmented at MW-%p, &#039prev&#039 is %p\\n&quot, mw, mw1, mw1-&gtprev );\newline                FLUSH();\newline                goto emergency;\newline                }\newline            }\newline        if( mw1 == NULL ) {\newline            mwWrite(&quotrelink: MW-%p not found in reverse chain search\\n&quot, mw );\newline            FLUSH();\newline            fails ++;\newline            }\newline        }\newline	else\newline	{\newline		mwWrite( &quotrelink: MW-%p is the tail (last) allocation\\n&quot, mw );\newline		if( mw-&gtnext != NULL )\newline		{\newline			mwWrite( &quotrelink: MW-%p next pointer is non-NULL, you have a wild pointer\\n&quot, mw );\newline			mw-&gtnext = NULL;\newline		}\newline	}\newline\newline    if( fails &gt 1 ) {\newline        mwWrite(&quotrelink: heap appears intact, MW-%p probably garbage pointer\\n&quot, mw );\newline        FLUSH();\newline        goto verifyok;\newline        }\newline\newline    /* restore MW info where possible */\newline    if( mwIsReadAddr( mw-&gtfile, 1 ) ) {\newline        ms = mwStatGet( mw-&gtfile, -1, 0 );\newline        if( ms == NULL ) mw-&gtfile = &quot&ltrelinked&gt&quot;\newline        }\newline    mw-&gtcheck = CHKVAL(mw);\newline    goto verifyok;\newline\newline    /* Emergency repair */\newline    emergency:\newline\newline    if( mwHead == NULL &amp&amp mwTail == NULL )\newline    {\newline        if( mwStatCurAlloc == 0 )\newline            mwWrite(&quotrelink: &lt%ld&gt %s(%d) heap is empty, nothing to repair\\n&quot, mwCounter, file, line );\newline        else\newline            mwWrite(&quotrelink: &lt%ld&gt %s(%d) heap damaged beyond repair\\n&quot, mwCounter, file, line );\newline        FLUSH();\newline        return 0;\newline    }\newline\newline    mwWrite(&quotrelink: &lt%ld&gt %s(%d) attempting emergency repairs...\\n&quot, mwCounter, file, line );\newline    FLUSH();\newline\newline	if( mwHead == NULL || mwTail == NULL )\newline	{\newline		if( mwHead == NULL ) mwWrite(&quotrelink: mwHead is NULL, but mwTail is %p\\n&quot, mwTail );\newline		else mwWrite(&quotrelink: mwTail is NULL, but mwHead is %p\\n&quot, mwHead );\newline	}\newline\newline    mw1=NULL;\newline    if( mwHead != NULL )\newline	{\newline		if( !mwIsReadAddr( mwHead, mwDataSize ) || mwHead-&gtcheck != CHKVAL(mwHead) )\newline		{\newline			mwWrite(&quotrelink: mwHead (MW-%p) is damaged, skipping forward scan\\n&quot, mwHead );\newline			mwHead = NULL;\newline			goto scan_reverse;\newline		}\newline		if( mwHead-&gtprev != NULL )\newline		{\newline			mwWrite(&quotrelink: the mwHead pointer&#039s &#039prev&#039 member is %p, not NULL\\n&quot, mwHead-&gtprev );\newline		}\newline        for( mw1=mwHead; mw1; mw1=mw1-&gtnext )\newline		{\newline			if( mw1-&gtnext )\newline			{\newline				if( !mwIsReadAddr(mw1-&gtnext,mwDataSize) ||\newline					!mw1-&gtnext-&gtcheck != CHKVAL(mw1) ||\newline					mw1-&gtnext-&gtprev != mw1 )\newline				{\newline					mwWrite(&quotrelink: forward chain&#039s last intact MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline						mw1, mw1-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot, mw1-&gtfile, mw1-&gtline );\newline					if( mwIsReadAddr(mw1-&gtnext,mwDataSize ) )\newline					{\newline						mwWrite(&quotrelink: forward chain&#039s first damaged MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline							mw1-&gtnext, mw1-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot,\newline							mwIsReadAddr(mw1-&gtfile,16)?mw1-&gtfile:&quot&ltgarbage-pointer&gt&quot, mw1-&gtline );\newline					}\newline					else\newline					{\newline						mwWrite(&quotrelink: the &#039next&#039 pointer of this MW points to %p, which is out-of-legal-access\\n&quot,\newline							mw1-&gtnext );\newline					}\newline					break;\newline				}\newline			}\newline        }\newline	}\newline\newline\newlinescan_reverse:\newline    mw2=NULL;\newline    if( mwTail != NULL )\newline	{\newline		if( !mwIsReadAddr(mwTail,mwDataSize) || mwTail-&gtcheck != CHKVAL(mwTail) )\newline		{\newline			mwWrite(&quotrelink: mwTail (%p) is damaged, skipping reverse scan\\n&quot, mwTail );\newline			mwTail = NULL;\newline			goto analyze;\newline		}\newline		if( mwTail-&gtnext != NULL )\newline		{\newline			mwWrite(&quotrelink: the mwTail pointer&#039s &#039next&#039 member is %p, not NULL\\n&quot, mwTail-&gtnext );\newline		}\newline        for( mw2=mwTail; mw2; mw2=mw2-&gtprev )\newline		{\newline            if( mw2-&gtprev )\newline			{\newline				if( !mwIsReadAddr(mw2-&gtprev,mwDataSize) ||\newline					!mw2-&gtprev-&gtcheck != CHKVAL(mw2) ||\newline					mw2-&gtprev-&gtnext != mw2 )\newline				{\newline					mwWrite(&quotrelink: reverse chain&#039s last intact MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline						mw2, mw2-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot, mw2-&gtfile, mw2-&gtline );\newline					if( mwIsReadAddr(mw2-&gtprev,mwDataSize ) )\newline					{\newline						mwWrite(&quotrelink: reverse chain&#039s first damaged MW is MW-%p, %ld %sbytes at %s(%d)\\n&quot,\newline							mw2-&gtprev, mw2-&gtsize, (mw-&gtflag &amp MW_NML)?&quotNoMansLand &quot:&quot&quot,\newline							mwIsReadAddr(mw2-&gtfile,16)?mw2-&gtfile:&quot&ltgarbage-pointer&gt&quot, mw2-&gtline );\newline					}\newline					else\newline					{\newline						mwWrite(&quotrelink: the &#039prev&#039 pointer of this MW points to %p, which is out-of-legal-access\\n&quot,\newline							mw2-&gtprev );\newline					}\newline					break;\newline				}\newline			}\newline        }\newline	}\newline\newlineanalyze:\newline	if( mwHead == NULL &amp&amp mwTail == NULL )\newline	{\newline        mwWrite(&quotrelink: both head and tail pointers damaged, aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline	}\newline	if( mwHead == NULL )\newline	{\newline		mwHead = mw2;\newline		mwWrite(&quotrelink: heap truncated, MW-%p designated as new mwHead\\n&quot, mw2 );\newline		mw2-&gtprev = NULL;\newline		mw1 = mw2 = NULL;\newline	}\newline	if( mwTail == NULL )\newline	{\newline		mwTail = mw1;\newline		mwWrite(&quotrelink: heap truncated, MW-%p designated as new mwTail\\n&quot, mw1 );\newline		mw1-&gtnext = NULL;\newline		mw1 = mw2 = NULL;\newline	}\newline    if( mw1 == NULL &amp&amp mw2 == NULL &amp&amp\newline        mwHead-&gtprev == NULL &amp&amp mwTail-&gtnext == NULL ) {\newline        mwWrite(&quotrelink: verifying heap integrity...\\n&quot );\newline        FLUSH();\newline        goto verifyok;\newline        }\newline    if( mw1 &amp&amp mw2 &amp&amp mw1 != mw2 ) {\newline        mw1-&gtnext = mw2;\newline        mw2-&gtprev = mw1;\newline        mwWrite(&quotrelink: emergency repairs successful, assessing damage...\\n&quot);\newline        FLUSH();\newline        }\newline    else {\newline        mwWrite(&quotrelink: heap totally destroyed, aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline        }\newline\newline    /* Verify by checking that the number of active allocations */\newline    /* match the number of entries in the chain */\newlineverifyok:\newline    if( !mwIsHeapOK( NULL ) ) {\newline        mwWrite(&quotrelink: heap verification FAILS - aborting program\\n&quot);\newline        mwFlushW(1);\newline        FLUSH();\newline        abort();\newline        }\newline    for( size=count=0, mw1=mwHead; mw1; mw1=mw1-&gtnext ) {\newline        count ++;\newline        size += (long) mw1-&gtsize;\newline        }\newline    if( count == mwNumCurAlloc ) {\newline        mwWrite(&quotrelink: successful, &quot);\newline        if( size == mwStatCurAlloc ) {\newline            mwWrite(&quotno allocations lost\\n&quot);\newline            }\newline        else {\newline            if( mw != NULL ) {\newline                mwWrite(&quotsize information lost for MW-%p\\n&quot, mw);\newline                mw-&gtsize = 0;\newline                }\newline            }\newline        }\newline    else {\newline        mwWrite(&quotrelink: partial, %ld MW-blocks of %ld bytes lost\\n&quot,\newline			mwNmlNumAlloc+mwNumCurAlloc-count, mwNmlCurAlloc+mwStatCurAlloc-size );\newline        return 0;\newline        }\newline\newline    return 1;\newline    }\newline","\newline Relinking tries to repair a damaged mw block.\newline Returns nonzero if it thinks it successfully\newline repaired the heap chain.\newline \newline","5108307","emulate.c","int32 emulate_time(void) {\newline  return clock()-startime;\newline}\newline","\newline &#039emulate_time&#039 is called to deal with the Basic pseudo-variable\newline &#039TIME&#039 to return its current value. Under RISC OS, the C function\newline &#039clock&#039 returns the current value of the centisecond clock, which\newline is just what we want\newline \newline","5967937","rose_qsig_cc.c","unsigned char *rose_enc_qsig_CcnrRequest_ARG(struct pri *ctrl, unsigned char *pos,\newline	unsigned char *end, const union rose_msg_invoke_args *args)\newline{\newline	return rose_enc_qsig_CcRequestArg(ctrl, pos, end, ASN1_TAG_SEQUENCE,\newline		&ampargs-&gtqsig.CcnrRequest);\newline}\newline","!\newline \\brief Encode the Q.SIG CcnrRequest invoke facility ie arguments.\newline \newline \\param ctrl D channel controller for diagnostic messages or global options.\newline \\param pos Starting position to encode ASN.1 component.\newline \\param end End of ASN.1 encoding data buffer.\newline \\param args Arguments to encode in the buffer.\newline \newline \\retval Start of the next ASN.1 component to encode on success.\newline \\retval NULL on error.\newline \newline","6493740","sched.c","void sched_exec(void)\newline{\newline	struct task_struct *p = current;\newline	unsigned long flags;\newline	struct rq *rq;\newline	int dest_cpu;\newline\newline	rq = task_rq_lock(p, &ampflags);\newline	dest_cpu = p-&gtsched_class-&gtselect_task_rq(rq, p, SD_BALANCE_EXEC, 0);\newline	if (dest_cpu == smp_processor_id())\newline		goto unlock;\newline\newline	/*\newline	 * select_task_rq() can race against -&gtcpus_allowed\newline	 */\newline	if (cpumask_test_cpu(dest_cpu, &ampp-&gtcpus_allowed) &amp&amp\newline	    likely(cpu_active(dest_cpu)) &amp&amp migrate_task(p, dest_cpu)) {\newline		struct migration_arg arg = { p, dest_cpu };\newline\newline		task_rq_unlock(rq, &ampflags);\newline		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &amparg);\newline		return;\newline	}\newlineunlock:\newline	task_rq_unlock(rq, &ampflags);\newline}\newline","\newline sched_exec - execve() is a valuable balancing opportunity, because at\newline this point the task has the smallest effective memory and cache footprint.\newline \newline","2245088","p_polys.h","static inline unsigned pLength(poly a)\newline{\newline  unsigned l = 0;\newline  while (a!=NULL)\newline  {\newline    pIter(a);\newline    l++;\newline  }\newline  return l;\newline}\newline","2\newline returns the length of a polynomial (numbers of monomials)\newline \newline","243049","build.c","void sqliteAddNotNull(Parse *pParse, int onError){\newline  Table *p;\newline  int i;\newline  if( (p = pParse-&gtpNewTable)==0 ) return;\newline  i = p-&gtnCol-1;\newline  if( i&gt=0 ) p-&gtaCol[i].notNull = onError;\newline}\newline","\newline This routine is called by the parser while in the middle of\newline parsing a CREATE TABLE statement. A &quotNOT NULL&quot constraint has\newline been seen on a column. This routine sets the notNull flag on\newline the column currently under construction.\newline \newline","4047622","png.c","int rgba_to_gdkpixmap(GdkWindow *window, uint8 *data,int width, int height,\newline                      GdkPixmap **pix, GdkBitmap **mask, GdkColormap *colormap)\newline{\newline    GdkGC       *gc, *gc_alpha;\newline    int         has_alpha=0, alpha;\newline    GdkColor  scolor;\newline    int x,y;\newline\newline    *pix = gdk_pixmap_new(window, width, height, -1);\newline\newline    gc=gdk_gc_new(*pix);\newline    gdk_gc_set_function(gc, GDK_COPY);\newline\newline    *mask=gdk_pixmap_new(window, width, height,1);\newline    gc_alpha=gdk_gc_new(*mask);\newline\newline    scolor.pixel=1;\newline    gdk_gc_set_foreground(gc_alpha, &ampscolor);\newline    gdk_draw_rectangle(*mask, gc_alpha, 1, 0, 0, width, height);\newline\newline    scolor.pixel=0;\newline    gdk_gc_set_foreground(gc_alpha, &ampscolor);\newline\newline    /* we need to draw the alpha channel.  The image may not in fact\newline     * have alpha, but no way to know at this point other than to try\newline     * and draw it.\newline     */\newline    for (y=0; y&ltheight; y++) {\newline        for (x=0; x&ltwidth; x++) {\newline            alpha = data[(y * width + x) * 4 +3];\newline            /* Transparent bit */\newline            if (alpha==0) {\newline                gdk_draw_point(*mask, gc_alpha, x, y);\newline                has_alpha=1;\newline            }\newline        }\newline    }\newline\newline    gdk_draw_rgb_32_image(*pix, gc,  0, 0, width, height, GDK_RGB_DITHER_NONE, data, width*4);\newline    if (!has_alpha) {\newline        gdk_pixmap_unref(*mask);\newline        *mask = NULL;\newline    }\newline\newline    gdk_gc_destroy(gc_alpha);\newline    gdk_gc_destroy(gc);\newline    return 0;\newline}\newline","\newline Takes data that has already been converted into RGBA format (via png_to_data\newline above perhaps) and creates a GdkPixmap and GdkBitmap out of it.\newline \newline @param window\newline @param data\newline @param width\newline @param height\newline @param pix\newline @param mask\newline @param colormap\newline @return Non-zero on error (currently, no checks for error conditions is done\newline \newline","11768","instore.c","external_parser_type *TinTree(const tsd_t *TSD,\newline                              const internal_parser_type *ipt,\newline                              unsigned long *length)\newline{\newline   external_parser_type *retval;\newline   unsigned long srclines, nodecount, len;\newline\newline   *length = ComputeExternalSize(ipt, &ampsrclines, &ampnodecount);\newline\newline   retval = (external_parser_type *)IfcAllocateMemory(*length);\newline   if (retval == NULL)\newline      return(NULL);\newline   memset(retval, 0, sizeof(external_parser_type));\newline\newline   /* Build the envelope */\newline   len = sizeof(MagicHeader); /* includes a terminating 0 */\newline   if (len &gt sizeof(retval-&gtMagic))\newline      len = sizeof(retval-&gtMagic);\newline   memcpy(retval-&gtMagic, MagicHeader, len);\newline   len = sizeof(PARSE_VERSION_STRING);\newline   if (len &gt sizeof(retval-&gtReginaVersion))\newline      len = sizeof(retval-&gtReginaVersion);\newline   memcpy(retval-&gtReginaVersion, PARSE_VERSION_STRING, len);\newline\newline   retval-&gtarch_detector.s.one = 1;\newline   retval-&gtarch_detector.s.two = 2;\newline   retval-&gtarch_detector.s.ptr3 = (void *)3;\newline   retval-&gtarch_detector.s.ptr4 = (void *)4;\newline   retval-&gtOverallSize = (unsigned long) *length;\newline   retval-&gtNumberOfSourceLines = srclines;\newline   retval-&gtversion = INSTORE_VERSION;\newline   retval-&gtNumberOfTreeElements = nodecount;\newline\newline   retval-&gtsource = sizeof(external_parser_type);\newline   len = FillStrings((char *) retval,\newline                     sizeof(external_parser_type),\newline                     ipt-&gtsrclines);\newline\newline   retval-&gttree = len;\newline   retval-&gtTreeStart = ipt-&gtroot-&gtnodeindex;\newline   len = FillTree((treenode *) ((char *) retval + len),\newline                  (char *) retval,\newline                  len + nodecount*sizeof(treenode),\newline                  ipt-&gtnodes);\newline\newline   memcpy((char *) retval + len, retval-&gtMagic, sizeof(retval-&gtMagic));\newline\newline   assert((unsigned long) len + sizeof(retval-&gtMagic) == *length);\newline\newline   /* DEBUGGING: return NULL if you don&#039t want tinned trees */\newline   TSD = TSD; /* keep compiler happy */\newline   return(retval);\newline}\newline","TinTree &quottins&quot a tree into an external structure. The complete structure\newline is allocated by one call to IfcAllocateMemory. The returned value shall\newline be used as an instore macro for RexxStart.\newline length is set to the allocated size of the memory block on return.\newline ExpandedTinnedTree can expand the returned value and IsValidTin checks it.\newline \newline","4051121","previsat.cpp","void PreviSat::on_effacerHeuresIri_clicked()\newline{\newline    /* Declarations des variables locales */\newline\newline    /* Initialisations */\newline\newline    /* Corps de la methode */\newline    ui-&gtdateInitialeIri-&gtsetTime(QTime(0, 0, 0));\newline    ui-&gtdateFinaleIri-&gtsetTime(QTime(0, 0, 0));\newline\newline    /* Retour */\newline    return;\newline}\newline","\newline Calcul des flashs Iridium\newline \newline","3068951","nxstaxablock.cpp","bool NxsTaxaBlock::NeedsQuotes(\newline  unsigned i)	/* the taxon label number in question */\newline	{\newline	const NxsString x(GetTaxonLabel(i).c_str());\newline	return x.QuotesNeeded();\newline	}\newline","!\newline Returns true if taxonLabels[i] contains embedded spaces and thus should be surrounded by single quotes if output is\newline NEXUS format.\newline \newline","3672140","dsensor.c","void ds_shutdown(void) {\newline\newline  AD_CSR=0x00;\newline  PORT6        &amp=DS_ALL_PASSIVE;\newline  rom_port6_ddr&amp=DS_ALL_PASSIVE;\newline  PORT6_DDR     =rom_port6_ddr;\newline}\newline","! all sensors set to passive mode\newline \newline","4630930","fix_imd.cpp","void FixIMD::ioworker()\newline{\newline  while (1) {\newline    pthread_mutex_lock(&ampwrite_mutex);\newline    if (buf_has_data &lt 0) {\newline      /* master told us to go away */\newline      fprintf(screen,&quotAsynchronous I/O thread is exiting.\\n&quot);\newline      buf_has_data=0;\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline      pthread_exit(NULL);\newline    } else if (buf_has_data &gt 0) {\newline      /* send coordinate data, if client is able to accept */\newline      if (clientsock &amp&amp imdsock_selwrite(clientsock,0)) {\newline        imd_writen(clientsock, msgdata, msglen);\newline      }\newline      delete[] msgdata;\newline      buf_has_data=0;\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline    } else {\newline      /* nothing to write out yet. wait on condition. */\newline      pthread_cond_wait(&ampwrite_cond, &ampwrite_mutex);\newline      pthread_mutex_unlock(&ampwrite_mutex);\newline    }\newline  }\newline}\newline","the real i/o worker thread \newline","340908","lexinit2.c","void raw_fe_reorder(edge_id e_id)\newline{ int fcount = 0;\newline  facetedge_id fe;\newline  struct fsort fe_list[FSORTMAX];\newline  REAL side[MAXCOORD],norm_a[MAXCOORD],side_a[MAXCOORD];\newline  REAL side_b[MAXCOORD],norm_aa[MAXCOORD],a_norm,aa_norm;\newline  REAL c,s,angle;\newline  int i,j,k;\newline  facetedge_id first_fe;\newline\newline  memset(norm_a,0,sizeof(norm_a));\newline  memset(norm_aa,0,sizeof(norm_aa));\newline\newline  /* see if we have 3 or more facets */\newline  fe = first_fe = get_edge_fe(e_id);\newline  if ( valid_id(fe) ) \newline  do { fcount++; \newline       fe = get_next_facet(fe);\newline     } while ( valid_id(fe) &amp&amp !equal_id(fe,first_fe) );\newline  if ( fcount &lt= 2 ) return;\newline\newline  if ( fcount &gt FSORTMAX )\newline  { kb_error(5742,&quotMore than 100 facets on an edge; not sorted.\\n&quot,WARNING); \newline    return;\newline  }\newline\newline  /* use first facet as reference facet */\newline  /* to get basis for calculating angles */\newline  get_edge_side(e_id,side);     \newline  fe = get_edge_fe(e_id);\newline  fe_list[0].fe = fe;\newline  get_fe_side(get_next_edge(fe),side_a);\newline  cross_prod(side,side_a,norm_a);\newline  cross_prod(norm_a,side,norm_aa);\newline  a_norm = sqrt(SDIM_dot(norm_a,norm_a));\newline  aa_norm = sqrt(SDIM_dot(norm_aa,norm_aa));\newline\newline  /* now get angles to rest of facets */\newline  fe_list[0].angle = 0.0;\newline  for ( i = 1 ; i &lt fcount ; i++ )\newline  { fe = get_next_facet(fe);\newline    fe_list[i].fe = fe;\newline    get_fe_side(get_next_edge(fe),side_b);\newline    s = SDIM_dot(side_b,norm_a)*aa_norm;\newline    c = SDIM_dot(side_b,norm_aa)*a_norm;\newline    angle = atan2(s,c);\newline    fe_list[i].angle = angle;\newline  }\newline\newline  /* sort by angle */\newline  for ( j = 0 ; j &lt fcount-1 ; j++ )\newline    for ( k = j+1 ; k &lt fcount ; k++ )\newline       if ( fe_list[k].angle &lt fe_list[j].angle )\newline       { struct fsort ftemp;\newline         ftemp = fe_list[k];\newline         fe_list[k] = fe_list[j];\newline         fe_list[j] = ftemp;\newline       } \newline\newline  /* relink in proper order */\newline  for ( i = 0 ; i &lt fcount ; i++ )\newline  { set_next_facet(fe_list[i].fe,fe_list[(i+1)%fcount].fe);\newline    set_prev_facet(fe_list[i].fe,fe_list[(i+fcount-1)%fcount].fe);\newline  }\newline} // end raw_fe_reorder()\newline","\newline \newline Function: raw_fe_reorder()\newline \newline Purpose: Order facets properly around edge, without regard for bodies.\newline For use by merge_edge().\newline Note: for higher dimension ambient space, just uses \newline first three dimensions.\newline \newline","6007880","defins.c","globle void ListDefinstancesCommand(\newline  void *theEnv)\newline  {\newline   ListConstructCommand(theEnv,&quotlist-definstances&quot,DefinstancesData(theEnv)-&gtDefinstancesConstruct);\newline  }\newline","\newlineNAME : ListDefinstancesCommand\newlineDESCRIPTION : Displays all definstances names\newlineINPUTS : None\newlineRETURNS : Nothing useful\newlineSIDE EFFECTS : Definstances name sprinted\newlineNOTES : H/L Interface\newline \newline","1576513","format_dpdk.c","static int dpdk_config_input (libtrace_t *libtrace,\newline                                        trace_option_t option,\newline                                        void *data) {\newline    switch (option) {\newline        case TRACE_OPTION_SNAPLEN:\newline            /* Only support changing snaplen before a call to start is \newline             * made */\newline            if (FORMAT(libtrace)-&gtpaused == DPDK_NEVER_STARTED)\newline                FORMAT(libtrace)-&gtsnaplen=*(int*)data;\newline            else\newline                return -1;\newline            return 0;\newline		case TRACE_OPTION_PROMISC:\newline			FORMAT(libtrace)-&gtpromisc=*(int*)data;\newline            return 0;\newline        case TRACE_OPTION_FILTER:\newline            /* TODO filtering */\newline            break;\newline        case TRACE_OPTION_META_FREQ:\newline            break;\newline        case TRACE_OPTION_EVENT_REALTIME:\newline            break;\newline        /* Avoid default: so that future options will cause a warning\newline         * here to remind us to implement it, or flag it as\newline         * unimplementable\newline         */\newline    }\newline\newline	/* Don&#039t set an error - trace_config will try to deal with the\newline	 * option and will set an error if it fails */\newline    return -1;\newline}\newline","\newline Note here snaplen excludes the MAC checksum. Packets over\newline the requested snaplen will be dropped. (Excluding MAC checksum)\newline \newline I.e the maximum size of a standard ethernet packet is 1518 (Including MAC checksum)\newline So to allow packets upto 1518 this would be set to 1514 and if GET_MAC_CRC_CHECKSUM\newline is set the maximum size of the returned packet would be 1518 otherwise\newline 1514 would be the largest size possibly returned.\newline \newline \newline","2662755","scan.c","int scan_inquiry (hcicfg_t *hci)\newline{\newline	int num_rsp, length, flags, dd, i, cc, rv;\newline	inquiry_info *info = NULL;\newline	device_t *dev;\newline	char buf[BUFN_SZ], tmp[32];\newline	uint16_t handle;\newline	struct search_context context;\newline	rangedef_t *range;\newline	uint8_t do_store, uval;\newline	int8_t val;\newline\newline\newline	length = 8; /* ~10 seconds */\newline	flags = IREQ_CACHE_FLUSH; /* flush each time */\newline	num_rsp = 10; /* max devices to scan for, FIXME */\newline	cc = 0;\newline	do_store = 0;\newline\newline	/* scan */\newline	num_rsp = hci_inquiry(hci-&gtid, length, num_rsp, NULL, &ampinfo, flags);\newline	if (num_rsp &lt 0)\newline		return -1;\newline\newline	/* open the bluetooth device to enquiries */\newline	dd = hci_open_dev(hci-&gtid);\newline	if (dd &lt 0)\newline		return -1;\newline\newline	/* now we have a list of devices, get thier info and enum */\newline	for (i = 0; i &lt num_rsp &amp&amp bts_run_scan; i++, cc=0) {\newline		/* get the rangedef for this particular device */\newline		range = cfg_get_range(bd2int(&amp(info+i)-&gtbdaddr));\newline		if (!range) continue;\newline\newline		ba2str(&amp(info+i)-&gtbdaddr, tmp);\newline		screen_log(&quotFound device %s&quot, tmp);\newline\newline		dev = ll_lock_device(&amp(info+i)-&gtbdaddr);\newline		if (!dev) continue; /* malloc failed or locked */\newline\newline		/* the clock offset + class */\newline		ll_lock_list();\newline		dev-&gtclk_off = (info+i)-&gtclock_offset;\newline		if (!dev-&gtgot_class) {\newline			dev-&gtclass = (info+i)-&gtdev_class[2] &lt&lt 16;\newline			dev-&gtclass |= (info+i)-&gtdev_class[1] &lt&lt 8;\newline			dev-&gtclass |= (info+i)-&gtdev_class[0];\newline			dev-&gtgot_class = 1;\newline			do_store = 1;\newline		}\newline\newline		/* state of play */\newline		dev-&gtupdated = 1;\newline		time(&amp(dev-&gtlast_scanned));\newline		bacpy(&amp(dev-&gtbd_scan), &amp(hci-&gtbdaddr));\newline		dev-&gtscan_count++;\newline		ll_unlock_list();\newline\newline\newline		/* the name */\newline		if ((range-&gtsf &amp SF_NAME) &amp&amp !ll_check_got_name(dev)) {\newline			if (hci_read_remote_name(dd, &amp(info+i)-&gtbdaddr,\newline			  BUFN_SZ*sizeof(char), buf, 100000) == 0) {\newline				ll_lock_list();\newline				ll_copy_name(dev, buf);\newline				dev-&gtgot_name = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		/* the oui */\newline		if (!ll_check_got_oui(dev)) {\newline			ll_lock_list();\newline			dev-&gtoui = ouidb_query(&ampdev-&gtbdaddr);\newline			dev-&gtgot_oui = 1;\newline			ll_unlock_list();\newline		}\newline\newline		/* do we need to do any of this */\newline		if (0 == (range-&gtsf &amp ~(SF_HCI|SF_RSSI|SF_LQ|SF_TXPWR|SF_SDP)))\newline			goto scan_inquiry_nextdev;\newline			\newline\newline		/* get a connection */\newline		handle = find_conn(hci-&gtid, &ampdev-&gtbdaddr);\newline		if ((uint16_t)-1 == handle) {\newline			if (0 != errno) break;\newline\newline			cc=1;\newline			if (hci_create_connection(dd, &ampdev-&gtbdaddr, HCI_DM1 | HCI_DH1,\newline			  0, 0, &amphandle, 25000) &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_create_connection(): Cant create: %s&quot,\newline				  __FUNCTION__, strerror(errno));\newline				goto scan_inquiry_nextdev;\newline			}\newline\newline		}\newline\newline		/* the hci info */\newline		if ((range-&gtsf &amp SF_HCI) &amp&amp !ll_check_got_version(dev)) {\newline			if (hci_read_remote_version(dd,handle, &ampdev-&gtversion,20000) == 0) {\newline				ll_lock_list();\newline				dev-&gtgot_version = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		if ((range-&gtsf &amp SF_HCI) &amp&amp !ll_check_got_features(dev)) {\newline			if (hci_read_remote_features(dd,handle,dev-&gtfeatures,20000) == 0) {\newline				ll_lock_list();\newline				dev-&gtgot_features = 1;\newline				do_store = 1;\newline				ll_unlock_list();\newline			}\newline		}\newline\newline		/* read the RSSI/LQ/TXPWR */\newline		/* RSSI */\newline		if (range-&gtsf &amp SF_RSSI) {\newline			rv = hci_read_rssi(dd, handle, &ampval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): rssi read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gtrssi_status = rv;\newline			dev-&gtrssi = val;\newline			ll_unlock_list();\newline		}\newline\newline		/* LQ */\newline		if (range-&gtsf &amp SF_LQ) {\newline			rv = hci_read_link_quality(dd, handle, &ampuval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): lq read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gtlq_status = rv; \newline			dev-&gtlq = uval;\newline			ll_unlock_list();\newline		}\newline\newline		/* TXPWR */\newline		if (range-&gtsf &amp SF_TXPWR) {\newline			rv = hci_read_transmit_power_level(dd, handle, 0, &ampval, 100);\newline			if (rv &lt 0) {\newline				applog(LOG_WARNING,\newline				  &quot%s::hci_send_req(): tpl read failed: &quot,\newline				  __FUNCTION__, strerror(errno));\newline			}\newline\newline			ll_lock_list();\newline			dev-&gttxpwr_status = rv;\newline			dev-&gttxpwr_type = 0;\newline			dev-&gttxpwr_level = val;\newline			ll_unlock_list();\newline		}\newline\newline\newline		/* read the SDP info */\newline		if ((range-&gtsf &amp SF_SDP) &amp&amp !ll_check_got_sdp(dev)) {\newline			cbuf_t sdpstr;\newline			memset(&ampsdpstr, 0, sizeof(cbuf_t));\newline			memset(&ampcontext, 0, sizeof(struct search_context));\newline			sdp_uuid16_create(&amp(context.group), PUBLIC_BROWSE_GROUP);\newline			scan_sdp(hci, dev, &ampsdpstr, &ampcontext);\newline\newline			ll_lock_list();\newline			if(sdpstr.buf) sdpstr.buf[sdpstr.len] = 0;\newline			dev-&gtsdp = sdpstr.buf;\newline			do_store = 1;\newline			ll_unlock_list();\newline		}\newline\newline		/* all done */\newline		scan_inquiry_nextdev:\newline\newline		/* store a timestamp */\newline		store_timestamp(dev);\newline		/* store the device if needed */\newline		if (do_store) {\newline			store_device(dev);\newline			do_store = 0;\newline		}\newline		/* unlock */\newline		ll_unlock_device(dev);\newline\newline		/* disconnect */\newline		if (cc)\newline			hci_disconnect(dd, handle, HCI_OE_USER_ENDED_CONNECTION, 10000);\newline\newline	}\newline\newline	/* tidy up */\newline	hci_close_dev(dd);\newline	free(info);\newline	info = NULL;\newline\newline	return 0;\newline}\newline","scan_inquiry: run a standard inquiry \newline","2788886","measures3d.c","int lw_dist3d_line_poly(LWLINE *line, LWPOLY *poly, DISTPTS3D *dl)\newline{\newline	PLANE3D plane;	\newline	LWDEBUG(2, &quotlw_dist3d_line_poly is called&quot);	\newline		\newline	if (dl-&gtmode == DIST_MAX)\newline	{\newline		return lw_dist3d_ptarray_ptarray(line-&gtpoints, poly-&gtrings[0], dl);\newline	}\newline	\newline	if(!define_plane(poly-&gtrings[0], &ampplane))\newline		return LW_FALSE;\newline	\newline	return lw_dist3d_ptarray_poly(line-&gtpoints, poly,&ampplane, dl);\newline}\newline","\newlineline to polygon calculation\newline \newline","146911","srf.c","void srf_index_destroy(srf_index_t *idx) {\newline    size_t i;\newline\newline    if (!idx)\newline	return;\newline\newline    if (idx-&gtdb_hash)\newline	HashTableDestroy(idx-&gtdb_hash, 0);\newline    if (idx-&gtch_pos)\newline	ArrayDestroy(idx-&gtch_pos);\newline    if (idx-&gtth_pos)\newline	ArrayDestroy(idx-&gtth_pos);\newline    if (idx-&gtname_blocks) {\newline        for (i = 0; i &lt ArrayMax(idx-&gtname_blocks); i++) {\newline	    if (NULL != arr(srf_name_block_t, idx-&gtname_blocks, i).names)\newline	        free(arr(srf_name_block_t, idx-&gtname_blocks, i).names);\newline        }\newline	ArrayDestroy(idx-&gtname_blocks);\newline    }\newline\newline    free(idx);\newline}\newline","\newline Deallocates memory used by an srf_index_t structure.\newline \newline","","","","on","","","on","","","on","","","","","","","","","on","","","","on","","","","","","","","","","","","","","","","","","","","address to be examined.","creates a GdkPixmap and GdkBitmap","""tins"" a tree into an external structure.","{}","surrounded by single quotes","all sensors set to passive mode","{}","Order facets properly around edge, without regard for bodies.","Displays all definstances names","{}","run a standard inquiry","Return the cached value of the given @tracees'","polygon calculation","Deallocates memory used by an srf_index_t structure.","Set brightness level","repaired the heap chain.","returns the current value of the centisecond clock,","Encode the Q.SIG CcnrRequest invoke facility ie arguments.","{}","returns the length of a polynomial","sets the notNull flag onthe column currently under construction."
"3VEI3XUCZRXYD1S5ZWOWPWTGQMXRPP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3H0W84IWBK2W3U08GKDMK3Q1S3FERF","A2MX5YW3DSQ61W","Approved","Wed Apr 17 15:26:35 PDT 2019","Wed Apr 17 15:30:58 PDT 2019","Fri Apr 19 15:30:58 PDT 2019","2019-04-19 22:31:21 UTC","","","263","100% (5/5)","100% (5/5)","100% (5/5)","5584104","php_amule_lib.cpp","void php_get_log(PHP_VALUE_NODE *result)\newline{\newline	value_value_free(result);\newline\newline	PHP_SCOPE_ITEM *si = get_scope_item(g_current_scope, &quot__param_0&quot);\newline	bool rst;\newline	if ( !si ) {\newline		rst = false;\newline	} else {\newline		cast_value_dnum(&ampsi-&gtvar-&gtvalue);\newline		rst = si-&gtvar-&gtvalue.int_val != 0;\newline	}\newline	if ( rst ) {\newline		CECPacket req(EC_OP_RESET_LOG);\newline		CPhPLibContext::g_curr_context-&gtWebServer()-&gtSend_Discard_V2_Request(&ampreq);\newline	}\newline	CECPacket req(EC_OP_GET_LOG);\newline	const CECPacket *response = CPhPLibContext::g_curr_context-&gtWebServer()-&gtwebInterface-&gtSendRecvMsg_v2(&ampreq);\newline	if (response) {\newline		wxString serverInfoString(_SpecialChars(response-&gtGetFirstTagSafe()-&gtGetStringData()));\newline		delete response;\newline		result-&gttype = PHP_VAL_STRING;\newline		result-&gtstr_val = strdup((const char *)unicode2UTF8(serverInfoString));\newline	}\newline}\newline","\newline Request contents of log\newline \newline","3515879","musyx.c","static uint32_t voice_stage(struct hle_t* hle, musyx_t *musyx,\newline                            uint32_t voice_ptr, uint32_t last_sample_ptr)\newline{\newline    uint32_t output_ptr;\newline    int i = 0;\newline\newline    /* voice stage can be skipped if first voice has no samples */\newline    if (*dram_u16(hle, voice_ptr + VOICE_CATSRC_0 + CATSRC_SIZE1) == 0) {\newline        HleVerboseMessage(hle-&gtuser_defined, &quotSkipping Voice stage&quot);\newline        output_ptr = *dram_u32(hle, voice_ptr + VOICE_INTERLEAVED_PTR);\newline    } else {\newline        /* otherwise process voices until a non null output_ptr is encountered */\newline        for (;;) {\newline            /* load voice samples (PCM16 or APDCM) */\newline            int16_t samples[SAMPLE_BUFFER_SIZE];\newline            unsigned segbase;\newline            unsigned offset;\newline\newline            HleVerboseMessage(hle-&gtuser_defined, &quotProcessing Voice #%d&quot, i);\newline\newline            if (*dram_u8(hle, voice_ptr + VOICE_ADPCM_FRAMES) == 0)\newline                load_samples_PCM16(hle, voice_ptr, samples, &ampsegbase, &ampoffset);\newline            else\newline                load_samples_ADPCM(hle, voice_ptr, samples, &ampsegbase, &ampoffset);\newline\newline            /* mix them with each internal subframes */\newline            mix_voice_samples(hle, musyx, voice_ptr, samples, segbase, offset,\newline                              last_sample_ptr + i * 8);\newline\newline            /* check break condition */\newline            output_ptr = *dram_u32(hle, voice_ptr + VOICE_INTERLEAVED_PTR);\newline            if (output_ptr != 0)\newline                break;\newline\newline            /* next voice */\newline            ++i;\newline            voice_ptr += VOICE_SIZE;\newline        }\newline    }\newline\newline    return output_ptr;\newline}\newline","Process voices, and returns interleaved subframe destination address \newline","1480391","configdialog.cpp","int ConfigDialog::getPwdTemplateSelector() {\newline  return ui-&gtpasswordCharTemplateSelector-&gtcurrentIndex();\newline}\newline","\newline @brief ConfigDialog::getPwdTemplateSelector returns the selection of the\newline password characters template combobox\newline @return\newline \newline","5964507","ssi.c","faim_export int aim_ssi_editcomment(aim_session_t *sess, const char *gn, const char *sn, const char *comment)\newline{\newline	struct aim_ssi_item *tmp;\newline\newline	if (!sess || !gn || !sn)\newline		return -EINVAL;\newline\newline	if (!(tmp = aim_ssi_itemlist_finditem(sess-&gtssi.local, gn, sn, AIM_SSI_TYPE_BUDDY)))\newline		return -EINVAL;\newline\newline	/* Either add or remove the 0x0131 TLV from the TLV chain */\newline	if ((comment != NULL) &amp&amp (strlen(comment) &gt 0))\newline		aim_tlvlist_replace_raw(&amptmp-&gtdata, 0x013c, strlen(comment), comment);\newline	else\newline		aim_tlvlist_remove(&amptmp-&gtdata, 0x013c);\newline\newline	/* Sync our local list with the server list */\newline	aim_ssi_sync(sess);\newline\newline	return 0;\newline}\newline","\newline Change the comment stored on the server for a given buddy.\newline \newline @param sess The oscar session.\newline @param gn The group that the buddy is currently in.\newline @param sn The screen name of the buddy.\newline @param alias The new comment for the buddy, or NULL if you want to remove \newline a buddy&#039s comment.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","4459999","ocb_decrypt_verify_memory.c","int ocb_decrypt_verify_memory(int cipher,\newline    const unsigned char *key,    unsigned long keylen,\newline    const unsigned char *nonce,  \newline    const unsigned char *ct,     unsigned long ctlen,\newline          unsigned char *pt,\newline    const unsigned char *tag,    unsigned long taglen,\newline          int           *stat)\newline{\newline   int err;\newline   ocb_state *ocb;\newline\newline   LTC_ARGCHK(key    != NULL);\newline   LTC_ARGCHK(nonce  != NULL);\newline   LTC_ARGCHK(pt     != NULL);\newline   LTC_ARGCHK(ct     != NULL);\newline   LTC_ARGCHK(tag    != NULL);\newline   LTC_ARGCHK(stat    != NULL);\newline\newline   /* allocate memory */\newline   ocb = XMALLOC(sizeof(ocb_state));\newline   if (ocb == NULL) {\newline      return CRYPT_MEM;\newline   }\newline\newline   if ((err = ocb_init(ocb, cipher, key, keylen, nonce)) != CRYPT_OK) {\newline      goto LBL_ERR; \newline   }\newline\newline   while (ctlen &gt (unsigned long)ocb-&gtblock_len) {\newline        if ((err = ocb_decrypt(ocb, ct, pt)) != CRYPT_OK) {\newline            goto LBL_ERR; \newline        }\newline        ctlen   -= ocb-&gtblock_len;\newline        pt      += ocb-&gtblock_len;\newline        ct      += ocb-&gtblock_len;\newline   }\newline\newline   err = ocb_done_decrypt(ocb, ct, ctlen, pt, tag, taglen, stat);\newlineLBL_ERR:\newline#ifdef LTC_CLEAN_STACK\newline   zeromem(ocb, sizeof(ocb_state));\newline#endif\newline \newline   XFREE(ocb);\newline\newline   return err;\newline}\newline","\newlineDecrypt and compare the tag with OCB.\newline@param cipher The index of the cipher desired\newline@param key The secret key\newline@param keylen The length of the secret key (octets)\newline@param nonce The session nonce (length of the block size of the block cipher)\newline@param ct The ciphertext\newline@param ctlen The length of the ciphertext (octets)\newline@param pt [out] The plaintext\newline@param tag The tag to compare against\newline@param taglen The length of the tag (octets)\newline@param stat [out] The result of the tag comparison (1==valid, 0==invalid)\newline@return CRYPT_OK if successful regardless of the tag comparison\newline \newline","5623426","katedocument.cpp","bool KateDocument::removeStartStopCommentFromSingleLine( int line, int attrib )\newline{\newline  QString shortStartCommentMark = highlight()-&gtgetCommentStart( attrib );\newline  QString longStartCommentMark = shortStartCommentMark + &#039 &#039;\newline  QString shortStopCommentMark = highlight()-&gtgetCommentEnd( attrib );\newline  QString longStopCommentMark = &#039 &#039 + shortStopCommentMark;\newline\newline  editStart();\newline\newline  // TODO &quotthat&#039s a bad idea, can lead to stray endings, FIXME&quot\newline\newline  // Try to remove the long start comment mark first\newline  bool removedStart = (removeStringFromBeginning(line, longStartCommentMark)\newline                    || removeStringFromBeginning(line, shortStartCommentMark));\newline\newline  bool removedStop = false;\newline  if (removedStart)\newline  {\newline    // Try to remove the long stop comment mark first\newline    removedStop = (removeStringFromEnd(line, longStopCommentMark)\newline                || removeStringFromEnd(line, shortStopCommentMark));\newline  }\newline\newline  editEnd();\newline\newline  return (removedStart || removedStop);\newline}\newline","\newlineRemove from the current line a start comment mark at\newlinethe beginning and a stop comment mark at the end.\newline \newline","5078934","screen.cpp","int screen_readkey()\newline{\newline    int c = getch();\newline    if (c == ERR) {\newline        return -1;\newline    }\newline    return c;\newline}\newline","ERR is actually -1, but this prevents us from needing to use curses.h in\newline sipp.cpp. \newline","5980594","is_canonic_name.c","boolean_t is_canonic_name(mval *src, int *subscripts, int *start_off, int *stop_off)\newline{	/* subscripts is overloaded - out to op_fnqlength, which doesn&#039t use the last 2 arguments &amp in from op_fnqsubscript */\newline	char		term;\newline	int		envpart;\newline	boolean_t	instring;\newline	int		isrc;\newline	boolean_t	keep_quotes;\newline	char		letter;\newline	int		point;\newline	char		previous;\newline	int		seq;\newline	int		start;\newline	int		state;\newline	int		stop;\newline	int		subs_count;\newline	int		utf8_len;\newline\newline	/* state:\newline	 *    0      before start of name\newline	 *    1      found ^ allow environment\newline	 *    2      dispatch for starting a component\newline	 *    3      in string\newline	 *    4      in number\newline	 *    5      expect first letter of name\newline	 *    6      expect next letter of name\newline	 *    7      in $CHAR()\newline	 *    8      at end of processing\newline	 */\newline\newline	MV_FORCE_STR(src);\newline	seq = *subscripts;\newline	keep_quotes = FALSE;\newline	start = stop = 0;\newline	state = 0;\newline	subs_count = -1;\newline	for (isrc = 0; isrc &lt src-&gtstr.len; )\newline	{\newline		letter = src-&gtstr.addr[isrc];\newline		switch (state)\newline		{\newline			case 0:		/* start of name */\newline				if (&#039^&#039 == letter)	/* before start of name */\newline				{\newline					state = 1;	/* check for environment */\newline					break;\newline				}\newline				if ((&#039%&#039 == letter) || ISALPHA_ASCII(letter))\newline				{\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				return FALSE;\newline			case 1:		/* global name */\newline				if ((&#039%&#039 == letter) ||ISALPHA_ASCII(letter))	/* found ^ allow environment */\newline				{	/* found ^ allow environment */\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				if ((&#039|&#039 == letter) || (&#039[&#039 == letter))\newline				{\newline					term = (letter == &#039[&#039) ? &#039]&#039 : letter;\newline					envpart = 0;\newline					if (subs_count == seq)\newline						start = isrc + 1;\newline					state = 2;	/* process environment */\newline					break;\newline				}\newline				return FALSE;\newline			case 2:		 /* dispatch for starting a component */\newline				point = 0;\newline				instring = FALSE;\newline				if (envpart &gt 1)\newline					return FALSE;	/* too many environment components */\newline				if (&#039)&#039 == term)\newline					subs_count++;	/* new subscript */\newline				else\newline					envpart++;	/* next environment component */\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					start = isrc;\newline				if (&#039&quot&#039 == letter)\newline				{\newline					if ((subs_count == seq) &amp&amp (1 == envpart))\newline						start++;\newline					instring = TRUE;\newline					state = 3;	/* string */\newline					break;\newline				}\newline				if (&#039$&#039 ==letter)\newline				{\newline					state = 7;	/* $[z]char() */\newline					break;\newline				}\newline				if (&#0390&#039 == letter) /* Canonic number cannot start with 0 unless is single char */\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;	/* Cannot end with &quot0&quot */\newline					if (term == letter)\newline						state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline					else if (&#039,&#039 != letter)\newline						return FALSE;	/* Not a single char number */\newline					if ((subs_count == seq) &amp&amp (0 == stop))\newline						stop = isrc;\newline					break;\newline				}\newline				if ((&#039-&#039 == letter) || (&#039.&#039 == letter) || ISDIGIT_ASCII(letter))\newline				{\newline					if (&#039.&#039 == letter)\newline						point++;\newline					previous = letter;\newline					state = 4;	/* numeric */\newline					break;\newline				}\newline				return FALSE;\newline			case 3:		/* [quoted] string */\newline				if (&#039&quot&#039 == letter)	/* in string */\newline				{\newline					instring = !instring;\newline					if (instring)\newline						break;\newline					if (isrc + 1 &gt= src-&gtstr.len)\newline						return FALSE;\newline					if (&#039_&#039 != src-&gtstr.addr[isrc + 1])\newline						break;\newline					isrc++;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039$&#039 != letter)\newline						return FALSE;\newline					state = 7;	/* $[z]char() */\newline					break;\newline				}\newline				if (!instring)\newline				{\newline					if (&#039,&#039 == letter)\newline						state = 2;	/* on to next */\newline					else if (term == letter)\newline						state = (&#039)&#039 == term) ? 8 : 5;	/* end or name */\newline					else\newline						return FALSE;\newline					if ((subs_count == seq) &amp&amp (0 == stop))\newline						/* Not returning 2nd env part - maybe problem */\newline						stop = isrc - (keep_quotes ? 0 : 1);\newline				}\newline				break;\newline			case 4:		/* numeric */\newline				if (ISDIGIT_ASCII(letter))	/* in number */\newline				{\newline					if ((&#039-&#039 == previous) &amp&amp (&#0390&#039 == letter))\newline						return FALSE;\newline					previous = letter;\newline					break;\newline				}\newline				if (&#039.&#039 == letter)\newline				{\newline					if ((++point &gt 1))\newline						return FALSE;\newline					previous = letter;\newline					break;\newline				}\newline				if (point &amp&amp (&#0390&#039 == previous))\newline					return FALSE;\newline				if (&#039,&#039 == letter)\newline					state = 2;	/* next */\newline				else if (term == letter)\newline					state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline				else\newline					return FALSE;\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					stop = isrc;\newline				previous = letter;\newline				break;\newline			case 5:		/* expect first letter of name */\newline				if ((&#039%&#039 == letter) || ISALPHA_ASCII(letter))\newline				{\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				return FALSE;\newline			case 6:		/* expect next letter of name */\newline				if (&#039(&#039 == letter)\newline				{\newline					term = &#039)&#039;\newline					envpart = 1;\newline					subs_count = 0;\newline					state = 2;	/* done with name */\newline					if (0 == seq)\newline						stop = isrc;\newline				} else if (!ISALNUM_ASCII(letter))\newline					return FALSE;\newline				break;\newline			case 7:		/* $[Z]CHAR() */\newline				previous = letter;	/* in $CHAR() - must be ASCII */\newline				if ((&#039Z&#039 == letter) || (&#039z&#039 == letter))\newline				{	if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039z&#039 == previous)\newline						previous = &#039Z&#039;\newline				}\newline				if (!((&#039C&#039 == letter) || (&#039c&#039 == letter)))\newline					return FALSE;\newline				if (++isrc &lt src-&gtstr.len)\newline					letter = src-&gtstr.addr[isrc];\newline				else\newline					return FALSE;\newline				if ((&#039H&#039 == letter) || (&#039h&#039 == letter))\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (!((&#039A&#039 == letter) || (&#039a&#039 == letter) || ((&#039(&#039 == letter) &amp&amp (&#039Z&#039 == previous))))\newline						return FALSE;\newline				} else if (&#039Z&#039 == previous)\newline					return FALSE;\newline				if (&#039(&#039 != letter)\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (!(&#039R&#039 == letter) || (&#039r&#039 == letter))\newline						return FALSE;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline				}\newline				if (&#039(&#039 != letter)\newline					return FALSE;\newline				if (subs_count == seq)\newline					keep_quotes = TRUE;\newline				for (++isrc ;isrc &lt src-&gtstr.len; isrc++)\newline				{\newline					letter = src-&gtstr.addr[isrc];\newline					if (ISDIGIT_ASCII(letter))\newline						continue;\newline					if (!((&#039,&#039 == letter) || (&#039)&#039 == letter)))\newline						return FALSE;\newline					previous = letter;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039)&#039 == previous)\newline						break;\newline					if (!ISDIGIT_ASCII(letter))\newline						return FALSE;\newline				}\newline				if (isrc &gt src-&gtstr.len)\newline					return FALSE;\newline				if (&#039_&#039 == letter)\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039$&#039 == letter)\newline						break;\newline					if (&#039&quot&#039 != letter)\newline						return FALSE;\newline					instring = TRUE;\newline					state = 3;	/* back to string */\newline					break;\newline				}\newline				if (&#039,&#039 == letter)\newline					state = 2;\newline				else if (term == letter)\newline					state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline				else\newline					return FALSE;\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					stop = isrc - (keep_quotes ? 0 : 1);	/* Not returning 2nd env part - maybe problem */\newline				break;\newline			case 8:		/* end of subscript but no closing paren - &quot)&quot */\newline				return FALSE;\newline				break;\newline		}\newline#		ifdef UNICODE_SUPPORTED\newline		if (!gtm_utf8_mode || (0 == (letter &amp 0x80)))\newline			isrc++;\newline		else if (0 &lt (utf8_len = UTF8_MBFOLLOW(&ampsrc-&gtstr.addr[isrc++])))\newline		{	/* multi-byte increment */\newline			assert(4 &gt utf8_len);\newline			if (0 &gt utf8_len)\newline				rts_error_csa(CSA_ARG(NULL)\newline					VARLSTCNT(6) ERR_BADCHAR, 4, 1, &ampsrc-&gtstr.addr[isrc - 1], LEN_AND_LIT(UTF8_NAME));\newline			isrc += utf8_len;\newline		}\newline#		endif\newline		NON_UNICODE_ONLY(isrc++);\newline	}\newline	if ((8 != state) &amp&amp (6 != state))\newline		return FALSE;\newline	if ((0 &lt= seq) &amp&amp (0 == stop))\newline		stop = src-&gtstr.len - (8 == state ? 1 : 0);\newline	if (keep_quotes &amp&amp (&#039&quot&#039 == src-&gtstr.addr[start - 1]))\newline		start--;\newline	assert((0 &lt subs_count) || ((6 == state) &amp&amp (-1 == subs_count)));\newline	if (6 == state)\newline		subs_count = 0;\newline	assert(((&#039^&#039 == src-&gtstr.addr[0]) ? MAX_GVSUBSCRIPTS : MAX_LVSUBSCRIPTS) &gt subs_count);\newline	assert((0 &lt isrc) &amp&amp (isrc == src-&gtstr.len));\newline	assert(stop &lt= isrc);\newline	assert((0 &lt= start) &amp&amp (start &lt= stop));\newline	*subscripts = subs_count;\newline	*start_off = start;\newline	*stop_off = stop;\newline	return TRUE;\newline}\newline","\newline -----------------------------------------------\newline is_canonic_name()\newline validate a variable name (unsubscripted or subscripted).\newline Note: This code is very similar to &quotgvn2gds()&quot in op_fnview.c. With some effort, they might even be merged into one.\newline \newline Arguments:\newline src - Pointer to Source Name string mval\newline subscripts - Pointer to sequence number of subscript to find &amp return of subscript count\newline start_off - Pointer offset of the component requested by op_fnqsubscript\newline stop_off - Pointer offset of the end of the component requested by op_fnqsubscript\newline Return:\newline boolean_t - TRUE indicates good name; FALSE indicates defective\newline -----------------------------------------------\newline \newline","3702832","timer.c","time_t wall_ts(struct timespec *booth_clk_t)\newline{\newline	struct timespec res;\newline\newline	clock2epochtime(booth_clk_t, &ampres);\newline	return round2secs(&ampres);\newline}\newline","time booth_clk_t is a time since boot or similar, return\newline something humans can understand (rounded seconds only) \newline","4517128","dec_gain.c","Word16 D_GAIN_find_voice_factor(Word16 exc[], Word16 Q_exc,\newline                                Word16 gain_pit, Word16 code[],\newline                                Word16 gain_code, Word16 L_subfr)\newline{\newline\newline   Word32 tmp, ener1, ener2, i;\newline   Word16 exp, exp1, exp2;\newline\newline   ener1 = (D_UTIL_dot_product12(exc, exc, L_subfr, &ampexp1)) &gt&gt 16;\newline   exp1 = (Word16)(exp1 - (Q_exc + Q_exc));\newline   tmp = (gain_pit * gain_pit) &lt&lt 1;\newline   exp = D_UTIL_norm_l(tmp);\newline   tmp = (tmp &lt&lt exp) &gt&gt 16;\newline   ener1 = (ener1 * tmp) &gt&gt 15;\newline   exp1 = (Word16)((exp1 - exp) - 10);   /* 10 -&gt gain_pit Q14 to Q9 */\newline   ener2 = D_UTIL_dot_product12(code, code, L_subfr, &ampexp2) &gt&gt 16;\newline   exp = D_UTIL_norm_s(gain_code);\newline   tmp = gain_code &lt&lt exp;\newline   tmp = (tmp * tmp) &gt&gt 15;\newline   ener2 = (ener2 * tmp) &gt&gt 15;\newline   exp2 = (Word16)(exp2 - (exp &lt&lt 1));\newline   i = exp1 - exp2;\newline\newline   if(i &gt= 0)\newline   {\newline      ener1 = ener1 &gt&gt 1;\newline      ener2 = ener2 &gt&gt (i + 1);\newline   }\newline   else if(i &gt (-16))\newline   {\newline      ener1 = ener1 &gt&gt (1 - i);\newline      ener2 = ener2 &gt&gt 1;\newline   }\newline   else\newline   {\newline      ener1 = 0;\newline      ener2 = ener2 &gt&gt 1;\newline   }\newline\newline   tmp = ener1 - ener2;\newline   ener1 = (ener1 + ener2) + 1;\newline   tmp = (tmp &lt&lt 15) / ener1;\newline\newline   return((Word16)tmp);\newline}\newline","\newline D_GAIN_find_voice_factor\newline \newline Parameters:\newline exc I: pitch excitation\newline Q_exc I: exc format\newline gain_pit I: (Q14) gain of pitch\newline code I: (Q9) fixed codebook excitation\newline gain_code I: (Q0) gain of code\newline L_subfr I: subframe length\newline \newline Function:\newline Find the voicing factor.\newline \newline Returns:\newline (Q15) 1=voice to -1=unvoiced\newline \newline","2842458","bstrlib.c","int bcatblk (bstring b, const unsigned char * s, int len) {\newlinestruct tagbstring t;\newline\newline	if (s == NULL || len &lt 0) return BSTR_ERR;\newline	blk2tbstr (t, s, len);\newline	return bconcat (b, &ampt);\newline}\newline","int bcatblk (bstring b, unsigned char s, int len)\newline \newline Concatenate a fixed length buffer to a bstring.\newline \newline","5923861","library.c","PHP_REDIS_API int redis_sock_connect(RedisSock *redis_sock TSRMLS_DC)\newline{\newline    struct timeval tv, read_tv, *tv_ptr = NULL;\newline    char host[1024], *persistent_id = NULL;\newline    const char *fmtstr = &quot%s:%d&quot;\newline    int host_len, err = 0;\newline    php_netstream_data_t *sock;\newline    int tcp_flag = 1;\newline\newline    if (redis_sock-&gtstream != NULL) {\newline        redis_sock_disconnect(redis_sock TSRMLS_CC);\newline    }\newline\newline    tv.tv_sec  = (time_t)redis_sock-&gttimeout;\newline    tv.tv_usec = (int)((redis_sock-&gttimeout - tv.tv_sec) * 1000000);\newline    if(tv.tv_sec != 0 || tv.tv_usec != 0) {\newline        tv_ptr = &amptv;\newline    }\newline\newline    read_tv.tv_sec  = (time_t)redis_sock-&gtread_timeout;\newline    read_tv.tv_usec = (int)((redis_sock-&gtread_timeout-read_tv.tv_sec)*1000000);\newline\newline    if(redis_sock-&gthost[0] == &#039/&#039 &amp&amp redis_sock-&gtport &lt 1) {\newline        host_len = snprintf(host, sizeof(host), &quotunix://%s&quot, redis_sock-&gthost);\newline    } else {\newline        if(redis_sock-&gtport == 0)\newline            redis_sock-&gtport = 6379;\newline\newline#ifdef HAVE_IPV6\newline        /* If we&#039ve got IPv6 and find a colon in our address, convert to proper\newline         * IPv6 [host]:port format */\newline        if (strchr(redis_sock-&gthost, &#039:&#039) != NULL) {\newline            fmtstr = &quot[%s]:%d&quot;\newline        }\newline#endif\newline        host_len = snprintf(host, sizeof(host), fmtstr, redis_sock-&gthost, redis_sock-&gtport);\newline    }\newline\newline    if (redis_sock-&gtpersistent) {\newline        if (redis_sock-&gtpersistent_id) {\newline            spprintf(&amppersistent_id, 0, &quotphpredis:%s:%s&quot, host, \newline                redis_sock-&gtpersistent_id);\newline        } else {\newline            spprintf(&amppersistent_id, 0, &quotphpredis:%s:%f&quot, host, \newline                redis_sock-&gttimeout);\newline        }\newline    }\newline\newline    redis_sock-&gtstream = php_stream_xport_create(host, host_len, \newline        0, STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\newline        persistent_id, tv_ptr, NULL, NULL, &amperr);\newline\newline    if (persistent_id) {\newline        efree(persistent_id);\newline    }\newline\newline    if (!redis_sock-&gtstream) {\newline        return -1;\newline    }\newline\newline    /* set TCP_NODELAY */\newline    sock = (php_netstream_data_t*)redis_sock-&gtstream-&gtabstract;\newline    setsockopt(sock-&gtsocket, IPPROTO_TCP, TCP_NODELAY, (char *) &amptcp_flag, \newline        sizeof(int));\newline\newline    php_stream_auto_cleanup(redis_sock-&gtstream);\newline\newline    if(tv.tv_sec != 0 || tv.tv_usec != 0) {\newline        php_stream_set_option(redis_sock-&gtstream,PHP_STREAM_OPTION_READ_TIMEOUT,\newline            0, &ampread_tv);\newline    }\newline    php_stream_set_option(redis_sock-&gtstream,\newline        PHP_STREAM_OPTION_WRITE_BUFFER, PHP_STREAM_BUFFER_NONE, NULL);\newline\newline    redis_sock-&gtstatus = REDIS_SOCK_STATUS_CONNECTED;\newline\newline    return 0;\newline}\newline","\newline redis_sock_connect\newline \newline","4974578","lcmaps_credential.c","int lcmaps_credential_store_requested_account(\newline        uid_t *                 puid,\newline        gid_t **                ppgid_list,\newline        int *                   pnpgid,\newline        gid_t **                psgid_list,\newline        int *                   pnsgid,\newline        char **                 ppoolindex,\newline        lcmaps_cred_id_t *      plcmaps_credential\newline)\newline{\newline    if (plcmaps_credential == NULL)\newline    {\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_credential_store_requested_account(): Create lcmaps_cred_id_t first!\\n&quot);\newline        return LCMAPS_CRED_INVOCATION_ERROR;\newline    }\newline    if (lcmaps_account_info_fill(\newline        puid,\newline        ppgid_list,\newline        pnpgid,\newline        psgid_list,\newline        pnsgid,\newline        ppoolindex,\newline        &amp(plcmaps_credential-&gtrequested_account))\newline    )\newline    {\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_credential_store_requested_account(): Error storing requested account info\\n&quot);\newline        return LCMAPS_CRED_ERROR;\newline    }\newline\newline    return LCMAPS_CRED_SUCCESS;\newline}\newline","\newlineFunction: lcmaps_credential_store_requested_account()\newlineDescription: stores the requested account (the account that should be verified)\newlinein an lcmaps_account_info_t structure.\newlineParameters:\newlinepuid: pointer to the uid of the local account\newlineppgid_list: pointer to the list of primary gids\newlinepnpgid: pointer to the number of primary gids found\newlinepsgid_list: pointer to the list of secondary gids\newlinepnsgid: pointer to the number of secondary gids found\newlineppoolindex: pointer to the pool index\newlineplcmaps_credential: pointer to lcmaps_credential\newlineReturns: LCMAPS_CRED_SUCCESS: success\newlineLCMAPS_CRED_ERROR: failure, because error filling lcmaps_account_info_t\newlineLCMAPS_CRED_INVOCATION_ERROR: failure, because lcmaps_credential does not exist\newline \newline","2573276","utils.c","void decode_uri(gchar *decoded_uri, const gchar *encoded_uri)\newline{\newline	gchar *dec = decoded_uri;\newline	const gchar *enc = encoded_uri;\newline\newline	while (*enc) {\newline		if (*enc == &#039%&#039) {\newline			enc++;\newline			if (g_ascii_isxdigit((guchar)enc[0]) &amp&amp\newline			    g_ascii_isxdigit((guchar)enc[1])) {\newline				*dec = axtoi(enc);\newline				dec++;\newline				enc += 2;\newline			}\newline		} else {\newline			if (*enc == &#039+&#039)\newline				*dec = &#039 &#039;\newline			else\newline				*dec = *enc;\newline			dec++;\newline			enc++;\newline		}\newline	}\newline\newline	*dec = &#039\\0&#039;\newline}\newline","Decodes URL-Encoded strings (i.e. strings in which spaces are replaced by\newline plusses, and escape characters are used)\newline Note: decoded_uri and encoded_uri can point the same location\newline \newline","1259652","lexer.c","void TY_(FreeNode)( TidyDocImpl* doc, Node *node )\newline{\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER) &amp&amp defined(DEBUG_ALLOCATION)\newline    if (node) SPRTF(&quotFree node %p\\n&quot, node );\newline#endif\newline    /* this is no good ;=((\newline    if (node &amp&amp doc &amp&amp doc-&gtlexer) {\newline        if (node == doc-&gtlexer-&gttoken) {\newline            doc-&gtlexer-&gttoken = NULL; // TY_(NewNode)( doc-&gtlexer-&gtallocator, doc-&gtlexer );\newline        }\newline    }\newline      ----------------- */\newline    while ( node )\newline    {\newline        Node* next = node-&gtnext;\newline\newline        TY_(FreeAttrs)( doc, node );\newline        TY_(FreeNode)( doc, node-&gtcontent );\newline        TidyDocFree( doc, node-&gtelement );\newline#ifdef TIDY_STORE_ORIGINAL_TEXT\newline        if (node-&gtotext)\newline            TidyDocFree(doc, node-&gtotext);\newline#endif\newline        if (RootNode != node-&gttype)\newline            TidyDocFree( doc, node );\newline        else\newline            node-&gtcontent = NULL;\newline\newline        node = next;\newline    }\newline}\newline","\newlineFree document nodes by iterating through peers and recursing\newlinethrough children. Set next to NULL before calling TY_(FreeNode)()\newlineto avoid freeing peer nodes. Doesn&#039t patch up prev/next links.\newline \newline","3591099","rthreads.c","bool scond_wait_timeout(scond_t *cond, slock_t *lock, int64_t timeout_us)\newline{\newline#ifdef USE_WIN32_THREADS\newline   DWORD ret;\newline\newline   WaitForSingleObject(cond-&gtevent, 0);\newline   ret = SignalObjectAndWait(lock-&gtlock, cond-&gtevent,\newline         (DWORD)(timeout_us) / 1000, FALSE);\newline\newline   slock_lock(lock);\newline   return ret == WAIT_OBJECT_0;\newline#else\newline   int ret;\newline   int64_t seconds, remainder;\newline   struct timespec now = {0};\newline\newline#ifdef __MACH__\newline   /* OSX doesn&#039t have clock_gettime. */\newline   clock_serv_t cclock;\newline   mach_timespec_t mts;\newline\newline   host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &ampcclock);\newline   clock_get_time(cclock, &ampmts);\newline   mach_port_deallocate(mach_task_self(), cclock);\newline   now.tv_sec = mts.tv_sec;\newline   now.tv_nsec = mts.tv_nsec;\newline#elif defined(__CELLOS_LV2__)\newline   sys_time_sec_t s;\newline   sys_time_nsec_t n;\newline\newline   sys_time_get_current_time(&amps, &ampn);\newline   now.tv_sec  = s;\newline   now.tv_nsec = n;\newline#elif defined(__mips__) || defined(VITA)\newline   struct timeval tm;\newline\newline   gettimeofday(&amptm, NULL);\newline   now.tv_sec = tm.tv_sec;\newline   now.tv_nsec = tm.tv_usec * 1000;\newline#elif defined(RETRO_WIN32_USE_PTHREADS)\newline   _ftime64_s(&ampnow);\newline#elif !defined(GEKKO)\newline   /* timeout on libogc is duration, not end time. */\newline   clock_gettime(CLOCK_REALTIME, &ampnow);\newline#endif\newline\newline   seconds      = timeout_us / INT64_C(1000000);\newline   remainder    = timeout_us % INT64_C(1000000);\newline\newline   now.tv_sec  += seconds;\newline   now.tv_nsec += remainder * INT64_C(1000);\newline\newline   ret = pthread_cond_timedwait(&ampcond-&gtcond, &amplock-&gtlock, &ampnow);\newline   return (ret == 0);\newline#endif\newline}\newline","\newline scond_wait_timeout:\newline @cond : pointer to condition variable object \newline @lock : pointer to mutex object \newline @timeout_us : timeout (in microseconds)\newline \newline Try to block on a condition variable (i.e. wait on a condition) until\newline @timeout_us elapses.\newline \newline Returns: false (0) if timeout elapses before condition variable is\newline signaled or broadcast, otherwise true (1).\newline \newline","3749922","res_xmpp.c","static int xmpp_pak_presence(struct ast_xmpp_client *client, struct ast_xmpp_client_config *cfg, iks *node, ikspak *pak)\newline{\newline	struct ast_xmpp_buddy *buddy;\newline	struct ast_xmpp_resource *resource;\newline	char *type = iks_find_attrib(pak-&gtx, &quottype&quot);\newline	int status = pak-&gtshow ? pak-&gtshow : STATUS_DISAPPEAR;\newline	enum ast_device_state state = AST_DEVICE_UNAVAILABLE;\newline\newline	/* If this is a component presence probe request answer immediately with our presence status */\newline	if (ast_test_flag(&ampcfg-&gtflags, XMPP_COMPONENT) &amp&amp !ast_strlen_zero(type) &amp&amp !strcasecmp(type, &quotprobe&quot)) {\newline		xmpp_client_set_presence(client, pak-&gtfrom-&gtfull, iks_find_attrib(pak-&gtx, &quotto&quot), cfg-&gtstatus, cfg-&gtstatusmsg);\newline	}\newline\newline	/* If no resource is available this is a general buddy presence update, which we will ignore */\newline	if (!pak-&gtfrom-&gtresource) {\newline		return 0;\newline	}\newline\newline	if (!(buddy = ao2_find(client-&gtbuddies, pak-&gtfrom-&gtpartial, OBJ_KEY))) {\newline		/* Only output the message if it is not about us */\newline		if (strcmp(client-&gtjid-&gtpartial, pak-&gtfrom-&gtpartial)) {\newline			ast_log(LOG_WARNING, &quotReceived presence information about &#039%s&#039 despite not having them in roster on client &#039%s&#039\\n&quot,\newline				pak-&gtfrom-&gtpartial, client-&gtname);\newline		}\newline		return 0;\newline	}\newline\newline	ao2_lock(buddy-&gtresources);\newline\newline	if (!(resource = ao2_callback(buddy-&gtresources, OBJ_NOLOCK, xmpp_resource_cmp, pak-&gtfrom-&gtresource))) {\newline		/* Only create the new resource if it is not going away - in reality this should not happen */\newline		if (status != STATUS_DISAPPEAR) {\newline			if (!(resource = ao2_alloc(sizeof(*resource), xmpp_resource_destructor))) {\newline				ast_log(LOG_ERROR, &quotCould not allocate resource object for resource &#039%s&#039 of buddy &#039%s&#039 on client &#039%s&#039\\n&quot,\newline					pak-&gtfrom-&gtresource, buddy-&gtid, client-&gtname);\newline				ao2_unlock(buddy-&gtresources);\newline				ao2_ref(buddy, -1);\newline				return 0;\newline			}\newline\newline			ast_copy_string(resource-&gtresource, pak-&gtfrom-&gtresource, sizeof(resource-&gtresource));\newline		}\newline	} else {\newline		/* We unlink the resource in case the priority changes or in case they are going away */\newline		ao2_unlink_flags(buddy-&gtresources, resource, OBJ_NOLOCK);\newline	}\newline\newline	/* Only update the resource and add it back in if it is not going away */\newline	if (resource &amp&amp (status != STATUS_DISAPPEAR)) {\newline		char *node, *ver;\newline\newline		/* Try to get the XMPP spec node, and fall back to Google if not found */\newline		if (!(node = iks_find_attrib(iks_find(pak-&gtx, &quotc&quot), &quotnode&quot))) {\newline			node = iks_find_attrib(iks_find(pak-&gtx, &quotcaps:c&quot), &quotnode&quot);\newline		}\newline\newline		if (!(ver = iks_find_attrib(iks_find(pak-&gtx, &quotc&quot), &quotver&quot))) {\newline			ver = iks_find_attrib(iks_find(pak-&gtx, &quotcaps:c&quot), &quotver&quot);\newline		}\newline\newline		if (resource-&gtdescription) {\newline			ast_free(resource-&gtdescription);\newline		}\newline\newline		if ((node &amp&amp strcmp(resource-&gtcaps.node, node)) || (ver &amp&amp strcmp(resource-&gtcaps.version, ver))) {\newline			/* For interoperability reasons, proceed even if the resource fails to provide node or version */\newline			if (node) {\newline				ast_copy_string(resource-&gtcaps.node, node, sizeof(resource-&gtcaps.node));\newline			}\newline			if (ver) {\newline				ast_copy_string(resource-&gtcaps.version, ver, sizeof(resource-&gtcaps.version));\newline			}\newline\newline			/* Google Talk places the capabilities information directly in presence, so see if it is there */\newline			if (iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://www.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://www.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://www.android.com/gtalk/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://www.android.com/gtalk/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://mail.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://mail.google.com/xmpp/client/caps&quot)) {\newline				resource-&gtcaps.google = 1;\newline			}\newline\newline			/* To discover if the buddy supports Jingle we need to query, so do so */\newline			if (xmpp_client_send_disco_info_request(client, pak-&gtfrom-&gtfull, client-&gtjid-&gtfull)) {\newline				ast_log(LOG_WARNING, &quotCould not send discovery information request to resource &#039%s&#039 of buddy &#039%s&#039 on client &#039%s&#039, capabilities may be incomplete\\n&quot, resource-&gtresource, buddy-&gtid, client-&gtname);\newline			}\newline		}\newline\newline		resource-&gtstatus = status;\newline		resource-&gtdescription = ast_strdup(iks_find_cdata(pak-&gtx, &quotstatus&quot));\newline		resource-&gtpriority = atoi((iks_find_cdata(pak-&gtx, &quotpriority&quot)) ? iks_find_cdata(pak-&gtx, &quotpriority&quot) : &quot0&quot);\newline\newline		ao2_link_flags(buddy-&gtresources, resource, OBJ_NOLOCK);\newline\newline		manager_event(EVENT_FLAG_USER, &quotJabberStatus&quot,\newline			      &quotAccount: %s\\r\\nJID: %s\\r\\nResource: %s\\r\\nStatus: %d\\r\\nPriority: %d&quot\newline			      &quot\\r\\nDescription: %s\\r\\n&quot,\newline			      client-&gtname, pak-&gtfrom-&gtpartial, resource-&gtresource, resource-&gtstatus,\newline			      resource-&gtpriority, S_OR(resource-&gtdescription, &quot&quot));\newline\newline		ao2_ref(resource, -1);\newline	} else {\newline		/* This will get hit by presence coming in for an unknown resource, and also when a resource goes away */\newline		if (resource) {\newline			ao2_ref(resource, -1);\newline		}\newline\newline		manager_event(EVENT_FLAG_USER, &quotJabberStatus&quot,\newline			      &quotAccount: %s\\r\\nJID: %s\\r\\nStatus: %u\\r\\n&quot,\newline			      client-&gtname, pak-&gtfrom-&gtpartial, pak-&gtshow ? pak-&gtshow : IKS_SHOW_UNAVAILABLE);\newline	}\newline\newline	/* Determine if at least one resource is available for device state purposes */\newline	if ((resource = ao2_callback(buddy-&gtresources, OBJ_NOLOCK, xmpp_resource_is_available, NULL))) {\newline		state = AST_DEVICE_NOT_INUSE;\newline		ao2_ref(resource, -1);\newline	}\newline\newline	ao2_unlock(buddy-&gtresources);\newline\newline	ao2_ref(buddy, -1);\newline\newline	ast_devstate_changed(state, AST_DEVSTATE_CACHABLE, &quotXMPP/%s/%s&quot, client-&gtname, pak-&gtfrom-&gtpartial);\newline\newline	return 0;\newline}\newline","! \\brief Internal function called when a presence message is received \newline","2532131","output.c","static void print_verbose_error(struct file_info *info)\newline{\newline	char actual[130], expected[130];\newline	assert(HC_FAILED(info-&gthc.flags));\newline\newline	fprintf(rhash_data.out, _(&quotERROR&quot));\newline\newline	if (HC_WRONG_FILESIZE &amp info-&gthc.flags) {\newline		sprintI64(actual, info-&gtrctx-&gtmsg_size, 0);\newline		sprintI64(expected, info-&gthc.file_size, 0);\newline		fprintf(rhash_data.out, _(&quot, size is %s should be %s&quot), actual, expected);\newline	}\newline\newline	if (HC_WRONG_EMBCRC32 &amp info-&gthc.flags) {\newline		rhash_print(expected, info-&gtrctx, RHASH_CRC32, RHPR_UPPERCASE);\newline		fprintf(rhash_data.out, _(&quot, embedded CRC32 should be %s&quot), expected);\newline	}\newline\newline	if (HC_WRONG_HASHES &amp info-&gthc.flags) {\newline		int i;\newline		unsigned reported = 0;\newline		for (i = 0; i &lt info-&gthc.hashes_num; i++) {\newline			hash_value *hv = &ampinfo-&gthc.hashes[i];\newline			char *expected_hash = info-&gthc.data + hv-&gtoffset;\newline			unsigned hid = hv-&gthash_id;\newline			int pflags;\newline			if ((info-&gthc.wrong_hashes &amp (1 &lt&lt i)) == 0) continue;\newline\newline			assert(hid != 0);\newline\newline			/* if can&#039t detect precise hash */\newline			if ((hid &amp (hid - 1)) != 0) {\newline				/* guess the hash id */\newline				if (hid &amp opt.sum_flags) hid &amp= opt.sum_flags;\newline				if (hid &amp ~info-&gthc.found_hash_ids) hid &amp= ~info-&gthc.found_hash_ids;\newline				if (hid &amp ~reported) hid &amp= ~reported; /* avoiding repeating */\newline				if (hid &amp REPORT_FIRST_MASK) hid &amp= REPORT_FIRST_MASK;\newline				hid &amp= -(int)hid; /* take the lowest bit */\newline			}\newline			assert(hid != 0 &amp&amp (hid &amp (hid - 1)) == 0); /* single bit only */\newline			reported |= hid;\newline\newline			pflags = (hv-&gtlength == (rhash_get_digest_size(hid) * 2) ?\newline				(RHPR_HEX | RHPR_UPPERCASE) : (RHPR_BASE32 | RHPR_UPPERCASE));\newline			rhash_print(actual, info-&gtrctx, hid, pflags);\newline			fprintf(rhash_data.out, _(&quot, %s is %s should be %s&quot),\newline				rhash_get_name(hid), actual, expected_hash);\newline		}\newline	}\newline\newline	fprintf(rhash_data.out, &quot\\n&quot);\newline}\newline","\newline Print verbose error on hash sums mismatch.\newline \newline @param info file information with path and its hash sums.\newline \newline","2162075","mboxkey.c","static int mboxkey_merge_cb(void *rockp,\newline			 const char *key, size_t keylen,\newline			 const char *tmpdata, size_t tmpdatalen) \newline{\newline    int r;\newline    struct mboxkey_merge_rock *rockdata = (struct mboxkey_merge_rock *)rockp;\newline    struct db *tgtdb = rockdata-&gtdb;\newline    const char *tgtdata;\newline    size_t tgtdatalen;\newline\newline    if (!tgtdb) return IMAP_INTERNAL;\newline\newline    r = cyrusdb_fetchlock(tgtdb, key, keylen, &amptgtdata, &amptgtdatalen,\newline		      &amp(rockdata-&gttid));\newline    if(!r &amp&amp tgtdata) {\newline	unsigned short version, s;\newline	const char *tmp = tmpdata, *tgt = tgtdata;\newline	\newline	/* get version */\newline	memcpy(&amps, tgt, sizeof(s));\newline	version = ntohs(s);\newline	assert(version == MBOXKEY_VERSION);\newline\newline	/* get version */\newline	memcpy(&amps, tmp, sizeof(s));\newline	version = ntohs(s);\newline	assert(version == MBOXKEY_VERSION);\newline    }\newline    \newline    return cyrusdb_store(tgtdb, key, keylen, tmpdata, tmpdatalen,\newline		     &amp(rockdata-&gttid));\newline}\newline","Copy keys from tmp file to tgt file.\newline \newline XXX We currently have nothing to compare against.\newline \newline","6394726","mgx11windows.c","void Xmg_sortdisplaylist()\newline{\newline  static int *primp;\newline\newline  if (_mgx11c-&gtsortmethod == MG_DEPTH)\newline    {\newline      primp = VVEC(_mgx11c-&gtmysort-&gtprimsort, int);\newline      qsort(primp, _mgx11c-&gtmysort-&gtcprim, sizeof(int), &ampXmg_primcomp);\newline    }\newline}\newline","\newlineFunction: Xmg_sortdisplaylist\newlineDescription: Does depth sorting of primitives.\newlineAuthor: Daeron Meyer\newline \newline","4227482","stream_dvdnav.c","int mp_dvdnav_spu_has_changed (stream_t *stream, int clear) {\newline  dvdnav_priv_t *priv =  stream-&gtpriv;\newline\newline  if (!(priv-&gtstate &amp NAV_FLAG_SPU_CHANGE))\newline    return 0;\newline\newline  if (clear)\newline    priv-&gtstate &amp= ~NAV_FLAG_SPU_CHANGE;\newline\newline  return 1;\newline}\newline","\newline \\brief Check if SPU has changed\newline \\param stream: - stream pointer\newline \\param clear : - if true, then clear spu change flag\newline \\return 1 if spu has changed\newline \newline","","","","on","","","","","on","","","","","on","","","","","on","","on","","","","","","","","on","","","","","","","","","","on","","","","Request contents of log","Find the voicing factor.","Concatenate a fixed length buffer to a bstring.","{}","stores the requested account","Decodes URL-Encoded strings","Free document nodes by iterating through peers and recursingthrough children.","Try to block on a condition variable (i.e. wait on a condition)","{}","Print verbose error on hash sums mismatch.","Copy keys from tmp file to tgt file.","Process voices, and returns interleaved subframe destination address","depth sorting of primitives.","{}","returns the selection of thepassword characters template","Change the comment stored on the server for a given buddy.","Decrypt and compare the tag with OCB.","Remove from the current line a start comment mark atthe","{}","validate a variable name","{}"
"3VEI3XUCZRXYD1S5ZWOWPWTGQMXRPP","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3PWWM24LHSYYQ99WORCLRLM75B1821","A1Y0ABOUJUMCWW","Approved","Wed Apr 17 22:19:21 PDT 2019","Wed Apr 17 22:27:29 PDT 2019","Fri Apr 19 22:27:29 PDT 2019","2019-04-20 05:28:21 UTC","","","488","100% (10/10)","100% (10/10)","100% (10/10)","5584104","php_amule_lib.cpp","void php_get_log(PHP_VALUE_NODE *result)\newline{\newline	value_value_free(result);\newline\newline	PHP_SCOPE_ITEM *si = get_scope_item(g_current_scope, &quot__param_0&quot);\newline	bool rst;\newline	if ( !si ) {\newline		rst = false;\newline	} else {\newline		cast_value_dnum(&ampsi-&gtvar-&gtvalue);\newline		rst = si-&gtvar-&gtvalue.int_val != 0;\newline	}\newline	if ( rst ) {\newline		CECPacket req(EC_OP_RESET_LOG);\newline		CPhPLibContext::g_curr_context-&gtWebServer()-&gtSend_Discard_V2_Request(&ampreq);\newline	}\newline	CECPacket req(EC_OP_GET_LOG);\newline	const CECPacket *response = CPhPLibContext::g_curr_context-&gtWebServer()-&gtwebInterface-&gtSendRecvMsg_v2(&ampreq);\newline	if (response) {\newline		wxString serverInfoString(_SpecialChars(response-&gtGetFirstTagSafe()-&gtGetStringData()));\newline		delete response;\newline		result-&gttype = PHP_VAL_STRING;\newline		result-&gtstr_val = strdup((const char *)unicode2UTF8(serverInfoString));\newline	}\newline}\newline","\newline Request contents of log\newline \newline","3515879","musyx.c","static uint32_t voice_stage(struct hle_t* hle, musyx_t *musyx,\newline                            uint32_t voice_ptr, uint32_t last_sample_ptr)\newline{\newline    uint32_t output_ptr;\newline    int i = 0;\newline\newline    /* voice stage can be skipped if first voice has no samples */\newline    if (*dram_u16(hle, voice_ptr + VOICE_CATSRC_0 + CATSRC_SIZE1) == 0) {\newline        HleVerboseMessage(hle-&gtuser_defined, &quotSkipping Voice stage&quot);\newline        output_ptr = *dram_u32(hle, voice_ptr + VOICE_INTERLEAVED_PTR);\newline    } else {\newline        /* otherwise process voices until a non null output_ptr is encountered */\newline        for (;;) {\newline            /* load voice samples (PCM16 or APDCM) */\newline            int16_t samples[SAMPLE_BUFFER_SIZE];\newline            unsigned segbase;\newline            unsigned offset;\newline\newline            HleVerboseMessage(hle-&gtuser_defined, &quotProcessing Voice #%d&quot, i);\newline\newline            if (*dram_u8(hle, voice_ptr + VOICE_ADPCM_FRAMES) == 0)\newline                load_samples_PCM16(hle, voice_ptr, samples, &ampsegbase, &ampoffset);\newline            else\newline                load_samples_ADPCM(hle, voice_ptr, samples, &ampsegbase, &ampoffset);\newline\newline            /* mix them with each internal subframes */\newline            mix_voice_samples(hle, musyx, voice_ptr, samples, segbase, offset,\newline                              last_sample_ptr + i * 8);\newline\newline            /* check break condition */\newline            output_ptr = *dram_u32(hle, voice_ptr + VOICE_INTERLEAVED_PTR);\newline            if (output_ptr != 0)\newline                break;\newline\newline            /* next voice */\newline            ++i;\newline            voice_ptr += VOICE_SIZE;\newline        }\newline    }\newline\newline    return output_ptr;\newline}\newline","Process voices, and returns interleaved subframe destination address \newline","1480391","configdialog.cpp","int ConfigDialog::getPwdTemplateSelector() {\newline  return ui-&gtpasswordCharTemplateSelector-&gtcurrentIndex();\newline}\newline","\newline @brief ConfigDialog::getPwdTemplateSelector returns the selection of the\newline password characters template combobox\newline @return\newline \newline","5964507","ssi.c","faim_export int aim_ssi_editcomment(aim_session_t *sess, const char *gn, const char *sn, const char *comment)\newline{\newline	struct aim_ssi_item *tmp;\newline\newline	if (!sess || !gn || !sn)\newline		return -EINVAL;\newline\newline	if (!(tmp = aim_ssi_itemlist_finditem(sess-&gtssi.local, gn, sn, AIM_SSI_TYPE_BUDDY)))\newline		return -EINVAL;\newline\newline	/* Either add or remove the 0x0131 TLV from the TLV chain */\newline	if ((comment != NULL) &amp&amp (strlen(comment) &gt 0))\newline		aim_tlvlist_replace_raw(&amptmp-&gtdata, 0x013c, strlen(comment), comment);\newline	else\newline		aim_tlvlist_remove(&amptmp-&gtdata, 0x013c);\newline\newline	/* Sync our local list with the server list */\newline	aim_ssi_sync(sess);\newline\newline	return 0;\newline}\newline","\newline Change the comment stored on the server for a given buddy.\newline \newline @param sess The oscar session.\newline @param gn The group that the buddy is currently in.\newline @param sn The screen name of the buddy.\newline @param alias The new comment for the buddy, or NULL if you want to remove \newline a buddy&#039s comment.\newline @return Return 0 if no errors, otherwise return the error number.\newline \newline","4459999","ocb_decrypt_verify_memory.c","int ocb_decrypt_verify_memory(int cipher,\newline    const unsigned char *key,    unsigned long keylen,\newline    const unsigned char *nonce,  \newline    const unsigned char *ct,     unsigned long ctlen,\newline          unsigned char *pt,\newline    const unsigned char *tag,    unsigned long taglen,\newline          int           *stat)\newline{\newline   int err;\newline   ocb_state *ocb;\newline\newline   LTC_ARGCHK(key    != NULL);\newline   LTC_ARGCHK(nonce  != NULL);\newline   LTC_ARGCHK(pt     != NULL);\newline   LTC_ARGCHK(ct     != NULL);\newline   LTC_ARGCHK(tag    != NULL);\newline   LTC_ARGCHK(stat    != NULL);\newline\newline   /* allocate memory */\newline   ocb = XMALLOC(sizeof(ocb_state));\newline   if (ocb == NULL) {\newline      return CRYPT_MEM;\newline   }\newline\newline   if ((err = ocb_init(ocb, cipher, key, keylen, nonce)) != CRYPT_OK) {\newline      goto LBL_ERR; \newline   }\newline\newline   while (ctlen &gt (unsigned long)ocb-&gtblock_len) {\newline        if ((err = ocb_decrypt(ocb, ct, pt)) != CRYPT_OK) {\newline            goto LBL_ERR; \newline        }\newline        ctlen   -= ocb-&gtblock_len;\newline        pt      += ocb-&gtblock_len;\newline        ct      += ocb-&gtblock_len;\newline   }\newline\newline   err = ocb_done_decrypt(ocb, ct, ctlen, pt, tag, taglen, stat);\newlineLBL_ERR:\newline#ifdef LTC_CLEAN_STACK\newline   zeromem(ocb, sizeof(ocb_state));\newline#endif\newline \newline   XFREE(ocb);\newline\newline   return err;\newline}\newline","\newlineDecrypt and compare the tag with OCB.\newline@param cipher The index of the cipher desired\newline@param key The secret key\newline@param keylen The length of the secret key (octets)\newline@param nonce The session nonce (length of the block size of the block cipher)\newline@param ct The ciphertext\newline@param ctlen The length of the ciphertext (octets)\newline@param pt [out] The plaintext\newline@param tag The tag to compare against\newline@param taglen The length of the tag (octets)\newline@param stat [out] The result of the tag comparison (1==valid, 0==invalid)\newline@return CRYPT_OK if successful regardless of the tag comparison\newline \newline","5623426","katedocument.cpp","bool KateDocument::removeStartStopCommentFromSingleLine( int line, int attrib )\newline{\newline  QString shortStartCommentMark = highlight()-&gtgetCommentStart( attrib );\newline  QString longStartCommentMark = shortStartCommentMark + &#039 &#039;\newline  QString shortStopCommentMark = highlight()-&gtgetCommentEnd( attrib );\newline  QString longStopCommentMark = &#039 &#039 + shortStopCommentMark;\newline\newline  editStart();\newline\newline  // TODO &quotthat&#039s a bad idea, can lead to stray endings, FIXME&quot\newline\newline  // Try to remove the long start comment mark first\newline  bool removedStart = (removeStringFromBeginning(line, longStartCommentMark)\newline                    || removeStringFromBeginning(line, shortStartCommentMark));\newline\newline  bool removedStop = false;\newline  if (removedStart)\newline  {\newline    // Try to remove the long stop comment mark first\newline    removedStop = (removeStringFromEnd(line, longStopCommentMark)\newline                || removeStringFromEnd(line, shortStopCommentMark));\newline  }\newline\newline  editEnd();\newline\newline  return (removedStart || removedStop);\newline}\newline","\newlineRemove from the current line a start comment mark at\newlinethe beginning and a stop comment mark at the end.\newline \newline","5078934","screen.cpp","int screen_readkey()\newline{\newline    int c = getch();\newline    if (c == ERR) {\newline        return -1;\newline    }\newline    return c;\newline}\newline","ERR is actually -1, but this prevents us from needing to use curses.h in\newline sipp.cpp. \newline","5980594","is_canonic_name.c","boolean_t is_canonic_name(mval *src, int *subscripts, int *start_off, int *stop_off)\newline{	/* subscripts is overloaded - out to op_fnqlength, which doesn&#039t use the last 2 arguments &amp in from op_fnqsubscript */\newline	char		term;\newline	int		envpart;\newline	boolean_t	instring;\newline	int		isrc;\newline	boolean_t	keep_quotes;\newline	char		letter;\newline	int		point;\newline	char		previous;\newline	int		seq;\newline	int		start;\newline	int		state;\newline	int		stop;\newline	int		subs_count;\newline	int		utf8_len;\newline\newline	/* state:\newline	 *    0      before start of name\newline	 *    1      found ^ allow environment\newline	 *    2      dispatch for starting a component\newline	 *    3      in string\newline	 *    4      in number\newline	 *    5      expect first letter of name\newline	 *    6      expect next letter of name\newline	 *    7      in $CHAR()\newline	 *    8      at end of processing\newline	 */\newline\newline	MV_FORCE_STR(src);\newline	seq = *subscripts;\newline	keep_quotes = FALSE;\newline	start = stop = 0;\newline	state = 0;\newline	subs_count = -1;\newline	for (isrc = 0; isrc &lt src-&gtstr.len; )\newline	{\newline		letter = src-&gtstr.addr[isrc];\newline		switch (state)\newline		{\newline			case 0:		/* start of name */\newline				if (&#039^&#039 == letter)	/* before start of name */\newline				{\newline					state = 1;	/* check for environment */\newline					break;\newline				}\newline				if ((&#039%&#039 == letter) || ISALPHA_ASCII(letter))\newline				{\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				return FALSE;\newline			case 1:		/* global name */\newline				if ((&#039%&#039 == letter) ||ISALPHA_ASCII(letter))	/* found ^ allow environment */\newline				{	/* found ^ allow environment */\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				if ((&#039|&#039 == letter) || (&#039[&#039 == letter))\newline				{\newline					term = (letter == &#039[&#039) ? &#039]&#039 : letter;\newline					envpart = 0;\newline					if (subs_count == seq)\newline						start = isrc + 1;\newline					state = 2;	/* process environment */\newline					break;\newline				}\newline				return FALSE;\newline			case 2:		 /* dispatch for starting a component */\newline				point = 0;\newline				instring = FALSE;\newline				if (envpart &gt 1)\newline					return FALSE;	/* too many environment components */\newline				if (&#039)&#039 == term)\newline					subs_count++;	/* new subscript */\newline				else\newline					envpart++;	/* next environment component */\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					start = isrc;\newline				if (&#039&quot&#039 == letter)\newline				{\newline					if ((subs_count == seq) &amp&amp (1 == envpart))\newline						start++;\newline					instring = TRUE;\newline					state = 3;	/* string */\newline					break;\newline				}\newline				if (&#039$&#039 ==letter)\newline				{\newline					state = 7;	/* $[z]char() */\newline					break;\newline				}\newline				if (&#0390&#039 == letter) /* Canonic number cannot start with 0 unless is single char */\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;	/* Cannot end with &quot0&quot */\newline					if (term == letter)\newline						state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline					else if (&#039,&#039 != letter)\newline						return FALSE;	/* Not a single char number */\newline					if ((subs_count == seq) &amp&amp (0 == stop))\newline						stop = isrc;\newline					break;\newline				}\newline				if ((&#039-&#039 == letter) || (&#039.&#039 == letter) || ISDIGIT_ASCII(letter))\newline				{\newline					if (&#039.&#039 == letter)\newline						point++;\newline					previous = letter;\newline					state = 4;	/* numeric */\newline					break;\newline				}\newline				return FALSE;\newline			case 3:		/* [quoted] string */\newline				if (&#039&quot&#039 == letter)	/* in string */\newline				{\newline					instring = !instring;\newline					if (instring)\newline						break;\newline					if (isrc + 1 &gt= src-&gtstr.len)\newline						return FALSE;\newline					if (&#039_&#039 != src-&gtstr.addr[isrc + 1])\newline						break;\newline					isrc++;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039$&#039 != letter)\newline						return FALSE;\newline					state = 7;	/* $[z]char() */\newline					break;\newline				}\newline				if (!instring)\newline				{\newline					if (&#039,&#039 == letter)\newline						state = 2;	/* on to next */\newline					else if (term == letter)\newline						state = (&#039)&#039 == term) ? 8 : 5;	/* end or name */\newline					else\newline						return FALSE;\newline					if ((subs_count == seq) &amp&amp (0 == stop))\newline						/* Not returning 2nd env part - maybe problem */\newline						stop = isrc - (keep_quotes ? 0 : 1);\newline				}\newline				break;\newline			case 4:		/* numeric */\newline				if (ISDIGIT_ASCII(letter))	/* in number */\newline				{\newline					if ((&#039-&#039 == previous) &amp&amp (&#0390&#039 == letter))\newline						return FALSE;\newline					previous = letter;\newline					break;\newline				}\newline				if (&#039.&#039 == letter)\newline				{\newline					if ((++point &gt 1))\newline						return FALSE;\newline					previous = letter;\newline					break;\newline				}\newline				if (point &amp&amp (&#0390&#039 == previous))\newline					return FALSE;\newline				if (&#039,&#039 == letter)\newline					state = 2;	/* next */\newline				else if (term == letter)\newline					state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline				else\newline					return FALSE;\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					stop = isrc;\newline				previous = letter;\newline				break;\newline			case 5:		/* expect first letter of name */\newline				if ((&#039%&#039 == letter) || ISALPHA_ASCII(letter))\newline				{\newline					if (0 == seq)\newline						start = isrc;\newline					state = 6;	/* rest of name */\newline					break;\newline				}\newline				return FALSE;\newline			case 6:		/* expect next letter of name */\newline				if (&#039(&#039 == letter)\newline				{\newline					term = &#039)&#039;\newline					envpart = 1;\newline					subs_count = 0;\newline					state = 2;	/* done with name */\newline					if (0 == seq)\newline						stop = isrc;\newline				} else if (!ISALNUM_ASCII(letter))\newline					return FALSE;\newline				break;\newline			case 7:		/* $[Z]CHAR() */\newline				previous = letter;	/* in $CHAR() - must be ASCII */\newline				if ((&#039Z&#039 == letter) || (&#039z&#039 == letter))\newline				{	if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039z&#039 == previous)\newline						previous = &#039Z&#039;\newline				}\newline				if (!((&#039C&#039 == letter) || (&#039c&#039 == letter)))\newline					return FALSE;\newline				if (++isrc &lt src-&gtstr.len)\newline					letter = src-&gtstr.addr[isrc];\newline				else\newline					return FALSE;\newline				if ((&#039H&#039 == letter) || (&#039h&#039 == letter))\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (!((&#039A&#039 == letter) || (&#039a&#039 == letter) || ((&#039(&#039 == letter) &amp&amp (&#039Z&#039 == previous))))\newline						return FALSE;\newline				} else if (&#039Z&#039 == previous)\newline					return FALSE;\newline				if (&#039(&#039 != letter)\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (!(&#039R&#039 == letter) || (&#039r&#039 == letter))\newline						return FALSE;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline				}\newline				if (&#039(&#039 != letter)\newline					return FALSE;\newline				if (subs_count == seq)\newline					keep_quotes = TRUE;\newline				for (++isrc ;isrc &lt src-&gtstr.len; isrc++)\newline				{\newline					letter = src-&gtstr.addr[isrc];\newline					if (ISDIGIT_ASCII(letter))\newline						continue;\newline					if (!((&#039,&#039 == letter) || (&#039)&#039 == letter)))\newline						return FALSE;\newline					previous = letter;\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039)&#039 == previous)\newline						break;\newline					if (!ISDIGIT_ASCII(letter))\newline						return FALSE;\newline				}\newline				if (isrc &gt src-&gtstr.len)\newline					return FALSE;\newline				if (&#039_&#039 == letter)\newline				{\newline					if (++isrc &lt src-&gtstr.len)\newline						letter = src-&gtstr.addr[isrc];\newline					else\newline						return FALSE;\newline					if (&#039$&#039 == letter)\newline						break;\newline					if (&#039&quot&#039 != letter)\newline						return FALSE;\newline					instring = TRUE;\newline					state = 3;	/* back to string */\newline					break;\newline				}\newline				if (&#039,&#039 == letter)\newline					state = 2;\newline				else if (term == letter)\newline					state = (&#039)&#039 == term) ? 8 : 5;		/* end or name */\newline				else\newline					return FALSE;\newline				if ((subs_count == seq) &amp&amp (0 == stop))\newline					stop = isrc - (keep_quotes ? 0 : 1);	/* Not returning 2nd env part - maybe problem */\newline				break;\newline			case 8:		/* end of subscript but no closing paren - &quot)&quot */\newline				return FALSE;\newline				break;\newline		}\newline#		ifdef UNICODE_SUPPORTED\newline		if (!gtm_utf8_mode || (0 == (letter &amp 0x80)))\newline			isrc++;\newline		else if (0 &lt (utf8_len = UTF8_MBFOLLOW(&ampsrc-&gtstr.addr[isrc++])))\newline		{	/* multi-byte increment */\newline			assert(4 &gt utf8_len);\newline			if (0 &gt utf8_len)\newline				rts_error_csa(CSA_ARG(NULL)\newline					VARLSTCNT(6) ERR_BADCHAR, 4, 1, &ampsrc-&gtstr.addr[isrc - 1], LEN_AND_LIT(UTF8_NAME));\newline			isrc += utf8_len;\newline		}\newline#		endif\newline		NON_UNICODE_ONLY(isrc++);\newline	}\newline	if ((8 != state) &amp&amp (6 != state))\newline		return FALSE;\newline	if ((0 &lt= seq) &amp&amp (0 == stop))\newline		stop = src-&gtstr.len - (8 == state ? 1 : 0);\newline	if (keep_quotes &amp&amp (&#039&quot&#039 == src-&gtstr.addr[start - 1]))\newline		start--;\newline	assert((0 &lt subs_count) || ((6 == state) &amp&amp (-1 == subs_count)));\newline	if (6 == state)\newline		subs_count = 0;\newline	assert(((&#039^&#039 == src-&gtstr.addr[0]) ? MAX_GVSUBSCRIPTS : MAX_LVSUBSCRIPTS) &gt subs_count);\newline	assert((0 &lt isrc) &amp&amp (isrc == src-&gtstr.len));\newline	assert(stop &lt= isrc);\newline	assert((0 &lt= start) &amp&amp (start &lt= stop));\newline	*subscripts = subs_count;\newline	*start_off = start;\newline	*stop_off = stop;\newline	return TRUE;\newline}\newline","\newline -----------------------------------------------\newline is_canonic_name()\newline validate a variable name (unsubscripted or subscripted).\newline Note: This code is very similar to &quotgvn2gds()&quot in op_fnview.c. With some effort, they might even be merged into one.\newline \newline Arguments:\newline src - Pointer to Source Name string mval\newline subscripts - Pointer to sequence number of subscript to find &amp return of subscript count\newline start_off - Pointer offset of the component requested by op_fnqsubscript\newline stop_off - Pointer offset of the end of the component requested by op_fnqsubscript\newline Return:\newline boolean_t - TRUE indicates good name; FALSE indicates defective\newline -----------------------------------------------\newline \newline","3702832","timer.c","time_t wall_ts(struct timespec *booth_clk_t)\newline{\newline	struct timespec res;\newline\newline	clock2epochtime(booth_clk_t, &ampres);\newline	return round2secs(&ampres);\newline}\newline","time booth_clk_t is a time since boot or similar, return\newline something humans can understand (rounded seconds only) \newline","4517128","dec_gain.c","Word16 D_GAIN_find_voice_factor(Word16 exc[], Word16 Q_exc,\newline                                Word16 gain_pit, Word16 code[],\newline                                Word16 gain_code, Word16 L_subfr)\newline{\newline\newline   Word32 tmp, ener1, ener2, i;\newline   Word16 exp, exp1, exp2;\newline\newline   ener1 = (D_UTIL_dot_product12(exc, exc, L_subfr, &ampexp1)) &gt&gt 16;\newline   exp1 = (Word16)(exp1 - (Q_exc + Q_exc));\newline   tmp = (gain_pit * gain_pit) &lt&lt 1;\newline   exp = D_UTIL_norm_l(tmp);\newline   tmp = (tmp &lt&lt exp) &gt&gt 16;\newline   ener1 = (ener1 * tmp) &gt&gt 15;\newline   exp1 = (Word16)((exp1 - exp) - 10);   /* 10 -&gt gain_pit Q14 to Q9 */\newline   ener2 = D_UTIL_dot_product12(code, code, L_subfr, &ampexp2) &gt&gt 16;\newline   exp = D_UTIL_norm_s(gain_code);\newline   tmp = gain_code &lt&lt exp;\newline   tmp = (tmp * tmp) &gt&gt 15;\newline   ener2 = (ener2 * tmp) &gt&gt 15;\newline   exp2 = (Word16)(exp2 - (exp &lt&lt 1));\newline   i = exp1 - exp2;\newline\newline   if(i &gt= 0)\newline   {\newline      ener1 = ener1 &gt&gt 1;\newline      ener2 = ener2 &gt&gt (i + 1);\newline   }\newline   else if(i &gt (-16))\newline   {\newline      ener1 = ener1 &gt&gt (1 - i);\newline      ener2 = ener2 &gt&gt 1;\newline   }\newline   else\newline   {\newline      ener1 = 0;\newline      ener2 = ener2 &gt&gt 1;\newline   }\newline\newline   tmp = ener1 - ener2;\newline   ener1 = (ener1 + ener2) + 1;\newline   tmp = (tmp &lt&lt 15) / ener1;\newline\newline   return((Word16)tmp);\newline}\newline","\newline D_GAIN_find_voice_factor\newline \newline Parameters:\newline exc I: pitch excitation\newline Q_exc I: exc format\newline gain_pit I: (Q14) gain of pitch\newline code I: (Q9) fixed codebook excitation\newline gain_code I: (Q0) gain of code\newline L_subfr I: subframe length\newline \newline Function:\newline Find the voicing factor.\newline \newline Returns:\newline (Q15) 1=voice to -1=unvoiced\newline \newline","2842458","bstrlib.c","int bcatblk (bstring b, const unsigned char * s, int len) {\newlinestruct tagbstring t;\newline\newline	if (s == NULL || len &lt 0) return BSTR_ERR;\newline	blk2tbstr (t, s, len);\newline	return bconcat (b, &ampt);\newline}\newline","int bcatblk (bstring b, unsigned char s, int len)\newline \newline Concatenate a fixed length buffer to a bstring.\newline \newline","5923861","library.c","PHP_REDIS_API int redis_sock_connect(RedisSock *redis_sock TSRMLS_DC)\newline{\newline    struct timeval tv, read_tv, *tv_ptr = NULL;\newline    char host[1024], *persistent_id = NULL;\newline    const char *fmtstr = &quot%s:%d&quot;\newline    int host_len, err = 0;\newline    php_netstream_data_t *sock;\newline    int tcp_flag = 1;\newline\newline    if (redis_sock-&gtstream != NULL) {\newline        redis_sock_disconnect(redis_sock TSRMLS_CC);\newline    }\newline\newline    tv.tv_sec  = (time_t)redis_sock-&gttimeout;\newline    tv.tv_usec = (int)((redis_sock-&gttimeout - tv.tv_sec) * 1000000);\newline    if(tv.tv_sec != 0 || tv.tv_usec != 0) {\newline        tv_ptr = &amptv;\newline    }\newline\newline    read_tv.tv_sec  = (time_t)redis_sock-&gtread_timeout;\newline    read_tv.tv_usec = (int)((redis_sock-&gtread_timeout-read_tv.tv_sec)*1000000);\newline\newline    if(redis_sock-&gthost[0] == &#039/&#039 &amp&amp redis_sock-&gtport &lt 1) {\newline        host_len = snprintf(host, sizeof(host), &quotunix://%s&quot, redis_sock-&gthost);\newline    } else {\newline        if(redis_sock-&gtport == 0)\newline            redis_sock-&gtport = 6379;\newline\newline#ifdef HAVE_IPV6\newline        /* If we&#039ve got IPv6 and find a colon in our address, convert to proper\newline         * IPv6 [host]:port format */\newline        if (strchr(redis_sock-&gthost, &#039:&#039) != NULL) {\newline            fmtstr = &quot[%s]:%d&quot;\newline        }\newline#endif\newline        host_len = snprintf(host, sizeof(host), fmtstr, redis_sock-&gthost, redis_sock-&gtport);\newline    }\newline\newline    if (redis_sock-&gtpersistent) {\newline        if (redis_sock-&gtpersistent_id) {\newline            spprintf(&amppersistent_id, 0, &quotphpredis:%s:%s&quot, host, \newline                redis_sock-&gtpersistent_id);\newline        } else {\newline            spprintf(&amppersistent_id, 0, &quotphpredis:%s:%f&quot, host, \newline                redis_sock-&gttimeout);\newline        }\newline    }\newline\newline    redis_sock-&gtstream = php_stream_xport_create(host, host_len, \newline        0, STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\newline        persistent_id, tv_ptr, NULL, NULL, &amperr);\newline\newline    if (persistent_id) {\newline        efree(persistent_id);\newline    }\newline\newline    if (!redis_sock-&gtstream) {\newline        return -1;\newline    }\newline\newline    /* set TCP_NODELAY */\newline    sock = (php_netstream_data_t*)redis_sock-&gtstream-&gtabstract;\newline    setsockopt(sock-&gtsocket, IPPROTO_TCP, TCP_NODELAY, (char *) &amptcp_flag, \newline        sizeof(int));\newline\newline    php_stream_auto_cleanup(redis_sock-&gtstream);\newline\newline    if(tv.tv_sec != 0 || tv.tv_usec != 0) {\newline        php_stream_set_option(redis_sock-&gtstream,PHP_STREAM_OPTION_READ_TIMEOUT,\newline            0, &ampread_tv);\newline    }\newline    php_stream_set_option(redis_sock-&gtstream,\newline        PHP_STREAM_OPTION_WRITE_BUFFER, PHP_STREAM_BUFFER_NONE, NULL);\newline\newline    redis_sock-&gtstatus = REDIS_SOCK_STATUS_CONNECTED;\newline\newline    return 0;\newline}\newline","\newline redis_sock_connect\newline \newline","4974578","lcmaps_credential.c","int lcmaps_credential_store_requested_account(\newline        uid_t *                 puid,\newline        gid_t **                ppgid_list,\newline        int *                   pnpgid,\newline        gid_t **                psgid_list,\newline        int *                   pnsgid,\newline        char **                 ppoolindex,\newline        lcmaps_cred_id_t *      plcmaps_credential\newline)\newline{\newline    if (plcmaps_credential == NULL)\newline    {\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_credential_store_requested_account(): Create lcmaps_cred_id_t first!\\n&quot);\newline        return LCMAPS_CRED_INVOCATION_ERROR;\newline    }\newline    if (lcmaps_account_info_fill(\newline        puid,\newline        ppgid_list,\newline        pnpgid,\newline        psgid_list,\newline        pnsgid,\newline        ppoolindex,\newline        &amp(plcmaps_credential-&gtrequested_account))\newline    )\newline    {\newline        lcmaps_log_debug(1,&quotlcmaps.mod-lcmaps_credential_store_requested_account(): Error storing requested account info\\n&quot);\newline        return LCMAPS_CRED_ERROR;\newline    }\newline\newline    return LCMAPS_CRED_SUCCESS;\newline}\newline","\newlineFunction: lcmaps_credential_store_requested_account()\newlineDescription: stores the requested account (the account that should be verified)\newlinein an lcmaps_account_info_t structure.\newlineParameters:\newlinepuid: pointer to the uid of the local account\newlineppgid_list: pointer to the list of primary gids\newlinepnpgid: pointer to the number of primary gids found\newlinepsgid_list: pointer to the list of secondary gids\newlinepnsgid: pointer to the number of secondary gids found\newlineppoolindex: pointer to the pool index\newlineplcmaps_credential: pointer to lcmaps_credential\newlineReturns: LCMAPS_CRED_SUCCESS: success\newlineLCMAPS_CRED_ERROR: failure, because error filling lcmaps_account_info_t\newlineLCMAPS_CRED_INVOCATION_ERROR: failure, because lcmaps_credential does not exist\newline \newline","2573276","utils.c","void decode_uri(gchar *decoded_uri, const gchar *encoded_uri)\newline{\newline	gchar *dec = decoded_uri;\newline	const gchar *enc = encoded_uri;\newline\newline	while (*enc) {\newline		if (*enc == &#039%&#039) {\newline			enc++;\newline			if (g_ascii_isxdigit((guchar)enc[0]) &amp&amp\newline			    g_ascii_isxdigit((guchar)enc[1])) {\newline				*dec = axtoi(enc);\newline				dec++;\newline				enc += 2;\newline			}\newline		} else {\newline			if (*enc == &#039+&#039)\newline				*dec = &#039 &#039;\newline			else\newline				*dec = *enc;\newline			dec++;\newline			enc++;\newline		}\newline	}\newline\newline	*dec = &#039\\0&#039;\newline}\newline","Decodes URL-Encoded strings (i.e. strings in which spaces are replaced by\newline plusses, and escape characters are used)\newline Note: decoded_uri and encoded_uri can point the same location\newline \newline","1259652","lexer.c","void TY_(FreeNode)( TidyDocImpl* doc, Node *node )\newline{\newline#if !defined(NDEBUG) &amp&amp defined(_MSC_VER) &amp&amp defined(DEBUG_ALLOCATION)\newline    if (node) SPRTF(&quotFree node %p\\n&quot, node );\newline#endif\newline    /* this is no good ;=((\newline    if (node &amp&amp doc &amp&amp doc-&gtlexer) {\newline        if (node == doc-&gtlexer-&gttoken) {\newline            doc-&gtlexer-&gttoken = NULL; // TY_(NewNode)( doc-&gtlexer-&gtallocator, doc-&gtlexer );\newline        }\newline    }\newline      ----------------- */\newline    while ( node )\newline    {\newline        Node* next = node-&gtnext;\newline\newline        TY_(FreeAttrs)( doc, node );\newline        TY_(FreeNode)( doc, node-&gtcontent );\newline        TidyDocFree( doc, node-&gtelement );\newline#ifdef TIDY_STORE_ORIGINAL_TEXT\newline        if (node-&gtotext)\newline            TidyDocFree(doc, node-&gtotext);\newline#endif\newline        if (RootNode != node-&gttype)\newline            TidyDocFree( doc, node );\newline        else\newline            node-&gtcontent = NULL;\newline\newline        node = next;\newline    }\newline}\newline","\newlineFree document nodes by iterating through peers and recursing\newlinethrough children. Set next to NULL before calling TY_(FreeNode)()\newlineto avoid freeing peer nodes. Doesn&#039t patch up prev/next links.\newline \newline","3591099","rthreads.c","bool scond_wait_timeout(scond_t *cond, slock_t *lock, int64_t timeout_us)\newline{\newline#ifdef USE_WIN32_THREADS\newline   DWORD ret;\newline\newline   WaitForSingleObject(cond-&gtevent, 0);\newline   ret = SignalObjectAndWait(lock-&gtlock, cond-&gtevent,\newline         (DWORD)(timeout_us) / 1000, FALSE);\newline\newline   slock_lock(lock);\newline   return ret == WAIT_OBJECT_0;\newline#else\newline   int ret;\newline   int64_t seconds, remainder;\newline   struct timespec now = {0};\newline\newline#ifdef __MACH__\newline   /* OSX doesn&#039t have clock_gettime. */\newline   clock_serv_t cclock;\newline   mach_timespec_t mts;\newline\newline   host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &ampcclock);\newline   clock_get_time(cclock, &ampmts);\newline   mach_port_deallocate(mach_task_self(), cclock);\newline   now.tv_sec = mts.tv_sec;\newline   now.tv_nsec = mts.tv_nsec;\newline#elif defined(__CELLOS_LV2__)\newline   sys_time_sec_t s;\newline   sys_time_nsec_t n;\newline\newline   sys_time_get_current_time(&amps, &ampn);\newline   now.tv_sec  = s;\newline   now.tv_nsec = n;\newline#elif defined(__mips__) || defined(VITA)\newline   struct timeval tm;\newline\newline   gettimeofday(&amptm, NULL);\newline   now.tv_sec = tm.tv_sec;\newline   now.tv_nsec = tm.tv_usec * 1000;\newline#elif defined(RETRO_WIN32_USE_PTHREADS)\newline   _ftime64_s(&ampnow);\newline#elif !defined(GEKKO)\newline   /* timeout on libogc is duration, not end time. */\newline   clock_gettime(CLOCK_REALTIME, &ampnow);\newline#endif\newline\newline   seconds      = timeout_us / INT64_C(1000000);\newline   remainder    = timeout_us % INT64_C(1000000);\newline\newline   now.tv_sec  += seconds;\newline   now.tv_nsec += remainder * INT64_C(1000);\newline\newline   ret = pthread_cond_timedwait(&ampcond-&gtcond, &amplock-&gtlock, &ampnow);\newline   return (ret == 0);\newline#endif\newline}\newline","\newline scond_wait_timeout:\newline @cond : pointer to condition variable object \newline @lock : pointer to mutex object \newline @timeout_us : timeout (in microseconds)\newline \newline Try to block on a condition variable (i.e. wait on a condition) until\newline @timeout_us elapses.\newline \newline Returns: false (0) if timeout elapses before condition variable is\newline signaled or broadcast, otherwise true (1).\newline \newline","3749922","res_xmpp.c","static int xmpp_pak_presence(struct ast_xmpp_client *client, struct ast_xmpp_client_config *cfg, iks *node, ikspak *pak)\newline{\newline	struct ast_xmpp_buddy *buddy;\newline	struct ast_xmpp_resource *resource;\newline	char *type = iks_find_attrib(pak-&gtx, &quottype&quot);\newline	int status = pak-&gtshow ? pak-&gtshow : STATUS_DISAPPEAR;\newline	enum ast_device_state state = AST_DEVICE_UNAVAILABLE;\newline\newline	/* If this is a component presence probe request answer immediately with our presence status */\newline	if (ast_test_flag(&ampcfg-&gtflags, XMPP_COMPONENT) &amp&amp !ast_strlen_zero(type) &amp&amp !strcasecmp(type, &quotprobe&quot)) {\newline		xmpp_client_set_presence(client, pak-&gtfrom-&gtfull, iks_find_attrib(pak-&gtx, &quotto&quot), cfg-&gtstatus, cfg-&gtstatusmsg);\newline	}\newline\newline	/* If no resource is available this is a general buddy presence update, which we will ignore */\newline	if (!pak-&gtfrom-&gtresource) {\newline		return 0;\newline	}\newline\newline	if (!(buddy = ao2_find(client-&gtbuddies, pak-&gtfrom-&gtpartial, OBJ_KEY))) {\newline		/* Only output the message if it is not about us */\newline		if (strcmp(client-&gtjid-&gtpartial, pak-&gtfrom-&gtpartial)) {\newline			ast_log(LOG_WARNING, &quotReceived presence information about &#039%s&#039 despite not having them in roster on client &#039%s&#039\\n&quot,\newline				pak-&gtfrom-&gtpartial, client-&gtname);\newline		}\newline		return 0;\newline	}\newline\newline	ao2_lock(buddy-&gtresources);\newline\newline	if (!(resource = ao2_callback(buddy-&gtresources, OBJ_NOLOCK, xmpp_resource_cmp, pak-&gtfrom-&gtresource))) {\newline		/* Only create the new resource if it is not going away - in reality this should not happen */\newline		if (status != STATUS_DISAPPEAR) {\newline			if (!(resource = ao2_alloc(sizeof(*resource), xmpp_resource_destructor))) {\newline				ast_log(LOG_ERROR, &quotCould not allocate resource object for resource &#039%s&#039 of buddy &#039%s&#039 on client &#039%s&#039\\n&quot,\newline					pak-&gtfrom-&gtresource, buddy-&gtid, client-&gtname);\newline				ao2_unlock(buddy-&gtresources);\newline				ao2_ref(buddy, -1);\newline				return 0;\newline			}\newline\newline			ast_copy_string(resource-&gtresource, pak-&gtfrom-&gtresource, sizeof(resource-&gtresource));\newline		}\newline	} else {\newline		/* We unlink the resource in case the priority changes or in case they are going away */\newline		ao2_unlink_flags(buddy-&gtresources, resource, OBJ_NOLOCK);\newline	}\newline\newline	/* Only update the resource and add it back in if it is not going away */\newline	if (resource &amp&amp (status != STATUS_DISAPPEAR)) {\newline		char *node, *ver;\newline\newline		/* Try to get the XMPP spec node, and fall back to Google if not found */\newline		if (!(node = iks_find_attrib(iks_find(pak-&gtx, &quotc&quot), &quotnode&quot))) {\newline			node = iks_find_attrib(iks_find(pak-&gtx, &quotcaps:c&quot), &quotnode&quot);\newline		}\newline\newline		if (!(ver = iks_find_attrib(iks_find(pak-&gtx, &quotc&quot), &quotver&quot))) {\newline			ver = iks_find_attrib(iks_find(pak-&gtx, &quotcaps:c&quot), &quotver&quot);\newline		}\newline\newline		if (resource-&gtdescription) {\newline			ast_free(resource-&gtdescription);\newline		}\newline\newline		if ((node &amp&amp strcmp(resource-&gtcaps.node, node)) || (ver &amp&amp strcmp(resource-&gtcaps.version, ver))) {\newline			/* For interoperability reasons, proceed even if the resource fails to provide node or version */\newline			if (node) {\newline				ast_copy_string(resource-&gtcaps.node, node, sizeof(resource-&gtcaps.node));\newline			}\newline			if (ver) {\newline				ast_copy_string(resource-&gtcaps.version, ver, sizeof(resource-&gtcaps.version));\newline			}\newline\newline			/* Google Talk places the capabilities information directly in presence, so see if it is there */\newline			if (iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://www.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://www.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://www.android.com/gtalk/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://www.android.com/gtalk/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotc&quot, &quotnode&quot, &quothttp://mail.google.com/xmpp/client/caps&quot) ||\newline			    iks_find_with_attrib(pak-&gtx, &quotcaps:c&quot, &quotnode&quot, &quothttp://mail.google.com/xmpp/client/caps&quot)) {\newline				resource-&gtcaps.google = 1;\newline			}\newline\newline			/* To discover if the buddy supports Jingle we need to query, so do so */\newline			if (xmpp_client_send_disco_info_request(client, pak-&gtfrom-&gtfull, client-&gtjid-&gtfull)) {\newline				ast_log(LOG_WARNING, &quotCould not send discovery information request to resource &#039%s&#039 of buddy &#039%s&#039 on client &#039%s&#039, capabilities may be incomplete\\n&quot, resource-&gtresource, buddy-&gtid, client-&gtname);\newline			}\newline		}\newline\newline		resource-&gtstatus = status;\newline		resource-&gtdescription = ast_strdup(iks_find_cdata(pak-&gtx, &quotstatus&quot));\newline		resource-&gtpriority = atoi((iks_find_cdata(pak-&gtx, &quotpriority&quot)) ? iks_find_cdata(pak-&gtx, &quotpriority&quot) : &quot0&quot);\newline\newline		ao2_link_flags(buddy-&gtresources, resource, OBJ_NOLOCK);\newline\newline		manager_event(EVENT_FLAG_USER, &quotJabberStatus&quot,\newline			      &quotAccount: %s\\r\\nJID: %s\\r\\nResource: %s\\r\\nStatus: %d\\r\\nPriority: %d&quot\newline			      &quot\\r\\nDescription: %s\\r\\n&quot,\newline			      client-&gtname, pak-&gtfrom-&gtpartial, resource-&gtresource, resource-&gtstatus,\newline			      resource-&gtpriority, S_OR(resource-&gtdescription, &quot&quot));\newline\newline		ao2_ref(resource, -1);\newline	} else {\newline		/* This will get hit by presence coming in for an unknown resource, and also when a resource goes away */\newline		if (resource) {\newline			ao2_ref(resource, -1);\newline		}\newline\newline		manager_event(EVENT_FLAG_USER, &quotJabberStatus&quot,\newline			      &quotAccount: %s\\r\\nJID: %s\\r\\nStatus: %u\\r\\n&quot,\newline			      client-&gtname, pak-&gtfrom-&gtpartial, pak-&gtshow ? pak-&gtshow : IKS_SHOW_UNAVAILABLE);\newline	}\newline\newline	/* Determine if at least one resource is available for device state purposes */\newline	if ((resource = ao2_callback(buddy-&gtresources, OBJ_NOLOCK, xmpp_resource_is_available, NULL))) {\newline		state = AST_DEVICE_NOT_INUSE;\newline		ao2_ref(resource, -1);\newline	}\newline\newline	ao2_unlock(buddy-&gtresources);\newline\newline	ao2_ref(buddy, -1);\newline\newline	ast_devstate_changed(state, AST_DEVSTATE_CACHABLE, &quotXMPP/%s/%s&quot, client-&gtname, pak-&gtfrom-&gtpartial);\newline\newline	return 0;\newline}\newline","! \\brief Internal function called when a presence message is received \newline","2532131","output.c","static void print_verbose_error(struct file_info *info)\newline{\newline	char actual[130], expected[130];\newline	assert(HC_FAILED(info-&gthc.flags));\newline\newline	fprintf(rhash_data.out, _(&quotERROR&quot));\newline\newline	if (HC_WRONG_FILESIZE &amp info-&gthc.flags) {\newline		sprintI64(actual, info-&gtrctx-&gtmsg_size, 0);\newline		sprintI64(expected, info-&gthc.file_size, 0);\newline		fprintf(rhash_data.out, _(&quot, size is %s should be %s&quot), actual, expected);\newline	}\newline\newline	if (HC_WRONG_EMBCRC32 &amp info-&gthc.flags) {\newline		rhash_print(expected, info-&gtrctx, RHASH_CRC32, RHPR_UPPERCASE);\newline		fprintf(rhash_data.out, _(&quot, embedded CRC32 should be %s&quot), expected);\newline	}\newline\newline	if (HC_WRONG_HASHES &amp info-&gthc.flags) {\newline		int i;\newline		unsigned reported = 0;\newline		for (i = 0; i &lt info-&gthc.hashes_num; i++) {\newline			hash_value *hv = &ampinfo-&gthc.hashes[i];\newline			char *expected_hash = info-&gthc.data + hv-&gtoffset;\newline			unsigned hid = hv-&gthash_id;\newline			int pflags;\newline			if ((info-&gthc.wrong_hashes &amp (1 &lt&lt i)) == 0) continue;\newline\newline			assert(hid != 0);\newline\newline			/* if can&#039t detect precise hash */\newline			if ((hid &amp (hid - 1)) != 0) {\newline				/* guess the hash id */\newline				if (hid &amp opt.sum_flags) hid &amp= opt.sum_flags;\newline				if (hid &amp ~info-&gthc.found_hash_ids) hid &amp= ~info-&gthc.found_hash_ids;\newline				if (hid &amp ~reported) hid &amp= ~reported; /* avoiding repeating */\newline				if (hid &amp REPORT_FIRST_MASK) hid &amp= REPORT_FIRST_MASK;\newline				hid &amp= -(int)hid; /* take the lowest bit */\newline			}\newline			assert(hid != 0 &amp&amp (hid &amp (hid - 1)) == 0); /* single bit only */\newline			reported |= hid;\newline\newline			pflags = (hv-&gtlength == (rhash_get_digest_size(hid) * 2) ?\newline				(RHPR_HEX | RHPR_UPPERCASE) : (RHPR_BASE32 | RHPR_UPPERCASE));\newline			rhash_print(actual, info-&gtrctx, hid, pflags);\newline			fprintf(rhash_data.out, _(&quot, %s is %s should be %s&quot),\newline				rhash_get_name(hid), actual, expected_hash);\newline		}\newline	}\newline\newline	fprintf(rhash_data.out, &quot\\n&quot);\newline}\newline","\newline Print verbose error on hash sums mismatch.\newline \newline @param info file information with path and its hash sums.\newline \newline","2162075","mboxkey.c","static int mboxkey_merge_cb(void *rockp,\newline			 const char *key, size_t keylen,\newline			 const char *tmpdata, size_t tmpdatalen) \newline{\newline    int r;\newline    struct mboxkey_merge_rock *rockdata = (struct mboxkey_merge_rock *)rockp;\newline    struct db *tgtdb = rockdata-&gtdb;\newline    const char *tgtdata;\newline    size_t tgtdatalen;\newline\newline    if (!tgtdb) return IMAP_INTERNAL;\newline\newline    r = cyrusdb_fetchlock(tgtdb, key, keylen, &amptgtdata, &amptgtdatalen,\newline		      &amp(rockdata-&gttid));\newline    if(!r &amp&amp tgtdata) {\newline	unsigned short version, s;\newline	const char *tmp = tmpdata, *tgt = tgtdata;\newline	\newline	/* get version */\newline	memcpy(&amps, tgt, sizeof(s));\newline	version = ntohs(s);\newline	assert(version == MBOXKEY_VERSION);\newline\newline	/* get version */\newline	memcpy(&amps, tmp, sizeof(s));\newline	version = ntohs(s);\newline	assert(version == MBOXKEY_VERSION);\newline    }\newline    \newline    return cyrusdb_store(tgtdb, key, keylen, tmpdata, tmpdatalen,\newline		     &amp(rockdata-&gttid));\newline}\newline","Copy keys from tmp file to tgt file.\newline \newline XXX We currently have nothing to compare against.\newline \newline","6394726","mgx11windows.c","void Xmg_sortdisplaylist()\newline{\newline  static int *primp;\newline\newline  if (_mgx11c-&gtsortmethod == MG_DEPTH)\newline    {\newline      primp = VVEC(_mgx11c-&gtmysort-&gtprimsort, int);\newline      qsort(primp, _mgx11c-&gtmysort-&gtcprim, sizeof(int), &ampXmg_primcomp);\newline    }\newline}\newline","\newlineFunction: Xmg_sortdisplaylist\newlineDescription: Does depth sorting of primitives.\newlineAuthor: Daeron Meyer\newline \newline","4227482","stream_dvdnav.c","int mp_dvdnav_spu_has_changed (stream_t *stream, int clear) {\newline  dvdnav_priv_t *priv =  stream-&gtpriv;\newline\newline  if (!(priv-&gtstate &amp NAV_FLAG_SPU_CHANGE))\newline    return 0;\newline\newline  if (clear)\newline    priv-&gtstate &amp= ~NAV_FLAG_SPU_CHANGE;\newline\newline  return 1;\newline}\newline","\newline \\brief Check if SPU has changed\newline \\param stream: - stream pointer\newline \\param clear : - if true, then clear spu change flag\newline \\return 1 if spu has changed\newline \newline","","","","on","","","","","","","","","","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","","Request contents of log","Find the voicing factor.","Concatenate a fixed length buffer to a bstring.","{}","stores the requested account (the account that should be verified)","replaced by plusses, and escape characters","iterating through peers and recursing through children.","Try to block on a condition variable","Internal function called when a presence message is received","Print verbose error on hash sums mismatch.","Copy keys from tmp file to tgt file.","returns interleaved subframe destination address","Does depth sorting of primitives.","clear spu change flag","returns the selection of the password characters template combobox","Change the comment stored on the server","Decrypt and compare the tag with OCB.","Remove from the current line a start comment","prevents us from needing to use curses.h","validate a variable name","return something humans can understand"
"3VIVIU06FKCFZZS9HT2VU0YUYL3MIK","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","33FBRBDW6OZBOR1YLK1R3YVTHZTC8N","AVC62JNYAXA45","Approved","Wed Apr 17 14:09:21 PDT 2019","Wed Apr 17 14:28:03 PDT 2019","Fri Apr 19 14:28:03 PDT 2019","2019-04-19 21:28:21 UTC","","","1122","100% (24/24)","100% (24/24)","100% (24/24)","1281952","pthread_internal.c","static void pthread_handle_sigrestart(int sig) {\newline  _pthread_descr this=__thread_self();\newline  this-&gtp_sig=sig;\newline#ifdef DEBUG\newline  printf(&quotpthread_handle_sigrestart(%d) in %d\\n&quot,sig,this-&gtpid);\newline#endif\newline}\newline","restart signal handler \newline","4488551","g_cmds.c","void StopFollowing( gentity_t *ent ) {\newline	if(g_gametype.integer&ltGT_ELIMINATION || g_gametype.integer&gtGT_LMS)\newline	{\newline		//Shouldn&#039t this already be the case?\newline		ent-&gtclient-&gtps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;	\newline		ent-&gtclient-&gtsess.sessionTeam = TEAM_SPECTATOR;	\newline	}\newline	else {\newline		ent-&gtclient-&gtps.stats[STAT_HEALTH] = 0;\newline		ent-&gthealth = 0;\newline	}\newline	ent-&gtclient-&gtsess.spectatorState = SPECTATOR_FREE;\newline	ent-&gtclient-&gtps.pm_flags &amp= ~PMF_FOLLOW;\newline	ent-&gtr.svFlags &amp= ~SVF_BOT;\newline	ent-&gtclient-&gtps.clientNum = ent - g_entities;\newline}\newline","\newline=================\newlineStopFollowing\newlineIf the client being followed leaves the game, or you just want to drop\newlineto free floating spectator mode\newline=================\newline \newline","5281126","lj_ir.c","int lj_ir_numcmp(lua_Number a, lua_Number b, IROp op)\newline{\newline  switch (op) {\newline  case IR_EQ: return (a == b);\newline  case IR_NE: return (a != b);\newline  case IR_LT: return (a &lt b);\newline  case IR_GE: return (a &gt= b);\newline  case IR_LE: return (a &lt= b);\newline  case IR_GT: return (a &gt b);\newline  case IR_ULT: return !(a &gt= b);\newline  case IR_UGE: return !(a &lt b);\newline  case IR_ULE: return !(a &gt b);\newline  case IR_UGT: return !(a &lt= b);\newline  default: lua_assert(0); return 0;\newline  }\newline}\newline","Evaluate numeric comparison. \newline","690512","ipepage.cpp","void Page::removeLayer(String name)\newline{\newline  int index = findLayer(name);\newline  assert(iLayers.size() &gt 1 &amp&amp index &gt= 0);\newline  for (ObjSeq::iterator it = iObjects.begin(); it != iObjects.end(); ++it) {\newline    int k = it-&gtiLayer;\newline    assert(k != index);\newline    if (k &gt index)\newline      it-&gtiLayer = k-1;\newline  }\newline  iLayers.erase(iLayers.begin() + index);\newline}\newline","! All objects are adjusted. Panics if there are objects in the\newlinedeleted layer, of if it is the only layer.\newline \newline","2531936","torrent.c","static void bt_generate_torrent(torrent_ctx *ctx)\newline{\newline	uint64_t total_size = 0;\newline	size_t info_start_pos;\newline\newline	assert(ctx-&gtcontent.str == NULL);\newline\newline	if (ctx-&gtpiece_length == 0) {\newline		if (ctx-&gtfiles.size == 1) {\newline			total_size = ((bt_file_info*)ctx-&gtfiles.array[0])-&gtsize;\newline		}\newline		ctx-&gtpiece_length = bt_default_piece_length(total_size);\newline	}\newline\newline	if ((ctx-&gtoptions &amp BT_OPT_INFOHASH_ONLY) == 0) {\newline		/* write the torrent header */\newline		bt_str_append(ctx, &quotd&quot);\newline		if (ctx-&gtannounce.array &amp&amp ctx-&gtannounce.size &gt 0) {\newline			bt_bencode_str(ctx, &quot8:announce&quot, ctx-&gtannounce.array[0]);\newline\newline			/* if more than one announce url */\newline			if (ctx-&gtannounce.size &gt 1) {\newline				/* add the announce-list key-value pair */\newline				size_t i;\newline				bt_str_append(ctx, &quot13:announce-listll&quot);\newline\newline				for (i = 0; i &lt ctx-&gtannounce.size; i++) {\newline					if (i &gt 0) {\newline						bt_str_append(ctx, &quotel&quot);\newline					}\newline					bt_bencode_str(ctx, 0, ctx-&gtannounce.array[i]);\newline				}\newline				bt_str_append(ctx, &quotee&quot);\newline			}\newline		}\newline\newline		if (ctx-&gtprogram_name) {\newline			bt_bencode_str(ctx, &quot10:created by&quot, ctx-&gtprogram_name);\newline		}\newline		bt_bencode_int(ctx, &quot13:creation date&quot, (uint64_t)time(NULL));\newline\newline		bt_str_append(ctx, &quot8:encoding5:UTF-8&quot);\newline	}\newline\newline	/* write the essential for BTIH part of the torrent file */\newline\newline	bt_str_append(ctx, &quot4:infod&quot); /* start the info dictionary */\newline	info_start_pos = ctx-&gtcontent.length - 1;\newline\newline	if (ctx-&gtfiles.size &gt 1) {\newline		size_t i;\newline\newline		/* process batch torrent */\newline		bt_str_append(ctx, &quot5:filesl&quot); /* start list of files */\newline\newline		/* write length and path for each file in the batch */\newline		for (i = 0; i &lt ctx-&gtfiles.size; i++) {\newline			bt_file_info_append(ctx, &quotd6:length&quot, &quot4:pathl&quot,\newline				(bt_file_info*)ctx-&gtfiles.array[i]);\newline			bt_str_append(ctx, &quotee&quot);\newline		}\newline		/* note: get_batch_name modifies path, so should be called here */\newline		bt_bencode_str(ctx, &quote4:name&quot, get_batch_name(\newline			((bt_file_info*)ctx-&gtfiles.array[0])-&gtpath));\newline	}\newline	else if (ctx-&gtfiles.size &gt 0) {\newline		/* write size and basename of the first file */\newline		/* in the non-batch mode other files are ignored */\newline		bt_file_info_append(ctx, &quot6:length&quot, &quot4:name&quot,\newline			(bt_file_info*)ctx-&gtfiles.array[0]);\newline	}\newline\newline	bt_bencode_int(ctx, &quot12:piece length&quot, ctx-&gtpiece_length);\newline	bt_str_append(ctx, &quot6:pieces&quot);\newline	bt_bencode_pieces(ctx);\newline\newline	if (ctx-&gtoptions &amp BT_OPT_PRIVATE) {\newline		bt_str_append(ctx, &quot7:privatei1e&quot);\newline	}\newline	bt_str_append(ctx, &quotee&quot);\newline\newline	/* calculate BTIH */\newline	SHA1_INIT(ctx);\newline	SHA1_UPDATE(ctx, (unsigned char*)ctx-&gtcontent.str + info_start_pos,\newline		ctx-&gtcontent.length - info_start_pos - 1);\newline	SHA1_FINAL(ctx, ctx-&gtbtih);\newline}\newline","\newline Generate torrent file content\newline @see http://wiki.theory.org/BitTorrentSpecification\newline \newline @param ctx the torrent algorithm context\newline \newline","242558","trigger.c","TriggerStep *sqliteTriggerDeleteStep(Token *pTableName, Expr *pWhere){\newline  TriggerStep *pTriggerStep = sqliteMalloc(sizeof(TriggerStep));\newline  if( pTriggerStep==0 ) return 0;\newline\newline  pTriggerStep-&gtop = TK_DELETE;\newline  pTriggerStep-&gttarget  = *pTableName;\newline  pTriggerStep-&gtpWhere = pWhere;\newline  pTriggerStep-&gtorconf = OE_Default;\newline  sqlitePersistTriggerStep(pTriggerStep);\newline\newline  return pTriggerStep;\newline}\newline","\newline Construct a trigger step that implements a DELETE statement and return\newline a pointer to that trigger step. The parser calls this routine when it\newline sees a DELETE statement inside the body of a CREATE TRIGGER.\newline \newline","3496629","xsendstring.cpp","int ErrorHandler(Display *my_dpy, XErrorEvent *event) {\newline  char xmsg[512] = { 0 };\newline\newline  XGetErrorText(my_dpy, event-&gterror_code, xmsg, NumberOf(xmsg) - 1);\newline\newline  g_xerrormsg &lt&lt &quotX error (&quot &lt&lt event-&gtrequest_code &lt&lt &quot): &quot &lt&lt xmsg\newline              &lt&lt std::endl;\newline  return 0;\newline}\newline","\newline ErrorHandler will be called when X detects an error. This function\newline just saves the error message text\newline \newline","4756747","test_functions.c","struct cgroup *create_new_cgroup_ds(int ctl, const char *grpname,\newline	 int value_type, struct cntl_val_t cval, struct uid_gid_t ids, int i)\newline{\newline	int retval;\newline	char group[FILENAME_MAX];\newline	char controller_name[FILENAME_MAX], control_file[FILENAME_MAX];\newline\newline	strncpy(group, grpname, sizeof(group));\newline	retval = set_controller(ctl, controller_name, control_file);\newline	if (retval) {\newline		fprintf(stderr, &quotSetting controller failled\\n&quot);\newline		return NULL;\newline	}\newline\newline	switch (ctl) {\newline		/* control values are controller specific, so will be set\newline		 * accordingly from the config file */\newline	case CPU:\newline		strncpy(cval.val_string, &quot260000&quot, sizeof(cval.val_string));\newline		break;\newline\newline	case MEMORY:\newline		strncpy(cval.val_string, &quot7000064&quot, sizeof(cval.val_string));\newline		break;\newline\newline	/* To be added for other controllers */\newline	default:\newline		printf(&quotInvalid controller name passed. Setting control value&quot\newline					&quot failed. Dependent tests may fail\\n&quot);\newline		return NULL;\newline		break;\newline	}\newline\newline	return new_cgroup(group, controller_name, control_file,\newline						 value_type, cval, ids, i);\newline}\newline","\newline This function creates a cgroup data structure\newline This function is a bit ugly for now and need to be changed\newline @param ctl the controller under which group is to be created\newline @param grpname the name of the group\newline @param value_type which value out of four types\newline @param struct cval the control value structure\newline @param struct ids the permissions struct\newline @param the test number\newline \newline","3067387","qwt_thermo.cpp","void QwtThermo::setAlarmLevel(double level)\newline{\newline    d_data-&gtalarmLevel = level;\newline    d_data-&gtalarmEnabled = 1;\newline    update();\newline}\newline","! \newlineSpecify the alarm threshold.\newline\\param level Alarm threshold\newline\\sa alarmLevel()\newline \newline","5266440","config-table.c","struct config_table_t *nubase_config_table_set(struct llist_head *config_table_list, char *key, char *value)\newline{\newline	struct config_table_t *config_table;\newline\newline	/* It does not exists so we use _append*/\newline	if ( ! nubase_config_table_get(config_table_list, key) ) {\newline		return nubase_config_table_append(config_table_list, key, value);\newline	}\newline\newline	{\newline		struct llist_head *pos;\newline		llist_for_each(pos, config_table_list) {\newline			config_table = llist_entry(pos, struct config_table_t, list);\newline			if (!strncmp(key, config_table-&gtkey, strlen(config_table-&gtkey))) {\newline				llist_del(&ampconfig_table-&gtlist);\newline				return nubase_config_table_append(config_table_list, key, value);\newline			}\newline		}\newline	}\newline\newline	return NULL;\newline}\newline","Similar to nubase_config_table_append,\newline but does not check for existing value\newline and if it exists, free() it \newline","6158391","read_sh.c","int MPI_File_read_shared(MPI_File fh, void *buf, int count, \newline                  MPI_Datatype datatype, MPI_Status *status)\newline{\newline    int error_code, bufsize, buftype_is_contig, filetype_is_contig;\newline#ifndef PRINT_ERR_MSG\newline    static char myname[] = &quotMPI_FILE_READ_SHARED&quot;\newline#endif\newline    int datatype_size, incr;\newline    ADIO_Offset off, shared_fp;\newline\newline#ifdef PRINT_ERR_MSG\newline    if ((fh &lt= (MPI_File) 0) || (fh-&gtcookie != ADIOI_FILE_COOKIE)) {\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Invalid file handle\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline    }\newline#else\newline    ADIOI_TEST_FILE_HANDLE(fh, myname);\newline#endif\newline\newline    if (count &lt 0) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Invalid count argument\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);\newline#endif\newline    }\newline\newline    if (datatype == MPI_DATATYPE_NULL) {\newline#ifdef PRINT_ERR_MSG\newline        FPRINTF(stderr, &quotMPI_File_read_shared: Invalid datatype\\n&quot);\newline        MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);	    \newline#endif\newline    }\newline\newline    MPI_Type_size(datatype, &ampdatatype_size);\newline    if (count*datatype_size == 0) return MPI_SUCCESS;\newline\newline    if ((count*datatype_size) % fh-&gtetype_size != 0) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Only an integral number of etypes can be accessed\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);	    \newline#endif\newline    }\newline\newline    if ((fh-&gtfile_system == ADIO_PIOFS) || (fh-&gtfile_system == ADIO_PVFS)) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Shared file pointer not supported on PIOFS and PVFS\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, \newline                    MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);\newline#endif\newline    }\newline\newline    ADIOI_Datatype_iscontig(datatype, &ampbuftype_is_contig);\newline    ADIOI_Datatype_iscontig(fh-&gtfiletype, &ampfiletype_is_contig);\newline\newline    incr = (count*datatype_size)/fh-&gtetype_size;\newline    ADIO_Get_shared_fp(fh, incr, &ampshared_fp, &amperror_code);\newline    if (error_code != MPI_SUCCESS) {\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Error! Could not access shared file pointer.\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline    }\newline\newline    /* contiguous or strided? */\newline    if (buftype_is_contig &amp&amp filetype_is_contig) {\newline	/* convert count and shared_fp to bytes */\newline        bufsize = datatype_size * count;\newline        off = fh-&gtdisp + fh-&gtetype_size * shared_fp;\newline\newline        /* if atomic mode requested, lock (exclusive) the region, because there\newline           could be a concurrent noncontiguous request. On NFS, locking \newline           is done in the ADIO_ReadContig.*/\newline\newline        if ((fh-&gtatomicity) &amp&amp (fh-&gtfile_system != ADIO_NFS))\newline            ADIOI_WRITE_LOCK(fh, off, SEEK_SET, bufsize);\newline\newline        ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,\newline                        off, status, &amperror_code); \newline\newline        if ((fh-&gtatomicity) &amp&amp (fh-&gtfile_system != ADIO_NFS))\newline            ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);\newline    }\newline    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,\newline                          shared_fp, status, &amperror_code); \newline    /* For strided and atomic mode, locking is done in ADIO_ReadStrided */\newline\newline    return error_code;\newline}\newline","@\newlineMPI_File_read_shared - Read using shared file pointer\newlineInput Parameters:\newline. fh - file handle (handle)\newline. count - number of elements in buffer (nonnegative integer)\newline. datatype - datatype of each buffer element (handle)\newlineOutput Parameters:\newline. buf - initial address of buffer (choice)\newline. status - status object (Status)\newline.N fortran\newline@ \newline","3731702","hfs.c","long hfs_lseek(hfsfile *file, long offset, int from)\newline{\newline  unsigned long *lglen;\newline  long newpos;\newline\newline  f_getptrs(file, &amplglen, 0, 0);\newline\newline  switch (from)\newline    {\newline    case SEEK_SET:\newline      newpos = offset;\newline      break;\newline\newline    case SEEK_CUR:\newline      newpos = file-&gtpos + offset;\newline      break;\newline\newline    case SEEK_END:\newline      newpos = *lglen + offset;\newline      break;\newline\newline    default:\newline      ERROR(EINVAL, 0);\newline      return -1;\newline    }\newline\newline  if (newpos &lt 0)\newline    newpos = 0;\newline  else if (newpos &gt *lglen)\newline    newpos = *lglen;\newline\newline  file-&gtpos = newpos;\newline\newline  return newpos;\newline}\newline","\newline NAME: hfs-&gtlseek()\newline DESCRIPTION: change file seek pointer\newline \newline","6267469","adouble.cpp","adub floor ( const badouble&amp x ) {\newline    ADOLC_OPENMP_THREAD_NUMBER;\newline    ADOLC_OPENMP_GET_THREAD_NUMBER;\newline    locint locat=next_loc();\newline\newline    double coval =\newline        ADOLC_MATH_NSP::floor(ADOLC_GLOBAL_TAPE_VARS.store[x.loc()]);\newline\newline    if (ADOLC_CURRENT_TAPE_INFOS.traceFlag) { // old: write_args_d_a(floor_op,locat,coval,x.loc());\newline        put_op(floor_op);\newline        ADOLC_PUT_LOCINT(x.loc()); // = arg\newline        ADOLC_PUT_LOCINT(locat);      // = res\newline        ADOLC_PUT_VAL(coval);         // = coval\newline\newline        ++ADOLC_CURRENT_TAPE_INFOS.numTays_Tape;\newline        if (ADOLC_CURRENT_TAPE_INFOS.keepTaylors)\newline            ADOLC_WRITE_SCAYLOR(ADOLC_GLOBAL_TAPE_VARS.store[locat]);\newline    }\newline\newline    ADOLC_GLOBAL_TAPE_VARS.store[locat] = coval;\newline    return locat;\newline}\newline","Floor function (NOTE: This function is nondifferentiable) \newline","4943178","chcpu.c","static int cpu_enable(cpu_set_t *cpu_set, size_t setsize, int enable)\newline{\newline	unsigned int cpu;\newline	int online, rc;\newline	int configured = -1;\newline	size_t fails = 0;\newline\newline	for (cpu = 0; cpu &lt setsize; cpu++) {\newline		if (!CPU_ISSET(cpu, cpu_set))\newline			continue;\newline		if (!path_exist(_PATH_SYS_CPU &quot/cpu%d&quot, cpu)) {\newline			warnx(_(&quotCPU %u does not exist&quot), cpu);\newline			fails++;\newline			continue;\newline		}\newline		if (!path_exist(_PATH_SYS_CPU &quot/cpu%d/online&quot, cpu)) {\newline			warnx(_(&quotCPU %u is not hot pluggable&quot), cpu);\newline			fails++;\newline			continue;\newline		}\newline		online = path_read_s32(_PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline		if ((online == 1) &amp&amp (enable == 1)) {\newline			printf(_(&quotCPU %u is already enabled\\n&quot), cpu);\newline			continue;\newline		}\newline		if ((online == 0) &amp&amp (enable == 0)) {\newline			printf(_(&quotCPU %u is already disabled\\n&quot), cpu);\newline			continue;\newline		}\newline		if (path_exist(_PATH_SYS_CPU &quot/cpu%d/configure&quot, cpu))\newline			configured = path_read_s32(_PATH_SYS_CPU &quot/cpu%d/configure&quot, cpu);\newline		if (enable) {\newline			rc = path_write_str(&quot1&quot, _PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline			if ((rc == -1) &amp&amp (configured == 0)) {\newline				warn(_(&quotCPU %u enable failed (CPU is deconfigured)&quot), cpu);\newline				fails++;\newline			} else if (rc == -1) {\newline				warn(_(&quotCPU %u enable failed&quot), cpu);\newline				fails++;\newline			} else\newline				printf(_(&quotCPU %u enabled\\n&quot), cpu);\newline		} else {\newline			if (onlinecpus &amp&amp num_online_cpus() == 1) {\newline				warnx(_(&quotCPU %u disable failed (last enabled CPU)&quot), cpu);\newline				fails++;\newline				continue;\newline			}\newline			rc = path_write_str(&quot0&quot, _PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline			if (rc == -1) {\newline				warn(_(&quotCPU %u disable failed&quot), cpu);\newline				fails++;\newline			} else {\newline				printf(_(&quotCPU %u disabled\\n&quot), cpu);\newline				if (onlinecpus)\newline					CPU_CLR(cpu, onlinecpus);\newline			}\newline		}\newline	}\newline\newline	return fails == 0 ? 0 : fails == setsize ? -1 : 1;\newline}\newline","returns: 0 = success\newline &lt 0 = failure\newline &gt 0 = partial success\newline \newline","2011681","calcalcs.c","int ccs_dayssince( calcalcs_cal *calendar_orig, int year_orig, int month_orig, int day_orig,\newline		int ndays_since, calcalcs_cal *calendar_new, int *year_new, int *month_new, int *day_new )\newline{\newline	int		ierr, jd0, jd1;\newline	calcalcs_cal	*c2use_orig, *c2use_new;\newline\newline	if( calendar_orig == NULL ) return(CALCALCS_ERR_NULL_CALENDAR);\newline	if( calendar_orig-&gtsig != CCS_VALID_SIG ) return(CALCALCS_ERR_INVALID_CALENDAR);\newline\newline	if( calendar_new == NULL ) return(CALCALCS_ERR_NULL_CALENDAR);\newline	if( calendar_new-&gtsig != CCS_VALID_SIG ) return(CALCALCS_ERR_INVALID_CALENDAR);\newline\newline	/* Figure out which calendar of the ORIGINAL calendar to use if it&#039s a mixed calendar\newline	 */\newline	if( calendar_orig-&gtmixed ) {\newline		if( date_ge( year_orig, month_orig, day_orig, \newline				calendar_orig-&gtyear_x, calendar_orig-&gtmonth_x, calendar_orig-&gtday_x ))\newline			c2use_orig = calendar_orig-&gtlate_cal;\newline		else if( date_le( year_orig, month_orig, day_orig, \newline				calendar_orig-&gtyear_px, calendar_orig-&gtmonth_px, calendar_orig-&gtday_px ))\newline			c2use_orig = calendar_orig-&gtearly_cal;\newline		else\newline			{\newline			sprintf( error_message, &quotccs_dayssince: date %04d-%02d-%02d is not a valid date in the %s calendar; it falls between the last date the %s calendar was used (%04d-%02d-%02d) and the first date the %s calendar was used (%04d-%02d-%02d)&quot, \newline				year_orig, month_orig, day_orig, calendar_orig-&gtname, \newline				calendar_orig-&gtearly_cal-&gtname,\newline				calendar_orig-&gtyear_px, calendar_orig-&gtmonth_px, calendar_orig-&gtday_px,\newline				calendar_orig-&gtlate_cal-&gtname,\newline				calendar_orig-&gtyear_x, calendar_orig-&gtmonth_x, calendar_orig-&gtday_x );\newline			return( CALCALCS_ERR_DATE_NOT_IN_CALENDAR );\newline			}\newline		}\newline	else	\newline		c2use_orig = calendar_orig;\newline\newline	/* Get Julian day in the original calendar and date combo */\newline	if( (ierr = c2use_orig-&gtc_date2jday( year_orig, month_orig, day_orig, &ampjd0 )) != 0 )\newline		return(ierr);\newline\newline	/* Get new Julian day */\newline	jd1 = jd0 + ndays_since;\newline\newline	if( calendar_new-&gtmixed ) {\newline		/* Figure out which calendar of the NEW calendar to use if it&#039s a mixed calendar.\newline		 */\newline		if( jd1 &gt= calendar_new-&gtjday_x )\newline			c2use_new = calendar_new-&gtlate_cal;\newline		else\newline			c2use_new = calendar_new-&gtearly_cal;\newline		}\newline	else\newline		c2use_new = calendar_new;\newline\newline	/* Convert the new Julian day to a date in the new calendar */\newline	if( (ierr = c2use_new-&gtc_jday2date( jd1, year_new, month_new, day_new )) != 0 )\newline		return( ierr );\newline	\newline	return(0);\newline}\newline","\newline ccs_dayssince: Given a Y/M/D date in a specified calendar, and the number of days since \newline that date, this returns the new Y/M/D date in a (possibly different) calendar.\newline \newline Note that specifying &quotzero&quot days since, and giving different calendars as the original\newline and new calendars, essentially converts dates between calendars.\newline \newline Returns 0 on success, and a negative value on error.\newline \newline","2142771","tgdb.c","static int tgdb_has_command_to_run(struct tgdb *tgdb)\newline{\newline    if (tgdb_client_is_client_ready(tgdb-&gttcc) &amp&amp\newline            ((queue_size(tgdb-&gtgdb_input_queue) &gt 0) ||\newline                    (queue_size(tgdb-&gtoob_input_queue) &gt 0)))\newline        return 1;\newline\newline    return 0;\newline}\newline","\newline Determines if tgdb has commands it needs to run.\newline \newline \\return\newline 1 if can issue directly to gdb. Otherwise 0.\newline \newline","2905064","resonance.cpp","void Resonance::smooth(){\newline  REALTYPE old=Prespoints[0];\newline  for (int i=0;i&ltN_RES_POINTS;i++){\newline    old=old*0.4+Prespoints[i]*0.6;\newline    Prespoints[i]=(int) old;\newline  };\newline  old=Prespoints[N_RES_POINTS-1];\newline  for (int i=N_RES_POINTS-1;i&gt0;i--){\newline    old=old*0.4+Prespoints[i]*0.6;\newline    Prespoints[i]=(int) old+1;\newline    if (Prespoints[i]&gt127) Prespoints[i]=127;\newline  };\newline};\newline","\newline Smooth the resonance function\newline \newline","4996861","dcam_v_modes.c","int _dcam_count_v_modes( dcam_handle_t dcamhandle, int node, int directory )\newline{\newline   nodeaddr_t addr = dcamhandle-&gtcommand_regs_base;\newline   quadlet_t formats;\newline   quadlet_t modes;\newline   int count = 0;\newline	\newline   if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x100, &ampformats ) &lt 0 )\newline   {\newline      TRACE( &quotFailed to read formats\\n&quot );\newline      return 0;\newline   }	\newline\newline   if( formats &amp ( 1 &lt&lt 31 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline/* 					TRACE( &quotMode: %d\\n&quot, i ); */\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat0: %d\\n&quot, count ); */\newline   }\newline   if( formats &amp ( 1 &lt&lt 30 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat1: %d\\n&quot, count ); */\newline   }\newline   if( formats &amp ( 1 &lt&lt 29 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat2: %d\\n&quot, count ); */\newline   }\newline	\newline   return count;\newline}\newline","\newlinereturns the number of video modes supported by the device described by (node,directory)\newlinereturns 0 on errors\newline \newline","4347523","reapits.c","static void TestRegexCAPI(void) {\newline    UErrorCode           status = U_ZERO_ERROR;\newline    URegularExpression  *re;\newline    UChar                pat[200];\newline    UChar               *minus1;\newline\newline    memset(&ampminus1, -1, sizeof(minus1));\newline\newline    /* Mimimalist open/close */\newline    u_uastrncpy(pat, &quotabc*&quot, UPRV_LENGTHOF(pat));\newline    re = uregex_open(pat, -1, 0, 0, &ampstatus);\newline    if (U_FAILURE(status)) {\newline         log_data_err(&quotFailed to open regular expression, %s:%d, error is \\&quot%s\\&quot (Are you missing data?)\\n&quot, __FILE__, __LINE__, u_errorName(status));\newline         return;\newline    }\newline    uregex_close(re);\newline\newline    /* Open with all flag values set */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, \newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD | UREGEX_LITERAL,\newline        0, &ampstatus);\newline    TEST_ASSERT_SUCCESS(status);\newline    uregex_close(re);\newline\newline    /* Open with an invalid flag */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, 0x40000000, 0, &ampstatus);\newline    TEST_ASSERT(status == U_REGEX_INVALID_FLAG);\newline    uregex_close(re);\newline\newline    /* Open with an unimplemented flag */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, UREGEX_CANON_EQ, 0, &ampstatus);\newline    TEST_ASSERT(status == U_REGEX_UNIMPLEMENTED);\newline    uregex_close(re);\newline\newline    /* openC with an invalid parameter */\newline    status = U_ZERO_ERROR;\newline    re = uregex_openC(NULL,\newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD, 0, &ampstatus);\newline    TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR &amp&amp re == NULL);\newline\newline    /* openC with an invalid parameter */\newline    status = U_USELESS_COLLATOR_ERROR;\newline    re = uregex_openC(NULL,\newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD, 0, &ampstatus);\newline    TEST_ASSERT(status == U_USELESS_COLLATOR_ERROR &amp&amp re == NULL);\newline\newline    /* openC   open from a C string */\newline    {\newline        const UChar   *p;\newline        int32_t  len;\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        p = uregex_pattern(re, &amplen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if(U_SUCCESS(status)) {\newline            u_uastrncpy(pat, &quotabc*&quot, UPRV_LENGTHOF(pat));\newline            TEST_ASSERT(u_strcmp(pat, p) == 0);\newline            TEST_ASSERT(len==(int32_t)strlen(&quotabc*&quot));\newline        }\newline\newline        uregex_close(re);\newline\newline        /*  TODO:  Open with ParseError parameter */\newline    }\newline\newline    /*\newline     *  clone\newline     */\newline    {\newline        URegularExpression *clone1;\newline        URegularExpression *clone2;\newline        URegularExpression *clone3;\newline        UChar  testString1[30];\newline        UChar  testString2[30];\newline        UBool  result;\newline\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        clone1 = uregex_clone(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone1 != NULL);\newline\newline        status = U_ZERO_ERROR;\newline        clone2 = uregex_clone(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone2 != NULL);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        clone3 = uregex_clone(clone2, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone3 != NULL);\newline\newline        u_uastrncpy(testString1, &quotabcccd&quot, UPRV_LENGTHOF(pat));\newline        u_uastrncpy(testString2, &quotxxxabcccd&quot, UPRV_LENGTHOF(pat));\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(clone1, testString1, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_lookingAt(clone1, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==TRUE);\newline        \newline        status = U_ZERO_ERROR;\newline        uregex_setText(clone2, testString2, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_lookingAt(clone2, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==FALSE);\newline        result = uregex_find(clone2, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==TRUE);\newline\newline        uregex_close(clone1);\newline        uregex_close(clone2);\newline        uregex_close(clone3);\newline\newline    }\newline\newline    /*\newline     *  pattern()\newline    */\newline    {\newline        const UChar  *resultPat;\newline        int32_t       resultLen;\newline        u_uastrncpy(pat, &quothello&quot, UPRV_LENGTHOF(pat));\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        resultPat = uregex_pattern(re, &ampresultLen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if (U_SUCCESS(status)) {\newline            TEST_ASSERT(resultLen == -1);\newline            TEST_ASSERT(u_strcmp(resultPat, pat) == 0);\newline        }\newline\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, 3, 0, NULL, &ampstatus);\newline        resultPat = uregex_pattern(re, &ampresultLen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if (U_SUCCESS(status)) {\newline            TEST_ASSERT(resultLen == 3);\newline            TEST_ASSERT(u_strncmp(resultPat, pat, 3) == 0);\newline            TEST_ASSERT(u_strlen(resultPat) == 3);\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  flags()\newline     */\newline    {\newline        int32_t  t;\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, UREGEX_CASE_INSENSITIVE | UREGEX_DOTALL, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == (UREGEX_CASE_INSENSITIVE | UREGEX_DOTALL));\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  setText() and lookingAt()\newline     */\newline    {\newline        UChar  text1[50];\newline        UChar  text2[50];\newline        UBool  result;\newline\newline        u_uastrncpy(text1, &quotabcccd&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotabcccxd&quot, UPRV_LENGTHOF(text2));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* Operation before doing a setText should fail... */\newline        status = U_ZERO_ERROR;\newline        uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT( status== U_REGEX_INVALID_STATE);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 5, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  getText() \newline     */\newline    {\newline        UChar    text1[50];\newline        UChar    text2[50];\newline        const UChar   *result;\newline        int32_t  textLength;\newline\newline        u_uastrncpy(text1, &quotabcccd&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotabcccxd&quot, UPRV_LENGTHOF(text2));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text1);\newline        TEST_ASSERT(textLength == -1);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, 7, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text2);\newline        TEST_ASSERT(textLength == 7);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, 4, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text2);\newline        TEST_ASSERT(textLength == 4);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  matches()\newline     */\newline    {\newline        UChar   text1[50];\newline        UBool   result;\newline        int     len;\newline        UChar   nullString[] = {0,0,0};\newline\newline        u_uastrncpy(text1, &quotabcccde&quot,  UPRV_LENGTHOF(text1));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_matches(re, 1, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot.?&quot, 0, NULL, &ampstatus);\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        len = u_strlen(text1);\newline        result = uregex_matches(re, len, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, nullString, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  lookingAt()    Used in setText test.\newline     */\newline\newline\newline    /*\newline     *  find(), findNext, start, end, reset\newline     */\newline    {\newline        UChar    text1[50];\newline        UBool    result;\newline        u_uastrncpy(text1, &quot012rx5rx890rxrx...&quot,  UPRV_LENGTHOF(text1));\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotrx&quot, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_find(re, 9, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 11);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 13);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_find(re, 14, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_reset(re, 0, &ampstatus);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 6);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 8);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_reset(re, 12, &ampstatus);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 13);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 15);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  groupCount\newline     */\newline    {\newline        int32_t result;\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc&quot, 0, NULL, &ampstatus);\newline        result = uregex_groupCount(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc(def)(ghi(j))&quot, 0, NULL, &ampstatus);\newline        result = uregex_groupCount(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result == 3);\newline        uregex_close(re);\newline\newline    }\newline\newline\newline    /*\newline     *  group()\newline     */\newline    {\newline        UChar    text1[80];\newline        UChar    buf[80];\newline        UBool    result;\newline        int32_t  resultSz;\newline        u_uastrncpy(text1, &quotnoise abc interior def, and this is off the end&quot,  UPRV_LENGTHOF(text1));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc(.*?)def&quot, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT(result==TRUE);\newline\newline        /*  Capture Group 0, the full match.  Should succeed.  */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotabc interior def&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /*  Capture group #1.  Should succeed. */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quot interior &quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quot interior &quot));\newline\newline        /*  Capture group out of range.  Error. */\newline        status = U_ZERO_ERROR;\newline        uregex_group(re, 2, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT(status == U_INDEX_OUTOFBOUNDS_ERROR);\newline\newline        /* NULL buffer, pure pre-flight */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /* Too small buffer, truncated string */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_group(re, 0, buf, 5, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT_STRING(&quotabc i&quot, buf, FALSE);\newline        TEST_ASSERT(buf[5] == (UChar)0xffff);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /* Output string just fits buffer, no NUL term. */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, buf, (int32_t)strlen(&quotabc interior def&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotabc interior def&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline        TEST_ASSERT(buf[strlen(&quotabc interior def&quot)] == (UChar)0xffff);\newline        \newline        uregex_close(re);\newline\newline    }\newline    \newline    /*\newline     *  Regions\newline     */\newline        \newline        \newline        /* SetRegion(), getRegion() do something  */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0)\newline        UChar resultString[40];\newline        TEST_ASSERT(uregex_regionStart(re, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_regionEnd(re, &ampstatus) == 16);\newline        uregex_setRegion(re, 3, 6, &ampstatus);\newline        TEST_ASSERT(uregex_regionStart(re, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_regionEnd(re, &ampstatus) == 6);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus));\newline        TEST_ASSERT(uregex_group(re, 0, resultString, UPRV_LENGTHOF(resultString), &ampstatus) == 3)\newline        TEST_ASSERT_STRING(&quot345&quot, resultString, TRUE);\newline        TEST_TEARDOWN;\newline        \newline        /* find(start=-1) uses regions   */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 6);\newline        TEST_TEARDOWN;\newline        \newline        /* find (start &gt=0) does not use regions   */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 16);\newline        TEST_TEARDOWN;\newline         \newline        /* findNext() obeys regions    */\newline        TEST_SETUP(&quot.&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_findNext(re,&ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        /* matches(start=-1) uses regions                                           */\newline        /*    Also, verify that non-greedy *? succeeds in finding the full match.   */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_matches(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 6);\newline        TEST_TEARDOWN;\newline        \newline        /* matches (start &gt=0) does not use regions       */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_matches(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 16);\newline        TEST_TEARDOWN;\newline        \newline        /* lookingAt(start=-1) uses regions                                         */\newline        /*    Also, verify that non-greedy *? finds the first (shortest) match.     */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_lookingAt(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 4);\newline        TEST_TEARDOWN;\newline        \newline        /* lookingAt (start &gt=0) does not use regions  */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_lookingAt(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 0);\newline        TEST_TEARDOWN;\newline\newline        /* hitEnd()       */\newline        TEST_SETUP(&quot[a-f]*&quot, &quotabcdefghij&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_hitEnd(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        TEST_SETUP(&quot[a-f]*&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_hitEnd(re, &ampstatus) == TRUE);\newline        TEST_TEARDOWN;\newline\newline        /* requireEnd   */\newline        TEST_SETUP(&quotabcd&quot, &quotabcd&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_requireEnd(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        TEST_SETUP(&quotabcd$&quot, &quotabcd&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_requireEnd(re, &ampstatus) == TRUE);\newline        TEST_TEARDOWN;\newline        \newline        /* anchoringBounds        */\newline        TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_hasAnchoringBounds(re, &ampstatus) == TRUE);\newline        uregex_useAnchoringBounds(re, FALSE, &ampstatus);\newline        TEST_ASSERT(uregex_hasAnchoringBounds(re, &ampstatus) == FALSE);\newline        \newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == FALSE);\newline        uregex_useAnchoringBounds(re, TRUE, &ampstatus);\newline        uregex_setRegion(re, 0, 3, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 3);\newline        TEST_TEARDOWN;\newline        \newline        /* Transparent Bounds      */\newline        TEST_SETUP(&quotabc(?=def)&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_hasTransparentBounds(re, &ampstatus) == FALSE);\newline        uregex_useTransparentBounds(re, TRUE, &ampstatus);\newline        TEST_ASSERT(uregex_hasTransparentBounds(re, &ampstatus) == TRUE);\newline        \newline        uregex_useTransparentBounds(re, FALSE, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);    /* No Region */\newline        uregex_setRegion(re, 0, 3, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == FALSE);   /* with region, opaque bounds */\newline        uregex_useTransparentBounds(re, TRUE, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);    /* with region, transparent bounds */\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 3);\newline        TEST_TEARDOWN;\newline        \newline\newline    /*\newline     *  replaceFirst()\newline     */\newline    {\newline        UChar    text1[80];\newline        UChar    text2[80];\newline        UChar    replText[80];\newline        UChar    buf[80];\newline        int32_t  resultSz;\newline        u_uastrncpy(text1, &quotReplace xaax x1x x...x.&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline        u_uastrncpy(replText, &quot&lt$1&gt&quot, UPRV_LENGTHOF(replText));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotx(.*?)x&quot, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /*  Normal case, with match */\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline\newline        /* No match.  Text should copy to output with no changes.  */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotNo match here.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotNo match here.&quot));\newline\newline        /*  Match, output just fills buffer, no termination warning. */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        /* Do the replaceFirst again, without first resetting anything.\newline         *  Should give the same results.\newline         */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        /* NULL buffer, zero buffer length */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_replaceFirst(re, replText, -1, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline\newline        /* Buffer too small by one */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot)-1, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  replaceAll()\newline     */\newline    {\newline        UChar    text1[80];          /*  &quotReplace xaax x1x x...x.&quot */\newline        UChar    text2[80];          /*  &quotNo match Here&quot           */\newline        UChar    replText[80];       /*  &quot&lt$1&gt&quot                    */\newline        UChar    replText2[80];      /*  &quot&lt&lt$1&gt&gt&quot                  */\newline        const char * pattern = &quotx(.*?)x&quot;\newline        const char * expectedResult = &quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot;\newline        const char * expectedResult2 = &quotReplace &lt&ltaa&gt&gt &lt&lt1&gt&gt &lt&lt...&gt&gt.&quot;\newline        UChar    buf[80];\newline        int32_t  resultSize;\newline        int32_t  expectedResultSize;\newline        int32_t  expectedResultSize2;\newline        int32_t  i;\newline\newline        u_uastrncpy(text1, &quotReplace xaax x1x x...x.&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline        u_uastrncpy(replText, &quot&lt$1&gt&quot, UPRV_LENGTHOF(replText));\newline        u_uastrncpy(replText2, &quot&lt&lt$1&gt&gt&quot, UPRV_LENGTHOF(replText2));\newline        expectedResultSize = strlen(expectedResult);\newline        expectedResultSize2 = strlen(expectedResult2);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(pattern, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /*  Normal case, with match */\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(expectedResult, buf, TRUE);\newline        TEST_ASSERT(resultSize == expectedResultSize);\newline\newline        /* No match.  Text should copy to output with no changes.  */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotNo match here.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSize == u_strlen(text2));\newline\newline        /*  Match, output just fills buffer, no termination warning. */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        memset(buf, -1, sizeof(buf));\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, expectedResultSize, &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(expectedResult, buf, FALSE);\newline        TEST_ASSERT(resultSize == expectedResultSize);\newline        TEST_ASSERT(buf[resultSize] == (UChar)0xffff);\newline\newline        /* Do the replaceFirst again, without first resetting anything.\newline         *  Should give the same results.\newline         */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, strlen(&quotReplace xaax x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSize == (int32_t)strlen(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot));\newline        TEST_ASSERT(buf[resultSize] == (UChar)0xffff);\newline\newline        /* NULL buffer, zero buffer length */\newline        status = U_ZERO_ERROR;\newline        resultSize = uregex_replaceAll(re, replText, -1, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSize == (int32_t)strlen(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot));\newline\newline        /* Buffer too small.  Try every size, which will tickle edge cases\newline         * in uregex_appendReplacement (used by replaceAll)   */\newline        for (i=0; i&ltexpectedResultSize; i++) {\newline            char  expected[80];\newline            status = U_ZERO_ERROR;\newline            memset(buf, -1, sizeof(buf));\newline            resultSize = uregex_replaceAll(re, replText, -1, buf, i, &ampstatus);\newline            TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline            strcpy(expected, expectedResult);\newline            expected[i] = 0;\newline            TEST_ASSERT_STRING(expected, buf, FALSE);\newline            TEST_ASSERT(resultSize == expectedResultSize);\newline            TEST_ASSERT(buf[i] == (UChar)0xffff);\newline        }\newline\newline        /* Buffer too small.  Same as previous test, except this time the replacement\newline         * text is longer than the match capture group, making the length of the complete\newline         * replacement longer than the original string.\newline         */\newline        for (i=0; i&ltexpectedResultSize2; i++) {\newline            char  expected[80];\newline            status = U_ZERO_ERROR;\newline            memset(buf, -1, sizeof(buf));\newline            resultSize = uregex_replaceAll(re, replText2, -1, buf, i, &ampstatus);\newline            TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline            strcpy(expected, expectedResult2);\newline            expected[i] = 0;\newline            TEST_ASSERT_STRING(expected, buf, FALSE);\newline            TEST_ASSERT(resultSize == expectedResultSize2);\newline            TEST_ASSERT(buf[i] == (UChar)0xffff);\newline        }\newline\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  appendReplacement()\newline     */\newline    {\newline        UChar    text[100];\newline        UChar    repl[100];\newline        UChar    buf[100];\newline        UChar   *bufPtr;\newline        int32_t  bufCap;\newline\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot.*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        u_uastrncpy(text, &quotwhatever&quot,  UPRV_LENGTHOF(text));\newline        u_uastrncpy(repl, &quotsome other&quot, UPRV_LENGTHOF(repl));\newline        uregex_setText(re, text, -1, &ampstatus);\newline\newline        /* match covers whole target string */\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        bufCap = UPRV_LENGTHOF(buf);\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, &ampbufCap, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotsome other&quot, buf, TRUE);\newline\newline        /* Match has \\u \\U escapes */\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        bufCap = UPRV_LENGTHOF(buf);\newline        u_uastrncpy(repl, &quotabc\\\\u0041\\\\U00000042 \\\\\\\\ \\\\$ \\\\abc&quot, UPRV_LENGTHOF(repl));\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, &ampbufCap, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotabcAB \\\\ $ abc&quot, buf, TRUE); \newline\newline        /* Bug 6813, parameter check of NULL destCapacity; crashed before fix. */\newline        status = U_ZERO_ERROR;\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        status = U_BUFFER_OVERFLOW_ERROR;\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, NULL, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  appendTail().   Checked in ReplaceFirst(), replaceAll().\newline     */\newline\newline    /*\newline     *  split()\newline     */\newline    {\newline        UChar    textToSplit[80];\newline        UChar    text2[80];\newline        UChar    buf[200];\newline        UChar    *fields[10];\newline        int32_t  numFields;\newline        int32_t  requiredCapacity;\newline        int32_t  spaceNeeded;\newline        int32_t  sz;\newline\newline        u_uastrncpy(textToSplit, &quotfirst : second:  third&quot,  UPRV_LENGTHOF(textToSplit));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot:&quot, 0, NULL, &ampstatus);\newline\newline\newline        /*  Simple split */ \newline\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if (U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 10, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 3);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot  third&quot, fields[2], TRUE);\newline                TEST_ASSERT(fields[3] == NULL);\newline\newline                spaceNeeded = u_strlen(textToSplit) -\newline                            (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                            numFields;          /* Each field gets a NUL terminator */ \newline\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline\newline        uregex_close(re);\newline\newline    \newline        /*  Split with too few output strings available */\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot:&quot, 0, NULL, &ampstatus);\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 2, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 2);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quot second:  third&quot, fields[1], TRUE);\newline                TEST_ASSERT(!memcmp(&ampfields[2],&ampminus1,sizeof(UChar*)));\newline\newline                spaceNeeded = u_strlen(textToSplit) -\newline                            (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                            numFields;          /* Each field gets a NUL terminator */ \newline\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline\newline                /* Split with a range of output buffer sizes.  */\newline                spaceNeeded = u_strlen(textToSplit) -\newline                    (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                    numFields;          /* Each field gets a NUL terminator */ \newline                        \newline                for (sz=0; sz &lt spaceNeeded+1; sz++) {\newline                    memset(fields, -1, sizeof(fields));\newline                    status = U_ZERO_ERROR;\newline                    numFields = \newline                        uregex_split(re, buf, sz, &amprequiredCapacity, fields, 10, &ampstatus);\newline                    if (sz &gt= spaceNeeded) {\newline                        TEST_ASSERT_SUCCESS(status);\newline                        TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                        TEST_ASSERT_STRING(&quot second&quot, fields[1], TRUE);\newline                        TEST_ASSERT_STRING(&quot  third&quot, fields[2], TRUE);\newline                    } else {\newline                        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline                    }\newline                    TEST_ASSERT(numFields == 3);\newline                    TEST_ASSERT(fields[3] == NULL);\newline                    TEST_ASSERT(spaceNeeded == requiredCapacity);\newline                }\newline            }\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline\newline\newline\newline    /* Split(), part 2.  Patterns with capture groups.  The capture group text\newline     *                   comes out as additional fields.  */\newline    {\newline        UChar    textToSplit[80];\newline        UChar    buf[200];\newline        UChar    *fields[10];\newline        int32_t  numFields;\newline        int32_t  requiredCapacity;\newline        int32_t  spaceNeeded;\newline        int32_t  sz;\newline\newline        u_uastrncpy(textToSplit, &quotfirst &lttag-a&gt second&lttag-b&gt  third&quot,  UPRV_LENGTHOF(textToSplit));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot&lt(.*?)&gt&quot, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 10, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 5);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline                TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline                TEST_ASSERT_STRING(&quot  third&quot, fields[4], TRUE);\newline                TEST_ASSERT(fields[5] == NULL);\newline                spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b.  third.&quot);  /* &quot.&quot at NUL positions */\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline    \newline        /*  Split with too few output strings available (2) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 2, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 2);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quot second&lttag-b&gt  third&quot, fields[1], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[2],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst . second&lttag-b&gt  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /*  Split with too few output strings available (3) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 3, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 3);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline            TEST_ASSERT_STRING(&quot second&lttag-b&gt  third&quot, fields[2], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[3],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst .tag-a. second&lttag-b&gt  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /*  Split with just enough output strings available (5) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 5, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 5);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline            TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline            TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline            TEST_ASSERT_STRING(&quot  third&quot, fields[4], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[5],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b.  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /* Split, end of text is a field delimiter.   */\newline        status = U_ZERO_ERROR;\newline        sz = strlen(&quotfirst &lttag-a&gt second&lttag-b&gt&quot);\newline        uregex_setText(re, textToSplit, sz, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 9, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 5);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline                TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline                TEST_ASSERT_STRING(&quot&quot,        fields[4], TRUE);\newline                TEST_ASSERT(fields[5] == NULL);\newline                TEST_ASSERT(fields[8] == NULL);\newline                TEST_ASSERT(!memcmp(&ampfields[9],&ampminus1,sizeof(UChar*)));\newline                spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b..&quot);  /* &quot.&quot at NUL positions */\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     * set/getTimeLimit\newline     */\newline     TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 0);\newline     uregex_setTimeLimit(re, 1000, &ampstatus);\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 1000);\newline     TEST_ASSERT_SUCCESS(status);\newline     uregex_setTimeLimit(re, -1, &ampstatus);\newline     TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR);\newline     status = U_ZERO_ERROR;\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 1000);\newline     TEST_TEARDOWN;\newline\newline     /*\newline      * set/get Stack Limit\newline      */\newline     TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 8000000);\newline     uregex_setStackLimit(re, 40000, &ampstatus);\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 40000);\newline     TEST_ASSERT_SUCCESS(status);\newline     uregex_setStackLimit(re, -1, &ampstatus);\newline     TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR);\newline     status = U_ZERO_ERROR;\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 40000);\newline     TEST_TEARDOWN;\newline     \newline     \newline     /*\newline      * Get/Set callback functions\newline      *     This test is copied from intltest regex/Callbacks\newline      *     The pattern and test data will run long enough to cause the callback\newline      *       to be invoked.  The nested &#039+&#039 operators give exponential time\newline      *       behavior with increasing string length.\newline      */\newline     TEST_SETUP(&quot((.)+\\\\2)+x&quot, &quotaaaaaaaaaaaaaaaaaaab&quot, 0)\newline     callBackContext cbInfo = {4, 0, 0};\newline     const void     *pContext   = &ampcbInfo;\newline     URegexMatchCallback    *returnedFn = &ampTestCallbackFn;\newline     \newline     /*  Getting the callback fn when it hasn&#039t been set must return NULL  */\newline     uregex_getMatchCallback(re, &ampreturnedFn, &amppContext, &ampstatus);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(returnedFn == NULL);\newline     TEST_ASSERT(pContext == NULL);\newline     \newline     /* Set thecallback and do a match.                                   */\newline     /* The callback function should record that it has been called.      */\newline     uregex_setMatchCallback(re, &ampTestCallbackFn, &ampcbInfo, &ampstatus);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(cbInfo.numCalls == 0);\newline     TEST_ASSERT(uregex_matches(re, -1, &ampstatus) == FALSE);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(cbInfo.numCalls &gt 0);\newline     \newline     /* Getting the callback should return the values that were set above.  */\newline     uregex_getMatchCallback(re, &ampreturnedFn, &amppContext, &ampstatus);\newline     TEST_ASSERT(returnedFn == &ampTestCallbackFn);\newline     TEST_ASSERT(pContext == &ampcbInfo);\newline\newline     TEST_TEARDOWN;\newline}\newline","\newline Regular Expression C API Tests\newline \newline","4881015","websocket.cpp","bool WebSocket::waitForDisconnected(int msecs)\newline{\newline	bool retVal = true;\newline	if (m_pSocket)\newline	{\newline		retVal = m_pSocket-&gtwaitForDisconnected(msecs);\newline	}\newline	return retVal;\newline}\newline","!\newlineWaits \\a msecs for the socket to be disconnected.\newlineIf the socket was successfully disconnected within time, this method returns true.\newlineOtherwise false is returned.\newline\\param msecs The number of milliseconds to wait before a time out occurs; when -1, this function will block until the socket is disconnected.\newline\\sa close(), state()\newline \newline","2224111","tapdisk-client.c","static int tdctl_open(const char* sockpath)\newline{\newline  struct sockaddr_un saddr;\newline  int fd;\newline\newline  if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) &lt 0) {\newline    BWPRINTF(&quoterror creating socket: %s&quot, strerror(errno));\newline    return -1;\newline  }\newline\newline  memset(&ampsaddr, 0, sizeof(saddr));\newline  saddr.sun_family = AF_UNIX;\newline  memcpy(saddr.sun_path, sockpath, strlen(sockpath));\newline\newline  if (connect(fd, &ampsaddr, sizeof(saddr)) &lt 0) {\newline    BWPRINTF(&quoterror connecting to socket %s: %s&quot, sockpath, strerror(errno));\newline    close(fd);\newline    return -1;\newline  }\newline\newline  return fd;\newline}\newline","returns socket file descriptor \newline","","on","","","on","on","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","restart signal handler","{}","Read using shared file pointer","change file seek pointer","{}","{}","this returns the new Y/M/D date","Determines if tgdb has commands it needs to run.","Smooth the resonance function","returns the number of video modes supported by the device","{}","{}","Waits \a msecs for the socket to be disconnected.","returns socket file descriptor","Evaluate numeric comparison.","All objects are adjusted.","Generate torrent file content","Construct a trigger step","saves the error message text","creates a cgroup data structure","Specify the alarm threshold."
"3VIVIU06FKCFZZS9HT2VU0YUYL3MIK","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","37ZHEEHM6WMJBD0WIMYKWVV403873X","A2M2K3PO5ALBE2","Approved","Wed Apr 17 16:12:27 PDT 2019","Wed Apr 17 16:15:13 PDT 2019","Fri Apr 19 16:15:13 PDT 2019","2019-04-19 23:15:21 UTC","","","166","100% (13/13)","100% (13/13)","100% (13/13)","1281952","pthread_internal.c","static void pthread_handle_sigrestart(int sig) {\newline  _pthread_descr this=__thread_self();\newline  this-&gtp_sig=sig;\newline#ifdef DEBUG\newline  printf(&quotpthread_handle_sigrestart(%d) in %d\\n&quot,sig,this-&gtpid);\newline#endif\newline}\newline","restart signal handler \newline","4488551","g_cmds.c","void StopFollowing( gentity_t *ent ) {\newline	if(g_gametype.integer&ltGT_ELIMINATION || g_gametype.integer&gtGT_LMS)\newline	{\newline		//Shouldn&#039t this already be the case?\newline		ent-&gtclient-&gtps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;	\newline		ent-&gtclient-&gtsess.sessionTeam = TEAM_SPECTATOR;	\newline	}\newline	else {\newline		ent-&gtclient-&gtps.stats[STAT_HEALTH] = 0;\newline		ent-&gthealth = 0;\newline	}\newline	ent-&gtclient-&gtsess.spectatorState = SPECTATOR_FREE;\newline	ent-&gtclient-&gtps.pm_flags &amp= ~PMF_FOLLOW;\newline	ent-&gtr.svFlags &amp= ~SVF_BOT;\newline	ent-&gtclient-&gtps.clientNum = ent - g_entities;\newline}\newline","\newline=================\newlineStopFollowing\newlineIf the client being followed leaves the game, or you just want to drop\newlineto free floating spectator mode\newline=================\newline \newline","5281126","lj_ir.c","int lj_ir_numcmp(lua_Number a, lua_Number b, IROp op)\newline{\newline  switch (op) {\newline  case IR_EQ: return (a == b);\newline  case IR_NE: return (a != b);\newline  case IR_LT: return (a &lt b);\newline  case IR_GE: return (a &gt= b);\newline  case IR_LE: return (a &lt= b);\newline  case IR_GT: return (a &gt b);\newline  case IR_ULT: return !(a &gt= b);\newline  case IR_UGE: return !(a &lt b);\newline  case IR_ULE: return !(a &gt b);\newline  case IR_UGT: return !(a &lt= b);\newline  default: lua_assert(0); return 0;\newline  }\newline}\newline","Evaluate numeric comparison. \newline","690512","ipepage.cpp","void Page::removeLayer(String name)\newline{\newline  int index = findLayer(name);\newline  assert(iLayers.size() &gt 1 &amp&amp index &gt= 0);\newline  for (ObjSeq::iterator it = iObjects.begin(); it != iObjects.end(); ++it) {\newline    int k = it-&gtiLayer;\newline    assert(k != index);\newline    if (k &gt index)\newline      it-&gtiLayer = k-1;\newline  }\newline  iLayers.erase(iLayers.begin() + index);\newline}\newline","! All objects are adjusted. Panics if there are objects in the\newlinedeleted layer, of if it is the only layer.\newline \newline","2531936","torrent.c","static void bt_generate_torrent(torrent_ctx *ctx)\newline{\newline	uint64_t total_size = 0;\newline	size_t info_start_pos;\newline\newline	assert(ctx-&gtcontent.str == NULL);\newline\newline	if (ctx-&gtpiece_length == 0) {\newline		if (ctx-&gtfiles.size == 1) {\newline			total_size = ((bt_file_info*)ctx-&gtfiles.array[0])-&gtsize;\newline		}\newline		ctx-&gtpiece_length = bt_default_piece_length(total_size);\newline	}\newline\newline	if ((ctx-&gtoptions &amp BT_OPT_INFOHASH_ONLY) == 0) {\newline		/* write the torrent header */\newline		bt_str_append(ctx, &quotd&quot);\newline		if (ctx-&gtannounce.array &amp&amp ctx-&gtannounce.size &gt 0) {\newline			bt_bencode_str(ctx, &quot8:announce&quot, ctx-&gtannounce.array[0]);\newline\newline			/* if more than one announce url */\newline			if (ctx-&gtannounce.size &gt 1) {\newline				/* add the announce-list key-value pair */\newline				size_t i;\newline				bt_str_append(ctx, &quot13:announce-listll&quot);\newline\newline				for (i = 0; i &lt ctx-&gtannounce.size; i++) {\newline					if (i &gt 0) {\newline						bt_str_append(ctx, &quotel&quot);\newline					}\newline					bt_bencode_str(ctx, 0, ctx-&gtannounce.array[i]);\newline				}\newline				bt_str_append(ctx, &quotee&quot);\newline			}\newline		}\newline\newline		if (ctx-&gtprogram_name) {\newline			bt_bencode_str(ctx, &quot10:created by&quot, ctx-&gtprogram_name);\newline		}\newline		bt_bencode_int(ctx, &quot13:creation date&quot, (uint64_t)time(NULL));\newline\newline		bt_str_append(ctx, &quot8:encoding5:UTF-8&quot);\newline	}\newline\newline	/* write the essential for BTIH part of the torrent file */\newline\newline	bt_str_append(ctx, &quot4:infod&quot); /* start the info dictionary */\newline	info_start_pos = ctx-&gtcontent.length - 1;\newline\newline	if (ctx-&gtfiles.size &gt 1) {\newline		size_t i;\newline\newline		/* process batch torrent */\newline		bt_str_append(ctx, &quot5:filesl&quot); /* start list of files */\newline\newline		/* write length and path for each file in the batch */\newline		for (i = 0; i &lt ctx-&gtfiles.size; i++) {\newline			bt_file_info_append(ctx, &quotd6:length&quot, &quot4:pathl&quot,\newline				(bt_file_info*)ctx-&gtfiles.array[i]);\newline			bt_str_append(ctx, &quotee&quot);\newline		}\newline		/* note: get_batch_name modifies path, so should be called here */\newline		bt_bencode_str(ctx, &quote4:name&quot, get_batch_name(\newline			((bt_file_info*)ctx-&gtfiles.array[0])-&gtpath));\newline	}\newline	else if (ctx-&gtfiles.size &gt 0) {\newline		/* write size and basename of the first file */\newline		/* in the non-batch mode other files are ignored */\newline		bt_file_info_append(ctx, &quot6:length&quot, &quot4:name&quot,\newline			(bt_file_info*)ctx-&gtfiles.array[0]);\newline	}\newline\newline	bt_bencode_int(ctx, &quot12:piece length&quot, ctx-&gtpiece_length);\newline	bt_str_append(ctx, &quot6:pieces&quot);\newline	bt_bencode_pieces(ctx);\newline\newline	if (ctx-&gtoptions &amp BT_OPT_PRIVATE) {\newline		bt_str_append(ctx, &quot7:privatei1e&quot);\newline	}\newline	bt_str_append(ctx, &quotee&quot);\newline\newline	/* calculate BTIH */\newline	SHA1_INIT(ctx);\newline	SHA1_UPDATE(ctx, (unsigned char*)ctx-&gtcontent.str + info_start_pos,\newline		ctx-&gtcontent.length - info_start_pos - 1);\newline	SHA1_FINAL(ctx, ctx-&gtbtih);\newline}\newline","\newline Generate torrent file content\newline @see http://wiki.theory.org/BitTorrentSpecification\newline \newline @param ctx the torrent algorithm context\newline \newline","242558","trigger.c","TriggerStep *sqliteTriggerDeleteStep(Token *pTableName, Expr *pWhere){\newline  TriggerStep *pTriggerStep = sqliteMalloc(sizeof(TriggerStep));\newline  if( pTriggerStep==0 ) return 0;\newline\newline  pTriggerStep-&gtop = TK_DELETE;\newline  pTriggerStep-&gttarget  = *pTableName;\newline  pTriggerStep-&gtpWhere = pWhere;\newline  pTriggerStep-&gtorconf = OE_Default;\newline  sqlitePersistTriggerStep(pTriggerStep);\newline\newline  return pTriggerStep;\newline}\newline","\newline Construct a trigger step that implements a DELETE statement and return\newline a pointer to that trigger step. The parser calls this routine when it\newline sees a DELETE statement inside the body of a CREATE TRIGGER.\newline \newline","3496629","xsendstring.cpp","int ErrorHandler(Display *my_dpy, XErrorEvent *event) {\newline  char xmsg[512] = { 0 };\newline\newline  XGetErrorText(my_dpy, event-&gterror_code, xmsg, NumberOf(xmsg) - 1);\newline\newline  g_xerrormsg &lt&lt &quotX error (&quot &lt&lt event-&gtrequest_code &lt&lt &quot): &quot &lt&lt xmsg\newline              &lt&lt std::endl;\newline  return 0;\newline}\newline","\newline ErrorHandler will be called when X detects an error. This function\newline just saves the error message text\newline \newline","4756747","test_functions.c","struct cgroup *create_new_cgroup_ds(int ctl, const char *grpname,\newline	 int value_type, struct cntl_val_t cval, struct uid_gid_t ids, int i)\newline{\newline	int retval;\newline	char group[FILENAME_MAX];\newline	char controller_name[FILENAME_MAX], control_file[FILENAME_MAX];\newline\newline	strncpy(group, grpname, sizeof(group));\newline	retval = set_controller(ctl, controller_name, control_file);\newline	if (retval) {\newline		fprintf(stderr, &quotSetting controller failled\\n&quot);\newline		return NULL;\newline	}\newline\newline	switch (ctl) {\newline		/* control values are controller specific, so will be set\newline		 * accordingly from the config file */\newline	case CPU:\newline		strncpy(cval.val_string, &quot260000&quot, sizeof(cval.val_string));\newline		break;\newline\newline	case MEMORY:\newline		strncpy(cval.val_string, &quot7000064&quot, sizeof(cval.val_string));\newline		break;\newline\newline	/* To be added for other controllers */\newline	default:\newline		printf(&quotInvalid controller name passed. Setting control value&quot\newline					&quot failed. Dependent tests may fail\\n&quot);\newline		return NULL;\newline		break;\newline	}\newline\newline	return new_cgroup(group, controller_name, control_file,\newline						 value_type, cval, ids, i);\newline}\newline","\newline This function creates a cgroup data structure\newline This function is a bit ugly for now and need to be changed\newline @param ctl the controller under which group is to be created\newline @param grpname the name of the group\newline @param value_type which value out of four types\newline @param struct cval the control value structure\newline @param struct ids the permissions struct\newline @param the test number\newline \newline","3067387","qwt_thermo.cpp","void QwtThermo::setAlarmLevel(double level)\newline{\newline    d_data-&gtalarmLevel = level;\newline    d_data-&gtalarmEnabled = 1;\newline    update();\newline}\newline","! \newlineSpecify the alarm threshold.\newline\\param level Alarm threshold\newline\\sa alarmLevel()\newline \newline","5266440","config-table.c","struct config_table_t *nubase_config_table_set(struct llist_head *config_table_list, char *key, char *value)\newline{\newline	struct config_table_t *config_table;\newline\newline	/* It does not exists so we use _append*/\newline	if ( ! nubase_config_table_get(config_table_list, key) ) {\newline		return nubase_config_table_append(config_table_list, key, value);\newline	}\newline\newline	{\newline		struct llist_head *pos;\newline		llist_for_each(pos, config_table_list) {\newline			config_table = llist_entry(pos, struct config_table_t, list);\newline			if (!strncmp(key, config_table-&gtkey, strlen(config_table-&gtkey))) {\newline				llist_del(&ampconfig_table-&gtlist);\newline				return nubase_config_table_append(config_table_list, key, value);\newline			}\newline		}\newline	}\newline\newline	return NULL;\newline}\newline","Similar to nubase_config_table_append,\newline but does not check for existing value\newline and if it exists, free() it \newline","6158391","read_sh.c","int MPI_File_read_shared(MPI_File fh, void *buf, int count, \newline                  MPI_Datatype datatype, MPI_Status *status)\newline{\newline    int error_code, bufsize, buftype_is_contig, filetype_is_contig;\newline#ifndef PRINT_ERR_MSG\newline    static char myname[] = &quotMPI_FILE_READ_SHARED&quot;\newline#endif\newline    int datatype_size, incr;\newline    ADIO_Offset off, shared_fp;\newline\newline#ifdef PRINT_ERR_MSG\newline    if ((fh &lt= (MPI_File) 0) || (fh-&gtcookie != ADIOI_FILE_COOKIE)) {\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Invalid file handle\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline    }\newline#else\newline    ADIOI_TEST_FILE_HANDLE(fh, myname);\newline#endif\newline\newline    if (count &lt 0) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Invalid count argument\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_COUNT_ARG,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);\newline#endif\newline    }\newline\newline    if (datatype == MPI_DATATYPE_NULL) {\newline#ifdef PRINT_ERR_MSG\newline        FPRINTF(stderr, &quotMPI_File_read_shared: Invalid datatype\\n&quot);\newline        MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_TYPE, MPIR_ERR_TYPE_NULL,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);	    \newline#endif\newline    }\newline\newline    MPI_Type_size(datatype, &ampdatatype_size);\newline    if (count*datatype_size == 0) return MPI_SUCCESS;\newline\newline    if ((count*datatype_size) % fh-&gtetype_size != 0) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Only an integral number of etypes can be accessed\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_ETYPE_FRACTIONAL,\newline				     myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);	    \newline#endif\newline    }\newline\newline    if ((fh-&gtfile_system == ADIO_PIOFS) || (fh-&gtfile_system == ADIO_PVFS)) {\newline#ifdef PRINT_ERR_MSG\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Shared file pointer not supported on PIOFS and PVFS\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline#else\newline	error_code = MPIR_Err_setmsg(MPI_ERR_UNSUPPORTED_OPERATION, \newline                    MPIR_ERR_NO_SHARED_FP, myname, (char *) 0, (char *) 0);\newline	return ADIOI_Error(fh, error_code, myname);\newline#endif\newline    }\newline\newline    ADIOI_Datatype_iscontig(datatype, &ampbuftype_is_contig);\newline    ADIOI_Datatype_iscontig(fh-&gtfiletype, &ampfiletype_is_contig);\newline\newline    incr = (count*datatype_size)/fh-&gtetype_size;\newline    ADIO_Get_shared_fp(fh, incr, &ampshared_fp, &amperror_code);\newline    if (error_code != MPI_SUCCESS) {\newline	FPRINTF(stderr, &quotMPI_File_read_shared: Error! Could not access shared file pointer.\\n&quot);\newline	MPI_Abort(MPI_COMM_WORLD, 1);\newline    }\newline\newline    /* contiguous or strided? */\newline    if (buftype_is_contig &amp&amp filetype_is_contig) {\newline	/* convert count and shared_fp to bytes */\newline        bufsize = datatype_size * count;\newline        off = fh-&gtdisp + fh-&gtetype_size * shared_fp;\newline\newline        /* if atomic mode requested, lock (exclusive) the region, because there\newline           could be a concurrent noncontiguous request. On NFS, locking \newline           is done in the ADIO_ReadContig.*/\newline\newline        if ((fh-&gtatomicity) &amp&amp (fh-&gtfile_system != ADIO_NFS))\newline            ADIOI_WRITE_LOCK(fh, off, SEEK_SET, bufsize);\newline\newline        ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,\newline                        off, status, &amperror_code); \newline\newline        if ((fh-&gtatomicity) &amp&amp (fh-&gtfile_system != ADIO_NFS))\newline            ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);\newline    }\newline    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,\newline                          shared_fp, status, &amperror_code); \newline    /* For strided and atomic mode, locking is done in ADIO_ReadStrided */\newline\newline    return error_code;\newline}\newline","@\newlineMPI_File_read_shared - Read using shared file pointer\newlineInput Parameters:\newline. fh - file handle (handle)\newline. count - number of elements in buffer (nonnegative integer)\newline. datatype - datatype of each buffer element (handle)\newlineOutput Parameters:\newline. buf - initial address of buffer (choice)\newline. status - status object (Status)\newline.N fortran\newline@ \newline","3731702","hfs.c","long hfs_lseek(hfsfile *file, long offset, int from)\newline{\newline  unsigned long *lglen;\newline  long newpos;\newline\newline  f_getptrs(file, &amplglen, 0, 0);\newline\newline  switch (from)\newline    {\newline    case SEEK_SET:\newline      newpos = offset;\newline      break;\newline\newline    case SEEK_CUR:\newline      newpos = file-&gtpos + offset;\newline      break;\newline\newline    case SEEK_END:\newline      newpos = *lglen + offset;\newline      break;\newline\newline    default:\newline      ERROR(EINVAL, 0);\newline      return -1;\newline    }\newline\newline  if (newpos &lt 0)\newline    newpos = 0;\newline  else if (newpos &gt *lglen)\newline    newpos = *lglen;\newline\newline  file-&gtpos = newpos;\newline\newline  return newpos;\newline}\newline","\newline NAME: hfs-&gtlseek()\newline DESCRIPTION: change file seek pointer\newline \newline","6267469","adouble.cpp","adub floor ( const badouble&amp x ) {\newline    ADOLC_OPENMP_THREAD_NUMBER;\newline    ADOLC_OPENMP_GET_THREAD_NUMBER;\newline    locint locat=next_loc();\newline\newline    double coval =\newline        ADOLC_MATH_NSP::floor(ADOLC_GLOBAL_TAPE_VARS.store[x.loc()]);\newline\newline    if (ADOLC_CURRENT_TAPE_INFOS.traceFlag) { // old: write_args_d_a(floor_op,locat,coval,x.loc());\newline        put_op(floor_op);\newline        ADOLC_PUT_LOCINT(x.loc()); // = arg\newline        ADOLC_PUT_LOCINT(locat);      // = res\newline        ADOLC_PUT_VAL(coval);         // = coval\newline\newline        ++ADOLC_CURRENT_TAPE_INFOS.numTays_Tape;\newline        if (ADOLC_CURRENT_TAPE_INFOS.keepTaylors)\newline            ADOLC_WRITE_SCAYLOR(ADOLC_GLOBAL_TAPE_VARS.store[locat]);\newline    }\newline\newline    ADOLC_GLOBAL_TAPE_VARS.store[locat] = coval;\newline    return locat;\newline}\newline","Floor function (NOTE: This function is nondifferentiable) \newline","4943178","chcpu.c","static int cpu_enable(cpu_set_t *cpu_set, size_t setsize, int enable)\newline{\newline	unsigned int cpu;\newline	int online, rc;\newline	int configured = -1;\newline	size_t fails = 0;\newline\newline	for (cpu = 0; cpu &lt setsize; cpu++) {\newline		if (!CPU_ISSET(cpu, cpu_set))\newline			continue;\newline		if (!path_exist(_PATH_SYS_CPU &quot/cpu%d&quot, cpu)) {\newline			warnx(_(&quotCPU %u does not exist&quot), cpu);\newline			fails++;\newline			continue;\newline		}\newline		if (!path_exist(_PATH_SYS_CPU &quot/cpu%d/online&quot, cpu)) {\newline			warnx(_(&quotCPU %u is not hot pluggable&quot), cpu);\newline			fails++;\newline			continue;\newline		}\newline		online = path_read_s32(_PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline		if ((online == 1) &amp&amp (enable == 1)) {\newline			printf(_(&quotCPU %u is already enabled\\n&quot), cpu);\newline			continue;\newline		}\newline		if ((online == 0) &amp&amp (enable == 0)) {\newline			printf(_(&quotCPU %u is already disabled\\n&quot), cpu);\newline			continue;\newline		}\newline		if (path_exist(_PATH_SYS_CPU &quot/cpu%d/configure&quot, cpu))\newline			configured = path_read_s32(_PATH_SYS_CPU &quot/cpu%d/configure&quot, cpu);\newline		if (enable) {\newline			rc = path_write_str(&quot1&quot, _PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline			if ((rc == -1) &amp&amp (configured == 0)) {\newline				warn(_(&quotCPU %u enable failed (CPU is deconfigured)&quot), cpu);\newline				fails++;\newline			} else if (rc == -1) {\newline				warn(_(&quotCPU %u enable failed&quot), cpu);\newline				fails++;\newline			} else\newline				printf(_(&quotCPU %u enabled\\n&quot), cpu);\newline		} else {\newline			if (onlinecpus &amp&amp num_online_cpus() == 1) {\newline				warnx(_(&quotCPU %u disable failed (last enabled CPU)&quot), cpu);\newline				fails++;\newline				continue;\newline			}\newline			rc = path_write_str(&quot0&quot, _PATH_SYS_CPU &quot/cpu%d/online&quot, cpu);\newline			if (rc == -1) {\newline				warn(_(&quotCPU %u disable failed&quot), cpu);\newline				fails++;\newline			} else {\newline				printf(_(&quotCPU %u disabled\\n&quot), cpu);\newline				if (onlinecpus)\newline					CPU_CLR(cpu, onlinecpus);\newline			}\newline		}\newline	}\newline\newline	return fails == 0 ? 0 : fails == setsize ? -1 : 1;\newline}\newline","returns: 0 = success\newline &lt 0 = failure\newline &gt 0 = partial success\newline \newline","2011681","calcalcs.c","int ccs_dayssince( calcalcs_cal *calendar_orig, int year_orig, int month_orig, int day_orig,\newline		int ndays_since, calcalcs_cal *calendar_new, int *year_new, int *month_new, int *day_new )\newline{\newline	int		ierr, jd0, jd1;\newline	calcalcs_cal	*c2use_orig, *c2use_new;\newline\newline	if( calendar_orig == NULL ) return(CALCALCS_ERR_NULL_CALENDAR);\newline	if( calendar_orig-&gtsig != CCS_VALID_SIG ) return(CALCALCS_ERR_INVALID_CALENDAR);\newline\newline	if( calendar_new == NULL ) return(CALCALCS_ERR_NULL_CALENDAR);\newline	if( calendar_new-&gtsig != CCS_VALID_SIG ) return(CALCALCS_ERR_INVALID_CALENDAR);\newline\newline	/* Figure out which calendar of the ORIGINAL calendar to use if it&#039s a mixed calendar\newline	 */\newline	if( calendar_orig-&gtmixed ) {\newline		if( date_ge( year_orig, month_orig, day_orig, \newline				calendar_orig-&gtyear_x, calendar_orig-&gtmonth_x, calendar_orig-&gtday_x ))\newline			c2use_orig = calendar_orig-&gtlate_cal;\newline		else if( date_le( year_orig, month_orig, day_orig, \newline				calendar_orig-&gtyear_px, calendar_orig-&gtmonth_px, calendar_orig-&gtday_px ))\newline			c2use_orig = calendar_orig-&gtearly_cal;\newline		else\newline			{\newline			sprintf( error_message, &quotccs_dayssince: date %04d-%02d-%02d is not a valid date in the %s calendar; it falls between the last date the %s calendar was used (%04d-%02d-%02d) and the first date the %s calendar was used (%04d-%02d-%02d)&quot, \newline				year_orig, month_orig, day_orig, calendar_orig-&gtname, \newline				calendar_orig-&gtearly_cal-&gtname,\newline				calendar_orig-&gtyear_px, calendar_orig-&gtmonth_px, calendar_orig-&gtday_px,\newline				calendar_orig-&gtlate_cal-&gtname,\newline				calendar_orig-&gtyear_x, calendar_orig-&gtmonth_x, calendar_orig-&gtday_x );\newline			return( CALCALCS_ERR_DATE_NOT_IN_CALENDAR );\newline			}\newline		}\newline	else	\newline		c2use_orig = calendar_orig;\newline\newline	/* Get Julian day in the original calendar and date combo */\newline	if( (ierr = c2use_orig-&gtc_date2jday( year_orig, month_orig, day_orig, &ampjd0 )) != 0 )\newline		return(ierr);\newline\newline	/* Get new Julian day */\newline	jd1 = jd0 + ndays_since;\newline\newline	if( calendar_new-&gtmixed ) {\newline		/* Figure out which calendar of the NEW calendar to use if it&#039s a mixed calendar.\newline		 */\newline		if( jd1 &gt= calendar_new-&gtjday_x )\newline			c2use_new = calendar_new-&gtlate_cal;\newline		else\newline			c2use_new = calendar_new-&gtearly_cal;\newline		}\newline	else\newline		c2use_new = calendar_new;\newline\newline	/* Convert the new Julian day to a date in the new calendar */\newline	if( (ierr = c2use_new-&gtc_jday2date( jd1, year_new, month_new, day_new )) != 0 )\newline		return( ierr );\newline	\newline	return(0);\newline}\newline","\newline ccs_dayssince: Given a Y/M/D date in a specified calendar, and the number of days since \newline that date, this returns the new Y/M/D date in a (possibly different) calendar.\newline \newline Note that specifying &quotzero&quot days since, and giving different calendars as the original\newline and new calendars, essentially converts dates between calendars.\newline \newline Returns 0 on success, and a negative value on error.\newline \newline","2142771","tgdb.c","static int tgdb_has_command_to_run(struct tgdb *tgdb)\newline{\newline    if (tgdb_client_is_client_ready(tgdb-&gttcc) &amp&amp\newline            ((queue_size(tgdb-&gtgdb_input_queue) &gt 0) ||\newline                    (queue_size(tgdb-&gtoob_input_queue) &gt 0)))\newline        return 1;\newline\newline    return 0;\newline}\newline","\newline Determines if tgdb has commands it needs to run.\newline \newline \\return\newline 1 if can issue directly to gdb. Otherwise 0.\newline \newline","2905064","resonance.cpp","void Resonance::smooth(){\newline  REALTYPE old=Prespoints[0];\newline  for (int i=0;i&ltN_RES_POINTS;i++){\newline    old=old*0.4+Prespoints[i]*0.6;\newline    Prespoints[i]=(int) old;\newline  };\newline  old=Prespoints[N_RES_POINTS-1];\newline  for (int i=N_RES_POINTS-1;i&gt0;i--){\newline    old=old*0.4+Prespoints[i]*0.6;\newline    Prespoints[i]=(int) old+1;\newline    if (Prespoints[i]&gt127) Prespoints[i]=127;\newline  };\newline};\newline","\newline Smooth the resonance function\newline \newline","4996861","dcam_v_modes.c","int _dcam_count_v_modes( dcam_handle_t dcamhandle, int node, int directory )\newline{\newline   nodeaddr_t addr = dcamhandle-&gtcommand_regs_base;\newline   quadlet_t formats;\newline   quadlet_t modes;\newline   int count = 0;\newline	\newline   if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x100, &ampformats ) &lt 0 )\newline   {\newline      TRACE( &quotFailed to read formats\\n&quot );\newline      return 0;\newline   }	\newline\newline   if( formats &amp ( 1 &lt&lt 31 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline/* 					TRACE( &quotMode: %d\\n&quot, i ); */\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat0: %d\\n&quot, count ); */\newline   }\newline   if( formats &amp ( 1 &lt&lt 30 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat1: %d\\n&quot, count ); */\newline   }\newline   if( formats &amp ( 1 &lt&lt 29 ) )\newline   {\newline      if( _dcam_read_register( dcamhandle-&gtraw1394handle, node, addr + 0x180, &ampmodes ) == 0 )\newline      {\newline	 int i;\newline	 for( i = 0; i &lt 8; i++ )\newline	 {\newline	    if( modes &amp ( 1&lt&lt(31-i) ) )\newline	    {\newline	       count++;\newline	    }\newline	 }\newline      }\newline/* 		TRACE( &quotformat2: %d\\n&quot, count ); */\newline   }\newline	\newline   return count;\newline}\newline","\newlinereturns the number of video modes supported by the device described by (node,directory)\newlinereturns 0 on errors\newline \newline","4347523","reapits.c","static void TestRegexCAPI(void) {\newline    UErrorCode           status = U_ZERO_ERROR;\newline    URegularExpression  *re;\newline    UChar                pat[200];\newline    UChar               *minus1;\newline\newline    memset(&ampminus1, -1, sizeof(minus1));\newline\newline    /* Mimimalist open/close */\newline    u_uastrncpy(pat, &quotabc*&quot, UPRV_LENGTHOF(pat));\newline    re = uregex_open(pat, -1, 0, 0, &ampstatus);\newline    if (U_FAILURE(status)) {\newline         log_data_err(&quotFailed to open regular expression, %s:%d, error is \\&quot%s\\&quot (Are you missing data?)\\n&quot, __FILE__, __LINE__, u_errorName(status));\newline         return;\newline    }\newline    uregex_close(re);\newline\newline    /* Open with all flag values set */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, \newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD | UREGEX_LITERAL,\newline        0, &ampstatus);\newline    TEST_ASSERT_SUCCESS(status);\newline    uregex_close(re);\newline\newline    /* Open with an invalid flag */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, 0x40000000, 0, &ampstatus);\newline    TEST_ASSERT(status == U_REGEX_INVALID_FLAG);\newline    uregex_close(re);\newline\newline    /* Open with an unimplemented flag */\newline    status = U_ZERO_ERROR;\newline    re = uregex_open(pat, -1, UREGEX_CANON_EQ, 0, &ampstatus);\newline    TEST_ASSERT(status == U_REGEX_UNIMPLEMENTED);\newline    uregex_close(re);\newline\newline    /* openC with an invalid parameter */\newline    status = U_ZERO_ERROR;\newline    re = uregex_openC(NULL,\newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD, 0, &ampstatus);\newline    TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR &amp&amp re == NULL);\newline\newline    /* openC with an invalid parameter */\newline    status = U_USELESS_COLLATOR_ERROR;\newline    re = uregex_openC(NULL,\newline        UREGEX_CASE_INSENSITIVE | UREGEX_COMMENTS | UREGEX_DOTALL | UREGEX_MULTILINE | UREGEX_UWORD, 0, &ampstatus);\newline    TEST_ASSERT(status == U_USELESS_COLLATOR_ERROR &amp&amp re == NULL);\newline\newline    /* openC   open from a C string */\newline    {\newline        const UChar   *p;\newline        int32_t  len;\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        p = uregex_pattern(re, &amplen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if(U_SUCCESS(status)) {\newline            u_uastrncpy(pat, &quotabc*&quot, UPRV_LENGTHOF(pat));\newline            TEST_ASSERT(u_strcmp(pat, p) == 0);\newline            TEST_ASSERT(len==(int32_t)strlen(&quotabc*&quot));\newline        }\newline\newline        uregex_close(re);\newline\newline        /*  TODO:  Open with ParseError parameter */\newline    }\newline\newline    /*\newline     *  clone\newline     */\newline    {\newline        URegularExpression *clone1;\newline        URegularExpression *clone2;\newline        URegularExpression *clone3;\newline        UChar  testString1[30];\newline        UChar  testString2[30];\newline        UBool  result;\newline\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        clone1 = uregex_clone(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone1 != NULL);\newline\newline        status = U_ZERO_ERROR;\newline        clone2 = uregex_clone(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone2 != NULL);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        clone3 = uregex_clone(clone2, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(clone3 != NULL);\newline\newline        u_uastrncpy(testString1, &quotabcccd&quot, UPRV_LENGTHOF(pat));\newline        u_uastrncpy(testString2, &quotxxxabcccd&quot, UPRV_LENGTHOF(pat));\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(clone1, testString1, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_lookingAt(clone1, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==TRUE);\newline        \newline        status = U_ZERO_ERROR;\newline        uregex_setText(clone2, testString2, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_lookingAt(clone2, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==FALSE);\newline        result = uregex_find(clone2, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result==TRUE);\newline\newline        uregex_close(clone1);\newline        uregex_close(clone2);\newline        uregex_close(clone3);\newline\newline    }\newline\newline    /*\newline     *  pattern()\newline    */\newline    {\newline        const UChar  *resultPat;\newline        int32_t       resultLen;\newline        u_uastrncpy(pat, &quothello&quot, UPRV_LENGTHOF(pat));\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        resultPat = uregex_pattern(re, &ampresultLen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if (U_SUCCESS(status)) {\newline            TEST_ASSERT(resultLen == -1);\newline            TEST_ASSERT(u_strcmp(resultPat, pat) == 0);\newline        }\newline\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, 3, 0, NULL, &ampstatus);\newline        resultPat = uregex_pattern(re, &ampresultLen, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS above should change too... */\newline        if (U_SUCCESS(status)) {\newline            TEST_ASSERT(resultLen == 3);\newline            TEST_ASSERT(u_strncmp(resultPat, pat, 3) == 0);\newline            TEST_ASSERT(u_strlen(resultPat) == 3);\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  flags()\newline     */\newline    {\newline        int32_t  t;\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_open(pat, -1, UREGEX_CASE_INSENSITIVE | UREGEX_DOTALL, NULL, &ampstatus);\newline        t  = uregex_flags(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(t == (UREGEX_CASE_INSENSITIVE | UREGEX_DOTALL));\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  setText() and lookingAt()\newline     */\newline    {\newline        UChar  text1[50];\newline        UChar  text2[50];\newline        UBool  result;\newline\newline        u_uastrncpy(text1, &quotabcccd&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotabcccxd&quot, UPRV_LENGTHOF(text2));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* Operation before doing a setText should fail... */\newline        status = U_ZERO_ERROR;\newline        uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT( status== U_REGEX_INVALID_STATE);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 5, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_lookingAt(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  getText() \newline     */\newline    {\newline        UChar    text1[50];\newline        UChar    text2[50];\newline        const UChar   *result;\newline        int32_t  textLength;\newline\newline        u_uastrncpy(text1, &quotabcccd&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotabcccxd&quot, UPRV_LENGTHOF(text2));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text1);\newline        TEST_ASSERT(textLength == -1);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, 7, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text2);\newline        TEST_ASSERT(textLength == 7);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, 4, &ampstatus);\newline        result = uregex_getText(re, &amptextLength, &ampstatus);\newline        TEST_ASSERT(result == text2);\newline        TEST_ASSERT(textLength == 4);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  matches()\newline     */\newline    {\newline        UChar   text1[50];\newline        UBool   result;\newline        int     len;\newline        UChar   nullString[] = {0,0,0};\newline\newline        u_uastrncpy(text1, &quotabcccde&quot,  UPRV_LENGTHOF(text1));\newline        status = U_ZERO_ERROR;\newline        u_uastrncpy(pat, &quotabc*d&quot, UPRV_LENGTHOF(pat));\newline        re = uregex_open(pat, -1, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, 6, &ampstatus);\newline        result = uregex_matches(re, 1, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot.?&quot, 0, NULL, &ampstatus);\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        len = u_strlen(text1);\newline        result = uregex_matches(re, len, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, nullString, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        result = uregex_matches(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT_SUCCESS(status);\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  lookingAt()    Used in setText test.\newline     */\newline\newline\newline    /*\newline     *  find(), findNext, start, end, reset\newline     */\newline    {\newline        UChar    text1[50];\newline        UBool    result;\newline        u_uastrncpy(text1, &quot012rx5rx890rxrx...&quot,  UPRV_LENGTHOF(text1));\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotrx&quot, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_find(re, 9, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 11);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 13);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_find(re, 14, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_reset(re, 0, &ampstatus);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 6);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 8);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        status = U_ZERO_ERROR;\newline        uregex_reset(re, 12, &ampstatus);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 13);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 15);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        result = uregex_findNext(re, &ampstatus);\newline        TEST_ASSERT(result == FALSE);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     *  groupCount\newline     */\newline    {\newline        int32_t result;\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc&quot, 0, NULL, &ampstatus);\newline        result = uregex_groupCount(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result == 0);\newline        uregex_close(re);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc(def)(ghi(j))&quot, 0, NULL, &ampstatus);\newline        result = uregex_groupCount(re, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT(result == 3);\newline        uregex_close(re);\newline\newline    }\newline\newline\newline    /*\newline     *  group()\newline     */\newline    {\newline        UChar    text1[80];\newline        UChar    buf[80];\newline        UBool    result;\newline        int32_t  resultSz;\newline        u_uastrncpy(text1, &quotnoise abc interior def, and this is off the end&quot,  UPRV_LENGTHOF(text1));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotabc(.*?)def&quot, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        result = uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT(result==TRUE);\newline\newline        /*  Capture Group 0, the full match.  Should succeed.  */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotabc interior def&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /*  Capture group #1.  Should succeed. */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quot interior &quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quot interior &quot));\newline\newline        /*  Capture group out of range.  Error. */\newline        status = U_ZERO_ERROR;\newline        uregex_group(re, 2, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT(status == U_INDEX_OUTOFBOUNDS_ERROR);\newline\newline        /* NULL buffer, pure pre-flight */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /* Too small buffer, truncated string */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_group(re, 0, buf, 5, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT_STRING(&quotabc i&quot, buf, FALSE);\newline        TEST_ASSERT(buf[5] == (UChar)0xffff);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline\newline        /* Output string just fits buffer, no NUL term. */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_group(re, 0, buf, (int32_t)strlen(&quotabc interior def&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotabc interior def&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotabc interior def&quot));\newline        TEST_ASSERT(buf[strlen(&quotabc interior def&quot)] == (UChar)0xffff);\newline        \newline        uregex_close(re);\newline\newline    }\newline    \newline    /*\newline     *  Regions\newline     */\newline        \newline        \newline        /* SetRegion(), getRegion() do something  */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0)\newline        UChar resultString[40];\newline        TEST_ASSERT(uregex_regionStart(re, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_regionEnd(re, &ampstatus) == 16);\newline        uregex_setRegion(re, 3, 6, &ampstatus);\newline        TEST_ASSERT(uregex_regionStart(re, &ampstatus) == 3);\newline        TEST_ASSERT(uregex_regionEnd(re, &ampstatus) == 6);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus));\newline        TEST_ASSERT(uregex_group(re, 0, resultString, UPRV_LENGTHOF(resultString), &ampstatus) == 3)\newline        TEST_ASSERT_STRING(&quot345&quot, resultString, TRUE);\newline        TEST_TEARDOWN;\newline        \newline        /* find(start=-1) uses regions   */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 6);\newline        TEST_TEARDOWN;\newline        \newline        /* find (start &gt=0) does not use regions   */\newline        TEST_SETUP(&quot.*&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 16);\newline        TEST_TEARDOWN;\newline         \newline        /* findNext() obeys regions    */\newline        TEST_SETUP(&quot.&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_findNext(re,&ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 5);\newline        TEST_ASSERT(uregex_findNext(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        /* matches(start=-1) uses regions                                           */\newline        /*    Also, verify that non-greedy *? succeeds in finding the full match.   */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_matches(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 6);\newline        TEST_TEARDOWN;\newline        \newline        /* matches (start &gt=0) does not use regions       */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_matches(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 16);\newline        TEST_TEARDOWN;\newline        \newline        /* lookingAt(start=-1) uses regions                                         */\newline        /*    Also, verify that non-greedy *? finds the first (shortest) match.     */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_lookingAt(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 4);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 4);\newline        TEST_TEARDOWN;\newline        \newline        /* lookingAt (start &gt=0) does not use regions  */\newline        TEST_SETUP(&quot.*?&quot, &quot0123456789ABCDEF&quot, 0);\newline        uregex_setRegion(re, 4, 6, &ampstatus);\newline        TEST_ASSERT(uregex_lookingAt(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_start(re, 0, &ampstatus) == 0);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 0);\newline        TEST_TEARDOWN;\newline\newline        /* hitEnd()       */\newline        TEST_SETUP(&quot[a-f]*&quot, &quotabcdefghij&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_hitEnd(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        TEST_SETUP(&quot[a-f]*&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_hitEnd(re, &ampstatus) == TRUE);\newline        TEST_TEARDOWN;\newline\newline        /* requireEnd   */\newline        TEST_SETUP(&quotabcd&quot, &quotabcd&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_requireEnd(re, &ampstatus) == FALSE);\newline        TEST_TEARDOWN;\newline\newline        TEST_SETUP(&quotabcd$&quot, &quotabcd&quot, 0);\newline        TEST_ASSERT(uregex_find(re, 0, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_requireEnd(re, &ampstatus) == TRUE);\newline        TEST_TEARDOWN;\newline        \newline        /* anchoringBounds        */\newline        TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_hasAnchoringBounds(re, &ampstatus) == TRUE);\newline        uregex_useAnchoringBounds(re, FALSE, &ampstatus);\newline        TEST_ASSERT(uregex_hasAnchoringBounds(re, &ampstatus) == FALSE);\newline        \newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == FALSE);\newline        uregex_useAnchoringBounds(re, TRUE, &ampstatus);\newline        uregex_setRegion(re, 0, 3, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 3);\newline        TEST_TEARDOWN;\newline        \newline        /* Transparent Bounds      */\newline        TEST_SETUP(&quotabc(?=def)&quot, &quotabcdef&quot, 0);\newline        TEST_ASSERT(uregex_hasTransparentBounds(re, &ampstatus) == FALSE);\newline        uregex_useTransparentBounds(re, TRUE, &ampstatus);\newline        TEST_ASSERT(uregex_hasTransparentBounds(re, &ampstatus) == TRUE);\newline        \newline        uregex_useTransparentBounds(re, FALSE, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);    /* No Region */\newline        uregex_setRegion(re, 0, 3, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == FALSE);   /* with region, opaque bounds */\newline        uregex_useTransparentBounds(re, TRUE, &ampstatus);\newline        TEST_ASSERT(uregex_find(re, -1, &ampstatus) == TRUE);    /* with region, transparent bounds */\newline        TEST_ASSERT(uregex_end(re, 0, &ampstatus) == 3);\newline        TEST_TEARDOWN;\newline        \newline\newline    /*\newline     *  replaceFirst()\newline     */\newline    {\newline        UChar    text1[80];\newline        UChar    text2[80];\newline        UChar    replText[80];\newline        UChar    buf[80];\newline        int32_t  resultSz;\newline        u_uastrncpy(text1, &quotReplace xaax x1x x...x.&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline        u_uastrncpy(replText, &quot&lt$1&gt&quot, UPRV_LENGTHOF(replText));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quotx(.*?)x&quot, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /*  Normal case, with match */\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline\newline        /* No match.  Text should copy to output with no changes.  */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotNo match here.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotNo match here.&quot));\newline\newline        /*  Match, output just fills buffer, no termination warning. */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        /* Do the replaceFirst again, without first resetting anything.\newline         *  Should give the same results.\newline         */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        /* NULL buffer, zero buffer length */\newline        status = U_ZERO_ERROR;\newline        resultSz = uregex_replaceFirst(re, replText, -1, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline\newline        /* Buffer too small by one */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSz = uregex_replaceFirst(re, replText, -1, buf, strlen(&quotReplace &ltaa&gt x1x x...x.&quot)-1, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt x1x x...x&quot, buf, FALSE);\newline        TEST_ASSERT(resultSz == (int32_t)strlen(&quotReplace xaax x1x x...x.&quot));\newline        TEST_ASSERT(buf[resultSz] == (UChar)0xffff);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  replaceAll()\newline     */\newline    {\newline        UChar    text1[80];          /*  &quotReplace xaax x1x x...x.&quot */\newline        UChar    text2[80];          /*  &quotNo match Here&quot           */\newline        UChar    replText[80];       /*  &quot&lt$1&gt&quot                    */\newline        UChar    replText2[80];      /*  &quot&lt&lt$1&gt&gt&quot                  */\newline        const char * pattern = &quotx(.*?)x&quot;\newline        const char * expectedResult = &quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot;\newline        const char * expectedResult2 = &quotReplace &lt&ltaa&gt&gt &lt&lt1&gt&gt &lt&lt...&gt&gt.&quot;\newline        UChar    buf[80];\newline        int32_t  resultSize;\newline        int32_t  expectedResultSize;\newline        int32_t  expectedResultSize2;\newline        int32_t  i;\newline\newline        u_uastrncpy(text1, &quotReplace xaax x1x x...x.&quot,  UPRV_LENGTHOF(text1));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline        u_uastrncpy(replText, &quot&lt$1&gt&quot, UPRV_LENGTHOF(replText));\newline        u_uastrncpy(replText2, &quot&lt&lt$1&gt&gt&quot, UPRV_LENGTHOF(replText2));\newline        expectedResultSize = strlen(expectedResult);\newline        expectedResultSize2 = strlen(expectedResult2);\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(pattern, 0, NULL, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /*  Normal case, with match */\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(expectedResult, buf, TRUE);\newline        TEST_ASSERT(resultSize == expectedResultSize);\newline\newline        /* No match.  Text should copy to output with no changes.  */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text2, -1, &ampstatus);\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, UPRV_LENGTHOF(buf), &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotNo match here.&quot, buf, TRUE);\newline        TEST_ASSERT(resultSize == u_strlen(text2));\newline\newline        /*  Match, output just fills buffer, no termination warning. */\newline        status = U_ZERO_ERROR;\newline        uregex_setText(re, text1, -1, &ampstatus);\newline        memset(buf, -1, sizeof(buf));\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, expectedResultSize, &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(expectedResult, buf, FALSE);\newline        TEST_ASSERT(resultSize == expectedResultSize);\newline        TEST_ASSERT(buf[resultSize] == (UChar)0xffff);\newline\newline        /* Do the replaceFirst again, without first resetting anything.\newline         *  Should give the same results.\newline         */\newline        status = U_ZERO_ERROR;\newline        memset(buf, -1, sizeof(buf));\newline        resultSize = uregex_replaceAll(re, replText, -1, buf, strlen(&quotReplace xaax x1x x...x.&quot), &ampstatus);\newline        TEST_ASSERT(status == U_STRING_NOT_TERMINATED_WARNING);\newline        TEST_ASSERT_STRING(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot, buf, FALSE);\newline        TEST_ASSERT(resultSize == (int32_t)strlen(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot));\newline        TEST_ASSERT(buf[resultSize] == (UChar)0xffff);\newline\newline        /* NULL buffer, zero buffer length */\newline        status = U_ZERO_ERROR;\newline        resultSize = uregex_replaceAll(re, replText, -1, NULL, 0, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline        TEST_ASSERT(resultSize == (int32_t)strlen(&quotReplace &ltaa&gt &lt1&gt &lt...&gt.&quot));\newline\newline        /* Buffer too small.  Try every size, which will tickle edge cases\newline         * in uregex_appendReplacement (used by replaceAll)   */\newline        for (i=0; i&ltexpectedResultSize; i++) {\newline            char  expected[80];\newline            status = U_ZERO_ERROR;\newline            memset(buf, -1, sizeof(buf));\newline            resultSize = uregex_replaceAll(re, replText, -1, buf, i, &ampstatus);\newline            TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline            strcpy(expected, expectedResult);\newline            expected[i] = 0;\newline            TEST_ASSERT_STRING(expected, buf, FALSE);\newline            TEST_ASSERT(resultSize == expectedResultSize);\newline            TEST_ASSERT(buf[i] == (UChar)0xffff);\newline        }\newline\newline        /* Buffer too small.  Same as previous test, except this time the replacement\newline         * text is longer than the match capture group, making the length of the complete\newline         * replacement longer than the original string.\newline         */\newline        for (i=0; i&ltexpectedResultSize2; i++) {\newline            char  expected[80];\newline            status = U_ZERO_ERROR;\newline            memset(buf, -1, sizeof(buf));\newline            resultSize = uregex_replaceAll(re, replText2, -1, buf, i, &ampstatus);\newline            TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline            strcpy(expected, expectedResult2);\newline            expected[i] = 0;\newline            TEST_ASSERT_STRING(expected, buf, FALSE);\newline            TEST_ASSERT(resultSize == expectedResultSize2);\newline            TEST_ASSERT(buf[i] == (UChar)0xffff);\newline        }\newline\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  appendReplacement()\newline     */\newline    {\newline        UChar    text[100];\newline        UChar    repl[100];\newline        UChar    buf[100];\newline        UChar   *bufPtr;\newline        int32_t  bufCap;\newline\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot.*&quot, 0, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        u_uastrncpy(text, &quotwhatever&quot,  UPRV_LENGTHOF(text));\newline        u_uastrncpy(repl, &quotsome other&quot, UPRV_LENGTHOF(repl));\newline        uregex_setText(re, text, -1, &ampstatus);\newline\newline        /* match covers whole target string */\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        bufCap = UPRV_LENGTHOF(buf);\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, &ampbufCap, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotsome other&quot, buf, TRUE);\newline\newline        /* Match has \\u \\U escapes */\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        bufCap = UPRV_LENGTHOF(buf);\newline        u_uastrncpy(repl, &quotabc\\\\u0041\\\\U00000042 \\\\\\\\ \\\\$ \\\\abc&quot, UPRV_LENGTHOF(repl));\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, &ampbufCap, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        TEST_ASSERT_STRING(&quotabcAB \\\\ $ abc&quot, buf, TRUE); \newline\newline        /* Bug 6813, parameter check of NULL destCapacity; crashed before fix. */\newline        status = U_ZERO_ERROR;\newline        uregex_find(re, 0, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline        bufPtr = buf;\newline        status = U_BUFFER_OVERFLOW_ERROR;\newline        uregex_appendReplacement(re, repl, -1, &ampbufPtr, NULL, &ampstatus);\newline        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline\newline        uregex_close(re);\newline    }\newline\newline\newline    /*\newline     *  appendTail().   Checked in ReplaceFirst(), replaceAll().\newline     */\newline\newline    /*\newline     *  split()\newline     */\newline    {\newline        UChar    textToSplit[80];\newline        UChar    text2[80];\newline        UChar    buf[200];\newline        UChar    *fields[10];\newline        int32_t  numFields;\newline        int32_t  requiredCapacity;\newline        int32_t  spaceNeeded;\newline        int32_t  sz;\newline\newline        u_uastrncpy(textToSplit, &quotfirst : second:  third&quot,  UPRV_LENGTHOF(textToSplit));\newline        u_uastrncpy(text2, &quotNo match here.&quot,  UPRV_LENGTHOF(text2));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot:&quot, 0, NULL, &ampstatus);\newline\newline\newline        /*  Simple split */ \newline\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if (U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 10, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 3);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot  third&quot, fields[2], TRUE);\newline                TEST_ASSERT(fields[3] == NULL);\newline\newline                spaceNeeded = u_strlen(textToSplit) -\newline                            (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                            numFields;          /* Each field gets a NUL terminator */ \newline\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline\newline        uregex_close(re);\newline\newline    \newline        /*  Split with too few output strings available */\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot:&quot, 0, NULL, &ampstatus);\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 2, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 2);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quot second:  third&quot, fields[1], TRUE);\newline                TEST_ASSERT(!memcmp(&ampfields[2],&ampminus1,sizeof(UChar*)));\newline\newline                spaceNeeded = u_strlen(textToSplit) -\newline                            (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                            numFields;          /* Each field gets a NUL terminator */ \newline\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline\newline                /* Split with a range of output buffer sizes.  */\newline                spaceNeeded = u_strlen(textToSplit) -\newline                    (numFields - 1)  +  /* Field delimiters do not appear in output */\newline                    numFields;          /* Each field gets a NUL terminator */ \newline                        \newline                for (sz=0; sz &lt spaceNeeded+1; sz++) {\newline                    memset(fields, -1, sizeof(fields));\newline                    status = U_ZERO_ERROR;\newline                    numFields = \newline                        uregex_split(re, buf, sz, &amprequiredCapacity, fields, 10, &ampstatus);\newline                    if (sz &gt= spaceNeeded) {\newline                        TEST_ASSERT_SUCCESS(status);\newline                        TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                        TEST_ASSERT_STRING(&quot second&quot, fields[1], TRUE);\newline                        TEST_ASSERT_STRING(&quot  third&quot, fields[2], TRUE);\newline                    } else {\newline                        TEST_ASSERT(status == U_BUFFER_OVERFLOW_ERROR);\newline                    }\newline                    TEST_ASSERT(numFields == 3);\newline                    TEST_ASSERT(fields[3] == NULL);\newline                    TEST_ASSERT(spaceNeeded == requiredCapacity);\newline                }\newline            }\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline\newline\newline\newline    /* Split(), part 2.  Patterns with capture groups.  The capture group text\newline     *                   comes out as additional fields.  */\newline    {\newline        UChar    textToSplit[80];\newline        UChar    buf[200];\newline        UChar    *fields[10];\newline        int32_t  numFields;\newline        int32_t  requiredCapacity;\newline        int32_t  spaceNeeded;\newline        int32_t  sz;\newline\newline        u_uastrncpy(textToSplit, &quotfirst &lttag-a&gt second&lttag-b&gt  third&quot,  UPRV_LENGTHOF(textToSplit));\newline\newline        status = U_ZERO_ERROR;\newline        re = uregex_openC(&quot&lt(.*?)&gt&quot, 0, NULL, &ampstatus);\newline\newline        uregex_setText(re, textToSplit, -1, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 10, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 5);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline                TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline                TEST_ASSERT_STRING(&quot  third&quot, fields[4], TRUE);\newline                TEST_ASSERT(fields[5] == NULL);\newline                spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b.  third.&quot);  /* &quot.&quot at NUL positions */\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline    \newline        /*  Split with too few output strings available (2) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 2, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 2);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quot second&lttag-b&gt  third&quot, fields[1], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[2],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst . second&lttag-b&gt  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /*  Split with too few output strings available (3) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 3, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 3);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline            TEST_ASSERT_STRING(&quot second&lttag-b&gt  third&quot, fields[2], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[3],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst .tag-a. second&lttag-b&gt  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /*  Split with just enough output strings available (5) */\newline        status = U_ZERO_ERROR;\newline        memset(fields, -1, sizeof(fields));\newline        numFields = \newline            uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 5, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            TEST_ASSERT(numFields == 5);\newline            TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline            TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline            TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline            TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline            TEST_ASSERT_STRING(&quot  third&quot, fields[4], TRUE);\newline            TEST_ASSERT(!memcmp(&ampfields[5],&ampminus1,sizeof(UChar*)));\newline\newline            spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b.  third.&quot);  /* &quot.&quot at NUL positions */\newline            TEST_ASSERT(spaceNeeded == requiredCapacity);\newline        }\newline\newline        /* Split, end of text is a field delimiter.   */\newline        status = U_ZERO_ERROR;\newline        sz = strlen(&quotfirst &lttag-a&gt second&lttag-b&gt&quot);\newline        uregex_setText(re, textToSplit, sz, &ampstatus);\newline        TEST_ASSERT_SUCCESS(status);\newline\newline        /* The TEST_ASSERT_SUCCESS call above should change too... */\newline        if(U_SUCCESS(status)) {\newline            memset(fields, -1, sizeof(fields));\newline            numFields = \newline                uregex_split(re, buf, UPRV_LENGTHOF(buf), &amprequiredCapacity, fields, 9, &ampstatus);\newline            TEST_ASSERT_SUCCESS(status);\newline\newline            /* The TEST_ASSERT_SUCCESS call above should change too... */\newline            if(U_SUCCESS(status)) {\newline                TEST_ASSERT(numFields == 5);\newline                TEST_ASSERT_STRING(&quotfirst &quot,  fields[0], TRUE);\newline                TEST_ASSERT_STRING(&quottag-a&quot,   fields[1], TRUE);\newline                TEST_ASSERT_STRING(&quot second&quot, fields[2], TRUE);\newline                TEST_ASSERT_STRING(&quottag-b&quot,   fields[3], TRUE);\newline                TEST_ASSERT_STRING(&quot&quot,        fields[4], TRUE);\newline                TEST_ASSERT(fields[5] == NULL);\newline                TEST_ASSERT(fields[8] == NULL);\newline                TEST_ASSERT(!memcmp(&ampfields[9],&ampminus1,sizeof(UChar*)));\newline                spaceNeeded = strlen(&quotfirst .tag-a. second.tag-b..&quot);  /* &quot.&quot at NUL positions */\newline                TEST_ASSERT(spaceNeeded == requiredCapacity);\newline            }\newline        }\newline\newline        uregex_close(re);\newline    }\newline\newline    /*\newline     * set/getTimeLimit\newline     */\newline     TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 0);\newline     uregex_setTimeLimit(re, 1000, &ampstatus);\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 1000);\newline     TEST_ASSERT_SUCCESS(status);\newline     uregex_setTimeLimit(re, -1, &ampstatus);\newline     TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR);\newline     status = U_ZERO_ERROR;\newline     TEST_ASSERT(uregex_getTimeLimit(re, &ampstatus) == 1000);\newline     TEST_TEARDOWN;\newline\newline     /*\newline      * set/get Stack Limit\newline      */\newline     TEST_SETUP(&quotabc$&quot, &quotabcdef&quot, 0);\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 8000000);\newline     uregex_setStackLimit(re, 40000, &ampstatus);\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 40000);\newline     TEST_ASSERT_SUCCESS(status);\newline     uregex_setStackLimit(re, -1, &ampstatus);\newline     TEST_ASSERT(status == U_ILLEGAL_ARGUMENT_ERROR);\newline     status = U_ZERO_ERROR;\newline     TEST_ASSERT(uregex_getStackLimit(re, &ampstatus) == 40000);\newline     TEST_TEARDOWN;\newline     \newline     \newline     /*\newline      * Get/Set callback functions\newline      *     This test is copied from intltest regex/Callbacks\newline      *     The pattern and test data will run long enough to cause the callback\newline      *       to be invoked.  The nested &#039+&#039 operators give exponential time\newline      *       behavior with increasing string length.\newline      */\newline     TEST_SETUP(&quot((.)+\\\\2)+x&quot, &quotaaaaaaaaaaaaaaaaaaab&quot, 0)\newline     callBackContext cbInfo = {4, 0, 0};\newline     const void     *pContext   = &ampcbInfo;\newline     URegexMatchCallback    *returnedFn = &ampTestCallbackFn;\newline     \newline     /*  Getting the callback fn when it hasn&#039t been set must return NULL  */\newline     uregex_getMatchCallback(re, &ampreturnedFn, &amppContext, &ampstatus);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(returnedFn == NULL);\newline     TEST_ASSERT(pContext == NULL);\newline     \newline     /* Set thecallback and do a match.                                   */\newline     /* The callback function should record that it has been called.      */\newline     uregex_setMatchCallback(re, &ampTestCallbackFn, &ampcbInfo, &ampstatus);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(cbInfo.numCalls == 0);\newline     TEST_ASSERT(uregex_matches(re, -1, &ampstatus) == FALSE);\newline     TEST_ASSERT_SUCCESS(status);\newline     TEST_ASSERT(cbInfo.numCalls &gt 0);\newline     \newline     /* Getting the callback should return the values that were set above.  */\newline     uregex_getMatchCallback(re, &ampreturnedFn, &amppContext, &ampstatus);\newline     TEST_ASSERT(returnedFn == &ampTestCallbackFn);\newline     TEST_ASSERT(pContext == &ampcbInfo);\newline\newline     TEST_TEARDOWN;\newline}\newline","\newline Regular Expression C API Tests\newline \newline","4881015","websocket.cpp","bool WebSocket::waitForDisconnected(int msecs)\newline{\newline	bool retVal = true;\newline	if (m_pSocket)\newline	{\newline		retVal = m_pSocket-&gtwaitForDisconnected(msecs);\newline	}\newline	return retVal;\newline}\newline","!\newlineWaits \\a msecs for the socket to be disconnected.\newlineIf the socket was successfully disconnected within time, this method returns true.\newlineOtherwise false is returned.\newline\\param msecs The number of milliseconds to wait before a time out occurs; when -1, this function will block until the socket is disconnected.\newline\\sa close(), state()\newline \newline","2224111","tapdisk-client.c","static int tdctl_open(const char* sockpath)\newline{\newline  struct sockaddr_un saddr;\newline  int fd;\newline\newline  if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) &lt 0) {\newline    BWPRINTF(&quoterror creating socket: %s&quot, strerror(errno));\newline    return -1;\newline  }\newline\newline  memset(&ampsaddr, 0, sizeof(saddr));\newline  saddr.sun_family = AF_UNIX;\newline  memcpy(saddr.sun_path, sockpath, strlen(sockpath));\newline\newline  if (connect(fd, &ampsaddr, sizeof(saddr)) &lt 0) {\newline    BWPRINTF(&quoterror connecting to socket %s: %s&quot, sockpath, strerror(errno));\newline    close(fd);\newline    return -1;\newline  }\newline\newline  return fd;\newline}\newline","returns socket file descriptor \newline","","on","","","","on","","","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","on","","","","restart signal handler","{}","Read using shared file pointer","change file seek pointer","Floor function","{}","returns the new Y/M/D date in a (possibly different) calendar.","Determines if tgdb has commands it needs to run.","Smooth the resonance function","returns the number of video modes supported by the device","Regular Expression C API Tests","StopFollowing","{}","returns socket file descriptor","Evaluate numeric comparison.","All objects are adjusted.","Generate torrent file content","Construct a trigger step that implements a DELETE statement","error message text","creates a cgroup data structure","Specify the alarm threshold."
"3VW0145YLYCBUACFZBNV61DUB0SMJW","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","31HQ4X3T3SAMAFADCV0VN8LHN2WLSU","AMD1LYNQAH3R8","Approved","Wed Apr 17 15:16:50 PDT 2019","Wed Apr 17 15:23:39 PDT 2019","Fri Apr 19 15:23:39 PDT 2019","2019-04-19 22:24:21 UTC","","","409","100% (27/27)","100% (27/27)","100% (27/27)","1086458","fmopl.c","INLINE void CALC_FCSLOT(OPL_CH *CH,OPL_SLOT *SLOT)\newline{\newline	int ksr;\newline\newline	/* frequency step counter */\newline	SLOT-&gtIncr = CH-&gtfc * SLOT-&gtmul;\newline	ksr = CH-&gtkcode &gt&gt SLOT-&gtKSR;\newline\newline	if( SLOT-&gtksr != ksr )\newline	{\newline		SLOT-&gtksr = ksr;\newline		/* attack , decay rate recalcration */\newline		SLOT-&gtevsa = SLOT-&gtAR[ksr];\newline		SLOT-&gtevsd = SLOT-&gtDR[ksr];\newline		SLOT-&gtevsr = SLOT-&gtRR[ksr];\newline	}\newline	SLOT-&gtTLL = SLOT-&gtTL + (CH-&gtksl_base&gt&gtSLOT-&gtksl);\newline}\newline","---------- frequency counter for operater update ---------- \newline","5943353","bool.c","int bool_val(char *val)\newline{\newline	if (strlcmp(val, &quoton&quot) == 0 || strlcmp(val, &quottrue&quot) == 0 ||\newline	    strlcmp(val, &quotyes&quot) == 0)\newline		return 1;\newline	else if (strlcmp(val, &quotoff&quot) == 0 || strlcmp(val, &quotfalse&quot) == 0 ||\newline		 strlcmp(val, &quotno&quot) == 0)\newline		return 0;\newline	else\newline		return (int)strtol(val, NULL, 0);\newline}\newline","check boolean string; on, true, yes \newline","5595155","ccryptlib.c","static void make_nonce(xword32 nonce[8]) {\newline  char acc[512], host[256];\newline  struct timeval tv;\newline  static int count=0;\newline  \newline  gethostname(host, 256);   /* ignore failures */\newline  host[255] = 0;\newline  gettimeofday(&amptv, NULL);  /* ignore failures */\newline  sprintf(acc, &quot%s,%ld,%ld,%ld,%d&quot, host, (long)tv.tv_sec, (long)tv.tv_usec,\newline	  (long)getpid(), count++);\newline  hashstring(acc, nonce); \newline}\newline","return a 256-bit value that is practically unique \newline","3131421","notes.c","void add_new_note(void) {\newline	struct vnote *v;\newline\newline	v = vnote_new();\newline	if (v) {\newline		v-&gtuid = malloc(128);\newline		generate_uuid(v-&gtuid);\newline		v-&gtcolor_red = pastel_palette[3][0];\newline		v-&gtcolor_green = pastel_palette[3][1];\newline		v-&gtcolor_blue = pastel_palette[3][2];\newline		v-&gtbody = strdup(_(&quotClick on any note to edit it.&quot));\newline		write_vnote_to_server(v);\newline		vnote_free(v);\newline	}\newline	\newline	readloop(readfwd, eUseDefault);\newline}\newline","\newline Create a new note\newline \newline","2266926","game.c","void Tm_Hd()\newline{\newline    int w = gm.brd_w - gm.t_x * 2;\newline    int h = gm.f_wht-&gth;\newline\newline    D_DST(sdl.scr, gm.t_x + gm.b_x, gm.t_y, w, h);\newline    D_SRC(gm.s_bkgd, gm.t_x + gm.b_x, gm.t_y);\newline    SS_Blt();\newline    Sdl_AddR(gm.t_x + gm.b_x, gm.t_y, w, h);\newline}\newline","\newlinehide time\newline \newline","1193656","style.c","void style_draw_text(struct style *style, cairo_t *cairoctx, gchar *text, gdouble w, gdouble h)\newline{\newline	START_FUNC\newline	cairo_font_extents_t fe;\newline	cairo_text_extents_t te;\newline	PangoFontDescription *fontdesc;\newline	gchar *fontname;\newline	const gchar *fontfamilly;\newline	gchar *fontfamilly_with_fallback;\newline	GtkSettings *settings=NULL;\newline	cairo_font_slant_t slant;\newline	gint size=0.0;\newline\newline	style_cairo_status_check(cairoctx);\newline\newline	if (settings_get_bool(SETTINGS_SYSTEM_FONT)) {\newline		settings=gtk_settings_get_default();\newline		g_object_get(settings, &quotgtk-font-name&quot, &ampfontname, NULL);\newline	} else fontname=settings_get_string(SETTINGS_FONT);\newline	fontdesc=pango_font_description_from_string(fontname?fontname:FALLBACK_FONT &quot 10&quot);\newline	if (fontname) g_free(fontname);\newline	fontfamilly=pango_font_description_get_family(fontdesc);\newline	switch(pango_font_description_get_style(fontdesc)) {\newline		case PANGO_STYLE_NORMAL: slant=CAIRO_FONT_SLANT_NORMAL; break;\newline		case PANGO_STYLE_OBLIQUE: slant=CAIRO_FONT_SLANT_OBLIQUE; break;\newline		case PANGO_STYLE_ITALIC: slant=CAIRO_FONT_SLANT_ITALIC; break;\newline		default: flo_warn(_(&quotunknown slant for font %s: %d&quot), fontfamilly, pango_font_description_get_style(fontdesc));\newline			slant=CAIRO_FONT_SLANT_NORMAL; break;\newline	}\newline	fontfamilly_with_fallback = g_strconcat(fontfamilly, &quot,&quot FALLBACK_FONT, NULL);\newline\newline	cairo_save(cairoctx);\newline	style_cairo_set_color(cairoctx, STYLE_TEXT_OUTLINE_COLOR);\newline	cairo_select_font_face(cairoctx, fontfamilly_with_fallback, slant, \newline		pango_font_description_get_weight(fontdesc)&lt=500?CAIRO_FONT_WEIGHT_NORMAL:CAIRO_FONT_WEIGHT_BOLD);\newline	size=pango_font_description_get_size(fontdesc);\newline	if (pango_font_description_get_size_is_absolute(fontdesc)) {\newline		size=pango_units_to_double(size);\newline	}\newline	cairo_set_font_size(cairoctx, (gdouble)(size)/12800.);\newline	cairo_text_extents(cairoctx, text, &ampte);\newline	cairo_font_extents(cairoctx, &ampfe);\newline	if (te.width &gt w) {\newline		size=size*w/te.width;\newline		cairo_set_font_size(cairoctx, (gdouble)(size)/12800.);\newline		cairo_text_extents(cairoctx, text, &ampte);\newline		cairo_font_extents(cairoctx, &ampfe);\newline	} \newline	if (fe.height &gt h) {\newline		cairo_set_font_size(cairoctx, (gdouble)(size*h/fe.height)/12800.);\newline		cairo_text_extents(cairoctx, text, &ampte);\newline		cairo_font_extents(cairoctx, &ampfe);\newline	}\newline	cairo_move_to(cairoctx, (w-te.width)/2.-te.x_bearing, ((h+fe.height)/2.)-fe.descent);\newline	cairo_set_line_width(cairoctx, 0.1);\newline	cairo_text_path(cairoctx, text);\newline	cairo_stroke(cairoctx);\newline	style_cairo_set_color(cairoctx, STYLE_TEXT_COLOR);\newline	cairo_move_to(cairoctx, (w-te.width)/2.-te.x_bearing, ((h+fe.height)/2.)-fe.descent);\newline	cairo_text_path(cairoctx, text);\newline	cairo_fill(cairoctx);\newline	cairo_restore(cairoctx);\newline\newline	g_free(fontfamilly_with_fallback);\newline	pango_font_description_free(fontdesc);\newline	END_FUNC\newline}\newline","Draws text with cairo \newline","4135694","xperm_new.c","void SGSD(int *vds, int vdsl, int *dummies, int dl, int *mQ,\newline          int *vrs, int vrsl, int *repes, int rl, int n,\newline          int firstd, int *KD, int *KDl, int *bD, int *bDl) {\newline\newline	if (dl==0 &amp&amp rl==0) {\newline		*KDl=0;\newline		*bDl=0;\newline		return;\newline	} /* else */\newline\newline        int *tmp, tmpl;\newline        int *tmpGS   = (int*)malloc(n*n*sizeof(int)), tmpGSl;\newline        int *tmpbase = (int*)malloc(  n*sizeof(int)), tmpbasel;\newline	int i, itotal;\newline\newline        /* Loop over all dummysets */\newline        itotal = 0;\newline	*KDl = 0;\newline	*bDl = 0;\newline        for (i=0; i&ltvdsl; i++) {\newline                tmpl = vds[i];\newline                tmp = dummies + itotal;\newline                movedummyset(firstd, tmp, tmpl, mQ[i]);\newline                itotal = itotal + tmpl;\newline                SGSofdummyset(tmp, tmpl, mQ[i], n, \newline                    tmpGS, &amptmpGSl, tmpbase, &amptmpbasel);\newline                copy_list(tmpGS, KD+(*KDl)*n, tmpGSl*n);\newline                *KDl = *KDl + tmpGSl;\newline                copy_list(tmpbase, bD+ *bDl, tmpbasel);\newline                *bDl = *bDl + tmpbasel;\newline        }\newline\newline        /* Loop over all repeatedsets */\newline        itotal=0;\newline        for (i=0; i&ltvrsl; i++) {\newline                tmpl = vrs[i];\newline                tmp = repes + itotal;\newline                moverepeatedset(firstd, tmp, tmpl);\newline                itotal = itotal + tmpl;\newline                SGSofrepeatedset(tmp, tmpl, n, \newline                    tmpGS, &amptmpGSl, tmpbase, &amptmpbasel);\newline                copy_list(tmpGS, KD+(*KDl)*n, tmpGSl*n);\newline                *KDl = *KDl + tmpGSl;\newline                copy_list(tmpbase, bD+ *bDl, tmpbasel);\newline                *bDl = *bDl + tmpbasel;\newline        }\newline\newline        free(tmpGS);\newline	free(tmpbase);\newline\newline#ifdef VERBOSE_DOUBLE\newline	printf(&quotbase of D:&quot); print_list(bD, *bDl, 1);		/*PPC*/\newline	printf(&quotGS of D (%d perms of degree %d):&quot, *KDl, n);	/*PPC*/\newline	print_array_perm(KD, *KDl, n, 1);			/*PPC*/\newline#endif								/*PPC*/\newline}\newline","SGSD for a given list of dummies and repes \newline","683172","dfsd.c","PRIVATE intn DFSDIstart(void)\newline{\newline    CONSTR(FUNC, &quotDFSDIstart&quot);    /* for HERROR */\newline    intn        ret_value = SUCCEED;\newline\newline    /* Don&#039t call this routine again... */\newline    library_terminate = TRUE;\newline\newline    /* Install atexit() library cleanup routine */\newline    if (HPregister_term_func(&ampDFSDPshutdown) != 0)\newline      HGOTO_ERROR(DFE_CANTINIT, FAIL);\newline\newlinedone:\newline  if(ret_value == FAIL)   \newline    { /* Error condition cleanup */\newline\newline    } /* end if */\newline\newline  /* Normal function cleanup */\newline\newline    return(ret_value);\newline} /* end DFSDIstart() */\newline","--------------------------------------------------------------------------\newlineNAME\newlineDFSDIstart\newlinePURPOSE\newlineDFSD-level initialization routine\newlineUSAGE\newlineintn DFSDIstart()\newlineRETURNS\newlineReturns SUCCEED/FAIL\newlineDESCRIPTION\newlineRegister the shut-down routine (DFSDPshutdown) for call with atexit\newlineGLOBAL VARIABLES\newlineCOMMENTS, BUGS, ASSUMPTIONS\newlineEXAMPLES\newlineREVISION LOG\newline-------------------------------------------------------------------------- \newline","2944550","obsdata.c","static int scan_for_PC(struct ccd_frame *fr, struct wcs *fim)\newline{\newline	double pc[2][2];\newline	int ret = 0;\newline	double D;\newline\newline	if (fits_get_double(fr, P_STR(FN_CROTA1), &ampfim-&gtrot) &lt= 0)\newline		fim-&gtrot = 0;\newline\newline	if ( (fits_get_double(fr, P_STR(FN_CDELT1), &ampfim-&gtxinc) &lt= 0) ||\newline	     (fits_get_double(fr, P_STR(FN_CDELT2), &ampfim-&gtyinc) &lt= 0) ) {\newline		return 0;\newline	}\newline\newline	if (fits_get_double(fr, &quotPC1_1&quot, &amppc[0][0]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[0][0] = 1;\newline	}\newline	if (fits_get_double(fr, &quotPC1_2&quot, &amppc[0][1]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[0][1] = 0;\newline	}\newline	if (fits_get_double(fr, &quotPC2_1&quot, &amppc[1][0]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[1][0] = 0;\newline	}\newline	if (fits_get_double(fr, &quotPC2_2&quot, &amppc[1][1]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[1][1] = 1;\newline	}\newline\newline\newline	D = pc[0][0] * pc[1][1] - pc[1][0] * pc[0][1];\newline	d4_printf(&quotPC D=%8g\\n&quot, D);\newline	if (fabs(D) &lt 1e-30) {\newline		err_printf(&quotPC matrix is singular!\\n&quot);\newline		return 0;\newline	}\newline\newline	if (ret) {\newline//		fim-&gtflags |= WCS_USE_LIN;\newline	}\newline\newline	fim-&gtpc[0][0] = pc[0][0];\newline	fim-&gtpc[1][0] = pc[1][0];\newline	fim-&gtpc[0][1] = pc[0][1];\newline	fim-&gtpc[1][1] = pc[1][1];\newline	fim-&gtrot = raddeg(atan2(pc[0][1], pc[0][0]));\newline\newline	return 1;\newline}\newline","look for PC_ keywords; return 1 if found (and update fim) \newline","4562286","getpass.c","char *getpass_r(const char *prompt, char *buffer, size_t buflen)\newline{\newline  long sts;\newline  short chan;\newline\newline  /* MSK, 23-JAN-2004, iosbdef.h wasn&#039t in VAX V7.2 or CC 6.4  */\newline  /* distribution so I created this.  May revert back later to */\newline  /* struct _iosb iosb;                                        */\newline  struct _iosb\newline     {\newline     short int iosb$w_status; /* status     */\newline     short int iosb$w_bcnt;   /* byte count */\newline     int       unused;        /* unused     */\newline     } iosb;\newline\newline  $DESCRIPTOR(ttdesc, &quotTT&quot);\newline\newline  buffer[0]=&#039\\0&#039;\newline  sts = sys$assign(&ampttdesc, &ampchan,0,0);\newline  if (sts &amp 1) {\newline    sts = sys$qiow(0, chan,\newline                   IO$_READPROMPT | IO$M_NOECHO,\newline                   &ampiosb, 0, 0, buffer, buflen, 0, 0,\newline                   prompt, strlen(prompt));\newline\newline    if((sts &amp 1) &amp&amp (iosb.iosb$w_status&amp1))\newline      buffer[iosb.iosb$w_bcnt] = &#039\\0&#039;\newline\newline    sts = sys$dassgn(chan);\newline  }\newline  return buffer; /* we always return success */\newline}\newline","#include iosbdef \newline","780458","term.c","void gtk_term_cut(GtkWidget *widget)\newline{\newline	GtkTerm	*term;\newline	gchar *s;\newline\newline	g_return_if_fail (widget != NULL);\newline	g_return_if_fail (GTK_IS_TERM (widget));\newline\newline	term = GTK_TERM (widget);\newline	\newline	if (term-&gtepos!=term-&gtpos) {\newline		if(gtk_selection_owner_set(widget,GDK_SELECTION_PRIMARY,GDK_CURRENT_TIME)) {\newline			if (term-&gtepos&gtterm-&gtpos) {\newline				s = g_strndup(&amp((e_get_text(term-&gta,term-&gtcur))[term-&gtpos]),term-&gtepos-term-&gtpos);\newline				e_remove_text(term-&gta,term-&gtcur,term-&gtpos,term-&gtepos-term-&gtpos);\newline				term-&gtepos = term-&gtpos;\newline			} else {\newline				s = g_strndup(&amp((e_get_text(term-&gta,term-&gtcur))[term-&gtepos]),term-&gtpos-term-&gtepos);\newline				e_remove_text(term-&gta,term-&gtcur,term-&gtepos,term-&gtpos-term-&gtepos);\newline				term-&gtpos = term-&gtepos;\newline			}\newline			g_string_assign(term-&gtclipboard,s);\newline			g_free(s);\newline			gtk_term_update_caret(term);\newline			gtk_term_scroll_to_pos(term);\newline			if (!term-&gtchanged) {\newline				g_signal_emit(GTK_OBJECT(term),gtk_term_signals[GTK_TERM_CHANGED],0);\newline				term-&gtchanged = 1;\newline			}\newline		} else {\newline			g_print(&quoteuler could not own the selection\\n&quot);\newline		}\newline	}\newline}\newline","gtk_term_cut\newline cut the current selection to the clipboard\newline \newline","6249163","dictdplugin_dbi.c","static int connect_to_sqldb (\newline   global_data *dict_data)\newline{\newline#ifndef CONNECT_TO_SERVER_ONCE\newline   int err;\newline\newline   err = init_dbi_conn (dict_data);\newline   if (err)\newline      return err;\newline#endif\newline\newline   if (-1 == dbi_conn_connect (dict_data -&gt m_dbi_conn)){\newline      dbi_error (dict_data, dict_data -&gt m_dbi_conn);\newline\newline      return 13;\newline   }\newline\newline   return 0;\newline}\newline","returns zero if success \newline","236278","track.cpp","track::~track()\newline{\newline	emit destroyedTrack();\newline\newline	while( !m_trackContentObjects.isEmpty() )\newline	{\newline		delete m_trackContentObjects.last();\newline	}\newline\newline	m_trackContainer-&gtremoveTrack( this );\newline}\newline","! \\brief Destroy this track\newline \newline If the track container is a Beat+Bassline container, step through\newline its list of tracks and remove us.\newline \newline Then delete the trackContentObject&#039s contents, remove this track from\newline the track container.\newline \newline Finally step through this track&#039s automation and forget all of them.\newline \newline","1786228","qal_win.c","qboolean QAL_Init( void )\newline{\newline	char *buf = NULL;\newline\newline	hinstOpenAL = LoadLibrary( libopenal_name );\newline	if( hinstOpenAL == NULL )\newline	{\newline		FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,\newline		        GetLastError(), MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), ( LPTSTR ) &amp buf,\newline		        0, NULL );\newline		Com_Printf( &quot%s\\n&quot, buf );\newline		return false;\newline	}\newline\newline	dlsym_error = false;\newline	get_dlsym( &quotalEnable&quot, (void**) &amppqalEnable );\newline	get_dlsym( &quotalDisable&quot, (void**) &amppqalDisable );\newline	get_dlsym( &quotalIsEnabled&quot, (void**) &amppqalIsEnabled );\newline	get_dlsym( &quotalGetBooleanv&quot, (void**) &amppqalGetBooleanv );\newline	get_dlsym( &quotalGetIntegerv&quot, (void**) &amppqalGetIntegerv );\newline	get_dlsym( &quotalGetString&quot, (void**) &amppqalGetString );\newline	get_dlsym( &quotalGetFloatv&quot, (void**) &amppqalGetFloatv );\newline	get_dlsym( &quotalGetDoublev&quot, (void**) &amppqalGetDoublev );\newline	get_dlsym( &quotalGetBoolean&quot, (void**) &amppqalGetBoolean );\newline	get_dlsym( &quotalGetInteger&quot, (void**) &amppqalGetInteger );\newline	get_dlsym( &quotalGetFloat&quot, (void**) &amppqalGetFloat );\newline	get_dlsym( &quotalGetDouble&quot, (void**) &amppqalGetDouble );\newline	get_dlsym( &quotalGetError&quot, (void**) &amppqalGetError );\newline	get_dlsym( &quotalIsExtensionPresent&quot, (void**) &amppqalIsExtensionPresent );\newline	get_dlsym( &quotalGetProcAddress&quot, (void**) &amppqalGetProcAddress );\newline	get_dlsym( &quotalGetEnumValue&quot, (void**) &amppqalGetEnumValue );\newline	get_dlsym( &quotalListenerf&quot, (void**) &amppqalListenerf );\newline	get_dlsym( &quotalListener3f&quot, (void**) &amppqalListener3f );\newline	get_dlsym( &quotalListenerfv&quot, (void**) &amppqalListenerfv );\newline	get_dlsym( &quotalListeneri&quot, (void**) &amppqalListeneri );\newline	get_dlsym( &quotalListener3i&quot, (void**) &amppqalListener3i );\newline	get_dlsym( &quotalListeneriv&quot, (void**) &amppqalListeneriv );\newline	get_dlsym( &quotalGetListenerf&quot, (void**) &amppqalGetListenerf );\newline	get_dlsym( &quotalGetListener3f&quot, (void**) &amppqalGetListener3f );\newline	get_dlsym( &quotalGetListenerfv&quot, (void**) &amppqalGetListenerfv );\newline	get_dlsym( &quotalGetListeneri&quot, (void**) &amppqalGetListeneri );\newline	get_dlsym( &quotalGetListener3i&quot, (void**) &amppqalGetListener3i );\newline	get_dlsym( &quotalGetListeneriv&quot, (void**) &amppqalGetListeneriv );\newline	get_dlsym( &quotalGenSources&quot, (void**) &amppqalGenSources );\newline	get_dlsym( &quotalDeleteSources&quot, (void**) &amppqalDeleteSources );\newline	get_dlsym( &quotalIsSource&quot, (void**) &amppqalIsSource );\newline	get_dlsym( &quotalSourcef&quot, (void**) &amppqalSourcef );\newline	get_dlsym( &quotalSource3f&quot, (void**) &amppqalSource3f );\newline	get_dlsym( &quotalSourcefv&quot, (void**) &amppqalSourcefv );\newline	get_dlsym( &quotalSourcei&quot, (void**) &amppqalSourcei );\newline	get_dlsym( &quotalSource3i&quot, (void**) &amppqalSource3i );\newline	get_dlsym( &quotalSourceiv&quot, (void**) &amppqalSourceiv );\newline	get_dlsym( &quotalGetSourcef&quot, (void**) &amppqalGetSourcef );\newline	get_dlsym( &quotalGetSource3f&quot, (void**) &amppqalGetSource3f );\newline	get_dlsym( &quotalGetSourcefv&quot, (void**) &amppqalGetSourcefv );\newline	get_dlsym( &quotalGetSourcei&quot, (void**) &amppqalGetSourcei );\newline	get_dlsym( &quotalGetSource3i&quot, (void**) &amppqalGetSource3i );\newline	get_dlsym( &quotalGetSourceiv&quot, (void**) &amppqalGetSourceiv );\newline	get_dlsym( &quotalSourcePlayv&quot, (void**) &amppqalSourcePlayv );\newline	get_dlsym( &quotalSourceStopv&quot, (void**) &amppqalSourceStopv );\newline	get_dlsym( &quotalSourceRewindv&quot, (void**) &amppqalSourceRewindv );\newline	get_dlsym( &quotalSourcePausev&quot, (void**) &amppqalSourcePausev );\newline	get_dlsym( &quotalSourcePlay&quot, (void**) &amppqalSourcePlay );\newline	get_dlsym( &quotalSourceStop&quot, (void**) &amppqalSourceStop );\newline	get_dlsym( &quotalSourceRewind&quot, (void**) &amppqalSourceRewind );\newline	get_dlsym( &quotalSourcePause&quot, (void**) &amppqalSourcePause );\newline	get_dlsym( &quotalSourceQueueBuffers&quot, (void**) &amppqalSourceQueueBuffers );\newline	get_dlsym( &quotalSourceUnqueueBuffers&quot, (void**) &amppqalSourceUnqueueBuffers );\newline	get_dlsym( &quotalGenBuffers&quot, (void**) &amppqalGenBuffers );\newline	get_dlsym( &quotalDeleteBuffers&quot, (void**) &amppqalDeleteBuffers );\newline	get_dlsym( &quotalIsBuffer&quot, (void**) &amppqalIsBuffer );\newline	get_dlsym( &quotalBufferData&quot, (void**) &amppqalBufferData );\newline	get_dlsym( &quotalBufferf&quot, (void**) &amppqalBufferf );\newline	get_dlsym( &quotalBuffer3f&quot, (void**) &amppqalBuffer3f );\newline	get_dlsym( &quotalBufferfv&quot, (void**) &amppqalBufferfv );\newline	get_dlsym( &quotalBufferi&quot, (void**) &amppqalBufferi );\newline	get_dlsym( &quotalBuffer3i&quot, (void**) &amppqalBuffer3i );\newline	get_dlsym( &quotalBufferiv&quot, (void**) &amppqalBufferiv );\newline	get_dlsym( &quotalGetBufferf&quot, (void**) &amppqalGetBufferf );\newline	get_dlsym( &quotalGetBuffer3f&quot, (void**) &amppqalGetBuffer3f );\newline	get_dlsym( &quotalGetBufferfv&quot, (void**) &amppqalGetBufferfv );\newline	get_dlsym( &quotalGetBufferi&quot, (void**) &amppqalGetBufferi );\newline	get_dlsym( &quotalGetBuffer3i&quot, (void**) &amppqalGetBuffer3i );\newline	get_dlsym( &quotalGetBufferiv&quot, (void**) &amppqalGetBufferiv );\newline	get_dlsym( &quotalDopplerFactor&quot, (void**) &amppqalDopplerFactor );\newline	get_dlsym( &quotalDopplerVelocity&quot, (void**) &amppqalDopplerVelocity );\newline	get_dlsym( &quotalSpeedOfSound&quot, (void**) &amppqalSpeedOfSound );\newline	get_dlsym( &quotalDistanceModel&quot, (void**) &amppqalDistanceModel );\newline	get_dlsym( &quotalcCreateContext&quot, (void**) &amppqalcCreateContext );\newline	get_dlsym( &quotalcMakeContextCurrent&quot, (void**) &amppqalcMakeContextCurrent );\newline	get_dlsym( &quotalcProcessContext&quot, (void**) &amppqalcProcessContext );\newline	get_dlsym( &quotalcSuspendContext&quot, (void**) &amppqalcSuspendContext );\newline	get_dlsym( &quotalcDestroyContext&quot, (void**) &amppqalcDestroyContext );\newline	get_dlsym( &quotalcGetCurrentContext&quot, (void**) &amppqalcGetCurrentContext );\newline	get_dlsym( &quotalcGetContextsDevice&quot, (void**) &amppqalcGetContextsDevice );\newline	get_dlsym( &quotalcOpenDevice&quot, (void**) &amppqalcOpenDevice );\newline	get_dlsym( &quotalcCloseDevice&quot, (void**) &amppqalcCloseDevice );\newline	get_dlsym( &quotalcGetError&quot, (void**) &amppqalcGetError );\newline	get_dlsym( &quotalcIsExtensionPresent&quot, (void**) &amppqalcIsExtensionPresent );\newline	get_dlsym( &quotalcGetProcAddress&quot, (void**) &amppqalcGetProcAddress );\newline	get_dlsym( &quotalcGetEnumValue&quot, (void**) &amppqalcGetEnumValue );\newline	get_dlsym( &quotalcGetString&quot, (void**) &amppqalcGetString );\newline	get_dlsym( &quotalcGetIntegerv&quot, (void**) &amppqalcGetIntegerv );\newline	get_dlsym( &quotalcCaptureOpenDevice&quot, (void**) &amppqalcCaptureOpenDevice );\newline	get_dlsym( &quotalcCaptureCloseDevice&quot, (void**) &amppqalcCaptureCloseDevice );\newline	get_dlsym( &quotalcCaptureStart&quot, (void**) &amppqalcCaptureStart );\newline	get_dlsym( &quotalcCaptureStop&quot, (void**) &amppqalcCaptureStop );\newline	get_dlsym( &quotalcCaptureSamples&quot, (void**) &amppqalcCaptureSamples );\newline\newline	return !dlsym_error;\newline}\newline","\newline==\newlineQAL_Init()\newlineQAL_Shutdown()\newlineDynamically link/unlink OpenAL .dll\newline==\newline \newline","2090751","latentsvm.cpp","int clippingBoxes(int width, int height,\newline                  CvPoint *points, int kPoints)\newline{\newline    int i;\newline    for (i = 0; i &lt kPoints; i++)\newline    {\newline        if (points[i].x &gt width - 1)\newline        {\newline            points[i].x = width - 1;\newline        }\newline        if (points[i].x &lt 0)\newline        {\newline            points[i].x = 0;\newline        }\newline        if (points[i].y &gt height - 1)\newline        {\newline            points[i].y = height - 1;\newline        }\newline        if (points[i].y &lt 0)\newline        {\newline            points[i].y = 0;\newline        }\newline    }\newline    return LATENT_SVM_OK;\newline}\newline","\newline// Elimination boxes that are outside the image boudaries\newline//\newline// API\newline// int clippingBoxes(int width, int height,\newlineCvPoint points, int kPoints);\newline// INPUT\newline// width - image wediht\newline// height - image heigth\newline// points - a set of points (coordinates of top left or\newlinebottom right corners)\newline// kPoints - points number\newline// OUTPUT\newline// points - updated points (if coordinates less than zero then\newlineset zero coordinate, if coordinates more than image\newlinesize then set coordinates equal image size)\newline// RESULT\newline// Error status\newline \newline","2965599","qxmlquery.cpp","void QXmlQuery::setQuery(QIODevice *sourceCode, const QUrl &ampdocumentURI)\newline{\newline    if(!sourceCode)\newline    {\newline        qWarning(&quotA null QIODevice pointer cannot be passed.&quot);\newline        return;\newline    }\newline\newline    if(!sourceCode-&gtisReadable())\newline    {\newline        qWarning(&quotThe device must be readable.&quot);\newline        return;\newline    }\newline\newline    d-&gtqueryURI = QPatternist::XPathHelper::normalizeQueryURI(documentURI);\newline    d-&gtexpression(sourceCode);\newline}\newline","!\newlineSets this QXmlQuery to an XQuery read from the \\a sourceCode\newlinedevice. The device must have been opened with at least\newlineQIODevice::ReadOnly.\newline\\a documentURI represents the query obtained from the \\a sourceCode\newlinedevice. It is the base URI of the static context, as defined in the\newline\\l {http://www.w3.org/TR/xquery/}{XQuery language}. It is used\newlineinternally to resolve relative URIs that appear in the query, and\newlinefor message reporting. \\a documentURI can be empty. If it is empty,\newlinethe \\l{QCoreApplication::applicationFilePath()} {application file\newlinepath} is used. If it is not empty, it may be either relative or\newlineabsolute. If it is relative, it is resolved itself against the\newline\\l {QCoreApplication::applicationFilePath()} {application file\newlinepath} before it is used. If \\a documentURI is neither a valid URI\newlinenor empty, the result is undefined.\newlineIf the query contains a static error (e.g. syntax error), an error\newlinemessage is sent to the messageHandler(), and isValid() will return\newline\\e false.\newlineVariables must be bound before setQuery() is called.\newlineThe encoding of the XQuery in \\a sourceCode is detected internally\newlineusing the rules for setting and detecting encoding of XQuery files,\newlinewhich are explained in the \\l {http://www.w3.org/TR/xquery/}\newline{XQuery language}.\newlineIf \\a sourceCode is \\c null or not readable, or if \\a documentURI is not\newlinea valid URI, behavior is undefined.\newline\\sa isValid()\newline \newline","161053","backend_eps.c","static void eps_polygon(privcurve_t *curve, const color_t col) {\newline  int i;\newline  int m = curve-&gtn;\newline\newline  eps_linewidth(.02);\newline  eps_setcolor(col);\newline  eps_moveto(curve-&gtvertex[m-1]);\newline  for (i=0; i&ltm; i++) {\newline    eps_lineto(curve-&gtvertex[i]);\newline  }\newline  ship(&quotstroke\\n&quot);\newline}\newline","output polygon \newline","6419709","commands.c","static int cmd_filter(String *filter_regex, String *filter_name,\newline		      int is_negative, int is_case_insensitive)\newline{\newline    unsigned flags = REGCOMP_SAVE_MATCHED_PAREN_INFO;\newline\newline    kibishii_assert(lookup.slot);\newline\newline    if (COMBO(lookup.slot))\newline    {\newline	outputf(&quot%sslot is a combo; no filter allowed.\\n&quot, lookup.where);\newline	return COMMAND_HAS_ERROR;\newline    }\newline\newline    if (is_case_insensitive)\newline	flags |= REGCOMP_IGNORE_CASE;\newline\newline    if (lookup.slot-&gtfilter_spec.name)\newline    {\newline	free(lookup.slot-&gtfilter_spec.name);\newline	lookup.slot-&gtfilter_spec.name = 0;\newline    }\newline    if (lookup.slot-&gtfilter_spec.pattern)\newline    {\newline	free(lookup.slot-&gtfilter_spec.pattern);\newline	lookup.slot-&gtfilter_spec.pattern = 0;\newline	regfree(&amplookup.slot-&gtfilter_spec.regex);\newline    }\newline\newline    if (regcomp(&amplookup.slot-&gtfilter_spec.regex, filter_regex, flags)\newline	!= REGCOMP_SUCCESS)\newline    {\newline	outputf(&quot%s%s.\\n&quot, lookup.where,\newline		(string*)regcomp_error_report());\newline	return COMMAND_HAS_ERROR;\newline    }\newline    lookup.slot-&gtfilter_spec.name = filter_name ? strsave(filter_name) : 0;\newline    lookup.slot-&gtfilter_spec.pattern = strsave(filter_regex);\newline    lookup.slot-&gtfilter_spec.negative = is_negative;\newline    lookup.slot-&gtdefault_flag.filter = 1;\newline    return COMMAND_RUNS_OK;\newline}\newline","set the filter for a file \newline","4619484","mpg321.c","int getnext_place(int position)\newline{\newline	(position &lt buffer_size-1)?(position++):(position=0);\newline	return position;\newline}\newline","Get the next frame in the round buffer \newline","2693016","rwlock.h","static inline void _read_unlock(rwlock_t *lock)\newline{\newline    /*\newline     * Atomically decrement the reader count\newline     */\newline    atomic_sub(_QR_BIAS, &amplock-&gtcnts);\newline}\newline","\newline _read_unlock - release read lock of a queue rwlock.\newline @lock : Pointer to queue rwlock structure.\newline \newline","286784","main.c","static void close_consumer_sockets(void)\newline{\newline	int ret;\newline\newline	if (kconsumer_data.err_sock &gt= 0) {\newline		ret = close(kconsumer_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotkernel consumer err_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer32_data.err_sock &gt= 0) {\newline		ret = close(ustconsumer32_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd32 err_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer64_data.err_sock &gt= 0) {\newline		ret = close(ustconsumer64_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd64 err_sock close&quot);\newline		}\newline	}\newline	if (kconsumer_data.cmd_sock &gt= 0) {\newline		ret = close(kconsumer_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotkernel consumer cmd_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer32_data.cmd_sock &gt= 0) {\newline		ret = close(ustconsumer32_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd32 cmd_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer64_data.cmd_sock &gt= 0) {\newline		ret = close(ustconsumer64_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd64 cmd_sock close&quot);\newline		}\newline	}\newline}\newline","\newline Close every consumer sockets.\newline \newline","","on","","on","","on","","on","on","","","","","","","","","","","","","","","","","on","","","","","","","","","","","","","","","","","frequency counter for operater update","{}","cut the current selection to the clipboard","{}","Destroy this track","{}","Elimination boxes that are outside the image boudaries","{}","{}","set the filter for a file","Get the next frame in the round buffer","check boolean string;","release read lock of a queue","Close every consumer sockets.","return a 256-bit value that is practically unique","Create a new note","hide time","Draws text with cairo","SGSD for a given list of dummies and repes","Register the shut-down routine (DFSDPshutdown) for call with atexit","look for PC_ keywords;"
"3VW0145YLYCBUACFZBNV61DUB0SMJW","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:46 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:46 PDT 2019","","","33L7PJKHCGYSA83976WHS8VX5LV8T4","AVC62JNYAXA45","Approved","Wed Apr 17 14:08:45 PDT 2019","Wed Apr 17 14:23:49 PDT 2019","Fri Apr 19 14:23:49 PDT 2019","2019-04-19 21:24:21 UTC","","","904","100% (24/24)","100% (24/24)","100% (24/24)","1086458","fmopl.c","INLINE void CALC_FCSLOT(OPL_CH *CH,OPL_SLOT *SLOT)\newline{\newline	int ksr;\newline\newline	/* frequency step counter */\newline	SLOT-&gtIncr = CH-&gtfc * SLOT-&gtmul;\newline	ksr = CH-&gtkcode &gt&gt SLOT-&gtKSR;\newline\newline	if( SLOT-&gtksr != ksr )\newline	{\newline		SLOT-&gtksr = ksr;\newline		/* attack , decay rate recalcration */\newline		SLOT-&gtevsa = SLOT-&gtAR[ksr];\newline		SLOT-&gtevsd = SLOT-&gtDR[ksr];\newline		SLOT-&gtevsr = SLOT-&gtRR[ksr];\newline	}\newline	SLOT-&gtTLL = SLOT-&gtTL + (CH-&gtksl_base&gt&gtSLOT-&gtksl);\newline}\newline","---------- frequency counter for operater update ---------- \newline","5943353","bool.c","int bool_val(char *val)\newline{\newline	if (strlcmp(val, &quoton&quot) == 0 || strlcmp(val, &quottrue&quot) == 0 ||\newline	    strlcmp(val, &quotyes&quot) == 0)\newline		return 1;\newline	else if (strlcmp(val, &quotoff&quot) == 0 || strlcmp(val, &quotfalse&quot) == 0 ||\newline		 strlcmp(val, &quotno&quot) == 0)\newline		return 0;\newline	else\newline		return (int)strtol(val, NULL, 0);\newline}\newline","check boolean string; on, true, yes \newline","5595155","ccryptlib.c","static void make_nonce(xword32 nonce[8]) {\newline  char acc[512], host[256];\newline  struct timeval tv;\newline  static int count=0;\newline  \newline  gethostname(host, 256);   /* ignore failures */\newline  host[255] = 0;\newline  gettimeofday(&amptv, NULL);  /* ignore failures */\newline  sprintf(acc, &quot%s,%ld,%ld,%ld,%d&quot, host, (long)tv.tv_sec, (long)tv.tv_usec,\newline	  (long)getpid(), count++);\newline  hashstring(acc, nonce); \newline}\newline","return a 256-bit value that is practically unique \newline","3131421","notes.c","void add_new_note(void) {\newline	struct vnote *v;\newline\newline	v = vnote_new();\newline	if (v) {\newline		v-&gtuid = malloc(128);\newline		generate_uuid(v-&gtuid);\newline		v-&gtcolor_red = pastel_palette[3][0];\newline		v-&gtcolor_green = pastel_palette[3][1];\newline		v-&gtcolor_blue = pastel_palette[3][2];\newline		v-&gtbody = strdup(_(&quotClick on any note to edit it.&quot));\newline		write_vnote_to_server(v);\newline		vnote_free(v);\newline	}\newline	\newline	readloop(readfwd, eUseDefault);\newline}\newline","\newline Create a new note\newline \newline","2266926","game.c","void Tm_Hd()\newline{\newline    int w = gm.brd_w - gm.t_x * 2;\newline    int h = gm.f_wht-&gth;\newline\newline    D_DST(sdl.scr, gm.t_x + gm.b_x, gm.t_y, w, h);\newline    D_SRC(gm.s_bkgd, gm.t_x + gm.b_x, gm.t_y);\newline    SS_Blt();\newline    Sdl_AddR(gm.t_x + gm.b_x, gm.t_y, w, h);\newline}\newline","\newlinehide time\newline \newline","1193656","style.c","void style_draw_text(struct style *style, cairo_t *cairoctx, gchar *text, gdouble w, gdouble h)\newline{\newline	START_FUNC\newline	cairo_font_extents_t fe;\newline	cairo_text_extents_t te;\newline	PangoFontDescription *fontdesc;\newline	gchar *fontname;\newline	const gchar *fontfamilly;\newline	gchar *fontfamilly_with_fallback;\newline	GtkSettings *settings=NULL;\newline	cairo_font_slant_t slant;\newline	gint size=0.0;\newline\newline	style_cairo_status_check(cairoctx);\newline\newline	if (settings_get_bool(SETTINGS_SYSTEM_FONT)) {\newline		settings=gtk_settings_get_default();\newline		g_object_get(settings, &quotgtk-font-name&quot, &ampfontname, NULL);\newline	} else fontname=settings_get_string(SETTINGS_FONT);\newline	fontdesc=pango_font_description_from_string(fontname?fontname:FALLBACK_FONT &quot 10&quot);\newline	if (fontname) g_free(fontname);\newline	fontfamilly=pango_font_description_get_family(fontdesc);\newline	switch(pango_font_description_get_style(fontdesc)) {\newline		case PANGO_STYLE_NORMAL: slant=CAIRO_FONT_SLANT_NORMAL; break;\newline		case PANGO_STYLE_OBLIQUE: slant=CAIRO_FONT_SLANT_OBLIQUE; break;\newline		case PANGO_STYLE_ITALIC: slant=CAIRO_FONT_SLANT_ITALIC; break;\newline		default: flo_warn(_(&quotunknown slant for font %s: %d&quot), fontfamilly, pango_font_description_get_style(fontdesc));\newline			slant=CAIRO_FONT_SLANT_NORMAL; break;\newline	}\newline	fontfamilly_with_fallback = g_strconcat(fontfamilly, &quot,&quot FALLBACK_FONT, NULL);\newline\newline	cairo_save(cairoctx);\newline	style_cairo_set_color(cairoctx, STYLE_TEXT_OUTLINE_COLOR);\newline	cairo_select_font_face(cairoctx, fontfamilly_with_fallback, slant, \newline		pango_font_description_get_weight(fontdesc)&lt=500?CAIRO_FONT_WEIGHT_NORMAL:CAIRO_FONT_WEIGHT_BOLD);\newline	size=pango_font_description_get_size(fontdesc);\newline	if (pango_font_description_get_size_is_absolute(fontdesc)) {\newline		size=pango_units_to_double(size);\newline	}\newline	cairo_set_font_size(cairoctx, (gdouble)(size)/12800.);\newline	cairo_text_extents(cairoctx, text, &ampte);\newline	cairo_font_extents(cairoctx, &ampfe);\newline	if (te.width &gt w) {\newline		size=size*w/te.width;\newline		cairo_set_font_size(cairoctx, (gdouble)(size)/12800.);\newline		cairo_text_extents(cairoctx, text, &ampte);\newline		cairo_font_extents(cairoctx, &ampfe);\newline	} \newline	if (fe.height &gt h) {\newline		cairo_set_font_size(cairoctx, (gdouble)(size*h/fe.height)/12800.);\newline		cairo_text_extents(cairoctx, text, &ampte);\newline		cairo_font_extents(cairoctx, &ampfe);\newline	}\newline	cairo_move_to(cairoctx, (w-te.width)/2.-te.x_bearing, ((h+fe.height)/2.)-fe.descent);\newline	cairo_set_line_width(cairoctx, 0.1);\newline	cairo_text_path(cairoctx, text);\newline	cairo_stroke(cairoctx);\newline	style_cairo_set_color(cairoctx, STYLE_TEXT_COLOR);\newline	cairo_move_to(cairoctx, (w-te.width)/2.-te.x_bearing, ((h+fe.height)/2.)-fe.descent);\newline	cairo_text_path(cairoctx, text);\newline	cairo_fill(cairoctx);\newline	cairo_restore(cairoctx);\newline\newline	g_free(fontfamilly_with_fallback);\newline	pango_font_description_free(fontdesc);\newline	END_FUNC\newline}\newline","Draws text with cairo \newline","4135694","xperm_new.c","void SGSD(int *vds, int vdsl, int *dummies, int dl, int *mQ,\newline          int *vrs, int vrsl, int *repes, int rl, int n,\newline          int firstd, int *KD, int *KDl, int *bD, int *bDl) {\newline\newline	if (dl==0 &amp&amp rl==0) {\newline		*KDl=0;\newline		*bDl=0;\newline		return;\newline	} /* else */\newline\newline        int *tmp, tmpl;\newline        int *tmpGS   = (int*)malloc(n*n*sizeof(int)), tmpGSl;\newline        int *tmpbase = (int*)malloc(  n*sizeof(int)), tmpbasel;\newline	int i, itotal;\newline\newline        /* Loop over all dummysets */\newline        itotal = 0;\newline	*KDl = 0;\newline	*bDl = 0;\newline        for (i=0; i&ltvdsl; i++) {\newline                tmpl = vds[i];\newline                tmp = dummies + itotal;\newline                movedummyset(firstd, tmp, tmpl, mQ[i]);\newline                itotal = itotal + tmpl;\newline                SGSofdummyset(tmp, tmpl, mQ[i], n, \newline                    tmpGS, &amptmpGSl, tmpbase, &amptmpbasel);\newline                copy_list(tmpGS, KD+(*KDl)*n, tmpGSl*n);\newline                *KDl = *KDl + tmpGSl;\newline                copy_list(tmpbase, bD+ *bDl, tmpbasel);\newline                *bDl = *bDl + tmpbasel;\newline        }\newline\newline        /* Loop over all repeatedsets */\newline        itotal=0;\newline        for (i=0; i&ltvrsl; i++) {\newline                tmpl = vrs[i];\newline                tmp = repes + itotal;\newline                moverepeatedset(firstd, tmp, tmpl);\newline                itotal = itotal + tmpl;\newline                SGSofrepeatedset(tmp, tmpl, n, \newline                    tmpGS, &amptmpGSl, tmpbase, &amptmpbasel);\newline                copy_list(tmpGS, KD+(*KDl)*n, tmpGSl*n);\newline                *KDl = *KDl + tmpGSl;\newline                copy_list(tmpbase, bD+ *bDl, tmpbasel);\newline                *bDl = *bDl + tmpbasel;\newline        }\newline\newline        free(tmpGS);\newline	free(tmpbase);\newline\newline#ifdef VERBOSE_DOUBLE\newline	printf(&quotbase of D:&quot); print_list(bD, *bDl, 1);		/*PPC*/\newline	printf(&quotGS of D (%d perms of degree %d):&quot, *KDl, n);	/*PPC*/\newline	print_array_perm(KD, *KDl, n, 1);			/*PPC*/\newline#endif								/*PPC*/\newline}\newline","SGSD for a given list of dummies and repes \newline","683172","dfsd.c","PRIVATE intn DFSDIstart(void)\newline{\newline    CONSTR(FUNC, &quotDFSDIstart&quot);    /* for HERROR */\newline    intn        ret_value = SUCCEED;\newline\newline    /* Don&#039t call this routine again... */\newline    library_terminate = TRUE;\newline\newline    /* Install atexit() library cleanup routine */\newline    if (HPregister_term_func(&ampDFSDPshutdown) != 0)\newline      HGOTO_ERROR(DFE_CANTINIT, FAIL);\newline\newlinedone:\newline  if(ret_value == FAIL)   \newline    { /* Error condition cleanup */\newline\newline    } /* end if */\newline\newline  /* Normal function cleanup */\newline\newline    return(ret_value);\newline} /* end DFSDIstart() */\newline","--------------------------------------------------------------------------\newlineNAME\newlineDFSDIstart\newlinePURPOSE\newlineDFSD-level initialization routine\newlineUSAGE\newlineintn DFSDIstart()\newlineRETURNS\newlineReturns SUCCEED/FAIL\newlineDESCRIPTION\newlineRegister the shut-down routine (DFSDPshutdown) for call with atexit\newlineGLOBAL VARIABLES\newlineCOMMENTS, BUGS, ASSUMPTIONS\newlineEXAMPLES\newlineREVISION LOG\newline-------------------------------------------------------------------------- \newline","2944550","obsdata.c","static int scan_for_PC(struct ccd_frame *fr, struct wcs *fim)\newline{\newline	double pc[2][2];\newline	int ret = 0;\newline	double D;\newline\newline	if (fits_get_double(fr, P_STR(FN_CROTA1), &ampfim-&gtrot) &lt= 0)\newline		fim-&gtrot = 0;\newline\newline	if ( (fits_get_double(fr, P_STR(FN_CDELT1), &ampfim-&gtxinc) &lt= 0) ||\newline	     (fits_get_double(fr, P_STR(FN_CDELT2), &ampfim-&gtyinc) &lt= 0) ) {\newline		return 0;\newline	}\newline\newline	if (fits_get_double(fr, &quotPC1_1&quot, &amppc[0][0]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[0][0] = 1;\newline	}\newline	if (fits_get_double(fr, &quotPC1_2&quot, &amppc[0][1]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[0][1] = 0;\newline	}\newline	if (fits_get_double(fr, &quotPC2_1&quot, &amppc[1][0]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[1][0] = 0;\newline	}\newline	if (fits_get_double(fr, &quotPC2_2&quot, &amppc[1][1]) &gt 0) {\newline		ret = 1;\newline	} else {\newline		pc[1][1] = 1;\newline	}\newline\newline\newline	D = pc[0][0] * pc[1][1] - pc[1][0] * pc[0][1];\newline	d4_printf(&quotPC D=%8g\\n&quot, D);\newline	if (fabs(D) &lt 1e-30) {\newline		err_printf(&quotPC matrix is singular!\\n&quot);\newline		return 0;\newline	}\newline\newline	if (ret) {\newline//		fim-&gtflags |= WCS_USE_LIN;\newline	}\newline\newline	fim-&gtpc[0][0] = pc[0][0];\newline	fim-&gtpc[1][0] = pc[1][0];\newline	fim-&gtpc[0][1] = pc[0][1];\newline	fim-&gtpc[1][1] = pc[1][1];\newline	fim-&gtrot = raddeg(atan2(pc[0][1], pc[0][0]));\newline\newline	return 1;\newline}\newline","look for PC_ keywords; return 1 if found (and update fim) \newline","4562286","getpass.c","char *getpass_r(const char *prompt, char *buffer, size_t buflen)\newline{\newline  long sts;\newline  short chan;\newline\newline  /* MSK, 23-JAN-2004, iosbdef.h wasn&#039t in VAX V7.2 or CC 6.4  */\newline  /* distribution so I created this.  May revert back later to */\newline  /* struct _iosb iosb;                                        */\newline  struct _iosb\newline     {\newline     short int iosb$w_status; /* status     */\newline     short int iosb$w_bcnt;   /* byte count */\newline     int       unused;        /* unused     */\newline     } iosb;\newline\newline  $DESCRIPTOR(ttdesc, &quotTT&quot);\newline\newline  buffer[0]=&#039\\0&#039;\newline  sts = sys$assign(&ampttdesc, &ampchan,0,0);\newline  if (sts &amp 1) {\newline    sts = sys$qiow(0, chan,\newline                   IO$_READPROMPT | IO$M_NOECHO,\newline                   &ampiosb, 0, 0, buffer, buflen, 0, 0,\newline                   prompt, strlen(prompt));\newline\newline    if((sts &amp 1) &amp&amp (iosb.iosb$w_status&amp1))\newline      buffer[iosb.iosb$w_bcnt] = &#039\\0&#039;\newline\newline    sts = sys$dassgn(chan);\newline  }\newline  return buffer; /* we always return success */\newline}\newline","#include iosbdef \newline","780458","term.c","void gtk_term_cut(GtkWidget *widget)\newline{\newline	GtkTerm	*term;\newline	gchar *s;\newline\newline	g_return_if_fail (widget != NULL);\newline	g_return_if_fail (GTK_IS_TERM (widget));\newline\newline	term = GTK_TERM (widget);\newline	\newline	if (term-&gtepos!=term-&gtpos) {\newline		if(gtk_selection_owner_set(widget,GDK_SELECTION_PRIMARY,GDK_CURRENT_TIME)) {\newline			if (term-&gtepos&gtterm-&gtpos) {\newline				s = g_strndup(&amp((e_get_text(term-&gta,term-&gtcur))[term-&gtpos]),term-&gtepos-term-&gtpos);\newline				e_remove_text(term-&gta,term-&gtcur,term-&gtpos,term-&gtepos-term-&gtpos);\newline				term-&gtepos = term-&gtpos;\newline			} else {\newline				s = g_strndup(&amp((e_get_text(term-&gta,term-&gtcur))[term-&gtepos]),term-&gtpos-term-&gtepos);\newline				e_remove_text(term-&gta,term-&gtcur,term-&gtepos,term-&gtpos-term-&gtepos);\newline				term-&gtpos = term-&gtepos;\newline			}\newline			g_string_assign(term-&gtclipboard,s);\newline			g_free(s);\newline			gtk_term_update_caret(term);\newline			gtk_term_scroll_to_pos(term);\newline			if (!term-&gtchanged) {\newline				g_signal_emit(GTK_OBJECT(term),gtk_term_signals[GTK_TERM_CHANGED],0);\newline				term-&gtchanged = 1;\newline			}\newline		} else {\newline			g_print(&quoteuler could not own the selection\\n&quot);\newline		}\newline	}\newline}\newline","gtk_term_cut\newline cut the current selection to the clipboard\newline \newline","6249163","dictdplugin_dbi.c","static int connect_to_sqldb (\newline   global_data *dict_data)\newline{\newline#ifndef CONNECT_TO_SERVER_ONCE\newline   int err;\newline\newline   err = init_dbi_conn (dict_data);\newline   if (err)\newline      return err;\newline#endif\newline\newline   if (-1 == dbi_conn_connect (dict_data -&gt m_dbi_conn)){\newline      dbi_error (dict_data, dict_data -&gt m_dbi_conn);\newline\newline      return 13;\newline   }\newline\newline   return 0;\newline}\newline","returns zero if success \newline","236278","track.cpp","track::~track()\newline{\newline	emit destroyedTrack();\newline\newline	while( !m_trackContentObjects.isEmpty() )\newline	{\newline		delete m_trackContentObjects.last();\newline	}\newline\newline	m_trackContainer-&gtremoveTrack( this );\newline}\newline","! \\brief Destroy this track\newline \newline If the track container is a Beat+Bassline container, step through\newline its list of tracks and remove us.\newline \newline Then delete the trackContentObject&#039s contents, remove this track from\newline the track container.\newline \newline Finally step through this track&#039s automation and forget all of them.\newline \newline","1786228","qal_win.c","qboolean QAL_Init( void )\newline{\newline	char *buf = NULL;\newline\newline	hinstOpenAL = LoadLibrary( libopenal_name );\newline	if( hinstOpenAL == NULL )\newline	{\newline		FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,\newline		        GetLastError(), MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), ( LPTSTR ) &amp buf,\newline		        0, NULL );\newline		Com_Printf( &quot%s\\n&quot, buf );\newline		return false;\newline	}\newline\newline	dlsym_error = false;\newline	get_dlsym( &quotalEnable&quot, (void**) &amppqalEnable );\newline	get_dlsym( &quotalDisable&quot, (void**) &amppqalDisable );\newline	get_dlsym( &quotalIsEnabled&quot, (void**) &amppqalIsEnabled );\newline	get_dlsym( &quotalGetBooleanv&quot, (void**) &amppqalGetBooleanv );\newline	get_dlsym( &quotalGetIntegerv&quot, (void**) &amppqalGetIntegerv );\newline	get_dlsym( &quotalGetString&quot, (void**) &amppqalGetString );\newline	get_dlsym( &quotalGetFloatv&quot, (void**) &amppqalGetFloatv );\newline	get_dlsym( &quotalGetDoublev&quot, (void**) &amppqalGetDoublev );\newline	get_dlsym( &quotalGetBoolean&quot, (void**) &amppqalGetBoolean );\newline	get_dlsym( &quotalGetInteger&quot, (void**) &amppqalGetInteger );\newline	get_dlsym( &quotalGetFloat&quot, (void**) &amppqalGetFloat );\newline	get_dlsym( &quotalGetDouble&quot, (void**) &amppqalGetDouble );\newline	get_dlsym( &quotalGetError&quot, (void**) &amppqalGetError );\newline	get_dlsym( &quotalIsExtensionPresent&quot, (void**) &amppqalIsExtensionPresent );\newline	get_dlsym( &quotalGetProcAddress&quot, (void**) &amppqalGetProcAddress );\newline	get_dlsym( &quotalGetEnumValue&quot, (void**) &amppqalGetEnumValue );\newline	get_dlsym( &quotalListenerf&quot, (void**) &amppqalListenerf );\newline	get_dlsym( &quotalListener3f&quot, (void**) &amppqalListener3f );\newline	get_dlsym( &quotalListenerfv&quot, (void**) &amppqalListenerfv );\newline	get_dlsym( &quotalListeneri&quot, (void**) &amppqalListeneri );\newline	get_dlsym( &quotalListener3i&quot, (void**) &amppqalListener3i );\newline	get_dlsym( &quotalListeneriv&quot, (void**) &amppqalListeneriv );\newline	get_dlsym( &quotalGetListenerf&quot, (void**) &amppqalGetListenerf );\newline	get_dlsym( &quotalGetListener3f&quot, (void**) &amppqalGetListener3f );\newline	get_dlsym( &quotalGetListenerfv&quot, (void**) &amppqalGetListenerfv );\newline	get_dlsym( &quotalGetListeneri&quot, (void**) &amppqalGetListeneri );\newline	get_dlsym( &quotalGetListener3i&quot, (void**) &amppqalGetListener3i );\newline	get_dlsym( &quotalGetListeneriv&quot, (void**) &amppqalGetListeneriv );\newline	get_dlsym( &quotalGenSources&quot, (void**) &amppqalGenSources );\newline	get_dlsym( &quotalDeleteSources&quot, (void**) &amppqalDeleteSources );\newline	get_dlsym( &quotalIsSource&quot, (void**) &amppqalIsSource );\newline	get_dlsym( &quotalSourcef&quot, (void**) &amppqalSourcef );\newline	get_dlsym( &quotalSource3f&quot, (void**) &amppqalSource3f );\newline	get_dlsym( &quotalSourcefv&quot, (void**) &amppqalSourcefv );\newline	get_dlsym( &quotalSourcei&quot, (void**) &amppqalSourcei );\newline	get_dlsym( &quotalSource3i&quot, (void**) &amppqalSource3i );\newline	get_dlsym( &quotalSourceiv&quot, (void**) &amppqalSourceiv );\newline	get_dlsym( &quotalGetSourcef&quot, (void**) &amppqalGetSourcef );\newline	get_dlsym( &quotalGetSource3f&quot, (void**) &amppqalGetSource3f );\newline	get_dlsym( &quotalGetSourcefv&quot, (void**) &amppqalGetSourcefv );\newline	get_dlsym( &quotalGetSourcei&quot, (void**) &amppqalGetSourcei );\newline	get_dlsym( &quotalGetSource3i&quot, (void**) &amppqalGetSource3i );\newline	get_dlsym( &quotalGetSourceiv&quot, (void**) &amppqalGetSourceiv );\newline	get_dlsym( &quotalSourcePlayv&quot, (void**) &amppqalSourcePlayv );\newline	get_dlsym( &quotalSourceStopv&quot, (void**) &amppqalSourceStopv );\newline	get_dlsym( &quotalSourceRewindv&quot, (void**) &amppqalSourceRewindv );\newline	get_dlsym( &quotalSourcePausev&quot, (void**) &amppqalSourcePausev );\newline	get_dlsym( &quotalSourcePlay&quot, (void**) &amppqalSourcePlay );\newline	get_dlsym( &quotalSourceStop&quot, (void**) &amppqalSourceStop );\newline	get_dlsym( &quotalSourceRewind&quot, (void**) &amppqalSourceRewind );\newline	get_dlsym( &quotalSourcePause&quot, (void**) &amppqalSourcePause );\newline	get_dlsym( &quotalSourceQueueBuffers&quot, (void**) &amppqalSourceQueueBuffers );\newline	get_dlsym( &quotalSourceUnqueueBuffers&quot, (void**) &amppqalSourceUnqueueBuffers );\newline	get_dlsym( &quotalGenBuffers&quot, (void**) &amppqalGenBuffers );\newline	get_dlsym( &quotalDeleteBuffers&quot, (void**) &amppqalDeleteBuffers );\newline	get_dlsym( &quotalIsBuffer&quot, (void**) &amppqalIsBuffer );\newline	get_dlsym( &quotalBufferData&quot, (void**) &amppqalBufferData );\newline	get_dlsym( &quotalBufferf&quot, (void**) &amppqalBufferf );\newline	get_dlsym( &quotalBuffer3f&quot, (void**) &amppqalBuffer3f );\newline	get_dlsym( &quotalBufferfv&quot, (void**) &amppqalBufferfv );\newline	get_dlsym( &quotalBufferi&quot, (void**) &amppqalBufferi );\newline	get_dlsym( &quotalBuffer3i&quot, (void**) &amppqalBuffer3i );\newline	get_dlsym( &quotalBufferiv&quot, (void**) &amppqalBufferiv );\newline	get_dlsym( &quotalGetBufferf&quot, (void**) &amppqalGetBufferf );\newline	get_dlsym( &quotalGetBuffer3f&quot, (void**) &amppqalGetBuffer3f );\newline	get_dlsym( &quotalGetBufferfv&quot, (void**) &amppqalGetBufferfv );\newline	get_dlsym( &quotalGetBufferi&quot, (void**) &amppqalGetBufferi );\newline	get_dlsym( &quotalGetBuffer3i&quot, (void**) &amppqalGetBuffer3i );\newline	get_dlsym( &quotalGetBufferiv&quot, (void**) &amppqalGetBufferiv );\newline	get_dlsym( &quotalDopplerFactor&quot, (void**) &amppqalDopplerFactor );\newline	get_dlsym( &quotalDopplerVelocity&quot, (void**) &amppqalDopplerVelocity );\newline	get_dlsym( &quotalSpeedOfSound&quot, (void**) &amppqalSpeedOfSound );\newline	get_dlsym( &quotalDistanceModel&quot, (void**) &amppqalDistanceModel );\newline	get_dlsym( &quotalcCreateContext&quot, (void**) &amppqalcCreateContext );\newline	get_dlsym( &quotalcMakeContextCurrent&quot, (void**) &amppqalcMakeContextCurrent );\newline	get_dlsym( &quotalcProcessContext&quot, (void**) &amppqalcProcessContext );\newline	get_dlsym( &quotalcSuspendContext&quot, (void**) &amppqalcSuspendContext );\newline	get_dlsym( &quotalcDestroyContext&quot, (void**) &amppqalcDestroyContext );\newline	get_dlsym( &quotalcGetCurrentContext&quot, (void**) &amppqalcGetCurrentContext );\newline	get_dlsym( &quotalcGetContextsDevice&quot, (void**) &amppqalcGetContextsDevice );\newline	get_dlsym( &quotalcOpenDevice&quot, (void**) &amppqalcOpenDevice );\newline	get_dlsym( &quotalcCloseDevice&quot, (void**) &amppqalcCloseDevice );\newline	get_dlsym( &quotalcGetError&quot, (void**) &amppqalcGetError );\newline	get_dlsym( &quotalcIsExtensionPresent&quot, (void**) &amppqalcIsExtensionPresent );\newline	get_dlsym( &quotalcGetProcAddress&quot, (void**) &amppqalcGetProcAddress );\newline	get_dlsym( &quotalcGetEnumValue&quot, (void**) &amppqalcGetEnumValue );\newline	get_dlsym( &quotalcGetString&quot, (void**) &amppqalcGetString );\newline	get_dlsym( &quotalcGetIntegerv&quot, (void**) &amppqalcGetIntegerv );\newline	get_dlsym( &quotalcCaptureOpenDevice&quot, (void**) &amppqalcCaptureOpenDevice );\newline	get_dlsym( &quotalcCaptureCloseDevice&quot, (void**) &amppqalcCaptureCloseDevice );\newline	get_dlsym( &quotalcCaptureStart&quot, (void**) &amppqalcCaptureStart );\newline	get_dlsym( &quotalcCaptureStop&quot, (void**) &amppqalcCaptureStop );\newline	get_dlsym( &quotalcCaptureSamples&quot, (void**) &amppqalcCaptureSamples );\newline\newline	return !dlsym_error;\newline}\newline","\newline==\newlineQAL_Init()\newlineQAL_Shutdown()\newlineDynamically link/unlink OpenAL .dll\newline==\newline \newline","2090751","latentsvm.cpp","int clippingBoxes(int width, int height,\newline                  CvPoint *points, int kPoints)\newline{\newline    int i;\newline    for (i = 0; i &lt kPoints; i++)\newline    {\newline        if (points[i].x &gt width - 1)\newline        {\newline            points[i].x = width - 1;\newline        }\newline        if (points[i].x &lt 0)\newline        {\newline            points[i].x = 0;\newline        }\newline        if (points[i].y &gt height - 1)\newline        {\newline            points[i].y = height - 1;\newline        }\newline        if (points[i].y &lt 0)\newline        {\newline            points[i].y = 0;\newline        }\newline    }\newline    return LATENT_SVM_OK;\newline}\newline","\newline// Elimination boxes that are outside the image boudaries\newline//\newline// API\newline// int clippingBoxes(int width, int height,\newlineCvPoint points, int kPoints);\newline// INPUT\newline// width - image wediht\newline// height - image heigth\newline// points - a set of points (coordinates of top left or\newlinebottom right corners)\newline// kPoints - points number\newline// OUTPUT\newline// points - updated points (if coordinates less than zero then\newlineset zero coordinate, if coordinates more than image\newlinesize then set coordinates equal image size)\newline// RESULT\newline// Error status\newline \newline","2965599","qxmlquery.cpp","void QXmlQuery::setQuery(QIODevice *sourceCode, const QUrl &ampdocumentURI)\newline{\newline    if(!sourceCode)\newline    {\newline        qWarning(&quotA null QIODevice pointer cannot be passed.&quot);\newline        return;\newline    }\newline\newline    if(!sourceCode-&gtisReadable())\newline    {\newline        qWarning(&quotThe device must be readable.&quot);\newline        return;\newline    }\newline\newline    d-&gtqueryURI = QPatternist::XPathHelper::normalizeQueryURI(documentURI);\newline    d-&gtexpression(sourceCode);\newline}\newline","!\newlineSets this QXmlQuery to an XQuery read from the \\a sourceCode\newlinedevice. The device must have been opened with at least\newlineQIODevice::ReadOnly.\newline\\a documentURI represents the query obtained from the \\a sourceCode\newlinedevice. It is the base URI of the static context, as defined in the\newline\\l {http://www.w3.org/TR/xquery/}{XQuery language}. It is used\newlineinternally to resolve relative URIs that appear in the query, and\newlinefor message reporting. \\a documentURI can be empty. If it is empty,\newlinethe \\l{QCoreApplication::applicationFilePath()} {application file\newlinepath} is used. If it is not empty, it may be either relative or\newlineabsolute. If it is relative, it is resolved itself against the\newline\\l {QCoreApplication::applicationFilePath()} {application file\newlinepath} before it is used. If \\a documentURI is neither a valid URI\newlinenor empty, the result is undefined.\newlineIf the query contains a static error (e.g. syntax error), an error\newlinemessage is sent to the messageHandler(), and isValid() will return\newline\\e false.\newlineVariables must be bound before setQuery() is called.\newlineThe encoding of the XQuery in \\a sourceCode is detected internally\newlineusing the rules for setting and detecting encoding of XQuery files,\newlinewhich are explained in the \\l {http://www.w3.org/TR/xquery/}\newline{XQuery language}.\newlineIf \\a sourceCode is \\c null or not readable, or if \\a documentURI is not\newlinea valid URI, behavior is undefined.\newline\\sa isValid()\newline \newline","161053","backend_eps.c","static void eps_polygon(privcurve_t *curve, const color_t col) {\newline  int i;\newline  int m = curve-&gtn;\newline\newline  eps_linewidth(.02);\newline  eps_setcolor(col);\newline  eps_moveto(curve-&gtvertex[m-1]);\newline  for (i=0; i&ltm; i++) {\newline    eps_lineto(curve-&gtvertex[i]);\newline  }\newline  ship(&quotstroke\\n&quot);\newline}\newline","output polygon \newline","6419709","commands.c","static int cmd_filter(String *filter_regex, String *filter_name,\newline		      int is_negative, int is_case_insensitive)\newline{\newline    unsigned flags = REGCOMP_SAVE_MATCHED_PAREN_INFO;\newline\newline    kibishii_assert(lookup.slot);\newline\newline    if (COMBO(lookup.slot))\newline    {\newline	outputf(&quot%sslot is a combo; no filter allowed.\\n&quot, lookup.where);\newline	return COMMAND_HAS_ERROR;\newline    }\newline\newline    if (is_case_insensitive)\newline	flags |= REGCOMP_IGNORE_CASE;\newline\newline    if (lookup.slot-&gtfilter_spec.name)\newline    {\newline	free(lookup.slot-&gtfilter_spec.name);\newline	lookup.slot-&gtfilter_spec.name = 0;\newline    }\newline    if (lookup.slot-&gtfilter_spec.pattern)\newline    {\newline	free(lookup.slot-&gtfilter_spec.pattern);\newline	lookup.slot-&gtfilter_spec.pattern = 0;\newline	regfree(&amplookup.slot-&gtfilter_spec.regex);\newline    }\newline\newline    if (regcomp(&amplookup.slot-&gtfilter_spec.regex, filter_regex, flags)\newline	!= REGCOMP_SUCCESS)\newline    {\newline	outputf(&quot%s%s.\\n&quot, lookup.where,\newline		(string*)regcomp_error_report());\newline	return COMMAND_HAS_ERROR;\newline    }\newline    lookup.slot-&gtfilter_spec.name = filter_name ? strsave(filter_name) : 0;\newline    lookup.slot-&gtfilter_spec.pattern = strsave(filter_regex);\newline    lookup.slot-&gtfilter_spec.negative = is_negative;\newline    lookup.slot-&gtdefault_flag.filter = 1;\newline    return COMMAND_RUNS_OK;\newline}\newline","set the filter for a file \newline","4619484","mpg321.c","int getnext_place(int position)\newline{\newline	(position &lt buffer_size-1)?(position++):(position=0);\newline	return position;\newline}\newline","Get the next frame in the round buffer \newline","2693016","rwlock.h","static inline void _read_unlock(rwlock_t *lock)\newline{\newline    /*\newline     * Atomically decrement the reader count\newline     */\newline    atomic_sub(_QR_BIAS, &amplock-&gtcnts);\newline}\newline","\newline _read_unlock - release read lock of a queue rwlock.\newline @lock : Pointer to queue rwlock structure.\newline \newline","286784","main.c","static void close_consumer_sockets(void)\newline{\newline	int ret;\newline\newline	if (kconsumer_data.err_sock &gt= 0) {\newline		ret = close(kconsumer_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotkernel consumer err_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer32_data.err_sock &gt= 0) {\newline		ret = close(ustconsumer32_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd32 err_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer64_data.err_sock &gt= 0) {\newline		ret = close(ustconsumer64_data.err_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd64 err_sock close&quot);\newline		}\newline	}\newline	if (kconsumer_data.cmd_sock &gt= 0) {\newline		ret = close(kconsumer_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotkernel consumer cmd_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer32_data.cmd_sock &gt= 0) {\newline		ret = close(ustconsumer32_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd32 cmd_sock close&quot);\newline		}\newline	}\newline	if (ustconsumer64_data.cmd_sock &gt= 0) {\newline		ret = close(ustconsumer64_data.cmd_sock);\newline		if (ret &lt 0) {\newline			PERROR(&quotUST consumerd64 cmd_sock close&quot);\newline		}\newline	}\newline}\newline","\newline Close every consumer sockets.\newline \newline","","on","","on","","on","","","","","","on","","","","","","","on","on","","","","","","","","","","","","","","","","","","","","","","","frequency counter for operater update","{}","cut the current selection to the clipboard","{}","Destroy this track","{}","Elimination boxes that are outside the image boudaries","Sets this QXmlQuery to an XQuery read from the \a sourceCodedevice.","output polygon","set the filter for a file","Get the next frame in the round buffer","{}","release read lock of a queue rwlock.","Close every consumer sockets.","return a 256-bit value that is practically unique","Create a new note","hide time","Draws text with cairo","{}","{}","look for PC_ keywords;"
"3X55NP42EOG6UZ73O6N07YQ0K8HP3J","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3M0NZ3JDP1Y592T6F0EW2CMNORXZ5Q","A2MX5YW3DSQ61W","Approved","Wed Apr 17 15:21:39 PDT 2019","Wed Apr 17 15:26:28 PDT 2019","Fri Apr 19 15:26:28 PDT 2019","2019-04-19 22:27:21 UTC","","","289","100% (5/5)","100% (5/5)","100% (5/5)","2323573","dcomm.c","void dos_comm_port_send_break(comm_port *port, int msec_duration)\newline{\newline   /* The timer needs to be installed */\newline   if (!_dzdos_timer_installed) dzdos_install_timer();\newline\newline   /* Start the break signal */\newline   dos_comm_port_start_break(port);\newline   \newline   /* Set up an interrupt to stop the interrupt in msec_durations time */\newline   dzdos_install_param_int(dos_comm_port_eob_int, (void *)port, msec_duration);\newline}\newline","--------------------- DOS COMM PORT SEND BREAK --------------------- \newline","6434814","m_pseudo.c","int m_pseudo(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\newline{\newline  char *text, buffer[BUFSIZE];\newline  struct s_map *map;\newline  struct nick_host *nh;\newline\newline  assert(0 != cptr);\newline  assert(cptr == sptr);\newline  assert(0 != cli_user(sptr));\newline\newline  /* By default, relay the message straight through. */\newline  text = parv[parc - 1];\newline\newline  if (parc &lt 3 || EmptyString(text))\newline    return send_reply(sptr, ERR_NOTEXTTOSEND);\newline\newline  /* HACK! HACK! HACK! HACK! Yes. It&#039s icky, but\newline   * it&#039s the only way. */\newline  map = (struct s_map *)parv[1];\newline  assert(0 != map);\newline\newline  if (map-&gtprepend) {\newline    ircd_snprintf(0, buffer, sizeof(buffer) - 1, &quot%s%s&quot, map-&gtprepend, text);\newline    buffer[sizeof(buffer) - 1] = 0;\newline    text = buffer;\newline  }\newline\newline  for (nh = map-&gtservices; nh; nh = nh-&gtnext) {\newline    struct Client *target, *server;\newline\newline    if (NULL == (server = FindServer(nh-&gtnick + nh-&gtnicklen + 1)))\newline      continue;\newline    nh-&gtnick[nh-&gtnicklen] = &#039\\0&#039;\newline    if ((NULL == (target = FindUser(nh-&gtnick)))\newline        || (server != cli_user(target)-&gtserver))\newline      continue;\newline    nh-&gtnick[nh-&gtnicklen] = &#039@&#039;\newline    relay_directed_message(sptr, nh-&gtnick, nh-&gtnick + nh-&gtnicklen, text);\newline    return 0;\newline  }\newline\newline  return send_reply(sptr, ERR_SERVICESDOWN, map-&gtname);\newline}\newline","\newline m_pseudo - generic service message handler\newline \newline parv[0] = sender prefix\newline parv[1] = service mapping (s_map disguised as char )\newline parv[2] = message\newline \newline","4854578","ovl.c","static char* ovl_get_coverage_point(\newline  statement* stmt  /*!&lt Pointer to statement of task call to coverage task */\newline) { PROFILE(OVL_GET_COVERAGE_POINT);\newline\newline  char* cpoint;  /* Return value for this function */\newline\newline  /*\newline   We are going to make a lot of assumptions about the structure of the statement, so just\newline   do a lot of assertions to make sure that our assumptions are correct.\newline  */\newline  assert( stmt != NULL );\newline  assert( stmt-&gtexp != NULL );\newline  assert( stmt-&gtexp-&gtleft != NULL );\newline  assert( stmt-&gtexp-&gtleft-&gtop == EXP_OP_PASSIGN );\newline  assert( stmt-&gtexp-&gtleft-&gtright != NULL );\newline  assert( stmt-&gtexp-&gtleft-&gtright-&gtop == EXP_OP_STATIC );\newline  assert( ESUPPL_STATIC_BASE( stmt-&gtexp-&gtleft-&gtright-&gtsuppl ) == QSTRING );\newline\newline  cpoint = vector_to_string( stmt-&gtexp-&gtleft-&gtright-&gtvalue, ESUPPL_STATIC_BASE( stmt-&gtexp-&gtleft-&gtright-&gtsuppl ), FALSE, 0 );\newline\newline  PROFILE_END;\newline\newline  return( cpoint );\newline\newline}\newline","!\newline\\return Returns the string passed to the task call\newlineFinds the task call parameter that specifies the name of the coverage point and returns this\newlinestring value to the calling function.\newline \newline","4829226","node_mgr.c","bool is_node_resp (char *name)\newline{\newline#ifdef HAVE_FRONT_END\newline	front_end_record_t *node_ptr;\newline\newline	node_ptr = find_front_end_record (name);\newline#else\newline	struct node_record *node_ptr;\newline\newline	node_ptr = find_node_record (name);\newline#endif\newline	if (node_ptr == NULL) {\newline		error (&quotis_node_resp unable to find node %s&quot, name);\newline		return false;\newline	}\newline\newline	if (IS_NODE_NO_RESPOND(node_ptr))\newline		return false;\newline	return true;\newline}\newline","\newline is_node_resp - determine if the specified node&#039s state is responding\newline IN name - name of the node\newline RET true if node exists and is responding, otherwise false\newline \newline","1832110","speakermatch.cpp","void SpeakerMatch::LoadFile(const string&amp filename)\newline{\newline	string line;\newline	ifstream file;\newline	long int lineNum = -1;\newline	\newline	file.open(filename.c_str(), ifstream::in);\newline    \newline	if (! file.is_open())\newline	{ \newline		LOG_FATAL(logger, &quotError opening SpeakerMatch file &quot + filename); \newline		exit(E_LOAD); \newline	}\newline	\newline	while (getline(file,line,&#039\\n&#039))\newline    {\newline		++lineNum;\newline		\newline        if (line.find_first_of(&quot#&quot) == 0)\newline		{\newline			//comment so skip (for now)\newline		}\newline		else if(line == string(&quotFile,Channel,RefSpeaker,SysSpeaker,isMapped,timeOverlap&quot))\newline		{\newline			// CSV header\newline		}		\newline        else\newline        // if Type is &#039LEXEME&#039 we take it, unless we drop the line\newline        {\newline			size_t index = 0;\newline			size_t lpos = 0;\newline			string delim = string(&quot,&quot);\newline			size_t pos = line.find_first_of(delim, lpos);\newline			string tokens[6];\newline						\newline			do\newline			{\newline				if(index == 6)\newline				{\newline					char buffer[BUFFER_SIZE];\newline					sprintf(buffer, &quotToo much: Error parsing the line %li in file %s&quot, lineNum, filename.c_str());\newline					LOG_ERR(logger, buffer);\newline				}\newline				\newline				tokens[index] = line.substr(lpos, pos - lpos);\newline				++index;\newline				lpos = ( pos == string::npos ) ?  string::npos : pos + 1;\newline				pos = line.find_first_of(delim, lpos);\newline			}\newline			while( lpos != string::npos );\newline			\newline			if(index != 6)\newline			{\newline				char buffer[BUFFER_SIZE];\newline				sprintf(buffer, &quotToo few: Error parsing the line %li in file %s&quot, lineNum, filename.c_str());\newline				LOG_ERR(logger, buffer);\newline			}\newline			\newline			if( tokens[4] == string(&quotmapped&quot) )\newline			{\newline				//SetSysRef(string(l_file), string(l_channel), string(l_sys), string(l_ref));\newline				//transform(tokens[3].begin(), tokens[3].end(), tokens[3].begin(), (int(*)(int)) toupper);\newline				//transform(tokens[2].begin(), tokens[2].end(), tokens[2].begin(), (int(*)(int)) toupper);\newline				SetSysRef(tokens[0], tokens[1], tokens[3], tokens[2]);\newline			}\newline		}\newline    }\newline    \newline    file.close();\newline    LOG_INFO(logger, &quotloading of file &quot + filename + &quot done&quot);\newline}\newline","Load the file \newline","101216","window.c","void window_update_name_legacy(i3Window *win, xcb_get_property_reply_t *prop, bool before_mgmt) {\newline    if (prop == NULL || xcb_get_property_value_length(prop) == 0) {\newline        DLOG(&quotWM_NAME not set (_NET_WM_NAME is what you want anyways).\\n&quot);\newline        FREE(prop);\newline        return;\newline    }\newline\newline    /* ignore update when the window is known to already have a UTF-8 name */\newline    if (win-&gtuses_net_wm_name) {\newline        free(prop);\newline        return;\newline    }\newline\newline    i3string_free(win-&gtname);\newline    win-&gtname = i3string_from_utf8_with_length(xcb_get_property_value(prop),\newline                                               xcb_get_property_value_length(prop));\newline\newline    Con *con = con_by_window_id(win-&gtid);\newline    if (con != NULL &amp&amp con-&gttitle_format != NULL) {\newline        i3String *name = con_parse_title_format(con);\newline        ewmh_update_visible_name(win-&gtid, i3string_as_utf8(name));\newline        I3STRING_FREE(name);\newline    }\newline\newline    LOG(&quotWM_NAME changed to \\&quot%s\\&quot\\n&quot, i3string_as_utf8(win-&gtname));\newline    LOG(&quotUsing legacy window title. Note that in order to get Unicode window &quot\newline        &quottitles in i3, the application has to set _NET_WM_NAME (UTF-8)\\n&quot);\newline\newline    win-&gtname_x_changed = true;\newline\newline    if (before_mgmt) {\newline        free(prop);\newline        return;\newline    }\newline\newline    run_assignments(win);\newline\newline    free(prop);\newline}\newline","\newline Updates the name by using WM_NAME (encoded in COMPOUND_TEXT). We do not\newline touch what the client sends us but pass it to xcb_image_text_8. To get\newline proper unicode rendering, the application has to use _NET_WM_NAME (see\newline window_update_name()).\newline \newline \newline","4764187","ledmon.c","static void _ledmon_help(void)\newline{\newline	printf(ledmon_version, VERSION_MAJOR, VERSION_MINOR);\newline	printf(&quot\\nUsage: %s [OPTIONS]\\n\\n&quot, progname);\newline	printf(&quotMandatory arguments for long options are mandatory for short &quot\newline	       &quotoptions, too.\\n\\n&quot);\newline	printf(&quot--interval=VALUE\\t\\t  Set time interval to VALUE seconds.\\n&quot\newline	       &quot\\t\\t\\t\\t  The smallest interval is 5 seconds.\\n&quot);\newline	printf(&quot--config=PATH,  -c PATH\\t\\t  Use alternate configuration file &quot\newline	       &quot(not yet\\n\\t\\t\\t\\t  implemented).\\n&quot);\newline	printf\newline	    (&quot--log=PATH\\t\\t\\t  Use local log file instead\\n\\t\\t\\t\\t  /var/log/&quot\newline	     &quotledmon.log global file.\\n&quot);\newline	printf(&quot--help\\t\\t\\t\\t  Displays this help text.\\n&quot);\newline	printf\newline	    (&quot--version\\t\\t\\t  Displays version and license information.\\n\\n&quot);\newline	printf(&quotRefer to ledmon(8) man page for more detailed description.\\n&quot);\newline	printf(&quotBugs should be reported at: &quot\newline	       &quothttp://sourceforge.net/p/ledmon/bugs \\n&quot);\newline}\newline","\newline @brief Displays the help.\newline \newline This is internal function of monitor service. The function prints the name\newline and version of the program out. It displays the usage and available options\newline and its arguments (if any). Each option is described. This is an extract\newline from user manual page.\newline \newline @return The function does not return a value.\newline \newline","2142965","pseudo.c","int pty_open(int *masterfd, int *slavefd, char *slavename, size_t slavenamesize,\newline        const struct termios *slave_termios,\newline        const struct winsize *slave_winsize)\newline{\newline#if defined(HAVE_OPENPTY) || defined(BSD4_4)\newline    /* openpty(3) exists in OSF/1 and some other os&#039es */\newline\newline#ifdef HAVE_TTYNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master and slave descriptors, set ownership and permissions */\newline\newline    if (openpty(masterfd, slavefd, NULL, NULL, NULL) == -1)\newline        return -1;\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_TTYNAME_R\newline    if ((err = ttyname_r(*slavefd, buf, 64))) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ttyname(*slavefd))) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(ENOSPC);\newline    }\newline#else /* HAVE_OPENPTY */\newline#ifdef HAVE__GETPTY\newline\newline    /*\newline     * _getpty(3) exists in SGI Irix 4.x, 5.x &amp 6.x -- it generates more\newline     * pty&#039s automagically when needed\newline     */\newline\newline    char *slave;\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor and get the slave&#039s device name */\newline\newline    if (!(slave = _getpty(masterfd, O_RDWR, 0622, 0)))\newline        return -1;\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline#else /* HAVE__GETPTY */\newline#if defined(HAVE_DEV_PTMX)\newline\newline    /*\newline     * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\newline     * also has bsd-style ptys, but they simply do not work.)\newline     */\newline\newline#ifdef HAVE_PTSNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor */\newline\newline    if ((*masterfd = open(&quot/dev/ptmx&quot, O_RDWR | O_NOCTTY)) == -1)\newline        return -1;\newline\newline    /* Set slave ownership and permissions to real uid of process */\newline\newline    if (grantpt(*masterfd) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Unlock the slave so it can be opened */\newline\newline    if (unlockpt(*masterfd) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_PTSNAME_R\newline    if ((err = ptsname_r(*masterfd, buf, 64))) {\newline        close(*masterfd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ptsname(*masterfd))) {\newline        close(*masterfd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Turn the slave into a terminal */\newline\newline#ifndef HAVE_CYGWIN\newline#ifndef HAVE_LINUX              /* linux does not use the streams module */\newline    /*\newline     * Push the appropriate streams modules, as described in Solaris pts(7).\newline     * HP-UX pts(7) doesn&#039t have ttcompat module.\newline     */\newline    if (ioctl(*slavefd, I_PUSH, &quotptem&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    if (ioctl(*slavefd, I_PUSH, &quotldterm&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline#ifndef __hpux\newline    if (ioctl(*slavefd, I_PUSH, &quotttcompat&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline#endif\newline#endif\newline#endif\newline\newline#else /* HAVE_DEV_PTMX */\newline#ifdef HAVE_DEV_PTS_AND_PTC\newline\newline    /* AIX-style pty code */\newline\newline#ifdef HAVE_TTYNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor */\newline\newline    if ((*masterfd = open(&quot/dev/ptc&quot, O_RDWR | O_NOCTTY)) == -1)\newline        return -1;\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_TTYNAME_R\newline    if ((err = ttyname_r(*masterfd, buf, 64))) {\newline        close(*masterfd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ttyname(*masterfd))) {\newline        close(*masterfd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(name, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline#else /* HAVE_DEV_PTS_AND_PTC */\newline\newline    /* BSD-style pty code */\newline    const char *const ptymajors =\newline            &quotpqrstuvwxyzabcdefghijklmnoABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\newline    const char *const ptyminors = &quot0123456789abcdef&quot;\newline    int num_minors = strlen(ptyminors);\newline    int num_ptys = strlen(ptymajors) * num_minors;\newline    char buf[64];\newline    int found = 0;\newline    int i;\newline\newline    /* Identify the first available pty master device */\newline\newline    for (i = 0; !found &amp&amp i &lt num_ptys; i++) {\newline        snprintf(buf, sizeof buf, &quot/dev/pty%c%c&quot, ptymajors[i / num_minors],\newline                ptyminors[i % num_minors]);\newline        snprintf(slavename, slavenamesize, &quot/dev/tty%c%c&quot,\newline                ptymajors[i / num_minors], ptyminors[i % num_minors]);\newline\newline        /* Open the master descriptor */\newline\newline        if ((*masterfd = open(buf, O_RDWR | O_NOCTTY)) == -1) {\newline            /* Try SCO style naming */\newline            snprintf(buf, sizeof buf, &quot/dev/ptyp%d&quot, i);\newline            snprintf(slavename, slavenamesize, &quot/dev/ttyp%d&quot, i);\newline\newline            if ((*masterfd = open(buf, O_RDWR | O_NOCTTY)) == -1)\newline                continue;\newline        }\newline\newline        /* Set slave ownership and permissions to real uid of process */\newline\newline        pty_set_owner(slavename, getuid());\newline\newline        /* Open the slave descriptor */\newline\newline        if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline            close(*masterfd);\newline            return -1;\newline        }\newline\newline        found = 1;\newline    }\newline\newline    if (!found)\newline        return set_errno(ENOENT);\newline\newline#endif /* HAVE_DEV_PTS_AND_PTC */\newline#endif /* HAVE_DEV_PTMX */\newline#endif /* HAVE__GETPTY */\newline#endif /* HAVE_OPENPTY */\newline\newline    /* Set the slave&#039s terminal attributes if requested */\newline\newline    if (slave_termios &amp&amp tcsetattr(*slavefd, TCSANOW, slave_termios) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    /* Set the slave&#039s window size if required */\newline\newline    if (slave_winsize &amp&amp ioctl(*slavefd, TIOCSWINSZ, slave_winsize) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    return 0;\newline}\newline","pty_open: A safe version of openpty. \newline Allocates and opens a pseudo terminal. The new descriptor for the \newline master side of the pseudo terminal is stored in masterfd. The new \newline descriptor for the slave side of the pseudo terminal is stored in slavefd. \newline The device name of the slave side of the pseudo terminal is stored in the \newline buffer pointed to by slavename which must be able to hold at least 64 \newline characters. slavenamesize is the size of the buffer pointed to by \newline slavename. No more than slavenamesize bytes will be written into the \newline buffer pointed to by slavename, including the terminating nul byte. \newline If slave_termios is not null, it is passed to tcsetattr with the \newline command TCSANOW to set the terminal attributes of the slave device. \newline If slave_winsize is not null, it is passed to ioctl with the command \newline TIOCSWINSZ to set the window size of the slave device. On success, \newline returns 0. On error, returns -1 with errno set appropriately.\newline \newline","5209723","msg_vm.cpp","static inline int __MSG_vm_is_state(msg_vm_t vm, e_surf_vm_state_t state)\newline{\newline  return static_cast&ltsimgrid::s4u::VirtualMachine*&gt(vm)-&gtpimpl_vm_-&gtgetState() == state;\newline}\newline","Check state of a VM \newline","284472","rule.c","int rtnl_rule_delete(struct nl_sock *sk, struct rtnl_rule *rule, int flags)\newline{\newline	struct nl_msg *msg;\newline	int err;\newline	\newline	if ((err = rtnl_rule_build_delete_request(rule, flags, &ampmsg)) &lt 0)\newline		return err;\newline\newline	err = nl_send_auto_complete(sk, msg);\newline	nlmsg_free(msg);\newline	if (err &lt 0)\newline		return err;\newline\newline	return wait_for_ack(sk);\newline}\newline","\newline Delete a rule\newline @arg sk Netlink socket.\newline @arg rule rule to delete\newline @arg flags additional netlink message flags\newline \newline Builds a netlink message by calling rtnl_rule_build_delete_request(),\newline sends the request to the kernel and waits for the next ACK to be\newline received and thus blocks until the request has been fullfilled.\newline \newline @return 0 on sucess or a negative error if an error occured.\newline \newline","277953","fastq-lex.c","\newline/* %if-c-only */\newlinestatic int yy_init_globals (yyscan_t yyscanner)\newline{\newline    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\newline    /* Initialization is the same as for the non-reentrant scanner.\newline     * This function is called from FASTQ_lex_destroy(), so don&#039t allocate here.\newline     */\newline\newline    yyg-&gtyy_buffer_stack = 0;\newline    yyg-&gtyy_buffer_stack_top = 0;\newline    yyg-&gtyy_buffer_stack_max = 0;\newline    yyg-&gtyy_c_buf_p = (char *) 0;\newline    yyg-&gtyy_init = 0;\newline    yyg-&gtyy_start = 0;\newline\newline    yyg-&gtyy_start_stack_ptr = 0;\newline    yyg-&gtyy_start_stack_depth = 0;\newline    yyg-&gtyy_start_stack =  NULL;\newline\newline    yyg-&gtyy_state_buf = 0;\newline    yyg-&gtyy_state_ptr = 0;\newline    yyg-&gtyy_full_match = 0;\newline    yyg-&gtyy_lp = 0;\newline\newline/* Defined in main.c */\newline#ifdef YY_STDINIT\newline    yyin = stdin;\newline    yyout = stdout;\newline#else\newline    yyin = (FILE *) 0;\newline    yyout = (FILE *) 0;\newline#endif\newline\newline    /* For future reference: Set errno on error, since we are called by\newline     * FASTQ_lex_init()\newline     */\newline    return 0;\newline}\newline","%endif if-c-only \newline","5973447","timer.c","void pfunc(ntimer_t *t)\newline{\newline  t-&gtcallback(t-&gtdata);\newline}\newline","perform the function scheduled in t. \newline","286488","index.c","void relay_index_close_all(struct relay_stream *stream)\newline{\newline	struct lttng_ht_iter iter;\newline	struct relay_index *index;\newline\newline	rcu_read_lock();\newline	cds_lfht_for_each_entry(stream-&gtindexes_ht-&gtht, &ampiter.iter,\newline			index, index_n.node) {\newline		/* Put self-ref from index. */\newline		relay_index_put(index);\newline	}\newline	rcu_read_unlock();\newline}\newline","\newline Close every relay index within a given stream, without flushing\newline them.\newline \newline","4564800","vmgahp_common.cpp","int systemCommand( ArgList &ampargs, priv_state priv, StringList *cmd_out, StringList * cmd_in,\newline		   StringList *cmd_err, bool merge_stderr_with_stdout)\newline{\newline	int result = 0;\newline	FILE *fp = NULL;\newline	FILE * fp_for_stdin = NULL;\newline	FILE * childerr = NULL;\newline	MyString line;\newline	char buff[1024];\newline	StringList *my_cmd_out = cmd_out;\newline\newline	priv_state prev = get_priv_state();\newline\newline	int stdout_pipes[2];\newline	int stdin_pipes[2];\newline	int pid;\newline	bool use_privsep = false;\newline	switch ( priv ) {\newline	case PRIV_ROOT:\newline		prev = set_root_priv();\newline		break;\newline	case PRIV_USER:\newline	case PRIV_USER_FINAL:\newline		prev = set_user_priv();\newline#if !defined(WIN32)\newline		if ( privsep_enabled() &amp&amp (job_user_uid != get_condor_uid()) ) {\newline			use_privsep = true;\newline		}\newline#endif\newline		break;\newline	default:\newline		// Stay as Condor user, this should be a no-op\newline		prev = set_condor_priv();\newline	}\newline#if defined(WIN32)\newline	if((cmd_in != NULL) || (cmd_err != NULL))\newline	  {\newline	    vmprintf(D_ALWAYS, &quotInvalid use of systemCommand() in Windows.\\n&quot);\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline	//if ( use_privsep ) {\newline	//	fp = privsep_popen(args, &quotr&quot, want_stderr, job_user_uid);\newline	//}\newline	//else {\newline	fp = my_popen( args, &quotr&quot, merge_stderr_with_stdout );\newline	//}\newline#else\newline	// The old way of doing things (and the Win32 way of doing\newline	//	things)\newline	// fp = my_popen( args, &quotr&quot, want_stderr );\newline	if((cmd_err != NULL) &amp&amp merge_stderr_with_stdout)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotInvalid use of systemCommand().\\n&quot);\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline\newline	PrivSepForkExec psforkexec;\newline	char ** args_array = args.GetStringArray();\newline	int error_pipe[2];\newline		// AIX 5.2, Solaris 5.9, HPUX 11 don&#039t have AF_LOCAL\newline\newline	if(pipe(stdin_pipes) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError creating pipe: %s\\n&quot, strerror(errno));\newline		deleteStringArray( args_array );\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline	if(pipe(stdout_pipes) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError creating pipe: %s\\n&quot, strerror(errno));\newline	    close(stdin_pipes[0]);\newline	    close(stdin_pipes[1]);\newline		deleteStringArray( args_array );\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline\newline	if ( use_privsep ) {\newline	  if(!psforkexec.init())\newline	    {\newline	      vmprintf(D_ALWAYS,\newline		       &quotmy_popenv failure on %s\\n&quot,\newline		       args_array[0]);\newline	      close(stdin_pipes[0]);\newline	      close(stdin_pipes[1]);\newline	      close(stdout_pipes[0]);\newline	      close(stdout_pipes[1]);\newline		  deleteStringArray( args_array );\newline	      set_priv( prev );\newline	      return -1;\newline	    }\newline	}\newline\newline	if(cmd_err != NULL)\newline	  {\newline	    if(pipe(error_pipe) &lt 0)\newline	      {\newline		vmprintf(D_ALWAYS, &quotCould not open pipe for error output: %s\\n&quot, strerror(errno));\newline		close(stdin_pipes[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline		close(stdout_pipes[1]);\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline		return -1;\newline	      }\newline	  }\newline	// Now fork and do what my_popen used to do\newline	pid = fork();\newline	if(pid &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError forking: %s\\n&quot, strerror(errno));\newline		close(stdin_pipes[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline		close(stdout_pipes[1]);\newline		if(cmd_err != NULL) {\newline			close(error_pipe[0]);\newline			close(error_pipe[1]);\newline		}\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline	    return -1;\newline	  }\newline	if(pid == 0)\newline	  {\newline	    close(stdout_pipes[0]);\newline	    close(stdin_pipes[1]);\newline	    dup2(stdout_pipes[1], STDOUT_FILENO);\newline	    dup2(stdin_pipes[0], STDIN_FILENO);\newline\newline	    if(merge_stderr_with_stdout) dup2(stdout_pipes[1], STDERR_FILENO);\newline	    else if(cmd_err != NULL) \newline	      {\newline		close(error_pipe[0]);\newline		dup2(error_pipe[1], STDERR_FILENO);\newline	      }\newline\newline\newline			/* to be safe, we want to switch our real uid/gid to our\newline			   effective uid/gid (shedding any privledges we&#039ve got).\newline			   we also want to drop any supplimental groups we&#039re in.\newline			   we want to run this popen()&#039ed thing as our effective\newline			   uid/gid, dropping the real uid/gid.  all of these calls\newline			   will fail if we don&#039t have a ruid of 0 (root), but\newline			   that&#039s harmless.  also, note that we have to stash our\newline			   effective uid, then switch our euid to 0 to be able to\newline			   set our real uid/gid.\newline			   We wrap some of the calls in if-statements to quiet some\newline			   compilers that object to us not checking the return values.\newline			*/\newline	    uid_t euid = geteuid();\newline	    gid_t egid = getegid();\newline	    if ( seteuid( 0 ) ) { }\newline	    setgroups( 1, &ampegid );\newline	    if ( setgid( egid ) ) { }\newline	    if ( setuid( euid ) ) _exit(ENOEXEC); // Unsafe?\newline	    \newline	    install_sig_handler(SIGPIPE, SIG_DFL);\newline	    sigset_t sigs;\newline	    sigfillset(&ampsigs);\newline	    sigprocmask(SIG_UNBLOCK, &ampsigs, NULL);\newline\newline\newline	    MyString cmd = args_array[0];\newline\newline	    if ( use_privsep ) {\newline	    \newline	      ArgList al;\newline	      psforkexec.in_child(cmd, al);\newline          deleteStringArray( args_array );\newline	      args_array = al.GetStringArray();\newline	    }\newline\newline\newline	    execvp(cmd.Value(), args_array);\newline	    vmprintf(D_ALWAYS, &quotCould not execute %s: %s\\n&quot, args_array[0], strerror(errno));\newline	    exit(-1);\newline	  }\newline	close(stdin_pipes[0]);\newline	close(stdout_pipes[1]);\newline	fp_for_stdin = fdopen(stdin_pipes[1], &quotw&quot);\newline	fp = fdopen(stdout_pipes[0], &quotr&quot);\newline	if(cmd_err != NULL)\newline	  {\newline	    close(error_pipe[1]);\newline	    childerr = fdopen(error_pipe[0],&quotr&quot);\newline	    if(childerr == 0)\newline	      {\newline		vmprintf(D_ALWAYS, &quotCould not open pipe for reading child error output: %s\\n&quot, strerror(errno));\newline		close(error_pipe[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline	    fclose(fp);\newline		fclose(fp_for_stdin);\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline		return -1;\newline	      }\newline	  }\newline\newline	if ( use_privsep ) {\newline	  FILE* _fp = psforkexec.parent_begin();\newline	  privsep_exec_set_uid(_fp, job_user_uid);\newline	  privsep_exec_set_path(_fp, args_array[0]);\newline	  privsep_exec_set_args(_fp, args);\newline	  Env env;\newline	  env.MergeFrom(environ);\newline	  privsep_exec_set_env(_fp, env);\newline	  privsep_exec_set_iwd(_fp, &quot.&quot);\newline\newline	  privsep_exec_set_inherit_fd(_fp, 1);\newline	  privsep_exec_set_inherit_fd(_fp, 2);\newline	  privsep_exec_set_inherit_fd(_fp, 0);\newline	\newline	  if (!psforkexec.parent_end()) {\newline	    vmprintf(D_ALWAYS,\newline		     &quotmy_popenv failure on %s\\n&quot,\newline		     args_array[0]);\newline	    fclose(fp);\newline		fclose(fp_for_stdin);\newline		if (childerr) {\newline			fclose(childerr);\newline		}\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline	    return -1;\newline	  }\newline	}\newline\newline	deleteStringArray( args_array );\newline#endif\newline	set_priv( prev );\newline	if ( fp == NULL ) {\newline		MyString args_string;\newline		args.GetArgsStringForDisplay( &ampargs_string, 0 );\newline		vmprintf( D_ALWAYS, &quotFailed to execute command: %s\\n&quot,\newline				  args_string.Value() );\newline		if (childerr)\newline			fclose(childerr);\newline		return -1;\newline	}\newline\newline	if(cmd_in != NULL) {\newline	  cmd_in-&gtrewind();\newline	  char * tmp;\newline	  while((tmp = cmd_in-&gtnext()) != NULL)\newline	    {\newline	      fprintf(fp_for_stdin, &quot%s\\n&quot, tmp);\newline	      fflush(fp_for_stdin);\newline	    }\newline	}\newline	if (fp_for_stdin) {\newline	  // So that we will not be waiting for output while the\newline	  // script waits for stdin to be closed.\newline	  fclose(fp_for_stdin);\newline	}\newline\newline	if ( my_cmd_out == NULL ) {\newline		my_cmd_out = new StringList();\newline	}\newline\newline	while ( fgets( buff, sizeof(buff), fp ) != NULL ) {\newline		line += buff;\newline		if ( line.chomp() ) {\newline			my_cmd_out-&gtappend( line.Value() );\newline			line = &quot&quot;\newline		}\newline	}\newline\newline	if(cmd_err != NULL)\newline	  {\newline	    while(fgets(buff, sizeof(buff), childerr) != NULL)\newline	      {\newline		line += buff;\newline		if(line.chomp())\newline		  {\newline		    cmd_err-&gtappend(line.Value());\newline		    line = &quot&quot;\newline		  }\newline	      }\newline	    fclose(childerr);\newline	  }\newline#if defined(WIN32)\newline	result = my_pclose( fp );\newline#else\newline	// Why close first?  Just in case the child process is waiting\newline	// on a read, and we have nothing more to send it.  It will\newline	// now receive a SIGPIPE.\newline	fclose(fp);\newline	if(waitpid(pid, &ampresult, 0) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotUnable to wait: %s\\n&quot, strerror(errno));\newline		if ( cmd_out == NULL ) {\newline			delete my_cmd_out;\newline		}\newline	   \newline	    return -1;\newline	  }\newline#endif\newline	if( result != 0 ) {\newline		MyString args_string;\newline		args.GetArgsStringForDisplay(&ampargs_string,0);\newline		vmprintf(D_ALWAYS,\newline		         &quotCommand returned non-zero: %s\\n&quot,\newline		         args_string.Value());\newline		my_cmd_out-&gtrewind();\newline		const char *next_line;\newline		while ( (next_line = my_cmd_out-&gtnext()) ) {\newline			vmprintf( D_ALWAYS, &quot  %s\\n&quot, next_line );\newline		}\newline	}\newline	if ( cmd_out == NULL ) {\newline		delete my_cmd_out;\newline	}\newline	return result;\newline}\newline","\newline merge_stderr_with_stdout is intended for clients of this function\newline that wish to have the old behavior, where stderr and stdout were\newline both added to the same StringList.\newline \newline","1311260","multi.c","int_hash_function(const void *key, uint32_t iv)\newline{\newline    return (unsigned long)key;\newline}\newline","\newline inotify watcher descriptors are used as hash value\newline \newline","4047518","random1.c","static void random1_bang(t_random1 *x)\newline{\newline    int n = x-&gtx_f;\newline    double nval;\newline    unsigned int m;\newline    // this seems weird?\newline    m = (RAND_MAX * 2);\newline    //    unsigned int a = 1588635695, m = 4294967291U, q = 2, r = 1117695901;\newline\newline    //    post(&quotcxc/randomix.c: x_state: %d&quot,x-&gtx_state);\newline    x-&gtx_state = rand_random1(x-&gtx_state);\newline    nval = ((double)x-&gtx_state / (double)m) * (double)(x-&gtx_g - x-&gtx_f) + (double)x-&gtx_f;\newline    //    post(&quotcxc/randomix.c: lolim: %f, uplim: %f&quot, x-&gtx_f, x-&gtx_g);\newline    //    post(&quotcxc/randomix.c: nval: %f&quot,nval);\newline    outlet_float(x-&gtx_obj.ob_outlet, nval);\newline}\newline","works if your floating pt. mantissa has at least 53 bits.\newlinefaster than other versions \newline","1813066","sha1.c","void sha1_hmac_reset( sha1_context *ctx )\newline{\newline    sha1_starts( ctx );\newline    sha1_update( ctx, ctx-&gtipad, 64 );\newline}\newline","\newline SHA1 HMAC context reset\newline \newline","801897","iterator.h","GIT_INLINE(int) git_iterator_advance(\newline	const git_index_entry **entry, git_iterator *iter)\newline{\newline	return iter-&gtcb-&gtadvance(entry, iter);\newline}\newline","\newline Advance to the next item for the iterator.\newline \newline If GIT_ITERATOR_INCLUDE_TREES is set, this may be a tree item. If\newline GIT_ITERATOR_DONT_AUTOEXPAND is set, calling this again when on a tree\newline item will skip over all the items under that tree.\newline \newline","317088","wav2cdr.c","void help (void)\newline{\newline	fprintf (msgfile,\newline#include &quothelp.-c&quot\newline	, CDAUDIOSAMPLINGRATE\newline	, CDAUDIOSECTORSIZE\newline	, CDSECTORSPERSEC\newline	);\newline\newline	exit_error (ERR_USAGE, NULL, NULL);\newline\newline} /* help() */\newline","\newline Display help and exit.\newline In: ---\newline \newline","883051","array.c","void * ci_ptr_vector_add(ci_vector_t *vector, void *value)\newline{\newline    void **indx;\newline    ci_mem_allocator_t *packer = vector-&gtalloc;\newline    assert(packer);\newline\newline    if (!value)\newline        return NULL;\newline\newline    indx = ci_pack_allocator_alloc_unaligned(packer, array_item_size(void *));\newline    if (!indx) {\newline        ci_debug_printf(2, &quotNot enough space to add the new item to ptr_vector!\\n&quot);\newline        return NULL;\newline    }\newline    /*Store the pointer to the last ellement */\newline    *(vector-&gtlast) = value;\newline\newline    /*And create a new NULL terminated item: */\newline    vector-&gtlast = indx;\newline    *(vector-&gtlast) = NULL;\newline    vector-&gtcount++;\newline    return value;\newline}\newline","ci_ptr_vector functions.... \newline","4962291","addfeedwizard.cpp","void AddFeedWizard::newFolder()\newline{\newline  AddFolderDialog *addFolderDialog = new AddFolderDialog(this);\newline  QList&ltQTreeWidgetItem *&gt treeItems =\newline      addFolderDialog-&gtfoldersTree_-&gtfindItems(foldersTree_-&gtcurrentItem()-&gttext(1),\newline                                               Qt::MatchFixedString | Qt::MatchRecursive,\newline                                               1);\newline  addFolderDialog-&gtfoldersTree_-&gtsetCurrentItem(treeItems.at(0));\newline\newline  if (addFolderDialog-&gtexec() == QDialog::Rejected) {\newline    delete addFolderDialog;\newline    return;\newline  }\newline\newline  int folderId = 0;\newline  QString folderText = addFolderDialog-&gtnameFeedEdit_-&gttext();\newline  int parentId = addFolderDialog-&gtfoldersTree_-&gtcurrentItem()-&gttext(1).toInt();\newline\newline  // Calculate row number to insert folder\newline  int rowToParent = 0;\newline  QSqlQuery q;\newline  q.exec(QString(&quotSELECT count(id) FROM feeds WHERE parentId=&#039%1&#039&quot).arg(parentId));\newline  if (q.first())\newline    rowToParent = q.value(0).toInt();\newline\newline  // Add folder\newline  q.prepare(&quotINSERT INTO feeds(text, created, parentId, rowToParent) &quot\newline            &quotVALUES (:text, :feedCreateTime, :parentId, :rowToParent)&quot);\newline  q.bindValue(&quot:text&quot, folderText);\newline  q.bindValue(&quot:feedCreateTime&quot,\newline              QLocale::c().toString(QDateTime::currentDateTimeUtc(), &quotyyyy-MM-ddTHH:mm:ss&quot));\newline  q.bindValue(&quot:parentId&quot, parentId);\newline  q.bindValue(&quot:rowToParent&quot, rowToParent);\newline  q.exec();\newline\newline  folderId = q.lastInsertId().toInt();\newline  q.finish();\newline\newline  treeItems = foldersTree_-&gtfindItems(QString::number(parentId),\newline                                      Qt::MatchFixedString | Qt::MatchRecursive,\newline                                      1);\newline  QStringList treeItem;\newline  treeItem &lt&lt folderText &lt&lt QString::number(folderId);\newline  QTreeWidgetItem *treeWidgetItem = new QTreeWidgetItem(treeItem);\newline  treeItems.at(0)-&gtaddChild(treeWidgetItem);\newline  foldersTree_-&gtsetCurrentItem(treeWidgetItem);\newline\newline  delete addFolderDialog;\newline}\newline","! \\brief Adding new folder \newline","on","","on","","","on","on","on","","","","","on","","","","","on","","","","","","","","","","","","","","","","","","on","","","","on","","","{}","Builds a netlink message","{}","perform the function scheduled in t.","Close every relay index within a given stream, without flushingthem.","{}","{}","{}","context reset","Advance to the next item for the iterator.","Display help and exit.","generic service message handler","{}","Adding new folder","Finds the task call parameter that specifies the name of the","determine if the specified node's state is responding","Load the file","{}","prints the nameand version of the program out.","Allocates and opens a pseudo terminal.","Check state of a VM"
"3X55NP42EOG6UZ73O6N07YQ0K8HP3J","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3VD82FOHKQOE9JOES1QN0KLTW4COCH","A1NV81QEC0GDG7","Approved","Wed Apr 17 15:06:12 PDT 2019","Wed Apr 17 15:09:55 PDT 2019","Fri Apr 19 15:09:55 PDT 2019","2019-04-19 22:10:21 UTC","","","223","100% (5/5)","100% (5/5)","100% (5/5)","2323573","dcomm.c","void dos_comm_port_send_break(comm_port *port, int msec_duration)\newline{\newline   /* The timer needs to be installed */\newline   if (!_dzdos_timer_installed) dzdos_install_timer();\newline\newline   /* Start the break signal */\newline   dos_comm_port_start_break(port);\newline   \newline   /* Set up an interrupt to stop the interrupt in msec_durations time */\newline   dzdos_install_param_int(dos_comm_port_eob_int, (void *)port, msec_duration);\newline}\newline","--------------------- DOS COMM PORT SEND BREAK --------------------- \newline","6434814","m_pseudo.c","int m_pseudo(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\newline{\newline  char *text, buffer[BUFSIZE];\newline  struct s_map *map;\newline  struct nick_host *nh;\newline\newline  assert(0 != cptr);\newline  assert(cptr == sptr);\newline  assert(0 != cli_user(sptr));\newline\newline  /* By default, relay the message straight through. */\newline  text = parv[parc - 1];\newline\newline  if (parc &lt 3 || EmptyString(text))\newline    return send_reply(sptr, ERR_NOTEXTTOSEND);\newline\newline  /* HACK! HACK! HACK! HACK! Yes. It&#039s icky, but\newline   * it&#039s the only way. */\newline  map = (struct s_map *)parv[1];\newline  assert(0 != map);\newline\newline  if (map-&gtprepend) {\newline    ircd_snprintf(0, buffer, sizeof(buffer) - 1, &quot%s%s&quot, map-&gtprepend, text);\newline    buffer[sizeof(buffer) - 1] = 0;\newline    text = buffer;\newline  }\newline\newline  for (nh = map-&gtservices; nh; nh = nh-&gtnext) {\newline    struct Client *target, *server;\newline\newline    if (NULL == (server = FindServer(nh-&gtnick + nh-&gtnicklen + 1)))\newline      continue;\newline    nh-&gtnick[nh-&gtnicklen] = &#039\\0&#039;\newline    if ((NULL == (target = FindUser(nh-&gtnick)))\newline        || (server != cli_user(target)-&gtserver))\newline      continue;\newline    nh-&gtnick[nh-&gtnicklen] = &#039@&#039;\newline    relay_directed_message(sptr, nh-&gtnick, nh-&gtnick + nh-&gtnicklen, text);\newline    return 0;\newline  }\newline\newline  return send_reply(sptr, ERR_SERVICESDOWN, map-&gtname);\newline}\newline","\newline m_pseudo - generic service message handler\newline \newline parv[0] = sender prefix\newline parv[1] = service mapping (s_map disguised as char )\newline parv[2] = message\newline \newline","4854578","ovl.c","static char* ovl_get_coverage_point(\newline  statement* stmt  /*!&lt Pointer to statement of task call to coverage task */\newline) { PROFILE(OVL_GET_COVERAGE_POINT);\newline\newline  char* cpoint;  /* Return value for this function */\newline\newline  /*\newline   We are going to make a lot of assumptions about the structure of the statement, so just\newline   do a lot of assertions to make sure that our assumptions are correct.\newline  */\newline  assert( stmt != NULL );\newline  assert( stmt-&gtexp != NULL );\newline  assert( stmt-&gtexp-&gtleft != NULL );\newline  assert( stmt-&gtexp-&gtleft-&gtop == EXP_OP_PASSIGN );\newline  assert( stmt-&gtexp-&gtleft-&gtright != NULL );\newline  assert( stmt-&gtexp-&gtleft-&gtright-&gtop == EXP_OP_STATIC );\newline  assert( ESUPPL_STATIC_BASE( stmt-&gtexp-&gtleft-&gtright-&gtsuppl ) == QSTRING );\newline\newline  cpoint = vector_to_string( stmt-&gtexp-&gtleft-&gtright-&gtvalue, ESUPPL_STATIC_BASE( stmt-&gtexp-&gtleft-&gtright-&gtsuppl ), FALSE, 0 );\newline\newline  PROFILE_END;\newline\newline  return( cpoint );\newline\newline}\newline","!\newline\\return Returns the string passed to the task call\newlineFinds the task call parameter that specifies the name of the coverage point and returns this\newlinestring value to the calling function.\newline \newline","4829226","node_mgr.c","bool is_node_resp (char *name)\newline{\newline#ifdef HAVE_FRONT_END\newline	front_end_record_t *node_ptr;\newline\newline	node_ptr = find_front_end_record (name);\newline#else\newline	struct node_record *node_ptr;\newline\newline	node_ptr = find_node_record (name);\newline#endif\newline	if (node_ptr == NULL) {\newline		error (&quotis_node_resp unable to find node %s&quot, name);\newline		return false;\newline	}\newline\newline	if (IS_NODE_NO_RESPOND(node_ptr))\newline		return false;\newline	return true;\newline}\newline","\newline is_node_resp - determine if the specified node&#039s state is responding\newline IN name - name of the node\newline RET true if node exists and is responding, otherwise false\newline \newline","1832110","speakermatch.cpp","void SpeakerMatch::LoadFile(const string&amp filename)\newline{\newline	string line;\newline	ifstream file;\newline	long int lineNum = -1;\newline	\newline	file.open(filename.c_str(), ifstream::in);\newline    \newline	if (! file.is_open())\newline	{ \newline		LOG_FATAL(logger, &quotError opening SpeakerMatch file &quot + filename); \newline		exit(E_LOAD); \newline	}\newline	\newline	while (getline(file,line,&#039\\n&#039))\newline    {\newline		++lineNum;\newline		\newline        if (line.find_first_of(&quot#&quot) == 0)\newline		{\newline			//comment so skip (for now)\newline		}\newline		else if(line == string(&quotFile,Channel,RefSpeaker,SysSpeaker,isMapped,timeOverlap&quot))\newline		{\newline			// CSV header\newline		}		\newline        else\newline        // if Type is &#039LEXEME&#039 we take it, unless we drop the line\newline        {\newline			size_t index = 0;\newline			size_t lpos = 0;\newline			string delim = string(&quot,&quot);\newline			size_t pos = line.find_first_of(delim, lpos);\newline			string tokens[6];\newline						\newline			do\newline			{\newline				if(index == 6)\newline				{\newline					char buffer[BUFFER_SIZE];\newline					sprintf(buffer, &quotToo much: Error parsing the line %li in file %s&quot, lineNum, filename.c_str());\newline					LOG_ERR(logger, buffer);\newline				}\newline				\newline				tokens[index] = line.substr(lpos, pos - lpos);\newline				++index;\newline				lpos = ( pos == string::npos ) ?  string::npos : pos + 1;\newline				pos = line.find_first_of(delim, lpos);\newline			}\newline			while( lpos != string::npos );\newline			\newline			if(index != 6)\newline			{\newline				char buffer[BUFFER_SIZE];\newline				sprintf(buffer, &quotToo few: Error parsing the line %li in file %s&quot, lineNum, filename.c_str());\newline				LOG_ERR(logger, buffer);\newline			}\newline			\newline			if( tokens[4] == string(&quotmapped&quot) )\newline			{\newline				//SetSysRef(string(l_file), string(l_channel), string(l_sys), string(l_ref));\newline				//transform(tokens[3].begin(), tokens[3].end(), tokens[3].begin(), (int(*)(int)) toupper);\newline				//transform(tokens[2].begin(), tokens[2].end(), tokens[2].begin(), (int(*)(int)) toupper);\newline				SetSysRef(tokens[0], tokens[1], tokens[3], tokens[2]);\newline			}\newline		}\newline    }\newline    \newline    file.close();\newline    LOG_INFO(logger, &quotloading of file &quot + filename + &quot done&quot);\newline}\newline","Load the file \newline","101216","window.c","void window_update_name_legacy(i3Window *win, xcb_get_property_reply_t *prop, bool before_mgmt) {\newline    if (prop == NULL || xcb_get_property_value_length(prop) == 0) {\newline        DLOG(&quotWM_NAME not set (_NET_WM_NAME is what you want anyways).\\n&quot);\newline        FREE(prop);\newline        return;\newline    }\newline\newline    /* ignore update when the window is known to already have a UTF-8 name */\newline    if (win-&gtuses_net_wm_name) {\newline        free(prop);\newline        return;\newline    }\newline\newline    i3string_free(win-&gtname);\newline    win-&gtname = i3string_from_utf8_with_length(xcb_get_property_value(prop),\newline                                               xcb_get_property_value_length(prop));\newline\newline    Con *con = con_by_window_id(win-&gtid);\newline    if (con != NULL &amp&amp con-&gttitle_format != NULL) {\newline        i3String *name = con_parse_title_format(con);\newline        ewmh_update_visible_name(win-&gtid, i3string_as_utf8(name));\newline        I3STRING_FREE(name);\newline    }\newline\newline    LOG(&quotWM_NAME changed to \\&quot%s\\&quot\\n&quot, i3string_as_utf8(win-&gtname));\newline    LOG(&quotUsing legacy window title. Note that in order to get Unicode window &quot\newline        &quottitles in i3, the application has to set _NET_WM_NAME (UTF-8)\\n&quot);\newline\newline    win-&gtname_x_changed = true;\newline\newline    if (before_mgmt) {\newline        free(prop);\newline        return;\newline    }\newline\newline    run_assignments(win);\newline\newline    free(prop);\newline}\newline","\newline Updates the name by using WM_NAME (encoded in COMPOUND_TEXT). We do not\newline touch what the client sends us but pass it to xcb_image_text_8. To get\newline proper unicode rendering, the application has to use _NET_WM_NAME (see\newline window_update_name()).\newline \newline \newline","4764187","ledmon.c","static void _ledmon_help(void)\newline{\newline	printf(ledmon_version, VERSION_MAJOR, VERSION_MINOR);\newline	printf(&quot\\nUsage: %s [OPTIONS]\\n\\n&quot, progname);\newline	printf(&quotMandatory arguments for long options are mandatory for short &quot\newline	       &quotoptions, too.\\n\\n&quot);\newline	printf(&quot--interval=VALUE\\t\\t  Set time interval to VALUE seconds.\\n&quot\newline	       &quot\\t\\t\\t\\t  The smallest interval is 5 seconds.\\n&quot);\newline	printf(&quot--config=PATH,  -c PATH\\t\\t  Use alternate configuration file &quot\newline	       &quot(not yet\\n\\t\\t\\t\\t  implemented).\\n&quot);\newline	printf\newline	    (&quot--log=PATH\\t\\t\\t  Use local log file instead\\n\\t\\t\\t\\t  /var/log/&quot\newline	     &quotledmon.log global file.\\n&quot);\newline	printf(&quot--help\\t\\t\\t\\t  Displays this help text.\\n&quot);\newline	printf\newline	    (&quot--version\\t\\t\\t  Displays version and license information.\\n\\n&quot);\newline	printf(&quotRefer to ledmon(8) man page for more detailed description.\\n&quot);\newline	printf(&quotBugs should be reported at: &quot\newline	       &quothttp://sourceforge.net/p/ledmon/bugs \\n&quot);\newline}\newline","\newline @brief Displays the help.\newline \newline This is internal function of monitor service. The function prints the name\newline and version of the program out. It displays the usage and available options\newline and its arguments (if any). Each option is described. This is an extract\newline from user manual page.\newline \newline @return The function does not return a value.\newline \newline","2142965","pseudo.c","int pty_open(int *masterfd, int *slavefd, char *slavename, size_t slavenamesize,\newline        const struct termios *slave_termios,\newline        const struct winsize *slave_winsize)\newline{\newline#if defined(HAVE_OPENPTY) || defined(BSD4_4)\newline    /* openpty(3) exists in OSF/1 and some other os&#039es */\newline\newline#ifdef HAVE_TTYNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master and slave descriptors, set ownership and permissions */\newline\newline    if (openpty(masterfd, slavefd, NULL, NULL, NULL) == -1)\newline        return -1;\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_TTYNAME_R\newline    if ((err = ttyname_r(*slavefd, buf, 64))) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ttyname(*slavefd))) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return set_errno(ENOSPC);\newline    }\newline#else /* HAVE_OPENPTY */\newline#ifdef HAVE__GETPTY\newline\newline    /*\newline     * _getpty(3) exists in SGI Irix 4.x, 5.x &amp 6.x -- it generates more\newline     * pty&#039s automagically when needed\newline     */\newline\newline    char *slave;\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor and get the slave&#039s device name */\newline\newline    if (!(slave = _getpty(masterfd, O_RDWR, 0622, 0)))\newline        return -1;\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline#else /* HAVE__GETPTY */\newline#if defined(HAVE_DEV_PTMX)\newline\newline    /*\newline     * This code is used e.g. on Solaris 2.x.  (Note that Solaris 2.3\newline     * also has bsd-style ptys, but they simply do not work.)\newline     */\newline\newline#ifdef HAVE_PTSNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor */\newline\newline    if ((*masterfd = open(&quot/dev/ptmx&quot, O_RDWR | O_NOCTTY)) == -1)\newline        return -1;\newline\newline    /* Set slave ownership and permissions to real uid of process */\newline\newline    if (grantpt(*masterfd) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Unlock the slave so it can be opened */\newline\newline    if (unlockpt(*masterfd) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_PTSNAME_R\newline    if ((err = ptsname_r(*masterfd, buf, 64))) {\newline        close(*masterfd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ptsname(*masterfd))) {\newline        close(*masterfd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline\newline    /* Turn the slave into a terminal */\newline\newline#ifndef HAVE_CYGWIN\newline#ifndef HAVE_LINUX              /* linux does not use the streams module */\newline    /*\newline     * Push the appropriate streams modules, as described in Solaris pts(7).\newline     * HP-UX pts(7) doesn&#039t have ttcompat module.\newline     */\newline    if (ioctl(*slavefd, I_PUSH, &quotptem&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    if (ioctl(*slavefd, I_PUSH, &quotldterm&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline#ifndef __hpux\newline    if (ioctl(*slavefd, I_PUSH, &quotttcompat&quot) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline#endif\newline#endif\newline#endif\newline\newline#else /* HAVE_DEV_PTMX */\newline#ifdef HAVE_DEV_PTS_AND_PTC\newline\newline    /* AIX-style pty code */\newline\newline#ifdef HAVE_TTYNAME_R\newline    char buf[64], *name = buf;\newline    int err;\newline#else\newline    char *name;\newline#endif\newline\newline    if (!masterfd || !slavefd || !slavename || slavenamesize &lt 64)\newline        return set_errno(EINVAL);\newline\newline    /* Open the master descriptor */\newline\newline    if ((*masterfd = open(&quot/dev/ptc&quot, O_RDWR | O_NOCTTY)) == -1)\newline        return -1;\newline\newline    /* Retrieve the device name of the slave */\newline\newline#ifdef HAVE_TTYNAME_R\newline    if ((err = ttyname_r(*masterfd, buf, 64))) {\newline        close(*masterfd);\newline        return set_errno(err);\newline    }\newline#else\newline    if (!(name = ttyname(*masterfd))) {\newline        close(*masterfd);\newline        return set_errno(ENOTTY);\newline    }\newline#endif\newline\newline    /* Return it to the caller */\newline\newline    if (strlcpy_local(slavename, name, slavenamesize) &gt= slavenamesize) {\newline        close(*masterfd);\newline        return set_errno(ENOSPC);\newline    }\newline\newline    /* Open the slave descriptor */\newline\newline    if ((*slavefd = open(name, O_RDWR | O_NOCTTY)) == -1) {\newline        close(*masterfd);\newline        return -1;\newline    }\newline#else /* HAVE_DEV_PTS_AND_PTC */\newline\newline    /* BSD-style pty code */\newline    const char *const ptymajors =\newline            &quotpqrstuvwxyzabcdefghijklmnoABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;\newline    const char *const ptyminors = &quot0123456789abcdef&quot;\newline    int num_minors = strlen(ptyminors);\newline    int num_ptys = strlen(ptymajors) * num_minors;\newline    char buf[64];\newline    int found = 0;\newline    int i;\newline\newline    /* Identify the first available pty master device */\newline\newline    for (i = 0; !found &amp&amp i &lt num_ptys; i++) {\newline        snprintf(buf, sizeof buf, &quot/dev/pty%c%c&quot, ptymajors[i / num_minors],\newline                ptyminors[i % num_minors]);\newline        snprintf(slavename, slavenamesize, &quot/dev/tty%c%c&quot,\newline                ptymajors[i / num_minors], ptyminors[i % num_minors]);\newline\newline        /* Open the master descriptor */\newline\newline        if ((*masterfd = open(buf, O_RDWR | O_NOCTTY)) == -1) {\newline            /* Try SCO style naming */\newline            snprintf(buf, sizeof buf, &quot/dev/ptyp%d&quot, i);\newline            snprintf(slavename, slavenamesize, &quot/dev/ttyp%d&quot, i);\newline\newline            if ((*masterfd = open(buf, O_RDWR | O_NOCTTY)) == -1)\newline                continue;\newline        }\newline\newline        /* Set slave ownership and permissions to real uid of process */\newline\newline        pty_set_owner(slavename, getuid());\newline\newline        /* Open the slave descriptor */\newline\newline        if ((*slavefd = open(slavename, O_RDWR | O_NOCTTY)) == -1) {\newline            close(*masterfd);\newline            return -1;\newline        }\newline\newline        found = 1;\newline    }\newline\newline    if (!found)\newline        return set_errno(ENOENT);\newline\newline#endif /* HAVE_DEV_PTS_AND_PTC */\newline#endif /* HAVE_DEV_PTMX */\newline#endif /* HAVE__GETPTY */\newline#endif /* HAVE_OPENPTY */\newline\newline    /* Set the slave&#039s terminal attributes if requested */\newline\newline    if (slave_termios &amp&amp tcsetattr(*slavefd, TCSANOW, slave_termios) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    /* Set the slave&#039s window size if required */\newline\newline    if (slave_winsize &amp&amp ioctl(*slavefd, TIOCSWINSZ, slave_winsize) == -1) {\newline        close(*masterfd);\newline        close(*slavefd);\newline        return -1;\newline    }\newline\newline    return 0;\newline}\newline","pty_open: A safe version of openpty. \newline Allocates and opens a pseudo terminal. The new descriptor for the \newline master side of the pseudo terminal is stored in masterfd. The new \newline descriptor for the slave side of the pseudo terminal is stored in slavefd. \newline The device name of the slave side of the pseudo terminal is stored in the \newline buffer pointed to by slavename which must be able to hold at least 64 \newline characters. slavenamesize is the size of the buffer pointed to by \newline slavename. No more than slavenamesize bytes will be written into the \newline buffer pointed to by slavename, including the terminating nul byte. \newline If slave_termios is not null, it is passed to tcsetattr with the \newline command TCSANOW to set the terminal attributes of the slave device. \newline If slave_winsize is not null, it is passed to ioctl with the command \newline TIOCSWINSZ to set the window size of the slave device. On success, \newline returns 0. On error, returns -1 with errno set appropriately.\newline \newline","5209723","msg_vm.cpp","static inline int __MSG_vm_is_state(msg_vm_t vm, e_surf_vm_state_t state)\newline{\newline  return static_cast&ltsimgrid::s4u::VirtualMachine*&gt(vm)-&gtpimpl_vm_-&gtgetState() == state;\newline}\newline","Check state of a VM \newline","284472","rule.c","int rtnl_rule_delete(struct nl_sock *sk, struct rtnl_rule *rule, int flags)\newline{\newline	struct nl_msg *msg;\newline	int err;\newline	\newline	if ((err = rtnl_rule_build_delete_request(rule, flags, &ampmsg)) &lt 0)\newline		return err;\newline\newline	err = nl_send_auto_complete(sk, msg);\newline	nlmsg_free(msg);\newline	if (err &lt 0)\newline		return err;\newline\newline	return wait_for_ack(sk);\newline}\newline","\newline Delete a rule\newline @arg sk Netlink socket.\newline @arg rule rule to delete\newline @arg flags additional netlink message flags\newline \newline Builds a netlink message by calling rtnl_rule_build_delete_request(),\newline sends the request to the kernel and waits for the next ACK to be\newline received and thus blocks until the request has been fullfilled.\newline \newline @return 0 on sucess or a negative error if an error occured.\newline \newline","277953","fastq-lex.c","\newline/* %if-c-only */\newlinestatic int yy_init_globals (yyscan_t yyscanner)\newline{\newline    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\newline    /* Initialization is the same as for the non-reentrant scanner.\newline     * This function is called from FASTQ_lex_destroy(), so don&#039t allocate here.\newline     */\newline\newline    yyg-&gtyy_buffer_stack = 0;\newline    yyg-&gtyy_buffer_stack_top = 0;\newline    yyg-&gtyy_buffer_stack_max = 0;\newline    yyg-&gtyy_c_buf_p = (char *) 0;\newline    yyg-&gtyy_init = 0;\newline    yyg-&gtyy_start = 0;\newline\newline    yyg-&gtyy_start_stack_ptr = 0;\newline    yyg-&gtyy_start_stack_depth = 0;\newline    yyg-&gtyy_start_stack =  NULL;\newline\newline    yyg-&gtyy_state_buf = 0;\newline    yyg-&gtyy_state_ptr = 0;\newline    yyg-&gtyy_full_match = 0;\newline    yyg-&gtyy_lp = 0;\newline\newline/* Defined in main.c */\newline#ifdef YY_STDINIT\newline    yyin = stdin;\newline    yyout = stdout;\newline#else\newline    yyin = (FILE *) 0;\newline    yyout = (FILE *) 0;\newline#endif\newline\newline    /* For future reference: Set errno on error, since we are called by\newline     * FASTQ_lex_init()\newline     */\newline    return 0;\newline}\newline","%endif if-c-only \newline","5973447","timer.c","void pfunc(ntimer_t *t)\newline{\newline  t-&gtcallback(t-&gtdata);\newline}\newline","perform the function scheduled in t. \newline","286488","index.c","void relay_index_close_all(struct relay_stream *stream)\newline{\newline	struct lttng_ht_iter iter;\newline	struct relay_index *index;\newline\newline	rcu_read_lock();\newline	cds_lfht_for_each_entry(stream-&gtindexes_ht-&gtht, &ampiter.iter,\newline			index, index_n.node) {\newline		/* Put self-ref from index. */\newline		relay_index_put(index);\newline	}\newline	rcu_read_unlock();\newline}\newline","\newline Close every relay index within a given stream, without flushing\newline them.\newline \newline","4564800","vmgahp_common.cpp","int systemCommand( ArgList &ampargs, priv_state priv, StringList *cmd_out, StringList * cmd_in,\newline		   StringList *cmd_err, bool merge_stderr_with_stdout)\newline{\newline	int result = 0;\newline	FILE *fp = NULL;\newline	FILE * fp_for_stdin = NULL;\newline	FILE * childerr = NULL;\newline	MyString line;\newline	char buff[1024];\newline	StringList *my_cmd_out = cmd_out;\newline\newline	priv_state prev = get_priv_state();\newline\newline	int stdout_pipes[2];\newline	int stdin_pipes[2];\newline	int pid;\newline	bool use_privsep = false;\newline	switch ( priv ) {\newline	case PRIV_ROOT:\newline		prev = set_root_priv();\newline		break;\newline	case PRIV_USER:\newline	case PRIV_USER_FINAL:\newline		prev = set_user_priv();\newline#if !defined(WIN32)\newline		if ( privsep_enabled() &amp&amp (job_user_uid != get_condor_uid()) ) {\newline			use_privsep = true;\newline		}\newline#endif\newline		break;\newline	default:\newline		// Stay as Condor user, this should be a no-op\newline		prev = set_condor_priv();\newline	}\newline#if defined(WIN32)\newline	if((cmd_in != NULL) || (cmd_err != NULL))\newline	  {\newline	    vmprintf(D_ALWAYS, &quotInvalid use of systemCommand() in Windows.\\n&quot);\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline	//if ( use_privsep ) {\newline	//	fp = privsep_popen(args, &quotr&quot, want_stderr, job_user_uid);\newline	//}\newline	//else {\newline	fp = my_popen( args, &quotr&quot, merge_stderr_with_stdout );\newline	//}\newline#else\newline	// The old way of doing things (and the Win32 way of doing\newline	//	things)\newline	// fp = my_popen( args, &quotr&quot, want_stderr );\newline	if((cmd_err != NULL) &amp&amp merge_stderr_with_stdout)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotInvalid use of systemCommand().\\n&quot);\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline\newline	PrivSepForkExec psforkexec;\newline	char ** args_array = args.GetStringArray();\newline	int error_pipe[2];\newline		// AIX 5.2, Solaris 5.9, HPUX 11 don&#039t have AF_LOCAL\newline\newline	if(pipe(stdin_pipes) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError creating pipe: %s\\n&quot, strerror(errno));\newline		deleteStringArray( args_array );\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline	if(pipe(stdout_pipes) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError creating pipe: %s\\n&quot, strerror(errno));\newline	    close(stdin_pipes[0]);\newline	    close(stdin_pipes[1]);\newline		deleteStringArray( args_array );\newline	    set_priv( prev );\newline	    return -1;\newline	  }\newline\newline	if ( use_privsep ) {\newline	  if(!psforkexec.init())\newline	    {\newline	      vmprintf(D_ALWAYS,\newline		       &quotmy_popenv failure on %s\\n&quot,\newline		       args_array[0]);\newline	      close(stdin_pipes[0]);\newline	      close(stdin_pipes[1]);\newline	      close(stdout_pipes[0]);\newline	      close(stdout_pipes[1]);\newline		  deleteStringArray( args_array );\newline	      set_priv( prev );\newline	      return -1;\newline	    }\newline	}\newline\newline	if(cmd_err != NULL)\newline	  {\newline	    if(pipe(error_pipe) &lt 0)\newline	      {\newline		vmprintf(D_ALWAYS, &quotCould not open pipe for error output: %s\\n&quot, strerror(errno));\newline		close(stdin_pipes[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline		close(stdout_pipes[1]);\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline		return -1;\newline	      }\newline	  }\newline	// Now fork and do what my_popen used to do\newline	pid = fork();\newline	if(pid &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotError forking: %s\\n&quot, strerror(errno));\newline		close(stdin_pipes[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline		close(stdout_pipes[1]);\newline		if(cmd_err != NULL) {\newline			close(error_pipe[0]);\newline			close(error_pipe[1]);\newline		}\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline	    return -1;\newline	  }\newline	if(pid == 0)\newline	  {\newline	    close(stdout_pipes[0]);\newline	    close(stdin_pipes[1]);\newline	    dup2(stdout_pipes[1], STDOUT_FILENO);\newline	    dup2(stdin_pipes[0], STDIN_FILENO);\newline\newline	    if(merge_stderr_with_stdout) dup2(stdout_pipes[1], STDERR_FILENO);\newline	    else if(cmd_err != NULL) \newline	      {\newline		close(error_pipe[0]);\newline		dup2(error_pipe[1], STDERR_FILENO);\newline	      }\newline\newline\newline			/* to be safe, we want to switch our real uid/gid to our\newline			   effective uid/gid (shedding any privledges we&#039ve got).\newline			   we also want to drop any supplimental groups we&#039re in.\newline			   we want to run this popen()&#039ed thing as our effective\newline			   uid/gid, dropping the real uid/gid.  all of these calls\newline			   will fail if we don&#039t have a ruid of 0 (root), but\newline			   that&#039s harmless.  also, note that we have to stash our\newline			   effective uid, then switch our euid to 0 to be able to\newline			   set our real uid/gid.\newline			   We wrap some of the calls in if-statements to quiet some\newline			   compilers that object to us not checking the return values.\newline			*/\newline	    uid_t euid = geteuid();\newline	    gid_t egid = getegid();\newline	    if ( seteuid( 0 ) ) { }\newline	    setgroups( 1, &ampegid );\newline	    if ( setgid( egid ) ) { }\newline	    if ( setuid( euid ) ) _exit(ENOEXEC); // Unsafe?\newline	    \newline	    install_sig_handler(SIGPIPE, SIG_DFL);\newline	    sigset_t sigs;\newline	    sigfillset(&ampsigs);\newline	    sigprocmask(SIG_UNBLOCK, &ampsigs, NULL);\newline\newline\newline	    MyString cmd = args_array[0];\newline\newline	    if ( use_privsep ) {\newline	    \newline	      ArgList al;\newline	      psforkexec.in_child(cmd, al);\newline          deleteStringArray( args_array );\newline	      args_array = al.GetStringArray();\newline	    }\newline\newline\newline	    execvp(cmd.Value(), args_array);\newline	    vmprintf(D_ALWAYS, &quotCould not execute %s: %s\\n&quot, args_array[0], strerror(errno));\newline	    exit(-1);\newline	  }\newline	close(stdin_pipes[0]);\newline	close(stdout_pipes[1]);\newline	fp_for_stdin = fdopen(stdin_pipes[1], &quotw&quot);\newline	fp = fdopen(stdout_pipes[0], &quotr&quot);\newline	if(cmd_err != NULL)\newline	  {\newline	    close(error_pipe[1]);\newline	    childerr = fdopen(error_pipe[0],&quotr&quot);\newline	    if(childerr == 0)\newline	      {\newline		vmprintf(D_ALWAYS, &quotCould not open pipe for reading child error output: %s\\n&quot, strerror(errno));\newline		close(error_pipe[0]);\newline		close(stdin_pipes[1]);\newline		close(stdout_pipes[0]);\newline	    fclose(fp);\newline		fclose(fp_for_stdin);\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline		return -1;\newline	      }\newline	  }\newline\newline	if ( use_privsep ) {\newline	  FILE* _fp = psforkexec.parent_begin();\newline	  privsep_exec_set_uid(_fp, job_user_uid);\newline	  privsep_exec_set_path(_fp, args_array[0]);\newline	  privsep_exec_set_args(_fp, args);\newline	  Env env;\newline	  env.MergeFrom(environ);\newline	  privsep_exec_set_env(_fp, env);\newline	  privsep_exec_set_iwd(_fp, &quot.&quot);\newline\newline	  privsep_exec_set_inherit_fd(_fp, 1);\newline	  privsep_exec_set_inherit_fd(_fp, 2);\newline	  privsep_exec_set_inherit_fd(_fp, 0);\newline	\newline	  if (!psforkexec.parent_end()) {\newline	    vmprintf(D_ALWAYS,\newline		     &quotmy_popenv failure on %s\\n&quot,\newline		     args_array[0]);\newline	    fclose(fp);\newline		fclose(fp_for_stdin);\newline		if (childerr) {\newline			fclose(childerr);\newline		}\newline		deleteStringArray( args_array );\newline		set_priv( prev );\newline	    return -1;\newline	  }\newline	}\newline\newline	deleteStringArray( args_array );\newline#endif\newline	set_priv( prev );\newline	if ( fp == NULL ) {\newline		MyString args_string;\newline		args.GetArgsStringForDisplay( &ampargs_string, 0 );\newline		vmprintf( D_ALWAYS, &quotFailed to execute command: %s\\n&quot,\newline				  args_string.Value() );\newline		if (childerr)\newline			fclose(childerr);\newline		return -1;\newline	}\newline\newline	if(cmd_in != NULL) {\newline	  cmd_in-&gtrewind();\newline	  char * tmp;\newline	  while((tmp = cmd_in-&gtnext()) != NULL)\newline	    {\newline	      fprintf(fp_for_stdin, &quot%s\\n&quot, tmp);\newline	      fflush(fp_for_stdin);\newline	    }\newline	}\newline	if (fp_for_stdin) {\newline	  // So that we will not be waiting for output while the\newline	  // script waits for stdin to be closed.\newline	  fclose(fp_for_stdin);\newline	}\newline\newline	if ( my_cmd_out == NULL ) {\newline		my_cmd_out = new StringList();\newline	}\newline\newline	while ( fgets( buff, sizeof(buff), fp ) != NULL ) {\newline		line += buff;\newline		if ( line.chomp() ) {\newline			my_cmd_out-&gtappend( line.Value() );\newline			line = &quot&quot;\newline		}\newline	}\newline\newline	if(cmd_err != NULL)\newline	  {\newline	    while(fgets(buff, sizeof(buff), childerr) != NULL)\newline	      {\newline		line += buff;\newline		if(line.chomp())\newline		  {\newline		    cmd_err-&gtappend(line.Value());\newline		    line = &quot&quot;\newline		  }\newline	      }\newline	    fclose(childerr);\newline	  }\newline#if defined(WIN32)\newline	result = my_pclose( fp );\newline#else\newline	// Why close first?  Just in case the child process is waiting\newline	// on a read, and we have nothing more to send it.  It will\newline	// now receive a SIGPIPE.\newline	fclose(fp);\newline	if(waitpid(pid, &ampresult, 0) &lt 0)\newline	  {\newline	    vmprintf(D_ALWAYS, &quotUnable to wait: %s\\n&quot, strerror(errno));\newline		if ( cmd_out == NULL ) {\newline			delete my_cmd_out;\newline		}\newline	   \newline	    return -1;\newline	  }\newline#endif\newline	if( result != 0 ) {\newline		MyString args_string;\newline		args.GetArgsStringForDisplay(&ampargs_string,0);\newline		vmprintf(D_ALWAYS,\newline		         &quotCommand returned non-zero: %s\\n&quot,\newline		         args_string.Value());\newline		my_cmd_out-&gtrewind();\newline		const char *next_line;\newline		while ( (next_line = my_cmd_out-&gtnext()) ) {\newline			vmprintf( D_ALWAYS, &quot  %s\\n&quot, next_line );\newline		}\newline	}\newline	if ( cmd_out == NULL ) {\newline		delete my_cmd_out;\newline	}\newline	return result;\newline}\newline","\newline merge_stderr_with_stdout is intended for clients of this function\newline that wish to have the old behavior, where stderr and stdout were\newline both added to the same StringList.\newline \newline","1311260","multi.c","int_hash_function(const void *key, uint32_t iv)\newline{\newline    return (unsigned long)key;\newline}\newline","\newline inotify watcher descriptors are used as hash value\newline \newline","4047518","random1.c","static void random1_bang(t_random1 *x)\newline{\newline    int n = x-&gtx_f;\newline    double nval;\newline    unsigned int m;\newline    // this seems weird?\newline    m = (RAND_MAX * 2);\newline    //    unsigned int a = 1588635695, m = 4294967291U, q = 2, r = 1117695901;\newline\newline    //    post(&quotcxc/randomix.c: x_state: %d&quot,x-&gtx_state);\newline    x-&gtx_state = rand_random1(x-&gtx_state);\newline    nval = ((double)x-&gtx_state / (double)m) * (double)(x-&gtx_g - x-&gtx_f) + (double)x-&gtx_f;\newline    //    post(&quotcxc/randomix.c: lolim: %f, uplim: %f&quot, x-&gtx_f, x-&gtx_g);\newline    //    post(&quotcxc/randomix.c: nval: %f&quot,nval);\newline    outlet_float(x-&gtx_obj.ob_outlet, nval);\newline}\newline","works if your floating pt. mantissa has at least 53 bits.\newlinefaster than other versions \newline","1813066","sha1.c","void sha1_hmac_reset( sha1_context *ctx )\newline{\newline    sha1_starts( ctx );\newline    sha1_update( ctx, ctx-&gtipad, 64 );\newline}\newline","\newline SHA1 HMAC context reset\newline \newline","801897","iterator.h","GIT_INLINE(int) git_iterator_advance(\newline	const git_index_entry **entry, git_iterator *iter)\newline{\newline	return iter-&gtcb-&gtadvance(entry, iter);\newline}\newline","\newline Advance to the next item for the iterator.\newline \newline If GIT_ITERATOR_INCLUDE_TREES is set, this may be a tree item. If\newline GIT_ITERATOR_DONT_AUTOEXPAND is set, calling this again when on a tree\newline item will skip over all the items under that tree.\newline \newline","317088","wav2cdr.c","void help (void)\newline{\newline	fprintf (msgfile,\newline#include &quothelp.-c&quot\newline	, CDAUDIOSAMPLINGRATE\newline	, CDAUDIOSECTORSIZE\newline	, CDSECTORSPERSEC\newline	);\newline\newline	exit_error (ERR_USAGE, NULL, NULL);\newline\newline} /* help() */\newline","\newline Display help and exit.\newline In: ---\newline \newline","883051","array.c","void * ci_ptr_vector_add(ci_vector_t *vector, void *value)\newline{\newline    void **indx;\newline    ci_mem_allocator_t *packer = vector-&gtalloc;\newline    assert(packer);\newline\newline    if (!value)\newline        return NULL;\newline\newline    indx = ci_pack_allocator_alloc_unaligned(packer, array_item_size(void *));\newline    if (!indx) {\newline        ci_debug_printf(2, &quotNot enough space to add the new item to ptr_vector!\\n&quot);\newline        return NULL;\newline    }\newline    /*Store the pointer to the last ellement */\newline    *(vector-&gtlast) = value;\newline\newline    /*And create a new NULL terminated item: */\newline    vector-&gtlast = indx;\newline    *(vector-&gtlast) = NULL;\newline    vector-&gtcount++;\newline    return value;\newline}\newline","ci_ptr_vector functions.... \newline","4962291","addfeedwizard.cpp","void AddFeedWizard::newFolder()\newline{\newline  AddFolderDialog *addFolderDialog = new AddFolderDialog(this);\newline  QList&ltQTreeWidgetItem *&gt treeItems =\newline      addFolderDialog-&gtfoldersTree_-&gtfindItems(foldersTree_-&gtcurrentItem()-&gttext(1),\newline                                               Qt::MatchFixedString | Qt::MatchRecursive,\newline                                               1);\newline  addFolderDialog-&gtfoldersTree_-&gtsetCurrentItem(treeItems.at(0));\newline\newline  if (addFolderDialog-&gtexec() == QDialog::Rejected) {\newline    delete addFolderDialog;\newline    return;\newline  }\newline\newline  int folderId = 0;\newline  QString folderText = addFolderDialog-&gtnameFeedEdit_-&gttext();\newline  int parentId = addFolderDialog-&gtfoldersTree_-&gtcurrentItem()-&gttext(1).toInt();\newline\newline  // Calculate row number to insert folder\newline  int rowToParent = 0;\newline  QSqlQuery q;\newline  q.exec(QString(&quotSELECT count(id) FROM feeds WHERE parentId=&#039%1&#039&quot).arg(parentId));\newline  if (q.first())\newline    rowToParent = q.value(0).toInt();\newline\newline  // Add folder\newline  q.prepare(&quotINSERT INTO feeds(text, created, parentId, rowToParent) &quot\newline            &quotVALUES (:text, :feedCreateTime, :parentId, :rowToParent)&quot);\newline  q.bindValue(&quot:text&quot, folderText);\newline  q.bindValue(&quot:feedCreateTime&quot,\newline              QLocale::c().toString(QDateTime::currentDateTimeUtc(), &quotyyyy-MM-ddTHH:mm:ss&quot));\newline  q.bindValue(&quot:parentId&quot, parentId);\newline  q.bindValue(&quot:rowToParent&quot, rowToParent);\newline  q.exec();\newline\newline  folderId = q.lastInsertId().toInt();\newline  q.finish();\newline\newline  treeItems = foldersTree_-&gtfindItems(QString::number(parentId),\newline                                      Qt::MatchFixedString | Qt::MatchRecursive,\newline                                      1);\newline  QStringList treeItem;\newline  treeItem &lt&lt folderText &lt&lt QString::number(folderId);\newline  QTreeWidgetItem *treeWidgetItem = new QTreeWidgetItem(treeItem);\newline  treeItems.at(0)-&gtaddChild(treeWidgetItem);\newline  foldersTree_-&gtsetCurrentItem(treeWidgetItem);\newline\newline  delete addFolderDialog;\newline}\newline","! \\brief Adding new folder \newline","on","","on","","","on","on","on","","","","","on","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","{}","Builds a netlink message","{}","perform the function scheduled","Close every relay index within a given stream,","{}","{}","{}","SHA1 HMAC context reset","Advance to the next item for the iterator.","Display help and exit.","generic service message handler","{}","Adding new folder","Returns the string passed to the task call","determine if the specified node's state is responding","Load the file","Updates the name","Displays the help.","Allocates and opens a pseudo terminal.","Check state of a VM"
"3XBYQ44Z6P41DP2YF77MH52U74XTWZ","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3LPW2N6LKT2ON3ZW9DFOLK78M9JU5X","A3DBG3IETULYCN","Approved","Wed Apr 17 15:26:06 PDT 2019","Wed Apr 17 15:31:11 PDT 2019","Fri Apr 19 15:31:11 PDT 2019","2019-04-19 22:31:21 UTC","","","305","100% (37/37)","100% (37/37)","100% (37/37)","6434465","m_nick.c","static int do_nick_name(char* nick)\newline{\newline  char* ch  = nick;\newline  char* end = ch + NICKLEN;\newline  assert(0 != ch);\newline  \newline  /* first character in [0..9-] */\newline  if (*ch == &#039-&#039 || IsDigit(*ch))\newline    return 0;\newline  for ( ; (ch &lt end) &amp&amp *ch; ++ch)\newline    if (!IsNickChar(*ch))\newline      break;\newline\newline  *ch = &#039\\0&#039;\newline\newline  return (ch - nick);\newline}\newline","\newline &#039do_nick_name&#039 ensures that the given parameter (nick) is really a proper\newline string for a nickname (note, the &#039nick&#039 may be modified in the process...)\newline \newline RETURNS the length of the final NICKNAME (0, if nickname is invalid)\newline \newline Nickname characters are in range &#039A&#039..&#039}&#039, &#039_&#039, &#039-&#039, &#0390&#039..&#0399&#039\newline anything outside the above set will terminate nickname.\newline In addition, the first character cannot be &#039-&#039 or a Digit.\newline \newline Note:\newline The &#039~&#039-character should be allowed, but a change should be global,\newline some confusion would result if only few servers allowed it...\newline \newline","4988975","sfuntmpl.c","static void mdlOutputs(SimStruct *S, int_T tid)\newline{\newline    const real_T *u = (const real_T*) ssGetInputPortSignal(S,0);\newline    real_T       *y = ssGetOutputPortSignal(S,0);\newline    y[0] = 2.0 * u[0];\newline}\newline","Function: mdlOutputs =======================================================\newline Abstract:\newline In this function, you compute the outputs of your S-function\newline block. Generally outputs are placed in the output vector, ssGetY(S).\newline \newline","4890142","rsocket.c","static int rs_create_cq(struct rsocket *rs, struct rdma_cm_id *cm_id)\newline{\newline	cm_id-&gtrecv_cq_channel = ibv_create_comp_channel(cm_id-&gtverbs);\newline	if (!cm_id-&gtrecv_cq_channel)\newline		return -1;\newline\newline	cm_id-&gtrecv_cq = ibv_create_cq(cm_id-&gtverbs, rs-&gtsq_size + rs-&gtrq_size,\newline				       cm_id, cm_id-&gtrecv_cq_channel, 0);\newline	if (!cm_id-&gtrecv_cq)\newline		goto err1;\newline\newline	if (rs-&gtfd_flags &amp O_NONBLOCK) {\newline		if (fcntl(cm_id-&gtrecv_cq_channel-&gtfd, F_SETFL, O_NONBLOCK))\newline			goto err2;\newline	}\newline\newline	ibv_req_notify_cq(cm_id-&gtrecv_cq, 0);\newline	cm_id-&gtsend_cq_channel = cm_id-&gtrecv_cq_channel;\newline	cm_id-&gtsend_cq = cm_id-&gtrecv_cq;\newline	return 0;\newline\newlineerr2:\newline	ibv_destroy_cq(cm_id-&gtrecv_cq);\newline	cm_id-&gtrecv_cq = NULL;\newlineerr1:\newline	ibv_destroy_comp_channel(cm_id-&gtrecv_cq_channel);\newline	cm_id-&gtrecv_cq_channel = NULL;\newline	return -1;\newline}\newline","\newline If a user is waiting on a datagram rsocket through poll or select, then\newline we need the first completion to generate an event on the related epoll fd\newline in order to signal the user. We arm the CQ on creation for this purpose\newline \newline","1025401","cwdaemon.c","void cwdaemon_reset_libcw_output(void)\newline{\newline	/* This function is called when cwdaemon receives &#0390&#039 escape code.\newline	   README describes this code as &quotReset to default values&quot.\newline	   Therefore we use default_* below.\newline\newline	   However, the function is called after &quotcurrent_&quot values\newline	   have been reset to &quotdefault_&quot values. So maybe we could use\newline	   &quotcurrent_&quot values and somehow encapsulate the calls to\newline	   cw_set_*() functions? The calls are also made elsewhere.\newline	*/\newline\newline	/* Delete old generator (if it exists). */\newline	cwdaemon_close_libcw_output();\newline\newline	cwdaemon_debug(CWDAEMON_VERBOSITY_I, __func__, __LINE__, &quotsetting sound system \\&quot%s\\&quot&quot, cw_get_audio_system_label(default_audio_system));\newline\newline	if (cwdaemon_open_libcw_output(default_audio_system)) {\newline		has_audio_output = true;\newline	} else {\newline		has_audio_output = false;\newline		return;\newline	}\newline\newline	/* Remember that tone queue is bound to a generator.  When\newline	   cwdaemon switches on request to other sound system, it will\newline	   have to re-register the callback. */\newline	cw_register_tone_queue_low_callback(cwdaemon_tone_queue_low_callback, NULL, tq_low_watermark);\newline\newline	cw_set_frequency(default_morse_tone);\newline	cw_set_send_speed(default_morse_speed);\newline	cw_set_volume(default_morse_volume);\newline	cw_set_gap(0);\newline	cw_set_weighting(default_weighting * 0.6 + CWDAEMON_MORSE_WEIGHTING_MAX);\newline\newline	return;\newline}\newline","\newline\\brief Reset parameters of libcw to default values\newlineFunction uses values of cwdaemon&#039s global &#039default_&#039 variables, and some\newlineother values to reset state of libcw.\newline \newline","1893160","opengl.c","gboolean visu_gl_setStereoAngle(float angle)\newline{\newline  g_return_val_if_fail(angle &gt 0.f, FALSE);\newline\newline  if (stereoAngles[0] == angle)\newline    return FALSE;\newline\newline  stereoAngles[0] = angle;\newline  stereoAngles[1] = -angle;\newline\newline  return stereoStatus;\newline}\newline","\newline visu_gl_setStereoAngle:\newline @angle: a positive floating point value.\newline \newline Change the angle of the eyes in the stereo output.\newline \newline Returns: TRUE if redraw should be done.\newline \newline","2162883","mboxlist.c","EXPORTED int mboxlist_unsetquota(const char *root)\newline{\newline    char pattern[MAX_MAILBOX_PATH+1];\newline    struct quota q;\newline    int r=0;\newline\newline    if (!root[0] || root[0] == &#039.&#039 || strchr(root, &#039/&#039)\newline	|| strchr(root, &#039*&#039) || strchr(root, &#039%&#039) || strchr(root, &#039?&#039)) {\newline	return IMAP_MAILBOX_BADNAME;\newline    }\newline    \newline    quota_init(&ampq, root);\newline    r = quota_read(&ampq, NULL, 0);\newline    /* already unset */\newline    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\newline	r = 0;\newline	goto done;\newline    }\newline    if (r) goto done;\newline\newline    r = quota_changelock();\newline\newline    /*\newline     * Have to remove it from all affected mailboxes\newline     */\newline    strlcpy(pattern, root, sizeof(pattern));\newline    if (config_virtdomains &amp&amp root[strlen(root)-1] == &#039!&#039) {\newline	/* domain quota */\newline	strlcat(pattern, &quot*&quot, sizeof(pattern));\newline    }\newline    else\newline	strlcat(pattern, &quot.*&quot, sizeof(pattern));\newline    \newline    /* top level mailbox */\newline    mboxlist_rmquota(root, 0, 0, (void *)root);\newline    /* submailboxes - we&#039re using internal names here */\newline    mboxlist_findall(NULL, pattern, 1, 0, 0, mboxlist_rmquota, (void *)root);\newline\newline    r = quota_deleteroot(root);\newline    quota_changelockrelease();\newline\newline    if (!r) sync_log_quota(root);\newline\newline done:\newline    quota_free(&ampq);\newline    return r;\newline}\newline","\newline Remove a quota root\newline \newline","4206459","loaders.c","int load_one_re_filterfile(struct client_state *csp, int fileid)\newline{\newline   FILE *fp;\newline\newline   struct re_filterfile_spec *new_bl, *bl = NULL;\newline   struct file_list *fs;\newline\newline   char *buf = NULL;\newline   int error;\newline   unsigned long linenum = 0;\newline   pcrs_job *dummy, *lastjob = NULL;\newline\newline   /*\newline    * No need to reload if unchanged\newline    */\newline   if (!check_file_changed(current_re_filterfile[fileid], csp-&gtconfig-&gtre_filterfile[fileid], &ampfs))\newline   {\newline      csp-&gtrlist[fileid] = current_re_filterfile[fileid];\newline      return(0);\newline   }\newline   if (!fs)\newline   {\newline      goto load_re_filterfile_error;\newline   }\newline\newline   /*\newline    * Open the file or fail\newline    */\newline   if ((fp = fopen(csp-&gtconfig-&gtre_filterfile[fileid], &quotr&quot)) == NULL)\newline   {\newline      goto load_re_filterfile_error;\newline   }\newline\newline   log_error(LOG_LEVEL_INFO, &quotLoading filter file: %s&quot, csp-&gtconfig-&gtre_filterfile[fileid]);\newline\newline   /*\newline    * Read line by line\newline    */\newline   while (read_config_line(fp, &amplinenum, &ampbuf) != NULL)\newline   {\newline      enum filter_type new_filter = FT_INVALID_FILTER;\newline\newline      if (strncmp(buf, &quotFILTER:&quot, 7) == 0)\newline      {\newline         new_filter = FT_CONTENT_FILTER;\newline      }\newline      else if (strncmp(buf, &quotSERVER-HEADER-FILTER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_SERVER_HEADER_FILTER;\newline      }\newline      else if (strncmp(buf, &quotCLIENT-HEADER-FILTER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_CLIENT_HEADER_FILTER;\newline      }\newline      else if (strncmp(buf, &quotCLIENT-HEADER-TAGGER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_CLIENT_HEADER_TAGGER;\newline      }\newline      else if (strncmp(buf, &quotSERVER-HEADER-TAGGER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_SERVER_HEADER_TAGGER;\newline      }\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline      else if (strncmp(buf, &quotEXTERNAL-FILTER:&quot, 16) == 0)\newline      {\newline         new_filter = FT_EXTERNAL_CONTENT_FILTER;\newline      }\newline#endif\newline\newline      /*\newline       * If this is the head of a new filter block, make it a\newline       * re_filterfile spec of its own and chain it to the list:\newline       */\newline      if (new_filter != FT_INVALID_FILTER)\newline      {\newline         new_bl = zalloc_or_die(sizeof(*bl));\newline         if (new_filter == FT_CONTENT_FILTER)\newline         {\newline            new_bl-&gtname = chomp(buf + 7);\newline         }\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline         else if (new_filter == FT_EXTERNAL_CONTENT_FILTER)\newline         {\newline            new_bl-&gtname = chomp(buf + 16);\newline         }\newline#endif\newline         else\newline         {\newline            new_bl-&gtname = chomp(buf + 21);\newline         }\newline         new_bl-&gttype = new_filter;\newline\newline         /*\newline          * If a filter description is available,\newline          * encode it to HTML and save it.\newline          */\newline         if (NULL != (new_bl-&gtdescription = strpbrk(new_bl-&gtname, &quot \\t&quot)))\newline         {\newline            *new_bl-&gtdescription++ = &#039\\0&#039;\newline            new_bl-&gtdescription = html_encode(chomp(new_bl-&gtdescription));\newline            if (NULL == new_bl-&gtdescription)\newline            {\newline               new_bl-&gtdescription = strdup_or_die(&quotOut of memory while &quot\newline                  &quotencoding filter description to HTML&quot);\newline            }\newline         }\newline         else\newline         {\newline            new_bl-&gtdescription = strdup_or_die(&quotNo description available&quot);\newline         }\newline\newline         new_bl-&gtname = strdup_or_die(chomp(new_bl-&gtname));\newline\newline         /*\newline          * If this is the first filter block, chain it\newline          * to the file_list rather than its (nonexistant)\newline          * predecessor\newline          */\newline         if (fs-&gtf == NULL)\newline         {\newline            fs-&gtf = new_bl;\newline         }\newline         else\newline         {\newline            assert(NULL != bl);\newline            bl-&gtnext = new_bl;\newline         }\newline         bl = new_bl;\newline\newline         log_error(LOG_LEVEL_RE_FILTER, &quotReading in filter \\&quot%s\\&quot (\\&quot%s\\&quot)&quot, bl-&gtname, bl-&gtdescription);\newline\newline         freez(buf);\newline         continue;\newline      }\newline\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline      if ((bl != NULL) &amp&amp (bl-&gttype == FT_EXTERNAL_CONTENT_FILTER))\newline      {\newline         /* Save the code as &quotpattern&quot, but do not compile anything. */\newline         if (bl-&gtpatterns-&gtfirst != NULL)\newline         {\newline            log_error(LOG_LEVEL_FATAL, &quotExternal filter &#039%s&#039 contains several jobss. &quot\newline               &quotDid you forget to escape a line break?&quot,\newline               bl-&gtname);\newline         }\newline         error = enlist(bl-&gtpatterns, buf);\newline         if (JB_ERR_MEMORY == error)\newline         {\newline            log_error(LOG_LEVEL_FATAL,\newline               &quotOut of memory while enlisting external filter code \\&#039%s\\&#039 for filter %s.&quot,\newline               buf, bl-&gtname);\newline         }\newline         freez(buf);\newline         continue;\newline      }\newline#endif\newline      if (bl != NULL)\newline      {\newline         /*\newline          * Save the expression, make it a pcrs_job\newline          * and chain it into the current filter&#039s joblist\newline          */\newline         error = enlist(bl-&gtpatterns, buf);\newline         if (JB_ERR_MEMORY == error)\newline         {\newline            log_error(LOG_LEVEL_FATAL,\newline               &quotOut of memory while enlisting re_filter job \\&#039%s\\&#039 for filter %s.&quot, buf, bl-&gtname);\newline         }\newline         assert(JB_ERR_OK == error);\newline\newline         if (pcrs_job_is_dynamic(buf))\newline         {\newline            /*\newline             * Dynamic pattern that might contain variables\newline             * and has to be recompiled for every request\newline             */\newline            if (bl-&gtjoblist != NULL)\newline            {\newline                pcrs_free_joblist(bl-&gtjoblist);\newline                bl-&gtjoblist = NULL;\newline            }\newline            bl-&gtdynamic = 1;\newline            log_error(LOG_LEVEL_RE_FILTER,\newline               &quotAdding dynamic re_filter job \\&#039%s\\&#039 to filter %s succeeded.&quot, buf, bl-&gtname);\newline            freez(buf);\newline            continue;\newline         }\newline         else if (bl-&gtdynamic)\newline         {\newline            /*\newline             * A previous job was dynamic and as we\newline             * recompile the whole filter anyway, it\newline             * makes no sense to compile this job now.\newline             */\newline            log_error(LOG_LEVEL_RE_FILTER,\newline               &quotAdding static re_filter job \\&#039%s\\&#039 to dynamic filter %s succeeded.&quot, buf, bl-&gtname);\newline            freez(buf);\newline            continue;\newline         }\newline\newline         if ((dummy = pcrs_compile_command(buf, &amperror)) == NULL)\newline         {\newline            log_error(LOG_LEVEL_ERROR,\newline               &quotAdding re_filter job \\&#039%s\\&#039 to filter %s failed: %s&quot,\newline               buf, bl-&gtname, pcrs_strerror(error));\newline            freez(buf);\newline            continue;\newline         }\newline         else\newline         {\newline            if (bl-&gtjoblist == NULL)\newline            {\newline               bl-&gtjoblist = dummy;\newline            }\newline            else if (NULL != lastjob)\newline            {\newline               lastjob-&gtnext = dummy;\newline            }\newline            lastjob = dummy;\newline            log_error(LOG_LEVEL_RE_FILTER, &quotAdding re_filter job \\&#039%s\\&#039 to filter %s succeeded.&quot, buf, bl-&gtname);\newline         }\newline      }\newline      else\newline      {\newline         log_error(LOG_LEVEL_ERROR, &quotIgnoring job %s outside filter block in %s, line %d&quot,\newline            buf, csp-&gtconfig-&gtre_filterfile[fileid], linenum);\newline      }\newline      freez(buf);\newline   }\newline\newline   fclose(fp);\newline\newline   /*\newline    * Schedule the now-obsolete old data for unloading\newline    */\newline   if (NULL != current_re_filterfile[fileid])\newline   {\newline      current_re_filterfile[fileid]-&gtunloader = unload_re_filterfile;\newline   }\newline\newline   /*\newline    * Chain this file into the global list of loaded files\newline    */\newline   fs-&gtnext    = files-&gtnext;\newline   files-&gtnext = fs;\newline   current_re_filterfile[fileid] = fs;\newline   csp-&gtrlist[fileid] = fs;\newline\newline   return(0);\newline\newlineload_re_filterfile_error:\newline   log_error(LOG_LEVEL_FATAL, &quotcan&#039t load re_filterfile &#039%s&#039: %E&quot,\newline             csp-&gtconfig-&gtre_filterfile[fileid]);\newline   return(-1);\newline\newline}\newline","\newline \newline Function : load_one_re_filterfile\newline \newline Description : Load a re_filterfile.\newline Generate a chained list of re_filterfile_spec&#039s from\newline the &quotFILTER: &quot blocks, compiling all their substitutions\newline into chained lists of pcrs_job structs.\newline \newline Parameters :\newline 1 : csp = Current client state (buffers, headers, etc...)\newline \newline Returns : 0 =&gt Ok, everything else is an error.\newline \newline \newline","4521090","raw.c","sequence_t *raw_parse(FILE *f) {\newline  sequence_t *seq;\newline\newline  seq = rawy_parse(f);\newline\newline  return seq; }\newline","Parse RAW sequence \newline","5639191","amg_linklist.c","void hypre_dispose_elt ( hypre_LinkList element_ptr )\newline{\newline   free( element_ptr );\newline}\newline","\newline \newline dispose_elt(): dispose of memory space used by the element\newline pointed to by element_ptr. Use the &#039free()&#039\newline system call to return it to the free memory \newline pool.\newline \newline \newline","4854360","codegen.c","void codegen_gen_expr(\newline            expression*   expr,        /*!&lt Pointer to root of expression tree to generate */\newline            exp_op_type   parent_op,   /*!&lt Operation of parent.  If our op is the same, no surrounding parenthesis is needed */\newline  /*@out@*/ char***       code,        /*!&lt Pointer to array of strings that will contain code lines for the supplied expression */\newline  /*@out@*/ unsigned int* code_depth,  /*!&lt Pointer to number of strings contained in code array */\newline            func_unit*    funit        /*!&lt Pointer to functional unit containing the specified expression */\newline) { PROFILE(CODEGEN_GEN_EXPR);\newline\newline  char**       right_code;               /* Pointer to the code that is generated by the right side of the expression */\newline  char**       left_code;                /* Pointer to the code that is generated by the left side of the expression */\newline  unsigned int left_code_depth  = 0;     /* Depth of left code string array */\newline  unsigned int right_code_depth = 0;     /* Depth of right code string array */\newline  char         code_format[20];          /* Format for creating my_code string */\newline  char*        tmpstr;                   /* Temporary string holder */\newline  char*        before;                   /* String before operation */\newline  char*        after;                    /* String after operation */\newline  func_unit*   tfunit;                   /* Temporary pointer to functional unit */\newline  char*        pname            = NULL;  /* Printable version of signal name */\newline  unsigned int rv;                       /* Return value from calls to snprintf */\newline\newline  if( expr != NULL ) {\newline\newline    /* Only traverse left and right expression trees if we are not an SLIST-type */\newline    if( (expr-&gtop != EXP_OP_SLIST) &amp&amp (expr-&gtop != EXP_OP_ALWAYS_COMB) &amp&amp (expr-&gtop != EXP_OP_ALWAYS_LATCH) ) {\newline\newline      codegen_gen_expr( expr-&gtleft,  expr-&gtop, &ampleft_code,  &ampleft_code_depth,  funit );\newline      codegen_gen_expr( expr-&gtright, expr-&gtop, &ampright_code, &ampright_code_depth, funit );\newline\newline    }\newline\newline    if( (expr-&gtop == EXP_OP_LAST) || (expr-&gtop == EXP_OP_NB_CALL) || (expr-&gtop == EXP_OP_JOIN) || (expr-&gtop == EXP_OP_FORK) ||\newline        ((parent_op == EXP_OP_REPEAT) &amp&amp (expr-&gtparent-&gtexpr-&gtleft == expr)) ) {\newline\newline      /* Do nothing. */\newline      *code_depth = 0;\newline\newline    } else if( expr-&gtop == EXP_OP_STATIC ) {\newline\newline      unsigned int data_type = expr-&gtvalue-&gtsuppl.part.data_type;\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      *code_depth = 1;\newline\newline      if( data_type == VDATA_R64 ) {\newline\newline        assert( expr-&gtvalue-&gtvalue.r64-&gtstr != NULL );\newline        (*code)[0] = strdup_safe( expr-&gtvalue-&gtvalue.r64-&gtstr );\newline\newline      } else if( data_type == VDATA_R32 ) {\newline\newline        assert( expr-&gtvalue-&gtvalue.r32-&gtstr != NULL );\newline        (*code)[0] = strdup_safe( expr-&gtvalue-&gtvalue.r32-&gtstr );\newline\newline      } else {\newline\newline        if( ESUPPL_STATIC_BASE( expr-&gtsuppl ) == DECIMAL ) {\newline\newline          rv = snprintf( code_format, 20, &quot%d&quot, vector_to_int( expr-&gtvalue ) );\newline          assert( rv &lt 20 );\newline          if( (strlen( code_format ) == 1) &amp&amp (expr-&gtparent-&gtexpr-&gtop == EXP_OP_NEGATE) ) {\newline            strcat( code_format, &quot &quot );\newline          }\newline          (*code)[0] = strdup_safe( code_format );\newline\newline        } else if( ESUPPL_STATIC_BASE( expr-&gtsuppl ) == QSTRING ) {\newline\newline          unsigned int slen;\newline          tmpstr = vector_to_string( expr-&gtvalue, QSTRING, FALSE, 0 );\newline          slen   = strlen( tmpstr ) + 3;\newline          (*code)[0] = (char*)malloc_safe( slen );\newline          rv = snprintf( (*code)[0], slen, &quot\\&quot%s\\&quot&quot, tmpstr );\newline          assert( rv &lt slen );\newline          free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline\newline        } else { \newline\newline          (*code)[0] = vector_to_string( expr-&gtvalue, ESUPPL_STATIC_BASE( expr-&gtsuppl ), FALSE, 0 );\newline\newline        }\newline   \newline      }\newline\newline    } else if( (expr-&gtop == EXP_OP_SIG) || (expr-&gtop == EXP_OP_PARAM) ) {\newline\newline      tmpstr = scope_gen_printable( expr-&gtname );\newline\newline      switch( strlen( tmpstr ) ) {\newline        case 0 :  assert( strlen( tmpstr ) &gt 0 );  break;\newline        case 1 :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = (char*)malloc_safe( 4 );\newline          *code_depth = 1;\newline          rv = snprintf( (*code)[0], 4, &quot %s &quot, tmpstr );\newline          assert( rv &lt 4 );\newline          break;\newline        case 2 :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = (char*)malloc_safe( 4 );\newline          *code_depth = 1;\newline          rv = snprintf( (*code)[0], 4, &quot %s&quot, tmpstr );\newline          assert( rv &lt 4 );\newline          break;\newline        default :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = strdup_safe( tmpstr );\newline          *code_depth = 1;\newline          break;\newline      }\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_SBIT_SEL) || (expr-&gtop == EXP_OP_PARAM_SBIT) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth,\newline                           expr-&gtleft, &quot]&quot, NULL, 0, NULL, NULL );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_SEL) || (expr-&gtop == EXP_OP_PARAM_MBIT) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      if( ESUPPL_WAS_SWAPPED( expr-&gtsuppl ) ) {\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr,\newline                             right_code, right_code_depth, expr-&gtright, &quot:&quot,\newline                             left_code, left_code_depth, expr-&gtleft, &quot]&quot );\newline      } else {\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr,\newline                             left_code, left_code_depth, expr-&gtleft, &quot:&quot,\newline                             right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline      }\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_POS) || (expr-&gtop == EXP_OP_PARAM_MBIT_POS) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot+:&quot,\newline                           right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_NEG) || (expr-&gtop == EXP_OP_PARAM_MBIT_NEG) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot-:&quot,\newline                           right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_FUNC_CALL) || (expr-&gtop == EXP_OP_TASK_CALL) ) {\newline\newline      assert( expr-&gtelem.funit != NULL );\newline\newline      tfunit = expr-&gtelem.funit;\newline      after = (char*)malloc_safe( strlen( tfunit-&gtname ) + 1 );\newline      scope_extract_back( tfunit-&gtname, after, user_msg );\newline      pname = scope_gen_printable( after );\newline      if( (expr-&gtop == EXP_OP_TASK_CALL) &amp&amp (expr-&gtleft == NULL) ) {\newline        *code       = (char**)malloc_safe( sizeof( char* ) );\newline        (*code)[0]  = strdup_safe( pname );\newline        *code_depth = 1;\newline      } else {\newline        unsigned int slen;\newline        tmpstr = (char*)malloc_safe( strlen( pname ) + 3 );\newline        slen   = strlen( pname ) + 3;\newline        rv = snprintf( tmpstr, slen, &quot%s( &quot, pname );\newline        assert( rv &lt slen );\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot )&quot, NULL, 0, NULL, NULL );\newline        free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      }\newline      free_safe( after, (strlen( tfunit-&gtname ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_TRIGGER ) {\newline      unsigned int slen;\newline      assert( expr-&gtsig != NULL );\newline      pname  = scope_gen_printable( expr-&gtname );\newline      slen   = strlen( pname ) + 3;\newline      tmpstr = (char*)malloc_safe( slen );\newline      rv = snprintf( tmpstr, slen, &quot-&gt%s&quot, pname );\newline      assert( rv &lt slen );\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( tmpstr );\newline      *code_depth = 1;\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_DISABLE ) {\newline      unsigned int slen;\newline      assert( expr-&gtelem.funit != NULL );\newline      pname  = scope_gen_printable( expr-&gtname );\newline      slen   = strlen( pname ) + 9;\newline      tmpstr = (char*)malloc_safe( slen );\newline      rv = snprintf( tmpstr, slen, &quotdisable %s&quot, pname );\newline      assert( rv &lt slen );\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( tmpstr );\newline      *code_depth = 1;\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_DEFAULT ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotdefault :&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_SLIST ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot@*&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_ALWAYS_COMB ) {\newline \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotalways_comb&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_ALWAYS_LATCH ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotalways_latch&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_STIME ) {\newline   \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$time&quot );\newline      *code_depth = 1;\newline\newline    } else if( (expr-&gtop == EXP_OP_SRANDOM) &amp&amp (expr-&gtleft == NULL) ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$random&quot );\newline      *code_depth = 1;\newline\newline    } else if( (expr-&gtop == EXP_OP_SURANDOM) &amp&amp (expr-&gtleft == NULL) ) {\newline \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$urandom&quot );\newline      *code_depth = 1;\newline\newline    } else {\newline\newline      if( expr-&gtsuppl.part.parenthesis ) {\newline        before = strdup_safe( &quot(&quot );\newline        after  = strdup_safe( &quot)&quot );\newline      } else {\newline        before = NULL;\newline        after  = NULL;\newline      }\newline\newline      switch( expr-&gtop ) {\newline        case EXP_OP_XOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ^ &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_XOR_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ^= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MULTIPLY :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot * &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MLT_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot *= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_DIVIDE   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot / &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_DIV_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot /= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MOD      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot % &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MOD_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot %= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ADD      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot + &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ADD_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot += &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_SUBTRACT :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot - &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_SUB_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot -= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_EXPONENT :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ** &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_AND      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_AND_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_OR       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot | &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_OR_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot |= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~&amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~| &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NXOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~^ &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LT       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_GT       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LSHIFT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LS_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ALSHIFT  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt&lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ALS_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt&lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_RSHIFT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_RS_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ARSHIFT  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt&gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ARS_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt&gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_EQ       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot == &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_CEQ      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot === &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_GE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot != &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_CNE      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot !== &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot || &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp&amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_COND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot ? &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_COND_SEL :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot : &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_UINV     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~&quot : &quot~&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(&amp&quot : &quot&amp&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNOT     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(!&quot : &quot!&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(|&quot : &quot|&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UXOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(^&quot : &quot^&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNAND    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~&amp&quot : &quot~&amp&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~|&quot : &quot~|&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNXOR    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~^&quot : &quot~^&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_EXPAND   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot{&quot, left_code, left_code_depth, expr-&gtleft, &quot{&quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot}}&quot );\newline          break;\newline        case EXP_OP_LIST     :\newline        case EXP_OP_PLIST    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot, &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_CONCAT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot{&quot, right_code, right_code_depth, expr-&gtright, &quot}&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) || \newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(posedge &quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quotposedge &quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_NEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(negedge &quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quotnegedge &quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_AEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(&quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, NULL, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_EOR      :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(&quot, left_code, left_code_depth, expr-&gtleft, &quot or &quot,\newline                                 right_code, right_code_depth, expr-&gtright, &quot)&quot );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot or &quot,\newline                                 right_code, right_code_depth, expr-&gtright, NULL );\newline          }\newline          break;\newline        case EXP_OP_CASE     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcase( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_CASEX    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcasex( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_CASEZ    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcasez( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_DELAY    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot#(&quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_ASSIGN   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotassign &quot, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_DASSIGN  :\newline        case EXP_OP_RASSIGN  :\newline        case EXP_OP_BASSIGN  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_NASSIGN  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot &lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_PASSIGN  :\newline        case EXP_OP_SASSIGN  :\newline          *code            = right_code;\newline          *code_depth      = right_code_depth;\newline          right_code_depth = 0;\newline          break;\newline        case EXP_OP_DLY_ASSIGN :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_DLY_OP   :\newline        case EXP_OP_RPT_DLY  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_IF       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotif( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_REPEAT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotrepeat( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_WHILE    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotwhile( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_WAIT     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotwait( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_NEGATE   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot-&quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_IINC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot++&quot, left_code, left_code_depth, expr-&gtleft, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PINC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot++&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_IDEC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot--&quot, left_code, left_code_depth, expr-&gtleft, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PDEC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot--&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_DIM      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot&quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_SSIGNED  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$signed( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SUNSIGNED  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$unsigned( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SCLOG2 :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$clog2( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SRANDOM  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$random( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SURANDOM :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$urandom( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SURAND_RANGE :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$urandom_range( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SSRANDOM :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$srandom( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SB2R :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$bitstoreal( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SR2B :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$realtobits( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SI2R :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$itor( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SR2I :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$rtoi( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SSR2B :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$shortrealtobits( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SB2SR :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$bitstoshortreal( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_STESTARGS :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$test$plusargs( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SVALARGS :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$value$plusargs( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        default:  break;\newline      }\newline\newline      /* Deallocate before and after strings */\newline      free_safe( before, (strlen( before ) + 1) );\newline      free_safe( after, (strlen( after ) + 1) );\newline\newline    }\newline\newline    if( right_code_depth &gt 0 ) {\newline      free_safe( right_code, (sizeof( char* ) * right_code_depth) );\newline    }\newline\newline    if( left_code_depth &gt 0 ) {\newline      free_safe( left_code, (sizeof( char* ) * left_code_depth) );\newline    }\newline\newline  }\newline\newline}\newline","!\newline\\param expr Pointer to root of expression tree to generate.\newline\\param parent_op Operation of parent. If our op is the same, no surrounding parenthesis is needed.\newline\\param code Pointer to array of strings that will contain code lines for the supplied expression.\newline\\param code_depth Pointer to number of strings contained in code array.\newline\\param funit Pointer to functional unit containing the specified expression.\newlineGenerates Verilog code from specified expression tree. This Verilog\newlinesnippet is used by the verbose coverage reporting functions for showing\newlineVerilog examples that were missed during simulation. This code handles multi-line\newlineVerilog output by storing its information into the code and code_depth parameters.\newline \newline","799603","remote.c","static int prune_candidates(git_vector *candidates, git_remote *remote)\newline{\newline	git_strarray arr = { 0 };\newline	size_t i;\newline	int error;\newline\newline	if ((error = git_reference_list(&amparr, remote-&gtrepo)) &lt 0)\newline		return error;\newline\newline	for (i = 0; i &lt arr.count; i++) {\newline		const char *refname = arr.strings[i];\newline		char *refname_dup;\newline\newline		if (!git_remote__matching_dst_refspec(remote, refname))\newline			continue;\newline\newline		refname_dup = git__strdup(refname);\newline		GITERR_CHECK_ALLOC(refname_dup);\newline\newline		if ((error = git_vector_insert(candidates, refname_dup)) &lt 0)\newline			goto out;\newline	}\newline\newlineout:\newline	git_strarray_free(&amparr);\newline	return error;\newline}\newline","\newline Generate a list of candidates for pruning by getting a list of\newline references which match the rhs of an active refspec.\newline \newline","6200304","rmimage.c","void rm_trace_creation(Image *image)\newline{\newline    call_trace_proc(image, &quotc&quot);\newline}\newline","\newline Trace image creation\newline \newline No Ruby usage (internal function)\newline \newline @param image the image\newline @see call_trace_proc\newline \newline","6514205","key_management.c","int ecryptfs_unwrap_passphrase(char *decrypted_passphrase, char *filename,\newline			       char *wrapping_passphrase, char *wrapping_salt)\newline{\newline	char v2_wrapping_salt[ECRYPTFS_SALT_SIZE];\newline	char wrapping_auth_tok_sig[ECRYPTFS_SIG_SIZE_HEX + 1];\newline	char wrapping_auth_tok_sig_from_file[ECRYPTFS_SIG_SIZE_HEX + 1];\newline	char wrapping_key[ECRYPTFS_MAX_KEY_BYTES];\newline	char encrypted_passphrase[ECRYPTFS_MAX_PASSPHRASE_BYTES + 1];\newline	int encrypted_passphrase_pos = 0;\newline	int decrypted_passphrase_pos = 0;\newline	int tmp1_outlen = 0;\newline	int tmp2_outlen = 0;\newline	SECStatus err;\newline	SECItem key_item;\newline	PK11SymKey *sym_key = NULL;\newline	PK11SlotInfo *slot = NULL;\newline	PK11Context *enc_ctx = NULL;\newline	SECItem *sec_param = NULL;\newline	uint8_t version = 0;\newline	int encrypted_passphrase_bytes;\newline	int rc;\newline\newline	memset(wrapping_auth_tok_sig_from_file, 0,\newline	       sizeof(wrapping_auth_tok_sig_from_file));\newline	memset(encrypted_passphrase, 0, sizeof(encrypted_passphrase));\newline\newline	rc = __ecryptfs_detect_wrapped_passphrase_file_version(filename,\newline							       &ampversion);\newline	if (rc) {\newline		syslog(LOG_ERR,\newline		       &quotFailed to detect wrapped passphrase version: %s\\n&quot,\newline		       strerror(-rc));\newline		goto out;\newline	}\newline\newline	if (version == 1) {\newline		rc = read_v1_wrapped_passphrase_file(filename,\newline						wrapping_auth_tok_sig_from_file,\newline						encrypted_passphrase,\newline						&ampencrypted_passphrase_bytes);\newline		if (rc)\newline			goto out;\newline	} else if (version == 2) {\newline		rc = read_v2_wrapped_passphrase_file(filename,\newline						v2_wrapping_salt,\newline						wrapping_auth_tok_sig_from_file,\newline						encrypted_passphrase,\newline						&ampencrypted_passphrase_bytes);\newline		if (rc)\newline			goto out;\newline\newline		/**\newline		 * Version 2 wrapped passphrase self-contains the wrapping salt.\newline		 * The passed in @wrapping_salt buffer is ignored and the\newline		 * parsed wrapping salt is used instead.\newline		 */\newline		wrapping_salt = v2_wrapping_salt;\newline	} else {\newline		syslog(LOG_ERR,\newline		       &quotUnsupported wrapped passphrase file version: %u\\n&quot,\newline		       version);\newline		rc = -ENOTSUP;\newline		goto out;\newline	}\newline\newline	rc = generate_passphrase_sig(wrapping_auth_tok_sig, wrapping_key,\newline				     wrapping_salt, wrapping_passphrase);\newline	if (rc) {\newline		syslog(LOG_ERR, &quotError generating passphrase signature; &quot\newline		       &quotrc = [%d]\\n&quot, rc);\newline		rc = (rc &lt 0) ? rc : rc * -1;\newline		goto out;\newline	}\newline\newline	if (memcmp(wrapping_auth_tok_sig_from_file, wrapping_auth_tok_sig,\newline		   ECRYPTFS_SIG_SIZE_HEX) != 0) {\newline		syslog(LOG_ERR, &quotIncorrect wrapping key for file [%s]\\n&quot,\newline		       filename);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	NSS_NoDB_Init(NULL);\newline	slot = PK11_GetBestSlot(CKM_AES_ECB, NULL);\newline	key_item.data = (unsigned char *)wrapping_key;\newline	key_item.len = ECRYPTFS_AES_KEY_BYTES;\newline	sym_key = PK11_ImportSymKey(slot, CKM_AES_ECB, PK11_OriginUnwrap,\newline				    CKA_ENCRYPT, &ampkey_item, NULL);\newline	if (!sym_key) {\newline		syslog(LOG_ERR, &quot%s: PK11_ImportSymKey() returned NULL\\n&quot,\newline		       __FUNCTION__);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	sec_param = PK11_ParamFromIV(CKM_AES_ECB, NULL);\newline	enc_ctx = PK11_CreateContextBySymKey(CKM_AES_ECB, CKA_DECRYPT,\newline					     sym_key, sec_param);\newline	memset(decrypted_passphrase, 0, ECRYPTFS_MAX_PASSPHRASE_BYTES + 1);\newline	err = PK11_CipherOp(\newline		enc_ctx, (unsigned char *) decrypted_passphrase,\newline		&amptmp1_outlen, ECRYPTFS_MAX_PASSPHRASE_BYTES,\newline		(unsigned char *) encrypted_passphrase,\newline		encrypted_passphrase_bytes);//ECRYPTFS_MAX_PASSPHRASE_BYTES);\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11_CipherOp() error; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline		goto nss_finish;\newline	}\newline	err = PK11_DigestFinal(\newline		enc_ctx, \newline		(unsigned char *) decrypted_passphrase + tmp1_outlen,\newline		(unsigned int *) &amptmp2_outlen,\newline		(ECRYPTFS_MAX_PASSPHRASE_BYTES - tmp1_outlen));\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11 error on digest final; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline	}\newline\newlinenss_finish:\newline	if (enc_ctx)\newline		PK11_DestroyContext(enc_ctx, PR_TRUE);\newline	if (sym_key)\newline		PK11_FreeSymKey(sym_key);\newline	if (sec_param)\newline		SECITEM_FreeItem(sec_param, PR_TRUE);\newline	if (slot)\newline		PK11_FreeSlot(slot);\newline	if (rc)\newline		goto out;\newline	encrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	decrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	encrypted_passphrase_bytes -= tmp1_outlen + tmp2_outlen;\newline	if (encrypted_passphrase_bytes != 0) {\newline		syslog(LOG_ERR, &quotWrong size of unwrapped passphrase\\n&quot);\newline		rc = - EIO;\newline		goto out;\newline	}\newlineout:\newline	return rc;\newline}\newline","\newline decryptfs_passphrase must be able to hold\newline ECRYPTFS_MAX_PASSPHRASE_BYTES + 1 bytes\newline \newline","3405932","bluetooth_piconet.c","static int init_candidates(char channel, int known_clock_bits, btbb_piconet *pn)\newline{\newline	int i;\newline	int count = 0; /* total number of candidates */\newline	char observable_channel; /* accounts for aliasing if necessary */\newline\newline	/* only try clock values that match our known bits */\newline	for (i = known_clock_bits; i &lt SEQUENCE_LENGTH; i += 0x40) {\newline		if (pn-&gtaliased)\newline			observable_channel = aliased_channel(pn-&gtsequence[i]);\newline		else\newline			observable_channel = pn-&gtsequence[i];\newline		if (observable_channel == channel)\newline			pn-&gtclock_candidates[count++] = i;\newline		//FIXME ought to throw exception if count gets too big\newline	}\newline	return count;\newline}\newline","create list of initial candidate clock values (hops with same channel as first observed hop) \newline","6482662","rtp.c","void rtp_send_ctrl(struct rtp *session, uint32_t rtp_ts, rtcp_app_callback appcallback)\newline{\newline	/* Send an RTCP packet, if one is due... */\newline	struct timeval	 curr_time;\newline\newline	check_database(session);\newline	gettimeofday(&ampcurr_time, NULL);\newline	if (tv_gt(curr_time, session-&gtnext_rtcp_send_time)) {\newline		/* The RTCP transmission timer has expired. The following */\newline		/* implements draft-ietf-avt-rtp-new-02.txt section 6.3.6 */\newline		int		 h;\newline		source		*s;\newline		struct timeval	 new_send_time;\newline		double		 new_interval;\newline\newline		new_interval  = rtcp_interval(session) / (session-&gtcsrc_count + 1);\newline		new_send_time = session-&gtlast_rtcp_send_time;\newline		tv_add(&ampnew_send_time, new_interval);\newline		if (tv_gt(curr_time, new_send_time)) {\newline			send_rtcp(session, rtp_ts, appcallback);\newline			session-&gtinitial_rtcp        = FALSE;\newline			session-&gtlast_rtcp_send_time = curr_time;\newline			session-&gtnext_rtcp_send_time = curr_time; \newline			tv_add(&amp(session-&gtnext_rtcp_send_time), rtcp_interval(session) / (session-&gtcsrc_count + 1));\newline			/* We&#039re starting a new RTCP reporting interval, zero out */\newline			/* the per-interval statistics.                           */\newline			session-&gtsender_count = 0;\newline			for (h = 0; h &lt RTP_DB_SIZE; h++) {\newline				for (s = session-&gtdb[h]; s != NULL; s = s-&gtnext) {\newline					check_source(s);\newline					s-&gtsender = FALSE;\newline				}\newline			}\newline		} else {\newline			session-&gtnext_rtcp_send_time = new_send_time;\newline		}\newline		session-&gtssrc_count_prev = session-&gtssrc_count;\newline	} \newline	check_database(session);\newline}\newline","\newline rtp_send_ctrl:\newline @session: the session pointer (returned by rtp_init())\newline @rtp_ts: the current time expressed in units of the media timestamp.\newline @appcallback: a callback to create an APP RTCP packet, if needed.\newline \newline Checks RTCP timer and sends RTCP data when nececessary. The\newline interval between RTCP packets is randomized over an interval that\newline depends on the session bandwidth, the number of participants, and\newline whether the local participant is a sender. This function should be\newline called at least once per second, and can be safely called more\newline frequently. \newline \newline","3006459","knockd.c","void generate_pcap_filter()\newline{\newline	PMList *lp;\newline	opendoor_t *door;\newline	char *buffer = NULL;   /* temporary buffer to create the individual filter strings */ \newline	size_t bufsize = 0;    /* size of buffer */\newline	char port_str[10];     /* used by snprintf to convert unsigned short --&gt string */\newline	short head_set = 0;	   /* flag indicating if protocol head is set (i.e. &quot((tcp dst port&quot) */\newline	short tcp_present = 0; /* flag indicating if TCP is used */\newline	short udp_present = 0; /* flag indicating if UDP is used */\newline	unsigned int i;\newline	short modified_filters = 0;  /* flag indicating if at least one filter has changed --&gt recompile the filter */\newline	struct bpf_program bpf_prog; /* compiled BPF filter program */\newline\newline	/* generate subfilters for each door having a NULL pcap_filter_exp\newline	 *\newline	 * Example filter for one single door:\newline	 * ((tcp dst port 8000 or 8001 or 8002) and tcp[tcpflags] &amp tcp-syn != 0) or (udp dst port 4000 or 4001)\newline	 */\newline	for(lp = doors; lp; lp = lp-&gtnext) {\newline		door = (opendoor_t*)lp-&gtdata;\newline\newline		if(door-&gtpcap_filter_exp != NULL) {\newline			continue;\newline		}\newline\newline		/* if we get here at least one door had a pcap_filter_exp == NULL */\newline		modified_filters = 1;\newline\newline		head_set = 0;\newline		tcp_present = 0;\newline		udp_present = 0;\newline\newline		/* allocate memory for buffer if needed.\newline		 * The first allocation will be 200 Bytes (should be large enough for common sequences). If there is\newline		 * not enough space, a call to realloc_strcat() will eventually increase its size. The buffer will be\newline		 * reused for successive doors */\newline		if(buffer == NULL) {\newline			bufsize = 200;\newline			buffer = (char*)malloc(sizeof(char) * bufsize);\newline			if(buffer == NULL) {\newline				perror(&quotmalloc&quot);\newline				cleanup(1);\newline			}\newline			buffer[0] = &#039\\0&#039;\newline		}\newline\newline		bufsize = realloc_strcat(&ampbuffer, &quot(dst host &quot, bufsize);	/* accept only incoming packets */\newline		bufsize = realloc_strcat(&ampbuffer, door-&gttarget ? door-&gttarget : myip, bufsize);\newline		bufsize = realloc_strcat(&ampbuffer, &quot and (&quot, bufsize);\newline\newline		/* generate filter for all TCP ports (i.e. &quot((tcp dst port 4000 or 4001 or 4002) and tcp[tcpflags] &amp tcp-syn != 0)&quot */\newline		for(i = 0; i &lt door-&gtseqcount; i++) {\newline			if(door-&gtprotocol[i] == IPPROTO_TCP) {\newline				if(!head_set) {		/* first TCP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot((tcp dst port &quot, bufsize);\newline					head_set = 1;\newline					tcp_present = 1;\newline				} else {		/* not the first TCP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline				}\newline				snprintf(port_str, sizeof(port_str), &quot%hu&quot, door-&gtsequence[i]);		/* unsigned short to string */\newline				bufsize = realloc_strcat(&ampbuffer, port_str, bufsize);			/* append port number */\newline			}\newline		}\newline		if(tcp_present) {\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of TCP ports */\newline		}\newline\newline		/* append the TCP flag filters */\newline		if(tcp_present) {\newline			if(door-&gtflag_fin != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-fin &quot, bufsize);\newline				if(door-&gtflag_fin == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_fin == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_syn != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-syn &quot, bufsize);\newline				if(door-&gtflag_syn == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_syn == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_rst != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-rst &quot, bufsize);\newline				if(door-&gtflag_rst == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_rst == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_psh != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-psh &quot, bufsize);\newline				if(door-&gtflag_psh == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_psh == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_ack != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-ack &quot, bufsize);\newline				if(door-&gtflag_ack == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_ack == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_urg != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-urg &quot, bufsize);\newline				if(door-&gtflag_urg == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_urg == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of flags */\newline		}\newline\newline		/* append filter for all UDP ports (i.e. &quot(udp dst port 6543 or 6544 or 6545)&quot */\newline		head_set = 0;\newline		for(i = 0; i &lt door-&gtseqcount; i++) {\newline			if(door-&gtprotocol[i] == IPPROTO_UDP) {\newline				if(!head_set) {		/* first UDP port in the sequence */\newline					if(tcp_present) {\newline						bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline					}\newline					bufsize = realloc_strcat(&ampbuffer, &quot(udp dst port &quot, bufsize);\newline					head_set = 1;\newline					udp_present = 1;\newline				} else {		/* not the first UDP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline				}\newline				snprintf(port_str, sizeof(port_str), &quot%hu&quot, door-&gtsequence[i]);		/* unsigned short to string */\newline				bufsize = realloc_strcat(&ampbuffer, port_str, bufsize);			/* append port number */\newline			}\newline		}\newline		if(udp_present) {\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of UDP ports */\newline		}\newline\newline		bufsize = realloc_strcat(&ampbuffer, &quot))&quot, bufsize);		/* close parantheses around port filters */\newline\newline		/* test if in any of the precedent calls to realloc_strcat() failed. We can do this safely here because\newline		 * realloc_strcat() returns 0 on failure and if a buffer size of 0 is passed to it, the function does\newline		 * nothing but returning 0 again. Because we never read buffer in the above code, it is secure to test\newline		 * for failure only at this point (it makes the code more readable than checking for failure each time\newline		 * realloc_strcat() is called). */\newline		if(bufsize == 0) {\newline			perror(&quotrealloc&quot);\newline			cleanup(1);\newline		}\newline\newline		/* allocate the buffer in door holding the filter string, copy it and prepare buffer for being reused. */\newline		door-&gtpcap_filter_exp = (char*)malloc(strlen(buffer) + 1);\newline		if(door-&gtpcap_filter_exp == NULL) {\newline			perror(&quotmalloc&quot);\newline			cleanup(1);\newline		}\newline		strcpy(door-&gtpcap_filter_exp, buffer);\newline		dprint(&quotAdding pcap expression for door &#039%s&#039: %s\\n&quot, door-&gtname, door-&gtpcap_filter_exp);\newline		buffer[0] = &#039\\0&#039;	/* &quotclear&quot the buffer */\newline	}\newline\newline\newline	/* generate the whole pcap filter string if a filter had been modified. Reuse buffer (already &quotcleared&quot).\newline	 *\newline	 * Note that we don&#039t check if a port is included in multiple doors, we simply concatenate the individual door\newline	 * filters and rely on pcap&#039s optimization capabilities.\newline	 *\newline	 * Example filter for two doors with sequences 8000:tcp,4000:udp,8001:tcp,4001:udp,8002:tcp (syn) and \newline	 * 1234:tcp,4567:tcp,8901:tcp (syn,ack) :\newline	 * dst host the.hosts.ip.address and (\newline	 *      ((tcp dst port 8000 or 8001 or 8002) and tcp[tcpflags] &amp tcp-syn != 0) or (udp dst port 4000 or 4001)\newline	 *   or ((tcp dst port 1234 or 4567 or 8901) and tcp[tcpflags] &amp tcp-syn != 0 and tcp[tcpflags] &amp tcp-ack != 0)\newline	 * )\newline	 */\newline	if(modified_filters) {\newline		/* iterate over all doors */\newline		for(lp = doors; lp; lp = lp-&gtnext) {\newline			door = (opendoor_t*)lp-&gtdata;\newline			bufsize = realloc_strcat(&ampbuffer, door-&gtpcap_filter_exp, bufsize);\newline			if(lp-&gtnext != NULL) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline			}\newline		}\newline\newline		/* test if in any of the precedent calls to realloc_strcat() failed. See above why this is ok to do this only\newline		 * at this point */\newline		if(bufsize == 0) {\newline			perror(&quotrealloc&quot);\newline			cleanup(1);\newline		}\newline\newline		if(pcap_compile(cap, &ampbpf_prog, buffer, 1, 0) &lt 0) {	/* optimize filter (1), no netmask (0) (we&#039re not interested in broadcasts) */\newline			pcap_perror(cap, &quotpcap&quot);\newline			cleanup(1);\newline		}\newline		if(pcap_setfilter(cap, &ampbpf_prog) &lt 0) {\newline			pcap_perror(cap, &quotpcap&quot);\newline			cleanup(1);\newline		}\newline		pcap_freecode(&ampbpf_prog);\newline		free(buffer);\newline	}\newline}\newline","Generate and set the filter for pcap. That way only the relevant packets will\newline be forwarded to us (in sniff()). Note that generate_pcap_filter() will first\newline generate a subfilter (=substring of the whole filter string) for each door if\newline door-&gtpcap_filter_exp is NULL. This behaviour can be used for doors with one\newline time sequences, where the subfilter has to be generated after each sequence.\newline \newline","3829689","wxlist.cpp","void CBaseList::RemoveAll()\newline{\newline    /* Free up all the CNode objects NOTE we don&#039t bother putting the\newline       deleted nodes into the cache as this method is only really called\newline       in serious times of change such as when we are being deleted at\newline       which point the cache will be deleted anway */\newline\newline    CNode *pn = m_pFirst;\newline    while (pn) {\newline        CNode *op = pn;\newline        pn = pn-&gtNext();\newline        delete op;\newline    }\newline\newline    /* Reset the object count and the list pointers */\newline\newline    m_Count = 0;\newline    m_pFirst = m_pLast = NULL;\newline\newline} // RemoveAll\newline","Remove all the nodes from the list but don&#039t do anything\newlinewith the objects that each node looks after (this is the\newlineresponsibility of the creator).\newlineAa a last act we reset the signalling event\newline(if available) to indicate to clients that the list\newlinedoes not have any entries in it.\newline \newline","5173190","randm.c","void avRandomInit()\newline{\newline    avChurnRand(NULL, 0);\newline}\newline","\newline Initialize the random number generator.\newline \newline Since this is to be called on power up, we don&#039t have much\newline system randomess to work with. Here all we use is the\newline real-time clock. We&#039ll accumulate more randomness as soon\newline as things start happening.\newline \newline","3785490","state.c","int init_builtin(f_state *s, int type, char *suffix, char *header, char *footer, int header_len,\newline				 int footer_len, u_int64_t max_len, int case_sen)\newline{\newline\newline	int i = s-&gtnum_builtin;\newline\newline	search_spec[i].type = type;\newline	search_spec[i].suffix = (char *)malloc((strlen(suffix)+1) * sizeof(char));\newline	search_spec[i].num_markers = 0;\newline	strcpy(search_spec[i].suffix, suffix);\newline\newline	search_spec[i].header_len = header_len;\newline	search_spec[i].footer_len = footer_len;\newline\newline	search_spec[i].max_len = max_len;\newline	search_spec[i].found = 0;\newline	search_spec[i].header = (unsigned char *)malloc(search_spec[i].header_len * sizeof(unsigned char));\newline	search_spec[i].footer = (unsigned char *)malloc(search_spec[i].footer_len * sizeof(unsigned char));\newline	search_spec[i].case_sen = case_sen;\newline	memset(search_spec[i].comment, 0, COMMENT_LENGTH - 1);\newline\newline	memcpy(search_spec[i].header, header, search_spec[i].header_len);\newline	memcpy(search_spec[i].footer, footer, search_spec[i].footer_len);\newline\newline	init_bm_table(search_spec[i].header,\newline				  search_spec[i].header_bm_table,\newline				  search_spec[i].header_len,\newline				  search_spec[i].case_sen,\newline				  SEARCHTYPE_FORWARD);\newline	init_bm_table(search_spec[i].footer,\newline				  search_spec[i].footer_bm_table,\newline				  search_spec[i].footer_len,\newline				  search_spec[i].case_sen,\newline				  SEARCHTYPE_FORWARD);\newline	s-&gtnum_builtin++;\newline\newline	return i;\newline}\newline","Initialize any search specs \newline","5142364","gaio.c","gaint gaclosenc (struct gafile *pfi) {\newline#if USENETCDF==1\newline  gaint rc;\newline  gaint oldncopts ;     \newline  oldncopts = ncopts ;\newline  ncopts = 0;\newline  if (pfi-&gtncid != -999) {\newline    rc = nc_close(pfi-&gtncid);\newline    if (rc != NC_NOERR) {\newline      gaprnt(0,&quotError: nc_close failed\\n&quot);\newline      snprintf(pout,255,&quot%s\\n&quot,nc_strerror(rc));\newline      gaprnt(0,pout);\newline      return (1);\newline    }\newline    pfi-&gtncid = -999;\newline  }\newline  ncopts = oldncopts ;\newline#endif\newline  return (0);\newline}\newline","close a netCDF file, reset ncid in gafile structure \newline","5071342","hashcomp.h","inline std::string operator+(std::string &ampleftval, ci::string &amprightval)\newline{\newline	return leftval + std::string(rightval.c_str());\newline}\newline","Define operators for + and == with ci::string to std::string for easy assignment\newline and comparison\newline \newline Operator +\newline \newline","","","","","on","","","","","","","","","","","","","","","","","on","on","on","","","","on","","on","","","","","","","","","","on","","on","ensures that the given parameter (nick) is really a properstring","Generates Verilog code from specified expression tree.","Generate a list of candidates for pruning","Trace image creation","{}","create list of initial candidate clock values","Checks RTCP timer and sends RTCP data when nececessary.","Generate and set the filter for pcap.","Remove all the nodes from the list","Initialize the random number generator.","Initialize any search specs","compute the outputs of your S-functionblock.","close a netCDF file, reset ncid in gafile structure","Define operators for + and == with ci::string to std::string","generate an event on the related epoll fd","Reset parameters of libcw to default values","Change the angle of the eyes in the stereo output.","Remove a quota root","Load a re_filterfile.Generate a chained list of re_filterfile_spec's","Parse RAW sequence","dispose of memory space used by the elementpointed to by element_ptr."
"3XBYQ44Z6P41DP2YF77MH52U74XTWZ","39S3HZ8OHBR4Y1W0CRZ0ZZ0HUTU7SH","Highlight the phrase that best summarizes a C function (Chrome and Firefox only)","Given a function written in the C programming language and a corresponding comment, highlight the 0-12 words in the comment that best summarize the purpose of the function.","programming highlight code C function comment tag find choose summarize software engineering","$1.00","Wed Apr 17 13:22:45 PDT 2019","2","BatchId:3611275;OriginalHitTemplateId:920937336;","3600","172800","Wed Apr 24 13:22:45 PDT 2019","","","3P529IW9KYLD6A5R6B0WG922YELLFY","A2U0JT7TSIIXPS","Approved","Wed Apr 17 18:35:46 PDT 2019","Wed Apr 17 19:03:20 PDT 2019","Fri Apr 19 19:03:20 PDT 2019","2019-04-20 02:03:26 UTC","","","1654","100% (1/1)","100% (1/1)","100% (1/1)","6434465","m_nick.c","static int do_nick_name(char* nick)\newline{\newline  char* ch  = nick;\newline  char* end = ch + NICKLEN;\newline  assert(0 != ch);\newline  \newline  /* first character in [0..9-] */\newline  if (*ch == &#039-&#039 || IsDigit(*ch))\newline    return 0;\newline  for ( ; (ch &lt end) &amp&amp *ch; ++ch)\newline    if (!IsNickChar(*ch))\newline      break;\newline\newline  *ch = &#039\\0&#039;\newline\newline  return (ch - nick);\newline}\newline","\newline &#039do_nick_name&#039 ensures that the given parameter (nick) is really a proper\newline string for a nickname (note, the &#039nick&#039 may be modified in the process...)\newline \newline RETURNS the length of the final NICKNAME (0, if nickname is invalid)\newline \newline Nickname characters are in range &#039A&#039..&#039}&#039, &#039_&#039, &#039-&#039, &#0390&#039..&#0399&#039\newline anything outside the above set will terminate nickname.\newline In addition, the first character cannot be &#039-&#039 or a Digit.\newline \newline Note:\newline The &#039~&#039-character should be allowed, but a change should be global,\newline some confusion would result if only few servers allowed it...\newline \newline","4988975","sfuntmpl.c","static void mdlOutputs(SimStruct *S, int_T tid)\newline{\newline    const real_T *u = (const real_T*) ssGetInputPortSignal(S,0);\newline    real_T       *y = ssGetOutputPortSignal(S,0);\newline    y[0] = 2.0 * u[0];\newline}\newline","Function: mdlOutputs =======================================================\newline Abstract:\newline In this function, you compute the outputs of your S-function\newline block. Generally outputs are placed in the output vector, ssGetY(S).\newline \newline","4890142","rsocket.c","static int rs_create_cq(struct rsocket *rs, struct rdma_cm_id *cm_id)\newline{\newline	cm_id-&gtrecv_cq_channel = ibv_create_comp_channel(cm_id-&gtverbs);\newline	if (!cm_id-&gtrecv_cq_channel)\newline		return -1;\newline\newline	cm_id-&gtrecv_cq = ibv_create_cq(cm_id-&gtverbs, rs-&gtsq_size + rs-&gtrq_size,\newline				       cm_id, cm_id-&gtrecv_cq_channel, 0);\newline	if (!cm_id-&gtrecv_cq)\newline		goto err1;\newline\newline	if (rs-&gtfd_flags &amp O_NONBLOCK) {\newline		if (fcntl(cm_id-&gtrecv_cq_channel-&gtfd, F_SETFL, O_NONBLOCK))\newline			goto err2;\newline	}\newline\newline	ibv_req_notify_cq(cm_id-&gtrecv_cq, 0);\newline	cm_id-&gtsend_cq_channel = cm_id-&gtrecv_cq_channel;\newline	cm_id-&gtsend_cq = cm_id-&gtrecv_cq;\newline	return 0;\newline\newlineerr2:\newline	ibv_destroy_cq(cm_id-&gtrecv_cq);\newline	cm_id-&gtrecv_cq = NULL;\newlineerr1:\newline	ibv_destroy_comp_channel(cm_id-&gtrecv_cq_channel);\newline	cm_id-&gtrecv_cq_channel = NULL;\newline	return -1;\newline}\newline","\newline If a user is waiting on a datagram rsocket through poll or select, then\newline we need the first completion to generate an event on the related epoll fd\newline in order to signal the user. We arm the CQ on creation for this purpose\newline \newline","1025401","cwdaemon.c","void cwdaemon_reset_libcw_output(void)\newline{\newline	/* This function is called when cwdaemon receives &#0390&#039 escape code.\newline	   README describes this code as &quotReset to default values&quot.\newline	   Therefore we use default_* below.\newline\newline	   However, the function is called after &quotcurrent_&quot values\newline	   have been reset to &quotdefault_&quot values. So maybe we could use\newline	   &quotcurrent_&quot values and somehow encapsulate the calls to\newline	   cw_set_*() functions? The calls are also made elsewhere.\newline	*/\newline\newline	/* Delete old generator (if it exists). */\newline	cwdaemon_close_libcw_output();\newline\newline	cwdaemon_debug(CWDAEMON_VERBOSITY_I, __func__, __LINE__, &quotsetting sound system \\&quot%s\\&quot&quot, cw_get_audio_system_label(default_audio_system));\newline\newline	if (cwdaemon_open_libcw_output(default_audio_system)) {\newline		has_audio_output = true;\newline	} else {\newline		has_audio_output = false;\newline		return;\newline	}\newline\newline	/* Remember that tone queue is bound to a generator.  When\newline	   cwdaemon switches on request to other sound system, it will\newline	   have to re-register the callback. */\newline	cw_register_tone_queue_low_callback(cwdaemon_tone_queue_low_callback, NULL, tq_low_watermark);\newline\newline	cw_set_frequency(default_morse_tone);\newline	cw_set_send_speed(default_morse_speed);\newline	cw_set_volume(default_morse_volume);\newline	cw_set_gap(0);\newline	cw_set_weighting(default_weighting * 0.6 + CWDAEMON_MORSE_WEIGHTING_MAX);\newline\newline	return;\newline}\newline","\newline\\brief Reset parameters of libcw to default values\newlineFunction uses values of cwdaemon&#039s global &#039default_&#039 variables, and some\newlineother values to reset state of libcw.\newline \newline","1893160","opengl.c","gboolean visu_gl_setStereoAngle(float angle)\newline{\newline  g_return_val_if_fail(angle &gt 0.f, FALSE);\newline\newline  if (stereoAngles[0] == angle)\newline    return FALSE;\newline\newline  stereoAngles[0] = angle;\newline  stereoAngles[1] = -angle;\newline\newline  return stereoStatus;\newline}\newline","\newline visu_gl_setStereoAngle:\newline @angle: a positive floating point value.\newline \newline Change the angle of the eyes in the stereo output.\newline \newline Returns: TRUE if redraw should be done.\newline \newline","2162883","mboxlist.c","EXPORTED int mboxlist_unsetquota(const char *root)\newline{\newline    char pattern[MAX_MAILBOX_PATH+1];\newline    struct quota q;\newline    int r=0;\newline\newline    if (!root[0] || root[0] == &#039.&#039 || strchr(root, &#039/&#039)\newline	|| strchr(root, &#039*&#039) || strchr(root, &#039%&#039) || strchr(root, &#039?&#039)) {\newline	return IMAP_MAILBOX_BADNAME;\newline    }\newline    \newline    quota_init(&ampq, root);\newline    r = quota_read(&ampq, NULL, 0);\newline    /* already unset */\newline    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\newline	r = 0;\newline	goto done;\newline    }\newline    if (r) goto done;\newline\newline    r = quota_changelock();\newline\newline    /*\newline     * Have to remove it from all affected mailboxes\newline     */\newline    strlcpy(pattern, root, sizeof(pattern));\newline    if (config_virtdomains &amp&amp root[strlen(root)-1] == &#039!&#039) {\newline	/* domain quota */\newline	strlcat(pattern, &quot*&quot, sizeof(pattern));\newline    }\newline    else\newline	strlcat(pattern, &quot.*&quot, sizeof(pattern));\newline    \newline    /* top level mailbox */\newline    mboxlist_rmquota(root, 0, 0, (void *)root);\newline    /* submailboxes - we&#039re using internal names here */\newline    mboxlist_findall(NULL, pattern, 1, 0, 0, mboxlist_rmquota, (void *)root);\newline\newline    r = quota_deleteroot(root);\newline    quota_changelockrelease();\newline\newline    if (!r) sync_log_quota(root);\newline\newline done:\newline    quota_free(&ampq);\newline    return r;\newline}\newline","\newline Remove a quota root\newline \newline","4206459","loaders.c","int load_one_re_filterfile(struct client_state *csp, int fileid)\newline{\newline   FILE *fp;\newline\newline   struct re_filterfile_spec *new_bl, *bl = NULL;\newline   struct file_list *fs;\newline\newline   char *buf = NULL;\newline   int error;\newline   unsigned long linenum = 0;\newline   pcrs_job *dummy, *lastjob = NULL;\newline\newline   /*\newline    * No need to reload if unchanged\newline    */\newline   if (!check_file_changed(current_re_filterfile[fileid], csp-&gtconfig-&gtre_filterfile[fileid], &ampfs))\newline   {\newline      csp-&gtrlist[fileid] = current_re_filterfile[fileid];\newline      return(0);\newline   }\newline   if (!fs)\newline   {\newline      goto load_re_filterfile_error;\newline   }\newline\newline   /*\newline    * Open the file or fail\newline    */\newline   if ((fp = fopen(csp-&gtconfig-&gtre_filterfile[fileid], &quotr&quot)) == NULL)\newline   {\newline      goto load_re_filterfile_error;\newline   }\newline\newline   log_error(LOG_LEVEL_INFO, &quotLoading filter file: %s&quot, csp-&gtconfig-&gtre_filterfile[fileid]);\newline\newline   /*\newline    * Read line by line\newline    */\newline   while (read_config_line(fp, &amplinenum, &ampbuf) != NULL)\newline   {\newline      enum filter_type new_filter = FT_INVALID_FILTER;\newline\newline      if (strncmp(buf, &quotFILTER:&quot, 7) == 0)\newline      {\newline         new_filter = FT_CONTENT_FILTER;\newline      }\newline      else if (strncmp(buf, &quotSERVER-HEADER-FILTER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_SERVER_HEADER_FILTER;\newline      }\newline      else if (strncmp(buf, &quotCLIENT-HEADER-FILTER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_CLIENT_HEADER_FILTER;\newline      }\newline      else if (strncmp(buf, &quotCLIENT-HEADER-TAGGER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_CLIENT_HEADER_TAGGER;\newline      }\newline      else if (strncmp(buf, &quotSERVER-HEADER-TAGGER:&quot, 21) == 0)\newline      {\newline         new_filter = FT_SERVER_HEADER_TAGGER;\newline      }\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline      else if (strncmp(buf, &quotEXTERNAL-FILTER:&quot, 16) == 0)\newline      {\newline         new_filter = FT_EXTERNAL_CONTENT_FILTER;\newline      }\newline#endif\newline\newline      /*\newline       * If this is the head of a new filter block, make it a\newline       * re_filterfile spec of its own and chain it to the list:\newline       */\newline      if (new_filter != FT_INVALID_FILTER)\newline      {\newline         new_bl = zalloc_or_die(sizeof(*bl));\newline         if (new_filter == FT_CONTENT_FILTER)\newline         {\newline            new_bl-&gtname = chomp(buf + 7);\newline         }\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline         else if (new_filter == FT_EXTERNAL_CONTENT_FILTER)\newline         {\newline            new_bl-&gtname = chomp(buf + 16);\newline         }\newline#endif\newline         else\newline         {\newline            new_bl-&gtname = chomp(buf + 21);\newline         }\newline         new_bl-&gttype = new_filter;\newline\newline         /*\newline          * If a filter description is available,\newline          * encode it to HTML and save it.\newline          */\newline         if (NULL != (new_bl-&gtdescription = strpbrk(new_bl-&gtname, &quot \\t&quot)))\newline         {\newline            *new_bl-&gtdescription++ = &#039\\0&#039;\newline            new_bl-&gtdescription = html_encode(chomp(new_bl-&gtdescription));\newline            if (NULL == new_bl-&gtdescription)\newline            {\newline               new_bl-&gtdescription = strdup_or_die(&quotOut of memory while &quot\newline                  &quotencoding filter description to HTML&quot);\newline            }\newline         }\newline         else\newline         {\newline            new_bl-&gtdescription = strdup_or_die(&quotNo description available&quot);\newline         }\newline\newline         new_bl-&gtname = strdup_or_die(chomp(new_bl-&gtname));\newline\newline         /*\newline          * If this is the first filter block, chain it\newline          * to the file_list rather than its (nonexistant)\newline          * predecessor\newline          */\newline         if (fs-&gtf == NULL)\newline         {\newline            fs-&gtf = new_bl;\newline         }\newline         else\newline         {\newline            assert(NULL != bl);\newline            bl-&gtnext = new_bl;\newline         }\newline         bl = new_bl;\newline\newline         log_error(LOG_LEVEL_RE_FILTER, &quotReading in filter \\&quot%s\\&quot (\\&quot%s\\&quot)&quot, bl-&gtname, bl-&gtdescription);\newline\newline         freez(buf);\newline         continue;\newline      }\newline\newline#ifdef FEATURE_EXTERNAL_FILTERS\newline      if ((bl != NULL) &amp&amp (bl-&gttype == FT_EXTERNAL_CONTENT_FILTER))\newline      {\newline         /* Save the code as &quotpattern&quot, but do not compile anything. */\newline         if (bl-&gtpatterns-&gtfirst != NULL)\newline         {\newline            log_error(LOG_LEVEL_FATAL, &quotExternal filter &#039%s&#039 contains several jobss. &quot\newline               &quotDid you forget to escape a line break?&quot,\newline               bl-&gtname);\newline         }\newline         error = enlist(bl-&gtpatterns, buf);\newline         if (JB_ERR_MEMORY == error)\newline         {\newline            log_error(LOG_LEVEL_FATAL,\newline               &quotOut of memory while enlisting external filter code \\&#039%s\\&#039 for filter %s.&quot,\newline               buf, bl-&gtname);\newline         }\newline         freez(buf);\newline         continue;\newline      }\newline#endif\newline      if (bl != NULL)\newline      {\newline         /*\newline          * Save the expression, make it a pcrs_job\newline          * and chain it into the current filter&#039s joblist\newline          */\newline         error = enlist(bl-&gtpatterns, buf);\newline         if (JB_ERR_MEMORY == error)\newline         {\newline            log_error(LOG_LEVEL_FATAL,\newline               &quotOut of memory while enlisting re_filter job \\&#039%s\\&#039 for filter %s.&quot, buf, bl-&gtname);\newline         }\newline         assert(JB_ERR_OK == error);\newline\newline         if (pcrs_job_is_dynamic(buf))\newline         {\newline            /*\newline             * Dynamic pattern that might contain variables\newline             * and has to be recompiled for every request\newline             */\newline            if (bl-&gtjoblist != NULL)\newline            {\newline                pcrs_free_joblist(bl-&gtjoblist);\newline                bl-&gtjoblist = NULL;\newline            }\newline            bl-&gtdynamic = 1;\newline            log_error(LOG_LEVEL_RE_FILTER,\newline               &quotAdding dynamic re_filter job \\&#039%s\\&#039 to filter %s succeeded.&quot, buf, bl-&gtname);\newline            freez(buf);\newline            continue;\newline         }\newline         else if (bl-&gtdynamic)\newline         {\newline            /*\newline             * A previous job was dynamic and as we\newline             * recompile the whole filter anyway, it\newline             * makes no sense to compile this job now.\newline             */\newline            log_error(LOG_LEVEL_RE_FILTER,\newline               &quotAdding static re_filter job \\&#039%s\\&#039 to dynamic filter %s succeeded.&quot, buf, bl-&gtname);\newline            freez(buf);\newline            continue;\newline         }\newline\newline         if ((dummy = pcrs_compile_command(buf, &amperror)) == NULL)\newline         {\newline            log_error(LOG_LEVEL_ERROR,\newline               &quotAdding re_filter job \\&#039%s\\&#039 to filter %s failed: %s&quot,\newline               buf, bl-&gtname, pcrs_strerror(error));\newline            freez(buf);\newline            continue;\newline         }\newline         else\newline         {\newline            if (bl-&gtjoblist == NULL)\newline            {\newline               bl-&gtjoblist = dummy;\newline            }\newline            else if (NULL != lastjob)\newline            {\newline               lastjob-&gtnext = dummy;\newline            }\newline            lastjob = dummy;\newline            log_error(LOG_LEVEL_RE_FILTER, &quotAdding re_filter job \\&#039%s\\&#039 to filter %s succeeded.&quot, buf, bl-&gtname);\newline         }\newline      }\newline      else\newline      {\newline         log_error(LOG_LEVEL_ERROR, &quotIgnoring job %s outside filter block in %s, line %d&quot,\newline            buf, csp-&gtconfig-&gtre_filterfile[fileid], linenum);\newline      }\newline      freez(buf);\newline   }\newline\newline   fclose(fp);\newline\newline   /*\newline    * Schedule the now-obsolete old data for unloading\newline    */\newline   if (NULL != current_re_filterfile[fileid])\newline   {\newline      current_re_filterfile[fileid]-&gtunloader = unload_re_filterfile;\newline   }\newline\newline   /*\newline    * Chain this file into the global list of loaded files\newline    */\newline   fs-&gtnext    = files-&gtnext;\newline   files-&gtnext = fs;\newline   current_re_filterfile[fileid] = fs;\newline   csp-&gtrlist[fileid] = fs;\newline\newline   return(0);\newline\newlineload_re_filterfile_error:\newline   log_error(LOG_LEVEL_FATAL, &quotcan&#039t load re_filterfile &#039%s&#039: %E&quot,\newline             csp-&gtconfig-&gtre_filterfile[fileid]);\newline   return(-1);\newline\newline}\newline","\newline \newline Function : load_one_re_filterfile\newline \newline Description : Load a re_filterfile.\newline Generate a chained list of re_filterfile_spec&#039s from\newline the &quotFILTER: &quot blocks, compiling all their substitutions\newline into chained lists of pcrs_job structs.\newline \newline Parameters :\newline 1 : csp = Current client state (buffers, headers, etc...)\newline \newline Returns : 0 =&gt Ok, everything else is an error.\newline \newline \newline","4521090","raw.c","sequence_t *raw_parse(FILE *f) {\newline  sequence_t *seq;\newline\newline  seq = rawy_parse(f);\newline\newline  return seq; }\newline","Parse RAW sequence \newline","5639191","amg_linklist.c","void hypre_dispose_elt ( hypre_LinkList element_ptr )\newline{\newline   free( element_ptr );\newline}\newline","\newline \newline dispose_elt(): dispose of memory space used by the element\newline pointed to by element_ptr. Use the &#039free()&#039\newline system call to return it to the free memory \newline pool.\newline \newline \newline","4854360","codegen.c","void codegen_gen_expr(\newline            expression*   expr,        /*!&lt Pointer to root of expression tree to generate */\newline            exp_op_type   parent_op,   /*!&lt Operation of parent.  If our op is the same, no surrounding parenthesis is needed */\newline  /*@out@*/ char***       code,        /*!&lt Pointer to array of strings that will contain code lines for the supplied expression */\newline  /*@out@*/ unsigned int* code_depth,  /*!&lt Pointer to number of strings contained in code array */\newline            func_unit*    funit        /*!&lt Pointer to functional unit containing the specified expression */\newline) { PROFILE(CODEGEN_GEN_EXPR);\newline\newline  char**       right_code;               /* Pointer to the code that is generated by the right side of the expression */\newline  char**       left_code;                /* Pointer to the code that is generated by the left side of the expression */\newline  unsigned int left_code_depth  = 0;     /* Depth of left code string array */\newline  unsigned int right_code_depth = 0;     /* Depth of right code string array */\newline  char         code_format[20];          /* Format for creating my_code string */\newline  char*        tmpstr;                   /* Temporary string holder */\newline  char*        before;                   /* String before operation */\newline  char*        after;                    /* String after operation */\newline  func_unit*   tfunit;                   /* Temporary pointer to functional unit */\newline  char*        pname            = NULL;  /* Printable version of signal name */\newline  unsigned int rv;                       /* Return value from calls to snprintf */\newline\newline  if( expr != NULL ) {\newline\newline    /* Only traverse left and right expression trees if we are not an SLIST-type */\newline    if( (expr-&gtop != EXP_OP_SLIST) &amp&amp (expr-&gtop != EXP_OP_ALWAYS_COMB) &amp&amp (expr-&gtop != EXP_OP_ALWAYS_LATCH) ) {\newline\newline      codegen_gen_expr( expr-&gtleft,  expr-&gtop, &ampleft_code,  &ampleft_code_depth,  funit );\newline      codegen_gen_expr( expr-&gtright, expr-&gtop, &ampright_code, &ampright_code_depth, funit );\newline\newline    }\newline\newline    if( (expr-&gtop == EXP_OP_LAST) || (expr-&gtop == EXP_OP_NB_CALL) || (expr-&gtop == EXP_OP_JOIN) || (expr-&gtop == EXP_OP_FORK) ||\newline        ((parent_op == EXP_OP_REPEAT) &amp&amp (expr-&gtparent-&gtexpr-&gtleft == expr)) ) {\newline\newline      /* Do nothing. */\newline      *code_depth = 0;\newline\newline    } else if( expr-&gtop == EXP_OP_STATIC ) {\newline\newline      unsigned int data_type = expr-&gtvalue-&gtsuppl.part.data_type;\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      *code_depth = 1;\newline\newline      if( data_type == VDATA_R64 ) {\newline\newline        assert( expr-&gtvalue-&gtvalue.r64-&gtstr != NULL );\newline        (*code)[0] = strdup_safe( expr-&gtvalue-&gtvalue.r64-&gtstr );\newline\newline      } else if( data_type == VDATA_R32 ) {\newline\newline        assert( expr-&gtvalue-&gtvalue.r32-&gtstr != NULL );\newline        (*code)[0] = strdup_safe( expr-&gtvalue-&gtvalue.r32-&gtstr );\newline\newline      } else {\newline\newline        if( ESUPPL_STATIC_BASE( expr-&gtsuppl ) == DECIMAL ) {\newline\newline          rv = snprintf( code_format, 20, &quot%d&quot, vector_to_int( expr-&gtvalue ) );\newline          assert( rv &lt 20 );\newline          if( (strlen( code_format ) == 1) &amp&amp (expr-&gtparent-&gtexpr-&gtop == EXP_OP_NEGATE) ) {\newline            strcat( code_format, &quot &quot );\newline          }\newline          (*code)[0] = strdup_safe( code_format );\newline\newline        } else if( ESUPPL_STATIC_BASE( expr-&gtsuppl ) == QSTRING ) {\newline\newline          unsigned int slen;\newline          tmpstr = vector_to_string( expr-&gtvalue, QSTRING, FALSE, 0 );\newline          slen   = strlen( tmpstr ) + 3;\newline          (*code)[0] = (char*)malloc_safe( slen );\newline          rv = snprintf( (*code)[0], slen, &quot\\&quot%s\\&quot&quot, tmpstr );\newline          assert( rv &lt slen );\newline          free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline\newline        } else { \newline\newline          (*code)[0] = vector_to_string( expr-&gtvalue, ESUPPL_STATIC_BASE( expr-&gtsuppl ), FALSE, 0 );\newline\newline        }\newline   \newline      }\newline\newline    } else if( (expr-&gtop == EXP_OP_SIG) || (expr-&gtop == EXP_OP_PARAM) ) {\newline\newline      tmpstr = scope_gen_printable( expr-&gtname );\newline\newline      switch( strlen( tmpstr ) ) {\newline        case 0 :  assert( strlen( tmpstr ) &gt 0 );  break;\newline        case 1 :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = (char*)malloc_safe( 4 );\newline          *code_depth = 1;\newline          rv = snprintf( (*code)[0], 4, &quot %s &quot, tmpstr );\newline          assert( rv &lt 4 );\newline          break;\newline        case 2 :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = (char*)malloc_safe( 4 );\newline          *code_depth = 1;\newline          rv = snprintf( (*code)[0], 4, &quot %s&quot, tmpstr );\newline          assert( rv &lt 4 );\newline          break;\newline        default :\newline          *code       = (char**)malloc_safe( sizeof( char* ) );\newline          (*code)[0]  = strdup_safe( tmpstr );\newline          *code_depth = 1;\newline          break;\newline      }\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_SBIT_SEL) || (expr-&gtop == EXP_OP_PARAM_SBIT) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth,\newline                           expr-&gtleft, &quot]&quot, NULL, 0, NULL, NULL );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_SEL) || (expr-&gtop == EXP_OP_PARAM_MBIT) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      if( ESUPPL_WAS_SWAPPED( expr-&gtsuppl ) ) {\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr,\newline                             right_code, right_code_depth, expr-&gtright, &quot:&quot,\newline                             left_code, left_code_depth, expr-&gtleft, &quot]&quot );\newline      } else {\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr,\newline                             left_code, left_code_depth, expr-&gtleft, &quot:&quot,\newline                             right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline      }\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_POS) || (expr-&gtop == EXP_OP_PARAM_MBIT_POS) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot+:&quot,\newline                           right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_MBIT_NEG) || (expr-&gtop == EXP_OP_PARAM_MBIT_NEG) ) {\newline\newline      if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 0) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DIM) &amp&amp\newline          (expr-&gtparent-&gtexpr-&gtright == expr) ) {\newline        tmpstr = (char*)malloc_safe( 2 );\newline        rv = snprintf( tmpstr, 2, &quot[&quot );\newline        assert( rv &lt 2 );\newline      } else {\newline        unsigned int slen;\newline        pname  = scope_gen_printable( expr-&gtname );\newline        slen   = strlen( pname ) + 2;\newline        tmpstr = (char*)malloc_safe( slen );\newline        rv = snprintf( tmpstr, slen, &quot%s[&quot, pname );\newline        assert( rv &lt slen );\newline      }\newline\newline      codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot-:&quot,\newline                           right_code, right_code_depth, expr-&gtright, &quot]&quot );\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( (expr-&gtop == EXP_OP_FUNC_CALL) || (expr-&gtop == EXP_OP_TASK_CALL) ) {\newline\newline      assert( expr-&gtelem.funit != NULL );\newline\newline      tfunit = expr-&gtelem.funit;\newline      after = (char*)malloc_safe( strlen( tfunit-&gtname ) + 1 );\newline      scope_extract_back( tfunit-&gtname, after, user_msg );\newline      pname = scope_gen_printable( after );\newline      if( (expr-&gtop == EXP_OP_TASK_CALL) &amp&amp (expr-&gtleft == NULL) ) {\newline        *code       = (char**)malloc_safe( sizeof( char* ) );\newline        (*code)[0]  = strdup_safe( pname );\newline        *code_depth = 1;\newline      } else {\newline        unsigned int slen;\newline        tmpstr = (char*)malloc_safe( strlen( pname ) + 3 );\newline        slen   = strlen( pname ) + 3;\newline        rv = snprintf( tmpstr, slen, &quot%s( &quot, pname );\newline        assert( rv &lt slen );\newline        codegen_create_expr( code, code_depth, expr-&gtline, tmpstr, left_code, left_code_depth, expr-&gtleft, &quot )&quot, NULL, 0, NULL, NULL );\newline        free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      }\newline      free_safe( after, (strlen( tfunit-&gtname ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_TRIGGER ) {\newline      unsigned int slen;\newline      assert( expr-&gtsig != NULL );\newline      pname  = scope_gen_printable( expr-&gtname );\newline      slen   = strlen( pname ) + 3;\newline      tmpstr = (char*)malloc_safe( slen );\newline      rv = snprintf( tmpstr, slen, &quot-&gt%s&quot, pname );\newline      assert( rv &lt slen );\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( tmpstr );\newline      *code_depth = 1;\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_DISABLE ) {\newline      unsigned int slen;\newline      assert( expr-&gtelem.funit != NULL );\newline      pname  = scope_gen_printable( expr-&gtname );\newline      slen   = strlen( pname ) + 9;\newline      tmpstr = (char*)malloc_safe( slen );\newline      rv = snprintf( tmpstr, slen, &quotdisable %s&quot, pname );\newline      assert( rv &lt slen );\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( tmpstr );\newline      *code_depth = 1;\newline\newline      free_safe( tmpstr, (strlen( tmpstr ) + 1) );\newline      free_safe( pname, (strlen( pname ) + 1) );\newline\newline    } else if( expr-&gtop == EXP_OP_DEFAULT ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotdefault :&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_SLIST ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot@*&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_ALWAYS_COMB ) {\newline \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotalways_comb&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_ALWAYS_LATCH ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quotalways_latch&quot );\newline      *code_depth = 1;\newline\newline    } else if( expr-&gtop == EXP_OP_STIME ) {\newline   \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$time&quot );\newline      *code_depth = 1;\newline\newline    } else if( (expr-&gtop == EXP_OP_SRANDOM) &amp&amp (expr-&gtleft == NULL) ) {\newline\newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$random&quot );\newline      *code_depth = 1;\newline\newline    } else if( (expr-&gtop == EXP_OP_SURANDOM) &amp&amp (expr-&gtleft == NULL) ) {\newline \newline      *code       = (char**)malloc_safe( sizeof( char* ) );\newline      (*code)[0]  = strdup_safe( &quot$urandom&quot );\newline      *code_depth = 1;\newline\newline    } else {\newline\newline      if( expr-&gtsuppl.part.parenthesis ) {\newline        before = strdup_safe( &quot(&quot );\newline        after  = strdup_safe( &quot)&quot );\newline      } else {\newline        before = NULL;\newline        after  = NULL;\newline      }\newline\newline      switch( expr-&gtop ) {\newline        case EXP_OP_XOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ^ &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_XOR_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ^= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MULTIPLY :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot * &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MLT_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot *= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_DIVIDE   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot / &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_DIV_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot /= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MOD      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot % &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_MOD_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot %= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ADD      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot + &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ADD_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot += &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_SUBTRACT :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot - &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_SUB_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot -= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_EXPONENT :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ** &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_AND      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_AND_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_OR       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot | &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_OR_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot |= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~&amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~| &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NXOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot ~^ &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LT       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_GT       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LSHIFT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LS_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ALSHIFT  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt&lt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ALS_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt&lt&lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_RSHIFT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_RS_A     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ARSHIFT  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt&gt &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_ARS_A    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt&gt&gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_EQ       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot == &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_CEQ      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot === &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_GE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &gt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_NE       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot != &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_CNE      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot !== &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot || &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_LAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, before, left_code, left_code_depth, expr-&gtleft, &quot &amp&amp &quot,\newline                               right_code, right_code_depth, expr-&gtright, after );\newline          break;\newline        case EXP_OP_COND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot ? &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_COND_SEL :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot : &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_UINV     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~&quot : &quot~&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UAND     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(&amp&quot : &quot&amp&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNOT     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(!&quot : &quot!&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UOR      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(|&quot : &quot|&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UXOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(^&quot : &quot^&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNAND    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~&amp&quot : &quot~&amp&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNOR     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~|&quot : &quot~|&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_UNXOR    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, (expr-&gtsuppl.part.parenthesis ? &quot(~^&quot : &quot~^&quot), right_code, right_code_depth, expr-&gtright, after,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_EXPAND   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot{&quot, left_code, left_code_depth, expr-&gtleft, &quot{&quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot}}&quot );\newline          break;\newline        case EXP_OP_LIST     :\newline        case EXP_OP_PLIST    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot, &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_CONCAT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot{&quot, right_code, right_code_depth, expr-&gtright, &quot}&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) || \newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(posedge &quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quotposedge &quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_NEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(negedge &quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quotnegedge &quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_AEDGE    :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(&quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                                 NULL, 0, NULL, NULL );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, NULL, right_code, right_code_depth, expr-&gtright, NULL,\newline                                 NULL, 0, NULL, NULL );\newline          }\newline          break;\newline        case EXP_OP_EOR      :\newline          if( (ESUPPL_IS_ROOT( expr-&gtsuppl ) == 1)       ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_RPT_DLY) ||\newline              (expr-&gtparent-&gtexpr-&gtop == EXP_OP_DLY_OP) ) {\newline            codegen_create_expr( code, code_depth, expr-&gtline, &quot@(&quot, left_code, left_code_depth, expr-&gtleft, &quot or &quot,\newline                                 right_code, right_code_depth, expr-&gtright, &quot)&quot );\newline          } else {\newline            codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot or &quot,\newline                                 right_code, right_code_depth, expr-&gtright, NULL );\newline          }\newline          break;\newline        case EXP_OP_CASE     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcase( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_CASEX    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcasex( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_CASEZ    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotcasez( &quot, left_code, left_code_depth, expr-&gtleft, &quot ) &quot,\newline                               right_code, right_code_depth, expr-&gtright, &quot :&quot );\newline          break;\newline        case EXP_OP_DELAY    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot#(&quot, right_code, right_code_depth, expr-&gtright, &quot)&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_ASSIGN   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotassign &quot, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_DASSIGN  :\newline        case EXP_OP_RASSIGN  :\newline        case EXP_OP_BASSIGN  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_NASSIGN  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot &lt= &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_PASSIGN  :\newline        case EXP_OP_SASSIGN  :\newline          *code            = right_code;\newline          *code_depth      = right_code_depth;\newline          right_code_depth = 0;\newline          break;\newline        case EXP_OP_DLY_ASSIGN :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot = &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_DLY_OP   :\newline        case EXP_OP_RPT_DLY  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot &quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_IF       :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotif( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_REPEAT   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotrepeat( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_WHILE    :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotwhile( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_WAIT     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quotwait( &quot, right_code, right_code_depth, expr-&gtright, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_NEGATE   :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot-&quot, right_code, right_code_depth, expr-&gtright, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_IINC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot++&quot, left_code, left_code_depth, expr-&gtleft, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PINC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot++&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_IDEC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot--&quot, left_code, left_code_depth, expr-&gtleft, NULL,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_PDEC     :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot--&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_DIM      :\newline          codegen_create_expr( code, code_depth, expr-&gtline, NULL, left_code, left_code_depth, expr-&gtleft, &quot&quot,\newline                               right_code, right_code_depth, expr-&gtright, NULL );\newline          break;\newline        case EXP_OP_SSIGNED  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$signed( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SUNSIGNED  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$unsigned( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SCLOG2 :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$clog2( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SRANDOM  :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$random( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SURANDOM :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$urandom( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SURAND_RANGE :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$urandom_range( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SSRANDOM :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$srandom( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SB2R :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$bitstoreal( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SR2B :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$realtobits( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SI2R :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$itor( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SR2I :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$rtoi( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SSR2B :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$shortrealtobits( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SB2SR :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$bitstoshortreal( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_STESTARGS :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$test$plusargs( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        case EXP_OP_SVALARGS :\newline          codegen_create_expr( code, code_depth, expr-&gtline, &quot$value$plusargs( &quot, left_code, left_code_depth, expr-&gtleft, &quot )&quot,\newline                               NULL, 0, NULL, NULL );\newline          break;\newline        default:  break;\newline      }\newline\newline      /* Deallocate before and after strings */\newline      free_safe( before, (strlen( before ) + 1) );\newline      free_safe( after, (strlen( after ) + 1) );\newline\newline    }\newline\newline    if( right_code_depth &gt 0 ) {\newline      free_safe( right_code, (sizeof( char* ) * right_code_depth) );\newline    }\newline\newline    if( left_code_depth &gt 0 ) {\newline      free_safe( left_code, (sizeof( char* ) * left_code_depth) );\newline    }\newline\newline  }\newline\newline}\newline","!\newline\\param expr Pointer to root of expression tree to generate.\newline\\param parent_op Operation of parent. If our op is the same, no surrounding parenthesis is needed.\newline\\param code Pointer to array of strings that will contain code lines for the supplied expression.\newline\\param code_depth Pointer to number of strings contained in code array.\newline\\param funit Pointer to functional unit containing the specified expression.\newlineGenerates Verilog code from specified expression tree. This Verilog\newlinesnippet is used by the verbose coverage reporting functions for showing\newlineVerilog examples that were missed during simulation. This code handles multi-line\newlineVerilog output by storing its information into the code and code_depth parameters.\newline \newline","799603","remote.c","static int prune_candidates(git_vector *candidates, git_remote *remote)\newline{\newline	git_strarray arr = { 0 };\newline	size_t i;\newline	int error;\newline\newline	if ((error = git_reference_list(&amparr, remote-&gtrepo)) &lt 0)\newline		return error;\newline\newline	for (i = 0; i &lt arr.count; i++) {\newline		const char *refname = arr.strings[i];\newline		char *refname_dup;\newline\newline		if (!git_remote__matching_dst_refspec(remote, refname))\newline			continue;\newline\newline		refname_dup = git__strdup(refname);\newline		GITERR_CHECK_ALLOC(refname_dup);\newline\newline		if ((error = git_vector_insert(candidates, refname_dup)) &lt 0)\newline			goto out;\newline	}\newline\newlineout:\newline	git_strarray_free(&amparr);\newline	return error;\newline}\newline","\newline Generate a list of candidates for pruning by getting a list of\newline references which match the rhs of an active refspec.\newline \newline","6200304","rmimage.c","void rm_trace_creation(Image *image)\newline{\newline    call_trace_proc(image, &quotc&quot);\newline}\newline","\newline Trace image creation\newline \newline No Ruby usage (internal function)\newline \newline @param image the image\newline @see call_trace_proc\newline \newline","6514205","key_management.c","int ecryptfs_unwrap_passphrase(char *decrypted_passphrase, char *filename,\newline			       char *wrapping_passphrase, char *wrapping_salt)\newline{\newline	char v2_wrapping_salt[ECRYPTFS_SALT_SIZE];\newline	char wrapping_auth_tok_sig[ECRYPTFS_SIG_SIZE_HEX + 1];\newline	char wrapping_auth_tok_sig_from_file[ECRYPTFS_SIG_SIZE_HEX + 1];\newline	char wrapping_key[ECRYPTFS_MAX_KEY_BYTES];\newline	char encrypted_passphrase[ECRYPTFS_MAX_PASSPHRASE_BYTES + 1];\newline	int encrypted_passphrase_pos = 0;\newline	int decrypted_passphrase_pos = 0;\newline	int tmp1_outlen = 0;\newline	int tmp2_outlen = 0;\newline	SECStatus err;\newline	SECItem key_item;\newline	PK11SymKey *sym_key = NULL;\newline	PK11SlotInfo *slot = NULL;\newline	PK11Context *enc_ctx = NULL;\newline	SECItem *sec_param = NULL;\newline	uint8_t version = 0;\newline	int encrypted_passphrase_bytes;\newline	int rc;\newline\newline	memset(wrapping_auth_tok_sig_from_file, 0,\newline	       sizeof(wrapping_auth_tok_sig_from_file));\newline	memset(encrypted_passphrase, 0, sizeof(encrypted_passphrase));\newline\newline	rc = __ecryptfs_detect_wrapped_passphrase_file_version(filename,\newline							       &ampversion);\newline	if (rc) {\newline		syslog(LOG_ERR,\newline		       &quotFailed to detect wrapped passphrase version: %s\\n&quot,\newline		       strerror(-rc));\newline		goto out;\newline	}\newline\newline	if (version == 1) {\newline		rc = read_v1_wrapped_passphrase_file(filename,\newline						wrapping_auth_tok_sig_from_file,\newline						encrypted_passphrase,\newline						&ampencrypted_passphrase_bytes);\newline		if (rc)\newline			goto out;\newline	} else if (version == 2) {\newline		rc = read_v2_wrapped_passphrase_file(filename,\newline						v2_wrapping_salt,\newline						wrapping_auth_tok_sig_from_file,\newline						encrypted_passphrase,\newline						&ampencrypted_passphrase_bytes);\newline		if (rc)\newline			goto out;\newline\newline		/**\newline		 * Version 2 wrapped passphrase self-contains the wrapping salt.\newline		 * The passed in @wrapping_salt buffer is ignored and the\newline		 * parsed wrapping salt is used instead.\newline		 */\newline		wrapping_salt = v2_wrapping_salt;\newline	} else {\newline		syslog(LOG_ERR,\newline		       &quotUnsupported wrapped passphrase file version: %u\\n&quot,\newline		       version);\newline		rc = -ENOTSUP;\newline		goto out;\newline	}\newline\newline	rc = generate_passphrase_sig(wrapping_auth_tok_sig, wrapping_key,\newline				     wrapping_salt, wrapping_passphrase);\newline	if (rc) {\newline		syslog(LOG_ERR, &quotError generating passphrase signature; &quot\newline		       &quotrc = [%d]\\n&quot, rc);\newline		rc = (rc &lt 0) ? rc : rc * -1;\newline		goto out;\newline	}\newline\newline	if (memcmp(wrapping_auth_tok_sig_from_file, wrapping_auth_tok_sig,\newline		   ECRYPTFS_SIG_SIZE_HEX) != 0) {\newline		syslog(LOG_ERR, &quotIncorrect wrapping key for file [%s]\\n&quot,\newline		       filename);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	NSS_NoDB_Init(NULL);\newline	slot = PK11_GetBestSlot(CKM_AES_ECB, NULL);\newline	key_item.data = (unsigned char *)wrapping_key;\newline	key_item.len = ECRYPTFS_AES_KEY_BYTES;\newline	sym_key = PK11_ImportSymKey(slot, CKM_AES_ECB, PK11_OriginUnwrap,\newline				    CKA_ENCRYPT, &ampkey_item, NULL);\newline	if (!sym_key) {\newline		syslog(LOG_ERR, &quot%s: PK11_ImportSymKey() returned NULL\\n&quot,\newline		       __FUNCTION__);\newline		rc = -EIO;\newline		goto out;\newline	}\newline	sec_param = PK11_ParamFromIV(CKM_AES_ECB, NULL);\newline	enc_ctx = PK11_CreateContextBySymKey(CKM_AES_ECB, CKA_DECRYPT,\newline					     sym_key, sec_param);\newline	memset(decrypted_passphrase, 0, ECRYPTFS_MAX_PASSPHRASE_BYTES + 1);\newline	err = PK11_CipherOp(\newline		enc_ctx, (unsigned char *) decrypted_passphrase,\newline		&amptmp1_outlen, ECRYPTFS_MAX_PASSPHRASE_BYTES,\newline		(unsigned char *) encrypted_passphrase,\newline		encrypted_passphrase_bytes);//ECRYPTFS_MAX_PASSPHRASE_BYTES);\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11_CipherOp() error; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline		goto nss_finish;\newline	}\newline	err = PK11_DigestFinal(\newline		enc_ctx, \newline		(unsigned char *) decrypted_passphrase + tmp1_outlen,\newline		(unsigned int *) &amptmp2_outlen,\newline		(ECRYPTFS_MAX_PASSPHRASE_BYTES - tmp1_outlen));\newline	if (err == SECFailure) {\newline		syslog(LOG_ERR, &quot%s: PK11 error on digest final; &quot\newline			&quotSECFailure = [%d]; PORT_GetError() = [%d]\\n&quot,\newline			__FUNCTION__, SECFailure, PORT_GetError());\newline		rc = - EIO;\newline	}\newline\newlinenss_finish:\newline	if (enc_ctx)\newline		PK11_DestroyContext(enc_ctx, PR_TRUE);\newline	if (sym_key)\newline		PK11_FreeSymKey(sym_key);\newline	if (sec_param)\newline		SECITEM_FreeItem(sec_param, PR_TRUE);\newline	if (slot)\newline		PK11_FreeSlot(slot);\newline	if (rc)\newline		goto out;\newline	encrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	decrypted_passphrase_pos += tmp1_outlen + tmp2_outlen;\newline	encrypted_passphrase_bytes -= tmp1_outlen + tmp2_outlen;\newline	if (encrypted_passphrase_bytes != 0) {\newline		syslog(LOG_ERR, &quotWrong size of unwrapped passphrase\\n&quot);\newline		rc = - EIO;\newline		goto out;\newline	}\newlineout:\newline	return rc;\newline}\newline","\newline decryptfs_passphrase must be able to hold\newline ECRYPTFS_MAX_PASSPHRASE_BYTES + 1 bytes\newline \newline","3405932","bluetooth_piconet.c","static int init_candidates(char channel, int known_clock_bits, btbb_piconet *pn)\newline{\newline	int i;\newline	int count = 0; /* total number of candidates */\newline	char observable_channel; /* accounts for aliasing if necessary */\newline\newline	/* only try clock values that match our known bits */\newline	for (i = known_clock_bits; i &lt SEQUENCE_LENGTH; i += 0x40) {\newline		if (pn-&gtaliased)\newline			observable_channel = aliased_channel(pn-&gtsequence[i]);\newline		else\newline			observable_channel = pn-&gtsequence[i];\newline		if (observable_channel == channel)\newline			pn-&gtclock_candidates[count++] = i;\newline		//FIXME ought to throw exception if count gets too big\newline	}\newline	return count;\newline}\newline","create list of initial candidate clock values (hops with same channel as first observed hop) \newline","6482662","rtp.c","void rtp_send_ctrl(struct rtp *session, uint32_t rtp_ts, rtcp_app_callback appcallback)\newline{\newline	/* Send an RTCP packet, if one is due... */\newline	struct timeval	 curr_time;\newline\newline	check_database(session);\newline	gettimeofday(&ampcurr_time, NULL);\newline	if (tv_gt(curr_time, session-&gtnext_rtcp_send_time)) {\newline		/* The RTCP transmission timer has expired. The following */\newline		/* implements draft-ietf-avt-rtp-new-02.txt section 6.3.6 */\newline		int		 h;\newline		source		*s;\newline		struct timeval	 new_send_time;\newline		double		 new_interval;\newline\newline		new_interval  = rtcp_interval(session) / (session-&gtcsrc_count + 1);\newline		new_send_time = session-&gtlast_rtcp_send_time;\newline		tv_add(&ampnew_send_time, new_interval);\newline		if (tv_gt(curr_time, new_send_time)) {\newline			send_rtcp(session, rtp_ts, appcallback);\newline			session-&gtinitial_rtcp        = FALSE;\newline			session-&gtlast_rtcp_send_time = curr_time;\newline			session-&gtnext_rtcp_send_time = curr_time; \newline			tv_add(&amp(session-&gtnext_rtcp_send_time), rtcp_interval(session) / (session-&gtcsrc_count + 1));\newline			/* We&#039re starting a new RTCP reporting interval, zero out */\newline			/* the per-interval statistics.                           */\newline			session-&gtsender_count = 0;\newline			for (h = 0; h &lt RTP_DB_SIZE; h++) {\newline				for (s = session-&gtdb[h]; s != NULL; s = s-&gtnext) {\newline					check_source(s);\newline					s-&gtsender = FALSE;\newline				}\newline			}\newline		} else {\newline			session-&gtnext_rtcp_send_time = new_send_time;\newline		}\newline		session-&gtssrc_count_prev = session-&gtssrc_count;\newline	} \newline	check_database(session);\newline}\newline","\newline rtp_send_ctrl:\newline @session: the session pointer (returned by rtp_init())\newline @rtp_ts: the current time expressed in units of the media timestamp.\newline @appcallback: a callback to create an APP RTCP packet, if needed.\newline \newline Checks RTCP timer and sends RTCP data when nececessary. The\newline interval between RTCP packets is randomized over an interval that\newline depends on the session bandwidth, the number of participants, and\newline whether the local participant is a sender. This function should be\newline called at least once per second, and can be safely called more\newline frequently. \newline \newline","3006459","knockd.c","void generate_pcap_filter()\newline{\newline	PMList *lp;\newline	opendoor_t *door;\newline	char *buffer = NULL;   /* temporary buffer to create the individual filter strings */ \newline	size_t bufsize = 0;    /* size of buffer */\newline	char port_str[10];     /* used by snprintf to convert unsigned short --&gt string */\newline	short head_set = 0;	   /* flag indicating if protocol head is set (i.e. &quot((tcp dst port&quot) */\newline	short tcp_present = 0; /* flag indicating if TCP is used */\newline	short udp_present = 0; /* flag indicating if UDP is used */\newline	unsigned int i;\newline	short modified_filters = 0;  /* flag indicating if at least one filter has changed --&gt recompile the filter */\newline	struct bpf_program bpf_prog; /* compiled BPF filter program */\newline\newline	/* generate subfilters for each door having a NULL pcap_filter_exp\newline	 *\newline	 * Example filter for one single door:\newline	 * ((tcp dst port 8000 or 8001 or 8002) and tcp[tcpflags] &amp tcp-syn != 0) or (udp dst port 4000 or 4001)\newline	 */\newline	for(lp = doors; lp; lp = lp-&gtnext) {\newline		door = (opendoor_t*)lp-&gtdata;\newline\newline		if(door-&gtpcap_filter_exp != NULL) {\newline			continue;\newline		}\newline\newline		/* if we get here at least one door had a pcap_filter_exp == NULL */\newline		modified_filters = 1;\newline\newline		head_set = 0;\newline		tcp_present = 0;\newline		udp_present = 0;\newline\newline		/* allocate memory for buffer if needed.\newline		 * The first allocation will be 200 Bytes (should be large enough for common sequences). If there is\newline		 * not enough space, a call to realloc_strcat() will eventually increase its size. The buffer will be\newline		 * reused for successive doors */\newline		if(buffer == NULL) {\newline			bufsize = 200;\newline			buffer = (char*)malloc(sizeof(char) * bufsize);\newline			if(buffer == NULL) {\newline				perror(&quotmalloc&quot);\newline				cleanup(1);\newline			}\newline			buffer[0] = &#039\\0&#039;\newline		}\newline\newline		bufsize = realloc_strcat(&ampbuffer, &quot(dst host &quot, bufsize);	/* accept only incoming packets */\newline		bufsize = realloc_strcat(&ampbuffer, door-&gttarget ? door-&gttarget : myip, bufsize);\newline		bufsize = realloc_strcat(&ampbuffer, &quot and (&quot, bufsize);\newline\newline		/* generate filter for all TCP ports (i.e. &quot((tcp dst port 4000 or 4001 or 4002) and tcp[tcpflags] &amp tcp-syn != 0)&quot */\newline		for(i = 0; i &lt door-&gtseqcount; i++) {\newline			if(door-&gtprotocol[i] == IPPROTO_TCP) {\newline				if(!head_set) {		/* first TCP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot((tcp dst port &quot, bufsize);\newline					head_set = 1;\newline					tcp_present = 1;\newline				} else {		/* not the first TCP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline				}\newline				snprintf(port_str, sizeof(port_str), &quot%hu&quot, door-&gtsequence[i]);		/* unsigned short to string */\newline				bufsize = realloc_strcat(&ampbuffer, port_str, bufsize);			/* append port number */\newline			}\newline		}\newline		if(tcp_present) {\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of TCP ports */\newline		}\newline\newline		/* append the TCP flag filters */\newline		if(tcp_present) {\newline			if(door-&gtflag_fin != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-fin &quot, bufsize);\newline				if(door-&gtflag_fin == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_fin == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_syn != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-syn &quot, bufsize);\newline				if(door-&gtflag_syn == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_syn == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_rst != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-rst &quot, bufsize);\newline				if(door-&gtflag_rst == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_rst == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_psh != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-psh &quot, bufsize);\newline				if(door-&gtflag_psh == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_psh == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_ack != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-ack &quot, bufsize);\newline				if(door-&gtflag_ack == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_ack == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			if(door-&gtflag_urg != DONT_CARE) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot and tcp[tcpflags] &amp tcp-urg &quot, bufsize);\newline				if(door-&gtflag_urg == SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot!= 0&quot, bufsize);\newline				}\newline				if(door-&gtflag_urg == NOT_SET) {\newline					bufsize = realloc_strcat(&ampbuffer, &quot== 0&quot, bufsize);\newline				}\newline			}\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of flags */\newline		}\newline\newline		/* append filter for all UDP ports (i.e. &quot(udp dst port 6543 or 6544 or 6545)&quot */\newline		head_set = 0;\newline		for(i = 0; i &lt door-&gtseqcount; i++) {\newline			if(door-&gtprotocol[i] == IPPROTO_UDP) {\newline				if(!head_set) {		/* first UDP port in the sequence */\newline					if(tcp_present) {\newline						bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline					}\newline					bufsize = realloc_strcat(&ampbuffer, &quot(udp dst port &quot, bufsize);\newline					head_set = 1;\newline					udp_present = 1;\newline				} else {		/* not the first UDP port in the sequence */\newline					bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline				}\newline				snprintf(port_str, sizeof(port_str), &quot%hu&quot, door-&gtsequence[i]);		/* unsigned short to string */\newline				bufsize = realloc_strcat(&ampbuffer, port_str, bufsize);			/* append port number */\newline			}\newline		}\newline		if(udp_present) {\newline			bufsize = realloc_strcat(&ampbuffer, &quot)&quot, bufsize);		/* close parentheses of UDP ports */\newline		}\newline\newline		bufsize = realloc_strcat(&ampbuffer, &quot))&quot, bufsize);		/* close parantheses around port filters */\newline\newline		/* test if in any of the precedent calls to realloc_strcat() failed. We can do this safely here because\newline		 * realloc_strcat() returns 0 on failure and if a buffer size of 0 is passed to it, the function does\newline		 * nothing but returning 0 again. Because we never read buffer in the above code, it is secure to test\newline		 * for failure only at this point (it makes the code more readable than checking for failure each time\newline		 * realloc_strcat() is called). */\newline		if(bufsize == 0) {\newline			perror(&quotrealloc&quot);\newline			cleanup(1);\newline		}\newline\newline		/* allocate the buffer in door holding the filter string, copy it and prepare buffer for being reused. */\newline		door-&gtpcap_filter_exp = (char*)malloc(strlen(buffer) + 1);\newline		if(door-&gtpcap_filter_exp == NULL) {\newline			perror(&quotmalloc&quot);\newline			cleanup(1);\newline		}\newline		strcpy(door-&gtpcap_filter_exp, buffer);\newline		dprint(&quotAdding pcap expression for door &#039%s&#039: %s\\n&quot, door-&gtname, door-&gtpcap_filter_exp);\newline		buffer[0] = &#039\\0&#039;	/* &quotclear&quot the buffer */\newline	}\newline\newline\newline	/* generate the whole pcap filter string if a filter had been modified. Reuse buffer (already &quotcleared&quot).\newline	 *\newline	 * Note that we don&#039t check if a port is included in multiple doors, we simply concatenate the individual door\newline	 * filters and rely on pcap&#039s optimization capabilities.\newline	 *\newline	 * Example filter for two doors with sequences 8000:tcp,4000:udp,8001:tcp,4001:udp,8002:tcp (syn) and \newline	 * 1234:tcp,4567:tcp,8901:tcp (syn,ack) :\newline	 * dst host the.hosts.ip.address and (\newline	 *      ((tcp dst port 8000 or 8001 or 8002) and tcp[tcpflags] &amp tcp-syn != 0) or (udp dst port 4000 or 4001)\newline	 *   or ((tcp dst port 1234 or 4567 or 8901) and tcp[tcpflags] &amp tcp-syn != 0 and tcp[tcpflags] &amp tcp-ack != 0)\newline	 * )\newline	 */\newline	if(modified_filters) {\newline		/* iterate over all doors */\newline		for(lp = doors; lp; lp = lp-&gtnext) {\newline			door = (opendoor_t*)lp-&gtdata;\newline			bufsize = realloc_strcat(&ampbuffer, door-&gtpcap_filter_exp, bufsize);\newline			if(lp-&gtnext != NULL) {\newline				bufsize = realloc_strcat(&ampbuffer, &quot or &quot, bufsize);\newline			}\newline		}\newline\newline		/* test if in any of the precedent calls to realloc_strcat() failed. See above why this is ok to do this only\newline		 * at this point */\newline		if(bufsize == 0) {\newline			perror(&quotrealloc&quot);\newline			cleanup(1);\newline		}\newline\newline		if(pcap_compile(cap, &ampbpf_prog, buffer, 1, 0) &lt 0) {	/* optimize filter (1), no netmask (0) (we&#039re not interested in broadcasts) */\newline			pcap_perror(cap, &quotpcap&quot);\newline			cleanup(1);\newline		}\newline		if(pcap_setfilter(cap, &ampbpf_prog) &lt 0) {\newline			pcap_perror(cap, &quotpcap&quot);\newline			cleanup(1);\newline		}\newline		pcap_freecode(&ampbpf_prog);\newline		free(buffer);\newline	}\newline}\newline","Generate and set the filter for pcap. That way only the relevant packets will\newline be forwarded to us (in sniff()). Note that generate_pcap_filter() will first\newline generate a subfilter (=substring of the whole filter string) for each door if\newline door-&gtpcap_filter_exp is NULL. This behaviour can be used for doors with one\newline time sequences, where the subfilter has to be generated after each sequence.\newline \newline","3829689","wxlist.cpp","void CBaseList::RemoveAll()\newline{\newline    /* Free up all the CNode objects NOTE we don&#039t bother putting the\newline       deleted nodes into the cache as this method is only really called\newline       in serious times of change such as when we are being deleted at\newline       which point the cache will be deleted anway */\newline\newline    CNode *pn = m_pFirst;\newline    while (pn) {\newline        CNode *op = pn;\newline        pn = pn-&gtNext();\newline        delete op;\newline    }\newline\newline    /* Reset the object count and the list pointers */\newline\newline    m_Count = 0;\newline    m_pFirst = m_pLast = NULL;\newline\newline} // RemoveAll\newline","Remove all the nodes from the list but don&#039t do anything\newlinewith the objects that each node looks after (this is the\newlineresponsibility of the creator).\newlineAa a last act we reset the signalling event\newline(if available) to indicate to clients that the list\newlinedoes not have any entries in it.\newline \newline","5173190","randm.c","void avRandomInit()\newline{\newline    avChurnRand(NULL, 0);\newline}\newline","\newline Initialize the random number generator.\newline \newline Since this is to be called on power up, we don&#039t have much\newline system randomess to work with. Here all we use is the\newline real-time clock. We&#039ll accumulate more randomness as soon\newline as things start happening.\newline \newline","3785490","state.c","int init_builtin(f_state *s, int type, char *suffix, char *header, char *footer, int header_len,\newline				 int footer_len, u_int64_t max_len, int case_sen)\newline{\newline\newline	int i = s-&gtnum_builtin;\newline\newline	search_spec[i].type = type;\newline	search_spec[i].suffix = (char *)malloc((strlen(suffix)+1) * sizeof(char));\newline	search_spec[i].num_markers = 0;\newline	strcpy(search_spec[i].suffix, suffix);\newline\newline	search_spec[i].header_len = header_len;\newline	search_spec[i].footer_len = footer_len;\newline\newline	search_spec[i].max_len = max_len;\newline	search_spec[i].found = 0;\newline	search_spec[i].header = (unsigned char *)malloc(search_spec[i].header_len * sizeof(unsigned char));\newline	search_spec[i].footer = (unsigned char *)malloc(search_spec[i].footer_len * sizeof(unsigned char));\newline	search_spec[i].case_sen = case_sen;\newline	memset(search_spec[i].comment, 0, COMMENT_LENGTH - 1);\newline\newline	memcpy(search_spec[i].header, header, search_spec[i].header_len);\newline	memcpy(search_spec[i].footer, footer, search_spec[i].footer_len);\newline\newline	init_bm_table(search_spec[i].header,\newline				  search_spec[i].header_bm_table,\newline				  search_spec[i].header_len,\newline				  search_spec[i].case_sen,\newline				  SEARCHTYPE_FORWARD);\newline	init_bm_table(search_spec[i].footer,\newline				  search_spec[i].footer_bm_table,\newline				  search_spec[i].footer_len,\newline				  search_spec[i].case_sen,\newline				  SEARCHTYPE_FORWARD);\newline	s-&gtnum_builtin++;\newline\newline	return i;\newline}\newline","Initialize any search specs \newline","5142364","gaio.c","gaint gaclosenc (struct gafile *pfi) {\newline#if USENETCDF==1\newline  gaint rc;\newline  gaint oldncopts ;     \newline  oldncopts = ncopts ;\newline  ncopts = 0;\newline  if (pfi-&gtncid != -999) {\newline    rc = nc_close(pfi-&gtncid);\newline    if (rc != NC_NOERR) {\newline      gaprnt(0,&quotError: nc_close failed\\n&quot);\newline      snprintf(pout,255,&quot%s\\n&quot,nc_strerror(rc));\newline      gaprnt(0,pout);\newline      return (1);\newline    }\newline    pfi-&gtncid = -999;\newline  }\newline  ncopts = oldncopts ;\newline#endif\newline  return (0);\newline}\newline","close a netCDF file, reset ncid in gafile structure \newline","5071342","hashcomp.h","inline std::string operator+(std::string &ampleftval, ci::string &amprightval)\newline{\newline	return leftval + std::string(rightval.c_str());\newline}\newline","Define operators for + and == with ci::string to std::string for easy assignment\newline and comparison\newline \newline Operator +\newline \newline","","","on","","on","","","","","on","","","on","on","on","","","","","","","on","on","","on","","on","on","","on","","on","on","","","","on","on","","on","on","on","Nickname characters","Generates Verilog code from specified expression tree.","{}","@see call_trace_proc","{}","create list of initial candidate clock values","This function should becalled at least once per second,","This behaviour can be used for doors with onetime sequences,","objects that each node looks","{}","Initialize any search specs","Generally outputs are placed in the output vector, ssGetY(S).","{}","{}","{}","Function uses values of cwdaemon's global 'default_' variables, and someother values","Change the angle of the eyes in the stereo output.","quota root","Generate a chained list of re_filterfile_spec's fromthe ""FILTER:","Parse RAW sequence","dispose of memory space used by the elementpointed to by element_ptr."